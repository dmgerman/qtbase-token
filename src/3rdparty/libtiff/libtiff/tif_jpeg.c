begin_unit
begin_comment
comment|/* $Id: tif_jpeg.c,v 1.50.2.4 2009-08-30 16:21:46 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1994-1997 Sam Leffler  * Copyright (c) 1994-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_define
DECL|macro|WIN32_LEAN_AND_MEAN
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define
begin_define
DECL|macro|VC_EXTRALEAN
define|#
directive|define
name|VC_EXTRALEAN
end_define
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|JPEG_SUPPORT
end_ifdef
begin_comment
comment|/*  * TIFF Library  *  * JPEG Compression support per TIFF Technical Note #2  * (*not* per the original TIFF 6.0 spec).  *  * This file is simply an interface to the libjpeg library written by  * the Independent JPEG Group.  You need release 5 or later of the IJG  * code, which you can find on the Internet at ftp.uu.net:/graphics/jpeg/.  *  * Contributed by Tom Lane<tgl@sss.pgh.pa.us>.  */
end_comment
begin_include
include|#
directive|include
file|<setjmp.h>
end_include
begin_function_decl
name|int
name|TIFFFillStrip
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tstrip_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|TIFFFillTile
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|ttile_t
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* We undefine FAR to avoid conflict with JPEG definition */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FAR
end_ifdef
begin_undef
DECL|macro|FAR
undef|#
directive|undef
name|FAR
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Libjpeg's jmorecfg.h defines INT16 and INT32, but only if XMD_H is   not defined.  Unfortunately, the MinGW and Borland compilers include   a typedef for INT32, which causes a conflict.  MSVC does not include   a conficting typedef given the headers which are included. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if
begin_define
DECL|macro|XMD_H
define|#
directive|define
name|XMD_H
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    The windows RPCNDR.H file defines boolean, but defines it with the    unsigned char size.  You should compile JPEG library using appropriate    definitions in jconfig.h header, but many users compile library in wrong    way. That causes errors of the following type:     "JPEGLib: JPEG parameter struct mismatch: library thinks size is 432,    caller expects 464"     For such users we wil fix the problem here. See install.doc file from    the JPEG library distribution for details. */
end_comment
begin_comment
comment|/* Define "boolean" as unsigned char, not int, per Windows custom. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|__RPCNDR_H__
end_ifndef
begin_comment
comment|/* don't conflict if rpcndr.h already read */
end_comment
begin_typedef
DECL|typedef|boolean
typedef|typedef
name|unsigned
name|char
name|boolean
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|HAVE_BOOLEAN
define|#
directive|define
name|HAVE_BOOLEAN
end_define
begin_comment
DECL|macro|HAVE_BOOLEAN
comment|/* prevent jmorecfg.h from redefining it */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jerror.h"
end_include
begin_comment
comment|/*  * We are using width_in_blocks which is supposed to be private to  * libjpeg. Unfortunately, the libjpeg delivered with Cygwin has  * renamed this member to width_in_data_units.  Since the header has  * also renamed a define, use that unique define name in order to  * detect the problem header and adjust to suit.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|D_MAX_DATA_UNITS_IN_MCU
argument_list|)
end_if
begin_define
DECL|macro|width_in_blocks
define|#
directive|define
name|width_in_blocks
value|width_in_data_units
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * On some machines it may be worthwhile to use _setjmp or sigsetjmp  * in place of plain setjmp.  These macros will make it easier.  */
end_comment
begin_define
DECL|macro|SETJMP
define|#
directive|define
name|SETJMP
parameter_list|(
name|jbuf
parameter_list|)
value|setjmp(jbuf)
end_define
begin_define
DECL|macro|LONGJMP
define|#
directive|define
name|LONGJMP
parameter_list|(
name|jbuf
parameter_list|,
name|code
parameter_list|)
value|longjmp(jbuf,code)
end_define
begin_define
DECL|macro|JMP_BUF
define|#
directive|define
name|JMP_BUF
value|jmp_buf
end_define
begin_typedef
DECL|typedef|jpeg_destination_mgr
typedef|typedef
name|struct
name|jpeg_destination_mgr
name|jpeg_destination_mgr
typedef|;
end_typedef
begin_typedef
DECL|typedef|jpeg_source_mgr
typedef|typedef
name|struct
name|jpeg_source_mgr
name|jpeg_source_mgr
typedef|;
end_typedef
begin_typedef
DECL|typedef|jpeg_error_mgr
typedef|typedef
name|struct
name|jpeg_error_mgr
name|jpeg_error_mgr
typedef|;
end_typedef
begin_comment
comment|/*  * State block for each open TIFF file using  * libjpeg to do JPEG compression/decompression.  *  * libjpeg's visible state is either a jpeg_compress_struct  * or jpeg_decompress_struct depending on which way we  * are going.  comm can be used to refer to the fields  * which are common to both.  *  * NB: cinfo is required to be the first member of JPEGState,  *     so we can safely cast JPEGState* -> jpeg_xxx_struct*  *     and vice versa!  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
DECL|member|c
name|struct
name|jpeg_compress_struct
name|c
decl_stmt|;
DECL|member|d
name|struct
name|jpeg_decompress_struct
name|d
decl_stmt|;
DECL|member|comm
name|struct
name|jpeg_common_struct
name|comm
decl_stmt|;
block|}
DECL|member|cinfo
name|cinfo
union|;
comment|/* NB: must be first */
DECL|member|cinfo_initialized
name|int
name|cinfo_initialized
decl_stmt|;
DECL|member|err
name|jpeg_error_mgr
name|err
decl_stmt|;
comment|/* libjpeg error manager */
DECL|member|exit_jmpbuf
name|JMP_BUF
name|exit_jmpbuf
decl_stmt|;
comment|/* for catching libjpeg failures */
comment|/* 	 * The following two members could be a union, but 	 * they're small enough that it's not worth the effort. 	 */
DECL|member|dest
name|jpeg_destination_mgr
name|dest
decl_stmt|;
comment|/* data dest for compression */
DECL|member|src
name|jpeg_source_mgr
name|src
decl_stmt|;
comment|/* data source for decompression */
comment|/* private state */
DECL|member|tif
name|TIFF
modifier|*
name|tif
decl_stmt|;
comment|/* back link needed by some code */
DECL|member|photometric
name|uint16
name|photometric
decl_stmt|;
comment|/* copy of PhotometricInterpretation */
DECL|member|h_sampling
name|uint16
name|h_sampling
decl_stmt|;
comment|/* luminance sampling factors */
DECL|member|v_sampling
name|uint16
name|v_sampling
decl_stmt|;
DECL|member|bytesperline
name|tsize_t
name|bytesperline
decl_stmt|;
comment|/* decompressed bytes per scanline */
comment|/* pointers to intermediate buffers when processing downsampled data */
DECL|member|ds_buffer
name|JSAMPARRAY
name|ds_buffer
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|scancount
name|int
name|scancount
decl_stmt|;
comment|/* number of "scanlines" accumulated */
DECL|member|samplesperclump
name|int
name|samplesperclump
decl_stmt|;
DECL|member|vgetparent
name|TIFFVGetMethod
name|vgetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|vsetparent
name|TIFFVSetMethod
name|vsetparent
decl_stmt|;
comment|/* super-class method */
DECL|member|printdir
name|TIFFPrintMethod
name|printdir
decl_stmt|;
comment|/* super-class method */
DECL|member|defsparent
name|TIFFStripMethod
name|defsparent
decl_stmt|;
comment|/* super-class method */
DECL|member|deftparent
name|TIFFTileMethod
name|deftparent
decl_stmt|;
comment|/* super-class method */
comment|/* pseudo-tag fields */
DECL|member|jpegtables
name|void
modifier|*
name|jpegtables
decl_stmt|;
comment|/* JPEGTables tag value, or NULL */
DECL|member|jpegtables_length
name|uint32
name|jpegtables_length
decl_stmt|;
comment|/* number of bytes in same */
DECL|member|jpegquality
name|int
name|jpegquality
decl_stmt|;
comment|/* Compression quality level */
DECL|member|jpegcolormode
name|int
name|jpegcolormode
decl_stmt|;
comment|/* Auto RGB<=>YCbCr convert? */
DECL|member|jpegtablesmode
name|int
name|jpegtablesmode
decl_stmt|;
comment|/* What to put in JPEGTables */
DECL|member|ycbcrsampling_fetched
name|int
name|ycbcrsampling_fetched
decl_stmt|;
DECL|member|recvparams
name|uint32
name|recvparams
decl_stmt|;
comment|/* encoded Class 2 session params */
DECL|member|subaddress
name|char
modifier|*
name|subaddress
decl_stmt|;
comment|/* subaddress string */
DECL|member|recvtime
name|uint32
name|recvtime
decl_stmt|;
comment|/* time spent receiving (secs) */
DECL|member|faxdcs
name|char
modifier|*
name|faxdcs
decl_stmt|;
comment|/* encoded fax parameters (DCS, Table 2/T.30) */
block|}
DECL|typedef|JPEGState
name|JPEGState
typedef|;
end_typedef
begin_define
DECL|macro|JState
define|#
directive|define
name|JState
parameter_list|(
name|tif
parameter_list|)
value|((JPEGState*)(tif)->tif_data)
end_define
begin_function_decl
specifier|static
name|int
name|JPEGDecode
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|JPEGDecodeRaw
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|JPEGEncode
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|JPEGEncodeRaw
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|JPEGInitializeLibJPEG
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|force_encode
parameter_list|,
name|int
name|force_decode
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|FIELD_JPEGTABLES
define|#
directive|define
name|FIELD_JPEGTABLES
value|(FIELD_CODEC+0)
end_define
begin_define
DECL|macro|FIELD_RECVPARAMS
define|#
directive|define
name|FIELD_RECVPARAMS
value|(FIELD_CODEC+1)
end_define
begin_define
DECL|macro|FIELD_SUBADDRESS
define|#
directive|define
name|FIELD_SUBADDRESS
value|(FIELD_CODEC+2)
end_define
begin_define
DECL|macro|FIELD_RECVTIME
define|#
directive|define
name|FIELD_RECVTIME
value|(FIELD_CODEC+3)
end_define
begin_define
DECL|macro|FIELD_FAXDCS
define|#
directive|define
name|FIELD_FAXDCS
value|(FIELD_CODEC+4)
end_define
begin_decl_stmt
DECL|variable|jpegFieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|jpegFieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_JPEGTABLES
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
name|TIFF_UNDEFINED
block|,
name|FIELD_JPEGTABLES
block|,
name|FALSE
block|,
name|TRUE
block|,
literal|"JPEGTables"
block|}
block|,
block|{
name|TIFFTAG_JPEGQUALITY
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|""
block|}
block|,
block|{
name|TIFFTAG_JPEGCOLORMODE
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|""
block|}
block|,
block|{
name|TIFFTAG_JPEGTABLESMODE
block|,
literal|0
block|,
literal|0
block|,
name|TIFF_ANY
block|,
name|FIELD_PSEUDO
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|""
block|}
block|,
comment|/* Specific for JPEG in faxes */
block|{
name|TIFFTAG_FAXRECVPARAMS
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_RECVPARAMS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxRecvParams"
block|}
block|,
block|{
name|TIFFTAG_FAXSUBADDRESS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TIFF_ASCII
block|,
name|FIELD_SUBADDRESS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxSubAddress"
block|}
block|,
block|{
name|TIFFTAG_FAXRECVTIME
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_LONG
block|,
name|FIELD_RECVTIME
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxRecvTime"
block|}
block|,
block|{
name|TIFFTAG_FAXDCS
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|TIFF_ASCII
block|,
name|FIELD_FAXDCS
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"FaxDcs"
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|N
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a[0]))
end_define
begin_comment
comment|/*  * libjpeg interface layer.  *  * We use setjmp/longjmp to return control to libtiff  * when a fatal error is encountered within the JPEG  * library.  We also direct libjpeg error and warning  * messages through the appropriate libtiff handlers.  */
end_comment
begin_comment
comment|/*  * Error handling routines (these replace corresponding  * IJG routines from jerror.c).  These are used for both  * compression and decompression.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|TIFFjpeg_error_exit
name|TIFFjpeg_error_exit
parameter_list|(
name|j_common_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
comment|/* NB: cinfo assumed first */
name|char
name|buffer
index|[
name|JMSG_LENGTH_MAX
index|]
decl_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|format_message
call|)
argument_list|(
name|cinfo
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|TIFFErrorExt
argument_list|(
name|sp
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"JPEGLib"
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* display the error message */
name|jpeg_abort
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* clean up libjpeg state */
name|LONGJMP
argument_list|(
name|sp
operator|->
name|exit_jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* return to libtiff caller */
block|}
end_function
begin_comment
comment|/*  * This routine is invoked only for warning messages,  * since error_exit does its own thing and trace_level  * is never set> 0.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|TIFFjpeg_output_message
name|TIFFjpeg_output_message
parameter_list|(
name|j_common_ptr
name|cinfo
parameter_list|)
block|{
name|char
name|buffer
index|[
name|JMSG_LENGTH_MAX
index|]
decl_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|format_message
call|)
argument_list|(
name|cinfo
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|TIFFWarningExt
argument_list|(
operator|(
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
operator|)
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"JPEGLib"
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Interface routines.  This layer of routines exists  * primarily to limit side-effects from using setjmp.  * Also, normal/error returns are converted into return  * values per libtiff practice.  */
end_comment
begin_define
DECL|macro|CALLJPEG
define|#
directive|define
name|CALLJPEG
parameter_list|(
name|sp
parameter_list|,
name|fail
parameter_list|,
name|op
parameter_list|)
value|(SETJMP((sp)->exit_jmpbuf) ? (fail) : (op))
end_define
begin_define
DECL|macro|CALLVJPEG
define|#
directive|define
name|CALLVJPEG
parameter_list|(
name|sp
parameter_list|,
name|op
parameter_list|)
value|CALLJPEG(sp, 0, ((op),1))
end_define
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_create_compress
name|TIFFjpeg_create_compress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
comment|/* initialize JPEG error handling */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|err
operator|=
name|jpeg_std_error
argument_list|(
operator|&
name|sp
operator|->
name|err
argument_list|)
expr_stmt|;
name|sp
operator|->
name|err
operator|.
name|error_exit
operator|=
name|TIFFjpeg_error_exit
expr_stmt|;
name|sp
operator|->
name|err
operator|.
name|output_message
operator|=
name|TIFFjpeg_output_message
expr_stmt|;
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_create_compress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_create_decompress
name|TIFFjpeg_create_decompress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
comment|/* initialize JPEG error handling */
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|err
operator|=
name|jpeg_std_error
argument_list|(
operator|&
name|sp
operator|->
name|err
argument_list|)
expr_stmt|;
name|sp
operator|->
name|err
operator|.
name|error_exit
operator|=
name|TIFFjpeg_error_exit
expr_stmt|;
name|sp
operator|->
name|err
operator|.
name|output_message
operator|=
name|TIFFjpeg_output_message
expr_stmt|;
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_create_decompress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_set_defaults
name|TIFFjpeg_set_defaults
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_set_defaults
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_set_colorspace
name|TIFFjpeg_set_colorspace
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|J_COLOR_SPACE
name|colorspace
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_set_colorspace
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|colorspace
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_set_quality
name|TIFFjpeg_set_quality
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|int
name|quality
parameter_list|,
name|boolean
name|force_baseline
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_set_quality
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|quality
argument_list|,
name|force_baseline
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_suppress_tables
name|TIFFjpeg_suppress_tables
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|boolean
name|suppress
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_suppress_tables
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|suppress
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_start_compress
name|TIFFjpeg_start_compress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|boolean
name|write_all_tables
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_start_compress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|write_all_tables
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_write_scanlines
name|TIFFjpeg_write_scanlines
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|JSAMPARRAY
name|scanlines
parameter_list|,
name|int
name|num_lines
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|jpeg_write_scanlines
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|scanlines
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|num_lines
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_write_raw_data
name|TIFFjpeg_write_raw_data
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|JSAMPIMAGE
name|data
parameter_list|,
name|int
name|num_lines
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|jpeg_write_raw_data
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|,
name|data
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|num_lines
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_finish_compress
name|TIFFjpeg_finish_compress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_finish_compress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_write_tables
name|TIFFjpeg_write_tables
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_write_tables
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_read_header
name|TIFFjpeg_read_header
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|boolean
name|require_image
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
name|jpeg_read_header
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|,
name|require_image
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_start_decompress
name|TIFFjpeg_start_decompress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_start_decompress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_read_scanlines
name|TIFFjpeg_read_scanlines
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|JSAMPARRAY
name|scanlines
parameter_list|,
name|int
name|max_lines
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|jpeg_read_scanlines
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|,
name|scanlines
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|max_lines
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_read_raw_data
name|TIFFjpeg_read_raw_data
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|JSAMPIMAGE
name|data
parameter_list|,
name|int
name|max_lines
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|jpeg_read_raw_data
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|,
name|data
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|max_lines
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_finish_decompress
name|TIFFjpeg_finish_decompress
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|jpeg_finish_decompress
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|d
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_abort
name|TIFFjpeg_abort
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_abort
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|comm
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_destroy
name|TIFFjpeg_destroy
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|CALLVJPEG
argument_list|(
name|sp
argument_list|,
name|jpeg_destroy
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|comm
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|JSAMPARRAY
DECL|function|TIFFjpeg_alloc_sarray
name|TIFFjpeg_alloc_sarray
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|int
name|pool_id
parameter_list|,
name|JDIMENSION
name|samplesperrow
parameter_list|,
name|JDIMENSION
name|numrows
parameter_list|)
block|{
return|return
name|CALLJPEG
argument_list|(
name|sp
argument_list|,
operator|(
name|JSAMPARRAY
operator|)
name|NULL
argument_list|,
call|(
modifier|*
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|&
name|sp
operator|->
name|cinfo
operator|.
name|comm
argument_list|,
name|pool_id
argument_list|,
name|samplesperrow
argument_list|,
name|numrows
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * JPEG library destination data manager.  * These routines direct compressed data from libjpeg into the  * libtiff output buffer.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|std_init_destination
name|std_init_destination
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|TIFF
modifier|*
name|tif
init|=
name|sp
operator|->
name|tif
decl_stmt|;
name|sp
operator|->
name|dest
operator|.
name|next_output_byte
operator|=
operator|(
name|JOCTET
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
operator|=
operator|(
name|size_t
operator|)
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|boolean
DECL|function|std_empty_output_buffer
name|std_empty_output_buffer
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|TIFF
modifier|*
name|tif
init|=
name|sp
operator|->
name|tif
decl_stmt|;
comment|/* the entire buffer has been filled */
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
name|TIFFFlushData1
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|next_output_byte
operator|=
operator|(
name|JOCTET
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
operator|=
operator|(
name|size_t
operator|)
name|tif
operator|->
name|tif_rawdatasize
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|std_term_destination
name|std_term_destination
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|TIFF
modifier|*
name|tif
init|=
name|sp
operator|->
name|tif
decl_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
operator|(
name|tidata_t
operator|)
name|sp
operator|->
name|dest
operator|.
name|next_output_byte
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
name|tif
operator|->
name|tif_rawdatasize
operator|-
operator|(
name|tsize_t
operator|)
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
expr_stmt|;
comment|/* NB: libtiff does the final buffer flush */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|TIFFjpeg_data_dest
name|TIFFjpeg_data_dest
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|dest
operator|=
operator|&
name|sp
operator|->
name|dest
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|init_destination
operator|=
name|std_init_destination
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|empty_output_buffer
operator|=
name|std_empty_output_buffer
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|term_destination
operator|=
name|std_term_destination
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Alternate destination manager for outputting to JPEGTables field.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|tables_init_destination
name|tables_init_destination
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
comment|/* while building, jpegtables_length is allocated buffer size */
name|sp
operator|->
name|dest
operator|.
name|next_output_byte
operator|=
operator|(
name|JOCTET
operator|*
operator|)
name|sp
operator|->
name|jpegtables
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
operator|=
operator|(
name|size_t
operator|)
name|sp
operator|->
name|jpegtables_length
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|boolean
DECL|function|tables_empty_output_buffer
name|tables_empty_output_buffer
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|void
modifier|*
name|newbuf
decl_stmt|;
comment|/* the entire buffer has been filled; enlarge it by 1000 bytes */
name|newbuf
operator|=
name|_TIFFrealloc
argument_list|(
operator|(
name|tdata_t
operator|)
name|sp
operator|->
name|jpegtables
argument_list|,
call|(
name|tsize_t
call|)
argument_list|(
name|sp
operator|->
name|jpegtables_length
operator|+
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_OUT_OF_MEMORY
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|next_output_byte
operator|=
operator|(
name|JOCTET
operator|*
operator|)
name|newbuf
operator|+
name|sp
operator|->
name|jpegtables_length
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
operator|=
operator|(
name|size_t
operator|)
literal|1000
expr_stmt|;
name|sp
operator|->
name|jpegtables
operator|=
name|newbuf
expr_stmt|;
name|sp
operator|->
name|jpegtables_length
operator|+=
literal|1000
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|tables_term_destination
name|tables_term_destination
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
comment|/* set tables length to number of bytes actually emitted */
name|sp
operator|->
name|jpegtables_length
operator|-=
name|sp
operator|->
name|dest
operator|.
name|free_in_buffer
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFjpeg_tables_dest
name|TIFFjpeg_tables_dest
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
comment|/* 	 * Allocate a working buffer for building tables. 	 * Initial size is 1000 bytes, which is usually adequate. 	 */
if|if
condition|(
name|sp
operator|->
name|jpegtables
condition|)
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|jpegtables
argument_list|)
expr_stmt|;
name|sp
operator|->
name|jpegtables_length
operator|=
literal|1000
expr_stmt|;
name|sp
operator|->
name|jpegtables
operator|=
operator|(
name|void
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
operator|(
name|tsize_t
operator|)
name|sp
operator|->
name|jpegtables_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|jpegtables
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|jpegtables_length
operator|=
literal|0
expr_stmt|;
name|TIFFErrorExt
argument_list|(
name|sp
operator|->
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFjpeg_tables_dest"
argument_list|,
literal|"No space for JPEGTables"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|dest
operator|=
operator|&
name|sp
operator|->
name|dest
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|init_destination
operator|=
name|tables_init_destination
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|empty_output_buffer
operator|=
name|tables_empty_output_buffer
expr_stmt|;
name|sp
operator|->
name|dest
operator|.
name|term_destination
operator|=
name|tables_term_destination
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * JPEG library source data manager.  * These routines supply compressed data to libjpeg.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|std_init_source
name|std_init_source
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|TIFF
modifier|*
name|tif
init|=
name|sp
operator|->
name|tif
decl_stmt|;
name|sp
operator|->
name|src
operator|.
name|next_input_byte
operator|=
operator|(
specifier|const
name|JOCTET
operator|*
operator|)
name|tif
operator|->
name|tif_rawdata
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
operator|=
operator|(
name|size_t
operator|)
name|tif
operator|->
name|tif_rawcc
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|boolean
DECL|function|std_fill_input_buffer
name|std_fill_input_buffer
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
specifier|static
specifier|const
name|JOCTET
name|dummy_EOI
index|[
literal|2
index|]
init|=
block|{
literal|0xFF
block|,
name|JPEG_EOI
block|}
decl_stmt|;
comment|/* 	 * Should never get here since entire strip/tile is 	 * read into memory before the decompressor is called, 	 * and thus was supplied by init_source. 	 */
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_JPEG_EOF
argument_list|)
expr_stmt|;
comment|/* insert a fake EOI marker */
name|sp
operator|->
name|src
operator|.
name|next_input_byte
operator|=
name|dummy_EOI
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|std_skip_input_data
name|std_skip_input_data
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|,
name|long
name|num_bytes
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
if|if
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|num_bytes
operator|>
operator|(
name|long
operator|)
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
condition|)
block|{
comment|/* oops, buffer overrun */
operator|(
name|void
operator|)
name|std_fill_input_buffer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|src
operator|.
name|next_input_byte
operator|+=
operator|(
name|size_t
operator|)
name|num_bytes
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
operator|-=
operator|(
name|size_t
operator|)
name|num_bytes
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|std_term_source
name|std_term_source
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
comment|/* No work necessary here */
comment|/* Or must we update tif->tif_rawcp, tif->tif_rawcc ??? */
comment|/* (if so, need empty tables_term_source!) */
operator|(
name|void
operator|)
name|cinfo
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|TIFFjpeg_data_src
name|TIFFjpeg_data_src
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
operator|(
name|void
operator|)
name|tif
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|src
operator|=
operator|&
name|sp
operator|->
name|src
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|init_source
operator|=
name|std_init_source
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|fill_input_buffer
operator|=
name|std_fill_input_buffer
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|skip_input_data
operator|=
name|std_skip_input_data
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|resync_to_restart
operator|=
name|jpeg_resync_to_restart
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|term_source
operator|=
name|std_term_source
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
operator|=
literal|0
expr_stmt|;
comment|/* for safety */
name|sp
operator|->
name|src
operator|.
name|next_input_byte
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Alternate source manager for reading from JPEGTables.  * We can share all the code except for the init routine.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|tables_init_source
name|tables_init_source
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
operator|(
name|JPEGState
operator|*
operator|)
name|cinfo
decl_stmt|;
name|sp
operator|->
name|src
operator|.
name|next_input_byte
operator|=
operator|(
specifier|const
name|JOCTET
operator|*
operator|)
name|sp
operator|->
name|jpegtables
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|bytes_in_buffer
operator|=
operator|(
name|size_t
operator|)
name|sp
operator|->
name|jpegtables_length
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|TIFFjpeg_tables_src
name|TIFFjpeg_tables_src
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFjpeg_data_src
argument_list|(
name|sp
argument_list|,
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|src
operator|.
name|init_source
operator|=
name|tables_init_source
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Allocate downsampled-data buffers needed for downsampled I/O.  * We use values computed in jpeg_start_compress or jpeg_start_decompress.  * We use libjpeg's allocator so that buffers will be released automatically  * when done with strip/tile.  * This is also a handy place to compute samplesperclump, bytesperline.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|alloc_downsampled_buffers
name|alloc_downsampled_buffers
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|jpeg_component_info
modifier|*
name|comp_info
parameter_list|,
name|int
name|num_components
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JSAMPARRAY
name|buf
decl_stmt|;
name|int
name|samples_per_clump
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|comp_info
init|;
name|ci
operator|<
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|samples_per_clump
operator|+=
name|compptr
operator|->
name|h_samp_factor
operator|*
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
name|buf
operator|=
name|TIFFjpeg_alloc_sarray
argument_list|(
name|sp
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|compptr
operator|->
name|width_in_blocks
operator|*
name|DCTSIZE
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|DCTSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|ds_buffer
index|[
name|ci
index|]
operator|=
name|buf
expr_stmt|;
block|}
name|sp
operator|->
name|samplesperclump
operator|=
name|samples_per_clump
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * JPEG Decoding.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGSetupDecode
name|JPEGSetupDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|JPEGInitializeLibJPEG
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
argument_list|)
expr_stmt|;
comment|/* Read JPEGTables if it is present */
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
condition|)
block|{
name|TIFFjpeg_tables_src
argument_list|(
name|sp
argument_list|,
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFjpeg_read_header
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|JPEG_HEADER_TABLES_ONLY
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"JPEGSetupDecode"
argument_list|,
literal|"Bogus JPEGTables field"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Grab parameters that are same for all strips/tiles */
name|sp
operator|->
name|photometric
operator|=
name|td
operator|->
name|td_photometric
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_YCBCR
case|:
name|sp
operator|->
name|h_sampling
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|v_sampling
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
comment|/* TIFF 6.0 forbids subsampling of all other color spaces */
name|sp
operator|->
name|h_sampling
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|v_sampling
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Set up for reading normal data */
name|TIFFjpeg_data_src
argument_list|(
name|sp
argument_list|,
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
comment|/* override byte swapping */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set up for decoding a strip or tile.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGPreDecode
name|JPEGPreDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"JPEGPreDecode"
decl_stmt|;
name|uint32
name|segment_width
decl_stmt|,
name|segment_height
decl_stmt|;
name|int
name|downsampled_output
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
argument_list|)
expr_stmt|;
comment|/* 	 * Reset decoder state from any previous strip/tile, 	 * in case application didn't read the whole strip. 	 */
if|if
condition|(
operator|!
name|TIFFjpeg_abort
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Read the header for this strip/tile. 	 */
if|if
condition|(
name|TIFFjpeg_read_header
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
operator|!=
name|JPEG_HEADER_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Check image parameters and set decompression parameters. 	 */
name|segment_width
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
name|segment_height
operator|=
name|td
operator|->
name|td_imagelength
operator|-
name|tif
operator|->
name|tif_row
expr_stmt|;
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|segment_width
operator|=
name|td
operator|->
name|td_tilewidth
expr_stmt|;
name|segment_height
operator|=
name|td
operator|->
name|td_tilelength
expr_stmt|;
name|sp
operator|->
name|bytesperline
operator|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|segment_height
operator|>
name|td
operator|->
name|td_rowsperstrip
condition|)
name|segment_height
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|sp
operator|->
name|bytesperline
operator|=
name|TIFFOldScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|&&
name|s
operator|>
literal|0
condition|)
block|{
comment|/* 		 * For PC 2, scale down the expected strip/tile size 		 * to match a downsampled component 		 */
name|segment_width
operator|=
name|TIFFhowmany
argument_list|(
name|segment_width
argument_list|,
name|sp
operator|->
name|h_sampling
argument_list|)
expr_stmt|;
name|segment_height
operator|=
name|TIFFhowmany
argument_list|(
name|segment_height
argument_list|,
name|sp
operator|->
name|v_sampling
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_width
operator|<
name|segment_width
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
operator|<
name|segment_height
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG strip/tile size, "
literal|"expected %dx%d, got %dx%d"
argument_list|,
name|segment_width
argument_list|,
name|segment_height
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_width
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_width
operator|>
name|segment_width
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
operator|>
name|segment_height
condition|)
block|{
comment|/* 		 * This case could be dangerous, if the strip or tile size has 		 * been reported as less than the amount of data jpeg will 		 * return, some potential security issues arise. Catch this 		 * case and error out. 		 */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"JPEG strip/tile size exceeds expected dimensions,"
literal|" expected %dx%d, got %dx%d"
argument_list|,
name|segment_width
argument_list|,
name|segment_height
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_width
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
operator|!=
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
literal|1
operator|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG component count"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
if|if
condition|(
literal|12
operator|!=
name|td
operator|->
name|td_bitspersample
operator|&&
literal|8
operator|!=
name|td
operator|->
name|td_bitspersample
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG data precision"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|bits_in_jsample
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|!=
name|td
operator|->
name|td_bitspersample
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG data precision"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
comment|/* Component 0 should have expected sampling factors */
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
operator|!=
name|sp
operator|->
name|h_sampling
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
operator|!=
name|sp
operator|->
name|v_sampling
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG sampling factors %d,%d\n"
literal|"Apparently should be %d,%d."
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
argument_list|,
name|sp
operator|->
name|h_sampling
argument_list|,
name|sp
operator|->
name|v_sampling
argument_list|)
expr_stmt|;
comment|/* 				 * There are potential security issues here 				 * for decoders that have already allocated 				 * buffers based on the expected sampling 				 * factors. Lets check the sampling factors 				 * dont exceed what we were expecting. 				 */
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
operator|>
name|sp
operator|->
name|h_sampling
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
operator|>
name|sp
operator|->
name|v_sampling
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Cannot honour JPEG sampling factors"
literal|" that exceed those specified."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			     * XXX: Files written by the Intergraph software 			     * has different sampling factors stored in the 			     * TIFF tags and in the JPEG structures. We will 			     * try to deduce Intergraph files by the presense 			     * of the tag 33918. 			     */
if|if
condition|(
operator|!
name|_TIFFFindFieldInfo
argument_list|(
name|tif
argument_list|,
literal|33918
argument_list|,
name|TIFF_ANY
argument_list|)
condition|)
block|{
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Decompressor will try reading with "
literal|"sampling %d,%d."
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
argument_list|)
expr_stmt|;
name|sp
operator|->
name|h_sampling
operator|=
operator|(
name|uint16
operator|)
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
expr_stmt|;
name|sp
operator|->
name|v_sampling
operator|=
operator|(
name|uint16
operator|)
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
expr_stmt|;
block|}
block|}
comment|/* Rest should have sampling factors 1,1 */
for|for
control|(
name|ci
operator|=
literal|1
init|;
name|ci
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
name|ci
index|]
operator|.
name|h_samp_factor
operator|!=
literal|1
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
name|ci
index|]
operator|.
name|v_samp_factor
operator|!=
literal|1
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG sampling factors"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* PC 2's single component should have sampling factors 1,1 */
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
operator|!=
literal|1
operator|||
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
operator|!=
literal|1
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Improper JPEG sampling factors"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|downsampled_output
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
name|sp
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
name|sp
operator|->
name|jpegcolormode
operator|==
name|JPEGCOLORMODE_RGB
condition|)
block|{
comment|/* Convert YCbCr to RGB */
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|out_color_space
operator|=
name|JCS_RGB
expr_stmt|;
block|}
else|else
block|{
comment|/* Suppress colorspace handling */
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|jpeg_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|out_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
operator|&&
operator|(
name|sp
operator|->
name|h_sampling
operator|!=
literal|1
operator|||
name|sp
operator|->
name|v_sampling
operator|!=
literal|1
operator|)
condition|)
name|downsampled_output
operator|=
name|TRUE
expr_stmt|;
comment|/* XXX what about up-sampling? */
block|}
if|if
condition|(
name|downsampled_output
condition|)
block|{
comment|/* Need to use raw-data interface to libjpeg */
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|raw_data_out
operator|=
name|TRUE
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|JPEGDecodeRaw
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|JPEGDecodeRaw
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|JPEGDecodeRaw
expr_stmt|;
block|}
else|else
block|{
comment|/* Use normal interface to libjpeg */
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|raw_data_out
operator|=
name|FALSE
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|JPEGDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|JPEGDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|JPEGDecode
expr_stmt|;
block|}
comment|/* Start JPEG decompressor */
if|if
condition|(
operator|!
name|TIFFjpeg_start_decompress
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate downsampled-data buffers if needed */
if|if
condition|(
name|downsampled_output
condition|)
block|{
if|if
condition|(
operator|!
name|alloc_downsampled_buffers
argument_list|(
name|tif
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|scancount
operator|=
name|DCTSIZE
expr_stmt|;
comment|/* mark buffer empty */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a chunk of pixels.  * "Standard" case: returned data is not downsampled.  */
end_comment
begin_comment
comment|/*ARGSUSED*/
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGDecode
name|JPEGDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|nrows
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|nrows
operator|=
name|cc
operator|/
name|sp
operator|->
name|bytesperline
expr_stmt|;
if|if
condition|(
name|cc
operator|%
name|sp
operator|->
name|bytesperline
condition|)
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"fractional scanline not read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrows
operator|>
operator|(
name|int
operator|)
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
condition|)
name|nrows
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
expr_stmt|;
comment|/* data is expected to be read in multiples of a scanline */
if|if
condition|(
name|nrows
condition|)
block|{
name|JSAMPROW
name|line_work_buf
init|=
name|NULL
decl_stmt|;
comment|/*         ** For 6B, only use temporary buffer for 12 bit imagery.          ** For Mk1 always use it.          */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JPEG_LIB_MK1
argument_list|)
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|==
literal|12
condition|)
endif|#
directive|endif
block|{
name|line_work_buf
operator|=
operator|(
name|JSAMPROW
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|line_work_buf
operator|!=
name|NULL
condition|)
block|{
comment|/*                  ** In the MK1 case, we aways read into a 16bit buffer, and then                 ** pack down to 12bit or 8bit.  In 6B case we only read into 16                 ** bit buffer for 12bit data, which we need to repack.                  */
if|if
condition|(
name|TIFFjpeg_read_scanlines
argument_list|(
name|sp
argument_list|,
operator|&
name|line_work_buf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|==
literal|12
condition|)
block|{
name|int
name|value_pairs
init|=
operator|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|iPair
decl_stmt|;
for|for
control|(
name|iPair
operator|=
literal|0
init|;
name|iPair
operator|<
name|value_pairs
condition|;
name|iPair
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|out_ptr
init|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
name|iPair
operator|*
literal|3
decl_stmt|;
name|JSAMPLE
modifier|*
name|in_ptr
init|=
name|line_work_buf
operator|+
name|iPair
operator|*
literal|2
decl_stmt|;
name|out_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|in_ptr
index|[
literal|0
index|]
operator|&
literal|0xff0
operator|)
operator|>>
literal|4
expr_stmt|;
name|out_ptr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|in_ptr
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|in_ptr
index|[
literal|1
index|]
operator|&
literal|0xf00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|out_ptr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|in_ptr
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|==
literal|8
condition|)
block|{
name|int
name|value_count
init|=
operator|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
operator|)
decl_stmt|;
name|int
name|iValue
decl_stmt|;
for|for
control|(
name|iValue
operator|=
literal|0
init|;
name|iValue
operator|<
name|value_count
condition|;
name|iValue
operator|++
control|)
block|{
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
index|[
name|iValue
index|]
operator|=
name|line_work_buf
index|[
name|iValue
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*                 ** In the libjpeg6b 8bit case.  We read directly into the                  ** TIFF buffer.                 */
name|JSAMPROW
name|bufptr
init|=
operator|(
name|JSAMPROW
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|TIFFjpeg_read_scanlines
argument_list|(
name|sp
argument_list|,
operator|&
name|bufptr
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|++
name|tif
operator|->
name|tif_row
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|bytesperline
expr_stmt|;
name|cc
operator|-=
name|sp
operator|->
name|bytesperline
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nrows
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|line_work_buf
operator|!=
name|NULL
condition|)
name|_TIFFfree
argument_list|(
name|line_work_buf
argument_list|)
expr_stmt|;
block|}
comment|/* Close down the decompressor if we've finished the strip or tile. */
return|return
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_scanline
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_height
operator|||
name|TIFFjpeg_finish_decompress
argument_list|(
name|sp
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a chunk of pixels.  * Returned data is downsampled per sampling factors.  */
end_comment
begin_comment
comment|/*ARGSUSED*/
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGDecodeRaw
name|JPEGDecodeRaw
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|nrows
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
comment|/* data is expected to be read in multiples of a scanline */
if|if
condition|(
operator|(
name|nrows
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|image_height
operator|)
condition|)
block|{
comment|/* Cb,Cr both have sampling factors 1, so this is correct */
name|JDIMENSION
name|clumps_per_line
init|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
index|[
literal|1
index|]
operator|.
name|downsampled_width
decl_stmt|;
name|int
name|samples_per_clump
init|=
name|sp
operator|->
name|samplesperclump
decl_stmt|;
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
name|unsigned
name|short
modifier|*
name|tmpbuf
init|=
name|_TIFFmalloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
argument_list|)
decl_stmt|;
endif|#
directive|endif
do|do
block|{
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|clumpoffset
decl_stmt|;
comment|/* Reload downsampled-data buffer if needed */
if|if
condition|(
name|sp
operator|->
name|scancount
operator|>=
name|DCTSIZE
condition|)
block|{
name|int
name|n
init|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|max_v_samp_factor
operator|*
name|DCTSIZE
decl_stmt|;
if|if
condition|(
name|TIFFjpeg_read_raw_data
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|ds_buffer
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|scancount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Fastest way to unseparate data is to make one pass 			 * over the scanline for each row of each component. 			 */
name|clumpoffset
operator|=
literal|0
expr_stmt|;
comment|/* first sample in clump */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|comp_info
init|;
name|ci
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|int
name|hsamp
init|=
name|compptr
operator|->
name|h_samp_factor
decl_stmt|;
name|int
name|vsamp
init|=
name|compptr
operator|->
name|v_samp_factor
decl_stmt|;
name|int
name|ypos
decl_stmt|;
for|for
control|(
name|ypos
operator|=
literal|0
init|;
name|ypos
operator|<
name|vsamp
condition|;
name|ypos
operator|++
control|)
block|{
name|JSAMPLE
modifier|*
name|inptr
init|=
name|sp
operator|->
name|ds_buffer
index|[
name|ci
index|]
index|[
name|sp
operator|->
name|scancount
operator|*
name|vsamp
operator|+
name|ypos
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
name|JSAMPLE
modifier|*
name|outptr
init|=
operator|(
name|JSAMPLE
operator|*
operator|)
name|tmpbuf
operator|+
name|clumpoffset
decl_stmt|;
else|#
directive|else
name|JSAMPLE
modifier|*
name|outptr
init|=
operator|(
name|JSAMPLE
operator|*
operator|)
name|buf
operator|+
name|clumpoffset
decl_stmt|;
endif|#
directive|endif
name|JDIMENSION
name|nclump
decl_stmt|;
if|if
condition|(
name|hsamp
operator|==
literal|1
condition|)
block|{
comment|/* fast path for at least Cb and Cr */
for|for
control|(
name|nclump
operator|=
name|clumps_per_line
init|;
name|nclump
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|outptr
index|[
literal|0
index|]
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
name|outptr
operator|+=
name|samples_per_clump
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|xpos
decl_stmt|;
comment|/* general case */
for|for
control|(
name|nclump
operator|=
name|clumps_per_line
init|;
name|nclump
operator|--
operator|>
literal|0
condition|;
control|)
block|{
for|for
control|(
name|xpos
operator|=
literal|0
init|;
name|xpos
operator|<
name|hsamp
condition|;
name|xpos
operator|++
control|)
name|outptr
index|[
name|xpos
index|]
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
name|outptr
operator|+=
name|samples_per_clump
expr_stmt|;
block|}
block|}
name|clumpoffset
operator|+=
name|hsamp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
block|{
if|if
condition|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|data_precision
operator|==
literal|8
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
operator|=
name|tmpbuf
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// 12-bit
name|int
name|value_pairs
init|=
operator|(
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_width
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|num_components
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|iPair
decl_stmt|;
for|for
control|(
name|iPair
operator|=
literal|0
init|;
name|iPair
operator|<
name|value_pairs
condition|;
name|iPair
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|out_ptr
init|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
name|iPair
operator|*
literal|3
decl_stmt|;
name|JSAMPLE
modifier|*
name|in_ptr
init|=
name|tmpbuf
operator|+
name|iPair
operator|*
literal|2
decl_stmt|;
name|out_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|in_ptr
index|[
literal|0
index|]
operator|&
literal|0xff0
operator|)
operator|>>
literal|4
expr_stmt|;
name|out_ptr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|in_ptr
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|in_ptr
index|[
literal|1
index|]
operator|&
literal|0xf00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|out_ptr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|in_ptr
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|sp
operator|->
name|scancount
operator|++
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|+=
name|sp
operator|->
name|v_sampling
expr_stmt|;
comment|/* increment/decrement of buf and cc is still incorrect, but should not matter 			 * TODO: resolve this */
name|buf
operator|+=
name|sp
operator|->
name|bytesperline
expr_stmt|;
name|cc
operator|-=
name|sp
operator|->
name|bytesperline
expr_stmt|;
name|nrows
operator|-=
name|sp
operator|->
name|v_sampling
expr_stmt|;
block|}
do|while
condition|(
name|nrows
operator|>
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
name|_TIFFfree
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Close down the decompressor if done. */
return|return
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_scanline
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|d
operator|.
name|output_height
operator|||
name|TIFFjpeg_finish_decompress
argument_list|(
name|sp
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * JPEG Encoding.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|unsuppress_quant_table
name|unsuppress_quant_table
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|int
name|tblno
parameter_list|)
block|{
name|JQUANT_TBL
modifier|*
name|qtbl
decl_stmt|;
if|if
condition|(
operator|(
name|qtbl
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|quant_tbl_ptrs
index|[
name|tblno
index|]
operator|)
operator|!=
name|NULL
condition|)
name|qtbl
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|unsuppress_huff_table
name|unsuppress_huff_table
parameter_list|(
name|JPEGState
modifier|*
name|sp
parameter_list|,
name|int
name|tblno
parameter_list|)
block|{
name|JHUFF_TBL
modifier|*
name|htbl
decl_stmt|;
if|if
condition|(
operator|(
name|htbl
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|dc_huff_tbl_ptrs
index|[
name|tblno
index|]
operator|)
operator|!=
name|NULL
condition|)
name|htbl
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|htbl
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|ac_huff_tbl_ptrs
index|[
name|tblno
index|]
operator|)
operator|!=
name|NULL
condition|)
name|htbl
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|prepare_JPEGTables
name|prepare_JPEGTables
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|JPEGInitializeLibJPEG
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize quant tables for current quality setting */
if|if
condition|(
operator|!
name|TIFFjpeg_set_quality
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|jpegquality
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Mark only the tables we want for output */
comment|/* NB: chrominance tables are currently used only with YCbCr */
if|if
condition|(
operator|!
name|TIFFjpeg_suppress_tables
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|jpegtablesmode
operator|&
name|JPEGTABLESMODE_QUANT
condition|)
block|{
name|unsuppress_quant_table
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_YCBCR
condition|)
name|unsuppress_quant_table
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|jpegtablesmode
operator|&
name|JPEGTABLESMODE_HUFF
condition|)
block|{
name|unsuppress_huff_table
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_YCBCR
condition|)
name|unsuppress_huff_table
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Direct libjpeg output into jpegtables */
if|if
condition|(
operator|!
name|TIFFjpeg_tables_dest
argument_list|(
name|sp
argument_list|,
name|tif
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Emit tables-only datastream */
if|if
condition|(
operator|!
name|TIFFjpeg_write_tables
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|JPEGSetupEncode
name|JPEGSetupEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"JPEGSetupEncode"
decl_stmt|;
name|JPEGInitializeLibJPEG
argument_list|(
name|tif
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize all JPEG parameters to default values. 	 * Note that jpeg_set_defaults needs legal values for 	 * in_color_space and input_components. 	 */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|in_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|input_components
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFjpeg_set_defaults
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Set per-file parameters */
name|sp
operator|->
name|photometric
operator|=
name|td
operator|->
name|td_photometric
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|photometric
condition|)
block|{
case|case
name|PHOTOMETRIC_YCBCR
case|:
name|sp
operator|->
name|h_sampling
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|v_sampling
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * A ReferenceBlackWhite field *must* be present since the 		 * default value is inappropriate for YCbCr.  Fill in the 		 * proper value if application didn't set it. 		 */
block|{
name|float
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_REFERENCEBLACKWHITE
argument_list|,
operator|&
name|ref
argument_list|)
condition|)
block|{
name|float
name|refbw
index|[
literal|6
index|]
decl_stmt|;
name|long
name|top
init|=
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
decl_stmt|;
name|refbw
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|refbw
index|[
literal|1
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|top
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|refbw
index|[
literal|2
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|top
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|refbw
index|[
literal|3
index|]
operator|=
name|refbw
index|[
literal|1
index|]
expr_stmt|;
name|refbw
index|[
literal|4
index|]
operator|=
name|refbw
index|[
literal|2
index|]
expr_stmt|;
name|refbw
index|[
literal|5
index|]
operator|=
name|refbw
index|[
literal|1
index|]
expr_stmt|;
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_REFERENCEBLACKWHITE
argument_list|,
name|refbw
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PHOTOMETRIC_PALETTE
case|:
comment|/* disallowed by Tech Note */
case|case
name|PHOTOMETRIC_MASK
case|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"PhotometricInterpretation %d not allowed for JPEG"
argument_list|,
operator|(
name|int
operator|)
name|sp
operator|->
name|photometric
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* TIFF 6.0 forbids subsampling of all other color spaces */
name|sp
operator|->
name|h_sampling
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|v_sampling
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Verify miscellaneous parameters */
comment|/* 	 * This would need work if libtiff ever supports different 	 * depths for different components, or if libjpeg ever supports 	 * run-time selection of depth.  Neither is imminent. 	 */
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
comment|/* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|!=
literal|8
operator|&&
name|td
operator|->
name|td_bitspersample
operator|!=
literal|12
condition|)
else|#
directive|else
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|!=
name|BITS_IN_JSAMPLE
condition|)
endif|#
directive|endif
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"BitsPerSample %d not allowed for JPEG"
argument_list|,
operator|(
name|int
operator|)
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|data_precision
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
ifdef|#
directive|ifdef
name|JPEG_LIB_MK1
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|bits_in_jsample
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|td
operator|->
name|td_tilelength
operator|%
operator|(
name|sp
operator|->
name|v_sampling
operator|*
name|DCTSIZE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"JPEG tile height must be multiple of %d"
argument_list|,
name|sp
operator|->
name|v_sampling
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|td
operator|->
name|td_tilewidth
operator|%
operator|(
name|sp
operator|->
name|h_sampling
operator|*
name|DCTSIZE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"JPEG tile width must be multiple of %d"
argument_list|,
name|sp
operator|->
name|h_sampling
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|td
operator|->
name|td_rowsperstrip
operator|<
name|td
operator|->
name|td_imagelength
operator|&&
operator|(
name|td
operator|->
name|td_rowsperstrip
operator|%
operator|(
name|sp
operator|->
name|v_sampling
operator|*
name|DCTSIZE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"RowsPerStrip must be multiple of %d for JPEG"
argument_list|,
name|sp
operator|->
name|v_sampling
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Create a JPEGTables field if appropriate */
if|if
condition|(
name|sp
operator|->
name|jpegtablesmode
operator|&
operator|(
name|JPEGTABLESMODE_QUANT
operator||
name|JPEGTABLESMODE_HUFF
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|prepare_JPEGTables
argument_list|(
name|tif
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Mark the field present */
comment|/* Can't use TIFFSetField since BEENWRITING is already set! */
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_DIRTYDIRECT
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not support application-supplied JPEGTables, */
comment|/* so mark the field not present */
name|TIFFClrFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
expr_stmt|;
block|}
comment|/* Direct libjpeg output to libtiff's output buffer */
name|TIFFjpeg_data_dest
argument_list|(
name|sp
argument_list|,
name|tif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set encoding state at the start of a strip or tile.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGPreEncode
name|JPEGPreEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"JPEGPreEncode"
decl_stmt|;
name|uint32
name|segment_width
decl_stmt|,
name|segment_height
decl_stmt|;
name|int
name|downsampled_input
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
argument_list|)
expr_stmt|;
comment|/* 	 * Set encoding parameters for this strip/tile. 	 */
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|segment_width
operator|=
name|td
operator|->
name|td_tilewidth
expr_stmt|;
name|segment_height
operator|=
name|td
operator|->
name|td_tilelength
expr_stmt|;
name|sp
operator|->
name|bytesperline
operator|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|segment_width
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
name|segment_height
operator|=
name|td
operator|->
name|td_imagelength
operator|-
name|tif
operator|->
name|tif_row
expr_stmt|;
if|if
condition|(
name|segment_height
operator|>
name|td
operator|->
name|td_rowsperstrip
condition|)
name|segment_height
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
name|sp
operator|->
name|bytesperline
operator|=
name|TIFFOldScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_SEPARATE
operator|&&
name|s
operator|>
literal|0
condition|)
block|{
comment|/* for PC 2, scale down the strip/tile size 		 * to match a downsampled component 		 */
name|segment_width
operator|=
name|TIFFhowmany
argument_list|(
name|segment_width
argument_list|,
name|sp
operator|->
name|h_sampling
argument_list|)
expr_stmt|;
name|segment_height
operator|=
name|TIFFhowmany
argument_list|(
name|segment_height
argument_list|,
name|sp
operator|->
name|v_sampling
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|segment_width
operator|>
literal|65535
operator|||
name|segment_height
operator|>
literal|65535
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Strip/tile too large for JPEG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|image_width
operator|=
name|segment_width
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|image_height
operator|=
name|segment_height
expr_stmt|;
name|downsampled_input
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|input_components
operator|=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_YCBCR
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|jpegcolormode
operator|==
name|JPEGCOLORMODE_RGB
condition|)
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|in_color_space
operator|=
name|JCS_RGB
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|in_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|h_sampling
operator|!=
literal|1
operator|||
name|sp
operator|->
name|v_sampling
operator|!=
literal|1
condition|)
name|downsampled_input
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TIFFjpeg_set_colorspace
argument_list|(
name|sp
argument_list|,
name|JCS_YCbCr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Set Y sampling factors; 			 * we assume jpeg_set_colorspace() set the rest to 1 			 */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
operator|=
name|sp
operator|->
name|h_sampling
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
operator|=
name|sp
operator|->
name|v_sampling
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|in_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFjpeg_set_colorspace
argument_list|(
name|sp
argument_list|,
name|JCS_UNKNOWN
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* jpeg_set_colorspace set all sampling factors to 1 */
block|}
block|}
else|else
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|input_components
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|in_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFjpeg_set_colorspace
argument_list|(
name|sp
argument_list|,
name|JCS_UNKNOWN
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|component_id
operator|=
name|s
expr_stmt|;
comment|/* jpeg_set_colorspace() set sampling factors to 1 */
if|if
condition|(
name|sp
operator|->
name|photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
name|s
operator|>
literal|0
condition|)
block|{
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|quant_tbl_no
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|dc_tbl_no
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|0
index|]
operator|.
name|ac_tbl_no
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* ensure libjpeg won't write any extraneous markers */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|write_JFIF_header
operator|=
name|FALSE
expr_stmt|;
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|write_Adobe_marker
operator|=
name|FALSE
expr_stmt|;
comment|/* set up table handling correctly */
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|jpegtablesmode
operator|&
name|JPEGTABLESMODE_QUANT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFjpeg_set_quality
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|jpegquality
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unsuppress_quant_table
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsuppress_quant_table
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|jpegtablesmode
operator|&
name|JPEGTABLESMODE_HUFF
condition|)
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|optimize_coding
operator|=
name|FALSE
expr_stmt|;
else|else
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|optimize_coding
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|downsampled_input
condition|)
block|{
comment|/* Need to use raw-data interface to libjpeg */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|raw_data_in
operator|=
name|TRUE
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|JPEGEncodeRaw
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|JPEGEncodeRaw
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|JPEGEncodeRaw
expr_stmt|;
block|}
else|else
block|{
comment|/* Use normal interface to libjpeg */
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|raw_data_in
operator|=
name|FALSE
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|JPEGEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|JPEGEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|JPEGEncode
expr_stmt|;
block|}
comment|/* Start JPEG compressor */
if|if
condition|(
operator|!
name|TIFFjpeg_start_compress
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate downsampled-data buffers if needed */
if|if
condition|(
name|downsampled_input
condition|)
block|{
if|if
condition|(
operator|!
name|alloc_downsampled_buffers
argument_list|(
name|tif
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
argument_list|,
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|num_components
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|scancount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a chunk of pixels.  * "Standard" case: incoming data is not downsampled.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGEncode
name|JPEGEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|nrows
decl_stmt|;
name|JSAMPROW
name|bufptr
index|[
literal|1
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* data is expected to be supplied in multiples of a scanline */
name|nrows
operator|=
name|cc
operator|/
name|sp
operator|->
name|bytesperline
expr_stmt|;
if|if
condition|(
name|cc
operator|%
name|sp
operator|->
name|bytesperline
condition|)
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"fractional scanline discarded"
argument_list|)
expr_stmt|;
comment|/* The last strip will be limited to image size */
if|if
condition|(
operator|!
name|isTiled
argument_list|(
name|tif
argument_list|)
operator|&&
name|tif
operator|->
name|tif_row
operator|+
name|nrows
operator|>
name|tif
operator|->
name|tif_dir
operator|.
name|td_imagelength
condition|)
name|nrows
operator|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_imagelength
operator|-
name|tif
operator|->
name|tif_row
expr_stmt|;
while|while
condition|(
name|nrows
operator|--
operator|>
literal|0
condition|)
block|{
name|bufptr
index|[
literal|0
index|]
operator|=
operator|(
name|JSAMPROW
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|TIFFjpeg_write_scanlines
argument_list|(
name|sp
argument_list|,
name|bufptr
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nrows
operator|>
literal|0
condition|)
name|tif
operator|->
name|tif_row
operator|++
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|bytesperline
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Encode a chunk of pixels.  * Incoming data is expected to be downsampled per sampling factors.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGEncodeRaw
name|JPEGEncodeRaw
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|buf
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|JSAMPLE
modifier|*
name|inptr
decl_stmt|;
name|JSAMPLE
modifier|*
name|outptr
decl_stmt|;
name|tsize_t
name|nrows
decl_stmt|;
name|JDIMENSION
name|clumps_per_line
decl_stmt|,
name|nclump
decl_stmt|;
name|int
name|clumpoffset
decl_stmt|,
name|ci
decl_stmt|,
name|xpos
decl_stmt|,
name|ypos
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|int
name|samples_per_clump
init|=
name|sp
operator|->
name|samplesperclump
decl_stmt|;
name|tsize_t
name|bytesperclumpline
decl_stmt|;
operator|(
name|void
operator|)
name|s
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* data is expected to be supplied in multiples of a clumpline */
comment|/* a clumpline is equivalent to v_sampling desubsampled scanlines */
comment|/* TODO: the following calculation of bytesperclumpline, should substitute calculation of sp->bytesperline, except that it is per v_sampling lines */
name|bytesperclumpline
operator|=
operator|(
operator|(
operator|(
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|image_width
operator|+
name|sp
operator|->
name|h_sampling
operator|-
literal|1
operator|)
operator|/
name|sp
operator|->
name|h_sampling
operator|)
operator|*
operator|(
name|sp
operator|->
name|h_sampling
operator|*
name|sp
operator|->
name|v_sampling
operator|+
literal|2
operator|)
operator|*
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|data_precision
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|nrows
operator|=
operator|(
name|cc
operator|/
name|bytesperclumpline
operator|)
operator|*
name|sp
operator|->
name|v_sampling
expr_stmt|;
if|if
condition|(
name|cc
operator|%
name|bytesperclumpline
condition|)
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"fractional scanline discarded"
argument_list|)
expr_stmt|;
comment|/* Cb,Cr both have sampling factors 1, so this is correct */
name|clumps_per_line
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
index|[
literal|1
index|]
operator|.
name|downsampled_width
expr_stmt|;
while|while
condition|(
name|nrows
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Fastest way to separate the data is to make one pass 		 * over the scanline for each row of each component. 		 */
name|clumpoffset
operator|=
literal|0
expr_stmt|;
comment|/* first sample in clump */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
init|;
name|ci
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|int
name|hsamp
init|=
name|compptr
operator|->
name|h_samp_factor
decl_stmt|;
name|int
name|vsamp
init|=
name|compptr
operator|->
name|v_samp_factor
decl_stmt|;
name|int
name|padding
init|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|width_in_blocks
operator|*
name|DCTSIZE
operator|-
name|clumps_per_line
operator|*
name|hsamp
argument_list|)
decl_stmt|;
for|for
control|(
name|ypos
operator|=
literal|0
init|;
name|ypos
operator|<
name|vsamp
condition|;
name|ypos
operator|++
control|)
block|{
name|inptr
operator|=
operator|(
operator|(
name|JSAMPLE
operator|*
operator|)
name|buf
operator|)
operator|+
name|clumpoffset
expr_stmt|;
name|outptr
operator|=
name|sp
operator|->
name|ds_buffer
index|[
name|ci
index|]
index|[
name|sp
operator|->
name|scancount
operator|*
name|vsamp
operator|+
name|ypos
index|]
expr_stmt|;
if|if
condition|(
name|hsamp
operator|==
literal|1
condition|)
block|{
comment|/* fast path for at least Cb and Cr */
for|for
control|(
name|nclump
operator|=
name|clumps_per_line
init|;
name|nclump
operator|--
operator|>
literal|0
condition|;
control|)
block|{
operator|*
name|outptr
operator|++
operator|=
name|inptr
index|[
literal|0
index|]
expr_stmt|;
name|inptr
operator|+=
name|samples_per_clump
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* general case */
for|for
control|(
name|nclump
operator|=
name|clumps_per_line
init|;
name|nclump
operator|--
operator|>
literal|0
condition|;
control|)
block|{
for|for
control|(
name|xpos
operator|=
literal|0
init|;
name|xpos
operator|<
name|hsamp
condition|;
name|xpos
operator|++
control|)
operator|*
name|outptr
operator|++
operator|=
name|inptr
index|[
name|xpos
index|]
expr_stmt|;
name|inptr
operator|+=
name|samples_per_clump
expr_stmt|;
block|}
block|}
comment|/* pad each scanline as needed */
for|for
control|(
name|xpos
operator|=
literal|0
init|;
name|xpos
operator|<
name|padding
condition|;
name|xpos
operator|++
control|)
block|{
operator|*
name|outptr
operator|=
name|outptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|outptr
operator|++
expr_stmt|;
block|}
name|clumpoffset
operator|+=
name|hsamp
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|scancount
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|scancount
operator|>=
name|DCTSIZE
condition|)
block|{
name|int
name|n
init|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|max_v_samp_factor
operator|*
name|DCTSIZE
decl_stmt|;
if|if
condition|(
name|TIFFjpeg_write_raw_data
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|ds_buffer
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|->
name|scancount
operator|=
literal|0
expr_stmt|;
block|}
name|tif
operator|->
name|tif_row
operator|+=
name|sp
operator|->
name|v_sampling
expr_stmt|;
name|buf
operator|+=
name|sp
operator|->
name|bytesperline
expr_stmt|;
name|nrows
operator|-=
name|sp
operator|->
name|v_sampling
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Finish up at the end of a strip or tile.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|JPEGPostEncode
name|JPEGPostEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|scancount
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Need to emit a partial bufferload of downsampled data. 		 * Pad the data vertically. 		 */
name|int
name|ci
decl_stmt|,
name|ypos
decl_stmt|,
name|n
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|comp_info
init|;
name|ci
operator|<
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|int
name|vsamp
init|=
name|compptr
operator|->
name|v_samp_factor
decl_stmt|;
name|tsize_t
name|row_width
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|DCTSIZE
operator|*
sizeof|sizeof
argument_list|(
name|JSAMPLE
argument_list|)
decl_stmt|;
for|for
control|(
name|ypos
operator|=
name|sp
operator|->
name|scancount
operator|*
name|vsamp
init|;
name|ypos
operator|<
name|DCTSIZE
operator|*
name|vsamp
condition|;
name|ypos
operator|++
control|)
block|{
name|_TIFFmemcpy
argument_list|(
operator|(
name|tdata_t
operator|)
name|sp
operator|->
name|ds_buffer
index|[
name|ci
index|]
index|[
name|ypos
index|]
argument_list|,
operator|(
name|tdata_t
operator|)
name|sp
operator|->
name|ds_buffer
index|[
name|ci
index|]
index|[
name|ypos
operator|-
literal|1
index|]
argument_list|,
name|row_width
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|=
name|sp
operator|->
name|cinfo
operator|.
name|c
operator|.
name|max_v_samp_factor
operator|*
name|DCTSIZE
expr_stmt|;
if|if
condition|(
name|TIFFjpeg_write_raw_data
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|ds_buffer
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|TIFFjpeg_finish_compress
argument_list|(
name|JState
argument_list|(
name|tif
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|JPEGCleanup
name|JPEGCleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|sp
operator|->
name|vgetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|sp
operator|->
name|vsetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|sp
operator|->
name|printdir
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cinfo_initialized
condition|)
name|TIFFjpeg_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* release libjpeg resources */
if|if
condition|(
name|sp
operator|->
name|jpegtables
condition|)
comment|/* tag value */
name|_TIFFfree
argument_list|(
name|sp
operator|->
name|jpegtables
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_data
argument_list|)
expr_stmt|;
comment|/* release local state */
name|tif
operator|->
name|tif_data
operator|=
name|NULL
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|JPEGResetUpsampled
name|JPEGResetUpsampled
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
comment|/* 	 * Mark whether returned data is up-sampled or not so TIFFStripSize 	 * and TIFFTileSize return values that reflect the true amount of 	 * data. 	 */
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_UPSAMPLED
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
operator|&&
name|sp
operator|->
name|jpegcolormode
operator|==
name|JPEGCOLORMODE_RGB
condition|)
block|{
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_UPSAMPLED
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
operator|!=
literal|1
operator|||
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
empty_stmt|;
comment|/* XXX what about up-sampling? */
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Must recalculate cached tile size in case sampling state changed. 	 * Should we really be doing this now if image size isn't set?  	 */
name|tif
operator|->
name|tif_tilesize
operator|=
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|?
name|TIFFTileSize
argument_list|(
name|tif
argument_list|)
else|:
operator|(
name|tsize_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|JPEGVSetField
name|JPEGVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
decl_stmt|;
name|uint32
name|v32
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_JPEGTABLES
case|:
name|v32
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v32
operator|==
literal|0
condition|)
block|{
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFsetByteArray
argument_list|(
operator|&
name|sp
operator|->
name|jpegtables
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|v32
argument_list|)
expr_stmt|;
name|sp
operator|->
name|jpegtables_length
operator|=
name|v32
expr_stmt|;
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_JPEGQUALITY
case|:
name|sp
operator|->
name|jpegquality
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* pseudo tag */
case|case
name|TIFFTAG_JPEGCOLORMODE
case|:
name|sp
operator|->
name|jpegcolormode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|JPEGResetUpsampled
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* pseudo tag */
case|case
name|TIFFTAG_PHOTOMETRIC
case|:
block|{
name|int
name|ret_value
init|=
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|JPEGResetUpsampled
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
name|ret_value
return|;
block|}
case|case
name|TIFFTAG_JPEGTABLESMODE
case|:
name|sp
operator|->
name|jpegtablesmode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* pseudo tag */
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
comment|/* mark the fact that we have a real ycbcrsubsampling! */
name|sp
operator|->
name|ycbcrsampling_fetched
operator|=
literal|1
expr_stmt|;
comment|/* should we be recomputing upsampling info here? */
return|return
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
case|case
name|TIFFTAG_FAXRECVPARAMS
case|:
name|sp
operator|->
name|recvparams
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXSUBADDRESS
case|:
name|_TIFFsetString
argument_list|(
operator|&
name|sp
operator|->
name|subaddress
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVTIME
case|:
name|sp
operator|->
name|recvtime
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXDCS
case|:
name|_TIFFsetString
argument_list|(
operator|&
name|sp
operator|->
name|faxdcs
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|fip
operator|=
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
operator|)
condition|)
block|{
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|fip
operator|->
name|field_bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_DIRTYDIRECT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in  * the TIFF tags, but still use non-default (2,2) values within the jpeg  * data stream itself.  In order for TIFF applications to work properly  * - for instance to get the strip buffer size right - it is imperative  * that the subsampling be available before we start reading the image  * data normally.  This function will attempt to load the first strip in  * order to get the sampling values from the jpeg data stream.  Various  * hacks are various places are done to ensure this function gets called  * before the td_ycbcrsubsampling values are used from the directory structure,  * including calling TIFFGetField() for the YCBCRSUBSAMPLING field from   * TIFFStripSize(), and the printing code in tif_print.c.   *  * Note that JPEGPreDeocode() will produce a fairly loud warning when the  * discovered sampling does not match the default sampling (2,2) or whatever  * was actually in the tiff tags.   *  * Problems:  *  o This code will cause one whole strip/tile of compressed data to be  *    loaded just to get the tags right, even if the imagery is never read.  *    It would be more efficient to just load a bit of the header, and  *    initialize things from that.   *  * See the bug in bugzilla for details:  *  * http://bugzilla.remotesensing.org/show_bug.cgi?id=168  *  * Frank Warmerdam, July 2002  */
end_comment
begin_function
specifier|static
name|void
DECL|function|JPEGFixupTestSubsampling
name|JPEGFixupTestSubsampling
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHECK_JPEG_YCBCR_SUBSAMPLING
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|JPEGInitializeLibJPEG
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Some JPEG-in-TIFF files don't provide the ycbcrsampling tags,       * and use a sampling schema other than the default 2,2.  To handle      * this we actually have to scan the header of a strip or tile of      * jpeg data to get the sampling.        */
if|if
condition|(
operator|!
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
operator|||
name|sp
operator|->
name|ycbcrsampling_fetched
operator|||
name|td
operator|->
name|td_photometric
operator|!=
name|PHOTOMETRIC_YCBCR
condition|)
return|return;
name|sp
operator|->
name|ycbcrsampling_fetched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TIFFIsTiled
argument_list|(
name|tif
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFFillTile
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFFillStrip
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_YCBCRSUBSAMPLING
argument_list|,
operator|(
name|uint16
operator|)
name|sp
operator|->
name|h_sampling
argument_list|,
operator|(
name|uint16
operator|)
name|sp
operator|->
name|v_sampling
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CHECK_JPEG_YCBCR_SUBSAMPLING */
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|JPEGVGetField
name|JPEGVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_JPEGTABLES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|jpegtables_length
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|jpegtables
expr_stmt|;
break|break;
case|case
name|TIFFTAG_JPEGQUALITY
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|jpegquality
expr_stmt|;
break|break;
case|case
name|TIFFTAG_JPEGCOLORMODE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|jpegcolormode
expr_stmt|;
break|break;
case|case
name|TIFFTAG_JPEGTABLESMODE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|jpegtablesmode
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
name|JPEGFixupTestSubsampling
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
case|case
name|TIFFTAG_FAXRECVPARAMS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|recvparams
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXSUBADDRESS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|subaddress
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXRECVTIME
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|recvtime
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FAXDCS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|faxdcs
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|JPEGPrintDir
name|JPEGPrintDir
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  JPEG Tables: (%lu bytes)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|jpegtables_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_RECVPARAMS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax Receive Parameters: %08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|recvparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_SUBADDRESS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax SubAddress: %s\n"
argument_list|,
name|sp
operator|->
name|subaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_RECVTIME
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax Receive Time: %lu secs\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sp
operator|->
name|recvtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_FAXDCS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Fax DCS: %s\n"
argument_list|,
name|sp
operator|->
name|faxdcs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|JPEGDefaultStripSize
name|JPEGDefaultStripSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|s
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|s
operator|=
call|(
modifier|*
name|sp
operator|->
name|defsparent
call|)
argument_list|(
name|tif
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|td
operator|->
name|td_imagelength
condition|)
name|s
operator|=
name|TIFFroundup
argument_list|(
name|s
argument_list|,
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|JPEGDefaultTileSize
name|JPEGDefaultTileSize
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
modifier|*
name|tw
parameter_list|,
name|uint32
modifier|*
name|th
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
call|(
modifier|*
name|sp
operator|->
name|deftparent
call|)
argument_list|(
name|tif
argument_list|,
name|tw
argument_list|,
name|th
argument_list|)
expr_stmt|;
operator|*
name|tw
operator|=
name|TIFFroundup
argument_list|(
operator|*
name|tw
argument_list|,
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
operator|*
name|th
operator|=
name|TIFFroundup
argument_list|(
operator|*
name|th
argument_list|,
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
operator|*
name|DCTSIZE
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * The JPEG library initialized used to be done in TIFFInitJPEG(), but  * now that we allow a TIFF file to be opened in update mode it is necessary  * to have some way of deciding whether compression or decompression is  * desired other than looking at tif->tif_mode.  We accomplish this by   * examining {TILE/STRIP}BYTECOUNTS to see if there is a non-zero entry.  * If so, we assume decompression is desired.   *  * This is tricky, because TIFFInitJPEG() is called while the directory is  * being read, and generally speaking the BYTECOUNTS tag won't have been read  * at that point.  So we try to defer jpeg library initialization till we  * do have that tag ... basically any access that might require the compressor  * or decompressor that occurs after the reading of the directory.   *  * In an ideal world compressors or decompressors would be setup  * at the point where a single tile or strip was accessed (for read or write)  * so that stuff like update of missing tiles, or replacement of tiles could  * be done. However, we aren't trying to crack that nut just yet ...  *  * NFW, Feb 3rd, 2003.  */
end_comment
begin_function
DECL|function|JPEGInitializeLibJPEG
specifier|static
name|int
name|JPEGInitializeLibJPEG
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|force_encode
parameter_list|,
name|int
name|force_decode
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
init|=
name|JState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|uint32
modifier|*
name|byte_counts
init|=
name|NULL
decl_stmt|;
name|int
name|data_is_empty
init|=
name|TRUE
decl_stmt|;
name|int
name|decompress
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|cinfo_initialized
condition|)
block|{
if|if
condition|(
name|force_encode
operator|&&
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
condition|)
name|TIFFjpeg_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|force_decode
operator|&&
operator|!
name|sp
operator|->
name|cinfo
operator|.
name|comm
operator|.
name|is_decompressor
condition|)
name|TIFFjpeg_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
name|sp
operator|->
name|cinfo_initialized
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Do we have tile data already?  Make sure we initialize the      * the state in decompressor mode if we have tile data, even if we      * are not in read-only file access mode.       */
if|if
condition|(
name|TIFFIsTiled
argument_list|(
name|tif
argument_list|)
operator|&&
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_TILEBYTECOUNTS
argument_list|,
operator|&
name|byte_counts
argument_list|)
operator|&&
name|byte_counts
operator|!=
name|NULL
condition|)
block|{
name|data_is_empty
operator|=
name|byte_counts
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TIFFIsTiled
argument_list|(
name|tif
argument_list|)
operator|&&
name|TIFFGetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_STRIPBYTECOUNTS
argument_list|,
operator|&
name|byte_counts
argument_list|)
operator|&&
name|byte_counts
operator|!=
name|NULL
condition|)
block|{
name|data_is_empty
operator|=
name|byte_counts
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|force_decode
condition|)
name|decompress
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|force_encode
condition|)
name|decompress
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_RDONLY
condition|)
name|decompress
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|data_is_empty
condition|)
name|decompress
operator|=
literal|0
expr_stmt|;
else|else
name|decompress
operator|=
literal|1
expr_stmt|;
comment|/*      * Initialize libjpeg.      */
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
operator|!
name|TIFFjpeg_create_decompress
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFjpeg_create_compress
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|->
name|cinfo_initialized
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFInitJPEG
name|TIFFInitJPEG
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|scheme
parameter_list|)
block|{
name|JPEGState
modifier|*
name|sp
decl_stmt|;
name|assert
argument_list|(
name|scheme
operator|==
name|COMPRESSION_JPEG
argument_list|)
expr_stmt|;
comment|/* 	 * Merge codec-specific tag information. 	 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|jpegFieldInfo
argument_list|,
name|N
argument_list|(
name|jpegFieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitJPEG"
argument_list|,
literal|"Merging JPEG codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocate state block so tag methods have storage to record values. 	 */
name|tif
operator|->
name|tif_data
operator|=
operator|(
name|tidata_t
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|JPEGState
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_data
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFInitJPEG"
argument_list|,
literal|"No space for JPEG state block"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|_TIFFmemset
argument_list|(
name|tif
operator|->
name|tif_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|JPEGState
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|JState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|sp
operator|->
name|tif
operator|=
name|tif
expr_stmt|;
comment|/* back link */
comment|/* 	 * Override parent get/set field methods. 	 */
name|sp
operator|->
name|vgetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|JPEGVGetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|vsetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|JPEGVSetField
expr_stmt|;
comment|/* hook for codec tags */
name|sp
operator|->
name|printdir
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|JPEGPrintDir
expr_stmt|;
comment|/* hook for codec tags */
comment|/* Default values for codec-specific fields */
name|sp
operator|->
name|jpegtables
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|jpegtables_length
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|jpegquality
operator|=
literal|75
expr_stmt|;
comment|/* Default IJG quality */
name|sp
operator|->
name|jpegcolormode
operator|=
name|JPEGCOLORMODE_RAW
expr_stmt|;
name|sp
operator|->
name|jpegtablesmode
operator|=
name|JPEGTABLESMODE_QUANT
operator||
name|JPEGTABLESMODE_HUFF
expr_stmt|;
name|sp
operator|->
name|recvparams
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|subaddress
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|faxdcs
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ycbcrsampling_fetched
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Install codec methods. 	 */
name|tif
operator|->
name|tif_setupdecode
operator|=
name|JPEGSetupDecode
expr_stmt|;
name|tif
operator|->
name|tif_predecode
operator|=
name|JPEGPreDecode
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|JPEGDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|JPEGDecode
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|JPEGDecode
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|JPEGSetupEncode
expr_stmt|;
name|tif
operator|->
name|tif_preencode
operator|=
name|JPEGPreEncode
expr_stmt|;
name|tif
operator|->
name|tif_postencode
operator|=
name|JPEGPostEncode
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|JPEGEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|JPEGEncode
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|JPEGEncode
expr_stmt|;
name|tif
operator|->
name|tif_cleanup
operator|=
name|JPEGCleanup
expr_stmt|;
name|sp
operator|->
name|defsparent
operator|=
name|tif
operator|->
name|tif_defstripsize
expr_stmt|;
name|tif
operator|->
name|tif_defstripsize
operator|=
name|JPEGDefaultStripSize
expr_stmt|;
name|sp
operator|->
name|deftparent
operator|=
name|tif
operator|->
name|tif_deftilesize
expr_stmt|;
name|tif
operator|->
name|tif_deftilesize
operator|=
name|JPEGDefaultTileSize
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_NOBITREV
expr_stmt|;
comment|/* no bit reversal, please */
name|sp
operator|->
name|cinfo_initialized
operator|=
name|FALSE
expr_stmt|;
comment|/*         ** Create a JPEGTables field if no directory has yet been created.          ** We do this just to ensure that sufficient space is reserved for         ** the JPEGTables field.  It will be properly created the right         ** size later.          */
if|if
condition|(
name|tif
operator|->
name|tif_diroff
operator|==
literal|0
condition|)
block|{
DECL|macro|SIZE_OF_JPEGTABLES
define|#
directive|define
name|SIZE_OF_JPEGTABLES
value|2000
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_JPEGTABLES
argument_list|)
expr_stmt|;
name|sp
operator|->
name|jpegtables_length
operator|=
name|SIZE_OF_JPEGTABLES
expr_stmt|;
name|sp
operator|->
name|jpegtables
operator|=
operator|(
name|void
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|sp
operator|->
name|jpegtables_length
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|sp
operator|->
name|jpegtables
argument_list|,
literal|0
argument_list|,
name|SIZE_OF_JPEGTABLES
argument_list|)
expr_stmt|;
DECL|macro|SIZE_OF_JPEGTABLES
undef|#
directive|undef
name|SIZE_OF_JPEGTABLES
block|}
comment|/*          * Mark the TIFFTAG_YCBCRSAMPLES as present even if it is not          * see: JPEGFixupTestSubsampling().          */
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_YCBCRSUBSAMPLING
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* JPEG_SUPPORT */
end_comment
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
