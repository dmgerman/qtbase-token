begin_unit
begin_comment
comment|/* $Id: tif_aux.c,v 1.20 2006/06/08 14:24:13 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1991-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Auxiliary Support Routines.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|"tif_predict.h"
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_function
name|tdata_t
DECL|function|_TIFFCheckRealloc
name|_TIFFCheckRealloc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdata_t
name|buffer
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|tdata_t
name|cp
init|=
name|NULL
decl_stmt|;
name|tsize_t
name|bytes
init|=
name|nmemb
operator|*
name|elem_size
decl_stmt|;
comment|/* 	 * XXX: Check for integer overflow. 	 */
if|if
condition|(
name|nmemb
operator|&&
name|elem_size
operator|&&
name|bytes
operator|/
name|elem_size
operator|==
name|nmemb
condition|)
name|cp
operator|=
name|_TIFFrealloc
argument_list|(
name|buffer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"No space %s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function
begin_function
name|tdata_t
DECL|function|_TIFFCheckMalloc
name|_TIFFCheckMalloc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
return|return
name|_TIFFCheckRealloc
argument_list|(
name|tif
argument_list|,
name|NULL
argument_list|,
name|nmemb
argument_list|,
name|elem_size
argument_list|,
name|what
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFDefaultTransferFunction
name|TIFFDefaultTransferFunction
parameter_list|(
name|TIFFDirectory
modifier|*
name|td
parameter_list|)
block|{
name|uint16
modifier|*
modifier|*
name|tf
init|=
name|td
operator|->
name|td_transferfunction
decl_stmt|;
name|tsize_t
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|tf
index|[
literal|0
index|]
operator|=
name|tf
index|[
literal|1
index|]
operator|=
name|tf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|>=
sizeof|sizeof
argument_list|(
name|tsize_t
argument_list|)
operator|*
literal|8
operator|-
literal|2
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|1
operator|<<
name|td
operator|->
name|td_bitspersample
expr_stmt|;
name|nbytes
operator|=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tf
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|nbytes
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|tf
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|double
name|t
init|=
operator|(
name|double
operator|)
name|i
operator|/
operator|(
operator|(
name|double
operator|)
name|n
operator|-
literal|1.
operator|)
decl_stmt|;
name|tf
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
operator|(
name|uint16
operator|)
name|floor
argument_list|(
literal|65535.
operator|*
name|pow
argument_list|(
name|t
argument_list|,
literal|2.2
argument_list|)
operator|+
literal|.5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_samplesperpixel
operator|-
name|td
operator|->
name|td_extrasamples
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tf
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|nbytes
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|_TIFFmemcpy
argument_list|(
name|tf
index|[
literal|1
index|]
argument_list|,
name|tf
index|[
literal|0
index|]
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tf
index|[
literal|2
index|]
operator|=
operator|(
name|uint16
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|nbytes
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|_TIFFmemcpy
argument_list|(
name|tf
index|[
literal|2
index|]
argument_list|,
name|tf
index|[
literal|0
index|]
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
name|bad
label|:
if|if
condition|(
name|tf
index|[
literal|0
index|]
condition|)
name|_TIFFfree
argument_list|(
name|tf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
index|[
literal|1
index|]
condition|)
name|_TIFFfree
argument_list|(
name|tf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
index|[
literal|2
index|]
condition|)
name|_TIFFfree
argument_list|(
name|tf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tf
index|[
literal|0
index|]
operator|=
name|tf
index|[
literal|1
index|]
operator|=
name|tf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Like TIFFGetField, but return any default  * value if the tag is not present in the directory.  *  * NB:	We use the value in the directory, rather than  *	explcit values so that defaults exist only one  *	place in the library -- in TIFFDefaultDirectory.  */
end_comment
begin_function
name|int
DECL|function|TIFFVGetFieldDefaulted
name|TIFFVGetFieldDefaulted
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
name|TIFFVGetField
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_SUBFILETYPE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_subfiletype
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_BITSPERSAMPLE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_THRESHHOLDING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_threshholding
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_FILLORDER
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_fillorder
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_ORIENTATION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_orientation
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_SAMPLESPERPIXEL
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_ROWSPERSTRIP
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_MINSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_minsamplevalue
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_MAXSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_maxsamplevalue
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_PLANARCONFIG
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_planarconfig
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_RESOLUTIONUNIT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_resolutionunit
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_PREDICTOR
case|:
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
operator|(
name|TIFFPredictorState
operator|*
operator|)
name|tif
operator|->
name|tif_data
decl_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|(
name|uint16
operator|)
name|sp
operator|->
name|predictor
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|TIFFTAG_DOTRANGE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|td
operator|->
name|td_bitspersample
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_INKSET
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|INKSET_CMYK
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TIFFTAG_NUMBEROFINKS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
literal|4
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_EXTRASAMPLES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_extrasamples
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sampleinfo
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_MATTEING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|(
name|td
operator|->
name|td_extrasamples
operator|==
literal|1
operator|&&
name|td
operator|->
name|td_sampleinfo
index|[
literal|0
index|]
operator|==
name|EXTRASAMPLE_ASSOCALPHA
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_TILEDEPTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_tiledepth
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_DATATYPE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sampleformat
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_SAMPLEFORMAT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sampleformat
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_IMAGEDEPTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_imagedepth
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_YCBCRCOEFFICIENTS
case|:
block|{
comment|/* defaults are from CCIR Recommendation 601-1 */
specifier|static
name|float
name|ycbcrcoeffs
index|[]
init|=
block|{
literal|0.299f
block|,
literal|0.587f
block|,
literal|0.114f
block|}
decl_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
operator|*
argument_list|)
operator|=
name|ycbcrcoeffs
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_YCBCRPOSITIONING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrpositioning
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_WHITEPOINT
case|:
block|{
specifier|static
name|float
name|whitepoint
index|[
literal|2
index|]
decl_stmt|;
comment|/* TIFF 6.0 specification tells that it is no default 			   value for the WhitePoint, but AdobePhotoshop TIFF 			   Technical Note tells that it should be CIE D50. */
name|whitepoint
index|[
literal|0
index|]
operator|=
name|D50_X0
operator|/
operator|(
name|D50_X0
operator|+
name|D50_Y0
operator|+
name|D50_Z0
operator|)
expr_stmt|;
name|whitepoint
index|[
literal|1
index|]
operator|=
name|D50_Y0
operator|/
operator|(
name|D50_X0
operator|+
name|D50_Y0
operator|+
name|D50_Z0
operator|)
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
operator|*
argument_list|)
operator|=
name|whitepoint
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|TIFFTAG_TRANSFERFUNCTION
case|:
if|if
condition|(
operator|!
name|td
operator|->
name|td_transferfunction
index|[
literal|0
index|]
operator|&&
operator|!
name|TIFFDefaultTransferFunction
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"No space for \"TransferFunction\" tag"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_samplesperpixel
operator|-
name|td
operator|->
name|td_extrasamples
operator|>
literal|1
condition|)
block|{
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|2
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TIFFTAG_REFERENCEBLACKWHITE
case|:
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|float
name|ycbcr_refblackwhite
index|[]
init|=
block|{
literal|0.0F
block|,
literal|255.0F
block|,
literal|128.0F
block|,
literal|255.0F
block|,
literal|128.0F
block|,
literal|255.0F
block|}
decl_stmt|;
specifier|static
name|float
name|rgb_refblackwhite
index|[
literal|6
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|rgb_refblackwhite
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
literal|0.0F
expr_stmt|;
name|rgb_refblackwhite
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
operator|)
operator|-
literal|1L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_photometric
operator|==
name|PHOTOMETRIC_YCBCR
condition|)
block|{
comment|/* 				 * YCbCr (Class Y) images must have the 				 * ReferenceBlackWhite tag set. Fix the 				 * broken images, which lacks that tag. 				 */
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
operator|*
argument_list|)
operator|=
name|ycbcr_refblackwhite
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Assume RGB (Class R) 				 */
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
operator|*
argument_list|)
operator|=
name|rgb_refblackwhite
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Like TIFFGetField, but return any default  * value if the tag is not present in the directory.  */
end_comment
begin_function
name|int
DECL|function|TIFFGetFieldDefaulted
name|TIFFGetFieldDefaulted
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|ok
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ok
operator|=
name|TIFFVGetFieldDefaulted
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
