begin_unit
begin_comment
comment|/* $Id: tif_predict.c,v 1.11.2.3 2009-01-23 15:57:18 fwarmerdam Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Predictor Tag Support (used by multiple codecs).  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_include
include|#
directive|include
file|"tif_predict.h"
end_include
begin_define
DECL|macro|PredictorState
define|#
directive|define
name|PredictorState
parameter_list|(
name|tif
parameter_list|)
value|((TIFFPredictorState*) (tif)->tif_data)
end_define
begin_function_decl
specifier|static
name|void
name|horAcc8
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|horAcc16
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|horAcc32
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|swabHorAcc16
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|swabHorAcc32
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|horDiff8
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|horDiff16
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|horDiff32
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|fpAcc
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|fpDiff
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PredictorDecodeRow
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PredictorDecodeTile
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PredictorEncodeRow
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|PredictorEncodeTile
parameter_list|(
name|TIFF
modifier|*
parameter_list|,
name|tidata_t
parameter_list|,
name|tsize_t
parameter_list|,
name|tsample_t
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|int
DECL|function|PredictorSetup
name|PredictorSetup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PredictorSetup"
decl_stmt|;
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|predictor
condition|)
comment|/* no differencing */
block|{
case|case
name|PREDICTOR_NONE
case|:
return|return
literal|1
return|;
case|case
name|PREDICTOR_HORIZONTAL
case|:
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|!=
literal|8
operator|&&
name|td
operator|->
name|td_bitspersample
operator|!=
literal|16
operator|&&
name|td
operator|->
name|td_bitspersample
operator|!=
literal|32
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Horizontal differencing \"Predictor\" not supported with %d-bit samples"
argument_list|,
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|PREDICTOR_FLOATINGPOINT
case|:
if|if
condition|(
name|td
operator|->
name|td_sampleformat
operator|!=
name|SAMPLEFORMAT_IEEEFP
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Floating point \"Predictor\" not supported with %d data format"
argument_list|,
name|td
operator|->
name|td_sampleformat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"\"Predictor\" value %d not supported"
argument_list|,
name|sp
operator|->
name|predictor
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sp
operator|->
name|stride
operator|=
operator|(
name|td
operator|->
name|td_planarconfig
operator|==
name|PLANARCONFIG_CONTIG
condition|?
name|td
operator|->
name|td_samplesperpixel
else|:
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Calculate the scanline/tile-width size in bytes. 	 */
if|if
condition|(
name|isTiled
argument_list|(
name|tif
argument_list|)
condition|)
name|sp
operator|->
name|rowsize
operator|=
name|TIFFTileRowSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|rowsize
operator|=
name|TIFFScanlineSize
argument_list|(
name|tif
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PredictorSetupDecode
name|PredictorSetupDecode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|sp
operator|->
name|setupdecode
call|)
argument_list|(
name|tif
argument_list|)
operator|||
operator|!
name|PredictorSetup
argument_list|(
name|tif
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sp
operator|->
name|predictor
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
name|td
operator|->
name|td_bitspersample
condition|)
block|{
case|case
literal|8
case|:
name|sp
operator|->
name|decodepfunc
operator|=
name|horAcc8
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|sp
operator|->
name|decodepfunc
operator|=
name|horAcc16
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|sp
operator|->
name|decodepfunc
operator|=
name|horAcc32
expr_stmt|;
break|break;
block|}
comment|/* 		 * Override default decoding method with one that does the 		 * predictor stuff. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_decoderow
operator|!=
name|PredictorDecodeRow
condition|)
block|{
name|sp
operator|->
name|decoderow
operator|=
name|tif
operator|->
name|tif_decoderow
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|PredictorDecodeRow
expr_stmt|;
name|sp
operator|->
name|decodestrip
operator|=
name|tif
operator|->
name|tif_decodestrip
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|PredictorDecodeTile
expr_stmt|;
name|sp
operator|->
name|decodetile
operator|=
name|tif
operator|->
name|tif_decodetile
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|PredictorDecodeTile
expr_stmt|;
block|}
comment|/* 		 * If the data is horizontally differenced 16-bit data that 		 * requires byte-swapping, then it must be byte swapped before 		 * the accumulation step.  We do this with a special-purpose 		 * routine and override the normal post decoding logic that 		 * the library setup when the directory was read. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|decodepfunc
operator|==
name|horAcc16
condition|)
block|{
name|sp
operator|->
name|decodepfunc
operator|=
name|swabHorAcc16
expr_stmt|;
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|decodepfunc
operator|==
name|horAcc32
condition|)
block|{
name|sp
operator|->
name|decodepfunc
operator|=
name|swabHorAcc32
expr_stmt|;
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|predictor
operator|==
literal|3
condition|)
block|{
name|sp
operator|->
name|decodepfunc
operator|=
name|fpAcc
expr_stmt|;
comment|/* 		 * Override default decoding method with one that does the 		 * predictor stuff. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_decoderow
operator|!=
name|PredictorDecodeRow
condition|)
block|{
name|sp
operator|->
name|decoderow
operator|=
name|tif
operator|->
name|tif_decoderow
expr_stmt|;
name|tif
operator|->
name|tif_decoderow
operator|=
name|PredictorDecodeRow
expr_stmt|;
name|sp
operator|->
name|decodestrip
operator|=
name|tif
operator|->
name|tif_decodestrip
expr_stmt|;
name|tif
operator|->
name|tif_decodestrip
operator|=
name|PredictorDecodeTile
expr_stmt|;
name|sp
operator|->
name|decodetile
operator|=
name|tif
operator|->
name|tif_decodetile
expr_stmt|;
name|tif
operator|->
name|tif_decodetile
operator|=
name|PredictorDecodeTile
expr_stmt|;
block|}
comment|/* 		 * The data should not be swapped outside of the floating 		 * point predictor, the accumulation routine should return 		 * byres in the native order. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
block|}
comment|/* 		 * Allocate buffer to keep the decoded bytes before 		 * rearranging in the ight order 		 */
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PredictorSetupEncode
name|PredictorSetupEncode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|sp
operator|->
name|setupencode
call|)
argument_list|(
name|tif
argument_list|)
operator|||
operator|!
name|PredictorSetup
argument_list|(
name|tif
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sp
operator|->
name|predictor
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
name|td
operator|->
name|td_bitspersample
condition|)
block|{
case|case
literal|8
case|:
name|sp
operator|->
name|encodepfunc
operator|=
name|horDiff8
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|sp
operator|->
name|encodepfunc
operator|=
name|horDiff16
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|sp
operator|->
name|encodepfunc
operator|=
name|horDiff32
expr_stmt|;
break|break;
block|}
comment|/* 		 * Override default encoding method with one that does the 		 * predictor stuff. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_encoderow
operator|!=
name|PredictorEncodeRow
condition|)
block|{
name|sp
operator|->
name|encoderow
operator|=
name|tif
operator|->
name|tif_encoderow
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|PredictorEncodeRow
expr_stmt|;
name|sp
operator|->
name|encodestrip
operator|=
name|tif
operator|->
name|tif_encodestrip
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|PredictorEncodeTile
expr_stmt|;
name|sp
operator|->
name|encodetile
operator|=
name|tif
operator|->
name|tif_encodetile
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|PredictorEncodeTile
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|predictor
operator|==
literal|3
condition|)
block|{
name|sp
operator|->
name|encodepfunc
operator|=
name|fpDiff
expr_stmt|;
comment|/* 		 * Override default encoding method with one that does the 		 * predictor stuff. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_encoderow
operator|!=
name|PredictorEncodeRow
condition|)
block|{
name|sp
operator|->
name|encoderow
operator|=
name|tif
operator|->
name|tif_encoderow
expr_stmt|;
name|tif
operator|->
name|tif_encoderow
operator|=
name|PredictorEncodeRow
expr_stmt|;
name|sp
operator|->
name|encodestrip
operator|=
name|tif
operator|->
name|tif_encodestrip
expr_stmt|;
name|tif
operator|->
name|tif_encodestrip
operator|=
name|PredictorEncodeTile
expr_stmt|;
name|sp
operator|->
name|encodetile
operator|=
name|tif
operator|->
name|tif_encodetile
expr_stmt|;
name|tif
operator|->
name|tif_encodetile
operator|=
name|PredictorEncodeTile
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|REPEAT4
define|#
directive|define
name|REPEAT4
parameter_list|(
name|n
parameter_list|,
name|op
parameter_list|)
define|\
value|switch (n) {		\     default: { int i; for (i = n-4; i> 0; i--) { op; } } \     case 4:  op;		\     case 3:  op;		\     case 2:  op;		\     case 1:  op;		\     case 0:  ;			\     }
end_define
begin_function
specifier|static
name|void
DECL|function|horAcc8
name|horAcc8
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|cp0
decl_stmt|;
if|if
condition|(
name|cc
operator|>
name|stride
condition|)
block|{
name|cc
operator|-=
name|stride
expr_stmt|;
comment|/* 		 * Pipeline the most common cases. 		 */
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|unsigned
name|int
name|cr
init|=
name|cp
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
name|cg
init|=
name|cp
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|cb
init|=
name|cp
index|[
literal|2
index|]
decl_stmt|;
do|do
block|{
name|cc
operator|-=
literal|3
operator|,
name|cp
operator|+=
literal|3
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cr
operator|+=
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cg
operator|+=
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cb
operator|+=
name|cp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|cc
operator|>
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|unsigned
name|int
name|cr
init|=
name|cp
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
name|cg
init|=
name|cp
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|cb
init|=
name|cp
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|ca
init|=
name|cp
index|[
literal|3
index|]
decl_stmt|;
do|do
block|{
name|cc
operator|-=
literal|4
operator|,
name|cp
operator|+=
literal|4
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cr
operator|+=
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cg
operator|+=
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|cb
operator|+=
name|cp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|ca
operator|+=
name|cp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|cc
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|cp[stride] = 					(char) (cp[stride] + *cp); cp++
argument_list|)
name|cc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|cc
operator|>
literal|0
condition|)
do|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|swabHorAcc16
name|swabHorAcc16
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|TIFFSwabArrayOfShort
argument_list|(
name|wp
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|wc
operator|-=
name|stride
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += wp[
literal|0
argument|]; wp++
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horAcc16
name|horAcc16
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint16
modifier|*
name|wp
init|=
operator|(
name|uint16
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|wc
operator|-=
name|stride
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += wp[
literal|0
argument|]; wp++
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|swabHorAcc32
name|swabHorAcc32
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint32
modifier|*
name|wp
init|=
operator|(
name|uint32
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|TIFFSwabArrayOfLong
argument_list|(
name|wp
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|wc
operator|-=
name|stride
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += wp[
literal|0
argument|]; wp++
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horAcc32
name|horAcc32
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint32
modifier|*
name|wp
init|=
operator|(
name|uint32
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|wc
operator|-=
name|stride
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] += wp[
literal|0
argument|]; wp++
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_comment
comment|/*  * Floating point predictor accumulation routine.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|fpAcc
name|fpAcc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint32
name|bps
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_bitspersample
operator|/
literal|8
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
name|bps
decl_stmt|;
name|tsize_t
name|count
init|=
name|cc
decl_stmt|;
name|uint8
modifier|*
name|cp
init|=
operator|(
name|uint8
operator|*
operator|)
name|cp0
decl_stmt|;
name|uint8
modifier|*
name|tmp
init|=
operator|(
name|uint8
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|cc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return;
while|while
condition|(
name|count
operator|>
name|stride
condition|)
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|cp[stride] += cp[
literal|0
argument|]; cp++
argument_list|)
name|count
operator|-=
name|stride
expr_stmt|;
block|}
name|_TIFFmemcpy
argument_list|(
name|tmp
argument_list|,
name|cp0
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|uint8
operator|*
operator|)
name|cp0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|wc
condition|;
name|count
operator|++
control|)
block|{
name|uint32
name|byte
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|bps
condition|;
name|byte
operator|++
control|)
block|{
if|#
directive|if
name|WORDS_BIGENDIAN
name|cp
index|[
name|bps
operator|*
name|count
operator|+
name|byte
index|]
operator|=
name|tmp
index|[
name|byte
operator|*
name|wc
operator|+
name|count
index|]
expr_stmt|;
else|#
directive|else
name|cp
index|[
name|bps
operator|*
name|count
operator|+
name|byte
index|]
operator|=
name|tmp
index|[
operator|(
name|bps
operator|-
name|byte
operator|-
literal|1
operator|)
operator|*
name|wc
operator|+
name|count
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|_TIFFfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Decode a scanline and apply the predictor routine.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PredictorDecodeRow
name|PredictorDecodeRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op0
parameter_list|,
name|tsize_t
name|occ0
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|decoderow
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|decodepfunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|sp
operator|->
name|decoderow
call|)
argument_list|(
name|tif
argument_list|,
name|op0
argument_list|,
name|occ0
argument_list|,
name|s
argument_list|)
condition|)
block|{
call|(
modifier|*
name|sp
operator|->
name|decodepfunc
call|)
argument_list|(
name|tif
argument_list|,
name|op0
argument_list|,
name|occ0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Decode a tile/strip and apply the predictor routine.  * Note that horizontal differencing must be done on a  * row-by-row basis.  The width of a "row" has already  * been calculated at pre-decode time according to the  * strip/tile dimensions.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|PredictorDecodeTile
name|PredictorDecodeTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|op0
parameter_list|,
name|tsize_t
name|occ0
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|decodetile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|sp
operator|->
name|decodetile
call|)
argument_list|(
name|tif
argument_list|,
name|op0
argument_list|,
name|occ0
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|tsize_t
name|rowsize
init|=
name|sp
operator|->
name|rowsize
decl_stmt|;
name|assert
argument_list|(
name|rowsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|decodepfunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|long
operator|)
name|occ0
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|sp
operator|->
name|decodepfunc
call|)
argument_list|(
name|tif
argument_list|,
name|op0
argument_list|,
operator|(
name|tsize_t
operator|)
name|rowsize
argument_list|)
expr_stmt|;
name|occ0
operator|-=
name|rowsize
expr_stmt|;
name|op0
operator|+=
name|rowsize
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horDiff8
name|horDiff8
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|stride
init|=
name|sp
operator|->
name|stride
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|cp0
decl_stmt|;
if|if
condition|(
name|cc
operator|>
name|stride
condition|)
block|{
name|cc
operator|-=
name|stride
expr_stmt|;
comment|/* 		 * Pipeline the most common cases. 		 */
if|if
condition|(
name|stride
operator|==
literal|3
condition|)
block|{
name|int
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|;
name|int
name|r2
init|=
name|cp
index|[
literal|0
index|]
decl_stmt|;
name|int
name|g2
init|=
name|cp
index|[
literal|1
index|]
decl_stmt|;
name|int
name|b2
init|=
name|cp
index|[
literal|2
index|]
decl_stmt|;
do|do
block|{
name|r1
operator|=
name|cp
index|[
literal|3
index|]
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
name|r1
operator|-
name|r2
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|cp
index|[
literal|4
index|]
expr_stmt|;
name|cp
index|[
literal|4
index|]
operator|=
name|g1
operator|-
name|g2
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|cp
index|[
literal|5
index|]
expr_stmt|;
name|cp
index|[
literal|5
index|]
operator|=
name|b1
operator|-
name|b2
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
do|while
condition|(
call|(
name|int32
call|)
argument_list|(
name|cc
operator|-=
literal|3
argument_list|)
operator|>
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|stride
operator|==
literal|4
condition|)
block|{
name|int
name|r1
decl_stmt|,
name|g1
decl_stmt|,
name|b1
decl_stmt|,
name|a1
decl_stmt|;
name|int
name|r2
init|=
name|cp
index|[
literal|0
index|]
decl_stmt|;
name|int
name|g2
init|=
name|cp
index|[
literal|1
index|]
decl_stmt|;
name|int
name|b2
init|=
name|cp
index|[
literal|2
index|]
decl_stmt|;
name|int
name|a2
init|=
name|cp
index|[
literal|3
index|]
decl_stmt|;
do|do
block|{
name|r1
operator|=
name|cp
index|[
literal|4
index|]
expr_stmt|;
name|cp
index|[
literal|4
index|]
operator|=
name|r1
operator|-
name|r2
expr_stmt|;
name|r2
operator|=
name|r1
expr_stmt|;
name|g1
operator|=
name|cp
index|[
literal|5
index|]
expr_stmt|;
name|cp
index|[
literal|5
index|]
operator|=
name|g1
operator|-
name|g2
expr_stmt|;
name|g2
operator|=
name|g1
expr_stmt|;
name|b1
operator|=
name|cp
index|[
literal|6
index|]
expr_stmt|;
name|cp
index|[
literal|6
index|]
operator|=
name|b1
operator|-
name|b2
expr_stmt|;
name|b2
operator|=
name|b1
expr_stmt|;
name|a1
operator|=
name|cp
index|[
literal|7
index|]
expr_stmt|;
name|cp
index|[
literal|7
index|]
operator|=
name|a1
operator|-
name|a2
expr_stmt|;
name|a2
operator|=
name|a1
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
call|(
name|int32
call|)
argument_list|(
name|cc
operator|-=
literal|4
argument_list|)
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
name|cp
operator|+=
name|cc
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|cp[stride] -= cp[
literal|0
argument|]; cp--
argument_list|)
block|}
do|while
condition|(
call|(
name|int32
call|)
argument_list|(
name|cc
operator|-=
name|stride
argument_list|)
operator|>
literal|0
condition|)
do|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horDiff16
name|horDiff16
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|stride
init|=
name|sp
operator|->
name|stride
decl_stmt|;
name|int16
modifier|*
name|wp
init|=
operator|(
name|int16
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|wc
operator|-=
name|stride
expr_stmt|;
name|wp
operator|+=
name|wc
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] -= wp[
literal|0
argument|]; wp--
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|horDiff32
name|horDiff32
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|tsize_t
name|stride
init|=
name|sp
operator|->
name|stride
decl_stmt|;
name|int32
modifier|*
name|wp
init|=
operator|(
name|int32
operator|*
operator|)
name|cp0
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|wc
operator|>
name|stride
condition|)
block|{
name|wc
operator|-=
name|stride
expr_stmt|;
name|wp
operator|+=
name|wc
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|wp[stride] -= wp[
literal|0
argument|]; wp--
argument_list|)
name|wc
operator|-=
name|stride
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|int32
operator|)
name|wc
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function
begin_comment
comment|/*  * Floating point predictor differencing routine.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|fpDiff
name|fpDiff
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|cp0
parameter_list|,
name|tsize_t
name|cc
parameter_list|)
block|{
name|tsize_t
name|stride
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
operator|->
name|stride
decl_stmt|;
name|uint32
name|bps
init|=
name|tif
operator|->
name|tif_dir
operator|.
name|td_bitspersample
operator|/
literal|8
decl_stmt|;
name|tsize_t
name|wc
init|=
name|cc
operator|/
name|bps
decl_stmt|;
name|tsize_t
name|count
decl_stmt|;
name|uint8
modifier|*
name|cp
init|=
operator|(
name|uint8
operator|*
operator|)
name|cp0
decl_stmt|;
name|uint8
modifier|*
name|tmp
init|=
operator|(
name|uint8
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|cc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return;
name|_TIFFmemcpy
argument_list|(
name|tmp
argument_list|,
name|cp0
argument_list|,
name|cc
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|wc
condition|;
name|count
operator|++
control|)
block|{
name|uint32
name|byte
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|bps
condition|;
name|byte
operator|++
control|)
block|{
if|#
directive|if
name|WORDS_BIGENDIAN
name|cp
index|[
name|byte
operator|*
name|wc
operator|+
name|count
index|]
operator|=
name|tmp
index|[
name|bps
operator|*
name|count
operator|+
name|byte
index|]
expr_stmt|;
else|#
directive|else
name|cp
index|[
operator|(
name|bps
operator|-
name|byte
operator|-
literal|1
operator|)
operator|*
name|wc
operator|+
name|count
index|]
operator|=
name|tmp
index|[
name|bps
operator|*
name|count
operator|+
name|byte
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|_TIFFfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|uint8
operator|*
operator|)
name|cp0
expr_stmt|;
name|cp
operator|+=
name|cc
operator|-
name|stride
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
name|cc
init|;
name|count
operator|>
name|stride
condition|;
name|count
operator|-=
name|stride
control|)
name|REPEAT4
argument_list|(
argument|stride
argument_list|,
argument|cp[stride] -= cp[
literal|0
argument|]; cp--
argument_list|)
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PredictorEncodeRow
name|PredictorEncodeRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp
parameter_list|,
name|tsize_t
name|cc
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|encodepfunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|encoderow
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX horizontal differencing alters user's data XXX */
call|(
modifier|*
name|sp
operator|->
name|encodepfunc
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|cc
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|sp
operator|->
name|encoderow
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|cc
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PredictorEncodeTile
name|PredictorEncodeTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tidata_t
name|bp0
parameter_list|,
name|tsize_t
name|cc0
parameter_list|,
name|tsample_t
name|s
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"PredictorEncodeTile"
decl_stmt|;
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|uint8
modifier|*
name|working_copy
decl_stmt|;
name|tsize_t
name|cc
init|=
name|cc0
decl_stmt|,
name|rowsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|result_code
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|encodepfunc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|encodetile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*           * Do predictor manipulation in a working buffer to avoid altering          * the callers buffer. http://trac.osgeo.org/gdal/ticket/1965          */
name|working_copy
operator|=
operator|(
name|uint8
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|cc0
argument_list|)
expr_stmt|;
if|if
condition|(
name|working_copy
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Out of memory allocating %d byte temp buffer."
argument_list|,
name|cc0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|working_copy
argument_list|,
name|bp0
argument_list|,
name|cc0
argument_list|)
expr_stmt|;
name|bp
operator|=
name|working_copy
expr_stmt|;
name|rowsize
operator|=
name|sp
operator|->
name|rowsize
expr_stmt|;
name|assert
argument_list|(
name|rowsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|cc0
operator|%
name|rowsize
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cc
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|sp
operator|->
name|encodepfunc
call|)
argument_list|(
name|tif
argument_list|,
name|bp
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
name|cc
operator|-=
name|rowsize
expr_stmt|;
name|bp
operator|+=
name|rowsize
expr_stmt|;
block|}
name|result_code
operator|=
call|(
modifier|*
name|sp
operator|->
name|encodetile
call|)
argument_list|(
name|tif
argument_list|,
name|working_copy
argument_list|,
name|cc0
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|_TIFFfree
argument_list|(
name|working_copy
argument_list|)
expr_stmt|;
return|return
name|result_code
return|;
block|}
end_function
begin_define
DECL|macro|FIELD_PREDICTOR
define|#
directive|define
name|FIELD_PREDICTOR
value|(FIELD_CODEC+0)
end_define
begin_comment
DECL|macro|FIELD_PREDICTOR
comment|/* XXX */
end_comment
begin_decl_stmt
DECL|variable|predictFieldInfo
specifier|static
specifier|const
name|TIFFFieldInfo
name|predictFieldInfo
index|[]
init|=
block|{
block|{
name|TIFFTAG_PREDICTOR
block|,
literal|1
block|,
literal|1
block|,
name|TIFF_SHORT
block|,
name|FIELD_PREDICTOR
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|"Predictor"
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|int
DECL|function|PredictorVSetField
name|PredictorVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|vsetparent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_PREDICTOR
case|:
name|sp
operator|->
name|predictor
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_PREDICTOR
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vsetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_DIRTYDIRECT
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|PredictorVGetField
name|PredictorVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|->
name|vgetparent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_PREDICTOR
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|sp
operator|->
name|predictor
expr_stmt|;
break|break;
default|default:
return|return
call|(
modifier|*
name|sp
operator|->
name|vgetparent
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|PredictorPrintDir
name|PredictorPrintDir
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_PREDICTOR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"  Predictor: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|predictor
condition|)
block|{
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"none "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"horizontal differencing "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"floating point predictor "
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%u (0x%x)\n"
argument_list|,
name|sp
operator|->
name|predictor
argument_list|,
name|sp
operator|->
name|predictor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|printdir
condition|)
call|(
modifier|*
name|sp
operator|->
name|printdir
call|)
argument_list|(
name|tif
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFPredictorInit
name|TIFFPredictorInit
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Merge codec-specific tag information. 	 */
if|if
condition|(
operator|!
name|_TIFFMergeFieldInfo
argument_list|(
name|tif
argument_list|,
name|predictFieldInfo
argument_list|,
name|TIFFArrayCount
argument_list|(
name|predictFieldInfo
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFPredictorInit"
argument_list|,
literal|"Merging Predictor codec-specific tags failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Override parent get/set field methods. 	 */
name|sp
operator|->
name|vgetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|PredictorVGetField
expr_stmt|;
comment|/* hook for predictor tag */
name|sp
operator|->
name|vsetparent
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|PredictorVSetField
expr_stmt|;
comment|/* hook for predictor tag */
name|sp
operator|->
name|printdir
operator|=
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|PredictorPrintDir
expr_stmt|;
comment|/* hook for predictor tag */
name|sp
operator|->
name|setupdecode
operator|=
name|tif
operator|->
name|tif_setupdecode
expr_stmt|;
name|tif
operator|->
name|tif_setupdecode
operator|=
name|PredictorSetupDecode
expr_stmt|;
name|sp
operator|->
name|setupencode
operator|=
name|tif
operator|->
name|tif_setupencode
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|PredictorSetupEncode
expr_stmt|;
name|sp
operator|->
name|predictor
operator|=
literal|1
expr_stmt|;
comment|/* default value */
name|sp
operator|->
name|encodepfunc
operator|=
name|NULL
expr_stmt|;
comment|/* no predictor routine */
name|sp
operator|->
name|decodepfunc
operator|=
name|NULL
expr_stmt|;
comment|/* no predictor routine */
return|return
literal|1
return|;
block|}
end_function
begin_function
name|int
DECL|function|TIFFPredictorCleanup
name|TIFFPredictorCleanup
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFPredictorState
modifier|*
name|sp
init|=
name|PredictorState
argument_list|(
name|tif
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|sp
operator|->
name|vgetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|sp
operator|->
name|vsetparent
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|sp
operator|->
name|printdir
expr_stmt|;
name|tif
operator|->
name|tif_setupdecode
operator|=
name|sp
operator|->
name|setupdecode
expr_stmt|;
name|tif
operator|->
name|tif_setupencode
operator|=
name|sp
operator|->
name|setupencode
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
