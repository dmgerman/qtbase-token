begin_unit
begin_comment
comment|/* $Id: tif_dir.c,v 1.75.2.2 2009-01-01 00:10:43 bfriesen Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  *  * Directory Tag Get& Set Routines.  * (and also some miscellaneous stuff)  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_comment
comment|/*  * These are used in the backwards compatibility code...  */
end_comment
begin_define
DECL|macro|DATATYPE_VOID
define|#
directive|define
name|DATATYPE_VOID
value|0
end_define
begin_comment
DECL|macro|DATATYPE_VOID
comment|/* !untyped data */
end_comment
begin_define
DECL|macro|DATATYPE_INT
define|#
directive|define
name|DATATYPE_INT
value|1
end_define
begin_comment
DECL|macro|DATATYPE_INT
comment|/* !signed integer data */
end_comment
begin_define
DECL|macro|DATATYPE_UINT
define|#
directive|define
name|DATATYPE_UINT
value|2
end_define
begin_comment
DECL|macro|DATATYPE_UINT
comment|/* !unsigned integer data */
end_comment
begin_define
DECL|macro|DATATYPE_IEEEFP
define|#
directive|define
name|DATATYPE_IEEEFP
value|3
end_define
begin_comment
DECL|macro|DATATYPE_IEEEFP
comment|/* !IEEE floating point data */
end_comment
begin_function
specifier|static
name|void
DECL|function|setByteArray
name|setByteArray
parameter_list|(
name|void
modifier|*
modifier|*
name|vpp
parameter_list|,
name|void
modifier|*
name|vp
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|elem_size
parameter_list|)
block|{
if|if
condition|(
operator|*
name|vpp
condition|)
name|_TIFFfree
argument_list|(
operator|*
name|vpp
argument_list|)
operator|,
operator|*
name|vpp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|tsize_t
name|bytes
init|=
name|nmemb
operator|*
name|elem_size
decl_stmt|;
if|if
condition|(
name|elem_size
operator|&&
name|bytes
operator|/
name|elem_size
operator|==
name|nmemb
condition|)
operator|*
name|vpp
operator|=
operator|(
name|void
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vpp
condition|)
name|_TIFFmemcpy
argument_list|(
operator|*
name|vpp
argument_list|,
name|vp
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_TIFFsetByteArray
name|void
name|_TIFFsetByteArray
parameter_list|(
name|void
modifier|*
modifier|*
name|vpp
parameter_list|,
name|void
modifier|*
name|vp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
name|vpp
argument_list|,
name|vp
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetString
name|void
name|_TIFFsetString
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetNString
name|void
name|_TIFFsetNString
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetShortArray
name|void
name|_TIFFsetShortArray
parameter_list|(
name|uint16
modifier|*
modifier|*
name|wpp
parameter_list|,
name|uint16
modifier|*
name|wp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|wpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|wp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetLongArray
name|void
name|_TIFFsetLongArray
parameter_list|(
name|uint32
modifier|*
modifier|*
name|lpp
parameter_list|,
name|uint32
modifier|*
name|lp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|lpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetFloatArray
name|void
name|_TIFFsetFloatArray
parameter_list|(
name|float
modifier|*
modifier|*
name|fpp
parameter_list|,
name|float
modifier|*
name|fp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|fpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_TIFFsetDoubleArray
name|void
name|_TIFFsetDoubleArray
parameter_list|(
name|double
modifier|*
modifier|*
name|dpp
parameter_list|,
name|double
modifier|*
name|dp
parameter_list|,
name|uint32
name|n
parameter_list|)
block|{
name|setByteArray
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|dpp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Install extra samples information.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|setExtraSamples
name|setExtraSamples
parameter_list|(
name|TIFFDirectory
modifier|*
name|td
parameter_list|,
name|va_list
name|ap
parameter_list|,
name|uint32
modifier|*
name|v
parameter_list|)
block|{
comment|/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
DECL|macro|EXTRASAMPLE_COREL_UNASSALPHA
define|#
directive|define
name|EXTRASAMPLE_COREL_UNASSALPHA
value|999
name|uint16
modifier|*
name|va
decl_stmt|;
name|uint32
name|i
decl_stmt|;
operator|*
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint16
operator|)
operator|*
name|v
operator|>
name|td
operator|->
name|td_samplesperpixel
condition|)
return|return
literal|0
return|;
name|va
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|>
literal|0
operator|&&
name|va
operator|==
name|NULL
condition|)
comment|/* typically missing param */
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|v
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|va
index|[
name|i
index|]
operator|>
name|EXTRASAMPLE_UNASSALPHA
condition|)
block|{
comment|/* 			 * XXX: Corel Draw is known to produce incorrect 			 * ExtraSamples tags which must be patched here if we 			 * want to be able to open some of the damaged TIFF 			 * files:  			 */
if|if
condition|(
name|va
index|[
name|i
index|]
operator|==
name|EXTRASAMPLE_COREL_UNASSALPHA
condition|)
name|va
index|[
name|i
index|]
operator|=
name|EXTRASAMPLE_UNASSALPHA
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
block|}
name|td
operator|->
name|td_extrasamples
operator|=
operator|(
name|uint16
operator|)
operator|*
name|v
expr_stmt|;
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_sampleinfo
argument_list|,
name|va
argument_list|,
name|td
operator|->
name|td_extrasamples
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
DECL|macro|EXTRASAMPLE_COREL_UNASSALPHA
undef|#
directive|undef
name|EXTRASAMPLE_COREL_UNASSALPHA
block|}
end_function
begin_function
specifier|static
name|uint32
DECL|function|checkInkNamesString
name|checkInkNamesString
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|slen
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|uint16
name|i
init|=
name|td
operator|->
name|td_samplesperpixel
decl_stmt|;
if|if
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ep
init|=
name|s
operator|+
name|slen
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
init|=
name|s
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|cp
operator|>=
name|ep
condition|)
goto|goto
name|bad
goto|;
name|cp
operator|++
expr_stmt|;
comment|/* skip \0 */
block|}
return|return
operator|(
name|cp
operator|-
name|s
operator|)
return|;
block|}
name|bad
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFSetField"
argument_list|,
literal|"%s: Invalid InkNames value; expecting %d names, found %d"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|td
operator|->
name|td_samplesperpixel
argument_list|,
name|td
operator|->
name|td_samplesperpixel
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|_TIFFVSetField
name|_TIFFVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"_TIFFVSetField"
decl_stmt|;
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
name|uint32
name|v32
decl_stmt|,
name|i
decl_stmt|,
name|v
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_SUBFILETYPE
case|:
name|td
operator|->
name|td_subfiletype
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGEWIDTH
case|:
name|td
operator|->
name|td_imagewidth
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGELENGTH
case|:
name|td
operator|->
name|td_imagelength
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_BITSPERSAMPLE
case|:
name|td
operator|->
name|td_bitspersample
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* 		 * If the data require post-decoding processing to byte-swap 		 * samples, set it up here.  Note that since tags are required 		 * to be ordered, compression code can override this behaviour 		 * in the setup method if it wants to roll the post decoding 		 * work in with its normal work. 		 */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|==
literal|16
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab16BitData
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|==
literal|24
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab24BitData
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|==
literal|32
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab32BitData
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|==
literal|64
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab64BitData
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|td_bitspersample
operator|==
literal|128
condition|)
comment|/* two 64's */
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab64BitData
expr_stmt|;
block|}
break|break;
case|case
name|TIFFTAG_COMPRESSION
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* 		 * If we're changing the compression scheme, the notify the 		 * previous module so that it can cleanup any state it's 		 * setup. 		 */
if|if
condition|(
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_COMPRESSION
argument_list|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_compression
operator|==
name|v
condition|)
break|break;
call|(
modifier|*
name|tif
operator|->
name|tif_cleanup
call|)
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_CODERSETUP
expr_stmt|;
block|}
comment|/* 		 * Setup new compression routine state. 		 */
if|if
condition|(
operator|(
name|status
operator|=
name|TIFFSetCompressionScheme
argument_list|(
name|tif
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|td
operator|->
name|td_compression
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PHOTOMETRIC
case|:
name|td
operator|->
name|td_photometric
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_THRESHHOLDING
case|:
name|td
operator|->
name|td_threshholding
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FILLORDER
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|FILLORDER_LSB2MSB
operator|&&
name|v
operator|!=
name|FILLORDER_MSB2LSB
condition|)
goto|goto
name|badvalue
goto|;
name|td
operator|->
name|td_fillorder
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_ORIENTATION
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|ORIENTATION_TOPLEFT
operator|||
name|ORIENTATION_LEFTBOT
operator|<
name|v
condition|)
goto|goto
name|badvalue
goto|;
else|else
name|td
operator|->
name|td_orientation
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SAMPLESPERPIXEL
case|:
comment|/* XXX should cross check -- e.g. if pallette, then 1 */
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
goto|goto
name|badvalue
goto|;
name|td
operator|->
name|td_samplesperpixel
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_ROWSPERSTRIP
case|:
name|v32
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v32
operator|==
literal|0
condition|)
goto|goto
name|badvalue32
goto|;
name|td
operator|->
name|td_rowsperstrip
operator|=
name|v32
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|FIELD_TILEDIMENSIONS
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_tilelength
operator|=
name|v32
expr_stmt|;
name|td
operator|->
name|td_tilewidth
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
block|}
break|break;
case|case
name|TIFFTAG_MINSAMPLEVALUE
case|:
name|td
operator|->
name|td_minsamplevalue
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_MAXSAMPLEVALUE
case|:
name|td
operator|->
name|td_maxsamplevalue
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SMINSAMPLEVALUE
case|:
name|td
operator|->
name|td_sminsamplevalue
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SMAXSAMPLEVALUE
case|:
name|td
operator|->
name|td_smaxsamplevalue
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_XRESOLUTION
case|:
name|td
operator|->
name|td_xresolution
operator|=
operator|(
name|float
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YRESOLUTION
case|:
name|td
operator|->
name|td_yresolution
operator|=
operator|(
name|float
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PLANARCONFIG
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|PLANARCONFIG_CONTIG
operator|&&
name|v
operator|!=
name|PLANARCONFIG_SEPARATE
condition|)
goto|goto
name|badvalue
goto|;
name|td
operator|->
name|td_planarconfig
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_XPOSITION
case|:
name|td
operator|->
name|td_xposition
operator|=
operator|(
name|float
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YPOSITION
case|:
name|td
operator|->
name|td_yposition
operator|=
operator|(
name|float
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_RESOLUTIONUNIT
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|RESUNIT_NONE
operator|||
name|RESUNIT_CENTIMETER
operator|<
name|v
condition|)
goto|goto
name|badvalue
goto|;
name|td
operator|->
name|td_resolutionunit
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PAGENUMBER
case|:
name|td
operator|->
name|td_pagenumber
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pagenumber
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_HALFTONEHINTS
case|:
name|td
operator|->
name|td_halftonehints
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_halftonehints
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_COLORMAP
case|:
name|v32
operator|=
call|(
name|uint32
call|)
argument_list|(
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_colormap
index|[
literal|0
index|]
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
argument_list|,
name|v32
argument_list|)
expr_stmt|;
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_colormap
index|[
literal|1
index|]
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
argument_list|,
name|v32
argument_list|)
expr_stmt|;
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_colormap
index|[
literal|2
index|]
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
argument_list|,
name|v32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_EXTRASAMPLES
case|:
if|if
condition|(
operator|!
name|setExtraSamples
argument_list|(
name|td
argument_list|,
name|ap
argument_list|,
operator|&
name|v
argument_list|)
condition|)
goto|goto
name|badvalue
goto|;
break|break;
case|case
name|TIFFTAG_MATTEING
case|:
name|td
operator|->
name|td_extrasamples
operator|=
call|(
name|uint16
call|)
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_extrasamples
condition|)
block|{
name|uint16
name|sv
init|=
name|EXTRASAMPLE_ASSOCALPHA
decl_stmt|;
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_sampleinfo
argument_list|,
operator|&
name|sv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFFTAG_TILEWIDTH
case|:
name|v32
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v32
operator|%
literal|16
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|!=
name|O_RDONLY
condition|)
goto|goto
name|badvalue32
goto|;
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Nonstandard tile width %d, convert file"
argument_list|,
name|v32
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_tilewidth
operator|=
name|v32
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_ISTILED
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TILELENGTH
case|:
name|v32
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v32
operator|%
literal|16
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|!=
name|O_RDONLY
condition|)
goto|goto
name|badvalue32
goto|;
name|TIFFWarningExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
literal|"Nonstandard tile length %d, convert file"
argument_list|,
name|v32
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_tilelength
operator|=
name|v32
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_ISTILED
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TILEDEPTH
case|:
name|v32
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v32
operator|==
literal|0
condition|)
goto|goto
name|badvalue32
goto|;
name|td
operator|->
name|td_tiledepth
operator|=
name|v32
expr_stmt|;
break|break;
case|case
name|TIFFTAG_DATATYPE
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|DATATYPE_VOID
case|:
name|v
operator|=
name|SAMPLEFORMAT_VOID
expr_stmt|;
break|break;
case|case
name|DATATYPE_INT
case|:
name|v
operator|=
name|SAMPLEFORMAT_INT
expr_stmt|;
break|break;
case|case
name|DATATYPE_UINT
case|:
name|v
operator|=
name|SAMPLEFORMAT_UINT
expr_stmt|;
break|break;
case|case
name|DATATYPE_IEEEFP
case|:
name|v
operator|=
name|SAMPLEFORMAT_IEEEFP
expr_stmt|;
break|break;
default|default:
goto|goto
name|badvalue
goto|;
block|}
name|td
operator|->
name|td_sampleformat
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SAMPLEFORMAT
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|SAMPLEFORMAT_UINT
operator|||
name|SAMPLEFORMAT_COMPLEXIEEEFP
operator|<
name|v
condition|)
goto|goto
name|badvalue
goto|;
name|td
operator|->
name|td_sampleformat
operator|=
operator|(
name|uint16
operator|)
name|v
expr_stmt|;
comment|/*  Try to fix up the SWAB function for complex data. */
if|if
condition|(
name|td
operator|->
name|td_sampleformat
operator|==
name|SAMPLEFORMAT_COMPLEXINT
operator|&&
name|td
operator|->
name|td_bitspersample
operator|==
literal|32
operator|&&
name|tif
operator|->
name|tif_postdecode
operator|==
name|_TIFFSwab32BitData
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab16BitData
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|td
operator|->
name|td_sampleformat
operator|==
name|SAMPLEFORMAT_COMPLEXINT
operator|||
name|td
operator|->
name|td_sampleformat
operator|==
name|SAMPLEFORMAT_COMPLEXIEEEFP
operator|)
operator|&&
name|td
operator|->
name|td_bitspersample
operator|==
literal|64
operator|&&
name|tif
operator|->
name|tif_postdecode
operator|==
name|_TIFFSwab64BitData
condition|)
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFSwab32BitData
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGEDEPTH
case|:
name|td
operator|->
name|td_imagedepth
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SUBIFD
case|:
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_INSUBIFD
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_nsubifd
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_TIFFsetLongArray
argument_list|(
operator|&
name|td
operator|->
name|td_subifd
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_nsubifd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Sorry, cannot nest SubIFDs"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|TIFFTAG_YCBCRPOSITIONING
case|:
name|td
operator|->
name|td_ycbcrpositioning
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
operator|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TRANSFERFUNCTION
case|:
name|v
operator|=
operator|(
name|td
operator|->
name|td_samplesperpixel
operator|-
name|td
operator|->
name|td_extrasamples
operator|)
operator|>
literal|1
condition|?
literal|3
else|:
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|v
condition|;
name|i
operator|++
control|)
name|_TIFFsetShortArray
argument_list|(
operator|&
name|td
operator|->
name|td_transferfunction
index|[
name|i
index|]
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
argument_list|,
literal|1L
operator|<<
name|td
operator|->
name|td_bitspersample
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_INKNAMES
case|:
name|v
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|v
operator|=
name|checkInkNamesString
argument_list|(
name|tif
argument_list|,
name|v
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|status
operator|=
name|v
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|_TIFFsetNString
argument_list|(
operator|&
name|td
operator|->
name|td_inknames
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_inknameslen
operator|=
name|v
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|TIFFTagValue
modifier|*
name|tv
decl_stmt|;
name|int
name|tv_size
decl_stmt|,
name|iCustom
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
init|=
name|_TIFFFindFieldInfo
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|TIFF_ANY
argument_list|)
decl_stmt|;
comment|/* 	     * This can happen if multiple images are open with different 	     * codecs which have private tags.  The global tag information 	     * table may then have tags that are valid for one file but not 	     * the other. If the client tries to set a tag that is not valid 	     * for the image's codec then we'll arrive here.  This 	     * happens, for example, when tiffcp is used to convert between 	     * compression schemes and codec-specific tags are blindly copied.              */
if|if
condition|(
name|fip
operator|==
name|NULL
operator|||
name|fip
operator|->
name|field_bit
operator|!=
name|FIELD_CUSTOM
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Invalid %stag \"%s\" (not supported by codec)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|isPseudoTag
argument_list|(
name|tag
argument_list|)
condition|?
literal|"pseudo-"
else|:
literal|""
argument_list|,
name|fip
condition|?
name|fip
operator|->
name|field_name
else|:
literal|"Unknown"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*              * Find the existing entry for this custom value.              */
name|tv
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|iCustom
operator|=
literal|0
init|;
name|iCustom
operator|<
name|td
operator|->
name|td_customValueCount
condition|;
name|iCustom
operator|++
control|)
block|{
if|if
condition|(
name|td
operator|->
name|td_customValues
index|[
name|iCustom
index|]
operator|.
name|info
operator|->
name|field_tag
operator|==
name|tag
condition|)
block|{
name|tv
operator|=
name|td
operator|->
name|td_customValues
operator|+
name|iCustom
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|value
operator|!=
name|NULL
condition|)
block|{
name|_TIFFfree
argument_list|(
name|tv
operator|->
name|value
argument_list|)
expr_stmt|;
name|tv
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/*              * Grow the custom list if the entry was not found.              */
if|if
condition|(
name|tv
operator|==
name|NULL
condition|)
block|{
name|TIFFTagValue
modifier|*
name|new_customValues
decl_stmt|;
name|td
operator|->
name|td_customValueCount
operator|++
expr_stmt|;
name|new_customValues
operator|=
operator|(
name|TIFFTagValue
operator|*
operator|)
name|_TIFFrealloc
argument_list|(
name|td
operator|->
name|td_customValues
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFTagValue
argument_list|)
operator|*
name|td
operator|->
name|td_customValueCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_customValues
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Failed to allocate space for list of custom values"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|td
operator|->
name|td_customValues
operator|=
name|new_customValues
expr_stmt|;
name|tv
operator|=
name|td
operator|->
name|td_customValues
operator|+
operator|(
name|td
operator|->
name|td_customValueCount
operator|-
literal|1
operator|)
expr_stmt|;
name|tv
operator|->
name|info
operator|=
name|fip
expr_stmt|;
name|tv
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
name|tv
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/*              * Set custom value ... save a copy of the custom tag value.              */
name|tv_size
operator|=
name|_TIFFDataSize
argument_list|(
name|fip
operator|->
name|field_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv_size
operator|==
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Bad field type %d for \"%s\""
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|fip
operator|->
name|field_type
argument_list|,
name|fip
operator|->
name|field_name
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|fip
operator|->
name|field_passcount
condition|)
block|{
if|if
condition|(
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_VARIABLE2
condition|)
name|tv
operator|->
name|count
operator|=
operator|(
name|uint32
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
expr_stmt|;
else|else
name|tv
operator|->
name|count
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_VARIABLE
operator|||
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_VARIABLE2
condition|)
name|tv
operator|->
name|count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_SPP
condition|)
name|tv
operator|->
name|count
operator|=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
else|else
name|tv
operator|->
name|count
operator|=
name|fip
operator|->
name|field_writecount
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|field_type
operator|==
name|TIFF_ASCII
condition|)
name|_TIFFsetString
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|tv
operator|->
name|value
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tv
operator|->
name|value
operator|=
name|_TIFFCheckMalloc
argument_list|(
name|tif
argument_list|,
name|tv_size
argument_list|,
name|tv
operator|->
name|count
argument_list|,
literal|"Tag Value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tv
operator|->
name|value
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
name|fip
operator|->
name|field_passcount
operator|||
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_VARIABLE
operator|||
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_VARIABLE2
operator|||
name|fip
operator|->
name|field_writecount
operator|==
name|TIFF_SPP
operator|||
name|tv
operator|->
name|count
operator|>
literal|1
operator|)
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_PAGENUMBER
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_HALFTONEHINTS
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_YCBCRSUBSAMPLING
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_DOTRANGE
condition|)
block|{
name|_TIFFmemcpy
argument_list|(
name|tv
operator|->
name|value
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|tv
operator|->
name|count
operator|*
name|tv_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * XXX: The following loop required to handle 		     * TIFFTAG_PAGENUMBER, TIFFTAG_HALFTONEHINTS, 		     * TIFFTAG_YCBCRSUBSAMPLING and TIFFTAG_DOTRANGE tags. 		     * These tags are actually arrays and should be passed as 		     * array pointers to TIFFSetField() function, but actually 		     * passed as a list of separate values. This behaviour 		     * must be changed in the future! 		     */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|tv
operator|->
name|value
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tv
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|val
operator|+=
name|tv_size
control|)
block|{
switch|switch
condition|(
name|fip
operator|->
name|field_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_UNDEFINED
case|:
block|{
name|uint8
name|v
init|=
operator|(
name|uint8
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_SBYTE
case|:
block|{
name|int8
name|v
init|=
operator|(
name|int8
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_SHORT
case|:
block|{
name|uint16
name|v
init|=
operator|(
name|uint16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_SSHORT
case|:
block|{
name|int16
name|v
init|=
operator|(
name|int16
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_IFD
case|:
block|{
name|uint32
name|v
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_SLONG
case|:
block|{
name|int32
name|v
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int32
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
case|case
name|TIFF_FLOAT
case|:
block|{
name|float
name|v
init|=
operator|(
name|float
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIFF_DOUBLE
case|:
block|{
name|double
name|v
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
decl_stmt|;
name|_TIFFmemcpy
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|_TIFFmemset
argument_list|(
name|val
argument_list|,
literal|0
argument_list|,
name|tv_size
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|status
condition|)
block|{
name|TIFFSetFieldBit
argument_list|(
name|tif
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
operator|->
name|field_bit
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_DIRTYDIRECT
expr_stmt|;
block|}
name|end
label|:
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
name|badvalue
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Bad value %d for \"%s\" tag"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|v
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|badvalue32
label|:
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Bad value %u for \"%s\" tag"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|v32
argument_list|,
name|_TIFFFieldWithTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
operator|->
name|field_name
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return 1/0 according to whether or not  * it is permissible to set the tag's value.  * Note that we allow ImageLength to be changed  * so that we can append and extend to images.  * Any other tag may not be altered once writing  * has commenced, unless its value has no effect  * on the format of the data that is written.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|OkToChangeTag
name|OkToChangeTag
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|)
block|{
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
init|=
name|_TIFFFindFieldInfo
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|TIFF_ANY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fip
condition|)
block|{
comment|/* unknown tag */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFSetField"
argument_list|,
literal|"%s: Unknown %stag %u"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|isPseudoTag
argument_list|(
name|tag
argument_list|)
condition|?
literal|"pseudo-"
else|:
literal|""
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tag
operator|!=
name|TIFFTAG_IMAGELENGTH
operator|&&
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_BEENWRITING
operator|)
operator|&&
operator|!
name|fip
operator|->
name|field_oktochange
condition|)
block|{
comment|/* 		 * Consult info table to see if tag can be changed 		 * after we've started writing.  We only allow changes 		 * to those tags that don't/shouldn't affect the 		 * compression and/or format of the data. 		 */
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"TIFFSetField"
argument_list|,
literal|"%s: Cannot modify tag \"%s\" while writing"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|fip
operator|->
name|field_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Record the value of a field in the  * internal directory structure.  The  * field will be written to the file  * when/if the directory structure is  * updated.  */
end_comment
begin_function
name|int
DECL|function|TIFFSetField
name|TIFFSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|status
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|status
operator|=
name|TIFFVSetField
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Like TIFFSetField, but taking a varargs  * parameter list.  This routine is useful  * for building higher-level interfaces on  * top of the library.  */
end_comment
begin_function
name|int
DECL|function|TIFFVSetField
name|TIFFVSetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
return|return
name|OkToChangeTag
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|)
condition|?
call|(
modifier|*
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|_TIFFVGetField
name|_TIFFVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|int
name|ret_val
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TIFFTAG_SUBFILETYPE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_subfiletype
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGEWIDTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_imagewidth
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGELENGTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_imagelength
expr_stmt|;
break|break;
case|case
name|TIFFTAG_BITSPERSAMPLE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_bitspersample
expr_stmt|;
break|break;
case|case
name|TIFFTAG_COMPRESSION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_compression
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PHOTOMETRIC
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_photometric
expr_stmt|;
break|break;
case|case
name|TIFFTAG_THRESHHOLDING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_threshholding
expr_stmt|;
break|break;
case|case
name|TIFFTAG_FILLORDER
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_fillorder
expr_stmt|;
break|break;
case|case
name|TIFFTAG_ORIENTATION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_orientation
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SAMPLESPERPIXEL
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_samplesperpixel
expr_stmt|;
break|break;
case|case
name|TIFFTAG_ROWSPERSTRIP
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_rowsperstrip
expr_stmt|;
break|break;
case|case
name|TIFFTAG_MINSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_minsamplevalue
expr_stmt|;
break|break;
case|case
name|TIFFTAG_MAXSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_maxsamplevalue
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SMINSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sminsamplevalue
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SMAXSAMPLEVALUE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_smaxsamplevalue
expr_stmt|;
break|break;
case|case
name|TIFFTAG_XRESOLUTION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_xresolution
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YRESOLUTION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_yresolution
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PLANARCONFIG
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_planarconfig
expr_stmt|;
break|break;
case|case
name|TIFFTAG_XPOSITION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_xposition
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YPOSITION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_yposition
expr_stmt|;
break|break;
case|case
name|TIFFTAG_RESOLUTIONUNIT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_resolutionunit
expr_stmt|;
break|break;
case|case
name|TIFFTAG_PAGENUMBER
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_pagenumber
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_pagenumber
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|TIFFTAG_HALFTONEHINTS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_halftonehints
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_halftonehints
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|TIFFTAG_COLORMAP
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_colormap
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_colormap
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_colormap
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|TIFFTAG_STRIPOFFSETS
case|:
case|case
name|TIFFTAG_TILEOFFSETS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_stripoffset
expr_stmt|;
break|break;
case|case
name|TIFFTAG_STRIPBYTECOUNTS
case|:
case|case
name|TIFFTAG_TILEBYTECOUNTS
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_stripbytecount
expr_stmt|;
break|break;
case|case
name|TIFFTAG_MATTEING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|(
name|td
operator|->
name|td_extrasamples
operator|==
literal|1
operator|&&
name|td
operator|->
name|td_sampleinfo
index|[
literal|0
index|]
operator|==
name|EXTRASAMPLE_ASSOCALPHA
operator|)
expr_stmt|;
break|break;
case|case
name|TIFFTAG_EXTRASAMPLES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_extrasamples
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sampleinfo
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TILEWIDTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_tilewidth
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TILELENGTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_tilelength
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TILEDEPTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_tiledepth
expr_stmt|;
break|break;
case|case
name|TIFFTAG_DATATYPE
case|:
switch|switch
condition|(
name|td
operator|->
name|td_sampleformat
condition|)
block|{
case|case
name|SAMPLEFORMAT_UINT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|DATATYPE_UINT
expr_stmt|;
break|break;
case|case
name|SAMPLEFORMAT_INT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|DATATYPE_INT
expr_stmt|;
break|break;
case|case
name|SAMPLEFORMAT_IEEEFP
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|DATATYPE_IEEEFP
expr_stmt|;
break|break;
case|case
name|SAMPLEFORMAT_VOID
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|DATATYPE_VOID
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TIFFTAG_SAMPLEFORMAT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_sampleformat
expr_stmt|;
break|break;
case|case
name|TIFFTAG_IMAGEDEPTH
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_imagedepth
expr_stmt|;
break|break;
case|case
name|TIFFTAG_SUBIFD
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_nsubifd
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_subifd
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YCBCRPOSITIONING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrpositioning
expr_stmt|;
break|break;
case|case
name|TIFFTAG_YCBCRSUBSAMPLING
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|TIFFTAG_TRANSFERFUNCTION
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_samplesperpixel
operator|-
name|td
operator|->
name|td_extrasamples
operator|>
literal|1
condition|)
block|{
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_transferfunction
index|[
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TIFFTAG_INKNAMES
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
operator|=
name|td
operator|->
name|td_inknames
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
init|=
name|_TIFFFindFieldInfo
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|TIFF_ANY
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	     * This can happen if multiple images are open with different 	     * codecs which have private tags.  The global tag information 	     * table may then have tags that are valid for one file but not 	     * the other. If the client tries to get a tag that is not valid 	     * for the image's codec then we'll arrive here.              */
if|if
condition|(
name|fip
operator|==
name|NULL
operator|||
name|fip
operator|->
name|field_bit
operator|!=
name|FIELD_CUSTOM
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
literal|"_TIFFVGetField"
argument_list|,
literal|"%s: Invalid %stag \"%s\" "
literal|"(not supported by codec)"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|,
name|isPseudoTag
argument_list|(
name|tag
argument_list|)
condition|?
literal|"pseudo-"
else|:
literal|""
argument_list|,
name|fip
condition|?
name|fip
operator|->
name|field_name
else|:
literal|"Unknown"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	     * Do we have a custom value? 	     */
name|ret_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td
operator|->
name|td_customValueCount
condition|;
name|i
operator|++
control|)
block|{
name|TIFFTagValue
modifier|*
name|tv
init|=
name|td
operator|->
name|td_customValues
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|tv
operator|->
name|info
operator|->
name|field_tag
operator|!=
name|tag
condition|)
continue|continue;
if|if
condition|(
name|fip
operator|->
name|field_passcount
condition|)
block|{
if|if
condition|(
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_VARIABLE2
condition|)
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
operator|(
name|uint32
operator|)
name|tv
operator|->
name|count
expr_stmt|;
else|else
comment|/* Assume TIFF_VARIABLE */
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|(
name|uint16
operator|)
name|tv
operator|->
name|count
expr_stmt|;
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
operator|*
argument_list|)
operator|=
name|tv
operator|->
name|value
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fip
operator|->
name|field_type
operator|==
name|TIFF_ASCII
operator|||
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_VARIABLE
operator|||
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_VARIABLE2
operator|||
name|fip
operator|->
name|field_readcount
operator|==
name|TIFF_SPP
operator|||
name|tv
operator|->
name|count
operator|>
literal|1
operator|)
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_PAGENUMBER
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_HALFTONEHINTS
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_YCBCRSUBSAMPLING
operator|&&
name|fip
operator|->
name|field_tag
operator|!=
name|TIFFTAG_DOTRANGE
condition|)
block|{
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
operator|*
argument_list|)
operator|=
name|tv
operator|->
name|value
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|tv
operator|->
name|value
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tv
operator|->
name|count
condition|;
name|j
operator|++
operator|,
name|val
operator|+=
name|_TIFFDataSize
argument_list|(
name|tv
operator|->
name|info
operator|->
name|field_type
argument_list|)
control|)
block|{
switch|switch
condition|(
name|fip
operator|->
name|field_type
condition|)
block|{
case|case
name|TIFF_BYTE
case|:
case|case
name|TIFF_UNDEFINED
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint8
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|uint8
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_SBYTE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int8
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|int8
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_SHORT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|uint16
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_SSHORT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int16
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|int16
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_LONG
case|:
case|case
name|TIFF_IFD
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|uint32
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_SLONG
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int32
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|int32
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_RATIONAL
case|:
case|case
name|TIFF_SRATIONAL
case|:
case|case
name|TIFF_FLOAT
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|float
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIFF_DOUBLE
case|:
operator|*
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
operator|*
argument_list|)
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|val
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ret_val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
block|}
block|}
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the value of a field in the  * internal directory structure.  */
end_comment
begin_function
name|int
DECL|function|TIFFGetField
name|TIFFGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|status
operator|=
name|TIFFVGetField
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Like TIFFGetField, but taking a varargs  * parameter list.  This routine is useful  * for building higher-level interfaces on  * top of the library.  */
end_comment
begin_function
name|int
DECL|function|TIFFVGetField
name|TIFFVGetField
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|ttag_t
name|tag
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|TIFFFieldInfo
modifier|*
name|fip
init|=
name|_TIFFFindFieldInfo
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|TIFF_ANY
argument_list|)
decl_stmt|;
return|return
operator|(
name|fip
operator|&&
operator|(
name|isPseudoTag
argument_list|(
name|tag
argument_list|)
operator|||
name|TIFFFieldSet
argument_list|(
name|tif
argument_list|,
name|fip
operator|->
name|field_bit
argument_list|)
operator|)
condition|?
call|(
modifier|*
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
call|)
argument_list|(
name|tif
argument_list|,
name|tag
argument_list|,
name|ap
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_define
DECL|macro|CleanupField
define|#
directive|define
name|CleanupField
parameter_list|(
name|member
parameter_list|)
value|{		\     if (td->member) {			\ 	_TIFFfree(td->member);		\ 	td->member = 0;			\     }					\ }
end_define
begin_comment
comment|/*  * Release storage associated with a directory.  */
end_comment
begin_function
name|void
DECL|function|TIFFFreeDirectory
name|TIFFFreeDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|_TIFFmemset
argument_list|(
name|td
operator|->
name|td_fieldsset
argument_list|,
literal|0
argument_list|,
name|FIELD_SETLONGS
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_colormap
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_colormap
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_colormap
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_sampleinfo
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_subifd
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_inknames
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_transferfunction
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_transferfunction
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_transferfunction
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_stripoffset
argument_list|)
expr_stmt|;
name|CleanupField
argument_list|(
name|td_stripbytecount
argument_list|)
expr_stmt|;
name|TIFFClrFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_YCBCRSUBSAMPLING
argument_list|)
expr_stmt|;
name|TIFFClrFieldBit
argument_list|(
name|tif
argument_list|,
name|FIELD_YCBCRPOSITIONING
argument_list|)
expr_stmt|;
comment|/* Cleanup custom tag values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|td
operator|->
name|td_customValueCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|td
operator|->
name|td_customValues
index|[
name|i
index|]
operator|.
name|value
condition|)
name|_TIFFfree
argument_list|(
name|td
operator|->
name|td_customValues
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_customValueCount
operator|=
literal|0
expr_stmt|;
name|CleanupField
argument_list|(
name|td_customValues
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|CleanupField
undef|#
directive|undef
name|CleanupField
end_undef
begin_comment
comment|/*  * Client Tag extension support (from Niles Ritter).  */
end_comment
begin_decl_stmt
DECL|variable|_TIFFextender
specifier|static
name|TIFFExtendProc
name|_TIFFextender
init|=
operator|(
name|TIFFExtendProc
operator|)
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
name|TIFFExtendProc
DECL|function|TIFFSetTagExtender
name|TIFFSetTagExtender
parameter_list|(
name|TIFFExtendProc
name|extender
parameter_list|)
block|{
name|TIFFExtendProc
name|prev
init|=
name|_TIFFextender
decl_stmt|;
name|_TIFFextender
operator|=
name|extender
expr_stmt|;
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Setup for a new directory.  Should we automatically call  * TIFFWriteDirectory() if the current one is dirty?  *  * The newly created directory will not exist on the file till  * TIFFWriteDirectory(), TIFFFlush() or TIFFClose() is called.  */
end_comment
begin_function
name|int
DECL|function|TIFFCreateDirectory
name|TIFFCreateDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|TIFFDefaultDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_diroff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_nextdiroff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_curstrip
operator|=
operator|(
name|tstrip_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Setup a default directory structure.  */
end_comment
begin_function
name|int
DECL|function|TIFFDefaultDirectory
name|TIFFDefaultDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
specifier|register
name|TIFFDirectory
modifier|*
name|td
init|=
operator|&
name|tif
operator|->
name|tif_dir
decl_stmt|;
name|size_t
name|tiffFieldInfoCount
decl_stmt|;
specifier|const
name|TIFFFieldInfo
modifier|*
name|tiffFieldInfo
init|=
name|_TIFFGetFieldInfo
argument_list|(
operator|&
name|tiffFieldInfoCount
argument_list|)
decl_stmt|;
name|_TIFFSetupFieldInfo
argument_list|(
name|tif
argument_list|,
name|tiffFieldInfo
argument_list|,
name|tiffFieldInfoCount
argument_list|)
expr_stmt|;
name|_TIFFmemset
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_fillorder
operator|=
name|FILLORDER_MSB2LSB
expr_stmt|;
name|td
operator|->
name|td_bitspersample
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|td_threshholding
operator|=
name|THRESHHOLD_BILEVEL
expr_stmt|;
name|td
operator|->
name|td_orientation
operator|=
name|ORIENTATION_TOPLEFT
expr_stmt|;
name|td
operator|->
name|td_samplesperpixel
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|td_rowsperstrip
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
name|td
operator|->
name|td_tilewidth
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_tilelength
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_tiledepth
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|td_stripbytecountsorted
operator|=
literal|1
expr_stmt|;
comment|/* Our own arrays always sorted. */
name|td
operator|->
name|td_resolutionunit
operator|=
name|RESUNIT_INCH
expr_stmt|;
name|td
operator|->
name|td_sampleformat
operator|=
name|SAMPLEFORMAT_UINT
expr_stmt|;
name|td
operator|->
name|td_imagedepth
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|td
operator|->
name|td_ycbcrsubsampling
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|td
operator|->
name|td_ycbcrpositioning
operator|=
name|YCBCRPOSITION_CENTERED
expr_stmt|;
name|tif
operator|->
name|tif_postdecode
operator|=
name|_TIFFNoPostDecode
expr_stmt|;
name|tif
operator|->
name|tif_foundfield
operator|=
name|NULL
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vsetfield
operator|=
name|_TIFFVSetField
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|vgetfield
operator|=
name|_TIFFVGetField
expr_stmt|;
name|tif
operator|->
name|tif_tagmethods
operator|.
name|printdir
operator|=
name|NULL
expr_stmt|;
comment|/* 	 *  Give client code a chance to install their own 	 *  tag extensions& methods, prior to compression overloads. 	 */
if|if
condition|(
name|_TIFFextender
condition|)
call|(
modifier|*
name|_TIFFextender
call|)
argument_list|(
name|tif
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|TIFFSetField
argument_list|(
name|tif
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|COMPRESSION_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * NB: The directory is marked dirty as a result of setting 	 * up the default compression scheme.  However, this really 	 * isn't correct -- we want TIFF_DIRTYDIRECT to be set only 	 * if the user does something.  We could just do the setup 	 * by hand, but it seems better to use the normal mechanism 	 * (i.e. TIFFSetField). 	 */
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_DIRTYDIRECT
expr_stmt|;
comment|/* 	 * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19 	 * we clear the ISTILED flag when setting up a new directory. 	 * Should we also be clearing stuff like INSUBIFD? 	 */
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_ISTILED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|TIFFAdvanceDirectory
name|TIFFAdvanceDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
modifier|*
name|nextdir
parameter_list|,
name|toff_t
modifier|*
name|off
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFAdvanceDirectory"
decl_stmt|;
name|uint16
name|dircount
decl_stmt|;
if|if
condition|(
name|isMapped
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|toff_t
name|poff
init|=
operator|*
name|nextdir
decl_stmt|;
if|if
condition|(
name|poff
operator|+
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|>
name|tif
operator|->
name|tif_size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Error fetching directory count"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemcpy
argument_list|(
operator|&
name|dircount
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|poff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabShort
argument_list|(
operator|&
name|dircount
argument_list|)
expr_stmt|;
name|poff
operator|+=
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|+
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator|=
name|poff
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|toff_t
call|)
argument_list|(
name|poff
operator|+
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
operator|)
operator|>
name|tif
operator|->
name|tif_size
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Error fetching directory link"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|_TIFFmemcpy
argument_list|(
name|nextdir
argument_list|,
name|tif
operator|->
name|tif_base
operator|+
name|poff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabLong
argument_list|(
name|nextdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SeekOK
argument_list|(
name|tif
argument_list|,
operator|*
name|nextdir
argument_list|)
operator|||
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
operator|&
name|dircount
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Error fetching directory count"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabShort
argument_list|(
operator|&
name|dircount
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator|=
name|TIFFSeekFile
argument_list|(
name|tif
argument_list|,
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|TIFFSeekFile
argument_list|(
name|tif
argument_list|,
name|dircount
operator|*
sizeof|sizeof
argument_list|(
name|TIFFDirEntry
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
name|nextdir
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Error fetching directory link"
argument_list|,
name|tif
operator|->
name|tif_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabLong
argument_list|(
name|nextdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Count the number of directories in a file.  */
end_comment
begin_function
name|tdir_t
DECL|function|TIFFNumberOfDirectories
name|TIFFNumberOfDirectories
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
name|toff_t
name|nextdir
init|=
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
decl_stmt|;
name|tdir_t
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|nextdir
operator|!=
literal|0
operator|&&
name|TIFFAdvanceDirectory
argument_list|(
name|tif
argument_list|,
operator|&
name|nextdir
argument_list|,
name|NULL
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set the n-th directory as the current directory.  * NB: Directories are numbered starting at 0.  */
end_comment
begin_function
name|int
DECL|function|TIFFSetDirectory
name|TIFFSetDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdir_t
name|dirn
parameter_list|)
block|{
name|toff_t
name|nextdir
decl_stmt|;
name|tdir_t
name|n
decl_stmt|;
name|nextdir
operator|=
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
expr_stmt|;
for|for
control|(
name|n
operator|=
name|dirn
init|;
name|n
operator|>
literal|0
operator|&&
name|nextdir
operator|!=
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|!
name|TIFFAdvanceDirectory
argument_list|(
name|tif
argument_list|,
operator|&
name|nextdir
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tif
operator|->
name|tif_nextdiroff
operator|=
name|nextdir
expr_stmt|;
comment|/* 	 * Set curdir to the actual directory index.  The 	 * -1 is because TIFFReadDirectory will increment 	 * tif_curdir after successfully reading the directory. 	 */
name|tif
operator|->
name|tif_curdir
operator|=
operator|(
name|dirn
operator|-
name|n
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Reset tif_dirnumber counter and start new list of seen directories. 	 * We need this to prevent IFD loops. 	 */
name|tif
operator|->
name|tif_dirnumber
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|TIFFReadDirectory
argument_list|(
name|tif
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Set the current directory to be the directory  * located at the specified file offset.  This interface  * is used mainly to access directories linked with  * the SubIFD tag (e.g. thumbnail images).  */
end_comment
begin_function
name|int
DECL|function|TIFFSetSubDirectory
name|TIFFSetSubDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|uint32
name|diroff
parameter_list|)
block|{
name|tif
operator|->
name|tif_nextdiroff
operator|=
name|diroff
expr_stmt|;
comment|/* 	 * Reset tif_dirnumber counter and start new list of seen directories. 	 * We need this to prevent IFD loops. 	 */
name|tif
operator|->
name|tif_dirnumber
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|TIFFReadDirectory
argument_list|(
name|tif
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return file offset of the current directory.  */
end_comment
begin_function
name|uint32
DECL|function|TIFFCurrentDirOffset
name|TIFFCurrentDirOffset
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_diroff
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return an indication of whether or not we are  * at the last directory in the file.  */
end_comment
begin_function
name|int
DECL|function|TIFFLastDirectory
name|TIFFLastDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_nextdiroff
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Unlink the specified directory from the directory chain.  */
end_comment
begin_function
name|int
DECL|function|TIFFUnlinkDirectory
name|TIFFUnlinkDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|tdir_t
name|dirn
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFUnlinkDirectory"
decl_stmt|;
name|toff_t
name|nextdir
decl_stmt|;
name|toff_t
name|off
decl_stmt|;
name|tdir_t
name|n
decl_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_RDONLY
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Can not unlink directory in read-only file"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Go to the directory before the one we want 	 * to unlink and nab the offset of the link 	 * field we'll need to patch. 	 */
name|nextdir
operator|=
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|dirn
operator|-
literal|1
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|nextdir
operator|==
literal|0
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Directory %d does not exist"
argument_list|,
name|dirn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|TIFFAdvanceDirectory
argument_list|(
name|tif
argument_list|,
operator|&
name|nextdir
argument_list|,
operator|&
name|off
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Advance to the directory to be unlinked and fetch 	 * the offset of the directory that follows. 	 */
if|if
condition|(
operator|!
name|TIFFAdvanceDirectory
argument_list|(
name|tif
argument_list|,
operator|&
name|nextdir
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Go back and patch the link field of the preceding 	 * directory to point to the offset of the directory 	 * that follows. 	 */
operator|(
name|void
operator|)
name|TIFFSeekFile
argument_list|(
name|tif
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabLong
argument_list|(
operator|&
name|nextdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteOK
argument_list|(
name|tif
argument_list|,
operator|&
name|nextdir
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|module
argument_list|,
literal|"Error writing directory link"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Leave directory state setup safely.  We don't have 	 * facilities for doing inserting and removing directories, 	 * so it's safest to just invalidate everything.  This 	 * means that the caller can only append to the directory 	 * chain. 	 */
call|(
modifier|*
name|tif
operator|->
name|tif_cleanup
call|)
argument_list|(
name|tif
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MYBUFFER
operator|)
operator|&&
name|tif
operator|->
name|tif_rawdata
condition|)
block|{
name|_TIFFfree
argument_list|(
name|tif
operator|->
name|tif_rawdata
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_rawdata
operator|=
name|NULL
expr_stmt|;
name|tif
operator|->
name|tif_rawcc
operator|=
literal|0
expr_stmt|;
block|}
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
operator|(
name|TIFF_BEENWRITING
operator||
name|TIFF_BUFFERSETUP
operator||
name|TIFF_POSTENCODE
operator|)
expr_stmt|;
name|TIFFFreeDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|TIFFDefaultDirectory
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_diroff
operator|=
literal|0
expr_stmt|;
comment|/* force link on next write */
name|tif
operator|->
name|tif_nextdiroff
operator|=
literal|0
expr_stmt|;
comment|/* next write must be at end */
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_curstrip
operator|=
operator|(
name|tstrip_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*			[BFC]  *  * Author: Bruce Cameron<cameron@petris.com>  *  * Set a table of tags that are to be replaced during directory process by the  * 'IGNORE' state - or return TRUE/FALSE for the requested tag such that  * 'ReadDirectory' can use the stored information.  *  * FIXME: this is never used properly. Should be removed in the future.  */
end_comment
begin_function
name|int
DECL|function|TIFFReassignTagToIgnore
name|TIFFReassignTagToIgnore
parameter_list|(
name|enum
name|TIFFIgnoreSense
name|task
parameter_list|,
name|int
name|TIFFtagID
parameter_list|)
block|{
specifier|static
name|int
name|TIFFignoretags
index|[
name|FIELD_LAST
index|]
decl_stmt|;
specifier|static
name|int
name|tagcount
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Loop index */
name|int
name|j
decl_stmt|;
comment|/* Loop index */
switch|switch
condition|(
name|task
condition|)
block|{
case|case
name|TIS_STORE
case|:
if|if
condition|(
name|tagcount
operator|<
operator|(
name|FIELD_LAST
operator|-
literal|1
operator|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tagcount
condition|;
operator|++
name|j
control|)
block|{
comment|/* Do not add duplicate tag */
if|if
condition|(
name|TIFFignoretags
index|[
name|j
index|]
operator|==
name|TIFFtagID
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|TIFFignoretags
index|[
name|tagcount
operator|++
index|]
operator|=
name|TIFFtagID
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break ;
case|case
name|TIS_EXTRACT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tagcount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TIFFignoretags
index|[
name|i
index|]
operator|==
name|TIFFtagID
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
case|case
name|TIS_EMPTY
case|:
name|tagcount
operator|=
literal|0
expr_stmt|;
comment|/* Clear the list */
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
