begin_unit
begin_comment
comment|/* $Id: tif_open.c,v 1.33 2006/06/08 14:27:17 dron Exp $ */
end_comment
begin_comment
comment|/*  * Copyright (c) 1988-1997 Sam Leffler  * Copyright (c) 1991-1997 Silicon Graphics, Inc.  *  * Permission to use, copy, modify, distribute, and sell this software and   * its documentation for any purpose is hereby granted without fee, provided  * that (i) the above copyright notices and this permission notice appear in  * all copies of the software and related documentation, and (ii) the names of  * Sam Leffler and Silicon Graphics may not be used in any advertising or  * publicity relating to the software without the specific, prior written  * permission of Sam Leffler and Silicon Graphics.  *   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.    *   * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF   * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE   * OF THIS SOFTWARE.  */
end_comment
begin_comment
comment|/*  * TIFF Library.  */
end_comment
begin_include
include|#
directive|include
file|"tiffiop.h"
end_include
begin_decl_stmt
DECL|variable|typemask
specifier|static
specifier|const
name|long
name|typemask
index|[
literal|13
index|]
init|=
block|{
operator|(
name|long
operator|)
literal|0L
block|,
comment|/* TIFF_NOTYPE */
operator|(
name|long
operator|)
literal|0x000000ffL
block|,
comment|/* TIFF_BYTE */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_ASCII */
operator|(
name|long
operator|)
literal|0x0000ffffL
block|,
comment|/* TIFF_SHORT */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_LONG */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_RATIONAL */
operator|(
name|long
operator|)
literal|0x000000ffL
block|,
comment|/* TIFF_SBYTE */
operator|(
name|long
operator|)
literal|0x000000ffL
block|,
comment|/* TIFF_UNDEFINED */
operator|(
name|long
operator|)
literal|0x0000ffffL
block|,
comment|/* TIFF_SSHORT */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_SLONG */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_SRATIONAL */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_FLOAT */
operator|(
name|long
operator|)
literal|0xffffffffL
block|,
comment|/* TIFF_DOUBLE */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|bigTypeshift
specifier|static
specifier|const
name|int
name|bigTypeshift
index|[
literal|13
index|]
init|=
block|{
literal|0
block|,
comment|/* TIFF_NOTYPE */
literal|24
block|,
comment|/* TIFF_BYTE */
literal|0
block|,
comment|/* TIFF_ASCII */
literal|16
block|,
comment|/* TIFF_SHORT */
literal|0
block|,
comment|/* TIFF_LONG */
literal|0
block|,
comment|/* TIFF_RATIONAL */
literal|24
block|,
comment|/* TIFF_SBYTE */
literal|24
block|,
comment|/* TIFF_UNDEFINED */
literal|16
block|,
comment|/* TIFF_SSHORT */
literal|0
block|,
comment|/* TIFF_SLONG */
literal|0
block|,
comment|/* TIFF_SRATIONAL */
literal|0
block|,
comment|/* TIFF_FLOAT */
literal|0
block|,
comment|/* TIFF_DOUBLE */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|litTypeshift
specifier|static
specifier|const
name|int
name|litTypeshift
index|[
literal|13
index|]
init|=
block|{
literal|0
block|,
comment|/* TIFF_NOTYPE */
literal|0
block|,
comment|/* TIFF_BYTE */
literal|0
block|,
comment|/* TIFF_ASCII */
literal|0
block|,
comment|/* TIFF_SHORT */
literal|0
block|,
comment|/* TIFF_LONG */
literal|0
block|,
comment|/* TIFF_RATIONAL */
literal|0
block|,
comment|/* TIFF_SBYTE */
literal|0
block|,
comment|/* TIFF_UNDEFINED */
literal|0
block|,
comment|/* TIFF_SSHORT */
literal|0
block|,
comment|/* TIFF_SLONG */
literal|0
block|,
comment|/* TIFF_SRATIONAL */
literal|0
block|,
comment|/* TIFF_FLOAT */
literal|0
block|,
comment|/* TIFF_DOUBLE */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Dummy functions to fill the omitted client procedures.  */
end_comment
begin_function
specifier|static
name|int
DECL|function|_tiffDummyMapProc
name|_tiffDummyMapProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|,
name|tdata_t
modifier|*
name|pbase
parameter_list|,
name|toff_t
modifier|*
name|psize
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|pbase
expr_stmt|;
operator|(
name|void
operator|)
name|psize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|_tiffDummyUnmapProc
name|_tiffDummyUnmapProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|,
name|tdata_t
name|base
parameter_list|,
name|toff_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|base
expr_stmt|;
operator|(
name|void
operator|)
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Initialize the shift& mask tables, and the  * byte swapping state according to the file  * contents and the machine architecture.  */
end_comment
begin_function
specifier|static
name|void
DECL|function|TIFFInitOrder
name|TIFFInitOrder
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|magic
parameter_list|)
block|{
name|tif
operator|->
name|tif_typemask
operator|=
name|typemask
expr_stmt|;
if|if
condition|(
name|magic
operator|==
name|TIFF_BIGENDIAN
condition|)
block|{
name|tif
operator|->
name|tif_typeshift
operator|=
name|bigTypeshift
expr_stmt|;
ifndef|#
directive|ifndef
name|WORDS_BIGENDIAN
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_SWAB
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tif
operator|->
name|tif_typeshift
operator|=
name|litTypeshift
expr_stmt|;
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_SWAB
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
name|int
DECL|function|_TIFFgetMode
name|_TIFFgetMode
parameter_list|(
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|module
parameter_list|)
block|{
name|int
name|m
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|m
operator|=
name|O_RDONLY
expr_stmt|;
if|if
condition|(
name|mode
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
name|m
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'a'
case|:
name|m
operator|=
name|O_RDWR
operator||
name|O_CREAT
expr_stmt|;
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'w'
condition|)
name|m
operator||=
name|O_TRUNC
expr_stmt|;
break|break;
default|default:
name|TIFFErrorExt
argument_list|(
literal|0
argument_list|,
name|module
argument_list|,
literal|"\"%s\": Bad mode"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function
begin_function
name|TIFF
modifier|*
DECL|function|TIFFClientOpen
name|TIFFClientOpen
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
name|thandle_t
name|clientdata
parameter_list|,
name|TIFFReadWriteProc
name|readproc
parameter_list|,
name|TIFFReadWriteProc
name|writeproc
parameter_list|,
name|TIFFSeekProc
name|seekproc
parameter_list|,
name|TIFFCloseProc
name|closeproc
parameter_list|,
name|TIFFSizeProc
name|sizeproc
parameter_list|,
name|TIFFMapFileProc
name|mapproc
parameter_list|,
name|TIFFUnmapFileProc
name|unmapproc
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|module
index|[]
init|=
literal|"TIFFClientOpen"
decl_stmt|;
name|TIFF
modifier|*
name|tif
decl_stmt|;
name|int
name|m
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|m
operator|=
name|_TIFFgetMode
argument_list|(
name|mode
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad2
goto|;
name|tif
operator|=
operator|(
name|TIFF
operator|*
operator|)
name|_TIFFmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TIFF
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tif
operator|==
name|NULL
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|clientdata
argument_list|,
name|module
argument_list|,
literal|"%s: Out of memory (TIFF structure)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|_TIFFmemset
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tif
argument_list|)
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_name
operator|=
operator|(
name|char
operator|*
operator|)
name|tif
operator|+
sizeof|sizeof
argument_list|(
name|TIFF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tif
operator|->
name|tif_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_mode
operator|=
name|m
operator|&
operator|~
operator|(
name|O_CREAT
operator||
name|O_TRUNC
operator|)
expr_stmt|;
name|tif
operator|->
name|tif_curdir
operator|=
operator|(
name|tdir_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* non-existent directory */
name|tif
operator|->
name|tif_curoff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_curstrip
operator|=
operator|(
name|tstrip_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* invalid strip */
name|tif
operator|->
name|tif_row
operator|=
operator|(
name|uint32
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* read/write pre-increment */
name|tif
operator|->
name|tif_clientdata
operator|=
name|clientdata
expr_stmt|;
if|if
condition|(
operator|!
name|readproc
operator|||
operator|!
name|writeproc
operator|||
operator|!
name|seekproc
operator|||
operator|!
name|closeproc
operator|||
operator|!
name|sizeproc
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|clientdata
argument_list|,
name|module
argument_list|,
literal|"One of the client procedures is NULL pointer."
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|tif
operator|->
name|tif_readproc
operator|=
name|readproc
expr_stmt|;
name|tif
operator|->
name|tif_writeproc
operator|=
name|writeproc
expr_stmt|;
name|tif
operator|->
name|tif_seekproc
operator|=
name|seekproc
expr_stmt|;
name|tif
operator|->
name|tif_closeproc
operator|=
name|closeproc
expr_stmt|;
name|tif
operator|->
name|tif_sizeproc
operator|=
name|sizeproc
expr_stmt|;
if|if
condition|(
name|mapproc
condition|)
name|tif
operator|->
name|tif_mapproc
operator|=
name|mapproc
expr_stmt|;
else|else
name|tif
operator|->
name|tif_mapproc
operator|=
name|_tiffDummyMapProc
expr_stmt|;
if|if
condition|(
name|unmapproc
condition|)
name|tif
operator|->
name|tif_unmapproc
operator|=
name|unmapproc
expr_stmt|;
else|else
name|tif
operator|->
name|tif_unmapproc
operator|=
name|_tiffDummyUnmapProc
expr_stmt|;
name|_TIFFSetDefaultCompressionState
argument_list|(
name|tif
argument_list|)
expr_stmt|;
comment|/* setup default state */
comment|/* 	 * Default is to return data MSB2LSB and enable the 	 * use of memory-mapped files and strip chopping when 	 * a file is opened read-only. 	 */
name|tif
operator|->
name|tif_flags
operator|=
name|FILLORDER_MSB2LSB
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|O_RDONLY
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_MAPPED
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIPCHOP_DEFAULT
if|if
condition|(
name|m
operator|==
name|O_RDONLY
operator|||
name|m
operator|==
name|O_RDWR
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|STRIPCHOP_DEFAULT
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Process library-specific flags in the open mode string. 	 * The following flags may be used to control intrinsic library 	 * behaviour that may or may not be desirable (usually for 	 * compatibility with some application that claims to support 	 * TIFF but only supports some braindead idea of what the 	 * vendor thinks TIFF is): 	 * 	 * 'l'		use little-endian byte order for creating a file 	 * 'b'		use big-endian byte order for creating a file 	 * 'L'		read/write information using LSB2MSB bit order 	 * 'B'		read/write information using MSB2LSB bit order 	 * 'H'		read/write information using host bit order 	 * 'M'		enable use of memory-mapped files when supported 	 * 'm'		disable use of memory-mapped files 	 * 'C'		enable strip chopping support when reading 	 * 'c'		disable strip chopping support 	 * 'h'		read TIFF header only, do not load the first IFD 	 * 	 * The use of the 'l' and 'b' flags is strongly discouraged. 	 * These flags are provided solely because numerous vendors, 	 * typically on the PC, do not correctly support TIFF; they 	 * only support the Intel little-endian byte order.  This 	 * support is not configured by default because it supports 	 * the violation of the TIFF spec that says that readers *MUST* 	 * support both byte orders.  It is strongly recommended that 	 * you not use this feature except to deal with busted apps 	 * that write invalid TIFF.  And even in those cases you should 	 * bang on the vendors to fix their software. 	 * 	 * The 'L', 'B', and 'H' flags are intended for applications 	 * that can optimize operations on data by using a particular 	 * bit order.  By default the library returns data in MSB2LSB 	 * bit order for compatibiltiy with older versions of this 	 * library.  Returning data in the bit order of the native cpu 	 * makes the most sense but also requires applications to check 	 * the value of the FillOrder tag; something they probably do 	 * not do right now. 	 * 	 * The 'M' and 'm' flags are provided because some virtual memory 	 * systems exhibit poor behaviour when large images are mapped. 	 * These options permit clients to control the use of memory-mapped 	 * files on a per-file basis. 	 * 	 * The 'C' and 'c' flags are provided because the library support 	 * for chopping up large strips into multiple smaller strips is not 	 * application-transparent and as such can cause problems.  The 'c' 	 * option permits applications that only want to look at the tags, 	 * for example, to get the unadulterated TIFF tag information. 	 */
for|for
control|(
name|cp
operator|=
name|mode
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'b'
case|:
ifndef|#
directive|ifndef
name|WORDS_BIGENDIAN
if|if
condition|(
name|m
operator|&
name|O_CREAT
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_SWAB
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'l'
case|:
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
if|if
condition|(
operator|(
name|m
operator|&
name|O_CREAT
operator|)
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_SWAB
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'B'
case|:
name|tif
operator|->
name|tif_flags
operator|=
operator|(
name|tif
operator|->
name|tif_flags
operator|&
operator|~
name|TIFF_FILLORDER
operator|)
operator||
name|FILLORDER_MSB2LSB
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tif
operator|->
name|tif_flags
operator|=
operator|(
name|tif
operator|->
name|tif_flags
operator|&
operator|~
name|TIFF_FILLORDER
operator|)
operator||
name|FILLORDER_LSB2MSB
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|tif
operator|->
name|tif_flags
operator|=
operator|(
name|tif
operator|->
name|tif_flags
operator|&
operator|~
name|TIFF_FILLORDER
operator|)
operator||
name|HOST_FILLORDER
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|m
operator|==
name|O_RDONLY
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_MAPPED
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|m
operator|==
name|O_RDONLY
condition|)
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MAPPED
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|m
operator|==
name|O_RDONLY
condition|)
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_STRIPCHOP
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|m
operator|==
name|O_RDONLY
condition|)
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_STRIPCHOP
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_HEADERONLY
expr_stmt|;
break|break;
block|}
comment|/* 	 * Read in TIFF header. 	 */
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|&
name|O_TRUNC
operator|||
operator|!
name|ReadOK
argument_list|(
name|tif
argument_list|,
operator|&
name|tif
operator|->
name|tif_header
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFHeader
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|tif
operator|->
name|tif_mode
operator|==
name|O_RDONLY
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|name
argument_list|,
literal|"Cannot read TIFF header"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Setup header and write. 		 */
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|=
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|?
name|TIFF_LITTLEENDIAN
else|:
name|TIFF_BIGENDIAN
expr_stmt|;
else|#
directive|else
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|=
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|?
name|TIFF_BIGENDIAN
else|:
name|TIFF_LITTLEENDIAN
expr_stmt|;
endif|#
directive|endif
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
operator|=
name|TIFF_VERSION
expr_stmt|;
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
name|TIFFSwabShort
argument_list|(
operator|&
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
argument_list|)
expr_stmt|;
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
operator|=
literal|0
expr_stmt|;
comment|/* filled in later */
comment|/*                  * The doc for "fopen" for some STD_C_LIBs says that if you                   * open a file for modify ("+"), then you must fseek (or                   * fflush?) between any freads and fwrites.  This is not                  * necessary on most systems, but has been shown to be needed                  * on Solaris.                   */
name|TIFFSeekFile
argument_list|(
name|tif
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WriteOK
argument_list|(
name|tif
argument_list|,
operator|&
name|tif
operator|->
name|tif_header
argument_list|,
sizeof|sizeof
argument_list|(
name|TIFFHeader
argument_list|)
argument_list|)
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|name
argument_list|,
literal|"Error writing TIFF header"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Setup the byte order handling. 		 */
name|TIFFInitOrder
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
argument_list|)
expr_stmt|;
comment|/* 		 * Setup default directory. 		 */
if|if
condition|(
operator|!
name|TIFFDefaultDirectory
argument_list|(
name|tif
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|tif
operator|->
name|tif_diroff
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_dirlist
operator|=
name|NULL
expr_stmt|;
name|tif
operator|->
name|tif_dirlistsize
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_dirnumber
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|tif
operator|)
return|;
block|}
comment|/* 	 * Setup the byte order handling. 	 */
if|if
condition|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|!=
name|TIFF_BIGENDIAN
operator|&&
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|!=
name|TIFF_LITTLEENDIAN
if|#
directive|if
name|MDI_SUPPORT
operator|&&
if|#
directive|if
name|HOST_BIGENDIAN
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|!=
name|MDI_BIGENDIAN
else|#
directive|else
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|!=
name|MDI_LITTLEENDIAN
endif|#
directive|endif
condition|)
block|{
name|TIFFErrorExt
argument_list|(
argument|tif->tif_clientdata
argument_list|,
argument|name
argument_list|,
literal|"Not a TIFF or MDI file, bad magic number %d (0x%x)"
argument_list|,
else|#
directive|else
argument_list|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|name
argument_list|,
literal|"Not a TIFF file, bad magic number %d (0x%x)"
argument_list|,
endif|#
directive|endif
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
argument_list|,
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|TIFFInitOrder
argument_list|(
name|tif
argument_list|,
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
argument_list|)
expr_stmt|;
comment|/* 	 * Swap header if required. 	 */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
condition|)
block|{
name|TIFFSwabShort
argument_list|(
operator|&
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
argument_list|)
expr_stmt|;
name|TIFFSwabLong
argument_list|(
operator|&
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now check version (if needed, it's been byte-swapped). 	 * Note that this isn't actually a version number, it's a 	 * magic number that doesn't change (stupid). 	 */
if|if
condition|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
operator|==
name|TIFF_BIGTIFF_VERSION
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|name
argument_list|,
literal|"This is a BigTIFF file.  This format not supported\n"
literal|"by this version of libtiff."
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
operator|!=
name|TIFF_VERSION
condition|)
block|{
name|TIFFErrorExt
argument_list|(
name|tif
operator|->
name|tif_clientdata
argument_list|,
name|name
argument_list|,
literal|"Not a TIFF file, bad version number %d (0x%x)"
argument_list|,
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
argument_list|,
name|tif
operator|->
name|tif_header
operator|.
name|tiff_version
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_MYBUFFER
expr_stmt|;
name|tif
operator|->
name|tif_rawcp
operator|=
name|tif
operator|->
name|tif_rawdata
operator|=
literal|0
expr_stmt|;
name|tif
operator|->
name|tif_rawdatasize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Sometimes we do not want to read the first directory (for example, 	 * it may be broken) and want to proceed to other directories. I this 	 * case we use the TIFF_HEADERONLY flag to open file and return 	 * immediately after reading TIFF header. 	 */
if|if
condition|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_HEADERONLY
condition|)
return|return
operator|(
name|tif
operator|)
return|;
comment|/* 	 * Setup initial directory. 	 */
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|tif
operator|->
name|tif_nextdiroff
operator|=
name|tif
operator|->
name|tif_header
operator|.
name|tiff_diroff
expr_stmt|;
comment|/* 		 * Try to use a memory-mapped file if the client 		 * has not explicitly suppressed usage with the 		 * 'm' flag in the open mode (see above). 		 */
if|if
condition|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_MAPPED
operator|)
operator|&&
operator|!
name|TIFFMapFileContents
argument_list|(
name|tif
argument_list|,
operator|(
name|tdata_t
operator|*
operator|)
operator|&
name|tif
operator|->
name|tif_base
argument_list|,
operator|&
name|tif
operator|->
name|tif_size
argument_list|)
condition|)
name|tif
operator|->
name|tif_flags
operator|&=
operator|~
name|TIFF_MAPPED
expr_stmt|;
if|if
condition|(
name|TIFFReadDirectory
argument_list|(
name|tif
argument_list|)
condition|)
block|{
name|tif
operator|->
name|tif_rawcc
operator|=
operator|-
literal|1
expr_stmt|;
name|tif
operator|->
name|tif_flags
operator||=
name|TIFF_BUFFERSETUP
expr_stmt|;
return|return
operator|(
name|tif
operator|)
return|;
block|}
break|break;
case|case
literal|'a'
case|:
comment|/* 		 * New directories are automatically append 		 * to the end of the directory chain when they 		 * are written out (see TIFFWriteDirectory). 		 */
if|if
condition|(
operator|!
name|TIFFDefaultDirectory
argument_list|(
name|tif
argument_list|)
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
name|tif
operator|)
return|;
block|}
name|bad
label|:
name|tif
operator|->
name|tif_mode
operator|=
name|O_RDONLY
expr_stmt|;
comment|/* XXX avoid flush */
name|TIFFCleanup
argument_list|(
name|tif
argument_list|)
expr_stmt|;
name|bad2
label|:
return|return
operator|(
operator|(
name|TIFF
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/*  * Query functions to access private data.  */
comment|/*  * Return open file's name.  */
specifier|const
name|char
modifier|*
DECL|function|TIFFFileName
name|TIFFFileName
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_name
operator|)
return|;
block|}
comment|/*  * Set the file name.  */
specifier|const
name|char
modifier|*
DECL|function|TIFFSetFileName
name|TIFFSetFileName
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|old_name
init|=
name|tif
operator|->
name|tif_name
decl_stmt|;
name|tif
operator|->
name|tif_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
return|return
operator|(
name|old_name
operator|)
return|;
block|}
comment|/*  * Return open file's I/O descriptor.  */
name|int
DECL|function|TIFFFileno
name|TIFFFileno
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_fd
operator|)
return|;
block|}
comment|/*  * Set open file's I/O descriptor, and return previous value.  */
name|int
DECL|function|TIFFSetFileno
name|TIFFSetFileno
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|old_fd
init|=
name|tif
operator|->
name|tif_fd
decl_stmt|;
name|tif
operator|->
name|tif_fd
operator|=
name|fd
expr_stmt|;
return|return
name|old_fd
return|;
block|}
comment|/*  * Return open file's clientdata.  */
name|thandle_t
DECL|function|TIFFClientdata
name|TIFFClientdata
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_clientdata
operator|)
return|;
block|}
comment|/*  * Set open file's clientdata, and return previous value.  */
name|thandle_t
DECL|function|TIFFSetClientdata
name|TIFFSetClientdata
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|thandle_t
name|newvalue
parameter_list|)
block|{
name|thandle_t
name|m
init|=
name|tif
operator|->
name|tif_clientdata
decl_stmt|;
name|tif
operator|->
name|tif_clientdata
operator|=
name|newvalue
expr_stmt|;
return|return
name|m
return|;
block|}
comment|/*  * Return read/write mode.  */
name|int
DECL|function|TIFFGetMode
name|TIFFGetMode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_mode
operator|)
return|;
block|}
comment|/*  * Return read/write mode.  */
name|int
DECL|function|TIFFSetMode
name|TIFFSetMode
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|old_mode
init|=
name|tif
operator|->
name|tif_mode
decl_stmt|;
name|tif
operator|->
name|tif_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
name|old_mode
operator|)
return|;
block|}
comment|/*  * Return nonzero if file is organized in  * tiles; zero if organized as strips.  */
name|int
DECL|function|TIFFIsTiled
name|TIFFIsTiled
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|isTiled
argument_list|(
name|tif
argument_list|)
operator|)
return|;
block|}
comment|/*  * Return current row being read/written.  */
name|uint32
DECL|function|TIFFCurrentRow
name|TIFFCurrentRow
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_row
operator|)
return|;
block|}
comment|/*  * Return index of the current directory.  */
name|tdir_t
DECL|function|TIFFCurrentDirectory
name|TIFFCurrentDirectory
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_curdir
operator|)
return|;
block|}
comment|/*  * Return current strip.  */
name|tstrip_t
DECL|function|TIFFCurrentStrip
name|TIFFCurrentStrip
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_curstrip
operator|)
return|;
block|}
comment|/*  * Return current tile.  */
name|ttile_t
DECL|function|TIFFCurrentTile
name|TIFFCurrentTile
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_curtile
operator|)
return|;
block|}
comment|/*  * Return nonzero if the file has byte-swapped data.  */
name|int
DECL|function|TIFFIsByteSwapped
name|TIFFIsByteSwapped
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
operator|(
name|tif
operator|->
name|tif_flags
operator|&
name|TIFF_SWAB
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
comment|/*  * Return nonzero if the data is returned up-sampled.  */
name|int
DECL|function|TIFFIsUpSampled
name|TIFFIsUpSampled
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|isUpSampled
argument_list|(
name|tif
argument_list|)
operator|)
return|;
block|}
comment|/*  * Return nonzero if the data is returned in MSB-to-LSB bit order.  */
name|int
DECL|function|TIFFIsMSB2LSB
name|TIFFIsMSB2LSB
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|isFillOrder
argument_list|(
name|tif
argument_list|,
name|FILLORDER_MSB2LSB
argument_list|)
operator|)
return|;
block|}
comment|/*  * Return nonzero if given file was written in big-endian order.  */
name|int
DECL|function|TIFFIsBigEndian
name|TIFFIsBigEndian
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_header
operator|.
name|tiff_magic
operator|==
name|TIFF_BIGENDIAN
operator|)
return|;
block|}
comment|/*  * Return pointer to file read method.  */
name|TIFFReadWriteProc
DECL|function|TIFFGetReadProc
name|TIFFGetReadProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_readproc
operator|)
return|;
block|}
comment|/*  * Return pointer to file write method.  */
name|TIFFReadWriteProc
DECL|function|TIFFGetWriteProc
name|TIFFGetWriteProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_writeproc
operator|)
return|;
block|}
comment|/*  * Return pointer to file seek method.  */
name|TIFFSeekProc
DECL|function|TIFFGetSeekProc
name|TIFFGetSeekProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_seekproc
operator|)
return|;
block|}
comment|/*  * Return pointer to file close method.  */
name|TIFFCloseProc
DECL|function|TIFFGetCloseProc
name|TIFFGetCloseProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_closeproc
operator|)
return|;
block|}
comment|/*  * Return pointer to file size requesting method.  */
name|TIFFSizeProc
DECL|function|TIFFGetSizeProc
name|TIFFGetSizeProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_sizeproc
operator|)
return|;
block|}
comment|/*  * Return pointer to memory mapping method.  */
name|TIFFMapFileProc
DECL|function|TIFFGetMapFileProc
name|TIFFGetMapFileProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_mapproc
operator|)
return|;
block|}
comment|/*  * Return pointer to memory unmapping method.  */
name|TIFFUnmapFileProc
DECL|function|TIFFGetUnmapFileProc
name|TIFFGetUnmapFileProc
parameter_list|(
name|TIFF
modifier|*
name|tif
parameter_list|)
block|{
return|return
operator|(
name|tif
operator|->
name|tif_unmapproc
operator|)
return|;
block|}
end_function
begin_comment
comment|/* vim: set ts=8 sts=8 sw=8 noet: */
end_comment
end_unit
