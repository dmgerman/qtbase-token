begin_unit
begin_comment
comment|/* ** 2001 September 15 ** ** The author disclaims copyright to this source code.  In place of ** a legal notice, here is a blessing: ** **    May you do good and not evil. **    May you find forgiveness for yourself and forgive others. **    May you share freely, never taking more than you give. ** ************************************************************************* ** This file contains code to implement the "sqlite" command line ** utility for accessing SQLite databases. ** ** $Id: shell.c,v 1.178 2008/05/05 16:27:24 drh Exp $ */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|"sqlite3.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|<pwd.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__OS2__
end_ifdef
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
operator|&&
name|HAVE_READLINE
operator|==
literal|1
end_if
begin_include
include|#
directive|include
file|<readline/readline.h>
end_include
begin_include
include|#
directive|include
file|<readline/history.h>
end_include
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|readline
define|#
directive|define
name|readline
parameter_list|(
name|p
parameter_list|)
value|local_getline(p,stdin)
end_define
begin_define
DECL|macro|add_history
define|#
directive|define
name|add_history
parameter_list|(
name|X
parameter_list|)
end_define
begin_define
DECL|macro|read_history
define|#
directive|define
name|read_history
parameter_list|(
name|X
parameter_list|)
end_define
begin_define
DECL|macro|write_history
define|#
directive|define
name|write_history
parameter_list|(
name|X
parameter_list|)
end_define
begin_define
DECL|macro|stifle_history
define|#
directive|define
name|stifle_history
parameter_list|(
name|X
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if
begin_include
include|#
directive|include
file|<io.h>
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Make sure isatty() has a prototype. */
end_comment
begin_function_decl
specifier|extern
name|int
name|isatty
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if
begin_comment
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()  * thus we always assume that we have a console. That can be  * overridden with the -batch command line option.  */
end_comment
begin_define
DECL|macro|isatty
define|#
directive|define
name|isatty
parameter_list|(
name|x
parameter_list|)
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<sys/time.h>
end_include
begin_include
include|#
directive|include
file|<sys/resource.h>
end_include
begin_comment
comment|/* Saved resource information for the beginning of an operation */
end_comment
begin_decl_stmt
DECL|variable|sBegin
specifier|static
name|struct
name|rusage
name|sBegin
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* True if the timer is enabled */
end_comment
begin_decl_stmt
DECL|variable|enableTimer
specifier|static
name|int
name|enableTimer
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** Begin timing an operation */
end_comment
begin_function
DECL|function|beginTimer
specifier|static
name|void
name|beginTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sBegin
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Return the difference of two time_structs in microseconds */
end_comment
begin_function
DECL|function|timeDiff
specifier|static
name|int
name|timeDiff
parameter_list|(
name|struct
name|timeval
modifier|*
name|pStart
parameter_list|,
name|struct
name|timeval
modifier|*
name|pEnd
parameter_list|)
block|{
return|return
operator|(
name|pEnd
operator|->
name|tv_usec
operator|-
name|pStart
operator|->
name|tv_usec
operator|)
operator|+
literal|1000000
operator|*
operator|(
name|pEnd
operator|->
name|tv_sec
operator|-
name|pStart
operator|->
name|tv_sec
operator|)
return|;
block|}
end_function
begin_comment
comment|/* ** Print the timing results. */
end_comment
begin_function
DECL|function|endTimer
specifier|static
name|void
name|endTimer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enableTimer
condition|)
block|{
name|struct
name|rusage
name|sEnd
decl_stmt|;
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|sEnd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CPU Time: user %f sys %f\n"
argument_list|,
literal|0.000001
operator|*
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_utime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_utime
argument_list|)
argument_list|,
literal|0.000001
operator|*
name|timeDiff
argument_list|(
operator|&
name|sBegin
operator|.
name|ru_stime
argument_list|,
operator|&
name|sEnd
operator|.
name|ru_stime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|BEGIN_TIMER
define|#
directive|define
name|BEGIN_TIMER
value|beginTimer()
end_define
begin_define
DECL|macro|END_TIMER
define|#
directive|define
name|END_TIMER
value|endTimer()
end_define
begin_define
DECL|macro|HAS_TIMER
define|#
directive|define
name|HAS_TIMER
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|BEGIN_TIMER
define|#
directive|define
name|BEGIN_TIMER
end_define
begin_define
DECL|macro|END_TIMER
define|#
directive|define
name|END_TIMER
end_define
begin_define
DECL|macro|HAS_TIMER
define|#
directive|define
name|HAS_TIMER
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ** If the following flag is set, then command execution stops ** at an error if we are not interactive. */
end_comment
begin_decl_stmt
DECL|variable|bail_on_error
specifier|static
name|int
name|bail_on_error
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** Threat stdin as an interactive input if the following variable ** is true.  Otherwise, assume stdin is connected to a file or pipe. */
end_comment
begin_decl_stmt
DECL|variable|stdin_is_interactive
specifier|static
name|int
name|stdin_is_interactive
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** The following is the open SQLite database.  We make a pointer ** to this database a static variable so that it can be accessed ** by the SIGINT handler to interrupt database processing. */
end_comment
begin_decl_stmt
DECL|variable|db
specifier|static
name|sqlite3
modifier|*
name|db
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** True if an interrupt (Control-C) has been received. */
end_comment
begin_decl_stmt
DECL|variable|seenInterrupt
specifier|static
specifier|volatile
name|int
name|seenInterrupt
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** This is the name of our program. It is set in main(), used ** in a number of other places, mostly for error messages. */
end_comment
begin_decl_stmt
DECL|variable|Argv0
specifier|static
name|char
modifier|*
name|Argv0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** Prompt strings. Initialized in main. Settable with **   .prompt main continue */
end_comment
begin_decl_stmt
DECL|variable|mainPrompt
specifier|static
name|char
name|mainPrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|mainPrompt
comment|/* First line prompt. default: "sqlite> "*/
end_comment
begin_decl_stmt
DECL|variable|continuePrompt
specifier|static
name|char
name|continuePrompt
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|continuePrompt
comment|/* Continuation prompt. default: "   ...> " */
end_comment
begin_comment
comment|/* ** Write I/O traces to the following stream. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef
begin_decl_stmt
DECL|variable|iotrace
specifier|static
name|FILE
modifier|*
name|iotrace
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ** This routine works like printf in that its first argument is a ** format string and subsequent arguments are values to be substituted ** in place of % fields.  The result of formatting this string ** is written to iotrace. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
end_ifdef
begin_function
DECL|function|iotracePrintf
specifier|static
name|void
name|iotracePrintf
parameter_list|(
specifier|const
name|char
modifier|*
name|zFormat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|zFormat
argument_list|)
expr_stmt|;
name|z
operator|=
name|sqlite3_vmprintf
argument_list|(
name|zFormat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|iotrace
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ** Determines if a string is a number of not. */
end_comment
begin_function
DECL|function|isNumber
specifier|static
name|int
name|isNumber
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
modifier|*
name|realnum
parameter_list|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|||
operator|*
name|z
operator|==
literal|'+'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'.'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'e'
operator|||
operator|*
name|z
operator|==
literal|'E'
condition|)
block|{
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|'+'
operator|||
operator|*
name|z
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|z
argument_list|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|realnum
condition|)
operator|*
name|realnum
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|*
name|z
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ** A global char* and an SQL function to access its current value  ** from within an SQL statement. This program used to use the  ** sqlite_exec_printf() API to substitue a string into an SQL statement. ** The correct way to do this with sqlite3 is to use the bind API, but ** since the shell is built around the callback paradigm it would be a lot ** of work. Instead just use this hack, which is quite harmless. */
end_comment
begin_decl_stmt
DECL|variable|zShellStatic
specifier|static
specifier|const
name|char
modifier|*
name|zShellStatic
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|shellstaticFunc
specifier|static
name|void
name|shellstaticFunc
parameter_list|(
name|sqlite3_context
modifier|*
name|context
parameter_list|,
name|int
name|argc
parameter_list|,
name|sqlite3_value
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|assert
argument_list|(
literal|0
operator|==
name|argc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|zShellStatic
argument_list|)
expr_stmt|;
name|sqlite3_result_text
argument_list|(
name|context
argument_list|,
name|zShellStatic
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ** This routine reads a line of text from FILE in, stores ** the text in memory obtained from malloc() and returns a pointer ** to the text.  NULL is returned at end of file, or if malloc() ** fails. ** ** The interface is like "readline" but no command-line editing ** is done. */
end_comment
begin_function
DECL|function|local_getline
specifier|static
name|char
modifier|*
name|local_getline
parameter_list|(
name|char
modifier|*
name|zPrompt
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zLine
decl_stmt|;
name|int
name|nLine
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|eol
decl_stmt|;
if|if
condition|(
name|zPrompt
operator|&&
operator|*
name|zPrompt
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|zPrompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|nLine
operator|=
literal|100
expr_stmt|;
name|zLine
operator|=
name|malloc
argument_list|(
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|0
expr_stmt|;
name|eol
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eol
condition|)
block|{
if|if
condition|(
name|n
operator|+
literal|100
operator|>
name|nLine
condition|)
block|{
name|nLine
operator|=
name|nLine
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|nLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|zLine
index|[
name|n
index|]
argument_list|,
name|nLine
operator|-
name|n
argument_list|,
name|in
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|eol
operator|=
literal|1
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|zLine
index|[
name|n
index|]
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|zLine
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|zLine
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|eol
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|zLine
operator|=
name|realloc
argument_list|(
name|zLine
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|zLine
return|;
block|}
end_function
begin_comment
comment|/* ** Retrieve a single line of input text. ** ** zPrior is a string of prior text retrieved.  If not the empty ** string, then issue a continuation prompt. */
end_comment
begin_function
DECL|function|one_input_line
specifier|static
name|char
modifier|*
name|one_input_line
parameter_list|(
specifier|const
name|char
modifier|*
name|zPrior
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zPrompt
decl_stmt|;
name|char
modifier|*
name|zResult
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
return|return
name|local_getline
argument_list|(
literal|0
argument_list|,
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|zPrior
operator|&&
name|zPrior
index|[
literal|0
index|]
condition|)
block|{
name|zPrompt
operator|=
name|continuePrompt
expr_stmt|;
block|}
else|else
block|{
name|zPrompt
operator|=
name|mainPrompt
expr_stmt|;
block|}
name|zResult
operator|=
name|readline
argument_list|(
name|zPrompt
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
operator|&&
name|HAVE_READLINE
operator|==
literal|1
if|if
condition|(
name|zResult
operator|&&
operator|*
name|zResult
condition|)
name|add_history
argument_list|(
name|zResult
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|zResult
return|;
block|}
end_function
begin_struct
DECL|struct|previous_mode_data
struct|struct
name|previous_mode_data
block|{
DECL|member|valid
name|int
name|valid
decl_stmt|;
comment|/* Is there legit data in here? */
DECL|member|mode
name|int
name|mode
decl_stmt|;
DECL|member|showHeader
name|int
name|showHeader
decl_stmt|;
DECL|member|colWidth
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* ** An pointer to an instance of this structure is passed from ** the main program to the callback.  This is used to communicate ** state and mode information. */
end_comment
begin_struct
DECL|struct|callback_data
struct|struct
name|callback_data
block|{
DECL|member|db
name|sqlite3
modifier|*
name|db
decl_stmt|;
comment|/* The database */
DECL|member|echoOn
name|int
name|echoOn
decl_stmt|;
comment|/* True to echo input commands */
DECL|member|cnt
name|int
name|cnt
decl_stmt|;
comment|/* Number of records displayed so far */
DECL|member|out
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* Write results here */
DECL|member|mode
name|int
name|mode
decl_stmt|;
comment|/* An output mode setting */
DECL|member|writableSchema
name|int
name|writableSchema
decl_stmt|;
comment|/* True if PRAGMA writable_schema=ON */
DECL|member|showHeader
name|int
name|showHeader
decl_stmt|;
comment|/* True to show column names in List or Column mode */
DECL|member|zDestTable
name|char
modifier|*
name|zDestTable
decl_stmt|;
comment|/* Name of destination table when MODE_Insert */
DECL|member|separator
name|char
name|separator
index|[
literal|20
index|]
decl_stmt|;
comment|/* Separator character for MODE_List */
DECL|member|colWidth
name|int
name|colWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Requested width of each column when in column mode*/
DECL|member|actualWidth
name|int
name|actualWidth
index|[
literal|100
index|]
decl_stmt|;
comment|/* Actual width of each column */
DECL|member|nullvalue
name|char
name|nullvalue
index|[
literal|20
index|]
decl_stmt|;
comment|/* The text to print when a NULL comes back from                          ** the database */
DECL|member|explainPrev
name|struct
name|previous_mode_data
name|explainPrev
decl_stmt|;
comment|/* Holds the mode information just before                          ** .explain ON */
DECL|member|outfile
name|char
name|outfile
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
comment|/* Filename for *out */
DECL|member|zDbFilename
specifier|const
name|char
modifier|*
name|zDbFilename
decl_stmt|;
comment|/* name of the database file */
block|}
struct|;
end_struct
begin_comment
comment|/* ** These are the allowed modes. */
end_comment
begin_define
DECL|macro|MODE_Line
define|#
directive|define
name|MODE_Line
value|0
end_define
begin_comment
DECL|macro|MODE_Line
comment|/* One column per line.  Blank line between records */
end_comment
begin_define
DECL|macro|MODE_Column
define|#
directive|define
name|MODE_Column
value|1
end_define
begin_comment
DECL|macro|MODE_Column
comment|/* One record per line in neat columns */
end_comment
begin_define
DECL|macro|MODE_List
define|#
directive|define
name|MODE_List
value|2
end_define
begin_comment
DECL|macro|MODE_List
comment|/* One record per line with a separator */
end_comment
begin_define
DECL|macro|MODE_Semi
define|#
directive|define
name|MODE_Semi
value|3
end_define
begin_comment
DECL|macro|MODE_Semi
comment|/* Same as MODE_List but append ";" to each line */
end_comment
begin_define
DECL|macro|MODE_Html
define|#
directive|define
name|MODE_Html
value|4
end_define
begin_comment
DECL|macro|MODE_Html
comment|/* Generate an XHTML table */
end_comment
begin_define
DECL|macro|MODE_Insert
define|#
directive|define
name|MODE_Insert
value|5
end_define
begin_comment
DECL|macro|MODE_Insert
comment|/* Generate SQL "insert" statements */
end_comment
begin_define
DECL|macro|MODE_Tcl
define|#
directive|define
name|MODE_Tcl
value|6
end_define
begin_comment
DECL|macro|MODE_Tcl
comment|/* Generate ANSI-C or TCL quoted elements */
end_comment
begin_define
DECL|macro|MODE_Csv
define|#
directive|define
name|MODE_Csv
value|7
end_define
begin_comment
DECL|macro|MODE_Csv
comment|/* Quote strings, numbers are plain */
end_comment
begin_define
DECL|macro|MODE_Explain
define|#
directive|define
name|MODE_Explain
value|8
end_define
begin_comment
DECL|macro|MODE_Explain
comment|/* Like MODE_Column, but do not truncate data */
end_comment
begin_decl_stmt
DECL|variable|modeDescr
specifier|static
specifier|const
name|char
modifier|*
name|modeDescr
index|[]
init|=
block|{
literal|"line"
block|,
literal|"column"
block|,
literal|"list"
block|,
literal|"semi"
block|,
literal|"html"
block|,
literal|"insert"
block|,
literal|"tcl"
block|,
literal|"csv"
block|,
literal|"explain"
block|, }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** Number of elements in an array */
end_comment
begin_define
DECL|macro|ArraySize
define|#
directive|define
name|ArraySize
parameter_list|(
name|X
parameter_list|)
value|(sizeof(X)/sizeof(X[0]))
end_define
begin_comment
comment|/* ** Output the given string as a quoted string using SQL quoting conventions. */
end_comment
begin_function
DECL|function|output_quoted_string
specifier|static
name|void
name|output_quoted_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nSingle
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|nSingle
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nSingle
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'%s'"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"''"
argument_list|)
expr_stmt|;
name|z
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%.*s''"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ** Output the given string as a quoted according to C or TCL quoting rules. */
end_comment
begin_function
DECL|function|output_c_string
specifier|static
name|void
name|output_c_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
name|z
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'r'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ** Output the given string with characters that are special to ** HTML escaped. */
end_comment
begin_function
DECL|function|output_html_string
specifier|static
name|void
name|output_html_string
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|z
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'<'
operator|&&
name|z
index|[
name|i
index|]
operator|!=
literal|'&'
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'<'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|z
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ** If a field contains any character identified by a 1 in the following ** array, then the string must be quoted for CSV. */
end_comment
begin_decl_stmt
DECL|variable|needCsvQuote
specifier|static
specifier|const
name|char
name|needCsvQuote
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,    }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* ** Output a single term of CSV.  Actually, p->separator is used for ** the separator, which may or may not be a comma.  p->nullvalue is ** the null value.  Strings are quoted using ANSI-C rules.  Numbers ** appear outside of quotes. */
end_comment
begin_function
DECL|function|output_csv
specifier|static
name|void
name|output_csv
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|bSep
parameter_list|)
block|{
name|FILE
modifier|*
name|out
init|=
name|p
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|nSep
init|=
name|strlen
argument_list|(
name|p
operator|->
name|separator
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|needCsvQuote
index|[
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|z
operator|)
index|[
name|i
index|]
index|]
operator|||
operator|(
name|z
index|[
name|i
index|]
operator|==
name|p
operator|->
name|separator
index|[
literal|0
index|]
operator|&&
operator|(
name|nSep
operator|==
literal|1
operator|||
name|memcmp
argument_list|(
name|z
argument_list|,
name|p
operator|->
name|separator
argument_list|,
name|nSep
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|z
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|z
index|[
name|i
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bSep
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|SIGINT
end_ifdef
begin_comment
comment|/* ** This routine runs when the user presses Ctrl-C */
end_comment
begin_function
DECL|function|interrupt_handler
specifier|static
name|void
name|interrupt_handler
parameter_list|(
name|int
name|NotUsed
parameter_list|)
block|{
name|seenInterrupt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|db
condition|)
name|sqlite3_interrupt
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ** This is the callback routine that the SQLite library ** invokes for each row of a query result. */
end_comment
begin_function
DECL|function|callback
specifier|static
name|int
name|callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|callback_data
modifier|*
name|p
init|=
operator|(
expr|struct
name|callback_data
operator|*
operator|)
name|pArg
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_Line
case|:
block|{
name|int
name|w
init|=
literal|5
decl_stmt|;
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|w
condition|)
name|w
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%*s = %s\n"
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MODE_Explain
case|:
case|case
name|MODE_Column
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|colWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
block|{
name|w
operator|=
name|strlen
argument_list|(
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|10
condition|)
name|w
operator|=
literal|10
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|azArg
operator|&&
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
name|n
condition|)
name|w
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|showHeader
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
literal|"-----------------------------------"
literal|"----------------------------------------------------------"
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|actualWidth
argument_list|)
condition|)
block|{
name|w
operator|=
name|p
operator|->
name|actualWidth
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|w
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Explain
operator|&&
name|azArg
index|[
name|i
index|]
operator|&&
name|strlen
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
operator|>
name|w
condition|)
block|{
name|w
operator|=
name|strlen
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%-*.*s%s"
argument_list|,
name|w
argument_list|,
name|w
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
literal|"  "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MODE_Semi
case|:
case|case
name|MODE_List
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
name|i
operator|==
name|nArg
operator|-
literal|1
condition|?
literal|"\n"
else|:
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|azArg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
name|z
operator|=
name|p
operator|->
name|nullvalue
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nArg
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|mode
operator|==
name|MODE_Semi
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MODE_Html
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TH>%s</TH>"
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TR>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"<TD>"
argument_list|)
expr_stmt|;
name|output_html_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TD>\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"</TR>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Tcl
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
condition|?
name|azArg
index|[
name|i
index|]
else|:
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Csv
case|:
block|{
if|if
condition|(
name|p
operator|->
name|cnt
operator|++
operator|==
literal|0
operator|&&
name|p
operator|->
name|showHeader
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azCol
index|[
name|i
index|]
condition|?
name|azCol
index|[
name|i
index|]
else|:
literal|""
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|output_csv
argument_list|(
name|p
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|,
name|i
operator|<
name|nArg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MODE_Insert
case|:
block|{
if|if
condition|(
name|azArg
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"INSERT INTO %s VALUES("
argument_list|,
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|zSep
init|=
name|i
operator|>
literal|0
condition|?
literal|","
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|azArg
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%sNULL"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNumber
argument_list|(
name|azArg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s%s"
argument_list|,
name|zSep
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSep
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s"
argument_list|,
name|zSep
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|azArg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|");\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ** Set the destination table field of the callback_data structure to ** the name of the table given.  Escape any quote characters in the ** table name. */
end_comment
begin_function
DECL|function|set_table_name
specifier|static
name|void
name|set_table_name
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zName
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|needQuote
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|zDestTable
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|zDestTable
argument_list|)
expr_stmt|;
name|p
operator|->
name|zDestTable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zName
operator|==
literal|0
condition|)
return|return;
name|needQuote
operator|=
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|zName
argument_list|)
operator|&&
operator|*
name|zName
operator|!=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zName
index|[
name|i
index|]
argument_list|)
operator|&&
name|zName
index|[
name|i
index|]
operator|!=
literal|'_'
condition|)
block|{
name|needQuote
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zName
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needQuote
condition|)
name|n
operator|+=
literal|2
expr_stmt|;
name|z
operator|=
name|p
operator|->
name|zDestTable
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zName
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|z
index|[
name|n
operator|++
index|]
operator|=
name|zName
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zName
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
block|}
if|if
condition|(
name|needQuote
condition|)
name|z
index|[
name|n
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
name|z
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* zIn is either a pointer to a NULL-terminated string in memory obtained ** from malloc(), or a NULL pointer. The string pointed to by zAppend is ** added to zIn, and the result returned in memory obtained from malloc(). ** zIn, if it was not NULL, is freed. ** ** If the third argument, quote, is not '\0', then it is used as a  ** quote character for zAppend. */
end_comment
begin_function
DECL|function|appendText
specifier|static
name|char
modifier|*
name|appendText
parameter_list|(
name|char
modifier|*
name|zIn
parameter_list|,
name|char
specifier|const
modifier|*
name|zAppend
parameter_list|,
name|char
name|quote
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nAppend
init|=
name|strlen
argument_list|(
name|zAppend
argument_list|)
decl_stmt|;
name|int
name|nIn
init|=
operator|(
name|zIn
condition|?
name|strlen
argument_list|(
name|zIn
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|len
operator|=
name|nAppend
operator|+
name|nIn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|quote
condition|)
block|{
name|len
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
name|len
operator|++
expr_stmt|;
block|}
block|}
name|zIn
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|zIn
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zIn
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|quote
condition|)
block|{
name|char
modifier|*
name|zCsr
init|=
operator|&
name|zIn
index|[
name|nIn
index|]
decl_stmt|;
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nAppend
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|zCsr
operator|++
operator|=
name|zAppend
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zAppend
index|[
name|i
index|]
operator|==
name|quote
condition|)
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
block|}
operator|*
name|zCsr
operator|++
operator|=
name|quote
expr_stmt|;
operator|*
name|zCsr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
operator|(
name|zCsr
operator|-
name|zIn
operator|)
operator|==
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|zIn
index|[
name|nIn
index|]
argument_list|,
name|zAppend
argument_list|,
name|nAppend
argument_list|)
expr_stmt|;
name|zIn
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|zIn
return|;
block|}
end_function
begin_comment
comment|/* ** Execute a query statement that has a single result column.  Print ** that result column on a line by itself with a semicolon terminator. ** ** This is used, for example, to show the schema of the database by ** querying the SQLITE_MASTER table. */
end_comment
begin_function
DECL|function|run_table_dump_query
specifier|static
name|int
name|run_table_dump_query
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|sqlite3
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|zSelect
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|pSelect
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|db
argument_list|,
name|zSelect
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pSelect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
operator|!
name|pSelect
condition|)
block|{
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s;\n"
argument_list|,
name|sqlite3_column_text
argument_list|(
name|pSelect
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pSelect
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlite3_finalize
argument_list|(
name|pSelect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* ** This is a different callback routine used for dumping the database. ** Each row received by this callback consists of a table name, ** the table type ("index" or "table") and SQL to create the table. ** This routine should print text sufficient to recreate the table. */
end_comment
begin_function
DECL|function|dump_callback
specifier|static
name|int
name|dump_callback
parameter_list|(
name|void
modifier|*
name|pArg
parameter_list|,
name|int
name|nArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azArg
parameter_list|,
name|char
modifier|*
modifier|*
name|azCol
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|zTable
decl_stmt|;
specifier|const
name|char
modifier|*
name|zType
decl_stmt|;
specifier|const
name|char
modifier|*
name|zSql
decl_stmt|;
name|struct
name|callback_data
modifier|*
name|p
init|=
operator|(
expr|struct
name|callback_data
operator|*
operator|)
name|pArg
decl_stmt|;
if|if
condition|(
name|nArg
operator|!=
literal|3
condition|)
return|return
literal|1
return|;
name|zTable
operator|=
name|azArg
index|[
literal|0
index|]
expr_stmt|;
name|zType
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zSql
operator|=
name|azArg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_sequence"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"DELETE FROM sqlite_sequence;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_stat1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"ANALYZE sqlite_master;\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zTable
argument_list|,
literal|"sqlite_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zSql
argument_list|,
literal|"CREATE VIRTUAL TABLE"
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zIns
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|writableSchema
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=ON;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|1
expr_stmt|;
block|}
name|zIns
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"
literal|"VALUES('table','%q','%q',0,'%q');"
argument_list|,
name|zTable
argument_list|,
name|zTable
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|zIns
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zIns
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%s;\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zType
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3_stmt
modifier|*
name|pTableInfo
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zSelect
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zTableInfo
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zTmp
init|=
literal|0
decl_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
literal|"PRAGMA table_info("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|zTableInfo
operator|=
name|appendText
argument_list|(
name|zTableInfo
argument_list|,
literal|");"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zTableInfo
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pTableInfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zTableInfo
condition|)
name|free
argument_list|(
name|zTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
operator|||
operator|!
name|pTableInfo
condition|)
block|{
return|return
literal|1
return|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"SELECT 'INSERT INTO ' || "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zTmp
operator|=
name|appendText
argument_list|(
name|zTmp
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zTmp
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zTmp
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|" || ' VALUES(' || "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
specifier|const
name|char
modifier|*
name|zText
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|pTableInfo
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"quote("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zText
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_step
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_ROW
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|") || ',' || "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|") "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|sqlite3_finalize
argument_list|(
name|pTableInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
if|if
condition|(
name|zSelect
condition|)
name|free
argument_list|(
name|zSelect
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|"|| ')' FROM  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
name|zTable
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|rc
operator|=
name|run_table_dump_query
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|zSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|zSelect
operator|=
name|appendText
argument_list|(
name|zSelect
argument_list|,
literal|" ORDER BY rowid DESC"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|run_table_dump_query
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|db
argument_list|,
name|zSelect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zSelect
condition|)
name|free
argument_list|(
name|zSelect
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ** Run zQuery.  Use dump_callback() as the callback routine so that ** the contents of the query are output as SQL statements. ** ** If we get a SQLITE_CORRUPT error, rerun the query after appending ** "ORDER BY rowid DESC" to the end. */
end_comment
begin_function
DECL|function|run_schema_dump_query
specifier|static
name|int
name|run_schema_dump_query
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|zQuery
parameter_list|,
name|char
modifier|*
modifier|*
name|pzErrMsg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQuery
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
name|pzErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|SQLITE_CORRUPT
condition|)
block|{
name|char
modifier|*
name|zQ2
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|zQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|pzErrMsg
condition|)
name|sqlite3_free
argument_list|(
operator|*
name|pzErrMsg
argument_list|)
expr_stmt|;
name|zQ2
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQ2
operator|==
literal|0
condition|)
return|return
name|rc
return|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zQ2
argument_list|)
argument_list|,
name|zQ2
argument_list|,
literal|"%s ORDER BY rowid DESC"
argument_list|,
name|zQuery
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zQ2
argument_list|,
name|dump_callback
argument_list|,
name|p
argument_list|,
name|pzErrMsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zQ2
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_comment
comment|/* ** Text of a help message */
end_comment
begin_decl_stmt
DECL|variable|zHelp
specifier|static
name|char
name|zHelp
index|[]
init|=
literal|".bail ON|OFF           Stop after hitting an error.  Default OFF\n"
literal|".databases             List names and files of attached databases\n"
literal|".dump ?TABLE? ...      Dump the database in an SQL text format\n"
literal|".echo ON|OFF           Turn command echo on or off\n"
literal|".exit                  Exit this program\n"
literal|".explain ON|OFF        Turn output mode suitable for EXPLAIN on or off.\n"
literal|".header(s) ON|OFF      Turn display of headers on or off\n"
literal|".help                  Show this message\n"
literal|".import FILE TABLE     Import data from FILE into TABLE\n"
literal|".indices TABLE         Show names of all indices on TABLE\n"
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
literal|".iotrace FILE          Enable I/O diagnostic logging to FILE\n"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
literal|".load FILE ?ENTRY?     Load an extension library\n"
endif|#
directive|endif
literal|".mode MODE ?TABLE?     Set output mode where MODE is one of:\n"
literal|"                         csv      Comma-separated values\n"
literal|"                         column   Left-aligned columns.  (See .width)\n"
literal|"                         html     HTML<table> code\n"
literal|"                         insert   SQL insert statements for TABLE\n"
literal|"                         line     One value per line\n"
literal|"                         list     Values delimited by .separator string\n"
literal|"                         tabs     Tab-separated values\n"
literal|"                         tcl      TCL list elements\n"
literal|".nullvalue STRING      Print STRING in place of NULL values\n"
literal|".output FILENAME       Send output to FILENAME\n"
literal|".output stdout         Send output to the screen\n"
literal|".prompt MAIN CONTINUE  Replace the standard prompts\n"
literal|".quit                  Exit this program\n"
literal|".read FILENAME         Execute SQL in FILENAME\n"
literal|".schema ?TABLE?        Show the CREATE statements\n"
literal|".separator STRING      Change separator used by output mode and .import\n"
literal|".show                  Show the current values for various settings\n"
literal|".tables ?PATTERN?      List names of tables matching a LIKE pattern\n"
literal|".timeout MS            Try opening locked tables for MS milliseconds\n"
if|#
directive|if
name|HAS_TIMER
literal|".timer ON|OFF          Turn the CPU timer measurement on or off\n"
endif|#
directive|endif
literal|".width NUM NUM ...     Set column widths for \"column\" mode\n"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Forward reference */
end_comment
begin_function_decl
specifier|static
name|int
name|process_input
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* ** Make sure the database is open.  If it is not, then open it.  If ** the database fails to open, print an error message and exit. */
end_comment
begin_function
DECL|function|open_db
specifier|static
name|void
name|open_db
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|db
operator|==
literal|0
condition|)
block|{
name|sqlite3_open
argument_list|(
name|p
operator|->
name|zDbFilename
argument_list|,
operator|&
name|p
operator|->
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|p
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|db
operator|&&
name|sqlite3_errcode
argument_list|(
name|db
argument_list|)
operator|==
name|SQLITE_OK
condition|)
block|{
name|sqlite3_create_function
argument_list|(
name|db
argument_list|,
literal|"shellstatic"
argument_list|,
literal|0
argument_list|,
name|SQLITE_UTF8
argument_list|,
literal|0
argument_list|,
name|shellstaticFunc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|==
literal|0
operator|||
name|SQLITE_OK
operator|!=
name|sqlite3_errcode
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open database \"%s\": %s\n"
argument_list|,
name|p
operator|->
name|zDbFilename
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
name|sqlite3_enable_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_comment
comment|/* ** Do C-language style dequoting. ** **    \t    -> tab **    \n    -> newline **    \r    -> carriage return **    \NNN  -> ascii character NNN in octal **    \\    -> backslash */
end_comment
begin_function
DECL|function|resolve_backslashes
specifier|static
name|void
name|resolve_backslashes
parameter_list|(
name|char
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|z
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|z
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
block|{
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|z
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
block|}
block|}
name|z
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
block|}
name|z
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ** Interpret zArg as a boolean value.  Return either 0 or 1. */
end_comment
begin_function
DECL|function|booleanValue
specifier|static
name|int
name|booleanValue
parameter_list|(
name|char
modifier|*
name|zArg
parameter_list|)
block|{
name|int
name|val
init|=
name|atoi
argument_list|(
name|zArg
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|zArg
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|zArg
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
name|zArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|zArg
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/* ** If an input line begins with "." then invoke this routine to ** process that line. ** ** Return 1 on error, 2 to exit, and 0 otherwise. */
end_comment
begin_function
DECL|function|do_meta_command
specifier|static
name|int
name|do_meta_command
parameter_list|(
name|char
modifier|*
name|zLine
parameter_list|,
name|struct
name|callback_data
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|nArg
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|azArg
index|[
literal|50
index|]
decl_stmt|;
comment|/* Parse the input line into tokens.   */
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
name|nArg
operator|<
name|ArraySize
argument_list|(
name|azArg
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zLine
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
literal|'\''
operator|||
name|zLine
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
name|int
name|delim
init|=
name|zLine
index|[
name|i
operator|++
index|]
decl_stmt|;
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
name|zLine
index|[
name|i
index|]
operator|!=
name|delim
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|==
name|delim
condition|)
block|{
name|zLine
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|==
literal|'"'
condition|)
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|azArg
index|[
name|nArg
operator|++
index|]
operator|=
operator|&
name|zLine
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|zLine
index|[
name|i
index|]
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zLine
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zLine
index|[
name|i
index|]
condition|)
name|zLine
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|resolve_backslashes
argument_list|(
name|azArg
index|[
name|nArg
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the input line.   */
if|if
condition|(
name|nArg
operator|==
literal|0
condition|)
return|return
name|rc
return|;
name|n
operator|=
name|strlen
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|azArg
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'b'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"bail"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>
literal|1
condition|)
block|{
name|bail_on_error
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"databases"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_Column
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|1
index|]
operator|=
literal|15
expr_stmt|;
name|data
operator|.
name|colWidth
index|[
literal|2
index|]
operator|=
literal|58
expr_stmt|;
name|data
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"PRAGMA database_list; "
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"dump"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"BEGIN TRANSACTION;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type=='table'"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL AND type IN ('index','trigger','view')"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nArg
condition|;
name|i
operator|++
control|)
block|{
name|zShellStatic
operator|=
name|azArg
index|[
name|i
index|]
expr_stmt|;
name|run_schema_dump_query
argument_list|(
name|p
argument_list|,
literal|"SELECT name, type, sql FROM sqlite_master "
literal|"WHERE tbl_name LIKE shellstatic() AND type=='table'"
literal|"  AND sql NOT NULL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_table_dump_query
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM sqlite_master "
literal|"WHERE sql NOT NULL"
literal|"  AND type IN ('index','trigger','view')"
literal|"  AND tbl_name LIKE shellstatic()"
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|writableSchema
condition|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"PRAGMA writable_schema=OFF;\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|writableSchema
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"COMMIT;\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"echo"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>
literal|1
condition|)
block|{
name|p
operator|->
name|echoOn
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"explain"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|val
init|=
name|nArg
operator|>=
literal|2
condition|?
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|)
block|{
name|p
operator|->
name|explainPrev
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|explainPrev
operator|.
name|mode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|explainPrev
operator|.
name|showHeader
operator|=
name|p
operator|->
name|showHeader
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|explainPrev
operator|.
name|colWidth
argument_list|,
name|p
operator|->
name|colWidth
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We could put this code under the !p->explainValid       ** condition so that it does not execute if we are already in       ** explain mode. However, always executing it allows us an easy       ** was to reset to explain mode in case the user previously       ** did an .explain followed by a .width, .mode or .header       ** command.       */
name|p
operator|->
name|mode
operator|=
name|MODE_Explain
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|colWidth
argument_list|,
literal|0
argument_list|,
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|colWidth
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* addr */
name|p
operator|->
name|colWidth
index|[
literal|1
index|]
operator|=
literal|13
expr_stmt|;
comment|/* opcode */
name|p
operator|->
name|colWidth
index|[
literal|2
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P1 */
name|p
operator|->
name|colWidth
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P2 */
name|p
operator|->
name|colWidth
index|[
literal|4
index|]
operator|=
literal|4
expr_stmt|;
comment|/* P3 */
name|p
operator|->
name|colWidth
index|[
literal|5
index|]
operator|=
literal|13
expr_stmt|;
comment|/* P4 */
name|p
operator|->
name|colWidth
index|[
literal|6
index|]
operator|=
literal|2
expr_stmt|;
comment|/* P5 */
name|p
operator|->
name|colWidth
index|[
literal|7
index|]
operator|=
literal|13
expr_stmt|;
comment|/* Comment */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|)
block|{
name|p
operator|->
name|explainPrev
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|p
operator|->
name|explainPrev
operator|.
name|mode
expr_stmt|;
name|p
operator|->
name|showHeader
operator|=
name|p
operator|->
name|explainPrev
operator|.
name|showHeader
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|colWidth
argument_list|,
name|p
operator|->
name|explainPrev
operator|.
name|colWidth
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
operator|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"header"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"headers"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|nArg
operator|>
literal|1
condition|)
block|{
name|p
operator|->
name|showHeader
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'h'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"help"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zHelp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"import"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|3
condition|)
block|{
name|char
modifier|*
name|zTable
init|=
name|azArg
index|[
literal|2
index|]
decl_stmt|;
comment|/* Insert data into this table */
name|char
modifier|*
name|zFile
init|=
name|azArg
index|[
literal|1
index|]
decl_stmt|;
comment|/* The file from which to extract data */
name|sqlite3_stmt
modifier|*
name|pStmt
decl_stmt|;
comment|/* A statement */
name|int
name|rc
decl_stmt|;
comment|/* Result code */
name|int
name|nCol
decl_stmt|;
comment|/* Number of columns in the table */
name|int
name|nByte
decl_stmt|;
comment|/* Number of bytes in an SQL string */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Loop counters */
name|int
name|nSep
decl_stmt|;
comment|/* Number of bytes in p->separator[] */
name|char
modifier|*
name|zSql
decl_stmt|;
comment|/* An SQL statement */
name|char
modifier|*
name|zLine
decl_stmt|;
comment|/* A single line of input from the file */
name|char
modifier|*
modifier|*
name|azCol
decl_stmt|;
comment|/* zLine[] broken up into columns */
name|char
modifier|*
name|zCommit
decl_stmt|;
comment|/* How to commit changes */
name|FILE
modifier|*
name|in
decl_stmt|;
comment|/* The input file */
name|int
name|lineno
init|=
literal|0
decl_stmt|;
comment|/* Line number of input file */
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nSep
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSep
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-null separator required for import\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zSql
operator|=
name|sqlite3_mprintf
argument_list|(
literal|"SELECT * FROM '%q'"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|nByte
operator|=
name|strlen
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|nCol
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nCol
operator|=
name|sqlite3_column_count
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nCol
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|zSql
operator|=
name|malloc
argument_list|(
name|nByte
operator|+
literal|20
operator|+
name|nCol
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sqlite3_snprintf
argument_list|(
name|nByte
operator|+
literal|20
argument_list|,
name|zSql
argument_list|,
literal|"INSERT INTO '%q' VALUES(?"
argument_list|,
name|zTable
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
name|zSql
index|[
name|j
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|zSql
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|sqlite3_prepare
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pStmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|zFile
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open file: %s\n"
argument_list|,
name|zFile
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|azCol
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|azCol
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nCol
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|azCol
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zCommit
operator|=
literal|"COMMIT"
expr_stmt|;
while|while
condition|(
operator|(
name|zLine
operator|=
name|local_getline
argument_list|(
literal|0
argument_list|,
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
name|azCol
index|[
literal|0
index|]
operator|=
name|zLine
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|z
operator|=
name|zLine
init|;
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\n'
operator|&&
operator|*
name|z
operator|!=
literal|'\r'
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
name|p
operator|->
name|separator
index|[
literal|0
index|]
operator|&&
name|strncmp
argument_list|(
name|z
argument_list|,
name|p
operator|->
name|separator
argument_list|,
name|nSep
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|z
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nCol
condition|)
block|{
name|azCol
index|[
name|i
index|]
operator|=
operator|&
name|z
index|[
name|nSep
index|]
expr_stmt|;
name|z
operator|+=
name|nSep
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
operator|*
name|z
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|nCol
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s line %d: expected %d columns of data but found %d\n"
argument_list|,
name|zFile
argument_list|,
name|lineno
argument_list|,
name|nCol
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zCommit
operator|=
literal|"ROLLBACK"
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCol
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_bind_text
argument_list|(
name|pStmt
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|azCol
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|SQLITE_STATIC
argument_list|)
expr_stmt|;
block|}
name|sqlite3_step
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_reset
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|zCommit
operator|=
literal|"ROLLBACK"
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|azCol
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sqlite3_finalize
argument_list|(
name|pStmt
argument_list|)
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zCommit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"indices"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>
literal|1
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|zShellStatic
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM sqlite_master "
literal|"WHERE type='index' AND tbl_name LIKE shellstatic() "
literal|"UNION ALL "
literal|"SELECT name FROM sqlite_temp_master "
literal|"WHERE type='index' AND tbl_name LIKE shellstatic() "
literal|"ORDER BY 1"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|SQLITE_ENABLE_IOTRACE
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"iotrace"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|extern
name|void
function_decl|(
modifier|*
name|sqlite3IoTrace
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
if|if
condition|(
name|iotrace
operator|&&
name|iotrace
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|iotrace
argument_list|)
expr_stmt|;
name|iotrace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nArg
operator|<
literal|2
condition|)
block|{
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
name|iotrace
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|iotrace
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iotrace
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sqlite3IoTrace
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sqlite3IoTrace
operator|=
name|iotracePrintf
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SQLITE_OMIT_LOAD_EXTENSION
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"load"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|2
condition|)
block|{
specifier|const
name|char
modifier|*
name|zFile
decl_stmt|,
modifier|*
name|zProc
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|zFile
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|zProc
operator|=
name|nArg
operator|>=
literal|3
condition|?
name|azArg
index|[
literal|2
index|]
else|:
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_load_extension
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zFile
argument_list|,
name|zProc
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'m'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|2
condition|)
block|{
name|int
name|n2
init|=
name|strlen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"line"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"lines"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"column"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"columns"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Column
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"list"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"html"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tcl"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Tcl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"csv"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"tabs"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"insert"
argument_list|,
name|n2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|mode
operator|=
name|MODE_Insert
expr_stmt|;
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
name|set_table_name
argument_list|(
name|p
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_table_name
argument_list|(
name|p
argument_list|,
literal|"table"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode should be one of: "
literal|"column csv html insert line list tabs tcl\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"nullvalue"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|==
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|nullvalue
argument_list|)
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|nullvalue
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"output"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|out
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"stdout"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|out
operator|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|out
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't write to \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|out
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
argument_list|,
name|p
operator|->
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"prompt"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|nArg
operator|==
literal|2
operator|||
name|nArg
operator|==
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|nArg
operator|>=
literal|2
condition|)
block|{
name|strncpy
argument_list|(
name|mainPrompt
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|mainPrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nArg
operator|>=
literal|3
condition|)
block|{
name|strncpy
argument_list|(
name|continuePrompt
argument_list|,
name|azArg
index|[
literal|2
index|]
argument_list|,
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|continuePrompt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'q'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"read"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|==
literal|2
condition|)
block|{
name|FILE
modifier|*
name|alt
init|=
name|fopen
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|alt
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open \"%s\"\n"
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|process_input
argument_list|(
name|p
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"schema"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|callback_data
name|data
decl_stmt|;
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|mode
operator|=
name|MODE_Semi
expr_stmt|;
if|if
condition|(
name|nArg
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|azArg
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TABLE sqlite_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|,
literal|"sqlite_temp_master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|new_argv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|new_colv
index|[
literal|2
index|]
decl_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
literal|"CREATE TEMP TABLE sqlite_temp_master (\n"
literal|"  type text,\n"
literal|"  name text,\n"
literal|"  tbl_name text,\n"
literal|"  rootpage integer,\n"
literal|"  sql text\n"
literal|")"
expr_stmt|;
name|new_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_colv
index|[
literal|0
index|]
operator|=
literal|"sql"
expr_stmt|;
name|new_colv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|callback
argument_list|(
operator|&
name|data
argument_list|,
literal|1
argument_list|,
name|new_argv
argument_list|,
name|new_colv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zShellStatic
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM "
literal|"  (SELECT * FROM sqlite_master UNION ALL"
literal|"   SELECT * FROM sqlite_temp_master) "
literal|"WHERE tbl_name LIKE shellstatic() AND type!='meta' AND sql NOTNULL "
literal|"ORDER BY substr(type,2,1), name"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT sql FROM "
literal|"  (SELECT * FROM sqlite_master UNION ALL"
literal|"   SELECT * FROM sqlite_temp_master) "
literal|"WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"
literal|"ORDER BY substr(type,2,1), name"
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"separator"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|==
literal|2
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
argument_list|,
name|p
operator|->
name|separator
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|p
operator|->
name|separator
argument_list|)
operator|-
literal|1
argument_list|,
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"show"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"echo"
argument_list|,
name|p
operator|->
name|echoOn
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"explain"
argument_list|,
name|p
operator|->
name|explainPrev
operator|.
name|valid
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"headers"
argument_list|,
name|p
operator|->
name|showHeader
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"mode"
argument_list|,
name|modeDescr
index|[
name|p
operator|->
name|mode
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"nullvalue"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|nullvalue
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: %s\n"
argument_list|,
literal|"output"
argument_list|,
name|strlen
argument_list|(
name|p
operator|->
name|outfile
argument_list|)
condition|?
name|p
operator|->
name|outfile
else|:
literal|"stdout"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"separator"
argument_list|)
expr_stmt|;
name|output_c_string
argument_list|(
name|p
operator|->
name|out
argument_list|,
name|p
operator|->
name|separator
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%9.9s: "
argument_list|,
literal|"width"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
operator|&&
name|p
operator|->
name|colWidth
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"%d "
argument_list|,
name|p
operator|->
name|colWidth
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"tables"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|azResult
decl_stmt|;
name|int
name|nRow
decl_stmt|,
name|rc
decl_stmt|;
name|char
modifier|*
name|zErrMsg
decl_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nArg
operator|==
literal|1
condition|)
block|{
name|rc
operator|=
name|sqlite3_get_table
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM sqlite_master "
literal|"WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%'"
literal|"UNION ALL "
literal|"SELECT name FROM sqlite_temp_master "
literal|"WHERE type IN ('table','view') "
literal|"ORDER BY 1"
argument_list|,
operator|&
name|azResult
argument_list|,
operator|&
name|nRow
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zShellStatic
operator|=
name|azArg
index|[
literal|1
index|]
expr_stmt|;
name|rc
operator|=
name|sqlite3_get_table
argument_list|(
name|p
operator|->
name|db
argument_list|,
literal|"SELECT name FROM sqlite_master "
literal|"WHERE type IN ('table','view') AND name LIKE '%'||shellstatic()||'%' "
literal|"UNION ALL "
literal|"SELECT name FROM sqlite_temp_master "
literal|"WHERE type IN ('table','view') AND name LIKE '%'||shellstatic()||'%' "
literal|"ORDER BY 1"
argument_list|,
operator|&
name|azResult
argument_list|,
operator|&
name|nRow
argument_list|,
literal|0
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|zShellStatic
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|SQLITE_OK
condition|)
block|{
name|int
name|len
decl_stmt|,
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nPrintCol
decl_stmt|,
name|nPrintRow
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nRow
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|azResult
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
name|azResult
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
block|}
name|nPrintCol
operator|=
literal|80
operator|/
operator|(
name|maxlen
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|nPrintCol
operator|<
literal|1
condition|)
name|nPrintCol
operator|=
literal|1
expr_stmt|;
name|nPrintRow
operator|=
operator|(
name|nRow
operator|+
name|nPrintCol
operator|-
literal|1
operator|)
operator|/
name|nPrintCol
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPrintRow
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|nRow
condition|;
name|j
operator|+=
name|nPrintRow
control|)
block|{
name|char
modifier|*
name|zSp
init|=
name|j
operator|<=
name|nPrintRow
condition|?
literal|""
else|:
literal|"  "
decl_stmt|;
name|printf
argument_list|(
literal|"%s%-*s"
argument_list|,
name|zSp
argument_list|,
name|maxlen
argument_list|,
name|azResult
index|[
name|j
index|]
condition|?
name|azResult
index|[
name|j
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|sqlite3_free_table
argument_list|(
name|azResult
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>
literal|4
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timeout"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>=
literal|2
condition|)
block|{
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sqlite3_busy_timeout
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|atoi
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|#
directive|if
name|HAS_TIMER
if|if
condition|(
name|c
operator|==
literal|'t'
operator|&&
name|n
operator|>=
literal|5
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"timer"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|nArg
operator|>
literal|1
condition|)
block|{
name|enableTimer
operator|=
name|booleanValue
argument_list|(
name|azArg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'w'
operator|&&
name|strncmp
argument_list|(
name|azArg
index|[
literal|0
index|]
argument_list|,
literal|"width"
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|assert
argument_list|(
name|nArg
operator|<=
name|ArraySize
argument_list|(
name|azArg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nArg
operator|&&
name|j
operator|<
name|ArraySize
argument_list|(
name|p
operator|->
name|colWidth
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|->
name|colWidth
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|atoi
argument_list|(
name|azArg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown command or invalid arguments: "
literal|" \"%s\". Enter \".help\" for help\n"
argument_list|,
name|azArg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_comment
comment|/* ** Return TRUE if a semicolon occurs anywhere in the first N characters ** of string z[]. */
end_comment
begin_function
DECL|function|_contains_semicolon
specifier|static
name|int
name|_contains_semicolon
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|,
name|int
name|N
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
index|]
operator|==
literal|';'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ** Test to see if a line consists entirely of whitespace. */
end_comment
begin_function
DECL|function|_all_whitespace
specifier|static
name|int
name|_all_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|z
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|z
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|z
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|z
operator|==
literal|'/'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|(
operator|*
name|z
operator|!=
literal|'*'
operator|||
name|z
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|z
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|&&
operator|*
name|z
operator|!=
literal|'\n'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|0
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* ** Return TRUE if the line typed in is an SQL command terminator other ** than a semi-colon.  The SQL Server style "go" command is understood ** as is the Oracle "/". */
end_comment
begin_function
DECL|function|_is_command_terminator
specifier|static
name|int
name|_is_command_terminator
parameter_list|(
specifier|const
name|char
modifier|*
name|zLine
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|zLine
argument_list|)
condition|)
block|{
name|zLine
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|zLine
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Oracle */
if|if
condition|(
name|tolower
argument_list|(
name|zLine
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'g'
operator|&&
name|tolower
argument_list|(
name|zLine
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'o'
operator|&&
name|_all_whitespace
argument_list|(
operator|&
name|zLine
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* SQL Server */
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* ** Read input from *in and process it.  If *in==0 then input ** is interactive - the user is typing it it.  Otherwise, input ** is coming from a file or device.  A prompt is issued and history ** is saved only if input is interactive.  An interrupt signal will ** cause this routine to exit immediately, unless input is interactive. ** ** Return the number of errors. */
end_comment
begin_function
DECL|function|process_input
specifier|static
name|int
name|process_input
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|zLine
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zSql
init|=
literal|0
decl_stmt|;
name|int
name|nSql
init|=
literal|0
decl_stmt|;
name|int
name|nSqlPrior
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zErrMsg
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|errCnt
init|=
literal|0
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|int
name|startline
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|errCnt
operator|==
literal|0
operator|||
operator|!
name|bail_on_error
operator|||
operator|(
name|in
operator|==
literal|0
operator|&&
name|stdin_is_interactive
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|p
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
name|zLine
operator|=
name|one_input_line
argument_list|(
name|zSql
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|zLine
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* We have reached EOF */
block|}
if|if
condition|(
name|seenInterrupt
condition|)
block|{
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
break|break;
name|seenInterrupt
operator|=
literal|0
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|echoOn
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zLine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSql
operator|==
literal|0
operator|||
name|zSql
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
name|_all_whitespace
argument_list|(
name|zLine
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|zLine
operator|&&
name|zLine
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|nSql
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|do_meta_command
argument_list|(
name|zLine
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|errCnt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|_is_command_terminator
argument_list|(
name|zLine
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|zLine
argument_list|,
literal|";"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|nSqlPrior
operator|=
name|nSql
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zLine
index|[
name|i
index|]
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|zLine
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{}
if|if
condition|(
name|zLine
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|nSql
operator|=
name|strlen
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
name|zSql
operator|=
name|malloc
argument_list|(
name|nSql
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|zSql
argument_list|,
name|zLine
argument_list|,
name|nSql
operator|+
literal|1
argument_list|)
expr_stmt|;
name|startline
operator|=
name|lineno
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|zLine
argument_list|)
decl_stmt|;
name|zSql
operator|=
name|realloc
argument_list|(
name|zSql
argument_list|,
name|nSql
operator|+
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSql
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory!\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|zSql
index|[
name|nSql
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|zSql
index|[
name|nSql
index|]
argument_list|,
name|zLine
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nSql
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|zSql
operator|&&
name|_contains_semicolon
argument_list|(
operator|&
name|zSql
index|[
name|nSqlPrior
index|]
argument_list|,
name|nSql
operator|-
name|nSqlPrior
argument_list|)
operator|&&
name|sqlite3_complete
argument_list|(
name|zSql
argument_list|)
condition|)
block|{
name|p
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|open_db
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|BEGIN_TIMER
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|p
operator|->
name|db
argument_list|,
name|zSql
argument_list|,
name|callback
argument_list|,
name|p
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
name|END_TIMER
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|zErrMsg
condition|)
block|{
name|char
name|zPrefix
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
operator|||
operator|!
name|stdin_is_interactive
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"SQL error near line %d:"
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|zPrefix
argument_list|)
argument_list|,
name|zPrefix
argument_list|,
literal|"SQL error:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|sqlite3_free
argument_list|(
name|zErrMsg
argument_list|)
expr_stmt|;
name|zErrMsg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|zPrefix
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|p
operator|->
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|errCnt
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
name|zSql
operator|=
literal|0
expr_stmt|;
name|nSql
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zSql
condition|)
block|{
if|if
condition|(
operator|!
name|_all_whitespace
argument_list|(
name|zSql
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Incomplete SQL: %s\n"
argument_list|,
name|zSql
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zSql
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zLine
argument_list|)
expr_stmt|;
return|return
name|errCnt
return|;
block|}
end_function
begin_comment
comment|/* ** Return a pathname which is the user's home directory.  A ** 0 return indicates an error of some kind.  Space to hold the ** resulting string is obtained from malloc().  The calling ** function should free the result. */
end_comment
begin_function
DECL|function|find_home_dir
specifier|static
name|char
modifier|*
name|find_home_dir
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OS2__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|uid_t
name|uid
init|=
name|getuid
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|pwent
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|pwent
operator|->
name|pw_dir
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
comment|/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()    */
name|home_dir
operator|=
name|strdup
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"USERPROFILE"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|home_dir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__OS2__
argument_list|)
if|if
condition|(
operator|!
name|home_dir
condition|)
block|{
name|char
modifier|*
name|zDrive
decl_stmt|,
modifier|*
name|zPath
decl_stmt|;
name|int
name|n
decl_stmt|;
name|zDrive
operator|=
name|getenv
argument_list|(
literal|"HOMEDRIVE"
argument_list|)
expr_stmt|;
name|zPath
operator|=
name|getenv
argument_list|(
literal|"HOMEPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDrive
operator|&&
name|zPath
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|zDrive
argument_list|)
operator|+
name|strlen
argument_list|(
name|zPath
argument_list|)
operator|+
literal|1
expr_stmt|;
name|home_dir
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sqlite3_snprintf
argument_list|(
name|n
argument_list|,
name|home_dir
argument_list|,
literal|"%s%s"
argument_list|,
name|zDrive
argument_list|,
name|zPath
argument_list|)
expr_stmt|;
return|return
name|home_dir
return|;
block|}
name|home_dir
operator|=
literal|"c:\\"
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* !_WIN32_WCE */
if|if
condition|(
name|home_dir
condition|)
block|{
name|int
name|n
init|=
name|strlen
argument_list|(
name|home_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|z
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|z
condition|)
name|memcpy
argument_list|(
name|z
argument_list|,
name|home_dir
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|home_dir
operator|=
name|z
expr_stmt|;
block|}
return|return
name|home_dir
return|;
block|}
end_function
begin_comment
comment|/* ** Read input from the file given by sqliterc_override.  Or if that ** parameter is NULL, take input from ~/.sqliterc */
end_comment
begin_function
DECL|function|process_sqliterc
specifier|static
name|void
name|process_sqliterc
parameter_list|(
name|struct
name|callback_data
modifier|*
name|p
parameter_list|,
comment|/* Configuration data */
specifier|const
name|char
modifier|*
name|sqliterc_override
comment|/* Name of config file. NULL to use default */
parameter_list|)
block|{
name|char
modifier|*
name|home_dir
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sqliterc
init|=
name|sqliterc_override
decl_stmt|;
name|char
modifier|*
name|zBuf
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|NULL
decl_stmt|;
name|int
name|nBuf
decl_stmt|;
if|if
condition|(
name|sqliterc
operator|==
name|NULL
condition|)
block|{
name|home_dir
operator|=
name|find_home_dir
argument_list|()
expr_stmt|;
if|if
condition|(
name|home_dir
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot locate your home directory!\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
return|return;
block|}
name|nBuf
operator|=
name|strlen
argument_list|(
name|home_dir
argument_list|)
operator|+
literal|16
expr_stmt|;
name|zBuf
operator|=
name|malloc
argument_list|(
name|nBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zBuf
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory!\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sqlite3_snprintf
argument_list|(
name|nBuf
argument_list|,
name|zBuf
argument_list|,
literal|"%s/.sqliterc"
argument_list|,
name|home_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|home_dir
argument_list|)
expr_stmt|;
name|sqliterc
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|zBuf
expr_stmt|;
block|}
name|in
operator|=
name|fopen
argument_list|(
name|sqliterc
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
condition|)
block|{
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|printf
argument_list|(
literal|"-- Loading resources from %s\n"
argument_list|,
name|sqliterc
argument_list|)
expr_stmt|;
block|}
name|process_input
argument_list|(
name|p
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zBuf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_comment
comment|/* ** Show available command line options */
end_comment
begin_decl_stmt
DECL|variable|zOptions
specifier|static
specifier|const
name|char
name|zOptions
index|[]
init|=
literal|"   -init filename       read/process named file\n"
literal|"   -echo                print commands before execution\n"
literal|"   -[no]header          turn headers on or off\n"
literal|"   -bail                stop after hitting an error\n"
literal|"   -interactive         force interactive I/O\n"
literal|"   -batch               force batch I/O\n"
literal|"   -column              set output mode to 'column'\n"
literal|"   -csv                 set output mode to 'csv'\n"
literal|"   -html                set output mode to HTML\n"
literal|"   -line                set output mode to 'line'\n"
literal|"   -list                set output mode to 'list'\n"
literal|"   -separator 'x'       set output field separator (|)\n"
literal|"   -nullvalue 'text'    set text string for NULL values\n"
literal|"   -version             show SQLite version\n"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|usage
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|showDetail
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [OPTIONS] FILENAME [SQL]\n"
literal|"FILENAME is the name of an SQLite database. A new database is created\n"
literal|"if the file does not previously exist.\n"
argument_list|,
name|Argv0
argument_list|)
expr_stmt|;
if|if
condition|(
name|showDetail
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OPTIONS include:\n%s"
argument_list|,
name|zOptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use the -help option for additional information\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ** Initialize the state information in data */
end_comment
begin_function
DECL|function|main_init
specifier|static
name|void
name|main_init
parameter_list|(
name|struct
name|callback_data
modifier|*
name|data
parameter_list|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|mode
operator|=
name|MODE_List
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|->
name|separator
argument_list|,
literal|"|"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|->
name|showHeader
operator|=
literal|0
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|mainPrompt
argument_list|)
argument_list|,
name|mainPrompt
argument_list|,
literal|"sqlite> "
argument_list|)
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|continuePrompt
argument_list|)
argument_list|,
name|continuePrompt
argument_list|,
literal|"   ...> "
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|zErrMsg
init|=
literal|0
decl_stmt|;
name|struct
name|callback_data
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|zInitFile
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|zFirstCmd
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|Argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|main_init
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|stdin_is_interactive
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure we have a valid signal handler early, before anything   ** else is done.   */
ifdef|#
directive|ifdef
name|SIGINT
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do an initial pass through the command-line argument to locate   ** the name of the database file, the name of the initialization file,   ** and the first command to execute.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
name|z
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|z
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|zInitFile
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|argc
condition|)
block|{
ifdef|#
directive|ifdef
name|OS_OS2
name|data
operator|.
name|zDbFilename
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|convertCpPathToUtf8
argument_list|(
name|argv
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|data
operator|.
name|zDbFilename
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|SQLITE_OMIT_MEMORYDB
name|data
operator|.
name|zDbFilename
operator|=
literal|":memory:"
expr_stmt|;
else|#
directive|else
name|data
operator|.
name|zDbFilename
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
name|argc
condition|)
block|{
name|zFirstCmd
operator|=
name|argv
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|data
operator|.
name|out
operator|=
name|stdout
expr_stmt|;
ifdef|#
directive|ifdef
name|SQLITE_OMIT_MEMORYDB
if|if
condition|(
name|data
operator|.
name|zDbFilename
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no database filename specified\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Go ahead and open the database file if it already exists.  If the   ** file does not exist, delay opening it.  This prevents empty database   ** files from being created if a user mistypes the database name argument   ** to the sqlite command-line tool.   */
if|if
condition|(
name|access
argument_list|(
name|data
operator|.
name|zDbFilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|open_db
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* Process the initialization file if there is one.  If no -init option   ** is given on the command line, look for a file named ~/.sqliterc and   ** try to process it.   */
name|process_sqliterc
argument_list|(
operator|&
name|data
argument_list|,
name|zInitFile
argument_list|)
expr_stmt|;
comment|/* Make a second pass through the command-line argument and set   ** options.  This second pass is delayed until after the initialization   ** file is processed so that the command-line arguments will override   ** settings in the initialization file.   */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|z
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-init"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-html"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Html
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-list"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_List
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-line"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-column"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Column
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-csv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|mode
operator|=
name|MODE_Csv
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|.
name|separator
argument_list|,
literal|","
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-separator"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|separator
argument_list|)
argument_list|,
name|data
operator|.
name|separator
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|.
name|separator
argument_list|)
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-nullvalue"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|sqlite3_snprintf
argument_list|(
sizeof|sizeof
argument_list|(
name|data
operator|.
name|nullvalue
argument_list|)
argument_list|,
name|data
operator|.
name|nullvalue
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|.
name|nullvalue
argument_list|)
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-header"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-noheader"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|showHeader
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|echoOn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-bail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bail_on_error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-interactive"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stdin_is_interactive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option: %s\n"
argument_list|,
name|Argv0
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use -help for a list of options.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|zFirstCmd
condition|)
block|{
comment|/* Run just the command that follows the database name     */
if|if
condition|(
name|zFirstCmd
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|do_meta_command
argument_list|(
name|zFirstCmd
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|rc
decl_stmt|;
name|open_db
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_exec
argument_list|(
name|data
operator|.
name|db
argument_list|,
name|zFirstCmd
argument_list|,
name|callback
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|zErrMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
operator|&&
name|zErrMsg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SQL error: %s\n"
argument_list|,
name|zErrMsg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Run commands received from standard input     */
if|if
condition|(
name|stdin_is_interactive
condition|)
block|{
name|char
modifier|*
name|zHome
decl_stmt|;
name|char
modifier|*
name|zHistory
init|=
literal|0
decl_stmt|;
name|int
name|nHistory
decl_stmt|;
name|printf
argument_list|(
literal|"SQLite version %s\n"
literal|"Enter \".help\" for instructions\n"
argument_list|,
name|sqlite3_libversion
argument_list|()
argument_list|)
expr_stmt|;
name|zHome
operator|=
name|find_home_dir
argument_list|()
expr_stmt|;
if|if
condition|(
name|zHome
operator|&&
operator|(
name|zHistory
operator|=
name|malloc
argument_list|(
name|nHistory
operator|=
name|strlen
argument_list|(
name|zHome
argument_list|)
operator|+
literal|20
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sqlite3_snprintf
argument_list|(
name|nHistory
argument_list|,
name|zHistory
argument_list|,
literal|"%s/.sqlite_history"
argument_list|,
name|zHome
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_READLINE
argument_list|)
operator|&&
name|HAVE_READLINE
operator|==
literal|1
if|if
condition|(
name|zHistory
condition|)
name|read_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zHistory
condition|)
block|{
name|stifle_history
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|write_history
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zHistory
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zHome
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|process_input
argument_list|(
operator|&
name|data
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
name|set_table_name
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
if|if
condition|(
name|sqlite3_close
argument_list|(
name|db
argument_list|)
operator|!=
name|SQLITE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error closing database: %s\n"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function
end_unit
