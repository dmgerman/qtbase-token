begin_unit
begin_comment
comment|/************************* sha384-512.c ************************/
end_comment
begin_comment
comment|/***************** See RFC 6234 for details. *******************/
end_comment
begin_comment
comment|/* Copyright (c) 2011 IETF Trust and the persons identified as */
end_comment
begin_comment
comment|/* authors of the code.  All rights reserved.                  */
end_comment
begin_comment
comment|/* See sha.h for terms of use and redistribution.              */
end_comment
begin_comment
comment|/*  * Description:  *   This file implements the Secure Hash Algorithms SHA-384 and  *   SHA-512 as defined in the U.S. National Institute of Standards  *   and Technology Federal Information Processing Standards  *   Publication (FIPS PUB) 180-3 published in October 2008  *   and formerly defined in its predecessors, FIPS PUB 180-1  *   and FIP PUB 180-2.  *  *   A combined document showing all algorithms is available at  *       http://csrc.nist.gov/publications/fips/  *              fips180-3/fips180-3_final.pdf  *  *   The SHA-384 and SHA-512 algorithms produce 384-bit and 512-bit  *   message digests for a given data stream.  It should take about  *   2**n steps to find a message with the same digest as a given  *   message and 2**(n/2) to find any two messages with the same  *   digest, when n is the digest size in bits.  Therefore, this  *   algorithm can serve as a means of providing a  *   "fingerprint" for a message.  *  * Portability Issues:  *   SHA-384 and SHA-512 are defined in terms of 64-bit "words",  *   but if USE_32BIT_ONLY is #defined, this code is implemented in  *   terms of 32-bit "words".  This code uses<stdint.h> (included  *   via "sha.h") to define the 64-, 32- and 8-bit unsigned integer  *   types.  If your C compiler does not support 64-bit unsigned  *   integers and you do not #define USE_32BIT_ONLY, this code is  *   not appropriate.  *  * Caveats:  *   SHA-384 and SHA-512 are designed to work with messages less  *   than 2^128 bits long.  This implementation uses SHA384/512Input()  *   to hash the bits that are a multiple of the size of an 8-bit  *   octet, and then optionally uses SHA384/256FinalBits()  *   to hash the final few bits of the input.  *  */
end_comment
begin_include
include|#
directive|include
file|"sha.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
end_ifdef
begin_comment
comment|/*  * Define 64-bit arithmetic in terms of 32-bit arithmetic.  * Each 64-bit number is represented in a 2-word array.  * All macros are defined such that the result is the last parameter.  */
end_comment
begin_comment
comment|/*  * Define shift, rotate left, and rotate right functions  */
end_comment
begin_define
DECL|macro|SHA512_SHR
define|#
directive|define
name|SHA512_SHR
parameter_list|(
name|bits
parameter_list|,
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                          \
comment|/* (((uint64_t)((word)))>> (bits)) */
value|\     (ret)[0] = (((bits)< 32)&& ((bits)>= 0)) ?              \       ((word)[0]>> (bits)) : 0,                               \     (ret)[1] = ((bits)> 32) ? ((word)[0]>> ((bits) - 32)) :  \       ((bits) == 32) ? (word)[0] :                             \       ((bits)>= 0) ?                                          \         (((word)[0]<< (32 - (bits))) |                        \         ((word)[1]>> (bits))) : 0 )
end_define
begin_define
DECL|macro|SHA512_SHL
define|#
directive|define
name|SHA512_SHL
parameter_list|(
name|bits
parameter_list|,
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                          \
comment|/* (((uint64_t)(word))<< (bits)) */
value|\     (ret)[0] = ((bits)> 32) ? ((word)[1]<< ((bits) - 32)) :  \          ((bits) == 32) ? (word)[1] :                          \          ((bits)>= 0) ?                                       \            (((word)[0]<< (bits)) |                            \            ((word)[1]>> (32 - (bits)))) :                     \          0,                                                    \     (ret)[1] = (((bits)< 32)&& ((bits)>= 0)) ?              \         ((word)[1]<< (bits)) : 0 )
end_define
begin_comment
comment|/*  * Define 64-bit OR  */
end_comment
begin_define
DECL|macro|SHA512_OR
define|#
directive|define
name|SHA512_OR
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|,
name|ret
parameter_list|)
value|(                         \     (ret)[0] = (word1)[0] | (word2)[0],                        \     (ret)[1] = (word1)[1] | (word2)[1] )
end_define
begin_comment
comment|/*  * Define 64-bit XOR  */
end_comment
begin_define
DECL|macro|SHA512_XOR
define|#
directive|define
name|SHA512_XOR
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|,
name|ret
parameter_list|)
value|(                        \     (ret)[0] = (word1)[0] ^ (word2)[0],                        \     (ret)[1] = (word1)[1] ^ (word2)[1] )
end_define
begin_comment
comment|/*  * Define 64-bit AND  */
end_comment
begin_define
DECL|macro|SHA512_AND
define|#
directive|define
name|SHA512_AND
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|,
name|ret
parameter_list|)
value|(                        \     (ret)[0] = (word1)[0]& (word2)[0],                        \     (ret)[1] = (word1)[1]& (word2)[1] )
end_define
begin_comment
comment|/*  * Define 64-bit TILDA  */
end_comment
begin_define
DECL|macro|SHA512_TILDA
define|#
directive|define
name|SHA512_TILDA
parameter_list|(
name|word
parameter_list|,
name|ret
parameter_list|)
define|\
value|( (ret)[0] = ~(word)[0], (ret)[1] = ~(word)[1] )
end_define
begin_comment
comment|/*  * Define 64-bit ADD  */
end_comment
begin_define
DECL|macro|SHA512_ADD
define|#
directive|define
name|SHA512_ADD
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|,
name|ret
parameter_list|)
value|(                        \     (ret)[1] = (word1)[1], (ret)[1] += (word2)[1],             \     (ret)[0] = (word1)[0] + (word2)[0] + ((ret)[1]< (word1)[1]) )
end_define
begin_comment
comment|/*  * Add the 4word value in word2 to word1.  */
end_comment
begin_decl_stmt
DECL|variable|ADDTO4_temp
DECL|variable|ADDTO4_temp2
specifier|static
name|uint32_t
name|ADDTO4_temp
decl_stmt|,
name|ADDTO4_temp2
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_ADDTO4
define|#
directive|define
name|SHA512_ADDTO4
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|)
value|(                          \     ADDTO4_temp = (word1)[3],                                  \     (word1)[3] += (word2)[3],                                  \     ADDTO4_temp2 = (word1)[2],                                 \     (word1)[2] += (word2)[2] + ((word1)[3]< ADDTO4_temp),     \     ADDTO4_temp = (word1)[1],                                  \     (word1)[1] += (word2)[1] + ((word1)[2]< ADDTO4_temp2),    \     (word1)[0] += (word2)[0] + ((word1)[1]< ADDTO4_temp) )
end_define
begin_comment
comment|/*  * Add the 2word value in word2 to word1.  */
end_comment
begin_decl_stmt
DECL|variable|ADDTO2_temp
specifier|static
name|uint32_t
name|ADDTO2_temp
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_ADDTO2
define|#
directive|define
name|SHA512_ADDTO2
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|)
value|(                          \     ADDTO2_temp = (word1)[1],                                  \     (word1)[1] += (word2)[1],                                  \     (word1)[0] += (word2)[0] + ((word1)[1]< ADDTO2_temp) )
end_define
begin_comment
comment|/*  * SHA rotate   ((word>> bits) | (word<< (64-bits)))  */
end_comment
begin_decl_stmt
DECL|variable|ROTR_temp1
DECL|variable|ROTR_temp2
specifier|static
name|uint32_t
name|ROTR_temp1
index|[
literal|2
index|]
decl_stmt|,
name|ROTR_temp2
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_ROTR
define|#
directive|define
name|SHA512_ROTR
parameter_list|(
name|bits
parameter_list|,
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                         \     SHA512_SHR((bits), (word), ROTR_temp1),                    \     SHA512_SHL(64-(bits), (word), ROTR_temp2),                 \     SHA512_OR(ROTR_temp1, ROTR_temp2, (ret)) )
end_define
begin_comment
comment|/*  * Define the SHA SIGMA and sigma macros  *  *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)  */
end_comment
begin_decl_stmt
DECL|variable|SIGMA0_temp1
DECL|variable|SIGMA0_temp2
specifier|static
name|uint32_t
name|SIGMA0_temp1
index|[
literal|2
index|]
decl_stmt|,
name|SIGMA0_temp2
index|[
literal|2
index|]
decl_stmt|,
DECL|variable|SIGMA0_temp3
DECL|variable|SIGMA0_temp4
name|SIGMA0_temp3
index|[
literal|2
index|]
decl_stmt|,
name|SIGMA0_temp4
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_SIGMA0
define|#
directive|define
name|SHA512_SIGMA0
parameter_list|(
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                             \     SHA512_ROTR(28, (word), SIGMA0_temp1),                     \     SHA512_ROTR(34, (word), SIGMA0_temp2),                     \     SHA512_ROTR(39, (word), SIGMA0_temp3),                     \     SHA512_XOR(SIGMA0_temp2, SIGMA0_temp3, SIGMA0_temp4),      \     SHA512_XOR(SIGMA0_temp1, SIGMA0_temp4, (ret)) )
end_define
begin_comment
comment|/*  * SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word)  */
end_comment
begin_decl_stmt
DECL|variable|SIGMA1_temp1
DECL|variable|SIGMA1_temp2
specifier|static
name|uint32_t
name|SIGMA1_temp1
index|[
literal|2
index|]
decl_stmt|,
name|SIGMA1_temp2
index|[
literal|2
index|]
decl_stmt|,
DECL|variable|SIGMA1_temp3
DECL|variable|SIGMA1_temp4
name|SIGMA1_temp3
index|[
literal|2
index|]
decl_stmt|,
name|SIGMA1_temp4
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_SIGMA1
define|#
directive|define
name|SHA512_SIGMA1
parameter_list|(
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                             \     SHA512_ROTR(14, (word), SIGMA1_temp1),                     \     SHA512_ROTR(18, (word), SIGMA1_temp2),                     \     SHA512_ROTR(41, (word), SIGMA1_temp3),                     \     SHA512_XOR(SIGMA1_temp2, SIGMA1_temp3, SIGMA1_temp4),      \     SHA512_XOR(SIGMA1_temp1, SIGMA1_temp4, (ret)) )
end_define
begin_comment
comment|/*  * (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))  */
end_comment
begin_decl_stmt
DECL|variable|sigma0_temp1
DECL|variable|sigma0_temp2
specifier|static
name|uint32_t
name|sigma0_temp1
index|[
literal|2
index|]
decl_stmt|,
name|sigma0_temp2
index|[
literal|2
index|]
decl_stmt|,
DECL|variable|sigma0_temp3
DECL|variable|sigma0_temp4
name|sigma0_temp3
index|[
literal|2
index|]
decl_stmt|,
name|sigma0_temp4
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_sigma0
define|#
directive|define
name|SHA512_sigma0
parameter_list|(
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                             \     SHA512_ROTR( 1, (word), sigma0_temp1),                     \     SHA512_ROTR( 8, (word), sigma0_temp2),                     \     SHA512_SHR( 7, (word), sigma0_temp3),                      \     SHA512_XOR(sigma0_temp2, sigma0_temp3, sigma0_temp4),      \     SHA512_XOR(sigma0_temp1, sigma0_temp4, (ret)) )
end_define
begin_comment
comment|/*  * (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))  */
end_comment
begin_decl_stmt
DECL|variable|sigma1_temp1
DECL|variable|sigma1_temp2
specifier|static
name|uint32_t
name|sigma1_temp1
index|[
literal|2
index|]
decl_stmt|,
name|sigma1_temp2
index|[
literal|2
index|]
decl_stmt|,
DECL|variable|sigma1_temp3
DECL|variable|sigma1_temp4
name|sigma1_temp3
index|[
literal|2
index|]
decl_stmt|,
name|sigma1_temp4
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA512_sigma1
define|#
directive|define
name|SHA512_sigma1
parameter_list|(
name|word
parameter_list|,
name|ret
parameter_list|)
value|(                             \     SHA512_ROTR(19, (word), sigma1_temp1),                     \     SHA512_ROTR(61, (word), sigma1_temp2),                     \     SHA512_SHR( 6, (word), sigma1_temp3),                      \     SHA512_XOR(sigma1_temp2, sigma1_temp3, sigma1_temp4),      \     SHA512_XOR(sigma1_temp1, sigma1_temp4, (ret)) )
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|USE_MODIFIED_MACROS
end_ifndef
begin_comment
comment|/*  * These definitions are the ones used in FIPS 180-3, section 4.1.3  *  Ch(x,y,z)   ((x& y) ^ (~x& z))  */
end_comment
begin_decl_stmt
DECL|variable|Ch_temp1
DECL|variable|Ch_temp2
DECL|variable|Ch_temp3
specifier|static
name|uint32_t
name|Ch_temp1
index|[
literal|2
index|]
decl_stmt|,
name|Ch_temp2
index|[
literal|2
index|]
decl_stmt|,
name|Ch_temp3
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA_Ch
define|#
directive|define
name|SHA_Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|ret
parameter_list|)
value|(                                 \     SHA512_AND(x, y, Ch_temp1),                                \     SHA512_TILDA(x, Ch_temp2),                                 \     SHA512_AND(Ch_temp2, z, Ch_temp3),                         \     SHA512_XOR(Ch_temp1, Ch_temp3, (ret)) )
end_define
begin_comment
comment|/*  *  Maj(x,y,z)  (((x)&(y)) ^ ((x)&(z)) ^ ((y)&(z)))  */
end_comment
begin_decl_stmt
DECL|variable|Maj_temp1
DECL|variable|Maj_temp2
specifier|static
name|uint32_t
name|Maj_temp1
index|[
literal|2
index|]
decl_stmt|,
name|Maj_temp2
index|[
literal|2
index|]
decl_stmt|,
DECL|variable|Maj_temp3
DECL|variable|Maj_temp4
name|Maj_temp3
index|[
literal|2
index|]
decl_stmt|,
name|Maj_temp4
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA_Maj
define|#
directive|define
name|SHA_Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|ret
parameter_list|)
value|(                                \     SHA512_AND(x, y, Maj_temp1),                               \     SHA512_AND(x, z, Maj_temp2),                               \     SHA512_AND(y, z, Maj_temp3),                               \     SHA512_XOR(Maj_temp2, Maj_temp3, Maj_temp4),               \     SHA512_XOR(Maj_temp1, Maj_temp4, (ret)) )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !USE_MODIFIED_MACROS */
end_comment
begin_comment
comment|/*  * These definitions are potentially faster equivalents for the ones  * used in FIPS 180-3, section 4.1.3.  *   ((x& y) ^ (~x& z)) becomes  *   ((x& (y ^ z)) ^ z)  */
end_comment
begin_define
DECL|macro|SHA_Ch
define|#
directive|define
name|SHA_Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|ret
parameter_list|)
value|(                                 \    (ret)[0] = (((x)[0]& ((y)[0] ^ (z)[0])) ^ (z)[0]),         \    (ret)[1] = (((x)[1]& ((y)[1] ^ (z)[1])) ^ (z)[1]) )
end_define
begin_comment
comment|/*  *   ((x& y) ^ (x& z) ^ (y& z)) becomes  *   ((x& (y | z)) | (y& z))  */
end_comment
begin_define
DECL|macro|SHA_Maj
define|#
directive|define
name|SHA_Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|ret
parameter_list|)
value|(                                 \    ret[0] = (((x)[0]& ((y)[0] | (z)[0])) | ((y)[0]& (z)[0])), \    ret[1] = (((x)[1]& ((y)[1] | (z)[1])) | ((y)[1]& (z)[1])) )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_MODIFIED_MACROS */
end_comment
begin_comment
comment|/*  * Add "length" to the length.  * Set Corrupted when overflow has occurred.  */
end_comment
begin_decl_stmt
DECL|variable|addTemp
specifier|static
name|uint32_t
name|addTemp
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SHA384_512AddLength
define|#
directive|define
name|SHA384_512AddLength
parameter_list|(
name|context
parameter_list|,
name|length
parameter_list|)
value|(                        \     addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \     (context)->Corrupted = (((context)->Length[3]< (length))&&      \        ((context)->Length[2] == 0)&& ((context)->Length[1] == 0)&&  \        ((context)->Length[0] == 0)) ? shaInputTooLong :               \                                       (context)->Corrupted )
end_define
begin_comment
comment|/* Local Function Prototypes */
end_comment
begin_function_decl
specifier|static
name|int
name|SHA384_512Reset
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint32_t
name|H0
index|[
name|SHA512HashSize
operator|/
literal|4
index|]
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512ProcessMessageBlock
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512Finalize
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512PadMessage
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|SHA384_512ResultN
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Message_Digest
index|[ ]
parameter_list|,
name|int
name|HashSize
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */
end_comment
begin_decl_stmt
DECL|variable|SHA384_H0
specifier|static
name|uint32_t
name|SHA384_H0
index|[
name|SHA512HashSize
operator|/
literal|4
index|]
init|=
block|{
literal|0xCBBB9D5D
block|,
literal|0xC1059ED8
block|,
literal|0x629A292A
block|,
literal|0x367CD507
block|,
literal|0x9159015A
block|,
literal|0x3070DD17
block|,
literal|0x152FECD8
block|,
literal|0xF70E5939
block|,
literal|0x67332667
block|,
literal|0xFFC00B31
block|,
literal|0x8EB44A87
block|,
literal|0x68581511
block|,
literal|0xDB0C2E0D
block|,
literal|0x64F98FA7
block|,
literal|0x47B5481D
block|,
literal|0xBEFA4FA4
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|SHA512_H0
specifier|static
name|uint32_t
name|SHA512_H0
index|[
name|SHA512HashSize
operator|/
literal|4
index|]
init|=
block|{
literal|0x6A09E667
block|,
literal|0xF3BCC908
block|,
literal|0xBB67AE85
block|,
literal|0x84CAA73B
block|,
literal|0x3C6EF372
block|,
literal|0xFE94F82B
block|,
literal|0xA54FF53A
block|,
literal|0x5F1D36F1
block|,
literal|0x510E527F
block|,
literal|0xADE682D1
block|,
literal|0x9B05688C
block|,
literal|0x2B3E6C1F
block|,
literal|0x1F83D9AB
block|,
literal|0xFB41BD6B
block|,
literal|0x5BE0CD19
block|,
literal|0x137E2179
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !USE_32BIT_ONLY */
end_comment
begin_include
include|#
directive|include
file|"sha-private.h"
end_include
begin_comment
comment|/* Define the SHA shift, rotate left and rotate right macros */
end_comment
begin_define
DECL|macro|SHA512_SHR
define|#
directive|define
name|SHA512_SHR
parameter_list|(
name|bits
parameter_list|,
name|word
parameter_list|)
value|(((uint64_t)(word))>> (bits))
end_define
begin_define
DECL|macro|SHA512_ROTR
define|#
directive|define
name|SHA512_ROTR
parameter_list|(
name|bits
parameter_list|,
name|word
parameter_list|)
value|((((uint64_t)(word))>> (bits)) | \                                 (((uint64_t)(word))<< (64-(bits))))
end_define
begin_comment
comment|/*  * Define the SHA SIGMA and sigma macros  *  *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)  */
end_comment
begin_define
DECL|macro|SHA512_SIGMA0
define|#
directive|define
name|SHA512_SIGMA0
parameter_list|(
name|word
parameter_list|)
define|\
value|(SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word))
end_define
begin_define
DECL|macro|SHA512_SIGMA1
define|#
directive|define
name|SHA512_SIGMA1
parameter_list|(
name|word
parameter_list|)
define|\
value|(SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word))
end_define
begin_define
DECL|macro|SHA512_sigma0
define|#
directive|define
name|SHA512_sigma0
parameter_list|(
name|word
parameter_list|)
define|\
value|(SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))
end_define
begin_define
DECL|macro|SHA512_sigma1
define|#
directive|define
name|SHA512_sigma1
parameter_list|(
name|word
parameter_list|)
define|\
value|(SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))
end_define
begin_comment
comment|/*  * Add "length" to the length.  * Set Corrupted when overflow has occurred.  */
end_comment
begin_comment
comment|/* addTemp commented out by Nokia, static variables are not thread-safe */
end_comment
begin_comment
comment|/* static uint64_t addTemp; */
end_comment
begin_comment
comment|/* 'M' appended to Macro name by Nokia */
end_comment
begin_define
DECL|macro|SHA384_512AddLengthM
define|#
directive|define
name|SHA384_512AddLengthM
parameter_list|(
name|context
parameter_list|,
name|length
parameter_list|)
define|\
value|(addTemp = context->Length_Low, context->Corrupted =        \     ((context->Length_Low += length)< addTemp)&&             \     (++context->Length_High == 0) ? shaInputTooLong :          \                                     (context)->Corrupted)
end_define
begin_comment
comment|/* Local Function Prototypes */
end_comment
begin_function_decl
specifier|static
name|int
name|SHA384_512Reset
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint64_t
name|H0
index|[
name|SHA512HashSize
operator|/
literal|8
index|]
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512ProcessMessageBlock
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512Finalize
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SHA384_512PadMessage
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|SHA384_512ResultN
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Message_Digest
index|[ ]
parameter_list|,
name|int
name|HashSize
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */
end_comment
begin_decl_stmt
DECL|variable|SHA384_H0
specifier|static
name|uint64_t
name|SHA384_H0
index|[ ]
init|=
block|{
literal|0xCBBB9D5DC1059ED8ll
block|,
literal|0x629A292A367CD507ll
block|,
literal|0x9159015A3070DD17ll
block|,
literal|0x152FECD8F70E5939ll
block|,
literal|0x67332667FFC00B31ll
block|,
literal|0x8EB44A8768581511ll
block|,
literal|0xDB0C2E0D64F98FA7ll
block|,
literal|0x47B5481DBEFA4FA4ll
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|SHA512_H0
specifier|static
name|uint64_t
name|SHA512_H0
index|[ ]
init|=
block|{
literal|0x6A09E667F3BCC908ll
block|,
literal|0xBB67AE8584CAA73Bll
block|,
literal|0x3C6EF372FE94F82Bll
block|,
literal|0xA54FF53A5F1D36F1ll
block|,
literal|0x510E527FADE682D1ll
block|,
literal|0x9B05688C2B3E6C1Fll
block|,
literal|0x1F83D9ABFB41BD6Bll
block|,
literal|0x5BE0CD19137E2179ll
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_32BIT_ONLY */
end_comment
begin_comment
comment|/*  * SHA384Reset  *  * Description:  *   This function will initialize the SHA384Context in preparation  *   for computing a new SHA384 message digest.  *  * Parameters:  *   context: [in/out]  *     The context to reset.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384Reset
name|int
name|SHA384Reset
parameter_list|(
name|SHA384Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|SHA384_512Reset
argument_list|(
name|context
argument_list|,
name|SHA384_H0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA384Input  *  * Description:  *   This function accepts an array of octets as the next portion  *   of the message.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *   message_array[ ]: [in]  *     An array of octets representing the next portion of  *     the message.  *   length: [in]  *     The length of the message in message_array.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384Input
name|int
name|SHA384Input
parameter_list|(
name|SHA384Context
modifier|*
name|context
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|message_array
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
return|return
name|SHA512Input
argument_list|(
name|context
argument_list|,
name|message_array
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA384FinalBits  *  * Description:  *   This function will add in any final bits of the message.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *   message_bits: [in]  *     The final bits of the message, in the upper portion of the  *     byte.  (Use 0b###00000 instead of 0b00000### to input the  *     three bits ###.)  *   length: [in]  *     The number of bits in message_bits, between 1 and 7.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384FinalBits
name|int
name|SHA384FinalBits
parameter_list|(
name|SHA384Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|message_bits
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
return|return
name|SHA512FinalBits
argument_list|(
name|context
argument_list|,
name|message_bits
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA384Result  *  * Description:  *   This function will return the 384-bit message digest  *   into the Message_Digest array provided by the caller.  *   NOTE:  *    The first octet of hash is stored in the element with index 0,  *    the last octet of hash in the element with index 47.  *  * Parameters:  *   context: [in/out]  *     The context to use to calculate the SHA hash.  *   Message_Digest[ ]: [out]  *     Where the digest is returned.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384Result
name|int
name|SHA384Result
parameter_list|(
name|SHA384Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Message_Digest
index|[
name|SHA384HashSize
index|]
parameter_list|)
block|{
return|return
name|SHA384_512ResultN
argument_list|(
name|context
argument_list|,
name|Message_Digest
argument_list|,
name|SHA384HashSize
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA512Reset  *  * Description:  *   This function will initialize the SHA512Context in preparation  *   for computing a new SHA512 message digest.  *  * Parameters:  *   context: [in/out]  *     The context to reset.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA512Reset
name|int
name|SHA512Reset
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|SHA384_512Reset
argument_list|(
name|context
argument_list|,
name|SHA512_H0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA512Input  *  * Description:  *   This function accepts an array of octets as the next portion  *   of the message.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *   message_array[ ]: [in]  *     An array of octets representing the next portion of  *     the message.  *   length: [in]  *     The length of the message in message_array.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA512Input
name|int
name|SHA512Input
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|message_array
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|shaNull
return|;
if|if
condition|(
operator|!
name|length
condition|)
return|return
name|shaSuccess
return|;
if|if
condition|(
operator|!
name|message_array
condition|)
return|return
name|shaNull
return|;
if|if
condition|(
name|context
operator|->
name|Computed
condition|)
return|return
name|context
operator|->
name|Corrupted
operator|=
name|shaStateError
return|;
if|if
condition|(
name|context
operator|->
name|Corrupted
condition|)
return|return
name|context
operator|->
name|Corrupted
return|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|context
operator|->
name|Message_Block
index|[
name|context
operator|->
name|Message_Block_Index
operator|++
index|]
operator|=
operator|*
name|message_array
expr_stmt|;
if|if
condition|(
operator|(
name|SHA384_512AddLength
argument_list|(
name|context
argument_list|,
literal|8
argument_list|)
operator|==
name|shaSuccess
operator|)
operator|&&
operator|(
name|context
operator|->
name|Message_Block_Index
operator|==
name|SHA512_Message_Block_Size
operator|)
condition|)
name|SHA384_512ProcessMessageBlock
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|message_array
operator|++
expr_stmt|;
block|}
return|return
name|context
operator|->
name|Corrupted
return|;
block|}
end_function
begin_comment
comment|/*  * SHA512FinalBits  *  * Description:  *   This function will add in any final bits of the message.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *   message_bits: [in]  *     The final bits of the message, in the upper portion of the  *     byte.  (Use 0b###00000 instead of 0b00000### to input the  *     three bits ###.)  *   length: [in]  *     The number of bits in message_bits, between 1 and 7.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA512FinalBits
name|int
name|SHA512FinalBits
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|message_bits
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
specifier|static
name|uint8_t
name|masks
index|[
literal|8
index|]
init|=
block|{
comment|/* 0 0b00000000 */
literal|0x00
block|,
comment|/* 1 0b10000000 */
literal|0x80
block|,
comment|/* 2 0b11000000 */
literal|0xC0
block|,
comment|/* 3 0b11100000 */
literal|0xE0
block|,
comment|/* 4 0b11110000 */
literal|0xF0
block|,
comment|/* 5 0b11111000 */
literal|0xF8
block|,
comment|/* 6 0b11111100 */
literal|0xFC
block|,
comment|/* 7 0b11111110 */
literal|0xFE
block|}
decl_stmt|;
specifier|static
name|uint8_t
name|markbit
index|[
literal|8
index|]
init|=
block|{
comment|/* 0 0b10000000 */
literal|0x80
block|,
comment|/* 1 0b01000000 */
literal|0x40
block|,
comment|/* 2 0b00100000 */
literal|0x20
block|,
comment|/* 3 0b00010000 */
literal|0x10
block|,
comment|/* 4 0b00001000 */
literal|0x08
block|,
comment|/* 5 0b00000100 */
literal|0x04
block|,
comment|/* 6 0b00000010 */
literal|0x02
block|,
comment|/* 7 0b00000001 */
literal|0x01
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|shaNull
return|;
if|if
condition|(
operator|!
name|length
condition|)
return|return
name|shaSuccess
return|;
if|if
condition|(
name|context
operator|->
name|Corrupted
condition|)
return|return
name|context
operator|->
name|Corrupted
return|;
if|if
condition|(
name|context
operator|->
name|Computed
condition|)
return|return
name|context
operator|->
name|Corrupted
operator|=
name|shaStateError
return|;
if|if
condition|(
name|length
operator|>=
literal|8
condition|)
return|return
name|context
operator|->
name|Corrupted
operator|=
name|shaBadParam
return|;
name|SHA384_512AddLength
argument_list|(
name|context
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|SHA384_512Finalize
argument_list|(
name|context
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|message_bits
operator|&
name|masks
index|[
name|length
index|]
operator|)
operator||
name|markbit
index|[
name|length
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|context
operator|->
name|Corrupted
return|;
block|}
end_function
begin_comment
comment|/*  * SHA512Result  *  * Description:  *   This function will return the 512-bit message digest  *   into the Message_Digest array provided by the caller.  *   NOTE:  *    The first octet of hash is stored in the element with index 0,  *    the last octet of hash in the element with index 63.  *  * Parameters:  *   context: [in/out]  *     The context to use to calculate the SHA hash.  *   Message_Digest[ ]: [out]  *     Where the digest is returned.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA512Result
name|int
name|SHA512Result
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Message_Digest
index|[
name|SHA512HashSize
index|]
parameter_list|)
block|{
return|return
name|SHA384_512ResultN
argument_list|(
name|context
argument_list|,
name|Message_Digest
argument_list|,
name|SHA512HashSize
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * SHA384_512Reset  *  * Description:  *   This helper function will initialize the SHA512Context in  *   preparation for computing a new SHA384 or SHA512 message  *   digest.  *  * Parameters:  *   context: [in/out]  *     The context to reset.  *   H0[ ]: [in]  *     The initial hash value array to use.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
end_ifdef
begin_decl_stmt
DECL|function|SHA384_512Reset
specifier|static
name|int
name|SHA384_512Reset
argument_list|(
name|SHA512Context
operator|*
name|context
argument_list|,
name|uint32_t
name|H0
index|[
name|SHA512HashSize
operator|/
literal|4
index|]
argument_list|)
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
decl|static
name|int
name|SHA384_512Reset
argument_list|(
name|SHA512Context
operator|*
name|context
argument_list|,
name|uint64_t
name|H0
index|[
name|SHA512HashSize
operator|/
literal|8
index|]
argument_list|)
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|shaNull
return|;
name|context
operator|->
name|Message_Block_Index
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
name|context
operator|->
name|Length
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Length
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Length
index|[
literal|2
index|]
operator|=
name|context
operator|->
name|Length
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA512HashSize
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|Intermediate_Hash
index|[
name|i
index|]
operator|=
name|H0
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
name|context
operator|->
name|Length_High
operator|=
name|context
operator|->
name|Length_Low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA512HashSize
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|context
operator|->
name|Intermediate_Hash
index|[
name|i
index|]
operator|=
name|H0
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
name|context
operator|->
name|Computed
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|Corrupted
operator|=
name|shaSuccess
expr_stmt|;
return|return
name|shaSuccess
return|;
block|}
end_decl_stmt
begin_comment
comment|/*  * SHA384_512ProcessMessageBlock  *  * Description:  *   This helper function will process the next 1024 bits of the  *   message stored in the Message_Block array.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *  * Returns:  *   Nothing.  *  * Comments:  *   Many of the variable names in this code, especially the  *   single character names, were used because those were the  *   names used in the Secure Hash Standard.  *  *  */
end_comment
begin_function
DECL|function|SHA384_512ProcessMessageBlock
specifier|static
name|void
name|SHA384_512ProcessMessageBlock
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
comment|/* Constants defined in FIPS 180-3, section 4.2.3 */
specifier|static
specifier|const
name|uint32_t
name|K
index|[
literal|80
operator|*
literal|2
index|]
init|=
block|{
literal|0x428A2F98
block|,
literal|0xD728AE22
block|,
literal|0x71374491
block|,
literal|0x23EF65CD
block|,
literal|0xB5C0FBCF
block|,
literal|0xEC4D3B2F
block|,
literal|0xE9B5DBA5
block|,
literal|0x8189DBBC
block|,
literal|0x3956C25B
block|,
literal|0xF348B538
block|,
literal|0x59F111F1
block|,
literal|0xB605D019
block|,
literal|0x923F82A4
block|,
literal|0xAF194F9B
block|,
literal|0xAB1C5ED5
block|,
literal|0xDA6D8118
block|,
literal|0xD807AA98
block|,
literal|0xA3030242
block|,
literal|0x12835B01
block|,
literal|0x45706FBE
block|,
literal|0x243185BE
block|,
literal|0x4EE4B28C
block|,
literal|0x550C7DC3
block|,
literal|0xD5FFB4E2
block|,
literal|0x72BE5D74
block|,
literal|0xF27B896F
block|,
literal|0x80DEB1FE
block|,
literal|0x3B1696B1
block|,
literal|0x9BDC06A7
block|,
literal|0x25C71235
block|,
literal|0xC19BF174
block|,
literal|0xCF692694
block|,
literal|0xE49B69C1
block|,
literal|0x9EF14AD2
block|,
literal|0xEFBE4786
block|,
literal|0x384F25E3
block|,
literal|0x0FC19DC6
block|,
literal|0x8B8CD5B5
block|,
literal|0x240CA1CC
block|,
literal|0x77AC9C65
block|,
literal|0x2DE92C6F
block|,
literal|0x592B0275
block|,
literal|0x4A7484AA
block|,
literal|0x6EA6E483
block|,
literal|0x5CB0A9DC
block|,
literal|0xBD41FBD4
block|,
literal|0x76F988DA
block|,
literal|0x831153B5
block|,
literal|0x983E5152
block|,
literal|0xEE66DFAB
block|,
literal|0xA831C66D
block|,
literal|0x2DB43210
block|,
literal|0xB00327C8
block|,
literal|0x98FB213F
block|,
literal|0xBF597FC7
block|,
literal|0xBEEF0EE4
block|,
literal|0xC6E00BF3
block|,
literal|0x3DA88FC2
block|,
literal|0xD5A79147
block|,
literal|0x930AA725
block|,
literal|0x06CA6351
block|,
literal|0xE003826F
block|,
literal|0x14292967
block|,
literal|0x0A0E6E70
block|,
literal|0x27B70A85
block|,
literal|0x46D22FFC
block|,
literal|0x2E1B2138
block|,
literal|0x5C26C926
block|,
literal|0x4D2C6DFC
block|,
literal|0x5AC42AED
block|,
literal|0x53380D13
block|,
literal|0x9D95B3DF
block|,
literal|0x650A7354
block|,
literal|0x8BAF63DE
block|,
literal|0x766A0ABB
block|,
literal|0x3C77B2A8
block|,
literal|0x81C2C92E
block|,
literal|0x47EDAEE6
block|,
literal|0x92722C85
block|,
literal|0x1482353B
block|,
literal|0xA2BFE8A1
block|,
literal|0x4CF10364
block|,
literal|0xA81A664B
block|,
literal|0xBC423001
block|,
literal|0xC24B8B70
block|,
literal|0xD0F89791
block|,
literal|0xC76C51A3
block|,
literal|0x0654BE30
block|,
literal|0xD192E819
block|,
literal|0xD6EF5218
block|,
literal|0xD6990624
block|,
literal|0x5565A910
block|,
literal|0xF40E3585
block|,
literal|0x5771202A
block|,
literal|0x106AA070
block|,
literal|0x32BBD1B8
block|,
literal|0x19A4C116
block|,
literal|0xB8D2D0C8
block|,
literal|0x1E376C08
block|,
literal|0x5141AB53
block|,
literal|0x2748774C
block|,
literal|0xDF8EEB99
block|,
literal|0x34B0BCB5
block|,
literal|0xE19B48A8
block|,
literal|0x391C0CB3
block|,
literal|0xC5C95A63
block|,
literal|0x4ED8AA4A
block|,
literal|0xE3418ACB
block|,
literal|0x5B9CCA4F
block|,
literal|0x7763E373
block|,
literal|0x682E6FF3
block|,
literal|0xD6B2B8A3
block|,
literal|0x748F82EE
block|,
literal|0x5DEFB2FC
block|,
literal|0x78A5636F
block|,
literal|0x43172F60
block|,
literal|0x84C87814
block|,
literal|0xA1F0AB72
block|,
literal|0x8CC70208
block|,
literal|0x1A6439EC
block|,
literal|0x90BEFFFA
block|,
literal|0x23631E28
block|,
literal|0xA4506CEB
block|,
literal|0xDE82BDE9
block|,
literal|0xBEF9A3F7
block|,
literal|0xB2C67915
block|,
literal|0xC67178F2
block|,
literal|0xE372532B
block|,
literal|0xCA273ECE
block|,
literal|0xEA26619C
block|,
literal|0xD186B8C7
block|,
literal|0x21C0C207
block|,
literal|0xEADA7DD6
block|,
literal|0xCDE0EB1E
block|,
literal|0xF57D4F7F
block|,
literal|0xEE6ED178
block|,
literal|0x06F067AA
block|,
literal|0x72176FBA
block|,
literal|0x0A637DC5
block|,
literal|0xA2C898A6
block|,
literal|0x113F9804
block|,
literal|0xBEF90DAE
block|,
literal|0x1B710B35
block|,
literal|0x131C471B
block|,
literal|0x28DB77F5
block|,
literal|0x23047D84
block|,
literal|0x32CAAB7B
block|,
literal|0x40C72493
block|,
literal|0x3C9EBE0A
block|,
literal|0x15C9BEBC
block|,
literal|0x431D67C4
block|,
literal|0x9C100D4C
block|,
literal|0x4CC5D4BE
block|,
literal|0xCB3E42B6
block|,
literal|0x597F299C
block|,
literal|0xFC657E2A
block|,
literal|0x5FCB6FAB
block|,
literal|0x3AD6FAEC
block|,
literal|0x6C44198C
block|,
literal|0x4A475817
block|}
decl_stmt|;
name|int
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t8
decl_stmt|;
comment|/* Loop counter */
name|uint32_t
name|temp1
index|[
literal|2
index|]
decl_stmt|,
name|temp2
index|[
literal|2
index|]
decl_stmt|,
comment|/* Temporary word values */
name|temp3
index|[
literal|2
index|]
decl_stmt|,
name|temp4
index|[
literal|2
index|]
decl_stmt|,
name|temp5
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|W
index|[
literal|2
operator|*
literal|80
index|]
decl_stmt|;
comment|/* Word sequence */
name|uint32_t
name|A
index|[
literal|2
index|]
decl_stmt|,
name|B
index|[
literal|2
index|]
decl_stmt|,
name|C
index|[
literal|2
index|]
decl_stmt|,
name|D
index|[
literal|2
index|]
decl_stmt|,
comment|/* Word buffers */
name|E
index|[
literal|2
index|]
decl_stmt|,
name|F
index|[
literal|2
index|]
decl_stmt|,
name|G
index|[
literal|2
index|]
decl_stmt|,
name|H
index|[
literal|2
index|]
decl_stmt|;
comment|/* Initialize the first 16 words in the array W */
for|for
control|(
name|t
operator|=
name|t2
operator|=
name|t8
operator|=
literal|0
init|;
name|t
operator|<
literal|16
condition|;
name|t
operator|++
operator|,
name|t8
operator|+=
literal|8
control|)
block|{
name|W
index|[
name|t2
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
index|]
operator|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|1
index|]
operator|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|2
index|]
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|3
index|]
operator|)
operator|)
operator|)
expr_stmt|;
name|W
index|[
name|t2
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|4
index|]
operator|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|5
index|]
operator|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|6
index|]
operator|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|7
index|]
operator|)
operator|)
operator|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|16
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
operator|,
name|t2
operator|+=
literal|2
control|)
block|{
comment|/* W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +       SHA512_sigma0(W[t-15]) + W[t-16]; */
name|uint32_t
modifier|*
name|Wt2
init|=
operator|&
name|W
index|[
name|t2
operator|-
literal|2
operator|*
literal|2
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|Wt7
init|=
operator|&
name|W
index|[
name|t2
operator|-
literal|7
operator|*
literal|2
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|Wt15
init|=
operator|&
name|W
index|[
name|t2
operator|-
literal|15
operator|*
literal|2
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|Wt16
init|=
operator|&
name|W
index|[
name|t2
operator|-
literal|16
operator|*
literal|2
index|]
decl_stmt|;
name|SHA512_sigma1
argument_list|(
name|Wt2
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp1
argument_list|,
name|Wt7
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|SHA512_sigma0
argument_list|(
name|Wt15
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp1
argument_list|,
name|Wt16
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp2
argument_list|,
name|temp3
argument_list|,
operator|&
name|W
index|[
name|t2
index|]
argument_list|)
expr_stmt|;
block|}
name|A
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|0
index|]
expr_stmt|;
name|A
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|1
index|]
expr_stmt|;
name|B
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|2
index|]
expr_stmt|;
name|B
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|3
index|]
expr_stmt|;
name|C
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|4
index|]
expr_stmt|;
name|C
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|5
index|]
expr_stmt|;
name|D
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|6
index|]
expr_stmt|;
name|D
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|7
index|]
expr_stmt|;
name|E
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|8
index|]
expr_stmt|;
name|E
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|9
index|]
expr_stmt|;
name|F
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|10
index|]
expr_stmt|;
name|F
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|11
index|]
expr_stmt|;
name|G
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|12
index|]
expr_stmt|;
name|G
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|13
index|]
expr_stmt|;
name|H
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|14
index|]
expr_stmt|;
name|H
index|[
literal|1
index|]
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|15
index|]
expr_stmt|;
for|for
control|(
name|t
operator|=
name|t2
operator|=
literal|0
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
operator|,
name|t2
operator|+=
literal|2
control|)
block|{
comment|/*      * temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];      */
name|SHA512_SIGMA1
argument_list|(
name|E
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|H
argument_list|,
name|temp1
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|SHA_Ch
argument_list|(
name|E
argument_list|,
name|F
argument_list|,
name|G
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp2
argument_list|,
name|temp3
argument_list|,
name|temp4
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
operator|&
name|K
index|[
name|t2
index|]
argument_list|,
operator|&
name|W
index|[
name|t2
index|]
argument_list|,
name|temp5
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp4
argument_list|,
name|temp5
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
comment|/*      * temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);      */
name|SHA512_SIGMA0
argument_list|(
name|A
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|SHA_Maj
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|temp4
argument_list|)
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp3
argument_list|,
name|temp4
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|H
index|[
literal|0
index|]
operator|=
name|G
index|[
literal|0
index|]
expr_stmt|;
name|H
index|[
literal|1
index|]
operator|=
name|G
index|[
literal|1
index|]
expr_stmt|;
name|G
index|[
literal|0
index|]
operator|=
name|F
index|[
literal|0
index|]
expr_stmt|;
name|G
index|[
literal|1
index|]
operator|=
name|F
index|[
literal|1
index|]
expr_stmt|;
name|F
index|[
literal|0
index|]
operator|=
name|E
index|[
literal|0
index|]
expr_stmt|;
name|F
index|[
literal|1
index|]
operator|=
name|E
index|[
literal|1
index|]
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|D
argument_list|,
name|temp1
argument_list|,
name|E
argument_list|)
expr_stmt|;
name|D
index|[
literal|0
index|]
operator|=
name|C
index|[
literal|0
index|]
expr_stmt|;
name|D
index|[
literal|1
index|]
operator|=
name|C
index|[
literal|1
index|]
expr_stmt|;
name|C
index|[
literal|0
index|]
operator|=
name|B
index|[
literal|0
index|]
expr_stmt|;
name|C
index|[
literal|1
index|]
operator|=
name|B
index|[
literal|1
index|]
expr_stmt|;
name|B
index|[
literal|0
index|]
operator|=
name|A
index|[
literal|0
index|]
expr_stmt|;
name|B
index|[
literal|1
index|]
operator|=
name|A
index|[
literal|1
index|]
expr_stmt|;
name|SHA512_ADD
argument_list|(
name|temp1
argument_list|,
name|temp2
argument_list|,
name|A
argument_list|)
expr_stmt|;
block|}
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|0
index|]
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|2
index|]
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|4
index|]
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|6
index|]
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|8
index|]
argument_list|,
name|E
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|10
index|]
argument_list|,
name|F
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|12
index|]
argument_list|,
name|G
argument_list|)
expr_stmt|;
name|SHA512_ADDTO2
argument_list|(
operator|&
name|context
operator|->
name|Intermediate_Hash
index|[
literal|14
index|]
argument_list|,
name|H
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
comment|/* Constants defined in FIPS 180-3, section 4.2.3 */
specifier|static
specifier|const
name|uint64_t
name|K
index|[
literal|80
index|]
init|=
block|{
literal|0x428A2F98D728AE22ll
block|,
literal|0x7137449123EF65CDll
block|,
literal|0xB5C0FBCFEC4D3B2Fll
block|,
literal|0xE9B5DBA58189DBBCll
block|,
literal|0x3956C25BF348B538ll
block|,
literal|0x59F111F1B605D019ll
block|,
literal|0x923F82A4AF194F9Bll
block|,
literal|0xAB1C5ED5DA6D8118ll
block|,
literal|0xD807AA98A3030242ll
block|,
literal|0x12835B0145706FBEll
block|,
literal|0x243185BE4EE4B28Cll
block|,
literal|0x550C7DC3D5FFB4E2ll
block|,
literal|0x72BE5D74F27B896Fll
block|,
literal|0x80DEB1FE3B1696B1ll
block|,
literal|0x9BDC06A725C71235ll
block|,
literal|0xC19BF174CF692694ll
block|,
literal|0xE49B69C19EF14AD2ll
block|,
literal|0xEFBE4786384F25E3ll
block|,
literal|0x0FC19DC68B8CD5B5ll
block|,
literal|0x240CA1CC77AC9C65ll
block|,
literal|0x2DE92C6F592B0275ll
block|,
literal|0x4A7484AA6EA6E483ll
block|,
literal|0x5CB0A9DCBD41FBD4ll
block|,
literal|0x76F988DA831153B5ll
block|,
literal|0x983E5152EE66DFABll
block|,
literal|0xA831C66D2DB43210ll
block|,
literal|0xB00327C898FB213Fll
block|,
literal|0xBF597FC7BEEF0EE4ll
block|,
literal|0xC6E00BF33DA88FC2ll
block|,
literal|0xD5A79147930AA725ll
block|,
literal|0x06CA6351E003826Fll
block|,
literal|0x142929670A0E6E70ll
block|,
literal|0x27B70A8546D22FFCll
block|,
literal|0x2E1B21385C26C926ll
block|,
literal|0x4D2C6DFC5AC42AEDll
block|,
literal|0x53380D139D95B3DFll
block|,
literal|0x650A73548BAF63DEll
block|,
literal|0x766A0ABB3C77B2A8ll
block|,
literal|0x81C2C92E47EDAEE6ll
block|,
literal|0x92722C851482353Bll
block|,
literal|0xA2BFE8A14CF10364ll
block|,
literal|0xA81A664BBC423001ll
block|,
literal|0xC24B8B70D0F89791ll
block|,
literal|0xC76C51A30654BE30ll
block|,
literal|0xD192E819D6EF5218ll
block|,
literal|0xD69906245565A910ll
block|,
literal|0xF40E35855771202All
block|,
literal|0x106AA07032BBD1B8ll
block|,
literal|0x19A4C116B8D2D0C8ll
block|,
literal|0x1E376C085141AB53ll
block|,
literal|0x2748774CDF8EEB99ll
block|,
literal|0x34B0BCB5E19B48A8ll
block|,
literal|0x391C0CB3C5C95A63ll
block|,
literal|0x4ED8AA4AE3418ACBll
block|,
literal|0x5B9CCA4F7763E373ll
block|,
literal|0x682E6FF3D6B2B8A3ll
block|,
literal|0x748F82EE5DEFB2FCll
block|,
literal|0x78A5636F43172F60ll
block|,
literal|0x84C87814A1F0AB72ll
block|,
literal|0x8CC702081A6439ECll
block|,
literal|0x90BEFFFA23631E28ll
block|,
literal|0xA4506CEBDE82BDE9ll
block|,
literal|0xBEF9A3F7B2C67915ll
block|,
literal|0xC67178F2E372532Bll
block|,
literal|0xCA273ECEEA26619Cll
block|,
literal|0xD186B8C721C0C207ll
block|,
literal|0xEADA7DD6CDE0EB1Ell
block|,
literal|0xF57D4F7FEE6ED178ll
block|,
literal|0x06F067AA72176FBAll
block|,
literal|0x0A637DC5A2C898A6ll
block|,
literal|0x113F9804BEF90DAEll
block|,
literal|0x1B710B35131C471Bll
block|,
literal|0x28DB77F523047D84ll
block|,
literal|0x32CAAB7B40C72493ll
block|,
literal|0x3C9EBE0A15C9BEBCll
block|,
literal|0x431D67C49C100D4Cll
block|,
literal|0x4CC5D4BECB3E42B6ll
block|,
literal|0x597F299CFC657E2All
block|,
literal|0x5FCB6FAB3AD6FAECll
block|,
literal|0x6C44198C4A475817ll
block|}
decl_stmt|;
name|int
name|t
decl_stmt|,
name|t8
decl_stmt|;
comment|/* Loop counter */
name|uint64_t
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
comment|/* Temporary word value */
name|uint64_t
name|W
index|[
literal|80
index|]
decl_stmt|;
comment|/* Word sequence */
name|uint64_t
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|,
name|E
decl_stmt|,
name|F
decl_stmt|,
name|G
decl_stmt|,
name|H
decl_stmt|;
comment|/* Word buffers */
comment|/*    * Initialize the first 16 words in the array W    */
for|for
control|(
name|t
operator|=
name|t8
operator|=
literal|0
init|;
name|t
operator|<
literal|16
condition|;
name|t
operator|++
operator|,
name|t8
operator|+=
literal|8
control|)
name|W
index|[
name|t
index|]
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
index|]
argument_list|)
operator|<<
literal|56
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|1
index|]
argument_list|)
operator|<<
literal|48
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|2
index|]
argument_list|)
operator|<<
literal|40
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|3
index|]
argument_list|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|4
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|5
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|6
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|context
operator|->
name|Message_Block
index|[
name|t8
operator|+
literal|7
index|]
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|16
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
control|)
name|W
index|[
name|t
index|]
operator|=
name|SHA512_sigma1
argument_list|(
name|W
index|[
name|t
operator|-
literal|2
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|7
index|]
operator|+
name|SHA512_sigma0
argument_list|(
name|W
index|[
name|t
operator|-
literal|15
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|16
index|]
expr_stmt|;
name|A
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|0
index|]
expr_stmt|;
name|B
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|1
index|]
expr_stmt|;
name|C
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|2
index|]
expr_stmt|;
name|D
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|3
index|]
expr_stmt|;
name|E
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|4
index|]
expr_stmt|;
name|F
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|5
index|]
expr_stmt|;
name|G
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|6
index|]
expr_stmt|;
name|H
operator|=
name|context
operator|->
name|Intermediate_Hash
index|[
literal|7
index|]
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
control|)
block|{
name|temp1
operator|=
name|H
operator|+
name|SHA512_SIGMA1
argument_list|(
name|E
argument_list|)
operator|+
name|SHA_Ch
argument_list|(
name|E
argument_list|,
name|F
argument_list|,
name|G
argument_list|)
operator|+
name|K
index|[
name|t
index|]
operator|+
name|W
index|[
name|t
index|]
expr_stmt|;
name|temp2
operator|=
name|SHA512_SIGMA0
argument_list|(
name|A
argument_list|)
operator|+
name|SHA_Maj
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|H
operator|=
name|G
expr_stmt|;
name|G
operator|=
name|F
expr_stmt|;
name|F
operator|=
name|E
expr_stmt|;
name|E
operator|=
name|D
operator|+
name|temp1
expr_stmt|;
name|D
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|B
expr_stmt|;
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|temp1
operator|+
name|temp2
expr_stmt|;
block|}
name|context
operator|->
name|Intermediate_Hash
index|[
literal|0
index|]
operator|+=
name|A
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|1
index|]
operator|+=
name|B
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|2
index|]
operator|+=
name|C
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|3
index|]
operator|+=
name|D
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|4
index|]
operator|+=
name|E
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|5
index|]
operator|+=
name|F
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|6
index|]
operator|+=
name|G
expr_stmt|;
name|context
operator|->
name|Intermediate_Hash
index|[
literal|7
index|]
operator|+=
name|H
expr_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
name|context
operator|->
name|Message_Block_Index
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * SHA384_512Finalize  *  * Description:  *   This helper function finishes off the digest calculations.  *  * Parameters:  *   context: [in/out]  *     The SHA context to update.  *   Pad_Byte: [in]  *     The last byte to add to the message block before the 0-padding  *     and length.  This will contain the last bits of the message  *     followed by another single bit.  If the message was an  *     exact multiple of 8-bits long, Pad_Byte will be 0x80.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384_512Finalize
specifier|static
name|void
name|SHA384_512Finalize
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
block|{
name|int_least16_t
name|i
decl_stmt|;
name|SHA384_512PadMessage
argument_list|(
name|context
argument_list|,
name|Pad_Byte
argument_list|)
expr_stmt|;
comment|/* message may be sensitive, clear it out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHA512_Message_Block_Size
condition|;
operator|++
name|i
control|)
name|context
operator|->
name|Message_Block
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
comment|/* and clear length */
name|context
operator|->
name|Length
index|[
literal|0
index|]
operator|=
name|context
operator|->
name|Length
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|Length
index|[
literal|2
index|]
operator|=
name|context
operator|->
name|Length
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
name|context
operator|->
name|Length_High
operator|=
name|context
operator|->
name|Length_Low
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
name|context
operator|->
name|Computed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * SHA384_512PadMessage  *  * Description:  *   According to the standard, the message must be padded to the next  *   even multiple of 1024 bits.  The first padding bit must be a '1'.  *   The last 128 bits represent the length of the original message.  *   All bits in between should be 0.  This helper function will  *   pad the message according to those rules by filling the  *   Message_Block array accordingly.  When it returns, it can be  *   assumed that the message digest has been computed.  *  * Parameters:  *   context: [in/out]  *     The context to pad.  *   Pad_Byte: [in]  *     The last byte to add to the message block before the 0-padding  *     and length.  This will contain the last bits of the message  *     followed by another single bit.  If the message was an  *     exact multiple of 8-bits long, Pad_Byte will be 0x80.  *  * Returns:  *   Nothing.  *  */
end_comment
begin_function
DECL|function|SHA384_512PadMessage
specifier|static
name|void
name|SHA384_512PadMessage
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Pad_Byte
parameter_list|)
block|{
comment|/*    * Check to see if the current message block is too small to hold    * the initial padding bits and length.  If so, we will pad the    * block, process it, and then continue padding into a second    * block.    */
if|if
condition|(
name|context
operator|->
name|Message_Block_Index
operator|>=
operator|(
name|SHA512_Message_Block_Size
operator|-
literal|16
operator|)
condition|)
block|{
name|context
operator|->
name|Message_Block
index|[
name|context
operator|->
name|Message_Block_Index
operator|++
index|]
operator|=
name|Pad_Byte
expr_stmt|;
while|while
condition|(
name|context
operator|->
name|Message_Block_Index
operator|<
name|SHA512_Message_Block_Size
condition|)
name|context
operator|->
name|Message_Block
index|[
name|context
operator|->
name|Message_Block_Index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|SHA384_512ProcessMessageBlock
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
else|else
name|context
operator|->
name|Message_Block
index|[
name|context
operator|->
name|Message_Block_Index
operator|++
index|]
operator|=
name|Pad_Byte
expr_stmt|;
while|while
condition|(
name|context
operator|->
name|Message_Block_Index
operator|<
operator|(
name|SHA512_Message_Block_Size
operator|-
literal|16
operator|)
condition|)
name|context
operator|->
name|Message_Block
index|[
name|context
operator|->
name|Message_Block_Index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    * Store the message length as the last 16 octets    */
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
name|context
operator|->
name|Message_Block
index|[
literal|112
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|0
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|113
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|114
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|0
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|115
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|116
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|1
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|117
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|118
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|1
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|119
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|120
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|2
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|121
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|2
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|122
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|2
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|123
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|124
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|3
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|125
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|3
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|126
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|3
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|127
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
name|context
operator|->
name|Message_Block
index|[
literal|112
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|56
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|113
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|114
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|40
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|115
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|116
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|117
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|118
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|119
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_High
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|120
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|56
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|121
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|122
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|40
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|123
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|124
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|125
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|126
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|context
operator|->
name|Message_Block
index|[
literal|127
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Length_Low
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
name|SHA384_512ProcessMessageBlock
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * SHA384_512ResultN  *  * Description:  *   This helper function will return the 384-bit or 512-bit message  *   digest into the Message_Digest array provided by the caller.  *   NOTE:  *    The first octet of hash is stored in the element with index 0,  *    the last octet of hash in the element with index 47/63.  *  * Parameters:  *   context: [in/out]  *     The context to use to calculate the SHA hash.  *   Message_Digest[ ]: [out]  *     Where the digest is returned.  *   HashSize: [in]  *     The size of the hash, either 48 or 64.  *  * Returns:  *   sha Error Code.  *  */
end_comment
begin_function
DECL|function|SHA384_512ResultN
specifier|static
name|int
name|SHA384_512ResultN
parameter_list|(
name|SHA512Context
modifier|*
name|context
parameter_list|,
name|uint8_t
name|Message_Digest
index|[ ]
parameter_list|,
name|int
name|HashSize
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
name|int
name|i2
decl_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
if|if
condition|(
operator|!
name|context
condition|)
return|return
name|shaNull
return|;
if|if
condition|(
operator|!
name|Message_Digest
condition|)
return|return
name|shaNull
return|;
if|if
condition|(
name|context
operator|->
name|Corrupted
condition|)
return|return
name|context
operator|->
name|Corrupted
return|;
if|if
condition|(
operator|!
name|context
operator|->
name|Computed
condition|)
name|SHA384_512Finalize
argument_list|(
name|context
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_32BIT_ONLY
for|for
control|(
name|i
operator|=
name|i2
operator|=
literal|0
init|;
name|i
operator|<
name|HashSize
condition|;
control|)
block|{
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
operator|++
index|]
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|Message_Digest
index|[
name|i
operator|++
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i2
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !USE_32BIT_ONLY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HashSize
condition|;
operator|++
name|i
control|)
name|Message_Digest
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|context
operator|->
name|Intermediate_Hash
index|[
name|i
operator|>>
literal|3
index|]
operator|>>
literal|8
operator|*
operator|(
literal|7
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_32BIT_ONLY */
return|return
name|shaSuccess
return|;
block|}
end_function
end_unit
