begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qscroller.h"
end_include
begin_include
include|#
directive|include
file|"private/qflickgesture_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qscroller_p.h"
end_include
begin_include
include|#
directive|include
file|"qscrollerproperties.h"
end_include
begin_include
include|#
directive|include
file|"private/qscrollerproperties_p.h"
end_include
begin_include
include|#
directive|include
file|"qnumeric.h"
end_include
begin_include
include|#
directive|include
file|"math.h"
end_include
begin_include
include|#
directive|include
file|<QTime>
end_include
begin_include
include|#
directive|include
file|<QElapsedTimer>
end_include
begin_include
include|#
directive|include
file|<QMap>
end_include
begin_include
include|#
directive|include
file|<QApplication>
end_include
begin_include
include|#
directive|include
file|<QAbstractScrollArea>
end_include
begin_include
include|#
directive|include
file|<QGraphicsObject>
end_include
begin_include
include|#
directive|include
file|<QGraphicsScene>
end_include
begin_include
include|#
directive|include
file|<QGraphicsView>
end_include
begin_include
include|#
directive|include
file|<QDesktopWidget>
end_include
begin_include
include|#
directive|include
file|<QVector2D>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qevent.h>
end_include
begin_include
include|#
directive|include
file|<qnumeric.h>
end_include
begin_include
include|#
directive|include
file|<QtDebug>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//#define QSCROLLER_DEBUG
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QSCROLLER_DEBUG
end_ifdef
begin_define
DECL|macro|qScrollerDebug
define|#
directive|define
name|qScrollerDebug
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|qScrollerDebug
define|#
directive|define
name|qScrollerDebug
value|while (false) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|operator <<
name|QDebug
modifier|&
name|operator
name|<<
parameter_list|(
name|QDebug
modifier|&
name|dbg
parameter_list|,
specifier|const
name|QScrollerPrivate
operator|::
name|ScrollSegment
modifier|&
name|s
parameter_list|)
block|{
name|dbg
operator|<<
literal|"\n  Time: start:"
operator|<<
name|s
operator|.
name|startTime
operator|<<
literal|" duration:"
operator|<<
name|s
operator|.
name|deltaTime
operator|<<
literal|" stop progress:"
operator|<<
name|s
operator|.
name|stopProgress
expr_stmt|;
name|dbg
operator|<<
literal|"\n  Pos: start:"
operator|<<
name|s
operator|.
name|startPos
operator|<<
literal|" delta:"
operator|<<
name|s
operator|.
name|deltaPos
operator|<<
literal|" stop:"
operator|<<
name|s
operator|.
name|stopPos
expr_stmt|;
name|dbg
operator|<<
literal|"\n  Curve: type:"
operator|<<
name|s
operator|.
name|curve
operator|.
name|type
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|// a few helper operators to make the code below a lot more readable:
end_comment
begin_comment
comment|// otherwise a lot of ifs would have to be multi-line to check both the x
end_comment
begin_comment
comment|// and y coordinate separately.
end_comment
begin_comment
comment|// returns true only if the abs. value of BOTH x and y are<= f
end_comment
begin_function
DECL|function|operator <=
specifier|inline
name|bool
name|operator
name|<=
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
name|qreal
name|f
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|<=
name|f
operator|)
operator|&&
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
operator|<=
name|f
operator|)
return|;
block|}
end_function
begin_comment
comment|// returns true only if the abs. value of BOTH x and y are< f
end_comment
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
name|qreal
name|f
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|<
name|f
operator|)
operator|&&
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
operator|<
name|f
operator|)
return|;
block|}
end_function
begin_comment
comment|// returns true if the abs. value of EITHER x or y are>= f
end_comment
begin_function
DECL|function|operator >=
specifier|inline
name|bool
name|operator
name|>=
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
name|qreal
name|f
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|>=
name|f
operator|)
operator|||
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
operator|>=
name|f
operator|)
return|;
block|}
end_function
begin_comment
comment|// returns true if the abs. value of EITHER x or y are> f
end_comment
begin_function
DECL|function|operator >
specifier|inline
name|bool
name|operator
name|>
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
name|qreal
name|f
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
operator|>
name|f
operator|)
operator|||
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
operator|>
name|f
operator|)
return|;
block|}
end_function
begin_comment
comment|// returns a new point with both coordinates having the abs. value of the original one
end_comment
begin_function
DECL|function|qAbs
specifier|inline
name|QPointF
name|qAbs
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|)
block|{
return|return
name|QPointF
argument_list|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// returns a new point with all components of p1 multiplied by the corresponding components of p2
end_comment
begin_function
DECL|function|operator *
specifier|inline
name|QPointF
name|operator
name|*
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p2
parameter_list|)
block|{
return|return
name|QPointF
argument_list|(
name|p1
operator|.
name|x
argument_list|()
operator|*
name|p2
operator|.
name|x
argument_list|()
argument_list|,
name|p1
operator|.
name|y
argument_list|()
operator|*
name|p2
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// returns a new point with all components of p1 divided by the corresponding components of p2
end_comment
begin_function
DECL|function|operator /
specifier|inline
name|QPointF
name|operator
name|/
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p2
parameter_list|)
block|{
return|return
name|QPointF
argument_list|(
name|p1
operator|.
name|x
argument_list|()
operator|/
name|p2
operator|.
name|x
argument_list|()
argument_list|,
name|p1
operator|.
name|y
argument_list|()
operator|/
name|p2
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clampToRect
specifier|inline
name|QPointF
name|clampToRect
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|qreal
name|x
init|=
name|qBound
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
decl_stmt|;
name|qreal
name|y
init|=
name|qBound
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// returns -1, 0 or +1 according to r being<0, ==0 or>0
end_comment
begin_function
DECL|function|qSign
specifier|inline
name|int
name|qSign
parameter_list|(
name|qreal
name|r
parameter_list|)
block|{
return|return
operator|(
name|r
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|r
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|// this version is not mathematically exact, but it just works for every
end_comment
begin_comment
comment|// easing curve type (even custom ones)
end_comment
begin_function
DECL|function|differentialForProgress
specifier|static
name|qreal
name|differentialForProgress
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|curve
parameter_list|,
name|qreal
name|pos
parameter_list|)
block|{
specifier|const
name|qreal
name|dx
init|=
literal|0.01
decl_stmt|;
name|qreal
name|left
init|=
operator|(
name|pos
operator|<
name|qreal
argument_list|(
literal|0.5
argument_list|)
operator|)
condition|?
name|pos
else|:
name|pos
operator|-
name|qreal
argument_list|(
name|dx
argument_list|)
decl_stmt|;
name|qreal
name|right
init|=
operator|(
name|pos
operator|>=
name|qreal
argument_list|(
literal|0.5
argument_list|)
operator|)
condition|?
name|pos
else|:
name|pos
operator|+
name|qreal
argument_list|(
name|dx
argument_list|)
decl_stmt|;
name|qreal
name|d
init|=
operator|(
name|curve
operator|.
name|valueForProgress
argument_list|(
name|right
argument_list|)
operator|-
name|curve
operator|.
name|valueForProgress
argument_list|(
name|left
argument_list|)
operator|)
operator|/
name|qreal
argument_list|(
name|dx
argument_list|)
decl_stmt|;
comment|//qScrollerDebug()<< "differentialForProgress(type: "<< curve.type()<< ", pos: "<< pos<< ") = "<< d;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|// this version is not mathematically exact, but it just works for every
end_comment
begin_comment
comment|// easing curve type (even custom ones)
end_comment
begin_function
DECL|function|progressForValue
specifier|static
name|qreal
name|progressForValue
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|curve
parameter_list|,
name|qreal
name|value
parameter_list|)
block|{
if|if
condition|(
name|curve
operator|.
name|type
argument_list|()
operator|>=
name|QEasingCurve
operator|::
name|InElastic
operator|&&
name|curve
operator|.
name|type
argument_list|()
operator|<
name|QEasingCurve
operator|::
name|Custom
condition|)
block|{
name|qWarning
argument_list|(
literal|"progressForValue(): QEasingCurves of type %d do not have an inverse, since they are not injective."
argument_list|,
name|curve
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|value
argument_list|<
name|qreal
operator|(
literal|0
operator|)
operator|||
name|value
argument_list|>
name|qreal
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|value
return|;
name|qreal
name|progress
init|=
name|value
decl_stmt|,
name|left
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|right
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|iterations
init|=
literal|6
init|;
name|iterations
condition|;
operator|--
name|iterations
control|)
block|{
name|qreal
name|v
init|=
name|curve
operator|.
name|valueForProgress
argument_list|(
name|progress
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|<
name|value
condition|)
name|left
operator|=
name|progress
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>
name|value
condition|)
name|right
operator|=
name|progress
expr_stmt|;
else|else
break|break;
name|progress
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
name|qreal
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|progress
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
end_ifndef
begin_class
DECL|class|QScrollTimer
class|class
name|QScrollTimer
super|:
specifier|public
name|QAbstractAnimation
block|{
public|public:
DECL|function|QScrollTimer
name|QScrollTimer
parameter_list|(
name|QScrollerPrivate
modifier|*
name|_d
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|_d
argument_list|)
member_init_list|,
name|ignoreUpdate
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|skip
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|duration
name|int
name|duration
parameter_list|()
specifier|const
block|{
return|return
operator|-
literal|1
return|;
block|}
DECL|function|start
name|void
name|start
parameter_list|()
block|{
comment|// QAbstractAnimation::start() will immediately call
comment|// updateCurrentTime(), but our state is not set correctly yet
name|ignoreUpdate
operator|=
literal|true
expr_stmt|;
name|QAbstractAnimation
operator|::
name|start
argument_list|()
expr_stmt|;
name|ignoreUpdate
operator|=
literal|false
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
protected|protected:
DECL|function|updateCurrentTime
name|void
name|updateCurrentTime
parameter_list|(
name|int
comment|/*currentTime*/
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreUpdate
condition|)
block|{
if|if
condition|(
operator|++
name|skip
operator|>=
name|d
operator|->
name|frameRateSkip
argument_list|()
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timerTick
argument_list|()
expr_stmt|;
block|}
block|}
block|}
private|private:
DECL|member|d
name|QScrollerPrivate
modifier|*
name|d
decl_stmt|;
DECL|member|ignoreUpdate
name|bool
name|ignoreUpdate
decl_stmt|;
DECL|member|skip
name|int
name|skip
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ANIMATION
end_comment
begin_comment
comment|/*!     \class QScroller     \brief The QScroller class enables kinetic scrolling for any scrolling widget or graphics item.     \since 5.0      \inmodule QtWidgets      With kinetic scrolling, the user can push the widget in a given     direction and it will continue to scroll in this direction until it is     stopped either by the user or by friction.  Aspects of inertia, friction     and other physical concepts can be changed in order to fine-tune an     intuitive user experience.      The QScroller object is the object that stores the current position and     scrolling speed and takes care of updates.     QScroller can be triggered by a flick gesture      \code         QWidget *w = ...;         QScroller::grabGesture(w, QScroller::LeftMouseButtonGesture);     \endcode      or directly like this:      \code         QWidget *w = ...;         QScroller *scroller = QScroller::scroller(w);         scroller->scrollTo(QPointF(100, 100));     \endcode      The scrolled QObjects receive a QScrollPrepareEvent whenever the scroller needs to     update its geometry information and a QScrollEvent whenever the content of the object should     actually be scrolled.      The scroller uses the global QAbstractAnimation timer to generate its QScrollEvents. This     can be changed with QScrollerProperties::FrameRate on a per-QScroller basis.      Several examples in the \c scroller examples directory show how QScroller,     QScrollEvent and the scroller gesture can be used.      Even though this kinetic scroller has a large number of settings available via     QScrollerProperties, we recommend that you leave them all at their default, platform optimized     values. Before changing them you can experiment with the \c plot example in     the \c scroller examples directory.      \sa QScrollEvent, QScrollPrepareEvent, QScrollerProperties */
end_comment
begin_typedef
DECL|typedef|ScrollerHash
typedef|typedef
name|QMap
argument_list|<
name|QObject
modifier|*
argument_list|,
name|QScroller
modifier|*
argument_list|>
name|ScrollerHash
typedef|;
end_typedef
begin_typedef
DECL|typedef|ScrollerSet
typedef|typedef
name|QSet
argument_list|<
name|QScroller
modifier|*
argument_list|>
name|ScrollerSet
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|ScrollerHash
argument_list|,
argument|qt_allScrollers
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|ScrollerSet
argument_list|,
argument|qt_activeScrollers
argument_list|)
end_macro
begin_comment
comment|/*!     Returns \c true if a QScroller object was already created for \a target; \c false otherwise.      \sa scroller() */
end_comment
begin_function
DECL|function|hasScroller
name|bool
name|QScroller
operator|::
name|hasScroller
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|qt_allScrollers
argument_list|()
operator|->
name|value
argument_list|(
name|target
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the scroller for the given \a target.     As long as the object exists this function will always return the same QScroller instance.     If no QScroller exists for the \a target, one will implicitly be created.     At no point more than one QScroller will be active on an object.      \sa hasScroller(), target() */
end_comment
begin_function
DECL|function|scroller
name|QScroller
modifier|*
name|QScroller
operator|::
name|scroller
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|qWarning
argument_list|(
literal|"QScroller::scroller() was called with a null target."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|qt_allScrollers
argument_list|()
operator|->
name|contains
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|qt_allScrollers
argument_list|()
operator|->
name|value
argument_list|(
name|target
argument_list|)
return|;
name|QScroller
modifier|*
name|s
init|=
operator|new
name|QScroller
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|qt_allScrollers
argument_list|()
operator|->
name|insert
argument_list|(
name|target
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     This is the const version of scroller(). */
end_comment
begin_function
DECL|function|scroller
specifier|const
name|QScroller
modifier|*
name|QScroller
operator|::
name|scroller
parameter_list|(
specifier|const
name|QObject
modifier|*
name|target
parameter_list|)
block|{
return|return
name|scroller
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an application wide list of currently active QScroller objects.     Active QScroller objects are in a state() that is not QScroller::Inactive.     This function is useful when writing your own gesture recognizer. */
end_comment
begin_function
DECL|function|activeScrollers
name|QList
argument_list|<
name|QScroller
modifier|*
argument_list|>
name|QScroller
operator|::
name|activeScrollers
parameter_list|()
block|{
return|return
name|qt_activeScrollers
argument_list|()
operator|->
name|toList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the target object of this scroller.     \sa hasScroller(), scroller()  */
end_comment
begin_function
DECL|function|target
name|QObject
modifier|*
name|QScroller
operator|::
name|target
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|target
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QScroller::scrollerPropertiesChanged(const QScrollerProperties&newProperties);      QScroller emits this signal whenever its scroller properties change.     \a newProperties are the new scroller properties.      \sa scrollerProperties */
end_comment
begin_comment
comment|/*! \property QScroller::scrollerProperties     \brief The scroller properties of this scroller.     The properties are used by the QScroller to determine its scrolling behavior. */
end_comment
begin_function
DECL|function|scrollerProperties
name|QScrollerProperties
name|QScroller
operator|::
name|scrollerProperties
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|properties
return|;
block|}
end_function
begin_function
DECL|function|setScrollerProperties
name|void
name|QScroller
operator|::
name|setScrollerProperties
parameter_list|(
specifier|const
name|QScrollerProperties
modifier|&
name|sp
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|properties
operator|!=
name|sp
condition|)
block|{
name|d
operator|->
name|properties
operator|=
name|sp
expr_stmt|;
emit|emit
name|scrollerPropertiesChanged
argument_list|(
name|sp
argument_list|)
emit|;
comment|// we need to force the recalculation here, since the overshootPolicy may have changed and
comment|// existing segments may include an overshoot animation.
name|d
operator|->
name|recalcScrollingSegments
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_comment
comment|/*!     Registers a custom scroll gesture recognizer, grabs it for the \a     target and returns the resulting gesture type.  If \a scrollGestureType is     set to TouchGesture the gesture triggers on touch events. If it is set to     one of LeftMouseButtonGesture, RightMouseButtonGesture or     MiddleMouseButtonGesture it triggers on mouse events of the     corresponding button.      Only one scroll gesture can be active on a single object at the same     time. If you call this function twice on the same object, it will     ungrab the existing gesture before grabbing the new one.      \note To avoid unwanted side-effects, mouse events are consumed while     the gesture is triggered. Since the initial mouse press event is     not consumed, the gesture sends a fake mouse release event     at the global position \c{(INT_MIN, INT_MIN)}. This ensures that     internal states of the widget that received the original mouse press     are consistent.      \sa ungrabGesture(), grabbedGesture() */
end_comment
begin_function
DECL|function|grabGesture
name|Qt
operator|::
name|GestureType
name|QScroller
operator|::
name|grabGesture
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|,
name|ScrollerGestureType
name|scrollGestureType
parameter_list|)
block|{
comment|// ensure that a scroller for target is created
name|QScroller
modifier|*
name|s
init|=
name|scroller
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Qt
operator|::
name|GestureType
argument_list|(
literal|0
argument_list|)
return|;
name|QScrollerPrivate
modifier|*
name|sp
init|=
name|s
operator|->
name|d_ptr
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|recognizer
condition|)
name|ungrabGesture
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// ungrab the old gesture
name|Qt
operator|::
name|MouseButton
name|button
decl_stmt|;
switch|switch
condition|(
name|scrollGestureType
condition|)
block|{
case|case
name|LeftMouseButtonGesture
case|:
name|button
operator|=
name|Qt
operator|::
name|LeftButton
expr_stmt|;
break|break;
case|case
name|RightMouseButtonGesture
case|:
name|button
operator|=
name|Qt
operator|::
name|RightButton
expr_stmt|;
break|break;
case|case
name|MiddleMouseButtonGesture
case|:
name|button
operator|=
name|Qt
operator|::
name|MiddleButton
expr_stmt|;
break|break;
default|default                      :
case|case
name|TouchGesture
case|:
name|button
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
break|break;
comment|// NoButton == Touch
block|}
name|sp
operator|->
name|recognizer
operator|=
operator|new
name|QFlickGestureRecognizer
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|sp
operator|->
name|recognizerType
operator|=
name|QGestureRecognizer
operator|::
name|registerRecognizer
argument_list|(
name|sp
operator|->
name|recognizer
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|widget
operator|->
name|grabGesture
argument_list|(
name|sp
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrollGestureType
operator|==
name|TouchGesture
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
block|}
elseif|else
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|scrollGestureType
operator|==
name|TouchGesture
condition|)
name|go
operator|->
name|setAcceptTouchEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|go
operator|->
name|grabGesture
argument_list|(
name|sp
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_GRAPHICSVIEW
block|}
return|return
name|sp
operator|->
name|recognizerType
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the gesture type currently grabbed for the \a target or 0 if no     gesture is grabbed.      \sa grabGesture(), ungrabGesture() */
end_comment
begin_function
DECL|function|grabbedGesture
name|Qt
operator|::
name|GestureType
name|QScroller
operator|::
name|grabbedGesture
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
block|{
name|QScroller
modifier|*
name|s
init|=
name|scroller
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|d_ptr
condition|)
return|return
name|s
operator|->
name|d_ptr
operator|->
name|recognizerType
return|;
else|else
return|return
name|Qt
operator|::
name|GestureType
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Ungrabs the gesture for the \a target.     Does nothing if no gesture is grabbed.      \sa grabGesture(), grabbedGesture() */
end_comment
begin_function
DECL|function|ungrabGesture
name|void
name|QScroller
operator|::
name|ungrabGesture
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
block|{
name|QScroller
modifier|*
name|s
init|=
name|scroller
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
name|QScrollerPrivate
modifier|*
name|sp
init|=
name|s
operator|->
name|d_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|recognizer
condition|)
return|return;
comment|// nothing to do
if|if
condition|(
name|target
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|widget
operator|->
name|ungrabGesture
argument_list|(
name|sp
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
block|}
elseif|else
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|go
operator|->
name|ungrabGesture
argument_list|(
name|sp
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|QGestureRecognizer
operator|::
name|unregisterRecognizer
argument_list|(
name|sp
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
comment|// do not delete the recognizer. The QGestureManager is doing this.
name|sp
operator|->
name|recognizer
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QScroller
name|QScroller
operator|::
name|QScroller
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QScrollerPrivate
argument_list|(
name|this
argument_list|,
name|target
argument_list|)
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// you can't create a scroller without a target in any normal way
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QScroller
name|QScroller
operator|::
name|~
name|QScroller
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|QGestureRecognizer
operator|::
name|unregisterRecognizer
argument_list|(
name|d
operator|->
name|recognizerType
argument_list|)
expr_stmt|;
comment|// do not delete the recognizer. The QGestureManager is doing this.
name|d
operator|->
name|recognizer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|qt_allScrollers
argument_list|()
operator|->
name|remove
argument_list|(
name|d
operator|->
name|target
argument_list|)
expr_stmt|;
name|qt_activeScrollers
argument_list|()
operator|->
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QScroller::stateChanged(QScroller::State newState);      QScroller emits this signal whenever the state changes. \a newState is the new State.      \sa state */
end_comment
begin_comment
comment|/*!     \property QScroller::state     \brief the state of the scroller      \sa QScroller::State */
end_comment
begin_function
DECL|function|state
name|QScroller
operator|::
name|State
name|QScroller
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     Stops the scroller and resets its state back to Inactive. */
end_comment
begin_function
DECL|function|stop
name|void
name|QScroller
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|Inactive
condition|)
block|{
name|QPointF
name|here
init|=
name|clampToRect
argument_list|(
name|d
operator|->
name|contentPosition
argument_list|,
name|d
operator|->
name|contentPosRange
argument_list|)
decl_stmt|;
name|qreal
name|snapX
init|=
name|d
operator|->
name|nextSnapPos
argument_list|(
name|here
operator|.
name|x
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
decl_stmt|;
name|qreal
name|snapY
init|=
name|d
operator|->
name|nextSnapPos
argument_list|(
name|here
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
decl_stmt|;
name|QPointF
name|snap
init|=
name|here
decl_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|snapX
argument_list|)
condition|)
name|snap
operator|.
name|setX
argument_list|(
name|snapX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|snapY
argument_list|)
condition|)
name|snap
operator|.
name|setY
argument_list|(
name|snapY
argument_list|)
expr_stmt|;
name|d
operator|->
name|contentPosition
operator|=
name|snap
expr_stmt|;
name|d
operator|->
name|overshootPosition
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Inactive
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the pixel per meter metric for the scrolled widget.      The value is reported for both the x and y axis separately by using a QPointF.      \note Please note that this value should be physically correct. The actual DPI settings     that Qt returns for the display may be reported wrongly on purpose by the underlying     windowing system, for example on Mac OS X. */
end_comment
begin_function
DECL|function|pixelPerMeter
name|QPointF
name|QScroller
operator|::
name|pixelPerMeter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
name|QPointF
name|ppm
init|=
name|d
operator|->
name|pixelPerMeter
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|target
argument_list|)
condition|)
block|{
name|QTransform
name|viewtr
decl_stmt|;
comment|//TODO: the first view isn't really correct - maybe use an additional field in the prepare event?
if|if
condition|(
name|go
operator|->
name|scene
argument_list|()
operator|&&
operator|!
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|viewtr
operator|=
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|first
argument_list|()
operator|->
name|viewportTransform
argument_list|()
expr_stmt|;
name|QTransform
name|tr
init|=
name|go
operator|->
name|deviceTransform
argument_list|(
name|viewtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|tr
operator|.
name|isScaling
argument_list|()
condition|)
block|{
name|QPointF
name|p0
init|=
name|tr
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|px
init|=
name|tr
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|py
init|=
name|tr
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ppm
operator|.
name|rx
argument_list|()
operator|/=
name|QLineF
argument_list|(
name|p0
argument_list|,
name|px
argument_list|)
operator|.
name|length
argument_list|()
expr_stmt|;
name|ppm
operator|.
name|ry
argument_list|()
operator|/=
name|QLineF
argument_list|(
name|p0
argument_list|,
name|py
argument_list|)
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_GRAPHICSVIEW
return|return
name|ppm
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current scrolling velocity in meter per second when the state is Scrolling or Dragging.     Returns a zero velocity otherwise.      The velocity is reported for both the x and y axis separately by using a QPointF.      \sa pixelPerMeter() */
end_comment
begin_function
DECL|function|velocity
name|QPointF
name|QScroller
operator|::
name|velocity
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|d
operator|->
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|state
argument_list|()
condition|)
block|{
case|case
name|Dragging
case|:
return|return
name|d
operator|->
name|releaseVelocity
return|;
case|case
name|Scrolling
case|:
block|{
name|QPointF
name|vel
decl_stmt|;
name|qint64
name|now
init|=
name|d
operator|->
name|monotonicTimer
operator|.
name|elapsed
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|xSegments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QScrollerPrivate
operator|::
name|ScrollSegment
modifier|&
name|s
init|=
name|d
operator|->
name|xSegments
operator|.
name|head
argument_list|()
decl_stmt|;
name|qreal
name|progress
init|=
name|qreal
argument_list|(
name|now
operator|-
name|s
operator|.
name|startTime
argument_list|)
operator|/
name|qreal
argument_list|(
name|s
operator|.
name|deltaTime
argument_list|)
decl_stmt|;
name|qreal
name|v
init|=
name|qSign
argument_list|(
name|s
operator|.
name|deltaPos
argument_list|)
operator|*
name|qreal
argument_list|(
name|s
operator|.
name|deltaTime
argument_list|)
operator|/
name|qreal
argument_list|(
literal|1000
argument_list|)
operator|*
name|sp
operator|->
name|decelerationFactor
operator|*
name|qreal
argument_list|(
literal|0.5
argument_list|)
operator|*
name|differentialForProgress
argument_list|(
name|s
operator|.
name|curve
argument_list|,
name|progress
argument_list|)
decl_stmt|;
name|vel
operator|.
name|setX
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|ySegments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QScrollerPrivate
operator|::
name|ScrollSegment
modifier|&
name|s
init|=
name|d
operator|->
name|ySegments
operator|.
name|head
argument_list|()
decl_stmt|;
name|qreal
name|progress
init|=
name|qreal
argument_list|(
name|now
operator|-
name|s
operator|.
name|startTime
argument_list|)
operator|/
name|qreal
argument_list|(
name|s
operator|.
name|deltaTime
argument_list|)
decl_stmt|;
name|qreal
name|v
init|=
name|qSign
argument_list|(
name|s
operator|.
name|deltaPos
argument_list|)
operator|*
name|qreal
argument_list|(
name|s
operator|.
name|deltaTime
argument_list|)
operator|/
name|qreal
argument_list|(
literal|1000
argument_list|)
operator|*
name|sp
operator|->
name|decelerationFactor
operator|*
name|qreal
argument_list|(
literal|0.5
argument_list|)
operator|*
name|differentialForProgress
argument_list|(
name|s
operator|.
name|curve
argument_list|,
name|progress
argument_list|)
decl_stmt|;
name|vel
operator|.
name|setY
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|vel
return|;
block|}
default|default:
return|return
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the estimated final position for the current scroll movement.     Returns the current position if the scroller state is not Scrolling.     The result is undefined when the scroller state is Inactive.      The target position is in pixel.      \sa pixelPerMeter(), scrollTo() */
end_comment
begin_function
DECL|function|finalPosition
name|QPointF
name|QScroller
operator|::
name|finalPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QScroller
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|d
operator|->
name|scrollingSegmentsEndPos
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
argument_list|,
name|d
operator|->
name|scrollingSegmentsEndPos
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Starts scrolling the widget so that point \a pos is at the top-left position in     the viewport.      The behaviour when scrolling outside the valid scroll area is undefined.     In this case the scroller might or might not overshoot.      The scrolling speed will be calculated so that the given position will     be reached after a platform-defined time span.      \a pos is given in viewport coordinates.      \sa ensureVisible() */
end_comment
begin_function
DECL|function|scrollTo
name|void
name|QScroller
operator|::
name|scrollTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
block|{
comment|// we could make this adjustable via QScrollerProperties
name|scrollTo
argument_list|(
name|pos
argument_list|,
literal|300
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \overload      This version will reach its destination position in \a scrollTime milliseconds. */
end_comment
begin_function
DECL|function|scrollTo
name|void
name|QScroller
operator|::
name|scrollTo
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|int
name|scrollTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Pressed
operator|||
name|d
operator|->
name|state
operator|==
name|Dragging
condition|)
return|return;
comment|// no need to resend a prepare event if we are already scrolling
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Inactive
operator|&&
operator|!
name|d
operator|->
name|prepareScrolling
argument_list|(
name|QPointF
argument_list|()
argument_list|)
condition|)
return|return;
name|QPointF
name|newpos
init|=
name|clampToRect
argument_list|(
name|pos
argument_list|,
name|d
operator|->
name|contentPosRange
argument_list|)
decl_stmt|;
name|qreal
name|snapX
init|=
name|d
operator|->
name|nextSnapPos
argument_list|(
name|newpos
operator|.
name|x
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
decl_stmt|;
name|qreal
name|snapY
init|=
name|d
operator|->
name|nextSnapPos
argument_list|(
name|newpos
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|snapX
argument_list|)
condition|)
name|newpos
operator|.
name|setX
argument_list|(
name|snapX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|snapY
argument_list|)
condition|)
name|newpos
operator|.
name|setY
argument_list|(
name|snapY
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::scrollTo(req:"
operator|<<
name|pos
operator|<<
literal|" [pix] / snap:"
operator|<<
name|newpos
operator|<<
literal|", "
operator|<<
name|scrollTime
operator|<<
literal|" [ms])"
expr_stmt|;
if|if
condition|(
name|newpos
operator|==
name|d
operator|->
name|contentPosition
operator|+
name|d
operator|->
name|overshootPosition
condition|)
return|return;
name|QPointF
name|vel
init|=
name|velocity
argument_list|()
decl_stmt|;
if|if
condition|(
name|scrollTime
operator|<
literal|0
condition|)
name|scrollTime
operator|=
literal|0
expr_stmt|;
name|qreal
name|time
init|=
name|qreal
argument_list|(
name|scrollTime
argument_list|)
operator|/
literal|1000
decl_stmt|;
name|d
operator|->
name|createScrollToSegments
argument_list|(
name|vel
operator|.
name|x
argument_list|()
argument_list|,
name|time
argument_list|,
name|newpos
operator|.
name|x
argument_list|()
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
name|QScrollerPrivate
operator|::
name|ScrollTypeScrollTo
argument_list|)
expr_stmt|;
name|d
operator|->
name|createScrollToSegments
argument_list|(
name|vel
operator|.
name|y
argument_list|()
argument_list|,
name|time
argument_list|,
name|newpos
operator|.
name|y
argument_list|()
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
name|QScrollerPrivate
operator|::
name|ScrollTypeScrollTo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scrollTime
condition|)
name|d
operator|->
name|setContentPositionHelperScrolling
argument_list|()
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|scrollTime
condition|?
name|Scrolling
else|:
name|Inactive
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts scrolling so that the rectangle \a rect is visible inside the     viewport with additional margins specified in pixels by \a xmargin and \a ymargin around     the rect.      In cases where it is not possible to fit the rect plus margins inside the viewport the contents     are scrolled so that as much as possible is visible from \a rect.      The scrolling speed is calculated so that the given position is reached after a platform-defined     time span.      This function performs the actual scrolling by calling scrollTo().      \sa scrollTo() */
end_comment
begin_function
DECL|function|ensureVisible
name|void
name|QScroller
operator|::
name|ensureVisible
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xmargin
parameter_list|,
name|qreal
name|ymargin
parameter_list|)
block|{
comment|// we could make this adjustable via QScrollerProperties
name|ensureVisible
argument_list|(
name|rect
argument_list|,
name|xmargin
argument_list|,
name|ymargin
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \overload      This version will reach its destination position in \a scrollTime milliseconds. */
end_comment
begin_function
DECL|function|ensureVisible
name|void
name|QScroller
operator|::
name|ensureVisible
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xmargin
parameter_list|,
name|qreal
name|ymargin
parameter_list|,
name|int
name|scrollTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Pressed
operator|||
name|d
operator|->
name|state
operator|==
name|Dragging
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Inactive
operator|&&
operator|!
name|d
operator|->
name|prepareScrolling
argument_list|(
name|QPointF
argument_list|()
argument_list|)
condition|)
return|return;
comment|// -- calculate the current pos (or the position after the current scroll)
name|QPointF
name|startPos
init|=
name|d
operator|->
name|contentPosition
operator|+
name|d
operator|->
name|overshootPosition
decl_stmt|;
name|startPos
operator|=
name|QPointF
argument_list|(
name|d
operator|->
name|scrollingSegmentsEndPos
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
argument_list|,
name|d
operator|->
name|scrollingSegmentsEndPos
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
argument_list|)
expr_stmt|;
name|QRectF
name|marginRect
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|-
name|xmargin
argument_list|,
name|rect
operator|.
name|y
argument_list|()
operator|-
name|ymargin
argument_list|,
name|rect
operator|.
name|width
argument_list|()
operator|+
literal|2
operator|*
name|xmargin
argument_list|,
name|rect
operator|.
name|height
argument_list|()
operator|+
literal|2
operator|*
name|ymargin
argument_list|)
decl_stmt|;
name|QSizeF
name|visible
init|=
name|d
operator|->
name|viewportSize
decl_stmt|;
name|QRectF
name|visibleRect
argument_list|(
name|startPos
argument_list|,
name|visible
argument_list|)
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::ensureVisible("
operator|<<
name|rect
operator|<<
literal|" [pix], "
operator|<<
name|xmargin
operator|<<
literal|" [pix], "
operator|<<
name|ymargin
operator|<<
literal|" [pix], "
operator|<<
name|scrollTime
operator|<<
literal|"[ms])"
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> content position:"
operator|<<
name|d
operator|->
name|contentPosition
expr_stmt|;
if|if
condition|(
name|visibleRect
operator|.
name|contains
argument_list|(
name|marginRect
argument_list|)
condition|)
return|return;
name|QPointF
name|newPos
init|=
name|startPos
decl_stmt|;
if|if
condition|(
name|visibleRect
operator|.
name|width
argument_list|()
operator|<
name|rect
operator|.
name|width
argument_list|()
condition|)
block|{
comment|// at least try to move the rect into view
if|if
condition|(
name|rect
operator|.
name|left
argument_list|()
operator|>
name|visibleRect
operator|.
name|left
argument_list|()
condition|)
name|newPos
operator|.
name|setX
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rect
operator|.
name|right
argument_list|()
operator|<
name|visibleRect
operator|.
name|right
argument_list|()
condition|)
name|newPos
operator|.
name|setX
argument_list|(
name|rect
operator|.
name|right
argument_list|()
operator|-
name|visible
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visibleRect
operator|.
name|width
argument_list|()
operator|<
name|marginRect
operator|.
name|width
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setX
argument_list|(
name|rect
operator|.
name|center
argument_list|()
operator|.
name|x
argument_list|()
operator|-
name|visibleRect
operator|.
name|width
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marginRect
operator|.
name|left
argument_list|()
operator|>
name|visibleRect
operator|.
name|left
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setX
argument_list|(
name|marginRect
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marginRect
operator|.
name|right
argument_list|()
operator|<
name|visibleRect
operator|.
name|right
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setX
argument_list|(
name|marginRect
operator|.
name|right
argument_list|()
operator|-
name|visible
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visibleRect
operator|.
name|height
argument_list|()
operator|<
name|rect
operator|.
name|height
argument_list|()
condition|)
block|{
comment|// at least try to move the rect into view
if|if
condition|(
name|rect
operator|.
name|top
argument_list|()
operator|>
name|visibleRect
operator|.
name|top
argument_list|()
condition|)
name|newPos
operator|.
name|setX
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rect
operator|.
name|bottom
argument_list|()
operator|<
name|visibleRect
operator|.
name|bottom
argument_list|()
condition|)
name|newPos
operator|.
name|setX
argument_list|(
name|rect
operator|.
name|bottom
argument_list|()
operator|-
name|visible
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visibleRect
operator|.
name|height
argument_list|()
operator|<
name|marginRect
operator|.
name|height
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setY
argument_list|(
name|rect
operator|.
name|center
argument_list|()
operator|.
name|y
argument_list|()
operator|-
name|visibleRect
operator|.
name|height
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marginRect
operator|.
name|top
argument_list|()
operator|>
name|visibleRect
operator|.
name|top
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setY
argument_list|(
name|marginRect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marginRect
operator|.
name|bottom
argument_list|()
operator|<
name|visibleRect
operator|.
name|bottom
argument_list|()
condition|)
block|{
name|newPos
operator|.
name|setY
argument_list|(
name|marginRect
operator|.
name|bottom
argument_list|()
operator|-
name|visible
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// clamp to maximum content position
name|newPos
operator|=
name|clampToRect
argument_list|(
name|newPos
argument_list|,
name|d
operator|->
name|contentPosRange
argument_list|)
expr_stmt|;
if|if
condition|(
name|newPos
operator|==
name|startPos
condition|)
return|return;
name|scrollTo
argument_list|(
name|newPos
argument_list|,
name|scrollTime
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! This function resends the QScrollPrepareEvent.     Calling resendPrepareEvent triggers a QScrollPrepareEvent from the scroller.     This allows the receiver to re-set content position and content size while     scrolling.     Calling this function while in the Inactive state is useless as the prepare event     is sent again before scrolling starts.  */
end_comment
begin_function
DECL|function|resendPrepareEvent
name|void
name|QScroller
operator|::
name|resendPrepareEvent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|prepareScrolling
argument_list|(
name|d
operator|->
name|pressPosition
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Set the snap positions for the horizontal axis to a list of \a positions.     This overwrites all previously set snap positions and also a previously     set snapping interval.     Snapping can be deactivated by setting an empty list of positions.  */
end_comment
begin_function
DECL|function|setSnapPositionsX
name|void
name|QScroller
operator|::
name|setSnapPositionsX
parameter_list|(
specifier|const
name|QList
argument_list|<
name|qreal
argument_list|>
modifier|&
name|positions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|snapPositionsX
operator|=
name|positions
expr_stmt|;
name|d
operator|->
name|snapIntervalX
operator|=
literal|0.0
expr_stmt|;
name|d
operator|->
name|recalcScrollingSegments
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Set the snap positions for the horizontal axis to regular spaced intervals.     The first snap position is at \a first. The next at \a first + \a interval.     This can be used to implement a list header.     This overwrites all previously set snap positions and also a previously     set snapping interval.     Snapping can be deactivated by setting an interval of 0.0  */
end_comment
begin_function
DECL|function|setSnapPositionsX
name|void
name|QScroller
operator|::
name|setSnapPositionsX
parameter_list|(
name|qreal
name|first
parameter_list|,
name|qreal
name|interval
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|snapFirstX
operator|=
name|first
expr_stmt|;
name|d
operator|->
name|snapIntervalX
operator|=
name|interval
expr_stmt|;
name|d
operator|->
name|snapPositionsX
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|recalcScrollingSegments
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Set the snap positions for the vertical axis to a list of \a positions.     This overwrites all previously set snap positions and also a previously     set snapping interval.     Snapping can be deactivated by setting an empty list of positions.  */
end_comment
begin_function
DECL|function|setSnapPositionsY
name|void
name|QScroller
operator|::
name|setSnapPositionsY
parameter_list|(
specifier|const
name|QList
argument_list|<
name|qreal
argument_list|>
modifier|&
name|positions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|snapPositionsY
operator|=
name|positions
expr_stmt|;
name|d
operator|->
name|snapIntervalY
operator|=
literal|0.0
expr_stmt|;
name|d
operator|->
name|recalcScrollingSegments
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Set the snap positions for the vertical axis to regular spaced intervals.     The first snap position is at \a first. The next at \a first + \a interval.     This overwrites all previously set snap positions and also a previously     set snapping interval.     Snapping can be deactivated by setting an interval of 0.0  */
end_comment
begin_function
DECL|function|setSnapPositionsY
name|void
name|QScroller
operator|::
name|setSnapPositionsY
parameter_list|(
name|qreal
name|first
parameter_list|,
name|qreal
name|interval
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|d
operator|->
name|snapFirstY
operator|=
name|first
expr_stmt|;
name|d
operator|->
name|snapIntervalY
operator|=
name|interval
expr_stmt|;
name|d
operator|->
name|snapPositionsY
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|recalcScrollingSegments
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// -------------- private ------------
end_comment
begin_constructor
DECL|function|QScrollerPrivate
name|QScrollerPrivate
operator|::
name|QScrollerPrivate
parameter_list|(
name|QScroller
modifier|*
name|q
parameter_list|,
name|QObject
modifier|*
name|_target
parameter_list|)
member_init_list|:
name|target
argument_list|(
name|_target
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
member_init_list|,
name|recognizer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|recognizerType
argument_list|(
name|Qt
operator|::
name|CustomGesture
argument_list|)
endif|#
directive|endif
member_init_list|,
name|state
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
member_init_list|,
name|firstScroll
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|pressTimestamp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastTimestamp
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|snapFirstX
argument_list|(
operator|-
literal|1.0
argument_list|)
member_init_list|,
name|snapIntervalX
argument_list|(
literal|0.0
argument_list|)
member_init_list|,
name|snapFirstY
argument_list|(
operator|-
literal|1.0
argument_list|)
member_init_list|,
name|snapIntervalY
argument_list|(
literal|0.0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
member_init_list|,
name|scrollTimer
argument_list|(
operator|new
name|QScrollTimer
argument_list|(
name|this
argument_list|)
argument_list|)
endif|#
directive|endif
member_init_list|,
name|q_ptr
argument_list|(
name|q
argument_list|)
block|{
name|connect
argument_list|(
name|target
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|targetDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QScrollerPrivate
operator|::
name|init
parameter_list|()
block|{
name|setDpiFromWidget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|monotonicTimer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendEvent
name|void
name|QScrollerPrivate
operator|::
name|sendEvent
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|qt_sendSpontaneousEvent
argument_list|(
name|o
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stateName
specifier|const
name|char
modifier|*
name|QScrollerPrivate
operator|::
name|stateName
parameter_list|(
name|QScroller
operator|::
name|State
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QScroller
operator|::
name|Inactive
case|:
return|return
literal|"inactive"
return|;
case|case
name|QScroller
operator|::
name|Pressed
case|:
return|return
literal|"pressed"
return|;
case|case
name|QScroller
operator|::
name|Dragging
case|:
return|return
literal|"dragging"
return|;
case|case
name|QScroller
operator|::
name|Scrolling
case|:
return|return
literal|"scrolling"
return|;
default|default:
return|return
literal|"(invalid)"
return|;
block|}
block|}
end_function
begin_function
DECL|function|inputName
specifier|const
name|char
modifier|*
name|QScrollerPrivate
operator|::
name|inputName
parameter_list|(
name|QScroller
operator|::
name|Input
name|input
parameter_list|)
block|{
switch|switch
condition|(
name|input
condition|)
block|{
case|case
name|QScroller
operator|::
name|InputPress
case|:
return|return
literal|"press"
return|;
case|case
name|QScroller
operator|::
name|InputMove
case|:
return|return
literal|"move"
return|;
case|case
name|QScroller
operator|::
name|InputRelease
case|:
return|return
literal|"release"
return|;
default|default:
return|return
literal|"(invalid)"
return|;
block|}
block|}
end_function
begin_function
DECL|function|targetDestroyed
name|void
name|QScrollerPrivate
operator|::
name|targetDestroyed
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|scrollTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|delete
name|q_ptr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|timerTick
name|void
name|QScrollerPrivate
operator|::
name|timerTick
parameter_list|()
block|{
struct|struct
name|timerevent
block|{
name|QScroller
operator|::
name|State
name|state
decl_stmt|;
typedef|typedef
name|void
function_decl|(
name|QScrollerPrivate
operator|::
modifier|*
name|timerhandler_t
function_decl|)
parameter_list|()
function_decl|;
name|timerhandler_t
name|handler
decl_stmt|;
block|}
struct|;
name|timerevent
name|timerevents
index|[]
init|=
block|{
block|{
name|QScroller
operator|::
name|Dragging
block|,
operator|&
name|QScrollerPrivate
operator|::
name|timerEventWhileDragging
block|}
block|,
block|{
name|QScroller
operator|::
name|Scrolling
block|,
operator|&
name|QScrollerPrivate
operator|::
name|timerEventWhileScrolling
block|}
block|,     }
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|int
argument_list|(
sizeof|sizeof
argument_list|(
name|timerevents
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|timerevents
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|timerevent
modifier|*
name|te
init|=
name|timerevents
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|te
operator|->
name|state
condition|)
block|{
call|(
name|this
operator|->*
name|te
operator|->
name|handler
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|scrollTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     This function is used by gesture recognizers to inform the scroller about a new input event.     The scroller changes its internal state() according to the input event and its attached     scroller properties. The scroller doesn't distinguish between the kind of input device the     event came from. Therefore the event needs to be split into the \a input type, a \a position and a     milli-second \a timestamp.  The \a position needs to be in the target's coordinate system.      The return value is \c true if the event should be consumed by the calling filter or \c false     if the event should be forwarded to the control.      \note Using grabGesture() should be sufficient for most use cases. */
end_comment
begin_function
DECL|function|handleInput
name|bool
name|QScroller
operator|::
name|handleInput
parameter_list|(
name|Input
name|input
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::handleInput("
operator|<<
name|input
operator|<<
literal|", "
operator|<<
name|d
operator|->
name|stateName
argument_list|(
name|d
operator|->
name|state
argument_list|)
operator|<<
literal|", "
operator|<<
name|position
operator|<<
literal|", "
operator|<<
name|timestamp
operator|<<
literal|")"
expr_stmt|;
struct|struct
name|statechange
block|{
name|State
name|state
decl_stmt|;
name|Input
name|input
decl_stmt|;
typedef|typedef
name|bool
function_decl|(
name|QScrollerPrivate
operator|::
modifier|*
name|inputhandler_t
function_decl|)
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
function_decl|;
name|inputhandler_t
name|handler
decl_stmt|;
block|}
struct|;
name|statechange
name|statechanges
index|[]
init|=
block|{
block|{
name|QScroller
operator|::
name|Inactive
block|,
name|InputPress
block|,
operator|&
name|QScrollerPrivate
operator|::
name|pressWhileInactive
block|}
block|,
block|{
name|QScroller
operator|::
name|Pressed
block|,
name|InputMove
block|,
operator|&
name|QScrollerPrivate
operator|::
name|moveWhilePressed
block|}
block|,
block|{
name|QScroller
operator|::
name|Pressed
block|,
name|InputRelease
block|,
operator|&
name|QScrollerPrivate
operator|::
name|releaseWhilePressed
block|}
block|,
block|{
name|QScroller
operator|::
name|Dragging
block|,
name|InputMove
block|,
operator|&
name|QScrollerPrivate
operator|::
name|moveWhileDragging
block|}
block|,
block|{
name|QScroller
operator|::
name|Dragging
block|,
name|InputRelease
block|,
operator|&
name|QScrollerPrivate
operator|::
name|releaseWhileDragging
block|}
block|,
block|{
name|QScroller
operator|::
name|Scrolling
block|,
name|InputPress
block|,
operator|&
name|QScrollerPrivate
operator|::
name|pressWhileScrolling
block|}
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|int
argument_list|(
sizeof|sizeof
argument_list|(
name|statechanges
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|statechanges
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|statechange
modifier|*
name|sc
init|=
name|statechanges
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|sc
operator|->
name|state
operator|&&
name|input
operator|==
name|sc
operator|->
name|input
condition|)
return|return
call|(
name|d
operator|->*
name|sc
operator|->
name|handler
call|)
argument_list|(
name|position
operator|-
name|d
operator|->
name|overshootPosition
argument_list|,
name|timestamp
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
end_if
begin_comment
comment|// the Mac version is implemented in qscroller_mac.mm
end_comment
begin_function
DECL|function|realDpi
name|QPointF
name|QScrollerPrivate
operator|::
name|realDpi
parameter_list|(
name|int
name|screen
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_XRANDR
argument_list|)
if|if
condition|(
name|X11
operator|&&
name|X11
operator|->
name|use_xrandr
operator|&&
name|X11
operator|->
name|ptrXRRSizes
operator|&&
name|X11
operator|->
name|ptrXRRRootToScreen
condition|)
block|{
name|int
name|nsizes
init|=
literal|0
decl_stmt|;
comment|// QDesktopWidget is based on Xinerama screens, which do not always
comment|// correspond to RandR screens: NVidia's TwinView e.g.  will show up
comment|// as 2 screens in QDesktopWidget, but libXRandR will only see 1 screen.
comment|// (although with the combined size of the Xinerama screens).
comment|// Additionally, libXrandr will simply crash when calling XRRSizes
comment|// for (the non-existent) screen 1 in this scenario.
name|Window
name|root
init|=
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
operator|==
operator|-
literal|1
condition|?
name|X11
operator|->
name|defaultScreen
else|:
name|screen
argument_list|)
decl_stmt|;
name|int
name|randrscreen
init|=
operator|(
name|root
operator|!=
name|XNone
operator|)
condition|?
name|X11
operator|->
name|ptrXRRRootToScreen
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|root
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|XRRScreenSize
modifier|*
name|sizes
init|=
name|X11
operator|->
name|ptrXRRSizes
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|randrscreen
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|randrscreen
argument_list|,
operator|&
name|nsizes
argument_list|)
decl_stmt|;
if|if
condition|(
name|nsizes
operator|>
literal|0
operator|&&
name|sizes
operator|&&
name|sizes
operator|->
name|width
operator|&&
name|sizes
operator|->
name|height
operator|&&
name|sizes
operator|->
name|mwidth
operator|&&
name|sizes
operator|->
name|mheight
condition|)
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"XRandR DPI:"
operator|<<
name|QPointF
argument_list|(
name|qreal
argument_list|(
literal|25.4
argument_list|)
operator|*
name|qreal
argument_list|(
name|sizes
operator|->
name|width
argument_list|)
operator|/
name|qreal
argument_list|(
name|sizes
operator|->
name|mwidth
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|25.4
argument_list|)
operator|*
name|qreal
argument_list|(
name|sizes
operator|->
name|height
argument_list|)
operator|/
name|qreal
argument_list|(
name|sizes
operator|->
name|mheight
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QPointF
argument_list|(
name|qreal
argument_list|(
literal|25.4
argument_list|)
operator|*
name|qreal
argument_list|(
name|sizes
operator|->
name|width
argument_list|)
operator|/
name|qreal
argument_list|(
name|sizes
operator|->
name|mwidth
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|25.4
argument_list|)
operator|*
name|qreal
argument_list|(
name|sizes
operator|->
name|height
argument_list|)
operator|/
name|qreal
argument_list|(
name|sizes
operator|->
name|mheight
argument_list|)
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screen
argument_list|(
name|screen
argument_list|)
decl_stmt|;
return|return
name|QPointF
argument_list|(
name|w
operator|->
name|physicalDpiX
argument_list|()
argument_list|,
name|w
operator|->
name|physicalDpiY
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_WS_MAC
end_comment
begin_comment
comment|/*! \internal     Returns the resolution of the used screen. */
end_comment
begin_function
DECL|function|dpi
name|QPointF
name|QScrollerPrivate
operator|::
name|dpi
parameter_list|()
specifier|const
block|{
return|return
name|pixelPerMeter
operator|*
name|qreal
argument_list|(
literal|0.0254
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Sets the resolution used for scrolling.     This resolution is only used by the kinetic scroller. If you change this     then the scroller will behave quite different as a lot of the values are     given in physical distances (millimeter). */
end_comment
begin_function
DECL|function|setDpi
name|void
name|QScrollerPrivate
operator|::
name|setDpi
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|dpi
parameter_list|)
block|{
name|pixelPerMeter
operator|=
name|dpi
operator|/
name|qreal
argument_list|(
literal|0.0254
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Sets the dpi used for scrolling to the value of the widget. */
end_comment
begin_function
DECL|function|setDpiFromWidget
name|void
name|QScrollerPrivate
operator|::
name|setDpiFromWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QDesktopWidget
modifier|*
name|dw
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
decl_stmt|;
name|setDpi
argument_list|(
name|realDpi
argument_list|(
name|widget
condition|?
name|dw
operator|->
name|screenNumber
argument_list|(
name|widget
argument_list|)
else|:
name|dw
operator|->
name|primaryScreen
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Updates the velocity during dragging.     Sets releaseVelocity. */
end_comment
begin_function
DECL|function|updateVelocity
name|void
name|QScrollerPrivate
operator|::
name|updateVelocity
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|deltaPixelRaw
parameter_list|,
name|qint64
name|deltaTime
parameter_list|)
block|{
if|if
condition|(
name|deltaTime
operator|<=
literal|0
condition|)
return|return;
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|QPointF
name|ppm
init|=
name|q
operator|->
name|pixelPerMeter
argument_list|()
decl_stmt|;
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
name|QPointF
name|deltaPixel
init|=
name|deltaPixelRaw
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::updateVelocity("
operator|<<
name|deltaPixelRaw
operator|<<
literal|" [delta pix], "
operator|<<
name|deltaTime
operator|<<
literal|" [delta ms])"
expr_stmt|;
comment|// faster than 2.5mm/ms seems bogus (that would be a screen height in ~20 ms)
if|if
condition|(
operator|(
operator|(
name|deltaPixelRaw
operator|/
name|qreal
argument_list|(
name|deltaTime
argument_list|)
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|/
operator|(
operator|(
name|ppm
operator|.
name|x
argument_list|()
operator|+
name|ppm
operator|.
name|y
argument_list|()
operator|)
operator|/
literal|2
operator|)
operator|*
literal|1000
operator|)
operator|>
name|qreal
argument_list|(
literal|2.5
argument_list|)
condition|)
name|deltaPixel
operator|=
name|deltaPixelRaw
operator|*
name|qreal
argument_list|(
literal|2.5
argument_list|)
operator|*
name|ppm
operator|/
literal|1000
operator|/
operator|(
name|deltaPixelRaw
operator|/
name|qreal
argument_list|(
name|deltaTime
argument_list|)
operator|)
operator|.
name|manhattanLength
argument_list|()
expr_stmt|;
name|QPointF
name|newv
init|=
operator|-
name|deltaPixel
operator|/
name|qreal
argument_list|(
name|deltaTime
argument_list|)
operator|*
name|qreal
argument_list|(
literal|1000
argument_list|)
operator|/
name|ppm
decl_stmt|;
comment|// around 95% of all updates are in the [1..50] ms range, so make sure
comment|// to scale the smoothing factor over that range: this way a 50ms update
comment|// will have full impact, while 5ms update will only have a 10% impact.
name|qreal
name|smoothing
init|=
name|sp
operator|->
name|dragVelocitySmoothingFactor
operator|*
name|qMin
argument_list|(
name|qreal
argument_list|(
name|deltaTime
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|50
argument_list|)
argument_list|)
operator|/
name|qreal
argument_list|(
literal|50
argument_list|)
decl_stmt|;
comment|// only smooth if we already have a release velocity and only if the
comment|// user hasn't stopped to move his finger for more than 100ms
if|if
condition|(
operator|(
name|releaseVelocity
operator|!=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|deltaTime
operator|<
literal|100
operator|)
condition|)
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"SMOOTHED from "
operator|<<
name|newv
operator|<<
literal|" to "
operator|<<
name|newv
operator|*
name|smoothing
operator|+
name|releaseVelocity
operator|*
operator|(
name|qreal
argument_list|(
literal|1
argument_list|)
operator|-
name|smoothing
operator|)
expr_stmt|;
comment|// smooth x or y only if the new velocity is either 0 or at least in
comment|// the same direction of the release velocity
if|if
condition|(
operator|!
name|newv
operator|.
name|x
argument_list|()
operator|||
operator|(
name|qSign
argument_list|(
name|releaseVelocity
operator|.
name|x
argument_list|()
argument_list|)
operator|==
name|qSign
argument_list|(
name|newv
operator|.
name|x
argument_list|()
argument_list|)
operator|)
condition|)
name|newv
operator|.
name|setX
argument_list|(
name|newv
operator|.
name|x
argument_list|()
operator|*
name|smoothing
operator|+
name|releaseVelocity
operator|.
name|x
argument_list|()
operator|*
operator|(
name|qreal
argument_list|(
literal|1
argument_list|)
operator|-
name|smoothing
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newv
operator|.
name|y
argument_list|()
operator|||
operator|(
name|qSign
argument_list|(
name|releaseVelocity
operator|.
name|y
argument_list|()
argument_list|)
operator|==
name|qSign
argument_list|(
name|newv
operator|.
name|y
argument_list|()
argument_list|)
operator|)
condition|)
name|newv
operator|.
name|setY
argument_list|(
name|newv
operator|.
name|y
argument_list|()
operator|*
name|smoothing
operator|+
name|releaseVelocity
operator|.
name|y
argument_list|()
operator|*
operator|(
name|qreal
argument_list|(
literal|1
argument_list|)
operator|-
name|smoothing
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|qScrollerDebug
argument_list|()
operator|<<
literal|"NO SMOOTHING to "
operator|<<
name|newv
expr_stmt|;
name|releaseVelocity
operator|.
name|setX
argument_list|(
name|qBound
argument_list|(
operator|-
name|sp
operator|->
name|maximumVelocity
argument_list|,
name|newv
operator|.
name|x
argument_list|()
argument_list|,
name|sp
operator|->
name|maximumVelocity
argument_list|)
argument_list|)
expr_stmt|;
name|releaseVelocity
operator|.
name|setY
argument_list|(
name|qBound
argument_list|(
operator|-
name|sp
operator|->
name|maximumVelocity
argument_list|,
name|newv
operator|.
name|y
argument_list|()
argument_list|,
name|sp
operator|->
name|maximumVelocity
argument_list|)
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> new velocity:"
operator|<<
name|releaseVelocity
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pushSegment
name|void
name|QScrollerPrivate
operator|::
name|pushSegment
parameter_list|(
name|ScrollType
name|type
parameter_list|,
name|qreal
name|deltaTime
parameter_list|,
name|qreal
name|stopProgress
parameter_list|,
name|qreal
name|startPos
parameter_list|,
name|qreal
name|deltaPos
parameter_list|,
name|qreal
name|stopPos
parameter_list|,
name|QEasingCurve
operator|::
name|Type
name|curve
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
if|if
condition|(
name|startPos
operator|==
name|stopPos
operator|||
name|deltaPos
operator|==
literal|0
condition|)
return|return;
name|ScrollSegment
name|s
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|&&
operator|!
name|xSegments
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|.
name|startTime
operator|=
name|xSegments
operator|.
name|last
argument_list|()
operator|.
name|startTime
operator|+
name|xSegments
operator|.
name|last
argument_list|()
operator|.
name|deltaTime
operator|*
name|xSegments
operator|.
name|last
argument_list|()
operator|.
name|stopProgress
expr_stmt|;
elseif|else
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
operator|&&
operator|!
name|ySegments
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|.
name|startTime
operator|=
name|ySegments
operator|.
name|last
argument_list|()
operator|.
name|startTime
operator|+
name|ySegments
operator|.
name|last
argument_list|()
operator|.
name|deltaTime
operator|*
name|ySegments
operator|.
name|last
argument_list|()
operator|.
name|stopProgress
expr_stmt|;
else|else
name|s
operator|.
name|startTime
operator|=
name|monotonicTimer
operator|.
name|elapsed
argument_list|()
expr_stmt|;
name|s
operator|.
name|startPos
operator|=
name|startPos
expr_stmt|;
name|s
operator|.
name|deltaPos
operator|=
name|deltaPos
expr_stmt|;
name|s
operator|.
name|stopPos
operator|=
name|stopPos
expr_stmt|;
name|s
operator|.
name|deltaTime
operator|=
name|deltaTime
operator|*
literal|1000
expr_stmt|;
name|s
operator|.
name|stopProgress
operator|=
name|stopProgress
expr_stmt|;
name|s
operator|.
name|curve
operator|.
name|setType
argument_list|(
name|curve
argument_list|)
expr_stmt|;
name|s
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|xSegments
operator|.
name|enqueue
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|ySegments
operator|.
name|enqueue
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"+++ Added a new ScrollSegment: "
operator|<<
name|s
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Clears the old segments and recalculates them if the current segments are not longer valid */
end_comment
begin_function
DECL|function|recalcScrollingSegments
name|void
name|QScrollerPrivate
operator|::
name|recalcScrollingSegments
parameter_list|(
name|bool
name|forceRecalc
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|QPointF
name|ppm
init|=
name|q
operator|->
name|pixelPerMeter
argument_list|()
decl_stmt|;
name|releaseVelocity
operator|=
name|q
operator|->
name|velocity
argument_list|()
expr_stmt|;
if|if
condition|(
name|forceRecalc
operator|||
operator|!
name|scrollingSegmentsValid
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|||
operator|!
name|scrollingSegmentsValid
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
condition|)
name|createScrollingSegments
argument_list|(
name|releaseVelocity
argument_list|,
name|contentPosition
operator|+
name|overshootPosition
argument_list|,
name|ppm
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the end position after the current scroll has finished. */
end_comment
begin_function
DECL|function|scrollingSegmentsEndPos
name|qreal
name|QScrollerPrivate
operator|::
name|scrollingSegmentsEndPos
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
name|xSegments
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|contentPosition
operator|.
name|x
argument_list|()
operator|+
name|overshootPosition
operator|.
name|x
argument_list|()
return|;
else|else
return|return
name|xSegments
operator|.
name|last
argument_list|()
operator|.
name|stopPos
return|;
block|}
else|else
block|{
if|if
condition|(
name|ySegments
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|contentPosition
operator|.
name|y
argument_list|()
operator|+
name|overshootPosition
operator|.
name|y
argument_list|()
return|;
else|else
return|return
name|ySegments
operator|.
name|last
argument_list|()
operator|.
name|stopPos
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal     Checks if the scroller segment end in a valid position. */
end_comment
begin_function
DECL|function|scrollingSegmentsValid
name|bool
name|QScrollerPrivate
operator|::
name|scrollingSegmentsValid
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|QQueue
argument_list|<
name|ScrollSegment
argument_list|>
modifier|*
name|segments
decl_stmt|;
name|qreal
name|minPos
decl_stmt|;
name|qreal
name|maxPos
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|segments
operator|=
operator|&
name|xSegments
expr_stmt|;
name|minPos
operator|=
name|contentPosRange
operator|.
name|left
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|right
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|segments
operator|=
operator|&
name|ySegments
expr_stmt|;
name|minPos
operator|=
name|contentPosRange
operator|.
name|top
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|bottom
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|segments
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
specifier|const
name|ScrollSegment
modifier|&
name|last
init|=
name|segments
operator|->
name|last
argument_list|()
decl_stmt|;
name|qreal
name|stopPos
init|=
name|last
operator|.
name|stopPos
decl_stmt|;
if|if
condition|(
name|last
operator|.
name|type
operator|==
name|ScrollTypeScrollTo
condition|)
return|return
literal|true
return|;
comment|// scrollTo is always valid
if|if
condition|(
name|last
operator|.
name|type
operator|==
name|ScrollTypeOvershoot
operator|&&
operator|(
name|stopPos
operator|!=
name|minPos
operator|&&
name|stopPos
operator|!=
name|maxPos
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|stopPos
argument_list|<
name|minPos
operator|||
name|stopPos
argument_list|>
name|maxPos
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|stopPos
operator|==
name|minPos
operator|||
name|stopPos
operator|==
name|maxPos
condition|)
comment|// the begin and the end of the list are always ok
return|return
literal|true
return|;
name|qreal
name|nextSnap
init|=
name|nextSnapPos
argument_list|(
name|stopPos
argument_list|,
literal|0
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qIsNaN
argument_list|(
name|nextSnap
argument_list|)
operator|&&
name|stopPos
operator|!=
name|nextSnap
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal    Creates the sections needed to scroll to the specific \a endPos to the segments queue. */
end_comment
begin_function
DECL|function|createScrollToSegments
name|void
name|QScrollerPrivate
operator|::
name|createScrollToSegments
parameter_list|(
name|qreal
name|v
parameter_list|,
name|qreal
name|deltaTime
parameter_list|,
name|qreal
name|endPos
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|ScrollType
name|type
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|xSegments
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|ySegments
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"+++ createScrollToSegments: t:"
operator|<<
name|deltaTime
operator|<<
literal|"ep:"
operator|<<
name|endPos
operator|<<
literal|"o:"
operator|<<
name|int
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
name|qreal
name|startPos
init|=
operator|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|)
condition|?
name|contentPosition
operator|.
name|x
argument_list|()
operator|+
name|overshootPosition
operator|.
name|x
argument_list|()
else|:
name|contentPosition
operator|.
name|y
argument_list|()
operator|+
name|overshootPosition
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|deltaPos
init|=
operator|(
name|endPos
operator|-
name|startPos
operator|)
operator|/
literal|2
decl_stmt|;
name|pushSegment
argument_list|(
name|type
argument_list|,
name|deltaTime
operator|*
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|startPos
argument_list|,
name|deltaPos
argument_list|,
name|startPos
operator|+
name|deltaPos
argument_list|,
name|QEasingCurve
operator|::
name|InQuad
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
name|pushSegment
argument_list|(
name|type
argument_list|,
name|deltaTime
operator|*
name|qreal
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|startPos
operator|+
name|deltaPos
argument_list|,
name|deltaPos
argument_list|,
name|endPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|createScrollingSegments
name|void
name|QScrollerPrivate
operator|::
name|createScrollingSegments
parameter_list|(
name|qreal
name|v
parameter_list|,
name|qreal
name|startPos
parameter_list|,
name|qreal
name|deltaTime
parameter_list|,
name|qreal
name|deltaPos
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
name|QScrollerProperties
operator|::
name|OvershootPolicy
name|policy
decl_stmt|;
name|qreal
name|minPos
decl_stmt|;
name|qreal
name|maxPos
decl_stmt|;
name|qreal
name|viewSize
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|xSegments
operator|.
name|clear
argument_list|()
expr_stmt|;
name|policy
operator|=
name|sp
operator|->
name|hOvershootPolicy
expr_stmt|;
name|minPos
operator|=
name|contentPosRange
operator|.
name|left
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|right
argument_list|()
expr_stmt|;
name|viewSize
operator|=
name|viewportSize
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ySegments
operator|.
name|clear
argument_list|()
expr_stmt|;
name|policy
operator|=
name|sp
operator|->
name|vOvershootPolicy
expr_stmt|;
name|minPos
operator|=
name|contentPosRange
operator|.
name|top
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|bottom
argument_list|()
expr_stmt|;
name|viewSize
operator|=
name|viewportSize
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
name|bool
name|alwaysOvershoot
init|=
operator|(
name|policy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
decl_stmt|;
name|bool
name|noOvershoot
init|=
operator|(
name|policy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOff
operator|)
operator|||
operator|!
name|sp
operator|->
name|overshootScrollDistanceFactor
decl_stmt|;
name|bool
name|canOvershoot
init|=
operator|!
name|noOvershoot
operator|&&
operator|(
name|alwaysOvershoot
operator|||
name|maxPos
operator|)
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"+++ createScrollingSegments: s:"
operator|<<
name|startPos
operator|<<
literal|"maxPos:"
operator|<<
name|maxPos
operator|<<
literal|"o:"
operator|<<
name|int
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"v = "
operator|<<
name|v
operator|<<
literal|", decelerationFactor = "
operator|<<
name|sp
operator|->
name|decelerationFactor
operator|<<
literal|", curveType = "
operator|<<
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
expr_stmt|;
name|qreal
name|endPos
init|=
name|startPos
operator|+
name|deltaPos
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  Real Delta:"
operator|<<
name|deltaPos
expr_stmt|;
comment|// -- check if are in overshoot and end in overshoot
if|if
condition|(
operator|(
name|startPos
operator|<
name|minPos
operator|&&
name|endPos
operator|<
name|minPos
operator|)
operator|||
operator|(
name|startPos
operator|>
name|maxPos
operator|&&
name|endPos
operator|>
name|maxPos
operator|)
condition|)
block|{
name|qreal
name|stopPos
init|=
name|endPos
operator|<
name|minPos
condition|?
name|minPos
else|:
name|maxPos
decl_stmt|;
name|qreal
name|oDeltaTime
init|=
name|sp
operator|->
name|overshootScrollTime
decl_stmt|;
name|pushSegment
argument_list|(
name|ScrollTypeOvershoot
argument_list|,
name|oDeltaTime
operator|*
name|qreal
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|startPos
argument_list|,
name|stopPos
operator|-
name|startPos
argument_list|,
name|stopPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// -- determine snap points
name|qreal
name|nextSnap
init|=
name|nextSnapPos
argument_list|(
name|endPos
argument_list|,
literal|0
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
name|qreal
name|lowerSnapPos
init|=
name|nextSnapPos
argument_list|(
name|startPos
argument_list|,
operator|-
literal|1
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
name|qreal
name|higherSnapPos
init|=
name|nextSnapPos
argument_list|(
name|startPos
argument_list|,
literal|1
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  Real Delta:"
operator|<<
name|lowerSnapPos
operator|<<
literal|"-"
operator|<<
name|nextSnap
operator|<<
literal|"-"
operator|<<
name|higherSnapPos
expr_stmt|;
comment|// - check if we can reach another snap point
if|if
condition|(
name|nextSnap
operator|>
name|higherSnapPos
operator|||
name|qIsNaN
argument_list|(
name|higherSnapPos
argument_list|)
condition|)
name|higherSnapPos
operator|=
name|nextSnap
expr_stmt|;
if|if
condition|(
name|nextSnap
operator|<
name|lowerSnapPos
operator|||
name|qIsNaN
argument_list|(
name|lowerSnapPos
argument_list|)
condition|)
name|lowerSnapPos
operator|=
name|nextSnap
expr_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|v
argument_list|)
operator|<
name|sp
operator|->
name|minimumVelocity
condition|)
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"### below minimum Vel"
operator|<<
name|orientation
expr_stmt|;
comment|// - no snap points or already at one
if|if
condition|(
name|qIsNaN
argument_list|(
name|nextSnap
argument_list|)
operator|||
name|nextSnap
operator|==
name|startPos
condition|)
return|return;
comment|// nothing to do, no scrolling needed.
comment|// - decide which point to use
name|qreal
name|snapDistance
init|=
name|higherSnapPos
operator|-
name|lowerSnapPos
decl_stmt|;
name|qreal
name|pressDistance
init|=
operator|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|)
condition|?
name|lastPosition
operator|.
name|x
argument_list|()
operator|-
name|pressPosition
operator|.
name|x
argument_list|()
else|:
name|lastPosition
operator|.
name|y
argument_list|()
operator|-
name|pressPosition
operator|.
name|y
argument_list|()
decl_stmt|;
comment|// if not dragged far enough, pick the next snap point.
if|if
condition|(
name|sp
operator|->
name|snapPositionRatio
operator|==
literal|0.0
operator|||
name|qAbs
argument_list|(
name|pressDistance
operator|/
name|sp
operator|->
name|snapPositionRatio
argument_list|)
operator|>
name|snapDistance
condition|)
name|endPos
operator|=
name|nextSnap
expr_stmt|;
elseif|else
if|if
condition|(
name|pressDistance
operator|<
literal|0.0
condition|)
name|endPos
operator|=
name|lowerSnapPos
expr_stmt|;
else|else
name|endPos
operator|=
name|higherSnapPos
expr_stmt|;
name|deltaPos
operator|=
name|endPos
operator|-
name|startPos
expr_stmt|;
name|qreal
name|midPos
init|=
name|startPos
operator|+
name|deltaPos
operator|*
name|qreal
argument_list|(
literal|0.3
argument_list|)
decl_stmt|;
name|pushSegment
argument_list|(
name|ScrollTypeFlick
argument_list|,
name|sp
operator|->
name|snapTime
operator|*
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|startPos
argument_list|,
name|midPos
operator|-
name|startPos
argument_list|,
name|midPos
argument_list|,
name|QEasingCurve
operator|::
name|InQuad
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
name|pushSegment
argument_list|(
name|ScrollTypeFlick
argument_list|,
name|sp
operator|->
name|snapTime
operator|*
name|qreal
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|midPos
argument_list|,
name|endPos
operator|-
name|midPos
argument_list|,
name|endPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// - go to the next snappoint if there is one
if|if
condition|(
name|v
operator|>
literal|0
operator|&&
operator|!
name|qIsNaN
argument_list|(
name|higherSnapPos
argument_list|)
condition|)
block|{
comment|// change the time in relation to the changed end position
if|if
condition|(
name|endPos
operator|-
name|startPos
condition|)
name|deltaTime
operator|*=
name|qAbs
argument_list|(
operator|(
name|higherSnapPos
operator|-
name|startPos
operator|)
operator|/
operator|(
name|endPos
operator|-
name|startPos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaTime
operator|>
name|sp
operator|->
name|snapTime
condition|)
name|deltaTime
operator|=
name|sp
operator|->
name|snapTime
expr_stmt|;
name|endPos
operator|=
name|higherSnapPos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|0
operator|&&
operator|!
name|qIsNaN
argument_list|(
name|lowerSnapPos
argument_list|)
condition|)
block|{
comment|// change the time in relation to the changed end position
if|if
condition|(
name|endPos
operator|-
name|startPos
condition|)
name|deltaTime
operator|*=
name|qAbs
argument_list|(
operator|(
name|lowerSnapPos
operator|-
name|startPos
operator|)
operator|/
operator|(
name|endPos
operator|-
name|startPos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaTime
operator|>
name|sp
operator|->
name|snapTime
condition|)
name|deltaTime
operator|=
name|sp
operator|->
name|snapTime
expr_stmt|;
name|endPos
operator|=
name|lowerSnapPos
expr_stmt|;
comment|// -- check if we are overshooting
block|}
elseif|else
if|if
condition|(
name|endPos
argument_list|<
name|minPos
operator|||
name|endPos
argument_list|>
name|maxPos
condition|)
block|{
name|qreal
name|stopPos
init|=
name|endPos
operator|<
name|minPos
condition|?
name|minPos
else|:
name|maxPos
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"Overshoot: delta:"
operator|<<
operator|(
name|stopPos
operator|-
name|startPos
operator|)
expr_stmt|;
name|qreal
name|stopProgress
init|=
name|progressForValue
argument_list|(
name|sp
operator|->
name|scrollingCurve
argument_list|,
name|qAbs
argument_list|(
operator|(
name|stopPos
operator|-
name|startPos
operator|)
operator|/
name|deltaPos
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|canOvershoot
condition|)
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"Overshoot stopp:"
operator|<<
name|stopProgress
expr_stmt|;
name|pushSegment
argument_list|(
name|ScrollTypeFlick
argument_list|,
name|deltaTime
argument_list|,
name|stopProgress
argument_list|,
name|startPos
argument_list|,
name|endPos
argument_list|,
name|stopPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qreal
name|oDeltaTime
init|=
name|sp
operator|->
name|overshootScrollTime
decl_stmt|;
name|qreal
name|oStopProgress
init|=
name|qMin
argument_list|(
name|stopProgress
operator|+
name|oDeltaTime
operator|*
name|qreal
argument_list|(
literal|0.3
argument_list|)
operator|/
name|deltaTime
argument_list|,
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|oDistance
init|=
name|startPos
operator|+
name|deltaPos
operator|*
name|sp
operator|->
name|scrollingCurve
operator|.
name|valueForProgress
argument_list|(
name|oStopProgress
argument_list|)
operator|-
name|stopPos
decl_stmt|;
name|qreal
name|oMaxDistance
init|=
name|qSign
argument_list|(
name|oDistance
argument_list|)
operator|*
operator|(
name|viewSize
operator|*
name|sp
operator|->
name|overshootScrollDistanceFactor
operator|)
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"1 oDistance:"
operator|<<
name|oDistance
operator|<<
literal|"Max:"
operator|<<
name|oMaxDistance
operator|<<
literal|"stopP/oStopP"
operator|<<
name|stopProgress
operator|<<
name|oStopProgress
expr_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|oDistance
argument_list|)
operator|>
name|qAbs
argument_list|(
name|oMaxDistance
argument_list|)
condition|)
block|{
name|oStopProgress
operator|=
name|progressForValue
argument_list|(
name|sp
operator|->
name|scrollingCurve
argument_list|,
name|qAbs
argument_list|(
operator|(
name|stopPos
operator|+
name|oMaxDistance
operator|-
name|startPos
operator|)
operator|/
name|deltaPos
argument_list|)
argument_list|)
expr_stmt|;
name|oDistance
operator|=
name|oMaxDistance
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"2 oDistance:"
operator|<<
name|oDistance
operator|<<
literal|"Max:"
operator|<<
name|oMaxDistance
operator|<<
literal|"stopP/oStopP"
operator|<<
name|stopProgress
operator|<<
name|oStopProgress
expr_stmt|;
block|}
name|pushSegment
argument_list|(
name|ScrollTypeFlick
argument_list|,
name|deltaTime
argument_list|,
name|oStopProgress
argument_list|,
name|startPos
argument_list|,
name|deltaPos
argument_list|,
name|stopPos
operator|+
name|oDistance
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
name|pushSegment
argument_list|(
name|ScrollTypeOvershoot
argument_list|,
name|oDeltaTime
operator|*
name|qreal
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|stopPos
operator|+
name|oDistance
argument_list|,
operator|-
name|oDistance
argument_list|,
name|stopPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|pushSegment
argument_list|(
name|ScrollTypeFlick
argument_list|,
name|deltaTime
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|startPos
argument_list|,
name|deltaPos
argument_list|,
name|endPos
argument_list|,
name|sp
operator|->
name|scrollingCurve
operator|.
name|type
argument_list|()
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createScrollingSegments
name|void
name|QScrollerPrivate
operator|::
name|createScrollingSegments
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|v
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|startPos
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|ppm
parameter_list|)
block|{
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// This is only correct for QEasingCurve::OutQuad (linear velocity,
comment|// constant deceleration), but the results look and feel ok for OutExpo
comment|// and OutSine as well
comment|// v(t) = deltaTime * a * 0.5 * differentialForProgress(t / deltaTime)
comment|// v(0) = vrelease
comment|// v(deltaTime) = 0
comment|// deltaTime = (2 * vrelease) / (a * differntial(0))
comment|// pos(t) = integrate(v(t)dt)
comment|// pos(t) = vrelease * t - 0.5 * a * t * t
comment|// pos(t) = deltaTime * a * 0.5 * progress(t / deltaTime) * deltaTime
comment|// deltaPos = pos(deltaTime)
name|QVector2D
name|vel
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|qreal
name|deltaTime
init|=
operator|(
name|qreal
argument_list|(
literal|2
argument_list|)
operator|*
name|vel
operator|.
name|length
argument_list|()
operator|)
operator|/
operator|(
name|sp
operator|->
name|decelerationFactor
operator|*
name|differentialForProgress
argument_list|(
name|sp
operator|->
name|scrollingCurve
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
name|QPointF
name|deltaPos
init|=
operator|(
name|vel
operator|.
name|normalized
argument_list|()
operator|*
name|QVector2D
argument_list|(
name|ppm
argument_list|)
operator|)
operator|.
name|toPointF
argument_list|()
operator|*
name|deltaTime
operator|*
name|deltaTime
operator|*
name|qreal
argument_list|(
literal|0.5
argument_list|)
operator|*
name|sp
operator|->
name|decelerationFactor
decl_stmt|;
name|createScrollingSegments
argument_list|(
name|v
operator|.
name|x
argument_list|()
argument_list|,
name|startPos
operator|.
name|x
argument_list|()
argument_list|,
name|deltaTime
argument_list|,
name|deltaPos
operator|.
name|x
argument_list|()
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
name|createScrollingSegments
argument_list|(
name|v
operator|.
name|y
argument_list|()
argument_list|,
name|startPos
operator|.
name|y
argument_list|()
argument_list|,
name|deltaTime
argument_list|,
name|deltaPos
operator|.
name|y
argument_list|()
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Prepares scrolling by sending a QScrollPrepareEvent to the receiver widget.     Returns true if the scrolling was accepted and a target was returned. */
end_comment
begin_function
DECL|function|prepareScrolling
name|bool
name|QScrollerPrivate
operator|::
name|prepareScrolling
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|)
block|{
name|QScrollPrepareEvent
name|spe
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|spe
operator|.
name|ignore
argument_list|()
expr_stmt|;
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|spe
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScrollPrepareEvent returned from"
operator|<<
name|target
operator|<<
literal|"with"
operator|<<
name|spe
operator|.
name|isAccepted
argument_list|()
operator|<<
literal|"mcp:"
operator|<<
name|spe
operator|.
name|contentPosRange
argument_list|()
operator|<<
literal|"cp:"
operator|<<
name|spe
operator|.
name|contentPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|spe
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|QPointF
name|oldContentPos
init|=
name|contentPosition
operator|+
name|overshootPosition
decl_stmt|;
name|QPointF
name|contentDelta
init|=
name|spe
operator|.
name|contentPos
argument_list|()
operator|-
name|oldContentPos
decl_stmt|;
name|viewportSize
operator|=
name|spe
operator|.
name|viewportSize
argument_list|()
expr_stmt|;
name|contentPosRange
operator|=
name|spe
operator|.
name|contentPosRange
argument_list|()
expr_stmt|;
if|if
condition|(
name|contentPosRange
operator|.
name|width
argument_list|()
operator|<
literal|0
condition|)
name|contentPosRange
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentPosRange
operator|.
name|height
argument_list|()
operator|<
literal|0
condition|)
name|contentPosRange
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|contentPosition
operator|=
name|clampToRect
argument_list|(
name|spe
operator|.
name|contentPos
argument_list|()
argument_list|,
name|contentPosRange
argument_list|)
expr_stmt|;
name|overshootPosition
operator|=
name|spe
operator|.
name|contentPos
argument_list|()
operator|-
name|contentPosition
expr_stmt|;
comment|// - check if the content position was moved
if|if
condition|(
name|contentDelta
operator|!=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// need to correct all segments
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xSegments
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
name|xSegments
index|[
name|i
index|]
operator|.
name|startPos
operator|-=
name|contentDelta
operator|.
name|x
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ySegments
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
name|ySegments
index|[
name|i
index|]
operator|.
name|startPos
operator|-=
name|contentDelta
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
condition|)
name|setDpiFromWidget
argument_list|(
name|w
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
condition|)
block|{
comment|//TODO: the first view isn't really correct - maybe use an additional field in the prepare event?
if|if
condition|(
name|go
operator|->
name|scene
argument_list|()
operator|&&
operator|!
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|setDpiFromWidget
argument_list|(
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|state
operator|==
name|QScroller
operator|::
name|Scrolling
condition|)
block|{
name|recalcScrollingSegments
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|handleDrag
name|void
name|QScrollerPrivate
operator|::
name|handleDrag
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
name|QPointF
name|deltaPixel
init|=
name|position
operator|-
name|lastPosition
decl_stmt|;
name|qint64
name|deltaTime
init|=
name|timestamp
operator|-
name|lastTimestamp
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|axisLockThreshold
condition|)
block|{
name|int
name|dx
init|=
name|qAbs
argument_list|(
name|deltaPixel
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dy
init|=
name|qAbs
argument_list|(
name|deltaPixel
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dx
operator|||
name|dy
condition|)
block|{
name|bool
name|vertical
init|=
operator|(
name|dy
operator|>
name|dx
operator|)
decl_stmt|;
name|qreal
name|alpha
init|=
name|qreal
argument_list|(
name|vertical
condition|?
name|dx
else|:
name|dy
argument_list|)
operator|/
name|qreal
argument_list|(
name|vertical
condition|?
name|dy
else|:
name|dx
argument_list|)
decl_stmt|;
comment|//qScrollerDebug()<< "QScroller::handleDrag() -- axis lock:"<< alpha<< " / "<< axisLockThreshold<< "- isvertical:"<< vertical<< "- dx:"<< dx<< "- dy:"<< dy;
if|if
condition|(
name|alpha
operator|<=
name|sp
operator|->
name|axisLockThreshold
condition|)
block|{
if|if
condition|(
name|vertical
condition|)
name|deltaPixel
operator|.
name|setX
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|deltaPixel
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// calculate velocity (if the user would release the mouse NOW)
name|updateVelocity
argument_list|(
name|deltaPixel
argument_list|,
name|deltaTime
argument_list|)
expr_stmt|;
comment|// restrict velocity, if content is not scrollable
name|QRectF
name|max
init|=
name|contentPosRange
decl_stmt|;
name|bool
name|canScrollX
init|=
operator|(
name|max
operator|.
name|width
argument_list|()
operator|>
literal|0
operator|)
operator|||
operator|(
name|sp
operator|->
name|hOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
decl_stmt|;
name|bool
name|canScrollY
init|=
operator|(
name|max
operator|.
name|height
argument_list|()
operator|>
literal|0
operator|)
operator|||
operator|(
name|sp
operator|->
name|vOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|canScrollX
condition|)
block|{
name|deltaPixel
operator|.
name|setX
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|releaseVelocity
operator|.
name|setX
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|canScrollY
condition|)
block|{
name|deltaPixel
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|releaseVelocity
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//    if (firstDrag) {
comment|//        // Do not delay the first drag
comment|//        setContentPositionHelper(q->contentPosition() - overshootDistance - deltaPixel);
comment|//        dragDistance = QPointF(0, 0);
comment|//    } else {
name|dragDistance
operator|+=
name|deltaPixel
expr_stmt|;
comment|//    }
comment|//qScrollerDebug()<< "######################"<< deltaPixel<< position.y()<< lastPosition.y();
name|lastPosition
operator|=
name|position
expr_stmt|;
name|lastTimestamp
operator|=
name|timestamp
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pressWhileInactive
name|bool
name|QScrollerPrivate
operator|::
name|pressWhileInactive
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
if|if
condition|(
name|prepareScrolling
argument_list|(
name|position
argument_list|)
condition|)
block|{
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|contentPosRange
operator|.
name|isNull
argument_list|()
operator|||
operator|(
name|sp
operator|->
name|hOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
operator|||
operator|(
name|sp
operator|->
name|vOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
condition|)
block|{
name|lastPosition
operator|=
name|pressPosition
operator|=
name|position
expr_stmt|;
name|lastTimestamp
operator|=
name|pressTimestamp
operator|=
name|timestamp
expr_stmt|;
name|setState
argument_list|(
name|QScroller
operator|::
name|Pressed
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|releaseWhilePressed
name|bool
name|QScrollerPrivate
operator|::
name|releaseWhilePressed
parameter_list|(
specifier|const
name|QPointF
modifier|&
parameter_list|,
name|qint64
parameter_list|)
block|{
if|if
condition|(
name|overshootPosition
operator|!=
name|QPointF
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
condition|)
block|{
name|setState
argument_list|(
name|QScroller
operator|::
name|Scrolling
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|setState
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|moveWhilePressed
name|bool
name|QScrollerPrivate
operator|::
name|moveWhilePressed
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
name|QPointF
name|ppm
init|=
name|q
operator|->
name|pixelPerMeter
argument_list|()
decl_stmt|;
name|QPointF
name|deltaPixel
init|=
name|position
operator|-
name|pressPosition
decl_stmt|;
name|bool
name|moveAborted
init|=
literal|false
decl_stmt|;
name|bool
name|moveStarted
init|=
operator|(
operator|(
operator|(
name|deltaPixel
operator|/
name|ppm
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|)
operator|>
name|sp
operator|->
name|dragStartDistance
operator|)
decl_stmt|;
comment|// check the direction of the mouse drag and abort if it's too much in the wrong direction.
if|if
condition|(
name|moveStarted
condition|)
block|{
name|QRectF
name|max
init|=
name|contentPosRange
decl_stmt|;
name|bool
name|canScrollX
init|=
operator|(
name|max
operator|.
name|width
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
name|bool
name|canScrollY
init|=
operator|(
name|max
operator|.
name|height
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|hOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
condition|)
name|canScrollX
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|vOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
condition|)
name|canScrollY
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|deltaPixel
operator|.
name|x
argument_list|()
operator|/
name|ppm
operator|.
name|x
argument_list|()
argument_list|)
operator|<
name|qAbs
argument_list|(
name|deltaPixel
operator|.
name|y
argument_list|()
operator|/
name|ppm
operator|.
name|y
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|canScrollY
condition|)
name|moveAborted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|canScrollX
condition|)
name|moveAborted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|moveAborted
condition|)
block|{
name|setState
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
expr_stmt|;
name|moveStarted
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|moveStarted
condition|)
block|{
name|setState
argument_list|(
name|QScroller
operator|::
name|Dragging
argument_list|)
expr_stmt|;
comment|// subtract the dragStartDistance
name|deltaPixel
operator|=
name|deltaPixel
operator|-
name|deltaPixel
operator|*
operator|(
name|sp
operator|->
name|dragStartDistance
operator|/
name|deltaPixel
operator|.
name|manhattanLength
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|deltaPixel
operator|!=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|// handleDrag updates lastPosition, lastTimestamp and velocity
name|handleDrag
argument_list|(
name|pressPosition
operator|+
name|deltaPixel
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|moveStarted
return|;
block|}
end_function
begin_function
DECL|function|moveWhileDragging
name|bool
name|QScrollerPrivate
operator|::
name|moveWhileDragging
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
comment|// handleDrag updates lastPosition, lastTimestamp and velocity
name|handleDrag
argument_list|(
name|position
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|timerEventWhileDragging
name|void
name|QScrollerPrivate
operator|::
name|timerEventWhileDragging
parameter_list|()
block|{
if|if
condition|(
name|dragDistance
operator|!=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::timerEventWhileDragging() -- dragDistance:"
operator|<<
name|dragDistance
expr_stmt|;
name|setContentPositionHelperDragging
argument_list|(
operator|-
name|dragDistance
argument_list|)
expr_stmt|;
name|dragDistance
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|releaseWhileDragging
name|bool
name|QScrollerPrivate
operator|::
name|releaseWhileDragging
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// handleDrag updates lastPosition, lastTimestamp and velocity
name|handleDrag
argument_list|(
name|position
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
comment|// check if we moved at all - this can happen if you stop a running
comment|// scroller with a press and release shortly afterwards
name|QPointF
name|deltaPixel
init|=
name|position
operator|-
name|pressPosition
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|deltaPixel
operator|/
name|q
operator|->
name|pixelPerMeter
argument_list|()
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|)
operator|>
name|sp
operator|->
name|dragStartDistance
condition|)
block|{
comment|// handle accelerating flicks
if|if
condition|(
operator|(
name|oldVelocity
operator|!=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|sp
operator|->
name|acceleratingFlickMaximumTime
operator|&&
operator|(
operator|(
name|timestamp
operator|-
name|pressTimestamp
operator|)
operator|<
name|qint64
argument_list|(
name|sp
operator|->
name|acceleratingFlickMaximumTime
operator|*
literal|1000
argument_list|)
operator|)
condition|)
block|{
comment|// - determine if the direction was changed
name|int
name|signX
init|=
literal|0
decl_stmt|,
name|signY
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|releaseVelocity
operator|.
name|x
argument_list|()
condition|)
name|signX
operator|=
operator|(
name|releaseVelocity
operator|.
name|x
argument_list|()
operator|>
literal|0
operator|)
operator|==
operator|(
name|oldVelocity
operator|.
name|x
argument_list|()
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|releaseVelocity
operator|.
name|y
argument_list|()
condition|)
name|signY
operator|=
operator|(
name|releaseVelocity
operator|.
name|y
argument_list|()
operator|>
literal|0
operator|)
operator|==
operator|(
name|oldVelocity
operator|.
name|y
argument_list|()
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|signX
operator|>
literal|0
condition|)
name|releaseVelocity
operator|.
name|setX
argument_list|(
name|qBound
argument_list|(
operator|-
name|sp
operator|->
name|maximumVelocity
argument_list|,
name|oldVelocity
operator|.
name|x
argument_list|()
operator|*
name|sp
operator|->
name|acceleratingFlickSpeedupFactor
argument_list|,
name|sp
operator|->
name|maximumVelocity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signY
operator|>
literal|0
condition|)
name|releaseVelocity
operator|.
name|setY
argument_list|(
name|qBound
argument_list|(
operator|-
name|sp
operator|->
name|maximumVelocity
argument_list|,
name|oldVelocity
operator|.
name|y
argument_list|()
operator|*
name|sp
operator|->
name|acceleratingFlickSpeedupFactor
argument_list|,
name|sp
operator|->
name|maximumVelocity
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|QPointF
name|ppm
init|=
name|q
operator|->
name|pixelPerMeter
argument_list|()
decl_stmt|;
name|createScrollingSegments
argument_list|(
name|releaseVelocity
argument_list|,
name|contentPosition
operator|+
name|overshootPosition
argument_list|,
name|ppm
argument_list|)
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::releaseWhileDragging() -- velocity:"
operator|<<
name|releaseVelocity
operator|<<
literal|"-- minimum velocity:"
operator|<<
name|sp
operator|->
name|minimumVelocity
operator|<<
literal|"overshoot"
operator|<<
name|overshootPosition
expr_stmt|;
if|if
condition|(
name|xSegments
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ySegments
operator|.
name|isEmpty
argument_list|()
condition|)
name|setState
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
expr_stmt|;
else|else
name|setState
argument_list|(
name|QScroller
operator|::
name|Scrolling
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|timerEventWhileScrolling
name|void
name|QScrollerPrivate
operator|::
name|timerEventWhileScrolling
parameter_list|()
block|{
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::timerEventWhileScrolling()"
expr_stmt|;
name|setContentPositionHelperScrolling
argument_list|()
expr_stmt|;
if|if
condition|(
name|xSegments
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ySegments
operator|.
name|isEmpty
argument_list|()
condition|)
name|setState
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pressWhileScrolling
name|bool
name|QScrollerPrivate
operator|::
name|pressWhileScrolling
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
name|qint64
name|timestamp
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|velocity
argument_list|()
operator|<=
name|properties
operator|.
name|d
operator|->
name|maximumClickThroughVelocity
operator|)
operator|&&
operator|(
name|overshootPosition
operator|==
name|QPointF
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
operator|)
condition|)
block|{
name|setState
argument_list|(
name|QScroller
operator|::
name|Inactive
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|lastPosition
operator|=
name|pressPosition
operator|=
name|position
expr_stmt|;
name|lastTimestamp
operator|=
name|pressTimestamp
operator|=
name|timestamp
expr_stmt|;
name|setState
argument_list|(
name|QScroller
operator|::
name|Pressed
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|QScroller
operator|::
name|Dragging
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal     This function handles all state changes of the scroller. */
end_comment
begin_function
DECL|function|setState
name|void
name|QScrollerPrivate
operator|::
name|setState
parameter_list|(
name|QScroller
operator|::
name|State
name|newstate
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QScroller
argument_list|)
expr_stmt|;
name|bool
name|sendLastScroll
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|newstate
condition|)
return|return;
name|qScrollerDebug
argument_list|()
operator|<<
name|q
operator|<<
literal|"QScroller::setState("
operator|<<
name|stateName
argument_list|(
name|newstate
argument_list|)
operator|<<
literal|")"
expr_stmt|;
switch|switch
condition|(
name|newstate
condition|)
block|{
case|case
name|QScroller
operator|::
name|Inactive
case|:
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|scrollTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// send the last scroll event (but only after the current state change was finished)
if|if
condition|(
operator|!
name|firstScroll
condition|)
name|sendLastScroll
operator|=
literal|true
expr_stmt|;
name|releaseVelocity
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QScroller
operator|::
name|Pressed
case|:
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|scrollTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|oldVelocity
operator|=
name|releaseVelocity
expr_stmt|;
name|releaseVelocity
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QScroller
operator|::
name|Dragging
case|:
name|dragDistance
operator|=
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
if|if
condition|(
name|state
operator|==
name|QScroller
operator|::
name|Pressed
condition|)
name|scrollTimer
operator|->
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|QScroller
operator|::
name|Scrolling
case|:
ifndef|#
directive|ifndef
name|QT_NO_ANIMATION
name|scrollTimer
operator|->
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|qSwap
argument_list|(
name|state
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendLastScroll
condition|)
block|{
name|QScrollEvent
name|se
argument_list|(
name|contentPosition
argument_list|,
name|overshootPosition
argument_list|,
name|QScrollEvent
operator|::
name|ScrollFinished
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|se
argument_list|)
expr_stmt|;
name|firstScroll
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|QScroller
operator|::
name|Dragging
operator|||
name|state
operator|==
name|QScroller
operator|::
name|Scrolling
condition|)
name|qt_activeScrollers
argument_list|()
operator|->
name|insert
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|qt_activeScrollers
argument_list|()
operator|->
name|remove
argument_list|(
name|q
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*! \internal     Helps when setting the content position.     It will try to move the content by the requested delta but stop in case     when we are coming back from an overshoot or a scrollTo.     It will also indicate a new overshooting condition by the overshootX and oversthootY flags.      In this cases it will reset the velocity variables and other flags.      Also keeps track of the current over-shooting value in overshootPosition.      \a deltaPos is the amount of pixels the current content position should be moved */
end_comment
begin_function
DECL|function|setContentPositionHelperDragging
name|void
name|QScrollerPrivate
operator|::
name|setContentPositionHelperDragging
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|deltaPos
parameter_list|)
block|{
specifier|const
name|QScrollerPropertiesPrivate
modifier|*
name|sp
init|=
name|properties
operator|.
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|overshootDragResistanceFactor
condition|)
name|overshootPosition
operator|/=
name|sp
operator|->
name|overshootDragResistanceFactor
expr_stmt|;
name|QPointF
name|oldPos
init|=
name|contentPosition
operator|+
name|overshootPosition
decl_stmt|;
name|QPointF
name|newPos
init|=
name|oldPos
operator|+
name|deltaPos
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::setContentPositionHelperDragging("
operator|<<
name|deltaPos
operator|<<
literal|" [pix])"
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> overshoot:"
operator|<<
name|overshootPosition
operator|<<
literal|"- old pos:"
operator|<<
name|oldPos
operator|<<
literal|"- new pos:"
operator|<<
name|newPos
expr_stmt|;
name|QPointF
name|oldClampedPos
init|=
name|clampToRect
argument_list|(
name|oldPos
argument_list|,
name|contentPosRange
argument_list|)
decl_stmt|;
name|QPointF
name|newClampedPos
init|=
name|clampToRect
argument_list|(
name|newPos
argument_list|,
name|contentPosRange
argument_list|)
decl_stmt|;
comment|// --- handle overshooting and stop if the coordinate is going back inside the normal area
name|bool
name|alwaysOvershootX
init|=
operator|(
name|sp
operator|->
name|hOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
decl_stmt|;
name|bool
name|alwaysOvershootY
init|=
operator|(
name|sp
operator|->
name|vOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOn
operator|)
decl_stmt|;
name|bool
name|noOvershootX
init|=
operator|(
name|sp
operator|->
name|hOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOff
operator|)
operator|||
operator|(
operator|(
name|state
operator|==
name|QScroller
operator|::
name|Dragging
operator|)
operator|&&
operator|!
name|sp
operator|->
name|overshootDragResistanceFactor
operator|)
operator|||
operator|!
name|sp
operator|->
name|overshootDragDistanceFactor
decl_stmt|;
name|bool
name|noOvershootY
init|=
operator|(
name|sp
operator|->
name|vOvershootPolicy
operator|==
name|QScrollerProperties
operator|::
name|OvershootAlwaysOff
operator|)
operator|||
operator|(
operator|(
name|state
operator|==
name|QScroller
operator|::
name|Dragging
operator|)
operator|&&
operator|!
name|sp
operator|->
name|overshootDragResistanceFactor
operator|)
operator|||
operator|!
name|sp
operator|->
name|overshootDragDistanceFactor
decl_stmt|;
name|bool
name|canOvershootX
init|=
operator|!
name|noOvershootX
operator|&&
operator|(
name|alwaysOvershootX
operator|||
name|contentPosRange
operator|.
name|width
argument_list|()
operator|)
decl_stmt|;
name|bool
name|canOvershootY
init|=
operator|!
name|noOvershootY
operator|&&
operator|(
name|alwaysOvershootY
operator|||
name|contentPosRange
operator|.
name|height
argument_list|()
operator|)
decl_stmt|;
name|qreal
name|oldOvershootX
init|=
operator|(
name|canOvershootX
operator|)
condition|?
name|oldPos
operator|.
name|x
argument_list|()
operator|-
name|oldClampedPos
operator|.
name|x
argument_list|()
else|:
literal|0
decl_stmt|;
name|qreal
name|oldOvershootY
init|=
operator|(
name|canOvershootY
operator|)
condition|?
name|oldPos
operator|.
name|y
argument_list|()
operator|-
name|oldClampedPos
operator|.
name|y
argument_list|()
else|:
literal|0
decl_stmt|;
name|qreal
name|newOvershootX
init|=
operator|(
name|canOvershootX
operator|)
condition|?
name|newPos
operator|.
name|x
argument_list|()
operator|-
name|newClampedPos
operator|.
name|x
argument_list|()
else|:
literal|0
decl_stmt|;
name|qreal
name|newOvershootY
init|=
operator|(
name|canOvershootY
operator|)
condition|?
name|newPos
operator|.
name|y
argument_list|()
operator|-
name|newClampedPos
operator|.
name|y
argument_list|()
else|:
literal|0
decl_stmt|;
name|qreal
name|maxOvershootX
init|=
name|viewportSize
operator|.
name|width
argument_list|()
operator|*
name|sp
operator|->
name|overshootDragDistanceFactor
decl_stmt|;
name|qreal
name|maxOvershootY
init|=
name|viewportSize
operator|.
name|height
argument_list|()
operator|*
name|sp
operator|->
name|overshootDragDistanceFactor
decl_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> noOs:"
operator|<<
name|noOvershootX
operator|<<
literal|"drf:"
operator|<<
name|sp
operator|->
name|overshootDragResistanceFactor
operator|<<
literal|"mdf:"
operator|<<
name|sp
operator|->
name|overshootScrollDistanceFactor
operator|<<
literal|"ossP:"
operator|<<
name|sp
operator|->
name|hOvershootPolicy
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> canOS:"
operator|<<
name|canOvershootX
operator|<<
literal|"newOS:"
operator|<<
name|newOvershootX
operator|<<
literal|"maxOS:"
operator|<<
name|maxOvershootX
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|overshootDragResistanceFactor
condition|)
block|{
name|oldOvershootX
operator|*=
name|sp
operator|->
name|overshootDragResistanceFactor
expr_stmt|;
name|oldOvershootY
operator|*=
name|sp
operator|->
name|overshootDragResistanceFactor
expr_stmt|;
name|newOvershootX
operator|*=
name|sp
operator|->
name|overshootDragResistanceFactor
expr_stmt|;
name|newOvershootY
operator|*=
name|sp
operator|->
name|overshootDragResistanceFactor
expr_stmt|;
block|}
comment|// -- stop at the maximum overshoot distance
name|newOvershootX
operator|=
name|qBound
argument_list|(
operator|-
name|maxOvershootX
argument_list|,
name|newOvershootX
argument_list|,
name|maxOvershootX
argument_list|)
expr_stmt|;
name|newOvershootY
operator|=
name|qBound
argument_list|(
operator|-
name|maxOvershootY
argument_list|,
name|newOvershootY
argument_list|,
name|maxOvershootY
argument_list|)
expr_stmt|;
name|overshootPosition
operator|.
name|setX
argument_list|(
name|newOvershootX
argument_list|)
expr_stmt|;
name|overshootPosition
operator|.
name|setY
argument_list|(
name|newOvershootY
argument_list|)
expr_stmt|;
name|contentPosition
operator|=
name|newClampedPos
expr_stmt|;
name|QScrollEvent
name|se
argument_list|(
name|contentPosition
argument_list|,
name|overshootPosition
argument_list|,
name|firstScroll
condition|?
name|QScrollEvent
operator|::
name|ScrollStarted
else|:
name|QScrollEvent
operator|::
name|ScrollUpdated
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|se
argument_list|)
expr_stmt|;
name|firstScroll
operator|=
literal|false
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> new position:"
operator|<<
name|newClampedPos
operator|<<
literal|"- new overshoot:"
operator|<<
name|overshootPosition
operator|<<
literal|"- overshoot x/y?:"
operator|<<
name|overshootPosition
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nextSegmentPosition
name|qreal
name|QScrollerPrivate
operator|::
name|nextSegmentPosition
parameter_list|(
name|QQueue
argument_list|<
name|ScrollSegment
argument_list|>
modifier|&
name|segments
parameter_list|,
name|qint64
name|now
parameter_list|,
name|qreal
name|oldPos
parameter_list|)
block|{
name|qreal
name|pos
init|=
name|oldPos
decl_stmt|;
comment|// check the X segments for new positions
while|while
condition|(
operator|!
name|segments
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ScrollSegment
name|s
init|=
name|segments
operator|.
name|head
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|startTime
operator|+
name|s
operator|.
name|deltaTime
operator|*
name|s
operator|.
name|stopProgress
operator|)
operator|<=
name|now
condition|)
block|{
name|segments
operator|.
name|dequeue
argument_list|()
expr_stmt|;
name|pos
operator|=
name|s
operator|.
name|stopPos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|startTime
operator|<=
name|now
condition|)
block|{
name|qreal
name|progress
init|=
name|qreal
argument_list|(
name|now
operator|-
name|s
operator|.
name|startTime
argument_list|)
operator|/
name|qreal
argument_list|(
name|s
operator|.
name|deltaTime
argument_list|)
decl_stmt|;
name|pos
operator|=
name|s
operator|.
name|startPos
operator|+
name|s
operator|.
name|deltaPos
operator|*
name|s
operator|.
name|curve
operator|.
name|valueForProgress
argument_list|(
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|deltaPos
operator|>
literal|0
condition|?
name|pos
operator|>
name|s
operator|.
name|stopPos
else|:
name|pos
operator|<
name|s
operator|.
name|stopPos
condition|)
block|{
name|segments
operator|.
name|dequeue
argument_list|()
expr_stmt|;
name|pos
operator|=
name|s
operator|.
name|stopPos
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|pos
return|;
block|}
end_function
begin_function
DECL|function|setContentPositionHelperScrolling
name|void
name|QScrollerPrivate
operator|::
name|setContentPositionHelperScrolling
parameter_list|()
block|{
name|qint64
name|now
init|=
name|monotonicTimer
operator|.
name|elapsed
argument_list|()
decl_stmt|;
name|QPointF
name|newPos
init|=
name|contentPosition
operator|+
name|overshootPosition
decl_stmt|;
name|newPos
operator|.
name|setX
argument_list|(
name|nextSegmentPosition
argument_list|(
name|xSegments
argument_list|,
name|now
argument_list|,
name|newPos
operator|.
name|x
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|newPos
operator|.
name|setY
argument_list|(
name|nextSegmentPosition
argument_list|(
name|ySegments
argument_list|,
name|now
argument_list|,
name|newPos
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// -- set the position and handle overshoot
name|qScrollerDebug
argument_list|()
operator|<<
literal|"QScroller::setContentPositionHelperScrolling()"
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> overshoot:"
operator|<<
name|overshootPosition
operator|<<
literal|"- new pos:"
operator|<<
name|newPos
expr_stmt|;
name|QPointF
name|newClampedPos
init|=
name|clampToRect
argument_list|(
name|newPos
argument_list|,
name|contentPosRange
argument_list|)
decl_stmt|;
name|overshootPosition
operator|=
name|newPos
operator|-
name|newClampedPos
expr_stmt|;
name|contentPosition
operator|=
name|newClampedPos
expr_stmt|;
name|QScrollEvent
name|se
argument_list|(
name|contentPosition
argument_list|,
name|overshootPosition
argument_list|,
name|firstScroll
condition|?
name|QScrollEvent
operator|::
name|ScrollStarted
else|:
name|QScrollEvent
operator|::
name|ScrollUpdated
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|se
argument_list|)
expr_stmt|;
name|firstScroll
operator|=
literal|false
expr_stmt|;
name|qScrollerDebug
argument_list|()
operator|<<
literal|"  --> new position:"
operator|<<
name|newClampedPos
operator|<<
literal|"- new overshoot:"
operator|<<
name|overshootPosition
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the next snap point in direction.     If \a direction>0 it will return the next snap point that is larger than the current position.     If \a direction<0 it will return the next snap point that is smaller than the current position.     If \a direction ==0 it will return the nearest snap point (or the current position if we are already     on a snap point.     Returns the nearest snap position or NaN if no such point could be found.  */
end_comment
begin_function
DECL|function|nextSnapPos
name|qreal
name|QScrollerPrivate
operator|::
name|nextSnapPos
parameter_list|(
name|qreal
name|p
parameter_list|,
name|int
name|dir
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|qreal
name|bestSnapPos
init|=
name|Q_QNAN
decl_stmt|;
name|qreal
name|bestSnapPosDist
init|=
name|Q_INFINITY
decl_stmt|;
name|qreal
name|minPos
decl_stmt|;
name|qreal
name|maxPos
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|minPos
operator|=
name|contentPosRange
operator|.
name|left
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|right
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|minPos
operator|=
name|contentPosRange
operator|.
name|top
argument_list|()
expr_stmt|;
name|maxPos
operator|=
name|contentPosRange
operator|.
name|bottom
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
comment|// the snap points in the list
foreach|foreach
control|(
name|qreal
name|snapPos
decl|,
name|snapPositionsX
control|)
block|{
name|qreal
name|snapPosDist
init|=
name|snapPos
operator|-
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|>
literal|0
operator|&&
name|snapPosDist
operator|<
literal|0
operator|)
operator|||
operator|(
name|dir
argument_list|<
literal|0
operator|&&
name|snapPosDist
argument_list|>
literal|0
operator|)
condition|)
continue|continue;
comment|// wrong direction
if|if
condition|(
name|snapPos
argument_list|<
name|minPos
operator|||
name|snapPos
argument_list|>
name|maxPos
condition|)
continue|continue;
comment|// invalid
if|if
condition|(
name|qIsNaN
argument_list|(
name|bestSnapPos
argument_list|)
operator|||
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
operator|<
name|bestSnapPosDist
condition|)
block|{
name|bestSnapPos
operator|=
name|snapPos
expr_stmt|;
name|bestSnapPosDist
operator|=
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the snap point interval
if|if
condition|(
name|snapIntervalX
operator|>
literal|0.0
condition|)
block|{
name|qreal
name|first
init|=
name|minPos
operator|+
name|snapFirstX
decl_stmt|;
name|qreal
name|snapPos
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|snapPos
operator|=
name|qCeil
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalX
argument_list|)
operator|*
name|snapIntervalX
operator|+
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|snapPos
operator|=
name|qFloor
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalX
argument_list|)
operator|*
name|snapIntervalX
operator|+
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|<=
name|first
condition|)
name|snapPos
operator|=
name|first
expr_stmt|;
else|else
block|{
name|qreal
name|last
init|=
name|qFloor
argument_list|(
operator|(
name|maxPos
operator|-
name|first
operator|)
operator|/
name|snapIntervalX
argument_list|)
operator|*
name|snapIntervalX
operator|+
name|first
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|last
condition|)
name|snapPos
operator|=
name|last
expr_stmt|;
else|else
name|snapPos
operator|=
name|qRound
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalX
argument_list|)
operator|*
name|snapIntervalX
operator|+
name|first
expr_stmt|;
block|}
if|if
condition|(
name|snapPos
operator|>=
name|first
operator|&&
name|snapPos
operator|<=
name|maxPos
condition|)
block|{
name|qreal
name|snapPosDist
init|=
name|snapPos
operator|-
name|p
decl_stmt|;
if|if
condition|(
name|qIsNaN
argument_list|(
name|bestSnapPos
argument_list|)
operator|||
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
operator|<
name|bestSnapPosDist
condition|)
block|{
name|bestSnapPos
operator|=
name|snapPos
expr_stmt|;
name|bestSnapPosDist
operator|=
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// (orientation == Qt::Vertical)
comment|// the snap points in the list
foreach|foreach
control|(
name|qreal
name|snapPos
decl|,
name|snapPositionsY
control|)
block|{
name|qreal
name|snapPosDist
init|=
name|snapPos
operator|-
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|>
literal|0
operator|&&
name|snapPosDist
operator|<
literal|0
operator|)
operator|||
operator|(
name|dir
argument_list|<
literal|0
operator|&&
name|snapPosDist
argument_list|>
literal|0
operator|)
condition|)
continue|continue;
comment|// wrong direction
if|if
condition|(
name|snapPos
argument_list|<
name|minPos
operator|||
name|snapPos
argument_list|>
name|maxPos
condition|)
continue|continue;
comment|// invalid
if|if
condition|(
name|qIsNaN
argument_list|(
name|bestSnapPos
argument_list|)
operator|||
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
operator|<
name|bestSnapPosDist
condition|)
block|{
name|bestSnapPos
operator|=
name|snapPos
expr_stmt|;
name|bestSnapPosDist
operator|=
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the snap point interval
if|if
condition|(
name|snapIntervalY
operator|>
literal|0.0
condition|)
block|{
name|qreal
name|first
init|=
name|minPos
operator|+
name|snapFirstY
decl_stmt|;
name|qreal
name|snapPos
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|snapPos
operator|=
name|qCeil
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalY
argument_list|)
operator|*
name|snapIntervalY
operator|+
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|snapPos
operator|=
name|qFloor
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalY
argument_list|)
operator|*
name|snapIntervalY
operator|+
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|<=
name|first
condition|)
name|snapPos
operator|=
name|first
expr_stmt|;
else|else
block|{
name|qreal
name|last
init|=
name|qFloor
argument_list|(
operator|(
name|maxPos
operator|-
name|first
operator|)
operator|/
name|snapIntervalY
argument_list|)
operator|*
name|snapIntervalY
operator|+
name|first
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|last
condition|)
name|snapPos
operator|=
name|last
expr_stmt|;
else|else
name|snapPos
operator|=
name|qRound
argument_list|(
operator|(
name|p
operator|-
name|first
operator|)
operator|/
name|snapIntervalY
argument_list|)
operator|*
name|snapIntervalY
operator|+
name|first
expr_stmt|;
block|}
if|if
condition|(
name|snapPos
operator|>=
name|first
operator|&&
name|snapPos
operator|<=
name|maxPos
condition|)
block|{
name|qreal
name|snapPosDist
init|=
name|snapPos
operator|-
name|p
decl_stmt|;
if|if
condition|(
name|qIsNaN
argument_list|(
name|bestSnapPos
argument_list|)
operator|||
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
operator|<
name|bestSnapPosDist
condition|)
block|{
name|bestSnapPos
operator|=
name|snapPos
expr_stmt|;
name|bestSnapPosDist
operator|=
name|qAbs
argument_list|(
name|snapPosDist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|bestSnapPos
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QScroller::State      This enum contains the different QScroller states.      \value Inactive The scroller is not scrolling and nothing is pressed.     \value Pressed A touch event was received or the mouse button was pressed but the scroll area is currently not dragged.     \value Dragging The scroll area is currently following the touch point or mouse.     \value Scrolling The scroll area is moving on it's own. */
end_comment
begin_comment
comment|/*!     \enum QScroller::ScrollerGestureType      This enum contains the different gesture types that are supported by the QScroller gesture recognizer.      \value TouchGesture The gesture recognizer will only trigger on touch         events.  Specifically it will react on single touch points when using a         touch screen and dual touch points when using a touchpad.     \value LeftMouseButtonGesture The gesture recognizer will only trigger on left mouse button events.     \value MiddleMouseButtonGesture The gesture recognizer will only trigger on middle mouse button events.     \value RightMouseButtonGesture The gesture recognizer will only trigger on right mouse button events. */
end_comment
begin_comment
comment|/*!     \enum QScroller::Input      This enum contains an input device agnostic view of input events that are relevant for QScroller.      \value InputPress   The user pressed the input device (e.g.  QEvent::MouseButtonPress,                         QEvent::GraphicsSceneMousePress, QEvent::TouchBegin)      \value InputMove    The user moved the input device (e.g.  QEvent::MouseMove,                         QEvent::GraphicsSceneMouseMove, QEvent::TouchUpdate)      \value InputRelease The user released the input device (e.g.  QEvent::MouseButtonRelease,                         QEvent::GraphicsSceneMouseRelease, QEvent::TouchEnd)  */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
