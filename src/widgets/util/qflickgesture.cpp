begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qgesture.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsitem.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsview.h"
end_include
begin_include
include|#
directive|include
file|"qscroller.h"
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qflickgesture_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_function_decl
name|QT_BEGIN_NAMESPACE
comment|//#define QFLICKGESTURE_DEBUG
ifdef|#
directive|ifdef
name|QFLICKGESTURE_DEBUG
DECL|macro|qFGDebug
define|#
directive|define
name|qFGDebug
value|qDebug
else|#
directive|else
define|#
directive|define
name|qFGDebug
value|while (false) qDebug
endif|#
directive|endif
specifier|extern
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|copyMouseEvent
specifier|static
name|QMouseEvent
modifier|*
name|copyMouseEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
block|{
name|QMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
return|return
operator|new
name|QMouseEvent
argument_list|(
name|me
operator|->
name|type
argument_list|()
argument_list|,
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|me
operator|->
name|windowPos
argument_list|()
argument_list|,
name|me
operator|->
name|screenPos
argument_list|()
argument_list|,
name|me
operator|->
name|button
argument_list|()
argument_list|,
name|me
operator|->
name|buttons
argument_list|()
argument_list|,
name|me
operator|->
name|modifiers
argument_list|()
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
block|{
name|QGraphicsSceneMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|#
directive|if
literal|1
name|QEvent
operator|::
name|Type
name|met
init|=
name|me
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|GraphicsSceneMousePress
condition|?
name|QEvent
operator|::
name|MouseButtonPress
else|:
operator|(
name|me
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
condition|?
name|QEvent
operator|::
name|MouseButtonRelease
else|:
name|QEvent
operator|::
name|MouseMove
operator|)
decl_stmt|;
return|return
operator|new
name|QMouseEvent
argument_list|(
name|met
argument_list|,
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|me
operator|->
name|screenPos
argument_list|()
argument_list|,
name|me
operator|->
name|button
argument_list|()
argument_list|,
name|me
operator|->
name|buttons
argument_list|()
argument_list|,
name|me
operator|->
name|modifiers
argument_list|()
argument_list|)
return|;
else|#
directive|else
name|QGraphicsSceneMouseEvent
modifier|*
name|copy
init|=
operator|new
name|QGraphicsSceneMouseEvent
argument_list|(
name|me
operator|->
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|copy
operator|->
name|setPos
argument_list|(
name|me
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setScenePos
argument_list|(
name|me
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setScreenPos
argument_list|(
name|me
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0x1
init|;
name|i
operator|<=
literal|0x10
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|copy
operator|->
name|setButtonDownPos
argument_list|(
name|button
argument_list|,
name|me
operator|->
name|buttonDownPos
argument_list|(
name|button
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setButtonDownScenePos
argument_list|(
name|button
argument_list|,
name|me
operator|->
name|buttonDownScenePos
argument_list|(
name|button
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setButtonDownScreenPos
argument_list|(
name|button
argument_list|,
name|me
operator|->
name|buttonDownScreenPos
argument_list|(
name|button
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|copy
operator|->
name|setLastPos
argument_list|(
name|me
operator|->
name|lastPos
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setLastScenePos
argument_list|(
name|me
operator|->
name|lastScenePos
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setLastScreenPos
argument_list|(
name|me
operator|->
name|lastScreenPos
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setButtons
argument_list|(
name|me
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setButton
argument_list|(
name|me
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|->
name|setModifiers
argument_list|(
name|me
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|// QT_NO_GRAPHICSVIEW
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_class
DECL|class|PressDelayHandler
class|class
name|PressDelayHandler
super|:
specifier|public
name|QObject
block|{
private|private:
DECL|function|PressDelayHandler
name|PressDelayHandler
parameter_list|(
name|QObject
modifier|*
name|parent
init|=
literal|0
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|pressDelayTimer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sendingEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mouseButton
argument_list|(
name|Qt
operator|::
name|NoButton
argument_list|)
member_init_list|,
name|mouseTarget
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|member|inst
specifier|static
name|PressDelayHandler
modifier|*
name|inst
decl_stmt|;
public|public:
enum|enum
block|{
DECL|enumerator|UngrabMouseBefore
name|UngrabMouseBefore
init|=
literal|1
block|,
DECL|enumerator|RegrabMouseAfterwards
name|RegrabMouseAfterwards
init|=
literal|2
block|}
enum|;
DECL|function|instance
specifier|static
name|PressDelayHandler
modifier|*
name|instance
parameter_list|()
block|{
specifier|static
name|PressDelayHandler
modifier|*
name|inst
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|inst
condition|)
name|inst
operator|=
operator|new
name|PressDelayHandler
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
DECL|function|shouldEventBeIgnored
name|bool
name|shouldEventBeIgnored
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
specifier|const
block|{
return|return
name|sendingEvent
return|;
block|}
DECL|function|isDelaying
name|bool
name|isDelaying
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|pressDelayEvent
operator|.
name|isNull
argument_list|()
return|;
block|}
DECL|function|pressed
name|void
name|pressed
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pressDelayEvent
condition|)
block|{
name|pressDelayEvent
operator|.
name|reset
argument_list|(
name|copyMouseEvent
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pressDelayTimer
operator|=
name|startTimer
argument_list|(
name|delay
argument_list|)
expr_stmt|;
name|mouseTarget
operator|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|pressDelayEvent
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|mouseButton
operator|=
name|pressDelayEvent
operator|->
name|button
argument_list|()
expr_stmt|;
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: consuming/delaying mouse press"
expr_stmt|;
block|}
else|else
block|{
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: NOT consuming/delaying mouse press"
expr_stmt|;
block|}
name|e
operator|->
name|setAccepted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|released
name|bool
name|released
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|,
name|bool
name|scrollerWasActive
parameter_list|,
name|bool
name|scrollerIsActive
parameter_list|)
block|{
comment|// consume this event if the scroller was or is active
name|bool
name|result
init|=
name|scrollerWasActive
operator|||
name|scrollerIsActive
decl_stmt|;
comment|// stop the timer
if|if
condition|(
name|pressDelayTimer
condition|)
block|{
name|killTimer
argument_list|(
name|pressDelayTimer
argument_list|)
expr_stmt|;
name|pressDelayTimer
operator|=
literal|0
expr_stmt|;
block|}
comment|// we still haven't even sent the press, so do it now
if|if
condition|(
name|pressDelayEvent
operator|&&
name|mouseTarget
operator|&&
operator|!
name|scrollerIsActive
condition|)
block|{
name|QScopedPointer
argument_list|<
name|QMouseEvent
argument_list|>
name|releaseEvent
argument_list|(
name|copyMouseEvent
argument_list|(
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: re-sending mouse press (due to release) for "
operator|<<
name|mouseTarget
expr_stmt|;
name|sendMouseEvent
argument_list|(
name|pressDelayEvent
operator|.
name|data
argument_list|()
argument_list|,
name|UngrabMouseBefore
argument_list|)
expr_stmt|;
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: faking mouse release (due to release) for "
operator|<<
name|mouseTarget
expr_stmt|;
name|sendMouseEvent
argument_list|(
name|releaseEvent
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
literal|true
expr_stmt|;
comment|// consume this event
block|}
elseif|else
if|if
condition|(
name|mouseTarget
operator|&&
name|scrollerIsActive
condition|)
block|{
comment|// we grabbed the mouse expicitly when the scroller became active, so undo that now
name|sendMouseEvent
argument_list|(
literal|0
argument_list|,
name|UngrabMouseBefore
argument_list|)
expr_stmt|;
block|}
name|pressDelayEvent
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mouseTarget
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|function|scrollerWasIntercepted
name|void
name|scrollerWasIntercepted
parameter_list|()
block|{
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: deleting delayed mouse press, since scroller was only intercepted"
expr_stmt|;
if|if
condition|(
name|pressDelayEvent
condition|)
block|{
comment|// we still haven't even sent the press, so just throw it away now
if|if
condition|(
name|pressDelayTimer
condition|)
block|{
name|killTimer
argument_list|(
name|pressDelayTimer
argument_list|)
expr_stmt|;
name|pressDelayTimer
operator|=
literal|0
expr_stmt|;
block|}
name|pressDelayEvent
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mouseTarget
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|scrollerBecameActive
name|void
name|scrollerBecameActive
parameter_list|()
block|{
if|if
condition|(
name|pressDelayEvent
condition|)
block|{
comment|// we still haven't even sent the press, so just throw it away now
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: deleting delayed mouse press, since scroller is active now"
expr_stmt|;
if|if
condition|(
name|pressDelayTimer
condition|)
block|{
name|killTimer
argument_list|(
name|pressDelayTimer
argument_list|)
expr_stmt|;
name|pressDelayTimer
operator|=
literal|0
expr_stmt|;
block|}
name|pressDelayEvent
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mouseTarget
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mouseTarget
condition|)
block|{
comment|// we did send a press, so we need to fake a release now
comment|// release all pressed mouse buttons
comment|/* Qt::MouseButtons mouseButtons = QApplication::mouseButtons();             for (int i = 0; i< 32; ++i) {                 if (mouseButtons& (1<< i)) {                     Qt::MouseButton b = static_cast<Qt::MouseButton>(1<< i);                     mouseButtons&= ~b;                     QPoint farFarAway(-QWIDGETSIZE_MAX, -QWIDGETSIZE_MAX);                      qFGDebug()<< "QFG: sending a fake mouse release at far-far-away to "<< mouseTarget;                     QMouseEvent re(QEvent::MouseButtonRelease, QPoint(), farFarAway,                                    b, mouseButtons, QApplication::keyboardModifiers());                     sendMouseEvent(&re);                 }             }*/
name|QPoint
name|farFarAway
argument_list|(
operator|-
name|QWIDGETSIZE_MAX
argument_list|,
operator|-
name|QWIDGETSIZE_MAX
argument_list|)
decl_stmt|;
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: sending a fake mouse release at far-far-away to "
operator|<<
name|mouseTarget
expr_stmt|;
name|QMouseEvent
name|re
argument_list|(
name|QEvent
operator|::
name|MouseButtonRelease
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|farFarAway
argument_list|,
name|farFarAway
argument_list|,
name|mouseButton
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
operator|&
operator|~
name|mouseButton
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|sendMouseEvent
argument_list|(
operator|&
name|re
argument_list|,
name|RegrabMouseAfterwards
argument_list|)
expr_stmt|;
comment|// don't clear the mouseTarget just yet, since we need to explicitly ungrab the mouse on release!
block|}
block|}
protected|protected:
DECL|function|timerEvent
name|void
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|pressDelayTimer
condition|)
block|{
if|if
condition|(
name|pressDelayEvent
operator|&&
name|mouseTarget
condition|)
block|{
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: timer event: re-sending mouse press to "
operator|<<
name|mouseTarget
expr_stmt|;
name|sendMouseEvent
argument_list|(
name|pressDelayEvent
operator|.
name|data
argument_list|()
argument_list|,
name|UngrabMouseBefore
argument_list|)
expr_stmt|;
block|}
name|pressDelayEvent
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pressDelayTimer
condition|)
block|{
name|killTimer
argument_list|(
name|pressDelayTimer
argument_list|)
expr_stmt|;
name|pressDelayTimer
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
DECL|function|sendMouseEvent
name|void
name|sendMouseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|me
parameter_list|,
name|int
name|flags
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|mouseTarget
condition|)
block|{
name|sendingEvent
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QGraphicsItem
modifier|*
name|grabber
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mouseTarget
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|mouseTarget
operator|->
name|parentWidget
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|gv
operator|->
name|scene
argument_list|()
condition|)
name|grabber
operator|=
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|mouseGrabberItem
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|grabber
operator|&&
operator|(
name|flags
operator|&
name|UngrabMouseBefore
operator|)
condition|)
block|{
comment|// GraphicsView Mouse Handling Workaround #1:
comment|// we need to ungrab the mouse before re-sending the press,
comment|// since the scene had already set the mouse grabber to the
comment|// original (and consumed) event's receiver
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: ungrabbing"
operator|<<
name|grabber
expr_stmt|;
name|grabber
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_GRAPHICSVIEW
if|if
condition|(
name|me
condition|)
block|{
name|QMouseEvent
name|copy
argument_list|(
name|me
operator|->
name|type
argument_list|()
argument_list|,
name|mouseTarget
operator|->
name|mapFromGlobal
argument_list|(
name|me
operator|->
name|globalPos
argument_list|()
argument_list|)
argument_list|,
name|mouseTarget
operator|->
name|topLevelWidget
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|me
operator|->
name|globalPos
argument_list|()
argument_list|)
argument_list|,
name|me
operator|->
name|screenPos
argument_list|()
argument_list|,
name|me
operator|->
name|button
argument_list|()
argument_list|,
name|me
operator|->
name|buttons
argument_list|()
argument_list|,
name|me
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|qt_sendSpontaneousEvent
argument_list|(
name|mouseTarget
argument_list|,
operator|&
name|copy
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|grabber
operator|&&
operator|(
name|flags
operator|&
name|RegrabMouseAfterwards
operator|)
condition|)
block|{
comment|// GraphicsView Mouse Handling Workaround #2:
comment|// we need to re-grab the mouse after sending a faked mouse
comment|// release, since we still need the mouse moves for the gesture
comment|// (the scene will clear the item's mouse grabber status on
comment|// release).
name|qFGDebug
argument_list|()
operator|<<
literal|"QFG: re-grabbing"
operator|<<
name|grabber
expr_stmt|;
name|grabber
operator|->
name|grabMouse
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|sendingEvent
operator|=
literal|false
expr_stmt|;
block|}
block|}
private|private:
DECL|member|pressDelayTimer
name|int
name|pressDelayTimer
decl_stmt|;
DECL|member|pressDelayEvent
name|QScopedPointer
argument_list|<
name|QMouseEvent
argument_list|>
name|pressDelayEvent
decl_stmt|;
DECL|member|sendingEvent
name|bool
name|sendingEvent
decl_stmt|;
DECL|member|mouseButton
name|Qt
operator|::
name|MouseButton
name|mouseButton
decl_stmt|;
DECL|member|mouseTarget
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|mouseTarget
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \internal     \class QFlickGesture     \since 4.8     \brief The QFlickGesture class describes a flicking gesture made by the user.     \ingroup gestures     The QFlickGesture is more complex than the QPanGesture that uses QScroller and QScrollerProperties     to decide if it is triggered.     This gesture is reacting on touch event as compared to the QMouseFlickGesture.      \sa {Gestures in Widgets and Graphics View}, QScroller, QScrollerProperties, QMouseFlickGesture */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QFlickGesture
name|QFlickGesture
operator|::
name|QFlickGesture
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|Qt
operator|::
name|MouseButton
name|button
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QGesture
argument_list|(
operator|*
operator|new
name|QFlickGesturePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|receiver
operator|=
name|receiver
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|receiverScroller
operator|=
operator|(
name|receiver
operator|&&
name|QScroller
operator|::
name|hasScroller
argument_list|(
name|receiver
argument_list|)
operator|)
condition|?
name|QScroller
operator|::
name|scroller
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|button
operator|=
name|button
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QFlickGesture
name|QFlickGesture
operator|::
name|~
name|QFlickGesture
parameter_list|()
block|{ }
end_destructor
begin_constructor
DECL|function|QFlickGesturePrivate
name|QFlickGesturePrivate
operator|::
name|QFlickGesturePrivate
parameter_list|()
member_init_list|:
name|receiverScroller
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|button
argument_list|(
name|Qt
operator|::
name|NoButton
argument_list|)
member_init_list|,
name|macIgnoreWheel
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|//
end_comment
begin_comment
comment|// QFlickGestureRecognizer
end_comment
begin_comment
comment|//
end_comment
begin_constructor
DECL|function|QFlickGestureRecognizer
name|QFlickGestureRecognizer
operator|::
name|QFlickGestureRecognizer
parameter_list|(
name|Qt
operator|::
name|MouseButton
name|button
parameter_list|)
block|{
name|this
operator|->
name|button
operator|=
name|button
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|create
name|QGesture
modifier|*
name|QFlickGestureRecognizer
operator|::
name|create
parameter_list|(
name|QObject
modifier|*
name|target
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|go
operator|&&
name|button
operator|==
name|Qt
operator|::
name|NoButton
condition|)
block|{
name|go
operator|->
name|setAcceptTouchEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|new
name|QFlickGesture
argument_list|(
name|target
argument_list|,
name|button
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     The recognize function detects a touch event suitable to start the attached QScroller.     The QFlickGesture will be triggered as soon as the scroller is no longer in the state     QScroller::Inactive or QScroller::Pressed. It will be finished or canceled     at the next QEvent::TouchEnd.     Note that the QScroller might continue scrolling (kinetically) at this point.  */
end_comment
begin_function
DECL|function|recognize
name|QGestureRecognizer
operator|::
name|Result
name|QFlickGestureRecognizer
operator|::
name|recognize
parameter_list|(
name|QGesture
modifier|*
name|state
parameter_list|,
name|QObject
modifier|*
name|watched
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|watched
argument_list|)
expr_stmt|;
specifier|static
name|QElapsedTimer
name|monotonicTimer
decl_stmt|;
if|if
condition|(
operator|!
name|monotonicTimer
operator|.
name|isValid
argument_list|()
condition|)
name|monotonicTimer
operator|.
name|start
argument_list|()
expr_stmt|;
name|QFlickGesture
modifier|*
name|q
init|=
cast|static_cast
argument_list|<
name|QFlickGesture
operator|*
argument_list|>
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|QFlickGesturePrivate
modifier|*
name|d
init|=
name|q
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QScroller
modifier|*
name|scroller
init|=
name|d
operator|->
name|receiverScroller
decl_stmt|;
if|if
condition|(
operator|!
name|scroller
condition|)
return|return
name|Ignore
return|;
comment|// nothing to do without a scroller?
name|QWidget
modifier|*
name|receiverWidget
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|receiver
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QGraphicsObject
modifier|*
name|receiverGraphicsObject
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|receiver
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|// this is only set for events that we inject into the event loop via sendEvent()
if|if
condition|(
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|shouldEventBeIgnored
argument_list|(
name|event
argument_list|)
condition|)
block|{
comment|//qFGDebug()<< state<< "QFG: ignored event: "<< event->type();
return|return
name|Ignore
return|;
block|}
specifier|const
name|QMouseEvent
modifier|*
name|me
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
specifier|const
name|QGraphicsSceneMouseEvent
modifier|*
name|gsme
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|const
name|QTouchEvent
modifier|*
name|te
init|=
literal|0
decl_stmt|;
name|QPoint
name|globalPos
decl_stmt|;
comment|// qFGDebug()<< "FlickGesture "<<state<<"watched:"<<watched<<"receiver"<<d->receiver<<"event"<<event->type()<<"button"<<button;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
if|if
condition|(
operator|!
name|receiverWidget
condition|)
return|return
name|Ignore
return|;
if|if
condition|(
name|button
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
block|{
name|me
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|globalPos
operator|=
name|me
operator|->
name|globalPos
argument_list|()
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
if|if
condition|(
operator|!
name|receiverGraphicsObject
condition|)
return|return
name|Ignore
return|;
if|if
condition|(
name|button
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
block|{
name|gsme
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|globalPos
operator|=
name|gsme
operator|->
name|screenPos
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
if|if
condition|(
name|button
operator|==
name|Qt
operator|::
name|NoButton
condition|)
block|{
name|te
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|globalPos
operator|=
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
comment|// the only way to distinguish between real mouse wheels and wheel
comment|// events generated by the native 2 finger swipe gesture is to listen
comment|// for these events (according to Apple's Cocoa Event-Handling Guide)
case|case
name|QEvent
operator|::
name|NativeGesture
case|:
block|{
name|QNativeGestureEvent
modifier|*
name|nge
init|=
cast|static_cast
argument_list|<
name|QNativeGestureEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|nge
operator|->
name|gestureType
operator|==
name|QNativeGestureEvent
operator|::
name|GestureBegin
condition|)
name|d
operator|->
name|macIgnoreWheel
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|nge
operator|->
name|gestureType
operator|==
name|QNativeGestureEvent
operator|::
name|GestureEnd
condition|)
name|d
operator|->
name|macIgnoreWheel
operator|=
literal|false
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|// consume all wheel events if the scroller is active
case|case
name|QEvent
operator|::
name|Wheel
case|:
if|if
condition|(
name|d
operator|->
name|macIgnoreWheel
operator|||
operator|(
name|scroller
operator|->
name|state
argument_list|()
operator|!=
name|QScroller
operator|::
name|Inactive
operator|)
condition|)
return|return
name|Ignore
operator||
name|ConsumeEventHint
return|;
break|break;
comment|// consume all dbl click events if the scroller is active
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
if|if
condition|(
name|scroller
operator|->
name|state
argument_list|()
operator|!=
name|QScroller
operator|::
name|Inactive
condition|)
return|return
name|Ignore
operator||
name|ConsumeEventHint
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|me
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|&&
operator|!
name|gsme
endif|#
directive|endif
operator|&&
operator|!
name|te
condition|)
comment|// Neither mouse nor touch
return|return
name|Ignore
return|;
comment|// get the current pointer position in local coordinates.
name|QPointF
name|point
decl_stmt|;
name|QScroller
operator|::
name|Input
name|inputType
init|=
operator|(
name|QScroller
operator|::
name|Input
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
if|if
condition|(
name|me
operator|&&
name|me
operator|->
name|button
argument_list|()
operator|==
name|button
operator|&&
name|me
operator|->
name|buttons
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|me
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputPress
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|me
condition|)
block|{
name|scroller
operator|->
name|stop
argument_list|()
expr_stmt|;
return|return
name|CancelGesture
return|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
if|if
condition|(
name|me
operator|&&
name|me
operator|->
name|button
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|me
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputRelease
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|MouseMove
case|:
if|if
condition|(
name|me
operator|&&
name|me
operator|->
name|buttons
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|me
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputMove
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
if|if
condition|(
name|gsme
operator|&&
name|gsme
operator|->
name|button
argument_list|()
operator|==
name|button
operator|&&
name|gsme
operator|->
name|buttons
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|gsme
operator|->
name|scenePos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputPress
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gsme
condition|)
block|{
name|scroller
operator|->
name|stop
argument_list|()
expr_stmt|;
return|return
name|CancelGesture
return|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
if|if
condition|(
name|gsme
operator|&&
name|gsme
operator|->
name|button
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|gsme
operator|->
name|scenePos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputRelease
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
if|if
condition|(
name|gsme
operator|&&
name|gsme
operator|->
name|buttons
argument_list|()
operator|==
name|button
condition|)
block|{
name|point
operator|=
name|gsme
operator|->
name|scenePos
argument_list|()
expr_stmt|;
name|inputType
operator|=
name|QScroller
operator|::
name|InputMove
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
name|inputType
operator|=
name|QScroller
operator|::
name|InputPress
expr_stmt|;
comment|// fall through
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
if|if
condition|(
operator|!
name|inputType
condition|)
name|inputType
operator|=
name|QScroller
operator|::
name|InputRelease
expr_stmt|;
comment|// fallthrough
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
if|if
condition|(
operator|!
name|inputType
condition|)
name|inputType
operator|=
name|QScroller
operator|::
name|InputMove
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|device
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
if|if
condition|(
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
operator|!=
literal|2
condition|)
comment|// 2 fingers on pad
return|return
name|Ignore
return|;
name|point
operator|=
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|startScenePos
argument_list|()
operator|+
operator|(
operator|(
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|scenePos
argument_list|()
operator|-
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|startScenePos
argument_list|()
operator|)
operator|+
operator|(
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|scenePos
argument_list|()
operator|-
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|startScenePos
argument_list|()
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// TouchScreen
if|if
condition|(
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
comment|// 1 finger on screen
return|return
name|Ignore
return|;
name|point
operator|=
name|te
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|scenePos
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// Check for an active scroller at globalPos
if|if
condition|(
name|inputType
operator|==
name|QScroller
operator|::
name|InputPress
condition|)
block|{
foreach|foreach
control|(
name|QScroller
modifier|*
name|as
decl|,
name|QScroller
operator|::
name|activeScrollers
argument_list|()
control|)
block|{
if|if
condition|(
name|as
operator|!=
name|scroller
condition|)
block|{
name|QRegion
name|scrollerRegion
decl_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|as
operator|->
name|target
argument_list|()
argument_list|)
condition|)
block|{
name|scrollerRegion
operator|=
name|QRect
argument_list|(
name|w
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|w
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
block|}
elseif|else
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|as
operator|->
name|target
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|go
operator|->
name|scene
argument_list|()
operator|&&
operator|!
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|gv
decl|,
name|go
operator|->
name|scene
argument_list|()
operator|->
name|views
argument_list|()
control|)
name|scrollerRegion
operator||=
name|gv
operator|->
name|mapFromScene
argument_list|(
name|go
operator|->
name|mapToScene
argument_list|(
name|go
operator|->
name|boundingRect
argument_list|()
argument_list|)
argument_list|)
operator|.
name|translated
argument_list|(
name|gv
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|// active scrollers always have priority
if|if
condition|(
name|scrollerRegion
operator|.
name|contains
argument_list|(
name|globalPos
argument_list|)
condition|)
return|return
name|Ignore
return|;
block|}
block|}
block|}
name|bool
name|scrollerWasDragging
init|=
operator|(
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Dragging
operator|)
decl_stmt|;
name|bool
name|scrollerWasScrolling
init|=
operator|(
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Scrolling
operator|)
decl_stmt|;
if|if
condition|(
name|inputType
condition|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|receiver
argument_list|)
condition|)
name|point
operator|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|point
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
elseif|else
if|if
condition|(
name|QGraphicsObject
modifier|*
name|go
init|=
name|qobject_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|receiver
argument_list|)
condition|)
name|point
operator|=
name|go
operator|->
name|mapFromScene
argument_list|(
name|point
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// inform the scroller about the new event
name|scroller
operator|->
name|handleInput
argument_list|(
name|inputType
argument_list|,
name|point
argument_list|,
name|monotonicTimer
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// depending on the scroller state return the gesture state
name|Result
name|result
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|bool
name|scrollerIsActive
init|=
operator|(
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Dragging
operator|||
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Scrolling
operator|)
decl_stmt|;
comment|// Consume all mouse events while dragging or scrolling to avoid nasty
comment|// side effects with Qt's standard widgets.
if|if
condition|(
operator|(
name|me
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
name|gsme
endif|#
directive|endif
operator|)
operator|&&
name|scrollerIsActive
condition|)
name|result
operator||=
name|ConsumeEventHint
expr_stmt|;
comment|// The only problem with this approach is that we consume the
comment|// MouseRelease when we start the scrolling with a flick gesture, so we
comment|// have to fake a MouseRelease "somewhere" to not mess with the internal
comment|// states of Qt's widgets (a QPushButton would stay in 'pressed' state
comment|// forever, if it doesn't receive a MouseRelease).
if|if
condition|(
name|me
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
name|gsme
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|scrollerWasDragging
operator|&&
operator|!
name|scrollerWasScrolling
operator|&&
name|scrollerIsActive
condition|)
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|scrollerBecameActive
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|scrollerWasScrolling
operator|&&
operator|(
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Dragging
operator|||
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Inactive
operator|)
condition|)
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|scrollerWasIntercepted
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inputType
condition|)
block|{
name|result
operator||=
name|Ignore
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
endif|#
directive|endif
if|if
condition|(
name|scroller
operator|->
name|state
argument_list|()
operator|==
name|QScroller
operator|::
name|Pressed
condition|)
block|{
name|int
name|pressDelay
init|=
name|int
argument_list|(
literal|1000
operator|*
name|scroller
operator|->
name|scrollerProperties
argument_list|()
operator|.
name|scrollMetric
argument_list|(
name|QScrollerProperties
operator|::
name|MousePressEventDelay
argument_list|)
operator|.
name|toReal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pressDelay
operator|>
literal|0
condition|)
block|{
name|result
operator||=
name|ConsumeEventHint
expr_stmt|;
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|pressed
argument_list|(
name|event
argument_list|,
name|pressDelay
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
block|}
comment|// fall through
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
name|q
operator|->
name|setHotSpot
argument_list|(
name|globalPos
argument_list|)
expr_stmt|;
name|result
operator||=
name|scrollerIsActive
condition|?
name|TriggerGesture
else|:
name|MayBeGesture
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseMove
case|:
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
endif|#
directive|endif
if|if
condition|(
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|isDelaying
argument_list|()
condition|)
name|result
operator||=
name|ConsumeEventHint
expr_stmt|;
comment|// fall through
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
name|result
operator||=
name|scrollerIsActive
condition|?
name|TriggerGesture
else|:
name|Ignore
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
if|if
condition|(
name|PressDelayHandler
operator|::
name|instance
argument_list|()
operator|->
name|released
argument_list|(
name|event
argument_list|,
name|scrollerWasDragging
operator|||
name|scrollerWasScrolling
argument_list|,
name|scrollerIsActive
argument_list|)
condition|)
name|result
operator||=
name|ConsumeEventHint
expr_stmt|;
comment|// fall through
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
name|result
operator||=
name|scrollerIsActive
condition|?
name|FinishGesture
else|:
name|CancelGesture
expr_stmt|;
break|break;
default|default:
name|result
operator||=
name|Ignore
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|reset
name|void
name|QFlickGestureRecognizer
operator|::
name|reset
parameter_list|(
name|QGesture
modifier|*
name|state
parameter_list|)
block|{
name|QGestureRecognizer
operator|::
name|reset
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
end_unit
