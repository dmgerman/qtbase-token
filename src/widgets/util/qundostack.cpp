begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qundostack.h"
end_include
begin_include
include|#
directive|include
file|"qundogroup.h"
end_include
begin_include
include|#
directive|include
file|"qundostack_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_UNDOCOMMAND
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QUndoCommand     \brief The QUndoCommand class is the base class of all commands stored on a QUndoStack.     \since 4.2      \inmodule QtWidgets      For an overview of Qt's Undo Framework, see the     \l{Overview of Qt's Undo Framework}{overview document}.      A QUndoCommand represents a single editing action on a document; for example,     inserting or deleting a block of text in a text editor. QUndoCommand can apply     a change to the document with redo() and undo the change with undo(). The     implementations for these functions must be provided in a derived class.      \snippet code/src_gui_util_qundostack.cpp 0      A QUndoCommand has an associated text(). This is a short string     describing what the command does. It is used to update the text     properties of the stack's undo and redo actions; see     QUndoStack::createUndoAction() and QUndoStack::createRedoAction().      QUndoCommand objects are owned by the stack they were pushed on.     QUndoStack deletes a command if it has been undone and a new command is pushed. For example:  \snippet code/src_gui_util_qundostack.cpp 1      In effect, when a command is pushed, it becomes the top-most command     on the stack.      To support command compression, QUndoCommand has an id() and the virtual function     mergeWith(). These functions are used by QUndoStack::push().      To support command macros, a QUndoCommand object can have any number of child     commands. Undoing or redoing the parent command will cause the child     commands to be undone or redone. A command can be assigned     to a parent explicitly in the constructor. In this case, the command     will be owned by the parent.      The parent in this case is usually an empty command, in that it doesn't     provide its own implementation of undo() and redo(). Instead, it uses     the base implementations of these functions, which simply call undo() or     redo() on all its children. The parent should, however, have a meaningful     text().      \snippet code/src_gui_util_qundostack.cpp 2      Another way to create macros is to use the convenience functions     QUndoStack::beginMacro() and QUndoStack::endMacro().      \sa QUndoStack */
comment|/*!     Constructs a QUndoCommand object with the given \a parent and \a text.      If \a parent is not 0, this command is appended to parent's child list.     The parent command then owns this command and will delete it in its     destructor.      \sa ~QUndoCommand() */
DECL|function|QUndoCommand
name|QUndoCommand
operator|::
name|QUndoCommand
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QUndoCommand
modifier|*
name|parent
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QUndoCommandPrivate
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|0
condition|)
name|parent
operator|->
name|d
operator|->
name|child_list
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QUndoCommand object with parent \a parent.      If \a parent is not 0, this command is appended to parent's child list.     The parent command then owns this command and will delete it in its     destructor.      \sa ~QUndoCommand() */
end_comment
begin_constructor
DECL|function|QUndoCommand
name|QUndoCommand
operator|::
name|QUndoCommand
parameter_list|(
name|QUndoCommand
modifier|*
name|parent
parameter_list|)
block|{
name|d
operator|=
operator|new
name|QUndoCommandPrivate
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|0
condition|)
name|parent
operator|->
name|d
operator|->
name|child_list
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QUndoCommand object and all child commands.      \sa QUndoCommand() */
end_comment
begin_destructor
DECL|function|~QUndoCommand
name|QUndoCommand
operator|::
name|~
name|QUndoCommand
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|d
operator|->
name|child_list
argument_list|)
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the ID of this command.      A command ID is used in command compression. It must be an integer unique to     this command's class, or -1 if the command doesn't support compression.      If the command supports compression this function must be overridden in the     derived class to return the correct ID. The base implementation returns -1.      QUndoStack::push() will only try to merge two commands if they have the     same ID, and the ID is not -1.      \sa mergeWith(), QUndoStack::push() */
end_comment
begin_function
DECL|function|id
name|int
name|QUndoCommand
operator|::
name|id
parameter_list|()
specifier|const
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to merge this command with \a command. Returns true on     success; otherwise returns false.      If this function returns true, calling this command's redo() must have the same     effect as redoing both this command and \a command.     Similarly, calling this command's undo() must have the same effect as undoing     \a command and this command.      QUndoStack will only try to merge two commands if they have the same id, and     the id is not -1.      The default implementation returns false.      \snippet code/src_gui_util_qundostack.cpp 3      \sa id(), QUndoStack::push() */
end_comment
begin_function
DECL|function|mergeWith
name|bool
name|QUndoCommand
operator|::
name|mergeWith
parameter_list|(
specifier|const
name|QUndoCommand
modifier|*
name|command
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Applies a change to the document. This function must be implemented in     the derived class. Calling QUndoStack::push(),     QUndoStack::undo() or QUndoStack::redo() from this function leads to     undefined beahavior.      The default implementation calls redo() on all child commands.      \sa undo() */
end_comment
begin_function
DECL|function|redo
name|void
name|QUndoCommand
operator|::
name|redo
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|child_list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|child_list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|redo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reverts a change to the document. After undo() is called, the state of     the document should be the same as before redo() was called. This function must     be implemented in the derived class. Calling QUndoStack::push(),     QUndoStack::undo() or QUndoStack::redo() from this function leads to     undefined beahavior.      The default implementation calls undo() on all child commands in reverse order.      \sa redo() */
end_comment
begin_function
DECL|function|undo
name|void
name|QUndoCommand
operator|::
name|undo
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|child_list
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|d
operator|->
name|child_list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|undo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a short text string describing what this command does; for example,     "insert text".      The text is used for names of items in QUndoView.      \sa actionText(), setText(), QUndoStack::createUndoAction(), QUndoStack::createRedoAction() */
end_comment
begin_function
DECL|function|text
name|QString
name|QUndoCommand
operator|::
name|text
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a short text string describing what this command does; for example,     "insert text".      The text is used when the text properties of the stack's undo and redo     actions are updated.      \sa text(), setText(), QUndoStack::createUndoAction(), QUndoStack::createRedoAction() */
end_comment
begin_function
DECL|function|actionText
name|QString
name|QUndoCommand
operator|::
name|actionText
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|actionText
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the command's text to be the \a text specified.      The specified text should be a short user-readable string describing what this     command does.      If you need to have two different strings for text() and actionText(), separate     them with "\\n" and pass into this function. Even if you do not use this feature     for English strings during development, you can still let translators use two     different strings in order to match specific languages' needs.     The described feature and the function actionText() are available since Qt 4.8.      \sa text(), actionText(), QUndoStack::createUndoAction(), QUndoStack::createRedoAction() */
end_comment
begin_function
DECL|function|setText
name|void
name|QUndoCommand
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|int
name|cdpos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdpos
operator|>
literal|0
condition|)
block|{
name|d
operator|->
name|text
operator|=
name|text
operator|.
name|left
argument_list|(
name|cdpos
argument_list|)
expr_stmt|;
name|d
operator|->
name|actionText
operator|=
name|text
operator|.
name|mid
argument_list|(
name|cdpos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|actionText
operator|=
name|text
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the number of child commands in this command.      \sa child() */
end_comment
begin_function
DECL|function|childCount
name|int
name|QUndoCommand
operator|::
name|childCount
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|child_list
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the child command at \a index.      \sa childCount(), QUndoStack::command() */
end_comment
begin_function
DECL|function|child
specifier|const
name|QUndoCommand
modifier|*
name|QUndoCommand
operator|::
name|child
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|child_list
operator|.
name|count
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|child_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_UNDOCOMMAND
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_UNDOSTACK
end_ifndef
begin_comment
comment|/*!     \class QUndoStack     \brief The QUndoStack class is a stack of QUndoCommand objects.     \since 4.2      \inmodule QtWidgets      For an overview of Qt's Undo Framework, see the     \l{Overview of Qt's Undo Framework}{overview document}.      An undo stack maintains a stack of commands that have been applied to a     document.      New commands are pushed on the stack using push(). Commands can be     undone and redone using undo() and redo(), or by triggering the     actions returned by createUndoAction() and createRedoAction().      QUndoStack keeps track of the \a current command. This is the command     which will be executed by the next call to redo(). The index of this     command is returned by index(). The state of the edited object can be     rolled forward or back using setIndex(). If the top-most command on the     stack has already been redone, index() is equal to count().      QUndoStack provides support for undo and redo actions, command     compression, command macros, and supports the concept of a     \e{clean state}.      \section1 Undo and Redo Actions      QUndoStack provides convenient undo and redo QAction objects, which     can be inserted into a menu or a toolbar. When commands are undone or     redone, QUndoStack updates the text properties of these actions     to reflect what change they will trigger. The actions are also disabled     when no command is available for undo or redo. These actions     are returned by QUndoStack::createUndoAction() and QUndoStack::createRedoAction().      \section1 Command Compression and Macros      Command compression is useful when several commands can be compressed     into a single command that can be undone and redone in a single operation.     For example, when a user types a character in a text editor, a new command     is created. This command inserts the character into the document at the     cursor position. However, it is more convenient for the user to be able     to undo or redo typing of whole words, sentences, or paragraphs.     Command compression allows these single-character commands to be merged     into a single command which inserts or deletes sections of text.     For more information, see QUndoCommand::mergeWith() and push().      A command macro is a sequence of commands, all of which are undone and     redone in one go. Command macros are created by giving a command a list     of child commands.     Undoing or redoing the parent command will cause the child commands to     be undone or redone. Command macros may be created explicitly     by specifying a parent in the QUndoCommand constructor, or by using the     convenience functions beginMacro() and endMacro().      Although command compression and macros appear to have the same effect to the     user, they often have different uses in an application. Commands that     perform small changes to a document may be usefully compressed if there is     no need to individually record them, and if only larger changes are relevant     to the user.     However, for commands that need to be recorded individually, or those that     cannot be compressed, it is useful to use macros to provide a more convenient     user experience while maintaining a record of each command.      \section1 Clean State      QUndoStack supports the concept of a clean state. When the     document is saved to disk, the stack can be marked as clean using     setClean(). Whenever the stack returns to this state through undoing and     redoing commands, it emits the signal cleanChanged(). This signal     is also emitted when the stack leaves the clean state. This signal is     usually used to enable and disable the save actions in the application,     and to update the document's title to reflect that it contains unsaved     changes.      \sa QUndoCommand, QUndoView */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACTION
end_ifndef
begin_constructor
DECL|function|QUndoAction
name|QUndoAction
operator|::
name|QUndoAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAction
argument_list|(
name|parent
argument_list|)
block|{
name|m_prefix
operator|=
name|prefix
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|setPrefixedText
name|void
name|QUndoAction
operator|::
name|setPrefixedText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|m_defaultText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|s
init|=
name|m_prefix
decl_stmt|;
if|if
condition|(
operator|!
name|m_prefix
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|setText
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
name|setText
argument_list|(
name|m_defaultText
argument_list|)
expr_stmt|;
else|else
name|setText
argument_list|(
name|m_prefix
operator|.
name|arg
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setTextFormat
name|void
name|QUndoAction
operator|::
name|setTextFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|textFormat
parameter_list|,
specifier|const
name|QString
modifier|&
name|defaultText
parameter_list|)
block|{
name|m_prefix
operator|=
name|textFormat
expr_stmt|;
name|m_defaultText
operator|=
name|defaultText
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ACTION
end_comment
begin_comment
comment|/*! \internal     Sets the current index to \a idx, emitting appropriate signals. If \a clean is true,     makes \a idx the clean index as well. */
end_comment
begin_function
DECL|function|setIndex
name|void
name|QUndoStackPrivate
operator|::
name|setIndex
parameter_list|(
name|int
name|idx
parameter_list|,
name|bool
name|clean
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
name|bool
name|was_clean
init|=
name|index
operator|==
name|clean_index
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
name|index
condition|)
block|{
name|index
operator|=
name|idx
expr_stmt|;
emit|emit
name|q
operator|->
name|indexChanged
argument_list|(
name|index
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|canUndoChanged
argument_list|(
name|q
operator|->
name|canUndo
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|undoTextChanged
argument_list|(
name|q
operator|->
name|undoText
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|canRedoChanged
argument_list|(
name|q
operator|->
name|canRedo
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|redoTextChanged
argument_list|(
name|q
operator|->
name|redoText
argument_list|()
argument_list|)
emit|;
block|}
if|if
condition|(
name|clean
condition|)
name|clean_index
operator|=
name|index
expr_stmt|;
name|bool
name|is_clean
init|=
name|index
operator|==
name|clean_index
decl_stmt|;
if|if
condition|(
name|is_clean
operator|!=
name|was_clean
condition|)
emit|emit
name|q
operator|->
name|cleanChanged
argument_list|(
name|is_clean
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*! \internal     If the number of commands on the stack exceedes the undo limit, deletes commands from     the bottom of the stack.      Returns true if commands were deleted. */
end_comment
begin_function
DECL|function|checkUndoLimit
name|bool
name|QUndoStackPrivate
operator|::
name|checkUndoLimit
parameter_list|()
block|{
if|if
condition|(
name|undo_limit
operator|<=
literal|0
operator|||
operator|!
name|macro_stack
operator|.
name|isEmpty
argument_list|()
operator|||
name|undo_limit
operator|>=
name|command_list
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|del_count
init|=
name|command_list
operator|.
name|count
argument_list|()
operator|-
name|undo_limit
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|del_count
condition|;
operator|++
name|i
control|)
operator|delete
name|command_list
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
name|index
operator|-=
name|del_count
expr_stmt|;
if|if
condition|(
name|clean_index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|clean_index
operator|<
name|del_count
condition|)
name|clean_index
operator|=
operator|-
literal|1
expr_stmt|;
comment|// we've deleted the clean command
else|else
name|clean_index
operator|-=
name|del_count
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an empty undo stack with the parent \a parent. The     stack will initially be in the clean state. If \a parent is a     QUndoGroup object, the stack is automatically added to the group.      \sa push() */
end_comment
begin_constructor
DECL|function|QUndoStack
name|QUndoStack
operator|::
name|QUndoStack
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QUndoStackPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_UNDOGROUP
if|if
condition|(
name|QUndoGroup
modifier|*
name|group
init|=
name|qobject_cast
argument_list|<
name|QUndoGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
name|group
operator|->
name|addStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destroys the undo stack, deleting any commands that are on it. If the     stack is in a QUndoGroup, the stack is automatically removed from the group.      \sa QUndoStack() */
end_comment
begin_destructor
DECL|function|~QUndoStack
name|QUndoStack
operator|::
name|~
name|QUndoStack
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_UNDOGROUP
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
operator|!=
literal|0
condition|)
name|d
operator|->
name|group
operator|->
name|removeStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Clears the command stack by deleting all commands on it, and returns the stack     to the clean state.      Commands are not undone or redone; the state of the edited object remains     unchanged.      This function is usually used when the contents of the document are     abandoned.      \sa QUndoStack() */
end_comment
begin_function
DECL|function|clear
name|void
name|QUndoStack
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|command_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|bool
name|was_clean
init|=
name|isClean
argument_list|()
decl_stmt|;
name|d
operator|->
name|macro_stack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|command_list
argument_list|)
expr_stmt|;
name|d
operator|->
name|command_list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clean_index
operator|=
literal|0
expr_stmt|;
emit|emit
name|indexChanged
argument_list|(
literal|0
argument_list|)
emit|;
emit|emit
name|canUndoChanged
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|undoTextChanged
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
emit|emit
name|canRedoChanged
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|redoTextChanged
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
if|if
condition|(
operator|!
name|was_clean
condition|)
emit|emit
name|cleanChanged
argument_list|(
literal|true
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Pushes \a cmd on the stack or merges it with the most recently executed command.     In either case, executes \a cmd by calling its redo() function.      If \a cmd's id is not -1, and if the id is the same as that of the     most recently executed command, QUndoStack will attempt to merge the two     commands by calling QUndoCommand::mergeWith() on the most recently executed     command. If QUndoCommand::mergeWith() returns true, \a cmd is deleted.      In all other cases \a cmd is simply pushed on the stack.      If commands were undone before \a cmd was pushed, the current command and     all commands above it are deleted. Hence \a cmd always ends up being the     top-most on the stack.      Once a command is pushed, the stack takes ownership of it. There     are no getters to return the command, since modifying it after it has     been executed will almost always lead to corruption of the document's     state.      \sa QUndoCommand::id(), QUndoCommand::mergeWith() */
end_comment
begin_function
DECL|function|push
name|void
name|QUndoStack
operator|::
name|push
parameter_list|(
name|QUndoCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|redo
argument_list|()
expr_stmt|;
name|bool
name|macro
init|=
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|QUndoCommand
modifier|*
name|cur
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|macro
condition|)
block|{
name|QUndoCommand
modifier|*
name|macro_cmd
init|=
name|d
operator|->
name|macro_stack
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|macro_cmd
operator|->
name|d
operator|->
name|child_list
operator|.
name|isEmpty
argument_list|()
condition|)
name|cur
operator|=
name|macro_cmd
operator|->
name|d
operator|->
name|child_list
operator|.
name|last
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|index
operator|>
literal|0
condition|)
name|cur
operator|=
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|d
operator|->
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|index
operator|<
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
operator|delete
name|d
operator|->
name|command_list
operator|.
name|takeLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clean_index
operator|>
name|d
operator|->
name|index
condition|)
name|d
operator|->
name|clean_index
operator|=
operator|-
literal|1
expr_stmt|;
comment|// we've deleted the clean state
block|}
name|bool
name|try_merge
init|=
name|cur
operator|!=
literal|0
operator|&&
name|cur
operator|->
name|id
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|cur
operator|->
name|id
argument_list|()
operator|==
name|cmd
operator|->
name|id
argument_list|()
operator|&&
operator|(
name|macro
operator|||
name|d
operator|->
name|index
operator|!=
name|d
operator|->
name|clean_index
operator|)
decl_stmt|;
if|if
condition|(
name|try_merge
operator|&&
name|cur
operator|->
name|mergeWith
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
operator|delete
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|macro
condition|)
block|{
emit|emit
name|indexChanged
argument_list|(
name|d
operator|->
name|index
argument_list|)
emit|;
emit|emit
name|canUndoChanged
argument_list|(
name|canUndo
argument_list|()
argument_list|)
emit|;
emit|emit
name|undoTextChanged
argument_list|(
name|undoText
argument_list|()
argument_list|)
emit|;
emit|emit
name|canRedoChanged
argument_list|(
name|canRedo
argument_list|()
argument_list|)
emit|;
emit|emit
name|redoTextChanged
argument_list|(
name|redoText
argument_list|()
argument_list|)
emit|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|macro
condition|)
block|{
name|d
operator|->
name|macro_stack
operator|.
name|last
argument_list|()
operator|->
name|d
operator|->
name|child_list
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|command_list
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|d
operator|->
name|checkUndoLimit
argument_list|()
expr_stmt|;
name|d
operator|->
name|setIndex
argument_list|(
name|d
operator|->
name|index
operator|+
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Marks the stack as clean and emits cleanChanged() if the stack was     not already clean.      Whenever the stack returns to this state through the use of undo/redo     commands, it emits the signal cleanChanged(). This signal is also     emitted when the stack leaves the clean state.      \sa isClean(), cleanIndex() */
end_comment
begin_function
DECL|function|setClean
name|void
name|QUndoStack
operator|::
name|setClean
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::setClean(): cannot set clean in the middle of a macro"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setIndex
argument_list|(
name|d
operator|->
name|index
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the stack is in the clean state, returns true; otherwise returns false.      \sa setClean(), cleanIndex() */
end_comment
begin_function
DECL|function|isClean
name|bool
name|QUndoStack
operator|::
name|isClean
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|clean_index
operator|==
name|d
operator|->
name|index
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the clean index. This is the index at which setClean() was called.      A stack may not have a clean index. This happens if a document is saved,     some commands are undone, then a new command is pushed. Since     push() deletes all the undone commands before pushing the new command, the stack     can't return to the clean state again. In this case, this function returns -1.      \sa isClean(), setClean() */
end_comment
begin_function
DECL|function|cleanIndex
name|int
name|QUndoStack
operator|::
name|cleanIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|clean_index
return|;
block|}
end_function
begin_comment
comment|/*!     Undoes the command below the current command by calling QUndoCommand::undo().     Decrements the current command index.      If the stack is empty, or if the bottom command on the stack has already been     undone, this function does nothing.      \sa redo(), index() */
end_comment
begin_function
DECL|function|undo
name|void
name|QUndoStack
operator|::
name|undo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|index
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::undo(): cannot undo in the middle of a macro"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|idx
init|=
name|d
operator|->
name|index
operator|-
literal|1
decl_stmt|;
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|->
name|undo
argument_list|()
expr_stmt|;
name|d
operator|->
name|setIndex
argument_list|(
name|idx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Redoes the current command by calling QUndoCommand::redo(). Increments the current     command index.      If the stack is empty, or if the top command on the stack has already been     redone, this function does nothing.      \sa undo(), index() */
end_comment
begin_function
DECL|function|redo
name|void
name|QUndoStack
operator|::
name|redo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|index
operator|==
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::redo(): cannot redo in the middle of a macro"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|d
operator|->
name|index
argument_list|)
operator|->
name|redo
argument_list|()
expr_stmt|;
name|d
operator|->
name|setIndex
argument_list|(
name|d
operator|->
name|index
operator|+
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of commands on the stack. Macro commands are counted as     one command.      \sa index(), setIndex(), command() */
end_comment
begin_function
DECL|function|count
name|int
name|QUndoStack
operator|::
name|count
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the current command. This is the command that will be     executed on the next call to redo(). It is not always the top-most command     on the stack, since a number of commands may have been undone.      \sa undo(), redo(), count() */
end_comment
begin_function
DECL|function|index
name|int
name|QUndoStack
operator|::
name|index
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
return|;
block|}
end_function
begin_comment
comment|/*!     Repeatedly calls undo() or redo() until the current command index reaches     \a idx. This function can be used to roll the state of the document forwards     of backwards. indexChanged() is emitted only once.      \sa index(), count(), undo(), redo() */
end_comment
begin_function
DECL|function|setIndex
name|void
name|QUndoStack
operator|::
name|setIndex
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::setIndex(): cannot set index in the middle of a macro"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|>
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
name|idx
operator|=
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|i
init|=
name|d
operator|->
name|index
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|idx
condition|)
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
operator|->
name|redo
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|>
name|idx
condition|)
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
operator|--
name|i
argument_list|)
operator|->
name|undo
argument_list|()
expr_stmt|;
name|d
operator|->
name|setIndex
argument_list|(
name|idx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is a command available for undo; otherwise returns false.      This function returns false if the stack is empty, or if the bottom command     on the stack has already been undone.      Synonymous with index() == 0.      \sa index(), canRedo() */
end_comment
begin_function
DECL|function|canUndo
name|bool
name|QUndoStack
operator|::
name|canUndo
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|index
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is a command available for redo; otherwise returns false.      This function returns false if the stack is empty or if the top command     on the stack has already been redone.      Synonymous with index() == count().      \sa index(), canUndo() */
end_comment
begin_function
DECL|function|canRedo
name|bool
name|QUndoStack
operator|::
name|canRedo
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|index
operator|<
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text of the command which will be undone in the next call to undo().      \sa QUndoCommand::actionText(), redoText() */
end_comment
begin_function
DECL|function|undoText
name|QString
name|QUndoStack
operator|::
name|undoText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|index
operator|>
literal|0
condition|)
return|return
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|d
operator|->
name|index
operator|-
literal|1
argument_list|)
operator|->
name|actionText
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text of the command which will be redone in the next call to redo().      \sa QUndoCommand::actionText(), undoText() */
end_comment
begin_function
DECL|function|redoText
name|QString
name|QUndoStack
operator|::
name|redoText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|index
operator|<
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
return|return
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|d
operator|->
name|index
argument_list|)
operator|->
name|actionText
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACTION
end_ifndef
begin_comment
comment|/*!     Creates an undo QAction object with the given \a parent.      Triggering this action will cause a call to undo(). The text of this action     is the text of the command which will be undone in the next call to undo(),     prefixed by the specified \a prefix. If there is no command available for undo,     this action will be disabled.      If \a prefix is empty, the default template "Undo %1" is used instead of prefix.     Before Qt 4.8, the prefix "Undo" was used by default.      \sa createRedoAction(), canUndo(), QUndoCommand::text() */
end_comment
begin_function
DECL|function|createUndoAction
name|QAction
modifier|*
name|QUndoStack
operator|::
name|createUndoAction
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
specifier|const
block|{
name|QUndoAction
modifier|*
name|result
init|=
operator|new
name|QUndoAction
argument_list|(
name|prefix
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|->
name|setTextFormat
argument_list|(
name|tr
argument_list|(
literal|"Undo %1"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Undo"
argument_list|,
literal|"Default text for undo action"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|setEnabled
argument_list|(
name|canUndo
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|->
name|setPrefixedText
argument_list|(
name|undoText
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|canUndoChanged
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|SLOT
argument_list|(
name|setEnabled
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|undoTextChanged
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|SLOT
argument_list|(
name|setPrefixedText
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|result
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|undo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Creates an redo QAction object with the given \a parent.      Triggering this action will cause a call to redo(). The text of this action     is the text of the command which will be redone in the next call to redo(),     prefixed by the specified \a prefix. If there is no command available for redo,     this action will be disabled.      If \a prefix is empty, the default template "Redo %1" is used instead of prefix.     Before Qt 4.8, the prefix "Redo" was used by default.      \sa createUndoAction(), canRedo(), QUndoCommand::text() */
end_comment
begin_function
DECL|function|createRedoAction
name|QAction
modifier|*
name|QUndoStack
operator|::
name|createRedoAction
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
specifier|const
block|{
name|QUndoAction
modifier|*
name|result
init|=
operator|new
name|QUndoAction
argument_list|(
name|prefix
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|->
name|setTextFormat
argument_list|(
name|tr
argument_list|(
literal|"Redo %1"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Redo"
argument_list|,
literal|"Default text for redo action"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|setEnabled
argument_list|(
name|canRedo
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|->
name|setPrefixedText
argument_list|(
name|redoText
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|canRedoChanged
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|SLOT
argument_list|(
name|setEnabled
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|redoTextChanged
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|SLOT
argument_list|(
name|setPrefixedText
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|result
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|redo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ACTION
end_comment
begin_comment
comment|/*!     Begins composition of a macro command with the given \a text description.      An empty command described by the specified \a text is pushed on the stack.     Any subsequent commands pushed on the stack will be appended to the empty     command's children until endMacro() is called.      Calls to beginMacro() and endMacro() may be nested, but every call to     beginMacro() must have a matching call to endMacro().      While a macro is composed, the stack is disabled. This means that:     \list     \li indexChanged() and cleanChanged() are not emitted,     \li canUndo() and canRedo() return false,     \li calling undo() or redo() has no effect,     \li the undo/redo actions are disabled.     \endlist      The stack becomes enabled and appropriate signals are emitted when endMacro()     is called for the outermost macro.      \snippet code/src_gui_util_qundostack.cpp 4      This code is equivalent to:      \snippet code/src_gui_util_qundostack.cpp 5      \sa endMacro() */
end_comment
begin_function
DECL|function|beginMacro
name|void
name|QUndoStack
operator|::
name|beginMacro
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
name|QUndoCommand
modifier|*
name|cmd
init|=
operator|new
name|QUndoCommand
argument_list|()
decl_stmt|;
name|cmd
operator|->
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
while|while
condition|(
name|d
operator|->
name|index
operator|<
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
operator|delete
name|d
operator|->
name|command_list
operator|.
name|takeLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clean_index
operator|>
name|d
operator|->
name|index
condition|)
name|d
operator|->
name|clean_index
operator|=
operator|-
literal|1
expr_stmt|;
comment|// we've deleted the clean state
name|d
operator|->
name|command_list
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|macro_stack
operator|.
name|last
argument_list|()
operator|->
name|d
operator|->
name|child_list
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|macro_stack
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|macro_stack
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
emit|emit
name|canUndoChanged
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|undoTextChanged
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
emit|emit
name|canRedoChanged
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|redoTextChanged
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     Ends composition of a macro command.      If this is the outermost macro in a set nested macros, this function emits     indexChanged() once for the entire macro command.      \sa beginMacro() */
end_comment
begin_function
DECL|function|endMacro
name|void
name|QUndoStack
operator|::
name|endMacro
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::endMacro(): no matching beginMacro()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|macro_stack
operator|.
name|removeLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|macro_stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|checkUndoLimit
argument_list|()
expr_stmt|;
name|d
operator|->
name|setIndex
argument_list|(
name|d
operator|->
name|index
operator|+
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Returns a const pointer to the command at \a index.    This function returns a const pointer, because modifying a command,   once it has been pushed onto the stack and executed, almost always   causes corruption of the state of the document, if the command is   later undone or redone.    \sa QUndoCommand::child() */
end_comment
begin_function
DECL|function|command
specifier|const
name|QUndoCommand
modifier|*
name|QUndoStack
operator|::
name|command
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|command_list
operator|.
name|count
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text of the command at index \a idx.      \sa beginMacro() */
end_comment
begin_function
DECL|function|text
name|QString
name|QUndoStack
operator|::
name|text
parameter_list|(
name|int
name|idx
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|d
operator|->
name|command_list
operator|.
name|size
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|command_list
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|->
name|text
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QUndoStack::undoLimit     \brief the maximum number of commands on this stack.     \since 4.3      When the number of commands on a stack exceedes the stack's undoLimit, commands are     deleted from the bottom of the stack. Macro commands (commands with child commands)     are treated as one command. The default value is 0, which means that there is no     limit.      This property may only be set when the undo stack is empty, since setting it on a     non-empty stack might delete the command at the current index. Calling setUndoLimit()     on a non-empty stack prints a warning and does nothing. */
end_comment
begin_function
DECL|function|setUndoLimit
name|void
name|QUndoStack
operator|::
name|setUndoLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|command_list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QUndoStack::setUndoLimit(): an undo limit can only be set when the stack is empty"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|limit
operator|==
name|d
operator|->
name|undo_limit
condition|)
return|return;
name|d
operator|->
name|undo_limit
operator|=
name|limit
expr_stmt|;
name|d
operator|->
name|checkUndoLimit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|undoLimit
name|int
name|QUndoStack
operator|::
name|undoLimit
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|undo_limit
return|;
block|}
end_function
begin_comment
comment|/*!     \property QUndoStack::active     \brief the active status of this stack.      An application often has multiple undo stacks, one for each opened document. The active     stack is the one associated with the currently active document. If the stack belongs     to a QUndoGroup, calls to QUndoGroup::undo() or QUndoGroup::redo() will be forwarded     to this stack when it is active. If the QUndoGroup is watched by a QUndoView, the view     will display the contents of this stack when it is active. If the stack does not belong to     a QUndoGroup, making it active has no effect.      It is the programmer's responsibility to specify which stack is active by     calling setActive(), usually when the associated document window receives focus.      \sa QUndoGroup */
end_comment
begin_function
DECL|function|setActive
name|void
name|QUndoStack
operator|::
name|setActive
parameter_list|(
name|bool
name|active
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_UNDOGROUP
name|Q_UNUSED
argument_list|(
name|active
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
name|QUndoStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|active
condition|)
name|d
operator|->
name|group
operator|->
name|setActiveStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|group
operator|->
name|activeStack
argument_list|()
operator|==
name|this
condition|)
name|d
operator|->
name|group
operator|->
name|setActiveStack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|isActive
name|bool
name|QUndoStack
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_NO_UNDOGROUP
return|return
literal|true
return|;
else|#
directive|else
name|Q_D
argument_list|(
specifier|const
name|QUndoStack
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|group
operator|==
literal|0
operator|||
name|d
operator|->
name|group
operator|->
name|activeStack
argument_list|()
operator|==
name|this
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn void QUndoStack::indexChanged(int idx)      This signal is emitted whenever a command modifies the state of the document.     This happens when a command is undone or redone. When a macro     command is undone or redone, or setIndex() is called, this signal     is emitted only once.      \a idx specifies the index of the current command, ie. the command which will be     executed on the next call to redo().      \sa index(), setIndex() */
end_comment
begin_comment
comment|/*!     \fn void QUndoStack::cleanChanged(bool clean)      This signal is emitted whenever the stack enters or leaves the clean state.     If \a clean is true, the stack is in a clean state; otherwise this signal     indicates that it has left the clean state.      \sa isClean(), setClean() */
end_comment
begin_comment
comment|/*!     \fn void QUndoStack::undoTextChanged(const QString&undoText)      This signal is emitted whenever the value of undoText() changes. It is     used to update the text property of the undo action returned by createUndoAction().     \a undoText specifies the new text. */
end_comment
begin_comment
comment|/*!     \fn void QUndoStack::canUndoChanged(bool canUndo)      This signal is emitted whenever the value of canUndo() changes. It is     used to enable or disable the undo action returned by createUndoAction().     \a canUndo specifies the new value. */
end_comment
begin_comment
comment|/*!     \fn void QUndoStack::redoTextChanged(const QString&redoText)      This signal is emitted whenever the value of redoText() changes. It is     used to update the text property of the redo action returned by createRedoAction().     \a redoText specifies the new text. */
end_comment
begin_comment
comment|/*!     \fn void QUndoStack::canRedoChanged(bool canRedo)      This signal is emitted whenever the value of canRedo() changes. It is     used to enable or disable the redo action returned by createRedoAction().     \a canRedo specifies the new value. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_UNDOSTACK
end_comment
end_unit
