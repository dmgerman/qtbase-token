begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QCompleter     \brief The QCompleter class provides completions based on an item model.     \since 4.2      \inmodule QtWidgets      You can use QCompleter to provide auto completions in any Qt     widget, such as QLineEdit and QComboBox.     When the user starts typing a word, QCompleter suggests possible ways of     completing the word, based on a word list. The word list is     provided as a QAbstractItemModel. (For simple applications, where     the word list is static, you can pass a QStringList to     QCompleter's constructor.)      \tableofcontents      \section1 Basic Usage      A QCompleter is used typically with a QLineEdit or QComboBox.     For example, here's how to provide auto completions from a simple     word list in a QLineEdit:      \snippet code/src_gui_util_qcompleter.cpp 0      A QFileSystemModel can be used to provide auto completion of file names.     For example:      \snippet code/src_gui_util_qcompleter.cpp 1      To set the model on which QCompleter should operate, call     setModel(). By default, QCompleter will attempt to match the \l     {completionPrefix}{completion prefix} (i.e., the word that the     user has started typing) against the Qt::EditRole data stored in     column 0 in the  model case sensitively. This can be changed     using setCompletionRole(), setCompletionColumn(), and     setCaseSensitivity().      If the model is sorted on the column and role that are used for completion,     you can call setModelSorting() with either     QCompleter::CaseSensitivelySortedModel or     QCompleter::CaseInsensitivelySortedModel as the argument. On large models,     this can lead to significant performance improvements, because QCompleter     can then use binary search instead of linear search. The binary search only     works when the filterMode is Qt::MatchStartsWith.      The model can be a \l{QAbstractListModel}{list model},     a \l{QAbstractTableModel}{table model}, or a     \l{QAbstractItemModel}{tree model}. Completion on tree models     is slightly more involved and is covered in the \l{Handling     Tree Models} section below.      The completionMode() determines the mode used to provide completions to     the user.      \section1 Iterating Through Completions      To retrieve a single candidate string, call setCompletionPrefix()     with the text that needs to be completed and call     currentCompletion(). You can iterate through the list of     completions as below:      \snippet code/src_gui_util_qcompleter.cpp 2      completionCount() returns the total number of completions for the     current prefix. completionCount() should be avoided when possible,     since it requires a scan of the entire model.      \section1 The Completion Model      completionModel() return a list model that contains all possible     completions for the current completion prefix, in the order in which     they appear in the model. This model can be used to display the current     completions in a custom view. Calling setCompletionPrefix() automatically     refreshes the completion model.      \section1 Handling Tree Models      QCompleter can look for completions in tree models, assuming     that any item (or sub-item or sub-sub-item) can be unambiguously     represented as a string by specifying the path to the item. The     completion is then performed one level at a time.      Let's take the example of a user typing in a file system path.     The model is a (hierarchical) QFileSystemModel. The completion     occurs for every element in the path. For example, if the current     text is \c C:\Wind, QCompleter might suggest \c Windows to     complete the current path element. Similarly, if the current text     is \c C:\Windows\Sy, QCompleter might suggest \c System.      For this kind of completion to work, QCompleter needs to be able to     split the path into a list of strings that are matched at each level.     For \c C:\Windows\Sy, it needs to be split as "C:", "Windows" and "Sy".     The default implementation of splitPath(), splits the completionPrefix     using QDir::separator() if the model is a QFileSystemModel.      To provide completions, QCompleter needs to know the path from an index.     This is provided by pathFromIndex(). The default implementation of     pathFromIndex(), returns the data for the \l{Qt::EditRole}{edit role}     for list models and the absolute file path if the mode is a QFileSystemModel.      \sa QAbstractItemModel, QLineEdit, QComboBox, {Completer Example} */
end_comment
begin_include
include|#
directive|include
file|"qcompleter_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
end_ifndef
begin_include
include|#
directive|include
file|"QtWidgets/qscrollbar.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qstringlistmodel.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qdirmodel.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qfilesystemmodel.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qheaderview.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qlistview.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qapplication.h"
end_include
begin_include
include|#
directive|include
file|"QtGui/qevent.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qlineedit.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QCompletionModel
name|QCompletionModel
operator|::
name|QCompletionModel
parameter_list|(
name|QCompleterPrivate
modifier|*
name|c
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractProxyModel
argument_list|(
operator|*
operator|new
name|QCompletionModelPrivate
argument_list|,
name|parent
argument_list|)
member_init_list|,
name|c
argument_list|(
name|c
argument_list|)
member_init_list|,
name|showAll
argument_list|(
literal|false
argument_list|)
block|{
name|createEngine
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|columnCount
name|int
name|QCompletionModel
operator|::
name|columnCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setSourceModel
name|void
name|QCompletionModel
operator|::
name|setSourceModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|source
parameter_list|)
block|{
name|bool
name|hadModel
init|=
operator|(
name|sourceModel
argument_list|()
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|hadModel
condition|)
name|QObject
operator|::
name|disconnect
argument_list|(
name|sourceModel
argument_list|()
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QAbstractProxyModel
operator|::
name|setSourceModel
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
block|{
comment|// TODO: Optimize updates in the source model
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|modelReset
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|modelDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowsInserted
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|source
argument_list|,
name|SIGNAL
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|invalidate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createEngine
name|void
name|QCompletionModel
operator|::
name|createEngine
parameter_list|()
block|{
name|bool
name|sortedEngine
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|filterMode
operator|==
name|Qt
operator|::
name|MatchStartsWith
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|sorting
condition|)
block|{
case|case
name|QCompleter
operator|::
name|UnsortedModel
case|:
name|sortedEngine
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|QCompleter
operator|::
name|CaseSensitivelySortedModel
case|:
name|sortedEngine
operator|=
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
expr_stmt|;
break|break;
case|case
name|QCompleter
operator|::
name|CaseInsensitivelySortedModel
case|:
name|sortedEngine
operator|=
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseInsensitive
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sortedEngine
condition|)
name|engine
operator|.
name|reset
argument_list|(
operator|new
name|QSortedModelEngine
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|engine
operator|.
name|reset
argument_list|(
operator|new
name|QUnsortedModelEngine
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mapToSource
name|QModelIndex
name|QCompletionModel
operator|::
name|mapToSource
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|engine
operator|->
name|curParent
return|;
name|int
name|row
decl_stmt|;
name|QModelIndex
name|parent
init|=
name|engine
operator|->
name|curParent
decl_stmt|;
if|if
condition|(
operator|!
name|showAll
condition|)
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|Q_ASSERT
argument_list|(
name|index
operator|.
name|row
argument_list|()
operator|<
name|engine
operator|->
name|matchCount
argument_list|()
argument_list|)
expr_stmt|;
name|QIndexMapper
modifier|&
name|rootIndices
init|=
name|engine
operator|->
name|historyMatch
operator|.
name|indices
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|row
argument_list|()
operator|<
name|rootIndices
operator|.
name|count
argument_list|()
condition|)
block|{
name|row
operator|=
name|rootIndices
index|[
name|index
operator|.
name|row
argument_list|()
index|]
expr_stmt|;
name|parent
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|row
operator|=
name|engine
operator|->
name|curMatch
operator|.
name|indices
index|[
name|index
operator|.
name|row
argument_list|()
operator|-
name|rootIndices
operator|.
name|count
argument_list|()
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|row
operator|=
name|index
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mapFromSource
name|QModelIndex
name|QCompletionModel
operator|::
name|mapFromSource
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|idx
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|idx
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|int
name|row
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|showAll
condition|)
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QIndexMapper
modifier|&
name|rootIndices
init|=
name|engine
operator|->
name|historyMatch
operator|.
name|indices
decl_stmt|;
if|if
condition|(
name|idx
operator|.
name|parent
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|idx
operator|.
name|parent
argument_list|()
operator|!=
name|engine
operator|->
name|curParent
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
block|}
else|else
block|{
name|row
operator|=
name|rootIndices
operator|.
name|indexOf
argument_list|(
name|idx
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|==
operator|-
literal|1
operator|&&
name|engine
operator|->
name|curParent
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
comment|// source parent and our parent don't match
block|}
if|if
condition|(
name|row
operator|==
operator|-
literal|1
condition|)
block|{
name|QIndexMapper
modifier|&
name|indices
init|=
name|engine
operator|->
name|curMatch
operator|.
name|indices
decl_stmt|;
name|engine
operator|->
name|filterOnDemand
argument_list|(
name|idx
operator|.
name|row
argument_list|()
operator|-
name|indices
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
name|row
operator|=
name|indices
operator|.
name|indexOf
argument_list|(
name|idx
operator|.
name|row
argument_list|()
argument_list|)
operator|+
name|rootIndices
operator|.
name|count
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|==
operator|-
literal|1
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
block|}
else|else
block|{
if|if
condition|(
name|idx
operator|.
name|parent
argument_list|()
operator|!=
name|engine
operator|->
name|curParent
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|row
operator|=
name|idx
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
return|return
name|createIndex
argument_list|(
name|row
argument_list|,
name|idx
operator|.
name|column
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setCurrentRow
name|bool
name|QCompletionModel
operator|::
name|setCurrentRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
operator|||
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|row
operator|>=
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
name|engine
operator|->
name|filterOnDemand
argument_list|(
name|row
operator|+
literal|1
operator|-
name|engine
operator|->
name|matchCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
comment|// invalid row
return|return
literal|false
return|;
name|engine
operator|->
name|curRow
operator|=
name|row
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|currentIndex
name|QModelIndex
name|QCompletionModel
operator|::
name|currentIndex
parameter_list|(
name|bool
name|sourceIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|int
name|row
init|=
name|engine
operator|->
name|curRow
decl_stmt|;
if|if
condition|(
name|showAll
condition|)
name|row
operator|=
name|engine
operator|->
name|curMatch
operator|.
name|indices
index|[
name|engine
operator|->
name|curRow
index|]
expr_stmt|;
name|QModelIndex
name|idx
init|=
name|createIndex
argument_list|(
name|row
argument_list|,
name|c
operator|->
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceIndex
condition|)
return|return
name|idx
return|;
return|return
name|mapToSource
argument_list|(
name|idx
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|index
name|QModelIndex
name|QCompletionModel
operator|::
name|index
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|||
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
if|if
condition|(
operator|!
name|showAll
condition|)
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
if|if
condition|(
name|row
operator|>=
name|engine
operator|->
name|historyMatch
operator|.
name|indices
operator|.
name|count
argument_list|()
condition|)
block|{
name|int
name|want
init|=
name|row
operator|+
literal|1
operator|-
name|engine
operator|->
name|matchCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|want
operator|>
literal|0
condition|)
name|engine
operator|->
name|filterOnDemand
argument_list|(
name|want
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|>=
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|row
operator|>=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|engine
operator|->
name|curParent
argument_list|)
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
block|}
return|return
name|createIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|completionCount
name|int
name|QCompletionModel
operator|::
name|completionCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
literal|0
return|;
name|engine
operator|->
name|filterOnDemand
argument_list|(
name|INT_MAX
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|matchCount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|rowCount
name|int
name|QCompletionModel
operator|::
name|rowCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|showAll
condition|)
block|{
comment|// Show all items below current parent, even if we have no valid matches
if|if
condition|(
name|engine
operator|->
name|curParts
operator|.
name|count
argument_list|()
operator|!=
literal|1
operator|&&
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
operator|&&
operator|!
name|engine
operator|->
name|curParent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|engine
operator|->
name|curParent
argument_list|)
return|;
block|}
return|return
name|completionCount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setFiltered
name|void
name|QCompletionModel
operator|::
name|setFiltered
parameter_list|(
name|bool
name|filtered
parameter_list|)
block|{
if|if
condition|(
name|showAll
operator|==
operator|!
name|filtered
condition|)
return|return;
name|beginResetModel
argument_list|()
expr_stmt|;
name|showAll
operator|=
operator|!
name|filtered
expr_stmt|;
name|endResetModel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hasChildren
name|bool
name|QCompletionModel
operator|::
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|showAll
condition|)
return|return
name|d
operator|->
name|model
operator|->
name|hasChildren
argument_list|(
name|mapToSource
argument_list|(
name|parent
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|engine
operator|->
name|matchCount
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|data
name|QVariant
name|QCompletionModel
operator|::
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompletionModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|model
operator|->
name|data
argument_list|(
name|mapToSource
argument_list|(
name|index
argument_list|)
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|modelDestroyed
name|void
name|QCompletionModel
operator|::
name|modelDestroyed
parameter_list|()
block|{
name|QAbstractProxyModel
operator|::
name|setSourceModel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// switch to static empty model
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rowsInserted
name|void
name|QCompletionModel
operator|::
name|rowsInserted
parameter_list|()
block|{
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|rowsAdded
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|invalidate
name|void
name|QCompletionModel
operator|::
name|invalidate
parameter_list|()
block|{
name|engine
operator|->
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|filter
argument_list|(
name|engine
operator|->
name|curParts
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|filter
name|void
name|QCompletionModel
operator|::
name|filter
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parts
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompletionModel
argument_list|)
expr_stmt|;
name|beginResetModel
argument_list|()
expr_stmt|;
name|engine
operator|->
name|filter
argument_list|(
name|parts
argument_list|)
expr_stmt|;
name|endResetModel
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|model
operator|->
name|canFetchMore
argument_list|(
name|engine
operator|->
name|curParent
argument_list|)
condition|)
name|d
operator|->
name|model
operator|->
name|fetchMore
argument_list|(
name|engine
operator|->
name|curParent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|filter
name|void
name|QCompletionEngine
operator|::
name|filter
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|parts
parameter_list|)
block|{
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|curParts
operator|=
name|parts
expr_stmt|;
if|if
condition|(
name|curParts
operator|.
name|isEmpty
argument_list|()
condition|)
name|curParts
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|curRow
operator|=
operator|-
literal|1
expr_stmt|;
name|curParent
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|curMatch
operator|=
name|QMatchData
argument_list|()
expr_stmt|;
name|historyMatch
operator|=
name|filterHistory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|model
condition|)
return|return;
name|QModelIndex
name|parent
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|curParts
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|QString
name|part
init|=
name|curParts
index|[
name|i
index|]
decl_stmt|;
name|int
name|emi
init|=
name|filter
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|exactMatchIndex
decl_stmt|;
if|if
condition|(
name|emi
operator|==
operator|-
literal|1
condition|)
return|return;
name|parent
operator|=
name|model
operator|->
name|index
argument_list|(
name|emi
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Note that we set the curParent to a valid parent, even if we have no matches
comment|// When filtering is disabled, we show all the items under this parent
name|curParent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|curParts
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|curMatch
operator|=
name|QMatchData
argument_list|(
name|QIndexMapper
argument_list|(
literal|0
argument_list|,
name|model
operator|->
name|rowCount
argument_list|(
name|curParent
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|curMatch
operator|=
name|filter
argument_list|(
name|curParts
operator|.
name|last
argument_list|()
argument_list|,
name|curParent
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// build at least one
name|curRow
operator|=
name|curMatch
operator|.
name|isValid
argument_list|()
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|filterHistory
name|QMatchData
name|QCompletionEngine
operator|::
name|filterHistory
parameter_list|()
block|{
name|QAbstractItemModel
modifier|*
name|source
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
if|if
condition|(
name|curParts
operator|.
name|count
argument_list|()
operator|<=
literal|1
operator|||
name|c
operator|->
name|proxy
operator|->
name|showAll
operator|||
operator|!
name|source
condition|)
return|return
name|QMatchData
argument_list|()
return|;
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
specifier|const
name|bool
name|isDirModel
init|=
operator|(
name|qobject_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|source
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
else|#
directive|else
specifier|const
name|bool
name|isDirModel
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
name|Q_UNUSED
argument_list|(
argument|isDirModel
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
specifier|const
name|bool
name|isFsModel
init|=
operator|(
name|qobject_cast
argument_list|<
name|QFileSystemModel
operator|*
argument_list|>
argument_list|(
name|source
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
else|#
directive|else
specifier|const
name|bool
name|isFsModel
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
name|Q_UNUSED
argument_list|(
argument|isFsModel
argument_list|)
name|QVector
argument_list|<
name|int
argument_list|>
name|v
decl_stmt|;
name|QIndexMapper
name|im
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|QMatchData
name|m
argument_list|(
name|im
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|source
operator|->
name|rowCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QString
name|str
init|=
name|source
operator|->
name|index
argument_list|(
name|i
argument_list|,
name|c
operator|->
name|column
argument_list|)
operator|.
name|data
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|c
operator|->
name|prefix
argument_list|,
name|c
operator|->
name|cs
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|isFsModel
operator|&&
operator|!
name|isDirModel
operator|)
operator|||
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|str
argument_list|)
operator|!=
name|QDir
operator|::
name|separator
argument_list|()
operator|)
endif|#
directive|endif
condition|)
name|m
operator|.
name|indices
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|// Returns a match hint from the cache by chopping the search string
end_comment
begin_function
DECL|function|matchHint
name|bool
name|QCompletionEngine
operator|::
name|matchHint
parameter_list|(
name|QString
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|QMatchData
modifier|*
name|hint
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseInsensitive
condition|)
name|part
operator|=
name|part
operator|.
name|toLower
argument_list|()
expr_stmt|;
specifier|const
name|CacheItem
modifier|&
name|map
init|=
name|cache
index|[
name|parent
index|]
decl_stmt|;
name|QString
name|key
init|=
name|part
decl_stmt|;
while|while
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|key
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
operator|*
name|hint
operator|=
name|map
index|[
name|key
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|lookupCache
name|bool
name|QCompletionEngine
operator|::
name|lookupCache
parameter_list|(
name|QString
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|QMatchData
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseInsensitive
condition|)
name|part
operator|=
name|part
operator|.
name|toLower
argument_list|()
expr_stmt|;
specifier|const
name|CacheItem
modifier|&
name|map
init|=
name|cache
index|[
name|parent
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|contains
argument_list|(
name|part
argument_list|)
condition|)
return|return
literal|false
return|;
operator|*
name|m
operator|=
name|map
index|[
name|part
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// When the cache size exceeds 1MB, it clears out about 1/2 of the cache.
end_comment
begin_function
DECL|function|saveInCache
name|void
name|QCompletionEngine
operator|::
name|saveInCache
parameter_list|(
name|QString
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
specifier|const
name|QMatchData
modifier|&
name|m
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|filterMode
operator|==
name|Qt
operator|::
name|MatchEndsWith
condition|)
return|return;
name|QMatchData
name|old
init|=
name|cache
index|[
name|parent
index|]
operator|.
name|take
argument_list|(
name|part
argument_list|)
decl_stmt|;
name|cost
operator|=
name|cost
operator|+
name|m
operator|.
name|indices
operator|.
name|cost
argument_list|()
operator|-
name|old
operator|.
name|indices
operator|.
name|cost
argument_list|()
expr_stmt|;
if|if
condition|(
name|cost
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
literal|1024
operator|*
literal|1024
condition|)
block|{
name|QMap
argument_list|<
name|QModelIndex
argument_list|,
name|CacheItem
argument_list|>
operator|::
name|iterator
name|it1
init|=
name|cache
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it1
operator|!=
name|cache
operator|.
name|end
argument_list|()
condition|)
block|{
name|CacheItem
modifier|&
name|ci
init|=
name|it1
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|sz
init|=
name|ci
operator|.
name|count
argument_list|()
operator|/
literal|2
decl_stmt|;
name|QMap
argument_list|<
name|QString
argument_list|,
name|QMatchData
argument_list|>
operator|::
name|iterator
name|it2
init|=
name|ci
operator|.
name|begin
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it2
operator|!=
name|ci
operator|.
name|end
argument_list|()
operator|&&
name|i
operator|<
name|sz
condition|)
block|{
name|cost
operator|-=
name|it2
operator|.
name|value
argument_list|()
operator|.
name|indices
operator|.
name|cost
argument_list|()
expr_stmt|;
name|it2
operator|=
name|ci
operator|.
name|erase
argument_list|(
name|it2
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ci
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|it1
operator|=
name|cache
operator|.
name|erase
argument_list|(
name|it1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseInsensitive
condition|)
name|part
operator|=
name|part
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|cache
index|[
name|parent
index|]
index|[
name|part
index|]
operator|=
name|m
expr_stmt|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|indexHint
name|QIndexMapper
name|QSortedModelEngine
operator|::
name|indexHint
parameter_list|(
name|QString
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|cs
operator|==
name|Qt
operator|::
name|CaseInsensitive
condition|)
name|part
operator|=
name|part
operator|.
name|toLower
argument_list|()
expr_stmt|;
specifier|const
name|CacheItem
modifier|&
name|map
init|=
name|cache
index|[
name|parent
index|]
decl_stmt|;
comment|// Try to find a lower and upper bound for the search from previous results
name|int
name|to
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
specifier|const
name|CacheItem
operator|::
name|const_iterator
name|it
init|=
name|map
operator|.
name|lowerBound
argument_list|(
name|part
argument_list|)
decl_stmt|;
comment|// look backward for first valid hint
for|for
control|(
name|CacheItem
operator|::
name|const_iterator
name|it1
init|=
name|it
init|;
name|it1
operator|--
operator|!=
name|map
operator|.
name|constBegin
argument_list|()
condition|;
control|)
block|{
specifier|const
name|QMatchData
modifier|&
name|value
init|=
name|it1
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
block|{
name|from
operator|=
name|value
operator|.
name|indices
operator|.
name|last
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|to
operator|=
name|value
operator|.
name|indices
operator|.
name|first
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// look forward for first valid hint
for|for
control|(
name|CacheItem
operator|::
name|const_iterator
name|it2
init|=
name|it
init|;
name|it2
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it2
control|)
block|{
specifier|const
name|QMatchData
modifier|&
name|value
init|=
name|it2
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|it2
operator|.
name|key
argument_list|()
operator|.
name|startsWith
argument_list|(
name|part
argument_list|)
condition|)
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
block|{
name|to
operator|=
name|value
operator|.
name|indices
operator|.
name|first
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|value
operator|.
name|indices
operator|.
name|first
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|QIndexMapper
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sortOrder
name|Qt
operator|::
name|SortOrder
name|QSortedModelEngine
operator|::
name|sortOrder
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|int
name|rowCount
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowCount
operator|<
literal|2
condition|)
return|return
name|Qt
operator|::
name|AscendingOrder
return|;
name|QString
name|first
init|=
name|model
operator|->
name|data
argument_list|(
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|QString
name|last
init|=
name|model
operator|->
name|data
argument_list|(
name|model
operator|->
name|index
argument_list|(
name|rowCount
operator|-
literal|1
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|QString
operator|::
name|compare
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|c
operator|->
name|cs
argument_list|)
operator|<=
literal|0
condition|?
name|Qt
operator|::
name|AscendingOrder
else|:
name|Qt
operator|::
name|DescendingOrder
return|;
block|}
end_function
begin_function
DECL|function|filter
name|QMatchData
name|QSortedModelEngine
operator|::
name|filter
parameter_list|(
specifier|const
name|QString
modifier|&
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
parameter_list|)
block|{
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|QMatchData
name|hint
decl_stmt|;
if|if
condition|(
name|lookupCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
operator|&
name|hint
argument_list|)
condition|)
return|return
name|hint
return|;
name|QIndexMapper
name|indices
decl_stmt|;
name|Qt
operator|::
name|SortOrder
name|order
init|=
name|sortOrder
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchHint
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
operator|&
name|hint
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hint
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QMatchData
argument_list|()
return|;
name|indices
operator|=
name|hint
operator|.
name|indices
expr_stmt|;
block|}
else|else
block|{
name|indices
operator|=
name|indexHint
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
comment|// binary search the model within 'indices' for 'part' under 'parent'
name|int
name|high
init|=
name|indices
operator|.
name|to
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|low
init|=
name|indices
operator|.
name|from
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|probe
decl_stmt|;
name|QModelIndex
name|probeIndex
decl_stmt|;
name|QString
name|probeData
decl_stmt|;
while|while
condition|(
name|high
operator|-
name|low
operator|>
literal|1
condition|)
block|{
name|probe
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
expr_stmt|;
name|probeIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|probe
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|probeData
operator|=
name|model
operator|->
name|data
argument_list|(
name|probeIndex
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
specifier|const
name|int
name|cmp
init|=
name|QString
operator|::
name|compare
argument_list|(
name|probeData
argument_list|,
name|part
argument_list|,
name|c
operator|->
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
operator|&&
name|cmp
operator|>=
literal|0
operator|)
operator|||
operator|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
operator|&&
name|cmp
operator|<
literal|0
operator|)
condition|)
block|{
name|high
operator|=
name|probe
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
name|probe
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
operator|&&
name|low
operator|==
name|indices
operator|.
name|to
argument_list|()
operator|)
operator|||
operator|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
operator|&&
name|high
operator|==
name|indices
operator|.
name|from
argument_list|()
operator|)
condition|)
block|{
comment|// not found
name|saveInCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|QMatchData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMatchData
argument_list|()
return|;
block|}
name|probeIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|low
operator|+
literal|1
else|:
name|high
operator|-
literal|1
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|probeData
operator|=
name|model
operator|->
name|data
argument_list|(
name|probeIndex
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|probeData
operator|.
name|startsWith
argument_list|(
name|part
argument_list|,
name|c
operator|->
name|cs
argument_list|)
condition|)
block|{
name|saveInCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|QMatchData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMatchData
argument_list|()
return|;
block|}
specifier|const
name|bool
name|exactMatch
init|=
name|QString
operator|::
name|compare
argument_list|(
name|probeData
argument_list|,
name|part
argument_list|,
name|c
operator|->
name|cs
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|emi
init|=
name|exactMatch
condition|?
operator|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|low
operator|+
literal|1
else|:
name|high
operator|-
literal|1
operator|)
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|from
init|=
literal|0
decl_stmt|;
name|int
name|to
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
block|{
name|from
operator|=
name|low
operator|+
literal|1
expr_stmt|;
name|high
operator|=
name|indices
operator|.
name|to
argument_list|()
operator|+
literal|1
expr_stmt|;
name|low
operator|=
name|from
expr_stmt|;
block|}
else|else
block|{
name|to
operator|=
name|high
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|indices
operator|.
name|from
argument_list|()
operator|-
literal|1
expr_stmt|;
name|high
operator|=
name|to
expr_stmt|;
block|}
while|while
condition|(
name|high
operator|-
name|low
operator|>
literal|1
condition|)
block|{
name|probe
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
expr_stmt|;
name|probeIndex
operator|=
name|model
operator|->
name|index
argument_list|(
name|probe
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|probeData
operator|=
name|model
operator|->
name|data
argument_list|(
name|probeIndex
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|startsWith
init|=
name|probeData
operator|.
name|startsWith
argument_list|(
name|part
argument_list|,
name|c
operator|->
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
operator|&&
name|startsWith
operator|)
operator|||
operator|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
operator|&&
operator|!
name|startsWith
operator|)
condition|)
block|{
name|low
operator|=
name|probe
expr_stmt|;
block|}
else|else
block|{
name|high
operator|=
name|probe
expr_stmt|;
block|}
block|}
name|QMatchData
name|m
argument_list|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|?
name|QIndexMapper
argument_list|(
name|from
argument_list|,
name|high
operator|-
literal|1
argument_list|)
else|:
name|QIndexMapper
argument_list|(
name|low
operator|+
literal|1
argument_list|,
name|to
argument_list|)
argument_list|,
name|emi
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|saveInCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_function
DECL|function|buildIndices
name|int
name|QUnsortedModelEngine
operator|::
name|buildIndices
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|QIndexMapper
modifier|&
name|indices
parameter_list|,
name|QMatchData
modifier|*
name|m
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m
operator|->
name|partial
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|n
operator|!=
operator|-
literal|1
operator|||
name|m
operator|->
name|exactMatchIndex
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indices
operator|.
name|count
argument_list|()
operator|&&
name|count
operator|!=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QModelIndex
name|idx
init|=
name|model
operator|->
name|index
argument_list|(
name|indices
index|[
name|i
index|]
argument_list|,
name|c
operator|->
name|column
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|model
operator|->
name|flags
argument_list|(
name|idx
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsSelectable
operator|)
condition|)
continue|continue;
name|QString
name|data
init|=
name|model
operator|->
name|data
argument_list|(
name|idx
argument_list|,
name|c
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|c
operator|->
name|filterMode
condition|)
block|{
case|case
name|Qt
operator|::
name|MatchStartsWith
case|:
if|if
condition|(
operator|!
name|data
operator|.
name|startsWith
argument_list|(
name|str
argument_list|,
name|c
operator|->
name|cs
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|Qt
operator|::
name|MatchContains
case|:
if|if
condition|(
operator|!
name|data
operator|.
name|contains
argument_list|(
name|str
argument_list|,
name|c
operator|->
name|cs
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|Qt
operator|::
name|MatchEndsWith
case|:
if|if
condition|(
operator|!
name|data
operator|.
name|endsWith
argument_list|(
name|str
argument_list|,
name|c
operator|->
name|cs
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|Qt
operator|::
name|MatchExactly
case|:
case|case
name|Qt
operator|::
name|MatchFixedString
case|:
case|case
name|Qt
operator|::
name|MatchCaseSensitive
case|:
case|case
name|Qt
operator|::
name|MatchRegExp
case|:
case|case
name|Qt
operator|::
name|MatchWildcard
case|:
case|case
name|Qt
operator|::
name|MatchWrap
case|:
case|case
name|Qt
operator|::
name|MatchRecursive
case|:
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|indices
operator|.
name|append
argument_list|(
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|exactMatchIndex
operator|==
operator|-
literal|1
operator|&&
name|QString
operator|::
name|compare
argument_list|(
name|data
argument_list|,
name|str
argument_list|,
name|c
operator|->
name|cs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|exactMatchIndex
operator|=
name|indices
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
name|indices
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|indices
index|[
name|i
operator|-
literal|1
index|]
return|;
block|}
end_function
begin_function
DECL|function|filterOnDemand
name|void
name|QUnsortedModelEngine
operator|::
name|filterOnDemand
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|matchCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curMatch
operator|.
name|partial
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|n
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|int
name|lastRow
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|curParent
argument_list|)
operator|-
literal|1
decl_stmt|;
name|QIndexMapper
name|im
argument_list|(
name|curMatch
operator|.
name|indices
operator|.
name|last
argument_list|()
operator|+
literal|1
argument_list|,
name|lastRow
argument_list|)
decl_stmt|;
name|int
name|lastIndex
init|=
name|buildIndices
argument_list|(
name|curParts
operator|.
name|last
argument_list|()
argument_list|,
name|curParent
argument_list|,
name|n
argument_list|,
name|im
argument_list|,
operator|&
name|curMatch
argument_list|)
decl_stmt|;
name|curMatch
operator|.
name|partial
operator|=
operator|(
name|lastRow
operator|!=
name|lastIndex
operator|)
expr_stmt|;
name|saveInCache
argument_list|(
name|curParts
operator|.
name|last
argument_list|()
argument_list|,
name|curParent
argument_list|,
name|curMatch
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|filter
name|QMatchData
name|QUnsortedModelEngine
operator|::
name|filter
parameter_list|(
specifier|const
name|QString
modifier|&
name|part
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|QMatchData
name|hint
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|v
decl_stmt|;
name|QIndexMapper
name|im
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|QMatchData
name|m
argument_list|(
name|im
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|const
name|QAbstractItemModel
modifier|*
name|model
init|=
name|c
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|bool
name|foundInCache
init|=
name|lookupCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
operator|&
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foundInCache
condition|)
block|{
if|if
condition|(
name|matchHint
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
operator|&
name|hint
argument_list|)
operator|&&
operator|!
name|hint
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QMatchData
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|foundInCache
operator|&&
operator|!
name|hint
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|int
name|lastRow
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
decl_stmt|;
name|QIndexMapper
name|all
argument_list|(
literal|0
argument_list|,
name|lastRow
argument_list|)
decl_stmt|;
name|int
name|lastIndex
init|=
name|buildIndices
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|n
argument_list|,
name|all
argument_list|,
operator|&
name|m
argument_list|)
decl_stmt|;
name|m
operator|.
name|partial
operator|=
operator|(
name|lastIndex
operator|!=
name|lastRow
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|foundInCache
condition|)
block|{
comment|// build from hint as much as we can
name|buildIndices
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|INT_MAX
argument_list|,
name|hint
operator|.
name|indices
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|partial
operator|=
name|hint
operator|.
name|partial
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|.
name|partial
operator|&&
operator|(
operator|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|m
operator|.
name|exactMatchIndex
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|m
operator|.
name|indices
operator|.
name|count
argument_list|()
operator|<
name|n
operator|)
operator|)
condition|)
block|{
comment|// need more and have more
specifier|const
name|int
name|lastRow
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
decl_stmt|;
name|QIndexMapper
name|rest
argument_list|(
name|hint
operator|.
name|indices
operator|.
name|last
argument_list|()
operator|+
literal|1
argument_list|,
name|lastRow
argument_list|)
decl_stmt|;
name|int
name|want
init|=
name|n
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|n
operator|-
name|m
operator|.
name|indices
operator|.
name|count
argument_list|()
decl_stmt|;
name|int
name|lastIndex
init|=
name|buildIndices
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|want
argument_list|,
name|rest
argument_list|,
operator|&
name|m
argument_list|)
decl_stmt|;
name|m
operator|.
name|partial
operator|=
operator|(
name|lastRow
operator|!=
name|lastIndex
operator|)
expr_stmt|;
block|}
block|}
name|saveInCache
argument_list|(
name|part
argument_list|,
name|parent
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_constructor
DECL|function|QCompleterPrivate
name|QCompleterPrivate
operator|::
name|QCompleterPrivate
parameter_list|()
member_init_list|:
name|widget
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|proxy
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|popup
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|filterMode
argument_list|(
name|Qt
operator|::
name|MatchStartsWith
argument_list|)
member_init_list|,
name|cs
argument_list|(
name|Qt
operator|::
name|CaseSensitive
argument_list|)
member_init_list|,
name|role
argument_list|(
name|Qt
operator|::
name|EditRole
argument_list|)
member_init_list|,
name|column
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxVisibleItems
argument_list|(
literal|7
argument_list|)
member_init_list|,
name|sorting
argument_list|(
name|QCompleter
operator|::
name|UnsortedModel
argument_list|)
member_init_list|,
name|wrap
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|eatFocusOut
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|hiddenBecauseNoMatch
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|init
name|void
name|QCompleterPrivate
operator|::
name|init
parameter_list|(
name|QAbstractItemModel
modifier|*
name|m
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|proxy
operator|=
operator|new
name|QCompletionModel
argument_list|(
name|this
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|proxy
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAdded
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_autoResizePopup
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setModel
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_LISTVIEW
name|q
operator|->
name|setCompletionMode
argument_list|(
name|QCompleter
operator|::
name|InlineCompletion
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|setCompletionMode
argument_list|(
name|QCompleter
operator|::
name|PopupCompletion
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_LISTVIEW
block|}
end_function
begin_function
DECL|function|setCurrentIndex
name|void
name|QCompleterPrivate
operator|::
name|setCurrentIndex
parameter_list|(
name|QModelIndex
name|index
parameter_list|,
name|bool
name|select
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|popup
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|select
condition|)
block|{
name|popup
operator|->
name|selectionModel
argument_list|()
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
name|popup
operator|->
name|selectionModel
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
else|else
name|popup
operator|->
name|selectionModel
argument_list|()
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|Select
operator||
name|QItemSelectionModel
operator|::
name|Rows
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|popup
operator|->
name|selectionModel
argument_list|()
operator|->
name|currentIndex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
name|popup
operator|->
name|scrollToTop
argument_list|()
expr_stmt|;
else|else
name|popup
operator|->
name|scrollTo
argument_list|(
name|index
argument_list|,
name|QAbstractItemView
operator|::
name|PositionAtTop
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_completionSelected
name|void
name|QCompleterPrivate
operator|::
name|_q_completionSelected
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selection
parameter_list|)
block|{
name|QModelIndex
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|selection
operator|.
name|indexes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|index
operator|=
name|selection
operator|.
name|indexes
argument_list|()
operator|.
name|first
argument_list|()
expr_stmt|;
name|_q_complete
argument_list|(
name|index
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_complete
name|void
name|QCompleterPrivate
operator|::
name|_q_complete
parameter_list|(
name|QModelIndex
name|index
parameter_list|,
name|bool
name|highlighted
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|QString
name|completion
decl_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|(
operator|!
name|proxy
operator|->
name|showAll
operator|&&
operator|(
name|index
operator|.
name|row
argument_list|()
operator|>=
name|proxy
operator|->
name|engine
operator|->
name|matchCount
argument_list|()
operator|)
operator|)
condition|)
block|{
name|completion
operator|=
name|prefix
expr_stmt|;
name|index
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|index
operator|.
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
return|return;
name|QModelIndex
name|si
init|=
name|proxy
operator|->
name|mapToSource
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|si
operator|=
name|si
operator|.
name|sibling
argument_list|(
name|si
operator|.
name|row
argument_list|()
argument_list|,
name|column
argument_list|)
expr_stmt|;
comment|// for clicked()
name|completion
operator|=
name|q
operator|->
name|pathFromIndex
argument_list|(
name|si
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
comment|// add a trailing separator in inline
if|if
condition|(
name|mode
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
if|if
condition|(
name|qobject_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|&&
name|QFileInfo
argument_list|(
name|completion
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
name|completion
operator|+=
name|QDir
operator|::
name|separator
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
comment|// add a trailing separator in inline
if|if
condition|(
name|mode
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
if|if
condition|(
name|qobject_cast
argument_list|<
name|QFileSystemModel
operator|*
argument_list|>
argument_list|(
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|&&
name|QFileInfo
argument_list|(
name|completion
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
name|completion
operator|+=
name|QDir
operator|::
name|separator
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|highlighted
condition|)
block|{
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|index
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|completion
argument_list|)
emit|;
block|}
else|else
block|{
emit|emit
name|q
operator|->
name|activated
argument_list|(
name|index
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|activated
argument_list|(
name|completion
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|_q_autoResizePopup
name|void
name|QCompleterPrivate
operator|::
name|_q_autoResizePopup
parameter_list|()
block|{
if|if
condition|(
operator|!
name|popup
operator|||
operator|!
name|popup
operator|->
name|isVisible
argument_list|()
condition|)
return|return;
name|showPopup
argument_list|(
name|popupRect
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|showPopup
name|void
name|QCompleterPrivate
operator|::
name|showPopup
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|QRect
name|screen
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|availableGeometry
argument_list|(
name|widget
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|LayoutDirection
name|dir
init|=
name|widget
operator|->
name|layoutDirection
argument_list|()
decl_stmt|;
name|QPoint
name|pos
decl_stmt|;
name|int
name|rh
decl_stmt|,
name|w
decl_stmt|;
name|int
name|h
init|=
operator|(
name|popup
operator|->
name|sizeHintForRow
argument_list|(
literal|0
argument_list|)
operator|*
name|qMin
argument_list|(
name|maxVisibleItems
argument_list|,
name|popup
operator|->
name|model
argument_list|()
operator|->
name|rowCount
argument_list|()
argument_list|)
operator|+
literal|3
operator|)
operator|+
literal|3
decl_stmt|;
name|QScrollBar
modifier|*
name|hsb
init|=
name|popup
operator|->
name|horizontalScrollBar
argument_list|()
decl_stmt|;
if|if
condition|(
name|hsb
operator|&&
name|hsb
operator|->
name|isVisible
argument_list|()
condition|)
name|h
operator|+=
name|popup
operator|->
name|horizontalScrollBar
argument_list|()
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
if|if
condition|(
name|rect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|rh
operator|=
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|w
operator|=
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|pos
operator|=
name|widget
operator|->
name|mapToGlobal
argument_list|(
name|dir
operator|==
name|Qt
operator|::
name|RightToLeft
condition|?
name|rect
operator|.
name|bottomRight
argument_list|()
else|:
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rh
operator|=
name|widget
operator|->
name|height
argument_list|()
expr_stmt|;
name|pos
operator|=
name|widget
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
name|widget
operator|->
name|height
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|widget
operator|->
name|width
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
name|screen
operator|.
name|width
argument_list|()
condition|)
name|w
operator|=
name|screen
operator|.
name|width
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pos
operator|.
name|x
argument_list|()
operator|+
name|w
operator|)
operator|>
operator|(
name|screen
operator|.
name|x
argument_list|()
operator|+
name|screen
operator|.
name|width
argument_list|()
operator|)
condition|)
name|pos
operator|.
name|setX
argument_list|(
name|screen
operator|.
name|x
argument_list|()
operator|+
name|screen
operator|.
name|width
argument_list|()
operator|-
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|x
argument_list|()
operator|<
name|screen
operator|.
name|x
argument_list|()
condition|)
name|pos
operator|.
name|setX
argument_list|(
name|screen
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|top
init|=
name|pos
operator|.
name|y
argument_list|()
operator|-
name|rh
operator|-
name|screen
operator|.
name|top
argument_list|()
operator|+
literal|2
decl_stmt|;
name|int
name|bottom
init|=
name|screen
operator|.
name|bottom
argument_list|()
operator|-
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
name|h
operator|=
name|qMax
argument_list|(
name|h
argument_list|,
name|popup
operator|->
name|minimumHeight
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|>
name|bottom
condition|)
block|{
name|h
operator|=
name|qMin
argument_list|(
name|qMax
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|>
name|bottom
condition|)
name|pos
operator|.
name|setY
argument_list|(
name|pos
operator|.
name|y
argument_list|()
operator|-
name|h
operator|-
name|rh
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|popup
operator|->
name|setGeometry
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|popup
operator|->
name|isVisible
argument_list|()
condition|)
name|popup
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_fileSystemModelDirectoryLoaded
name|void
name|QCompleterPrivate
operator|::
name|_q_fileSystemModelDirectoryLoaded
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
comment|// Slot called when QFileSystemModel has finished loading.
comment|// If we hide the popup because there was no match because the model was not loaded yet,
comment|// we re-start the completion when we get the results
if|if
condition|(
name|hiddenBecauseNoMatch
operator|&&
name|prefix
operator|.
name|startsWith
argument_list|(
name|path
argument_list|)
operator|&&
name|prefix
operator|!=
operator|(
name|path
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|)
operator|&&
name|widget
condition|)
block|{
name|q
operator|->
name|complete
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a completer object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QCompleter
name|QCompleter
operator|::
name|QCompleter
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCompleterPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a completer object with the given \a parent that provides completions     from the specified \a model. */
end_comment
begin_constructor
DECL|function|QCompleter
name|QCompleter
operator|::
name|QCompleter
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCompleterPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STRINGLISTMODEL
end_ifndef
begin_comment
comment|/*!     Constructs a QCompleter object with the given \a parent that uses the specified     \a list as a source of possible completions. */
end_comment
begin_constructor
DECL|function|QCompleter
name|QCompleter
operator|::
name|QCompleter
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|list
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCompleterPrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
operator|new
name|QStringListModel
argument_list|(
name|list
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_STRINGLISTMODEL
end_comment
begin_comment
comment|/*!     Destroys the completer object. */
end_comment
begin_destructor
DECL|function|~QCompleter
name|QCompleter
operator|::
name|~
name|QCompleter
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the widget for which completion are provided for to \a widget. This     function is automatically called when a QCompleter is set on a QLineEdit     using QLineEdit::setCompleter() or on a QComboBox using     QComboBox::setCompleter(). The widget needs to be set explicitly when     providing completions for custom widgets.      \sa widget(), setModel(), setPopup()  */
end_comment
begin_function
DECL|function|setWidget
name|void
name|QCompleter
operator|::
name|setWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|d
operator|->
name|widget
operator|->
name|removeEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|widget
operator|=
name|widget
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|d
operator|->
name|widget
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|popup
condition|)
block|{
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
name|d
operator|->
name|popup
operator|->
name|setFocusProxy
argument_list|(
name|d
operator|->
name|widget
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the widget for which the completer object is providing completions.      \sa setWidget()  */
end_comment
begin_function
DECL|function|widget
name|QWidget
modifier|*
name|QCompleter
operator|::
name|widget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|widget
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the model which provides completions to \a model. The \a model can     be list model or a tree model. If a model has been already previously set     and it has the QCompleter as its parent, it is deleted.      For convenience, if \a model is a QFileSystemModel, QCompleter switches its     caseSensitivity to Qt::CaseInsensitive on Windows and Qt::CaseSensitive     on other platforms.      \sa completionModel(), modelSorting, {Handling Tree Models} */
end_comment
begin_function
DECL|function|setModel
name|void
name|QCompleter
operator|::
name|setModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|QAbstractItemModel
modifier|*
name|oldModel
init|=
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
name|d
operator|->
name|proxy
operator|->
name|setSourceModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|popup
condition|)
name|setPopup
argument_list|(
name|d
operator|->
name|popup
argument_list|)
expr_stmt|;
comment|// set the model and make new connections
if|if
condition|(
name|oldModel
operator|&&
name|oldModel
operator|->
name|QObject
operator|::
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|oldModel
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
if|if
condition|(
name|qobject_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|model
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|setCaseSensitivity
argument_list|(
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
expr_stmt|;
else|#
directive|else
name|setCaseSensitivity
argument_list|(
name|Qt
operator|::
name|CaseSensitive
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|// QT_NO_DIRMODEL
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
name|QFileSystemModel
modifier|*
name|fsModel
init|=
name|qobject_cast
argument_list|<
name|QFileSystemModel
operator|*
argument_list|>
argument_list|(
name|model
argument_list|)
decl_stmt|;
if|if
condition|(
name|fsModel
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|setCaseSensitivity
argument_list|(
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
expr_stmt|;
else|#
directive|else
name|setCaseSensitivity
argument_list|(
name|Qt
operator|::
name|CaseSensitive
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setCompletionRole
argument_list|(
name|QFileSystemModel
operator|::
name|FileNameRole
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|fsModel
argument_list|,
name|SIGNAL
argument_list|(
name|directoryLoaded
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_fileSystemModelDirectoryLoaded
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_FILESYSTEMMODEL
block|}
end_function
begin_comment
comment|/*!     Returns the model that provides completion strings.      \sa completionModel() */
end_comment
begin_function
DECL|function|model
name|QAbstractItemModel
modifier|*
name|QCompleter
operator|::
name|model
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QCompleter::CompletionMode      This enum specifies how completions are provided to the user.      \value PopupCompletion            Current completions are displayed in a popup window.     \value InlineCompletion           Completions appear inline (as selected text).     \value UnfilteredPopupCompletion  All possible completions are displayed in a popup window with the most likely suggestion indicated as current.      \sa setCompletionMode() */
end_comment
begin_comment
comment|/*!     \property QCompleter::completionMode     \brief how the completions are provided to the user      The default value is QCompleter::PopupCompletion. */
end_comment
begin_function
DECL|function|setCompletionMode
name|void
name|QCompleter
operator|::
name|setCompletionMode
parameter_list|(
name|QCompleter
operator|::
name|CompletionMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|setFiltered
argument_list|(
name|mode
operator|!=
name|QCompleter
operator|::
name|UnfilteredPopupCompletion
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|d
operator|->
name|widget
operator|->
name|removeEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|popup
condition|)
block|{
name|d
operator|->
name|popup
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|d
operator|->
name|popup
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|d
operator|->
name|widget
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|completionMode
name|QCompleter
operator|::
name|CompletionMode
name|QCompleter
operator|::
name|completionMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|mode
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::filterMode     \brief how the filtering is performed     \since 5.2      If filterMode is set to Qt::MatchStartsWith, only those entries that start     with the typed characters will be displayed. Qt::MatchContains will display     the entries that contain the typed characters, and Qt::MatchEndsWith the     ones that end with the typed characters.      Currently, only these three modes are implemented. Setting filterMode to     any other Qt::MatchFlag will issue a warning, and no action will be     performed.      The default mode is Qt::MatchStartsWith. */
end_comment
begin_function
DECL|function|setFilterMode
name|void
name|QCompleter
operator|::
name|setFilterMode
parameter_list|(
name|Qt
operator|::
name|MatchFlags
name|filterMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|filterMode
operator|==
name|filterMode
condition|)
return|return;
if|if
condition|(
name|filterMode
operator|!=
name|Qt
operator|::
name|MatchStartsWith
operator|&&
name|filterMode
operator|!=
name|Qt
operator|::
name|MatchContains
operator|&&
name|filterMode
operator|!=
name|Qt
operator|::
name|MatchEndsWith
condition|)
block|{
name|qWarning
argument_list|(
literal|"Unhandled QCompleter::filterMode flag is used."
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|filterMode
operator|=
name|filterMode
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|createEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|filterMode
name|Qt
operator|::
name|MatchFlags
name|QCompleter
operator|::
name|filterMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|filterMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the popup used to display completions to \a popup. QCompleter takes     ownership of the view.      A QListView is automatically created when the completionMode() is set to     QCompleter::PopupCompletion or QCompleter::UnfilteredPopupCompletion. The     default popup displays the completionColumn().      Ensure that this function is called before the view settings are modified.     This is required since view's properties may require that a model has been     set on the view (for example, hiding columns in the view requires a model     to be set on the view).      \sa popup() */
end_comment
begin_function
DECL|function|setPopup
name|void
name|QCompleter
operator|::
name|setPopup
parameter_list|(
name|QAbstractItemView
modifier|*
name|popup
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|popup
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|popup
condition|)
block|{
name|QObject
operator|::
name|disconnect
argument_list|(
name|d
operator|->
name|popup
operator|->
name|selectionModel
argument_list|()
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|d
operator|->
name|popup
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|popup
operator|!=
name|popup
condition|)
operator|delete
name|d
operator|->
name|popup
expr_stmt|;
if|if
condition|(
name|popup
operator|->
name|model
argument_list|()
operator|!=
name|d
operator|->
name|proxy
condition|)
name|popup
operator|->
name|setModel
argument_list|(
name|d
operator|->
name|proxy
argument_list|)
expr_stmt|;
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
name|Qt
operator|::
name|FocusPolicy
name|origPolicy
init|=
name|Qt
operator|::
name|NoFocus
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|origPolicy
operator|=
name|d
operator|->
name|widget
operator|->
name|focusPolicy
argument_list|()
expr_stmt|;
name|popup
operator|->
name|setParent
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|Popup
argument_list|)
expr_stmt|;
name|popup
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|NoFocus
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|widget
condition|)
name|d
operator|->
name|widget
operator|->
name|setFocusPolicy
argument_list|(
name|origPolicy
argument_list|)
expr_stmt|;
name|popup
operator|->
name|setFocusProxy
argument_list|(
name|d
operator|->
name|widget
argument_list|)
expr_stmt|;
name|popup
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|popup
operator|->
name|setItemDelegate
argument_list|(
operator|new
name|QCompleterItemDelegate
argument_list|(
name|popup
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
if|if
condition|(
name|QListView
modifier|*
name|listView
init|=
name|qobject_cast
argument_list|<
name|QListView
operator|*
argument_list|>
argument_list|(
name|popup
argument_list|)
condition|)
block|{
name|listView
operator|->
name|setModelColumn
argument_list|(
name|d
operator|->
name|column
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QObject
operator|::
name|connect
argument_list|(
name|popup
argument_list|,
name|SIGNAL
argument_list|(
name|clicked
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_complete
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|popup
argument_list|,
name|SLOT
argument_list|(
name|hide
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|popup
operator|->
name|selectionModel
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|,
name|QItemSelection
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_completionSelected
argument_list|(
name|QItemSelection
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|popup
operator|=
name|popup
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the popup used to display completions.      \sa setPopup() */
end_comment
begin_function
DECL|function|popup
name|QAbstractItemView
modifier|*
name|QCompleter
operator|::
name|popup
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
if|if
condition|(
operator|!
name|d
operator|->
name|popup
operator|&&
name|completionMode
argument_list|()
operator|!=
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
name|QListView
modifier|*
name|listView
init|=
operator|new
name|QListView
decl_stmt|;
name|listView
operator|->
name|setEditTriggers
argument_list|(
name|QAbstractItemView
operator|::
name|NoEditTriggers
argument_list|)
expr_stmt|;
name|listView
operator|->
name|setHorizontalScrollBarPolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAlwaysOff
argument_list|)
expr_stmt|;
name|listView
operator|->
name|setSelectionBehavior
argument_list|(
name|QAbstractItemView
operator|::
name|SelectRows
argument_list|)
expr_stmt|;
name|listView
operator|->
name|setSelectionMode
argument_list|(
name|QAbstractItemView
operator|::
name|SingleSelection
argument_list|)
expr_stmt|;
name|listView
operator|->
name|setModelColumn
argument_list|(
name|d
operator|->
name|column
argument_list|)
expr_stmt|;
name|QCompleter
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QCompleter
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|setPopup
argument_list|(
name|listView
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_LISTVIEW
return|return
name|d
operator|->
name|popup
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QCompleter
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|QObject
operator|::
name|event
argument_list|(
name|ev
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QCompleter
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|eatFocusOut
operator|&&
name|o
operator|==
name|d
operator|->
name|widget
operator|&&
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FocusOut
condition|)
block|{
name|d
operator|->
name|hiddenBecauseNoMatch
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|popup
operator|&&
name|d
operator|->
name|popup
operator|->
name|isVisible
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|!=
name|d
operator|->
name|popup
condition|)
return|return
name|QObject
operator|::
name|eventFilter
argument_list|(
name|o
argument_list|,
name|e
argument_list|)
return|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|KeyPress
case|:
block|{
name|QKeyEvent
modifier|*
name|ke
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QModelIndex
name|curIndex
init|=
name|d
operator|->
name|popup
operator|->
name|currentIndex
argument_list|()
decl_stmt|;
name|QModelIndexList
name|selList
init|=
name|d
operator|->
name|popup
operator|->
name|selectionModel
argument_list|()
operator|->
name|selectedIndexes
argument_list|()
decl_stmt|;
specifier|const
name|int
name|key
init|=
name|ke
operator|->
name|key
argument_list|()
decl_stmt|;
comment|// In UnFilteredPopup mode, select the current item
if|if
condition|(
operator|(
name|key
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
operator|&&
name|selList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|curIndex
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|mode
operator|==
name|QCompleter
operator|::
name|UnfilteredPopupCompletion
condition|)
block|{
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|curIndex
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Handle popup navigation keys. These are hardcoded because up/down might make the
comment|// widget do something else (lineedit cursor moves to home/end on mac, for instance)
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_End
case|:
case|case
name|Qt
operator|::
name|Key_Home
case|:
if|if
condition|(
name|ke
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|Qt
operator|::
name|Key_Up
case|:
if|if
condition|(
operator|!
name|curIndex
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|rowCount
init|=
name|d
operator|->
name|proxy
operator|->
name|rowCount
argument_list|()
decl_stmt|;
name|QModelIndex
name|lastIndex
init|=
name|d
operator|->
name|proxy
operator|->
name|index
argument_list|(
name|rowCount
operator|-
literal|1
argument_list|,
name|d
operator|->
name|column
argument_list|)
decl_stmt|;
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|lastIndex
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|curIndex
operator|.
name|row
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|wrap
condition|)
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
case|case
name|Qt
operator|::
name|Key_Down
case|:
if|if
condition|(
operator|!
name|curIndex
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QModelIndex
name|firstIndex
init|=
name|d
operator|->
name|proxy
operator|->
name|index
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|column
argument_list|)
decl_stmt|;
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|firstIndex
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|curIndex
operator|.
name|row
argument_list|()
operator|==
name|d
operator|->
name|proxy
operator|->
name|rowCount
argument_list|()
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|wrap
condition|)
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
case|case
name|Qt
operator|::
name|Key_PageUp
case|:
case|case
name|Qt
operator|::
name|Key_PageDown
case|:
return|return
literal|false
return|;
block|}
comment|// Send the event to the widget. If the widget accepted the event, do nothing
comment|// If the widget did not accept the event, provide a default implementation
name|d
operator|->
name|eatFocusOut
operator|=
literal|false
expr_stmt|;
operator|(
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|widget
argument_list|)
operator|)
operator|->
name|event
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|d
operator|->
name|eatFocusOut
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|widget
operator|||
name|e
operator|->
name|isAccepted
argument_list|()
operator|||
operator|!
name|d
operator|->
name|popup
operator|->
name|isVisible
argument_list|()
condition|)
block|{
comment|// widget lost focus, hide the popup
if|if
condition|(
name|d
operator|->
name|widget
operator|&&
operator|(
operator|!
name|d
operator|->
name|widget
operator|->
name|hasFocus
argument_list|()
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
operator|||
operator|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|widget
operator|->
name|hasEditFocus
argument_list|()
operator|)
endif|#
directive|endif
operator|)
condition|)
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|isAccepted
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
comment|// default implementation for keys not handled by the widget when popup is open
switch|switch
condition|(
name|key
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|Key_Return
case|:
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Tab
case|:
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
if|if
condition|(
name|curIndex
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|_q_complete
argument_list|(
name|curIndex
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_F4
case|:
if|if
condition|(
name|ke
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|AltModifier
condition|)
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Backtab
case|:
case|case
name|Qt
operator|::
name|Key_Escape
case|:
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
block|{
name|QKeyEvent
modifier|*
name|ke
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|ke
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Back
condition|)
block|{
comment|// Send the event to the 'widget'. This is what we did for KeyPress, so we need
comment|// to do the same for KeyRelease, in case the widget's KeyPress event set
comment|// up something (such as a timer) that is relying on also receiving the
comment|// key release. I see this as a bug in Qt, and should really set it up for all
comment|// the affected keys. However, it is difficult to tell how this will affect
comment|// existing code, and I can't test for every combination!
name|d
operator|->
name|eatFocusOut
operator|=
literal|false
expr_stmt|;
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|widget
argument_list|)
operator|->
name|event
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|d
operator|->
name|eatFocusOut
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
comment|// if we've clicked in the widget (or its descendant), let it handle the click
name|QWidget
modifier|*
name|source
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
condition|)
block|{
name|QPoint
name|pos
init|=
name|source
operator|->
name|mapToGlobal
argument_list|(
operator|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
operator|)
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|target
init|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|&&
operator|(
name|d
operator|->
name|widget
operator|->
name|isAncestorOf
argument_list|(
name|target
argument_list|)
operator|||
name|target
operator|==
name|d
operator|->
name|widget
operator|)
condition|)
block|{
name|d
operator|->
name|eatFocusOut
operator|=
literal|false
expr_stmt|;
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
operator|->
name|event
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|d
operator|->
name|eatFocusOut
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|popup
operator|->
name|underMouse
argument_list|()
condition|)
block|{
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
case|case
name|QEvent
operator|::
name|InputMethod
case|:
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|widget
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     For QCompleter::PopupCompletion and QCompletion::UnfilteredPopupCompletion     modes, calling this function displays the popup displaying the current     completions. By default, if \a rect is not specified, the popup is displayed     on the bottom of the widget(). If \a rect is specified the popup is     displayed on the left edge of the rectangle.      For QCompleter::InlineCompletion mode, the highlighted() signal is fired     with the current completion. */
end_comment
begin_function
DECL|function|complete
name|void
name|QCompleter
operator|::
name|complete
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|QModelIndex
name|idx
init|=
name|d
operator|->
name|proxy
operator|->
name|currentIndex
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|d
operator|->
name|hiddenBecauseNoMatch
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
if|if
condition|(
name|idx
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|_q_complete
argument_list|(
name|idx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|widget
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|mode
operator|==
name|QCompleter
operator|::
name|PopupCompletion
operator|&&
operator|!
name|idx
operator|.
name|isValid
argument_list|()
operator|)
operator|||
operator|(
name|d
operator|->
name|mode
operator|==
name|QCompleter
operator|::
name|UnfilteredPopupCompletion
operator|&&
name|d
operator|->
name|proxy
operator|->
name|rowCount
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|popup
condition|)
name|d
operator|->
name|popup
operator|->
name|hide
argument_list|()
expr_stmt|;
comment|// no suggestion, hide
name|d
operator|->
name|hiddenBecauseNoMatch
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|popup
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|QCompleter
operator|::
name|UnfilteredPopupCompletion
condition|)
name|d
operator|->
name|setCurrentIndex
argument_list|(
name|idx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|showPopup
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|d
operator|->
name|popupRect
operator|=
name|rect
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the current row to the \a row specified. Returns \c true if successful;     otherwise returns \c false.      This function may be used along with currentCompletion() to iterate     through all the possible completions.      \sa currentCompletion(), completionCount() */
end_comment
begin_function
DECL|function|setCurrentRow
name|bool
name|QCompleter
operator|::
name|setCurrentRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
operator|->
name|setCurrentRow
argument_list|(
name|row
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current row.      \sa setCurrentRow() */
end_comment
begin_function
DECL|function|currentRow
name|int
name|QCompleter
operator|::
name|currentRow
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
operator|->
name|currentRow
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of completions for the current prefix. For an unsorted     model with a large number of items this can be expensive. Use setCurrentRow()     and currentCompletion() to iterate through all the completions. */
end_comment
begin_function
DECL|function|completionCount
name|int
name|QCompleter
operator|::
name|completionCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
operator|->
name|completionCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QCompleter::ModelSorting      This enum specifies how the items in the model are sorted.      \value UnsortedModel                    The model is unsorted.     \value CaseSensitivelySortedModel       The model is sorted case sensitively.     \value CaseInsensitivelySortedModel     The model is sorted case insensitively.      \sa setModelSorting() */
end_comment
begin_comment
comment|/*!     \property QCompleter::modelSorting     \brief the way the model is sorted      By default, no assumptions are made about the order of the items     in the model that provides the completions.      If the model's data for the completionColumn() and completionRole() is sorted in     ascending order, you can set this property to \l CaseSensitivelySortedModel     or \l CaseInsensitivelySortedModel. On large models, this can lead to     significant performance improvements because the completer object can     then use a binary search algorithm instead of linear search algorithm.      The sort order (i.e ascending or descending order) of the model is determined     dynamically by inspecting the contents of the model.      \b{Note:} The performance improvements described above cannot take place     when the completer's \l caseSensitivity is different to the case sensitivity     used by the model's when sorting.      \sa setCaseSensitivity(), QCompleter::ModelSorting */
end_comment
begin_function
DECL|function|setModelSorting
name|void
name|QCompleter
operator|::
name|setModelSorting
parameter_list|(
name|QCompleter
operator|::
name|ModelSorting
name|sorting
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sorting
operator|==
name|sorting
condition|)
return|return;
name|d
operator|->
name|sorting
operator|=
name|sorting
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|createEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|modelSorting
name|QCompleter
operator|::
name|ModelSorting
name|QCompleter
operator|::
name|modelSorting
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sorting
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::completionColumn     \brief the column in the model in which completions are searched for.      If the popup() is a QListView, it is automatically setup to display     this column.      By default, the match column is 0.      \sa completionRole, caseSensitivity */
end_comment
begin_function
DECL|function|setCompletionColumn
name|void
name|QCompleter
operator|::
name|setCompletionColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|column
operator|==
name|column
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
if|if
condition|(
name|QListView
modifier|*
name|listView
init|=
name|qobject_cast
argument_list|<
name|QListView
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|popup
argument_list|)
condition|)
name|listView
operator|->
name|setModelColumn
argument_list|(
name|column
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|column
operator|=
name|column
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|completionColumn
name|int
name|QCompleter
operator|::
name|completionColumn
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|column
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::completionRole     \brief the item role to be used to query the contents of items for matching.      The default role is Qt::EditRole.      \sa completionColumn, caseSensitivity */
end_comment
begin_function
DECL|function|setCompletionRole
name|void
name|QCompleter
operator|::
name|setCompletionRole
parameter_list|(
name|int
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|role
operator|==
name|role
condition|)
return|return;
name|d
operator|->
name|role
operator|=
name|role
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|completionRole
name|int
name|QCompleter
operator|::
name|completionRole
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|role
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::wrapAround     \brief the completions wrap around when navigating through items     \since 4.3      The default is true. */
end_comment
begin_function
DECL|function|setWrapAround
name|void
name|QCompleter
operator|::
name|setWrapAround
parameter_list|(
name|bool
name|wrap
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|wrap
operator|==
name|wrap
condition|)
return|return;
name|d
operator|->
name|wrap
operator|=
name|wrap
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wrapAround
name|bool
name|QCompleter
operator|::
name|wrapAround
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|wrap
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::maxVisibleItems     \brief the maximum allowed size on screen of the completer, measured in items     \since 4.6      By default, this property has a value of 7. */
end_comment
begin_function
DECL|function|maxVisibleItems
name|int
name|QCompleter
operator|::
name|maxVisibleItems
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maxVisibleItems
return|;
block|}
end_function
begin_function
DECL|function|setMaxVisibleItems
name|void
name|QCompleter
operator|::
name|setMaxVisibleItems
parameter_list|(
name|int
name|maxItems
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxItems
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCompleter::setMaxVisibleItems: "
literal|"Invalid max visible items (%d) must be>= 0"
argument_list|,
name|maxItems
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|maxVisibleItems
operator|=
name|maxItems
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::caseSensitivity     \brief the case sensitivity of the matching      The default is Qt::CaseSensitive.      \sa completionColumn, completionRole, modelSorting */
end_comment
begin_function
DECL|function|setCaseSensitivity
name|void
name|QCompleter
operator|::
name|setCaseSensitivity
parameter_list|(
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cs
operator|==
name|cs
condition|)
return|return;
name|d
operator|->
name|cs
operator|=
name|cs
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|createEngine
argument_list|()
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|caseSensitivity
name|Qt
operator|::
name|CaseSensitivity
name|QCompleter
operator|::
name|caseSensitivity
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cs
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCompleter::completionPrefix     \brief the completion prefix used to provide completions.      The completionModel() is updated to reflect the list of possible     matches for \a prefix. */
end_comment
begin_function
DECL|function|setCompletionPrefix
name|void
name|QCompleter
operator|::
name|setCompletionPrefix
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCompleter
argument_list|)
expr_stmt|;
name|d
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|d
operator|->
name|proxy
operator|->
name|filter
argument_list|(
name|splitPath
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|completionPrefix
name|QString
name|QCompleter
operator|::
name|completionPrefix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|prefix
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the model index of the current completion in the completionModel().      \sa setCurrentRow(), currentCompletion(), model() */
end_comment
begin_function
DECL|function|currentIndex
name|QModelIndex
name|QCompleter
operator|::
name|currentIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
operator|->
name|currentIndex
argument_list|(
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current completion string. This includes the \l completionPrefix.     When used alongside setCurrentRow(), it can be used to iterate through     all the matches.      \sa setCurrentRow(), currentIndex() */
end_comment
begin_function
DECL|function|currentCompletion
name|QString
name|QCompleter
operator|::
name|currentCompletion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|pathFromIndex
argument_list|(
name|d
operator|->
name|proxy
operator|->
name|currentIndex
argument_list|(
literal|true
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the completion model. The completion model is a read-only list model     that contains all the possible matches for the current completion prefix.     The completion model is auto-updated to reflect the current completions.      \note The return value of this function is defined to be an QAbstractItemModel     purely for generality. This actual kind of model returned is an instance of an     QAbstractProxyModel subclass.      \sa completionPrefix, model() */
end_comment
begin_function
DECL|function|completionModel
name|QAbstractItemModel
modifier|*
name|QCompleter
operator|::
name|completionModel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the path for the given \a index. The completer object uses this to     obtain the completion text from the underlying model.      The default implementation returns the \l{Qt::EditRole}{edit role} of the     item for list models. It returns the absolute file path if the model is a     QFileSystemModel.      \sa splitPath() */
end_comment
begin_function
DECL|function|pathFromIndex
name|QString
name|QCompleter
operator|::
name|pathFromIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QAbstractItemModel
modifier|*
name|sourceModel
init|=
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceModel
condition|)
return|return
name|QString
argument_list|()
return|;
name|bool
name|isDirModel
init|=
literal|false
decl_stmt|;
name|bool
name|isFsModel
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
name|isDirModel
operator|=
name|qobject_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
name|isFsModel
operator|=
name|qobject_cast
argument_list|<
name|QFileSystemModel
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isDirModel
operator|&&
operator|!
name|isFsModel
condition|)
return|return
name|sourceModel
operator|->
name|data
argument_list|(
name|index
argument_list|,
name|d
operator|->
name|role
argument_list|)
operator|.
name|toString
argument_list|()
return|;
name|QModelIndex
name|idx
init|=
name|index
decl_stmt|;
name|QStringList
name|list
decl_stmt|;
do|do
block|{
name|QString
name|t
decl_stmt|;
if|if
condition|(
name|isDirModel
condition|)
name|t
operator|=
name|sourceModel
operator|->
name|data
argument_list|(
name|idx
argument_list|,
name|Qt
operator|::
name|EditRole
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
else|else
name|t
operator|=
name|sourceModel
operator|->
name|data
argument_list|(
name|idx
argument_list|,
name|QFileSystemModel
operator|::
name|FileNameRole
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|list
operator|.
name|prepend
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|QModelIndex
name|parent
init|=
name|idx
operator|.
name|parent
argument_list|()
decl_stmt|;
name|idx
operator|=
name|parent
operator|.
name|sibling
argument_list|(
name|parent
operator|.
name|row
argument_list|()
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|idx
operator|.
name|isValid
argument_list|()
condition|)
do|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
comment|// only the separator or some other text
return|return
name|list
index|[
literal|0
index|]
return|;
name|list
index|[
literal|0
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// the join below will provide the separator
endif|#
directive|endif
return|return
name|list
operator|.
name|join
argument_list|(
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Splits the given \a path into strings that are used to match at each level     in the model().      The default implementation of splitPath() splits a file system path based on     QDir::separator() when the sourceModel() is a QFileSystemModel.      When used with list models, the first item in the returned list is used for     matching.      \sa pathFromIndex(), {Handling Tree Models} */
end_comment
begin_function
DECL|function|splitPath
name|QStringList
name|QCompleter
operator|::
name|splitPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|bool
name|isDirModel
init|=
literal|false
decl_stmt|;
name|bool
name|isFsModel
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
name|isDirModel
operator|=
name|qobject_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_FILESYSTEMMODEL
ifdef|#
directive|ifdef
name|QT_NO_DIRMODEL
name|Q_D
argument_list|(
specifier|const
name|QCompleter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isFsModel
operator|=
name|qobject_cast
argument_list|<
name|QFileSystemModel
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|proxy
operator|->
name|sourceModel
argument_list|()
argument_list|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
name|isDirModel
operator|&&
operator|!
name|isFsModel
operator|)
operator|||
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QStringList
argument_list|(
name|completionPrefix
argument_list|()
argument_list|)
return|;
name|QString
name|pathCopy
init|=
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|QString
name|sep
init|=
name|QDir
operator|::
name|separator
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|pathCopy
operator|==
name|QLatin1String
argument_list|(
literal|"\\"
argument_list|)
operator|||
name|pathCopy
operator|==
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
condition|)
return|return
name|QStringList
argument_list|(
name|pathCopy
argument_list|)
return|;
name|QString
name|doubleSlash
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathCopy
operator|.
name|startsWith
argument_list|(
name|doubleSlash
argument_list|)
condition|)
name|pathCopy
operator|=
name|pathCopy
operator|.
name|mid
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|doubleSlash
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QRegExp
name|re
argument_list|(
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
operator|+
name|QRegExp
operator|::
name|escape
argument_list|(
name|sep
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
name|parts
init|=
name|pathCopy
operator|.
name|split
argument_list|(
name|re
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
operator|!
name|doubleSlash
operator|.
name|isEmpty
argument_list|()
condition|)
name|parts
index|[
literal|0
index|]
operator|.
name|prepend
argument_list|(
name|doubleSlash
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pathCopy
index|[
literal|0
index|]
operator|==
name|sep
index|[
literal|0
index|]
condition|)
comment|// readd the "/" at the beginning as the split removed it
name|parts
index|[
literal|0
index|]
operator|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|QString
argument_list|(
name|sep
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|parts
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QCompleter::activated(const QModelIndex& index)      This signal is sent when an item in the popup() is activated by the user.     (by clicking or pressing return). The item's \a index in the completionModel()     is given.  */
end_comment
begin_comment
comment|/*!     \fn void QCompleter::activated(const QString&text)      This signal is sent when an item in the popup() is activated by the user (by     clicking or pressing return). The item's \a text is given.  */
end_comment
begin_comment
comment|/*!     \fn void QCompleter::highlighted(const QModelIndex& index)      This signal is sent when an item in the popup() is highlighted by     the user. It is also sent if complete() is called with the completionMode()     set to QCompleter::InlineCompletion. The item's \a index in the completionModel()     is given. */
end_comment
begin_comment
comment|/*!     \fn void QCompleter::highlighted(const QString&text)      This signal is sent when an item in the popup() is highlighted by     the user. It is also sent if complete() is called with the completionMode()     set to QCompleter::InlineCompletion. The item's \a text is given. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qcompleter.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_COMPLETER
end_comment
end_unit
