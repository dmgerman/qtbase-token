begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qcursor.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qsessionmanager.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstylefactory.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qtranslator.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"private/qdnd_p.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"qmessagebox.h"
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicsproxywidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qstylehints.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputpanel.h>
end_include
begin_include
include|#
directive|include
file|"qinputcontext.h"
end_include
begin_include
include|#
directive|include
file|"private/qkeymapper_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_X11
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qguiplatformplugin_p.h"
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_EGL
argument_list|)
end_if
begin_include
include|#
directive|include
file|<link.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qgesture.h"
end_include
begin_include
include|#
directive|include
file|"private/qgesturemanager_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qplatformfontdatabase_qpa.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qguifunctions_wince.h"
end_include
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_smartphone
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_mobile
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_pocket_pc
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_cocoa_helpers_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define ALIEN_DEBUG
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qt_s60_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|initResources
specifier|static
name|void
name|initResources
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WINCE
argument_list|)
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qstyle_wince
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qstyle_wince
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qstyle_s60
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qstyle_s60
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qstyle
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qstyle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qmessagebox
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qmessagebox
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_CORE_EXPORT
name|void
name|qt_call_post_routines
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|qt_appType
name|QApplication
operator|::
name|Type
name|qt_appType
init|=
name|QApplication
operator|::
name|Tty
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|self
name|QApplicationPrivate
modifier|*
name|QApplicationPrivate
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|inputContext
name|QInputContext
modifier|*
name|QApplicationPrivate
operator|::
name|inputContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|quitOnLastWindowClosed
name|bool
name|QApplicationPrivate
operator|::
name|quitOnLastWindowClosed
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_WINCE
end_ifdef
begin_decl_stmt
DECL|member|autoMaximizeThreshold
name|int
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|autoSipEnabled
name|bool
name|QApplicationPrivate
operator|::
name|autoSipEnabled
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|member|autoSipEnabled
name|bool
name|QApplicationPrivate
operator|::
name|autoSipEnabled
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QApplicationPrivate
name|QApplicationPrivate
operator|::
name|QApplicationPrivate
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|QApplication
operator|::
name|Type
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
member_init_list|:
name|QApplicationPrivateBase
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|)
block|{
name|application_type
operator|=
name|type
expr_stmt|;
name|qt_appType
operator|=
name|type
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
name|is_session_restored
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|quitOnLastWindowClosed
operator|=
literal|true
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DIRECTPAINTER
argument_list|)
name|directPainters
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|gestureManager
operator|=
literal|0
expr_stmt|;
name|gestureWidget
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_GESTURES
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|move_cursor
operator|=
literal|0
expr_stmt|;
name|copy_cursor
operator|=
literal|0
expr_stmt|;
name|link_cursor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|ignore_cursor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|self
condition|)
name|self
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QApplicationPrivate
name|QApplicationPrivate
operator|::
name|~
name|QApplicationPrivate
parameter_list|()
block|{
if|if
condition|(
name|self
operator|==
name|this
condition|)
name|self
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QApplication     \brief The QApplication class manages the GUI application's control     flow and main settings.      \inmodule QtWidgets      QApplication contains the main event loop, where all events from the window     system and other sources are processed and dispatched. It also handles the     application's initialization, finalization, and provides session     management. In addition, QApplication handles most of the system-wide and     application-wide settings.      For any GUI application using Qt, there is precisely \bold one QApplication     object, no matter whether the application has 0, 1, 2 or more windows at     any given time. For non-GUI Qt applications, use QCoreApplication instead,     as it does not depend on the \l QtGui library.      The QApplication object is accessible through the instance() function that     returns a pointer equivalent to the global qApp pointer.      QApplication's main areas of responsibility are:         \list             \o  It initializes the application with the user's desktop settings                 such as palette(), font() and doubleClickInterval(). It keeps                 track of these properties in case the user changes the desktop                 globally, for example through some kind of control panel.              \o  It performs event handling, meaning that it receives events                 from the underlying window system and dispatches them to the                 relevant widgets. By using sendEvent() and postEvent() you can                 send your own events to widgets.              \o  It parses common command line arguments and sets its internal                 state accordingly. See the \l{QApplication::QApplication()}                 {constructor documentation} below for more details.              \o  It defines the application's look and feel, which is                 encapsulated in a QStyle object. This can be changed at runtime                 with setStyle().              \o  It specifies how the application is to allocate colors. See                 setColorSpec() for details.              \o  It provides localization of strings that are visible to the                 user via translate().              \o  It provides some magical objects like the desktop() and the                 clipboard().              \o  It knows about the application's windows. You can ask which                 widget is at a certain position using widgetAt(), get a list of                 topLevelWidgets() and closeAllWindows(), etc.              \o  It manages the application's mouse cursor handling, see                 setOverrideCursor()              \o  On the X window system, it provides functions to flush and sync                 the communication stream, see flushX() and syncX().              \o  It provides support for sophisticated \l{Session Management}                 {session management}. This makes it possible for applications                 to terminate gracefully when the user logs out, to cancel a                 shutdown process if termination isn't possible and even to                 preserve the entire application's state for a future session.                 See isSessionRestored(), sessionId() and commitData() and                 saveState() for details.         \endlist      Since the QApplication object does so much initialization, it \e{must} be     created before any other objects related to the user interface are created.     QApplication also deals with common command line arguments. Hence, it is     usually a good idea to create it \e before any interpretation or     modification of \c argv is done in the application itself.      \table     \header         \o{2,1} Groups of functions          \row         \o  System settings         \o  desktopSettingsAware(),             setDesktopSettingsAware(),             cursorFlashTime(),             setCursorFlashTime(),             doubleClickInterval(),             setDoubleClickInterval(),             setKeyboardInputInterval(),             wheelScrollLines(),             setWheelScrollLines(),             palette(),             setPalette(),             font(),             setFont(),             fontMetrics().          \row         \o  Event handling         \o  exec(),             processEvents(),             exit(),             quit().             sendEvent(),             postEvent(),             sendPostedEvents(),             removePostedEvents(),             hasPendingEvents(),             notify(),             macEventFilter(),             qwsEventFilter(),             x11EventFilter(),             x11ProcessEvent(),             winEventFilter().          \row         \o  GUI Styles         \o  style(),             setStyle().          \row         \o  Color usage         \o  colorSpec(),             setColorSpec(),             qwsSetCustomColors().          \row         \o  Text handling         \o  installTranslator(),             removeTranslator()             translate().          \row         \o  Widgets         \o  allWidgets(),             topLevelWidgets(),             desktop(),             activePopupWidget(),             activeModalWidget(),             clipboard(),             focusWidget(),             activeWindow(),             widgetAt().          \row         \o  Advanced cursor handling         \o  overrideCursor(),             setOverrideCursor(),             restoreOverrideCursor().          \row         \o  X Window System synchronization         \o  flushX(),             syncX().          \row         \o  Session management         \o  isSessionRestored(),             sessionId(),             commitData(),             saveState().          \row         \o  Miscellaneous         \o  closeAllWindows(),             startingUp(),             closingDown(),             type().     \endtable      \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop, QSettings */
end_comment
begin_comment
comment|/*!     \enum QApplication::Type      \value Tty a console application     \value GuiClient a GUI client application     \value GuiServer a GUI server application (for Qt for Embedded Linux) */
end_comment
begin_comment
comment|/*!     \enum QApplication::ColorSpec      \value NormalColor the default color allocation policy     \value CustomColor the same as NormalColor for X11; allocates colors     to a palette on demand under Windows     \value ManyColor the right choice for applications that use thousands of     colors      See setColorSpec() for full details. */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::topLevelAt(const QPoint&point)      Returns the top-level widget at the given \a point; returns 0 if     there is no such widget. */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::topLevelAt(int x, int y)      \overload      Returns the top-level widget at the point (\a{x}, \a{y}); returns     0 if there is no such widget. */
end_comment
begin_comment
comment|/*     The qt_init() and qt_cleanup() functions are implemented in the     qapplication_xyz.cpp file. */
end_comment
begin_function_decl
name|void
name|qt_init
parameter_list|(
name|QApplicationPrivate
modifier|*
name|priv
parameter_list|,
name|int
name|type
ifdef|#
directive|ifdef
name|Q_WS_X11
parameter_list|,
name|Display
modifier|*
name|display
init|=
literal|0
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
init|=
literal|0
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|colormap
init|=
literal|0
endif|#
directive|endif
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|qt_cleanup
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
DECL|member|mouse_buttons
name|Qt
operator|::
name|MouseButtons
name|QApplicationPrivate
operator|::
name|mouse_buttons
init|=
name|Qt
operator|::
name|NoButton
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|modifier_buttons
name|Qt
operator|::
name|KeyboardModifiers
name|QApplicationPrivate
operator|::
name|modifier_buttons
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_style
name|QStyle
modifier|*
name|QApplicationPrivate
operator|::
name|app_style
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_style
comment|// default application style
end_comment
begin_decl_stmt
DECL|member|styleOverride
name|QString
name|QApplicationPrivate
operator|::
name|styleOverride
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|styleOverride
comment|// style override
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
end_ifndef
begin_decl_stmt
DECL|member|styleSheet
name|QString
name|QApplicationPrivate
operator|::
name|styleSheet
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|styleSheet
comment|// default application stylesheet
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|leaveAfterRelease
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|QApplicationPrivate
operator|::
name|leaveAfterRelease
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_cspec
name|int
name|QApplicationPrivate
operator|::
name|app_cspec
init|=
name|QApplication
operator|::
name|NormalColor
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|sys_pal
name|QPalette
modifier|*
name|QApplicationPrivate
operator|::
name|sys_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|sys_pal
comment|// default system palette
end_comment
begin_decl_stmt
DECL|member|set_pal
name|QPalette
modifier|*
name|QApplicationPrivate
operator|::
name|set_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|set_pal
comment|// default palette set by programmer
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Q_WS_QPA
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMutex
argument_list|,
argument|applicationFontMutex
argument_list|)
end_macro
begin_decl_stmt
DECL|member|app_font
name|QFont
modifier|*
name|QApplicationPrivate
operator|::
name|app_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_font
comment|// default application font
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|sys_font
name|QFont
modifier|*
name|QApplicationPrivate
operator|::
name|sys_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|sys_font
comment|// default system font
end_comment
begin_decl_stmt
DECL|member|set_font
name|QFont
modifier|*
name|QApplicationPrivate
operator|::
name|set_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|set_font
comment|// default font set by programmer
end_comment
begin_decl_stmt
DECL|member|app_icon
name|QIcon
modifier|*
name|QApplicationPrivate
operator|::
name|app_icon
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|main_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|main_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|main_widget
comment|// main application widget
end_comment
begin_decl_stmt
DECL|member|focus_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|focus_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|focus_widget
comment|// has keyboard input focus
end_comment
begin_decl_stmt
DECL|member|hidden_focus_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|hidden_focus_widget
comment|// will get keyboard input focus after show()
end_comment
begin_decl_stmt
DECL|member|active_window
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|active_window
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|active_window
comment|// toplevel with keyboard focus
end_comment
begin_decl_stmt
DECL|member|obey_desktop_settings
name|bool
name|QApplicationPrivate
operator|::
name|obey_desktop_settings
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|obey_desktop_settings
comment|// use winsys resources
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_decl_stmt
DECL|member|wheel_scroll_lines
name|int
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|wheel_scroll_lines
comment|// number of lines to scroll
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_is_gui_used
name|bool
name|qt_is_gui_used
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_tab_all_widgets
name|bool
name|Q_WIDGETS_EXPORT
name|qt_tab_all_widgets
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_in_tab_key_event
name|bool
name|qt_in_tab_key_event
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_antialiasing_threshold
name|int
name|qt_antialiasing_threshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_strut
name|QSize
name|QApplicationPrivate
operator|::
name|app_strut
init|=
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_strut
comment|// no default application strut
end_comment
begin_decl_stmt
DECL|member|animate_ui
name|bool
name|QApplicationPrivate
operator|::
name|animate_ui
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|animate_menu
name|bool
name|QApplicationPrivate
operator|::
name|animate_menu
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|fade_menu
name|bool
name|QApplicationPrivate
operator|::
name|fade_menu
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|animate_combo
name|bool
name|QApplicationPrivate
operator|::
name|animate_combo
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|animate_tooltip
name|bool
name|QApplicationPrivate
operator|::
name|animate_tooltip
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|fade_tooltip
name|bool
name|QApplicationPrivate
operator|::
name|fade_tooltip
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|animate_toolbox
name|bool
name|QApplicationPrivate
operator|::
name|animate_toolbox
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|widgetCount
name|bool
name|QApplicationPrivate
operator|::
name|widgetCount
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|load_testability
name|bool
name|QApplicationPrivate
operator|::
name|load_testability
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_decl_stmt
DECL|member|navigationMode
name|Qt
operator|::
name|NavigationMode
name|QApplicationPrivate
operator|::
name|navigationMode
init|=
name|Qt
operator|::
name|NavigationModeKeypadDirectional
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|member|navigationMode
name|Qt
operator|::
name|NavigationMode
name|QApplicationPrivate
operator|::
name|navigationMode
init|=
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|oldEditFocus
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|oldEditFocus
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_tabletChokeMouse
name|bool
name|qt_tabletChokeMouse
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isAlien
specifier|inline
name|bool
name|QApplicationPrivate
operator|::
name|isAlien
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
return|return
name|widget
operator|&&
operator|!
name|widget
operator|->
name|isWindow
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// ######## move to QApplicationPrivate
end_comment
begin_comment
comment|// Default application palettes and fonts (per widget type)
end_comment
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|PaletteHash
argument_list|,
argument|app_palettes
argument_list|)
end_macro
begin_function
DECL|function|qt_app_palettes_hash
name|PaletteHash
modifier|*
name|qt_app_palettes_hash
parameter_list|()
block|{
return|return
name|app_palettes
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|FontHash
name|FontHash
operator|::
name|FontHash
parameter_list|()
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QFont
argument_list|>
operator|::
name|operator
name|=
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|fontDatabase
argument_list|()
operator|->
name|defaultFonts
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|FontHash
argument_list|,
argument|app_fonts
argument_list|)
end_macro
begin_function
DECL|function|qt_app_fonts_hash
name|FontHash
modifier|*
name|qt_app_fonts_hash
parameter_list|()
block|{
return|return
name|app_fonts
argument_list|()
return|;
block|}
end_function
begin_decl_stmt
DECL|member|popupWidgets
name|QWidgetList
modifier|*
name|QApplicationPrivate
operator|::
name|popupWidgets
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|popupWidgets
comment|// has keyboard input focus
end_comment
begin_decl_stmt
DECL|variable|qt_desktopWidget
name|QDesktopWidget
modifier|*
name|qt_desktopWidget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_desktopWidget
comment|// root window widgets
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CLIPBOARD
argument_list|)
end_if
begin_decl_stmt
DECL|variable|qt_clipboard
name|QClipboard
modifier|*
name|qt_clipboard
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_clipboard
comment|// global clipboard object
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_modal_stack
name|QWidgetList
modifier|*
name|qt_modal_stack
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_modal_stack
comment|// stack of modal widgets
end_comment
begin_decl_stmt
DECL|variable|app_do_modal
name|bool
name|app_do_modal
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|process_cmdline
name|void
name|QApplicationPrivate
operator|::
name|process_cmdline
parameter_list|()
block|{
comment|// process platform-indep command line
if|if
condition|(
operator|!
name|qt_is_gui_used
operator|||
operator|!
name|argc
condition|)
return|return;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|// if you add anything here, modify QCoreApplication::arguments()
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|arg
operator|=
name|arg
expr_stmt|;
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-qdevel"
operator|||
name|arg
operator|==
literal|"-qdebug"
condition|)
block|{
comment|// obsolete argument
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|indexOf
argument_list|(
literal|"-style="
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|.
name|right
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|7
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-style"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-session"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
condition|)
block|{
name|session_id
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|int
name|p
init|=
name|session_id
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|>=
literal|0
condition|)
block|{
name|session_key
operator|=
name|session_id
operator|.
name|mid
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|session_id
operator|=
name|session_id
operator|.
name|left
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|is_session_restored
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-stylesheet"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|styleSheet
operator|=
name|QLatin1String
argument_list|(
literal|"file:///"
argument_list|)
expr_stmt|;
name|styleSheet
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|indexOf
argument_list|(
literal|"-stylesheet="
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|styleSheet
operator|=
name|QLatin1String
argument_list|(
literal|"file:///"
argument_list|)
expr_stmt|;
name|styleSheet
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|.
name|right
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|qstrcmp
argument_list|(
name|arg
argument_list|,
literal|"-widgetcount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|widgetCount
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qstrcmp
argument_list|(
name|arg
argument_list|,
literal|"-testability"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load_testability
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|app_style
condition|)
block|{
operator|delete
name|app_style
expr_stmt|;
name|app_style
operator|=
literal|0
expr_stmt|;
block|}
name|styleOverride
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Initializes the window system and constructs an application object with     \a argc command line arguments in \a argv.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      The global \c qApp pointer refers to this application object. Only one     application object should be created.      This application object must be constructed before any \l{QPaintDevice}     {paint devices} (including widgets, pixmaps, bitmaps etc.).      \note \a argc and \a argv might be changed as Qt removes command line     arguments that it recognizes.      Qt debugging options (not available if Qt was compiled without the QT_DEBUG     flag defined):     \list         \o  -nograb, tells Qt that it must never grab the mouse or the             keyboard.         \o  -dograb (only under X11), running under a debugger can cause an             implicit -nograb, use -dograb to override.         \o  -sync (only under X11), switches to synchronous mode for             debugging.     \endlist      See \l{Debugging Techniques} for a more detailed explanation.      All Qt programs automatically support the following command line options:     \list         \o  -style= \e style, sets the application GUI style. Possible values             are \c motif, \c windows, and \c platinum. If you compiled Qt with             additional styles or have additional styles as plugins these will             be available to the \c -style command line option.         \o  -style \e style, is the same as listed above.         \o  -stylesheet= \e stylesheet, sets the application \l styleSheet. The             value must be a path to a file that contains the Style Sheet.             \note Relative URLs in the Style Sheet file are relative to the             Style Sheet file's path.         \o  -stylesheet \e stylesheet, is the same as listed above.         \o  -session= \e session, restores the application from an earlier             \l{Session Management}{session}.         \o  -session \e session, is the same as listed above.         \o  -widgetcount, prints debug message at the end about number of             widgets left undestroyed and maximum number of widgets existed at             the same time         \o  -reverse, sets the application's layout direction to             Qt::RightToLeft         \o  -qmljsdebugger=, activates the QML/JS debugger with a specified port.             The value must be of format port:1234[,block], where block is optional             and will make the application wait until a debugger connects to it.     \endlist      The X11 version of Qt supports some traditional X11 command line options:     \list         \o  -display \e display, sets the X display (default is $DISPLAY).         \o  -geometry \e geometry, sets the client geometry of the first window             that is shown.         \o  -fn or \c -font \e font, defines the application font. The font             should be specified using an X logical font description. Note that             this option is ignored when Qt is built with fontconfig support enabled.         \o  -bg or \c -background \e color, sets the default background color             and an application palette (light and dark shades are calculated).         \o  -fg or \c -foreground \e color, sets the default foreground color.         \o  -btn or \c -button \e color, sets the default button color.         \o  -name \e name, sets the application name.         \o  -title \e title, sets the application title.         \o  -visual \c TrueColor, forces the application to use a TrueColor             visual on an 8-bit display.         \o  -ncols \e count, limits the number of colors allocated in the color             cube on an 8-bit display, if the application is using the             QApplication::ManyColor color specification. If \e count is 216             then a 6x6x6 color cube is used (i.e. 6 levels of red, 6 of green,             and 6 of blue); for other values, a cube approximately proportional             to a 2x3x1 cube is used.         \o  -cmap, causes the application to install a private color map on an             8-bit display.         \o  -im, sets the input method server (equivalent to setting the             XMODIFIERS environment variable)         \o  -inputstyle, defines how the input is inserted into the given             widget, e.g., \c onTheSpot makes the input appear directly in the             widget, while \c overTheSpot makes the input appear in a box             floating over the widget and is not inserted until the editing is             done.     \endlist      \section1 X11 Notes      If QApplication fails to open the X11 display, it will terminate     the process. This behavior is consistent with most X11     applications.      \sa arguments() */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an application object with \a argc command line arguments in     \a argv. If \a GUIenabled is true, a GUI application is constructed,     otherwise a non-GUI (console) application is created.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      Set \a GUIenabled to false for programs without a graphical user interface     that should be able to run without a window system.      On X11, the window system is initialized if \a GUIenabled is true. If     \a GUIenabled is false, the application does not connect to the X server.     On Windows and Mac OS, currently the window system is always initialized,     regardless of the value of GUIenabled. This may change in future versions     of Qt.      The following example shows how to create an application that uses a     graphical interface when available.      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 0 */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|bool
name|GUIenabled
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GUIenabled
condition|?
name|GuiClient
else|:
name|Tty
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|bool
name|GUIenabled
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GUIenabled
condition|?
name|GuiClient
else|:
name|Tty
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an application object with \a argc command line arguments in     \a argv.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      With Qt for Embedded Linux, passing QApplication::GuiServer for \a type     makes this application the server (equivalent to running with the     \c -qws option). */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|Type
name|type
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|type
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|Type
name|type
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|type
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_EGL
argument_list|)
end_if
begin_function
DECL|function|qt_matchLibraryName
specifier|static
name|int
name|qt_matchLibraryName
parameter_list|(
name|dl_phdr_info
modifier|*
name|info
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
return|return
name|strstr
argument_list|(
name|info
operator|->
name|dlpi_name
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|construct
name|void
name|QApplicationPrivate
operator|::
name|construct
parameter_list|(
ifdef|#
directive|ifdef
name|Q_WS_X11
name|Display
modifier|*
name|dpy
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|cmap
endif|#
directive|endif
parameter_list|)
block|{
name|initResources
argument_list|()
expr_stmt|;
name|qt_is_gui_used
operator|=
operator|(
name|qt_appType
operator|!=
name|QApplication
operator|::
name|Tty
operator|)
expr_stmt|;
name|process_cmdline
argument_list|()
expr_stmt|;
comment|// Must be called before initialize()
name|qt_init
argument_list|(
name|this
argument_list|,
name|qt_appType
ifdef|#
directive|ifdef
name|Q_WS_X11
argument_list|,
name|dpy
argument_list|,
name|visual
argument_list|,
name|cmap
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_gui_eval_init
argument_list|(
name|uint
argument_list|)
decl_stmt|;
name|qt_gui_eval_init
argument_list|(
name|application_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SYSTEMLOCALE
argument_list|)
name|symbianInit
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
name|load_testability
condition|)
block|{
name|QLibrary
name|testLib
argument_list|(
name|QLatin1String
argument_list|(
literal|"qttestability"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|testLib
operator|.
name|load
argument_list|()
condition|)
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|TasInitialize
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|TasInitialize
name|initFunction
init|=
operator|(
name|TasInitialize
operator|)
name|testLib
operator|.
name|resolve
argument_list|(
literal|"qt_testability_init"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// resolving method by name does not work on Symbian OS so need to use ordinal
if|if
condition|(
operator|!
name|initFunction
condition|)
block|{
name|initFunction
operator|=
operator|(
name|TasInitialize
operator|)
name|testLib
operator|.
name|resolve
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|initFunction
condition|)
block|{
name|initFunction
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qCritical
argument_list|(
literal|"Library qttestability resolve failed!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qCritical
argument_list|(
literal|"Library qttestability load failed!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//make sure the plugin is loaded
if|if
condition|(
name|qt_is_gui_used
condition|)
name|qt_guiPlatformPlugin
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
end_if
begin_comment
comment|// ### a string literal is a cont char*
end_comment
begin_comment
comment|// ### using it as a char* is wrong and could lead to segfaults
end_comment
begin_comment
comment|// ### if aargv is modified someday
end_comment
begin_comment
comment|// ########## make it work with argc == argv == 0
end_comment
begin_decl_stmt
DECL|variable|aargc
specifier|static
name|int
name|aargc
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|aargv
specifier|static
name|char
modifier|*
name|aargv
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"unknown"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \fn QApplication::QApplication(Display* display, Qt::HANDLE visual, Qt::HANDLE colormap)      Creates an application, given an already open display \a display. If     \a visual and \a colormap are non-zero, the application will use those     values as the default Visual and Colormap contexts.      \warning Qt only supports TrueColor visuals at depths higher than 8     bits-per-pixel.      This function is only available on X11. */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|colormap
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|aargc
argument_list|,
name|aargv
argument_list|,
name|GuiClient
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|dpy
condition|)
name|qWarning
argument_list|(
literal|"QApplication: Invalid Display* argument"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|colormap
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|aargc
argument_list|,
name|aargv
argument_list|,
name|GuiClient
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|dpy
condition|)
name|qWarning
argument_list|(
literal|"QApplication: Invalid Display* argument"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_compile_version
operator|=
name|_internal
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QApplication::QApplication(Display *display, int&argc, char **argv,         Qt::HANDLE visual, Qt::HANDLE colormap)      Creates an application, given an already open \a display and using \a argc     command line arguments in \a argv. If \a visual and \a colormap are     non-zero, the application will use those values as the default Visual     and Colormap contexts.      \warning Qt only supports TrueColor visuals at depths higher than 8     bits-per-pixel.      This function is only available on X11. */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|colormap
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|dpy
condition|)
name|qWarning
argument_list|(
literal|"QApplication: Invalid Display* argument"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|visual
parameter_list|,
name|Qt
operator|::
name|HANDLE
name|colormap
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QApplicationBase
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
if|if
condition|(
operator|!
name|dpy
condition|)
name|qWarning
argument_list|(
literal|"QApplication: Invalid Display* argument"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|d
operator|->
name|construct
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|colormap
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_compile_version
operator|=
name|_internal
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_WS_X11
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
end_ifndef
begin_function_decl
specifier|extern
name|int
name|qRegisterGuiStateMachine
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|qUnregisterGuiStateMachine
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn void QApplicationPrivate::initialize()    Initializes the QApplication object, called from the constructors. */
end_comment
begin_function
DECL|function|initialize
name|void
name|QApplicationPrivate
operator|::
name|initialize
parameter_list|()
block|{
name|QWidgetPrivate
operator|::
name|mapper
operator|=
operator|new
name|QWidgetMapper
expr_stmt|;
name|QWidgetPrivate
operator|::
name|allWidgets
operator|=
operator|new
name|QWidgetSet
expr_stmt|;
if|if
condition|(
name|qt_appType
operator|!=
name|QApplication
operator|::
name|Tty
condition|)
operator|(
name|void
operator|)
name|QApplication
operator|::
name|style
argument_list|()
expr_stmt|;
comment|// trigger creation of application style
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
comment|// trigger registering of QStateMachine's GUI types
name|qRegisterGuiStateMachine
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|is_app_running
operator|=
literal|true
expr_stmt|;
comment|// no longer starting up
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
comment|// connect to the session manager
name|session_manager
operator|=
operator|new
name|QSessionManager
argument_list|(
name|q
argument_list|,
name|session_id
argument_list|,
name|session_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qgetenv
argument_list|(
literal|"QT_USE_NATIVE_WINDOWS"
argument_list|)
operator|.
name|toInt
argument_list|()
operator|>
literal|0
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_NativeWindows
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_WINCE
ifdef|#
directive|ifdef
name|QT_AUTO_MAXIMIZE_THRESHOLD
name|autoMaximizeThreshold
operator|=
name|QT_AUTO_MAXIMIZE_THRESHOLD
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|qt_wince_is_mobile
argument_list|()
condition|)
name|autoMaximizeThreshold
operator|=
literal|50
expr_stmt|;
else|else
name|autoMaximizeThreshold
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|//QT_AUTO_MAXIMIZE_THRESHOLD
endif|#
directive|endif
comment|//Q_WS_WINCE
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qt_is_gui_used
condition|)
name|initializeMultitouch
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of application (\l Tty, GuiClient, or     GuiServer). The type is set when constructing the QApplication     object. */
end_comment
begin_function
DECL|function|type
name|QApplication
operator|::
name|Type
name|QApplication
operator|::
name|type
parameter_list|()
block|{
return|return
name|qt_appType
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Functions returning the active popup and modal widgets.  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Returns the active popup widget.      A popup widget is a special top-level widget that sets the \c     Qt::WType_Popup widget flag, e.g. the QMenu widget. When the application     opens a popup widget, all events are sent to the popup. Normal widgets and     modal widgets cannot be accessed before the popup widget is closed.      Only other popup widgets may be opened when a popup widget is shown. The     popup widgets are organized in a stack. This function returns the active     popup widget at the top of the stack.      \sa activeModalWidget(), topLevelWidgets() */
end_comment
begin_function
DECL|function|activePopupWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|activePopupWidget
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|isEmpty
argument_list|()
condition|?
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|last
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the active modal widget.      A modal widget is a special top-level widget which is a subclass of QDialog     that specifies the modal parameter of the constructor as true. A modal     widget must be closed before the user can continue with other parts of the     program.      Modal widgets are organized in a stack. This function returns the active     modal widget at the top of the stack.      \sa activePopupWidget(), topLevelWidgets() */
end_comment
begin_function
DECL|function|activeModalWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|activeModalWidget
parameter_list|()
block|{
return|return
name|qt_modal_stack
operator|&&
operator|!
name|qt_modal_stack
operator|->
name|isEmpty
argument_list|()
condition|?
name|qt_modal_stack
operator|->
name|first
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Cleans up any window system resources that were allocated by this     application. Sets the global variable \c qApp to 0. */
end_comment
begin_destructor
DECL|function|~QApplication
name|QApplication
operator|::
name|~
name|QApplication
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CLIPBOARD
argument_list|)
comment|// flush clipboard contents
if|if
condition|(
name|qt_clipboard
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|Clipboard
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qt_clipboard
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//### this should probable be done even later
name|qt_call_post_routines
argument_list|()
expr_stmt|;
comment|// kill timers before closing down the dispatcher
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
name|d
operator|->
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
expr_stmt|;
name|d
operator|->
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|QApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|QApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
operator|delete
name|QWidgetPrivate
operator|::
name|mapper
expr_stmt|;
name|QWidgetPrivate
operator|::
name|mapper
operator|=
literal|0
expr_stmt|;
comment|// delete all widgets
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
block|{
name|QWidgetSet
modifier|*
name|mySet
init|=
name|QWidgetPrivate
operator|::
name|allWidgets
decl_stmt|;
name|QWidgetPrivate
operator|::
name|allWidgets
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|QWidgetSet
operator|::
name|ConstIterator
name|it
init|=
name|mySet
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|mySet
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|parent
argument_list|()
condition|)
comment|// window
name|w
operator|->
name|destroy
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
operator|delete
name|mySet
expr_stmt|;
block|}
operator|delete
name|qt_desktopWidget
expr_stmt|;
name|qt_desktopWidget
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CLIPBOARD
argument_list|)
operator|delete
name|qt_clipboard
expr_stmt|;
name|qt_clipboard
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|delete
name|d
operator|->
name|move_cursor
expr_stmt|;
name|d
operator|->
name|move_cursor
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|copy_cursor
expr_stmt|;
name|d
operator|->
name|copy_cursor
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|link_cursor
expr_stmt|;
name|d
operator|->
name|link_cursor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|delete
name|d
operator|->
name|ignore_cursor
expr_stmt|;
name|d
operator|->
name|ignore_cursor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|delete
name|QApplicationPrivate
operator|::
name|app_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|sys_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|sys_pal
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|set_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
literal|0
expr_stmt|;
name|app_palettes
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_QPA
block|{
name|QMutexLocker
name|locker
argument_list|(
name|applicationFontMutex
argument_list|()
argument_list|)
decl_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_font
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_font
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
operator|delete
name|QApplicationPrivate
operator|::
name|sys_font
expr_stmt|;
name|QApplicationPrivate
operator|::
name|sys_font
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|set_font
expr_stmt|;
name|QApplicationPrivate
operator|::
name|set_font
operator|=
literal|0
expr_stmt|;
name|app_fonts
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_style
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_icon
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|qt_is_gui_used
condition|)
operator|delete
name|QDragManager
operator|::
name|self
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|cleanupMultitouch
argument_list|()
expr_stmt|;
name|qt_cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|widgetCount
condition|)
name|qDebug
argument_list|(
literal|"Widgets left: %i    Max widgets: %i \n"
argument_list|,
name|QWidgetPrivate
operator|::
name|instanceCounter
argument_list|,
name|QWidgetPrivate
operator|::
name|maxInstances
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
operator|delete
name|d
operator|->
name|session_manager
expr_stmt|;
name|d
operator|->
name|session_manager
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_SESSIONMANAGER
name|QApplicationPrivate
operator|::
name|obey_desktop_settings
operator|=
literal|true
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_strut
operator|=
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|animate_ui
operator|=
literal|true
expr_stmt|;
name|QApplicationPrivate
operator|::
name|animate_menu
operator|=
literal|false
expr_stmt|;
name|QApplicationPrivate
operator|::
name|fade_menu
operator|=
literal|false
expr_stmt|;
name|QApplicationPrivate
operator|::
name|animate_combo
operator|=
literal|false
expr_stmt|;
name|QApplicationPrivate
operator|::
name|animate_tooltip
operator|=
literal|false
expr_stmt|;
name|QApplicationPrivate
operator|::
name|fade_tooltip
operator|=
literal|false
expr_stmt|;
name|QApplicationPrivate
operator|::
name|widgetCount
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
comment|// trigger unregistering of QStateMachine's GUI types
name|qUnregisterGuiStateMachine
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(const QPoint&point)      Returns the widget at global screen position \a point, or 0 if there is no     Qt widget there.      This function can be slow.      \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard() */
end_comment
begin_function
DECL|function|widgetAt
name|QWidget
modifier|*
name|QApplication
operator|::
name|widgetAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return
literal|0
return|;
name|QWidget
modifier|*
name|child
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TransparentForMouseEvents
argument_list|)
condition|)
name|child
operator|=
name|window
operator|->
name|childAt
argument_list|(
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
return|return
name|child
return|;
if|if
condition|(
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TransparentForMouseEvents
argument_list|)
condition|)
block|{
comment|//shoot a hole in the widget and try once again,
comment|//suboptimal on Qt for Embedded Linux where we do
comment|//know the stacking order of the toplevels.
name|int
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|QRegion
name|oldmask
init|=
name|window
operator|->
name|mask
argument_list|()
decl_stmt|;
name|QPoint
name|wpoint
init|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|QRegion
name|newmask
init|=
operator|(
name|oldmask
operator|.
name|isEmpty
argument_list|()
condition|?
name|QRegion
argument_list|(
name|window
operator|->
name|rect
argument_list|()
argument_list|)
else|:
name|oldmask
operator|)
operator|-
name|QRegion
argument_list|(
name|wpoint
operator|.
name|x
argument_list|()
argument_list|,
name|wpoint
operator|.
name|y
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|window
operator|->
name|setMask
argument_list|(
name|newmask
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|recurse
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|p
argument_list|)
operator|!=
name|window
condition|)
comment|// verify recursion will terminate
name|recurse
operator|=
name|widgetAt
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmask
operator|.
name|isEmpty
argument_list|()
condition|)
name|window
operator|->
name|clearMask
argument_list|()
expr_stmt|;
else|else
name|window
operator|->
name|setMask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
name|recurse
return|;
block|}
return|return
name|window
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(int x, int y)      \overload      Returns the widget at global screen position (\a x, \a y), or 0 if there is     no Qt widget there. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setArgs(int argc, char **argv)     \internal */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateRequest
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LayoutRequest
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Resize
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Move
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateSoftKeys
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|InputMethod
operator|)
condition|)
block|{
for|for
control|(
name|QPostEventList
operator|::
name|const_iterator
name|it
init|=
name|postedEvents
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|postedEvents
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|cur
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|receiver
operator|!=
name|receiver
operator|||
name|cur
operator|.
name|event
operator|==
literal|0
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|!=
name|event
operator|->
name|type
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LayoutRequest
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateRequest
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Resize
condition|)
block|{
operator|(
operator|(
name|QResizeEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|)
operator|->
name|s
operator|=
operator|(
operator|(
name|QResizeEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Move
condition|)
block|{
operator|(
operator|(
name|QMoveEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|)
operator|->
name|p
operator|=
operator|(
operator|(
name|QMoveEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateSoftKeys
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|InputMethod
condition|)
block|{
operator|*
operator|(
name|QInputMethodEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|=
operator|*
operator|(
name|QInputMethodEvent
operator|*
operator|)
name|event
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
return|return
name|QApplicationBase
operator|::
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
name|postedEvents
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::styleSheet     \brief the application style sheet     \since 4.2      By default, this property returns an empty string unless the user specifies     the \c{-stylesheet} option on the command line when running the application.      \sa QWidget::setStyle(), {Qt Style Sheets} */
end_comment
begin_comment
comment|/*!     \property QApplication::autoMaximizeThreshold     \since 4.4     \brief defines a threshold for auto maximizing widgets      \bold{The auto maximize threshold is only available as part of Qt for     Windows CE.}      This property defines a threshold for the size of a window as a percentage     of the screen size. If the minimum size hint of a window exceeds the     threshold, calling show() will cause the window to be maximized     automatically.      Setting the threshold to 100 or greater means that the widget will always     be maximized. Alternatively, setting the threshold to 50 means that the     widget will be maximized only if the vertical minimum size hint is at least     50% of the vertical screen size.      Setting the threshold to -1 disables the feature.      On Windows CE the default is -1 (i.e., it is disabled).     On Windows Mobile the default is 40. */
end_comment
begin_comment
comment|/*!     \property QApplication::autoSipEnabled     \since 4.5     \brief toggles automatic SIP (software input panel) visibility      Set this property to \c true to automatically display the SIP when entering     widgets that accept keyboard input. This property only affects widgets with     the WA_InputMethodEnabled attribute set, and is typically used to launch     a virtual keyboard on devices which have very few or no keys.      \bold{ The property only has an effect on platforms which use software input     panels, such as Windows CE and Symbian.}      The default is platform dependent. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_WINCE
end_ifdef
begin_function
DECL|function|setAutoMaximizeThreshold
name|void
name|QApplication
operator|::
name|setAutoMaximizeThreshold
parameter_list|(
specifier|const
name|int
name|threshold
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
operator|=
name|threshold
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoMaximizeThreshold
name|int
name|QApplication
operator|::
name|autoMaximizeThreshold
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setAutoSipEnabled
name|void
name|QApplication
operator|::
name|setAutoSipEnabled
parameter_list|(
specifier|const
name|bool
name|enabled
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|autoSipEnabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoSipEnabled
name|bool
name|QApplication
operator|::
name|autoSipEnabled
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|autoSipEnabled
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
end_ifndef
begin_function
DECL|function|styleSheet
name|QString
name|QApplication
operator|::
name|styleSheet
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|styleSheet
return|;
block|}
end_function
begin_function
DECL|function|setStyleSheet
name|void
name|QApplication
operator|::
name|setStyleSheet
parameter_list|(
specifier|const
name|QString
modifier|&
name|styleSheet
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|styleSheet
operator|=
name|styleSheet
expr_stmt|;
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
argument_list|)
decl_stmt|;
if|if
condition|(
name|styleSheet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// application style sheet removed
if|if
condition|(
operator|!
name|proxy
condition|)
return|return;
comment|// there was no stylesheet before
name|setStyle
argument_list|(
name|proxy
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proxy
condition|)
block|{
comment|// style sheet update, just repolish
name|proxy
operator|->
name|repolish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// stylesheet set the first time
name|QStyleSheetStyle
modifier|*
name|newProxy
init|=
operator|new
name|QStyleSheetStyle
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
name|setStyle
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_STYLE_STYLESHEET
end_comment
begin_comment
comment|/*!     Returns the application's style object.      \sa setStyle(), QStyle */
end_comment
begin_function
DECL|function|style
name|QStyle
modifier|*
name|QApplication
operator|::
name|style
parameter_list|()
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
return|return
name|QApplicationPrivate
operator|::
name|app_style
return|;
if|if
condition|(
operator|!
name|qt_is_gui_used
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
literal|"No style available in non-gui applications!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_style
condition|)
block|{
comment|// Compile-time search for default style
comment|//
name|QString
name|style
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
name|QString
name|envStyle
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_STYLE_OVERRIDE"
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|QString
name|envStyle
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleOverride
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|style
operator|=
name|QApplicationPrivate
operator|::
name|styleOverride
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|envStyle
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|style
operator|=
name|envStyle
expr_stmt|;
block|}
else|else
block|{
name|style
operator|=
name|QApplicationPrivate
operator|::
name|desktopStyleKey
argument_list|()
expr_stmt|;
block|}
name|QStyle
modifier|*
modifier|&
name|app_style
init|=
name|QApplicationPrivate
operator|::
name|app_style
decl_stmt|;
name|app_style
operator|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|app_style
condition|)
block|{
name|QStringList
name|styles
init|=
name|QStyleFactory
operator|::
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|styles
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|app_style
operator|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|styles
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|app_style
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
literal|"No styles available!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|// take ownership of the style
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
name|QApplicationPrivate
operator|::
name|setSystemPalette
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|standardPalette
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
comment|// repolish set palette with the new style
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleSheet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|setStyleSheet
argument_list|(
name|QApplicationPrivate
operator|::
name|styleSheet
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
return|return
name|QApplicationPrivate
operator|::
name|app_style
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the application's GUI style to \a style. Ownership of the style object     is transferred to QApplication, so QApplication will delete the style     object on application exit or when a new style is set and the old style is     still the parent of the application object.      Example usage:     \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 1      When switching application styles, the color palette is set back to the     initial colors or the system defaults. This is necessary since certain     styles have to adapt the color palette to be fully style-guide compliant.      Setting the style before a palette has been se, i.e., before creating     QApplication, will cause the application to use QStyle::standardPalette()     for the palette.      \warning Qt style sheets are currently not supported for custom QStyle     subclasses. We plan to address this in some future release.      \sa style(), QStyle, setPalette(), desktopSettingsAware() */
end_comment
begin_function
DECL|function|setStyle
name|void
name|QApplication
operator|::
name|setStyle
parameter_list|(
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
if|if
condition|(
operator|!
name|style
operator|||
name|style
operator|==
name|QApplicationPrivate
operator|::
name|app_style
condition|)
return|return;
name|QWidgetList
name|all
init|=
name|allWidgets
argument_list|()
decl_stmt|;
comment|// clean up the old style
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|&&
comment|// except desktop
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
block|{
comment|// has been polished
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|unpolish
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|unpolish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
block|}
name|QStyle
modifier|*
name|old
init|=
name|QApplicationPrivate
operator|::
name|app_style
decl_stmt|;
comment|// save
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleSheet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|style
argument_list|)
condition|)
block|{
comment|// we have a stylesheet already and a new style is being set
name|QStyleSheetStyle
modifier|*
name|newProxy
init|=
operator|new
name|QStyleSheetStyle
argument_list|(
name|style
argument_list|)
decl_stmt|;
name|style
operator|->
name|setParent
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|=
name|newProxy
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|// QT_NO_STYLE_STYLESHEET
name|QApplicationPrivate
operator|::
name|app_style
operator|=
name|style
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
comment|// take ownership
comment|// take care of possible palette requirements of certain gui
comment|// styles. Do it before polishing the application since the style
comment|// might call QApplication::setPalette() itself
if|if
condition|(
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
block|{
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
block|{
name|QApplicationPrivate
operator|::
name|initializeWidgetPaletteHash
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|setPalette_helper
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_pal
argument_list|,
comment|/*className=*/
literal|0
argument_list|,
comment|/*clearWidgetPaletteHash=*/
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
block|{
comment|// Initialize the sys_pal if it hasn't happened yet...
name|QApplicationPrivate
operator|::
name|setSystemPalette
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|standardPalette
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// initialize the application with the new style
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
comment|// re-polish existing widgets if necessary
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it1
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it1
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it1
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it1
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|style
argument_list|()
operator|==
name|QApplicationPrivate
operator|::
name|app_style
condition|)
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// repolish
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
else|else
name|w
operator|->
name|setStyleSheet
argument_list|(
name|w
operator|->
name|styleSheet
argument_list|()
argument_list|)
expr_stmt|;
comment|// touch
endif|#
directive|endif
block|}
block|}
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it2
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it2
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it2
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it2
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|w
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|oldProxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|oldProxy
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|old
operator|&&
name|old
operator|->
name|parent
argument_list|()
operator|==
name|qApp
condition|)
block|{
operator|delete
name|old
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|focus_widget
condition|)
block|{
name|QFocusEvent
name|in
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplicationPrivate
operator|::
name|focus_widget
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|focus_widget
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Requests a QStyle object for \a style from the QStyleFactory.      The string must be one of the QStyleFactory::keys(), typically one of     "windows", "motif", "cde", "plastique", "windowsxp", or "macintosh". Style     names are case insensitive.      Returns 0 if an unknown \a style is passed, otherwise the QStyle object     returned is set as the application's GUI style.      \warning To ensure that the application's style is set correctly, it is     best to call this function before the QApplication constructor, if     possible. */
end_comment
begin_function
DECL|function|setStyle
name|QStyle
modifier|*
name|QApplication
operator|::
name|setStyle
parameter_list|(
specifier|const
name|QString
modifier|&
name|style
parameter_list|)
block|{
name|QStyle
modifier|*
name|s
init|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
name|setStyle
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the color specification.      \sa QApplication::setColorSpec() */
end_comment
begin_function
DECL|function|colorSpec
name|int
name|QApplication
operator|::
name|colorSpec
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_cspec
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the color specification for the application to \a spec.      The color specification controls how the application allocates colors when     run on a display with a limited amount of colors, e.g. 8 bit / 256 color     displays.      The color specification must be set before you create the QApplication     object.      The options are:     \list         \o  QApplication::NormalColor. This is the default color allocation             strategy. Use this option if your application uses buttons, menus,             texts and pixmaps with few colors. With this option, the             application uses system global colors. This works fine for most             applications under X11, but on the Windows platform, it may cause             dithering of non-standard colors.         \o  QApplication::CustomColor. Use this option if your application             needs a small number of custom colors. On X11, this option is the             same as NormalColor. On Windows, Qt creates a Windows palette, and             allocates colors to it on demand.         \o  QApplication::ManyColor. Use this option if your application is             very color hungry, e.g., it requires thousands of colors. \br             Under X11 the effect is:             \list                 \o  For 256-color displays which have at best a 256 color true                     color visual, the default visual is used, and colors are                     allocated from a color cube. The color cube is the 6x6x6                     (216 color) "Web palette" (the red, green, and blue                     components always have one of the following values: 0x00,                     0x33, 0x66, 0x99, 0xCC, or 0xFF), but the number of colors                     can be changed by the \e -ncols option. The user can force                     the application to use the true color visual with the                     \l{QApplication::QApplication()}{-visual} option.                 \o  For 256-color displays which have a true color visual with                     more than 256 colors, use that visual. Silicon Graphics X                     servers this feature, for example. They provide an 8 bit                     visual by default but can deliver true color when asked.             \endlist             On Windows, Qt creates a Windows palette, and fills it with a color             cube.     \endlist      Be aware that the CustomColor and ManyColor choices may lead to colormap     flashing: The foreground application gets (most) of the available colors,     while the background windows will look less attractive.      Example:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 2      \sa colorSpec() */
end_comment
begin_function
DECL|function|setColorSpec
name|void
name|QApplication
operator|::
name|setColorSpec
parameter_list|(
name|int
name|spec
parameter_list|)
block|{
if|if
condition|(
name|qApp
condition|)
name|qWarning
argument_list|(
literal|"QApplication::setColorSpec: This function must be "
literal|"called before the QApplication object is created"
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_cspec
operator|=
name|spec
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::globalStrut     \brief the minimum size that any GUI element that the user can interact            with should have      For example, no button should be resized to be smaller than the global     strut size. The strut size should be considered when reimplementing GUI     controls that may be used on touch-screens or similar I/O devices.      Example:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 3      By default, this property contains a QSize object with zero width and height. */
end_comment
begin_function
DECL|function|globalStrut
name|QSize
name|QApplication
operator|::
name|globalStrut
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_strut
return|;
block|}
end_function
begin_function
DECL|function|setGlobalStrut
name|void
name|QApplication
operator|::
name|setGlobalStrut
parameter_list|(
specifier|const
name|QSize
modifier|&
name|strut
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|app_strut
operator|=
name|strut
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPalette QApplication::palette(const QWidget* widget)     \overload      If a \a widget is passed, the default palette for the widget's class is     returned. This may or may not be the application palette. In most cases     there is no special palette for certain types of widgets, but one notable     exception is the popup menu under Windows, if the user has defined a     special background color for menus in the display settings.      \sa setPalette(), QWidget::palette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QApplication
operator|::
name|palette
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QPalette
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
for|for
control|(
name|it
operator|=
name|hash
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|w
operator|->
name|inherits
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
block|}
return|return
name|palette
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the palette for widgets of the given \a className.      \sa setPalette(), QWidget::palette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QApplication
operator|::
name|palette
parameter_list|(
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_pal
condition|)
name|palette
argument_list|()
expr_stmt|;
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QPalette
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
return|;
block|}
end_function
begin_function
DECL|function|setPalette_helper
name|void
name|QApplicationPrivate
operator|::
name|setPalette_helper
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|,
name|bool
name|clearWidgetPaletteHash
parameter_list|)
block|{
name|QPalette
name|pal
init|=
name|palette
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|pal
argument_list|)
expr_stmt|;
comment|// NB: non-const reference
name|bool
name|all
init|=
literal|false
decl_stmt|;
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|className
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_pal
operator|&&
name|pal
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_pal
condition|)
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
name|pal
expr_stmt|;
if|if
condition|(
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|all
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|clearWidgetPaletteHash
condition|)
name|hash
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hash
condition|)
block|{
name|hash
operator|->
name|insert
argument_list|(
name|className
argument_list|,
name|pal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
comment|// Send ApplicationPaletteChange to qApp itself, and to the widgets.
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationPaletteChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|QWidgetList
name|wids
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|wids
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|wids
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|all
operator|||
operator|(
operator|!
name|className
operator|&&
name|w
operator|->
name|isWindow
argument_list|()
operator|)
operator|||
name|w
operator|->
name|inherits
argument_list|(
name|className
argument_list|)
condition|)
comment|// matching class
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Send to all scenes as well.
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QList
argument_list|<
name|QGraphicsScene
modifier|*
argument_list|>
modifier|&
name|scenes
init|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|scenes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|scenes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|*
name|it
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
if|if
condition|(
operator|!
name|className
operator|&&
operator|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
operator|||
operator|!
name|palette
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_pal
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
name|palette
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Changes the default application palette to \a palette.      If \a className is passed, the change applies only to widgets that inherit     \a className (as reported by QObject::inherits()). If \a className is left     0, the change affects all widgets, thus overriding any previously set class     specific palettes.      The palette may be changed according to the current GUI style in     QStyle::polish().      \warning Do not use this function in conjunction with \l{Qt Style Sheets}.     When using style sheets, the palette of a widget can be customized using     the "color", "background-color", "selection-color",     "selection-background-color" and "alternate-background-color".      \note Some styles do not use the palette for all drawing, for instance, if     they make use of native theme engines. This is the case for the Windows XP,     Windows Vista, and Mac OS X styles.      \sa QWidget::setPalette(), palette(), QStyle::polish() */
end_comment
begin_function
DECL|function|setPalette
name|void
name|QApplication
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|setPalette_helper
argument_list|(
name|palette
argument_list|,
name|className
argument_list|,
comment|/*clearWidgetPaletteHash=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSystemPalette
name|void
name|QApplicationPrivate
operator|::
name|setSystemPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|)
block|{
name|QPalette
name|adjusted
decl_stmt|;
if|#
directive|if
literal|0
comment|// adjust the system palette to avoid dithering
block|QColormap cmap = QColormap::instance();     if (cmap.depths()> 4&& cmap.depths()< 24) {         for (int g = 0; g< QPalette::NColorGroups; g++)             for (int i = 0; i< QPalette::NColorRoles; i++) {                 QColor color = pal.color((QPalette::ColorGroup)g, (QPalette::ColorRole)i);                 color = cmap.colorAt(cmap.pixel(color));                 adjusted.setColor((QPalette::ColorGroup)g, (QPalette::ColorRole) i, color);             }     }
else|#
directive|else
name|adjusted
operator|=
name|pal
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sys_pal
condition|)
name|sys_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|adjusted
argument_list|)
expr_stmt|;
else|else
operator|*
name|sys_pal
operator|=
name|adjusted
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|sys_pal
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default application font.      \sa fontMetrics(), QWidget::font() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|Q_WS_QPA
name|QMutexLocker
name|locker
argument_list|(
name|applicationFontMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_font
condition|)
name|QApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|QLatin1String
argument_list|(
literal|"Helvetica"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|QApplicationPrivate
operator|::
name|app_font
return|;
else|#
directive|else
return|return
name|QGuiApplication
operator|::
name|font
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the default font for the \a widget.      \sa fontMetrics(), QWidget::setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// short circuit for small and mini controls
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|)
condition|)
block|{
return|return
name|hash
operator|->
name|value
argument_list|(
literal|"QSmallFont"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|)
condition|)
block|{
return|return
name|hash
operator|->
name|value
argument_list|(
literal|"QMiniFont"
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|widget
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QFont
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|widget
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
for|for
control|(
name|it
operator|=
name|hash
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|widget
operator|->
name|inherits
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
block|}
return|return
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the font for widgets of the given \a className.      \sa setFont(), QWidget::font() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|(
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QFont
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application font to \a font. If \a className is passed,     the change applies only to classes that inherit \a className (as reported     by QObject::inherits()).      On application start-up, the default font depends on the window system. It     can vary depending on both the window system version and the locale. This     function lets you override the default font; but overriding may be a bad     idea because, for example, some locales need extra large fonts to support     their special characters.      \warning Do not use this function in conjunction with \l{Qt Style Sheets}.     The font of an application can be customized using the "font" style sheet     property. To set a bold font for all QPushButtons, set the application     styleSheet() as "QPushButton { font: bold }"      \sa font(), fontMetrics(), QWidget::setFont() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QApplication
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|bool
name|all
init|=
literal|false
decl_stmt|;
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|className
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_WS_QPA
name|QMutexLocker
name|locker
argument_list|(
name|applicationFontMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_font
condition|)
name|QApplicationPrivate
operator|::
name|app_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|app_font
operator|=
name|font
expr_stmt|;
else|#
directive|else
name|QGuiApplication
operator|::
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|all
operator|=
literal|true
expr_stmt|;
name|hash
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hash
condition|)
block|{
name|hash
operator|->
name|insert
argument_list|(
name|className
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
comment|// Send ApplicationFontChange to qApp itself, and to the widgets.
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationFontChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|QWidgetList
name|wids
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|wids
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|wids
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|all
operator|||
operator|(
operator|!
name|className
operator|&&
name|w
operator|->
name|isWindow
argument_list|()
operator|)
operator|||
name|w
operator|->
name|inherits
argument_list|(
name|className
argument_list|)
condition|)
comment|// matching class
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// Send to all scenes as well.
name|QList
argument_list|<
name|QGraphicsScene
modifier|*
argument_list|>
modifier|&
name|scenes
init|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|scenes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|scenes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|*
name|it
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
if|if
condition|(
operator|!
name|className
operator|&&
operator|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_font
operator|||
operator|!
name|font
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_font
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_font
condition|)
name|QApplicationPrivate
operator|::
name|set_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|set_font
operator|=
name|font
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|setSystemFont
name|void
name|QApplicationPrivate
operator|::
name|setSystemFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sys_font
condition|)
name|sys_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|sys_font
operator|=
name|font
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_font
condition|)
name|QApplication
operator|::
name|setFont
argument_list|(
operator|*
name|sys_font
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|desktopStyleKey
name|QString
name|QApplicationPrivate
operator|::
name|desktopStyleKey
parameter_list|()
block|{
return|return
name|qt_guiPlatformPlugin
argument_list|()
operator|->
name|styleName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::windowIcon     \brief the default window icon      \sa QWidget::setWindowIcon(), {Setting the Application Icon} */
end_comment
begin_function
DECL|function|windowIcon
name|QIcon
name|QApplication
operator|::
name|windowIcon
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_icon
condition|?
operator|*
name|QApplicationPrivate
operator|::
name|app_icon
else|:
name|QIcon
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setWindowIcon
name|void
name|QApplication
operator|::
name|setWindowIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_icon
condition|)
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
operator|new
name|QIcon
argument_list|()
expr_stmt|;
operator|*
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
name|icon
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|void
name|qt_mac_set_app_icon
argument_list|(
specifier|const
name|QPixmap
operator|&
argument_list|)
decl_stmt|;
comment|//qapplication_mac.cpp
name|QSize
name|size
init|=
name|QApplicationPrivate
operator|::
name|app_icon
operator|->
name|actualSize
argument_list|(
name|QSize
argument_list|(
literal|128
argument_list|,
literal|128
argument_list|)
argument_list|)
decl_stmt|;
name|qt_mac_set_app_icon
argument_list|(
name|QApplicationPrivate
operator|::
name|app_icon
operator|->
name|pixmap
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationWindowIconChange
argument_list|)
decl_stmt|;
name|QWidgetList
name|all
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of the top-level widgets (windows) in the application.      \note Some of the top-level widgets may be hidden, for example a tooltip if     no tooltip is currently shown.      Example:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 4      \sa allWidgets(), QWidget::isWindow(), QWidget::isHidden() */
end_comment
begin_function
DECL|function|topLevelWidgets
name|QWidgetList
name|QApplication
operator|::
name|topLevelWidgets
parameter_list|()
block|{
name|QWidgetList
name|list
decl_stmt|;
name|QWidgetList
name|all
init|=
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
name|list
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the widgets in the application.      The list is empty (QList::isEmpty()) if there are no widgets.      \note Some of the widgets may be hidden.      Example:     \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 5      \sa topLevelWidgets(), QWidget::isVisible() */
end_comment
begin_function
DECL|function|allWidgets
name|QWidgetList
name|QApplication
operator|::
name|allWidgets
parameter_list|()
block|{
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
return|return
name|QWidgetPrivate
operator|::
name|allWidgets
operator|->
name|toList
argument_list|()
return|;
return|return
name|QWidgetList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the application widget that has the keyboard input focus, or 0 if     no widget in this application has the focus.      \sa QWidget::setFocus(), QWidget::hasFocus(), activeWindow(), focusChanged() */
end_comment
begin_function
DECL|function|focusWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|focusWidget
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|focus_widget
return|;
block|}
end_function
begin_function
DECL|function|setFocusWidget
name|void
name|QApplicationPrivate
operator|::
name|setFocusWidget
parameter_list|(
name|QWidget
modifier|*
name|focus
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|reason
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|focus
operator|&&
name|focus
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|hidden_focus_widget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|focus
operator|!=
name|focus_widget
condition|)
block|{
if|if
condition|(
name|focus
operator|&&
name|focus
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|hidden_focus_widget
operator|=
name|focus
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|focus
operator|&&
operator|(
name|reason
operator|==
name|Qt
operator|::
name|BacktabFocusReason
operator|||
name|reason
operator|==
name|Qt
operator|::
name|TabFocusReason
operator|)
operator|&&
name|qt_in_tab_key_event
condition|)
name|focus
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|focus
operator|&&
name|reason
operator|==
name|Qt
operator|::
name|ShortcutFocusReason
condition|)
block|{
name|focus
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
block|}
name|QWidget
modifier|*
name|prev
init|=
name|focus_widget
decl_stmt|;
name|focus_widget
operator|=
name|focus
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|prev
operator|&&
operator|(
operator|(
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|MenuBarFocusReason
operator|&&
name|prev
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
operator|)
comment|// Do reset the input context, in case the new focus widget won't accept keyboard input
comment|// or it is not created fully yet.
operator|||
operator|(
name|focus_widget
operator|&&
operator|(
operator|!
name|focus_widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
operator|||
operator|!
name|focus_widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|qApp
operator|->
name|inputPanel
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|qApp
operator|->
name|inputPanel
argument_list|()
operator|->
name|setInputItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_IM
if|if
condition|(
name|focus_widget
condition|)
name|focus_widget
operator|->
name|d_func
argument_list|()
operator|->
name|setFocus_sys
argument_list|()
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|NoFocusReason
condition|)
block|{
comment|//send events
if|if
condition|(
name|prev
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|hasEditFocus
argument_list|()
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|ActiveWindowFocusReason
endif|#
directive|endif
condition|)
name|prev
operator|->
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QFocusEvent
name|out
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|prev
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|prev
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|focus
operator|&&
name|QApplicationPrivate
operator|::
name|focus_widget
operator|==
name|focus
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|focus
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
operator|&&
name|focus
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|focus
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|inputPanel
argument_list|()
operator|->
name|setInputItem
argument_list|(
name|focus
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_IM
name|QFocusEvent
name|in
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|focus
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|focus
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
block|}
emit|emit
name|qApp
operator|->
name|focusChanged
argument_list|(
name|prev
argument_list|,
name|focus_widget
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the application top-level window that has the keyboard input focus,     or 0 if no application window has the focus. There might be an     activeWindow() even if there is no focusWidget(), for example if no widget     in that window accepts key events.      \sa QWidget::setFocus(), QWidget::hasFocus(), focusWidget() */
end_comment
begin_function
DECL|function|activeWindow
name|QWidget
modifier|*
name|QApplication
operator|::
name|activeWindow
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|active_window
return|;
block|}
end_function
begin_comment
comment|/*!     Returns display (screen) font metrics for the application font.      \sa font(), setFont(), QWidget::fontMetrics(), QPainter::fontMetrics() */
end_comment
begin_function
DECL|function|fontMetrics
name|QFontMetrics
name|QApplication
operator|::
name|fontMetrics
parameter_list|()
block|{
return|return
name|desktop
argument_list|()
operator|->
name|fontMetrics
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Closes all top-level windows.      This function is particularly useful for applications with many top-level     windows. It could, for example, be connected to a \gui{Exit} entry in the     \gui{File} menu:      \snippet examples/mainwindows/mdi/mainwindow.cpp 0      The windows are closed in random order, until one window does not accept     the close event. The application quits when the last window was     successfully closed; this can be turned off by setting     \l quitOnLastWindowClosed to false.      \sa quitOnLastWindowClosed, lastWindowClosed(), QWidget::close(),     QWidget::closeEvent(), lastWindowClosed(), quit(), topLevelWidgets(),     QWidget::isWindow() */
end_comment
begin_function
DECL|function|closeAllWindows
name|void
name|QApplication
operator|::
name|closeAllWindows
parameter_list|()
block|{
name|bool
name|did_close
init|=
literal|true
decl_stmt|;
name|QWidget
modifier|*
name|w
decl_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|activeModalWidget
argument_list|()
operator|)
operator|&&
name|did_close
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|isVisible
argument_list|()
operator|||
name|w
operator|->
name|data
operator|->
name|is_closing
condition|)
break|break;
name|did_close
operator|=
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|did_close
operator|&&
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
operator|!
name|w
operator|->
name|data
operator|->
name|is_closing
condition|)
block|{
name|did_close
operator|=
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
name|list
operator|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Displays a simple message box about Qt. The message includes the version     number of Qt being used by the application.      This is useful for inclusion in the \gui Help menu of an application, as     shown in the \l{mainwindows/menus}{Menus} example.      This function is a convenience slot for QMessageBox::aboutQt(). */
end_comment
begin_function
DECL|function|aboutQt
name|void
name|QApplication
operator|::
name|aboutQt
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_MESSAGEBOX
name|QMessageBox
operator|::
name|aboutQt
argument_list|(
ifdef|#
directive|ifdef
name|Q_WS_MAC
literal|0
else|#
directive|else
name|activeWindow
argument_list|()
endif|#
directive|endif
comment|// Q_WS_MAC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_MESSAGEBOX
block|}
end_function
begin_comment
comment|/*!     \fn void QApplication::lastWindowClosed()      This signal is emitted from QApplication::exec() when the last visible     primary window (i.e. window with no parent) with the Qt::WA_QuitOnClose     attribute set is closed.      By default,      \list         \o  this attribute is set for all widgets except transient windows such             as splash screens, tool windows, and popup menus          \o  QApplication implicitly quits when this signal is emitted.     \endlist      This feature can be turned off by setting \l quitOnLastWindowClosed to     false.      \sa QWidget::close() */
end_comment
begin_comment
comment|/*!     \since 4.1     \fn void QApplication::focusChanged(QWidget *old, QWidget *now)      This signal is emitted when the widget that has keyboard focus changed from     \a old to \a now, i.e., because the user pressed the tab-key, clicked into     a widget or changed the active window. Both \a old and \a now can be the     null-pointer.      The signal is emitted after both widget have been notified about the change     through QFocusEvent.      \sa QWidget::setFocus(), QWidget::clearFocus(), Qt::FocusReason */
end_comment
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Close
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
comment|// In order to have proper application-exit effects on Symbian, certain
comment|// native APIs have to be called _before_ closing/destroying the widgets.
name|bool
name|effectStarted
init|=
name|qt_beginFullScreenEffect
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|QCloseEvent
modifier|*
name|ce
init|=
cast|static_cast
argument_list|<
name|QCloseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|ce
operator|->
name|accept
argument_list|()
expr_stmt|;
name|closeAllWindows
argument_list|()
expr_stmt|;
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|&&
operator|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Dialog
operator|)
operator|||
operator|!
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
block|{
name|ce
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ce
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
if|if
condition|(
name|effectStarted
condition|)
name|qt_abortFullScreenEffect
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|Q_OS_WIN
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LocaleChange
condition|)
block|{
comment|// on Windows the event propagation is taken care by the
comment|// WM_SETTINGCHANGE event handler.
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setLocale_helper
argument_list|(
name|QLocale
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
condition|)
block|{
name|QTimerEvent
modifier|*
name|te
init|=
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|te
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|toolTipWakeUp
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|toolTipWidget
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|d
operator|->
name|toolTipWidget
operator|->
name|window
argument_list|()
decl_stmt|;
comment|// show tooltip if WA_AlwaysShowToolTips is set, or if
comment|// any ancestor of d->toolTipWidget is the active
comment|// window
name|bool
name|showToolTip
init|=
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AlwaysShowToolTips
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
operator|&&
operator|!
name|showToolTip
condition|)
block|{
name|showToolTip
operator|=
name|w
operator|->
name|isActiveWindow
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
condition|?
name|w
operator|->
name|window
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|showToolTip
condition|)
block|{
name|QHelpEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ToolTip
argument_list|,
name|d
operator|->
name|toolTipPos
argument_list|,
name|d
operator|->
name|toolTipGlobalPos
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|toolTipWidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|isAccepted
argument_list|()
condition|)
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|start
argument_list|(
literal|2000
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|te
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|qt_mac_post_retranslateAppMenu
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
name|postEvent
argument_list|(
name|w
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|QApplicationBase
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
end_if
begin_comment
comment|// The doc and X implementation of this function is in qapplication_x11.cpp
end_comment
begin_function
DECL|function|syncX
name|void
name|QApplication
operator|::
name|syncX
parameter_list|()
block|{}
end_function
begin_comment
DECL|function|syncX
comment|// do nothing
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|notifyLayoutDirectionChange
name|void
name|QApplicationPrivate
operator|::
name|notifyLayoutDirectionChange
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|QWidgetList
name|list
init|=
name|q
operator|->
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
argument_list|)
decl_stmt|;
name|q
operator|->
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn Qt::WindowsVersion QApplication::winVersion()      Use \l QSysInfo::WindowsVersion instead. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setActiveWindow(QWidget* active)      Sets the active window to the \a active widget in response to a system     event. The function is called from the platform specific event handlers.      \warning This function does \e not set the keyboard focus to the active     widget. Call QWidget::activateWindow() instead.      It sets the activeWindow() and focusWidget() attributes and sends proper     \l{QEvent::WindowActivate}{WindowActivate}/\l{QEvent::WindowDeactivate}     {WindowDeactivate} and \l{QEvent::FocusIn}{FocusIn}/\l{QEvent::FocusOut}     {FocusOut} events to all appropriate widgets. The window will then be     painted in active state (e.g. cursors in line edits will blink), and it     will have tool tips enabled.      \sa activeWindow(), QWidget::activateWindow() */
end_comment
begin_function
DECL|function|setActiveWindow
name|void
name|QApplication
operator|::
name|setActiveWindow
parameter_list|(
name|QWidget
modifier|*
name|act
parameter_list|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|act
condition|?
name|act
operator|->
name|window
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
operator|==
name|window
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|window
operator|&&
name|window
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
comment|// Activate the proxy's view->viewport() ?
return|return;
block|}
endif|#
directive|endif
name|QWidgetList
name|toBeActivated
decl_stmt|;
name|QWidgetList
name|toBeDeactivated
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Widget_ShareActivation
argument_list|,
literal|0
argument_list|,
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
condition|)
block|{
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|toBeDeactivated
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toBeDeactivated
operator|.
name|append
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QWidget
modifier|*
name|previousActiveWindow
init|=
name|QApplicationPrivate
operator|::
name|active_window
decl_stmt|;
endif|#
directive|endif
name|QApplicationPrivate
operator|::
name|active_window
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Widget_ShareActivation
argument_list|,
literal|0
argument_list|,
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
condition|)
block|{
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|toBeActivated
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toBeActivated
operator|.
name|append
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
expr_stmt|;
block|}
block|}
comment|// first the activation/deactivation events
name|QEvent
name|activationChange
argument_list|(
name|QEvent
operator|::
name|ActivationChange
argument_list|)
decl_stmt|;
name|QEvent
name|windowActivate
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|QEvent
name|windowDeactivate
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
operator|!
name|previousActiveWindow
condition|)
block|{
name|QEvent
name|appActivate
argument_list|(
name|QEvent
operator|::
name|ApplicationActivate
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appActivate
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toBeActivated
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|toBeActivated
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|windowActivate
argument_list|)
expr_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|activationChange
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// In case the user clicked on a child window, we need to
comment|// reestablish the stacking order of the window so
comment|// it pops in front of other child windows in cocoa:
name|qt_cocoaStackChildWindowOnTopOfOtherChildren
argument_list|(
name|window
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toBeDeactivated
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|toBeDeactivated
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|windowDeactivate
argument_list|)
expr_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|activationChange
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
name|QEvent
name|appDeactivate
argument_list|(
name|QEvent
operator|::
name|ApplicationDeactivate
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|qApp
argument_list|,
operator|&
name|appDeactivate
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|==
literal|0
condition|)
block|{
comment|// !inPopupMode()
comment|// then focus events
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|active_window
operator|&&
name|QApplicationPrivate
operator|::
name|focus_widget
condition|)
block|{
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
comment|/*&& w->focusPolicy() != QWidget::NoFocus*/
condition|)
name|w
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|=
name|QApplicationPrivate
operator|::
name|focusNextPrevChild_helper
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the focus widget is not in the activate_window, clear the focus
name|w
operator|=
name|QApplicationPrivate
operator|::
name|focus_widget
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|&&
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|isAncestorOf
argument_list|(
name|w
argument_list|)
condition|)
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!internal  * Helper function that returns the new focus widget, but does not set the focus reason.  * Returns 0 if a new focus widget could not be found.  * Shared with QGraphicsProxyWidgetPrivate::findFocusChild() */
end_comment
begin_function
DECL|function|focusNextPrevChild_helper
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|focusNextPrevChild_helper
parameter_list|(
name|QWidget
modifier|*
name|toplevel
parameter_list|,
name|bool
name|next
parameter_list|)
block|{
name|uint
name|focus_flag
init|=
name|qt_tab_all_widgets
condition|?
name|Qt
operator|::
name|TabFocus
else|:
name|Qt
operator|::
name|StrongFocus
decl_stmt|;
name|QWidget
modifier|*
name|f
init|=
name|toplevel
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|f
operator|=
name|toplevel
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|f
decl_stmt|;
name|QWidget
modifier|*
name|test
init|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
decl_stmt|;
while|while
condition|(
name|test
operator|&&
name|test
operator|!=
name|f
condition|)
block|{
if|if
condition|(
operator|(
name|test
operator|->
name|focusPolicy
argument_list|()
operator|&
name|focus_flag
operator|)
operator|==
name|focus_flag
operator|&&
operator|!
operator|(
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
operator|)
operator|&&
name|test
operator|->
name|isVisibleTo
argument_list|(
name|toplevel
argument_list|)
operator|&&
name|test
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|SubWindow
operator|&&
operator|!
name|w
operator|->
name|isAncestorOf
argument_list|(
name|test
argument_list|)
operator|)
operator|&&
operator|(
name|toplevel
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|SubWindow
operator|||
name|toplevel
operator|->
name|isAncestorOf
argument_list|(
name|test
argument_list|)
operator|)
condition|)
block|{
name|w
operator|=
name|test
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
name|test
operator|=
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|qt_in_tab_key_event
condition|)
block|{
name|w
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
name|w
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|w
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QApplicationPrivate::dispatchEnterLeave(QWidget* enter, QWidget* leave)     \internal      Creates the proper Enter/Leave event when widget \a enter is entered and     widget \a leave is left.  */
end_comment
begin_function
DECL|function|dispatchEnterLeave
name|void
name|QApplicationPrivate
operator|::
name|dispatchEnterLeave
parameter_list|(
name|QWidget
modifier|*
name|enter
parameter_list|,
name|QWidget
modifier|*
name|leave
parameter_list|)
block|{
if|#
directive|if
literal|0
block|if (leave) {         QEvent e(QEvent::Leave);         QApplication::sendEvent(leave,& e);     }     if (enter) {         QEvent e(QEvent::Enter);         QApplication::sendEvent(enter,& e);     }     return;
endif|#
directive|endif
name|QWidget
modifier|*
name|w
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|enter
operator|&&
operator|!
name|leave
operator|)
operator|||
operator|(
name|enter
operator|==
name|leave
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::dispatchEnterLeave, ENTER:"
operator|<<
name|enter
operator|<<
literal|"LEAVE:"
operator|<<
name|leave
expr_stmt|;
endif|#
directive|endif
name|QWidgetList
name|leaveList
decl_stmt|;
name|QWidgetList
name|enterList
decl_stmt|;
name|bool
name|sameWindow
init|=
name|leave
operator|&&
name|enter
operator|&&
name|leave
operator|->
name|window
argument_list|()
operator|==
name|enter
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|leave
operator|&&
operator|!
name|sameWindow
condition|)
block|{
name|w
operator|=
name|leave
expr_stmt|;
do|do
block|{
name|leaveList
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|enter
operator|&&
operator|!
name|sameWindow
condition|)
block|{
name|w
operator|=
name|enter
expr_stmt|;
do|do
block|{
name|enterList
operator|.
name|prepend
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|sameWindow
condition|)
block|{
name|int
name|enterDepth
init|=
literal|0
decl_stmt|;
name|int
name|leaveDepth
init|=
literal|0
decl_stmt|;
name|w
operator|=
name|enter
expr_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
name|enterDepth
operator|++
expr_stmt|;
name|w
operator|=
name|leave
expr_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
name|leaveDepth
operator|++
expr_stmt|;
name|QWidget
modifier|*
name|wenter
init|=
name|enter
decl_stmt|;
name|QWidget
modifier|*
name|wleave
init|=
name|leave
decl_stmt|;
while|while
condition|(
name|enterDepth
operator|>
name|leaveDepth
condition|)
block|{
name|wenter
operator|=
name|wenter
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|enterDepth
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|leaveDepth
operator|>
name|enterDepth
condition|)
block|{
name|wleave
operator|=
name|wleave
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|leaveDepth
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|wenter
operator|->
name|isWindow
argument_list|()
operator|&&
name|wenter
operator|!=
name|wleave
condition|)
block|{
name|wenter
operator|=
name|wenter
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|wleave
operator|=
name|wleave
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|leave
expr_stmt|;
while|while
condition|(
name|w
operator|!=
name|wleave
condition|)
block|{
name|leaveList
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|enter
expr_stmt|;
while|while
condition|(
name|w
operator|!=
name|wenter
condition|)
block|{
name|enterList
operator|.
name|prepend
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|QEvent
name|leaveEvent
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaveList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|leaveList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|||
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|leaveAfterRelease
operator|==
name|w
condition|)
name|leaveAfterRelease
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|leaveEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|instance
argument_list|()
argument_list|)
expr_stmt|;
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverLeave
argument_list|,
name|QPoint
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|hoverGlobalPos
argument_list|)
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QPoint
name|posEnter
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
name|QEvent
name|enterEvent
argument_list|(
name|QEvent
operator|::
name|Enter
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enterList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|enterList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|||
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|enterEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverEnter
argument_list|,
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|posEnter
argument_list|)
argument_list|,
name|QPoint
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|// Update cursor for alien/graphics widgets.
specifier|const
name|bool
name|enterOnAlien
init|=
operator|(
name|enter
operator|&&
operator|(
name|isAlien
argument_list|(
name|enter
argument_list|)
operator|||
name|enter
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
operator|)
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
comment|//Whenever we leave an alien widget on X11, we need to reset its nativeParentWidget()'s cursor.
comment|// This is not required on Windows as the cursor is reset on every single mouse move.
name|QWidget
modifier|*
name|parentOfLeavingCursor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaveList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|leaveList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAlien
argument_list|(
name|w
argument_list|)
condition|)
break|break;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
condition|)
block|{
name|QWidget
modifier|*
name|parent
init|=
name|w
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|data
operator|.
name|in_destructor
condition|)
name|parent
operator|=
name|parent
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|parentOfLeavingCursor
operator|=
name|parent
expr_stmt|;
comment|//continue looping, we need to find the downest alien widget with a cursor.
comment|// (downest on the screen)
block|}
block|}
comment|//check that we will not call qt_x11_enforce_cursor twice with the same native widget
if|if
condition|(
name|parentOfLeavingCursor
operator|&&
operator|(
operator|!
name|enterOnAlien
operator|||
name|parentOfLeavingCursor
operator|->
name|effectiveWinId
argument_list|()
operator|!=
name|enter
operator|->
name|effectiveWinId
argument_list|()
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
operator|!
name|parentOfLeavingCursor
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|qt_x11_enforce_cursor
argument_list|(
name|parentOfLeavingCursor
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
if|if
condition|(
name|enter
operator|==
name|QApplication
operator|::
name|desktop
argument_list|()
condition|)
block|{
name|qt_qpa_set_cursor
argument_list|(
name|enter
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_qpa_set_cursor
argument_list|(
name|parentOfLeavingCursor
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|enterOnAlien
condition|)
block|{
name|QWidget
modifier|*
name|cursorWidget
init|=
name|enter
decl_stmt|;
while|while
condition|(
operator|!
name|cursorWidget
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|cursorWidget
operator|->
name|isEnabled
argument_list|()
condition|)
name|cursorWidget
operator|=
name|cursorWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cursorWidget
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|cursorWidget
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
name|QWidgetPrivate
operator|::
name|nearestGraphicsProxyWidget
argument_list|(
name|cursorWidget
argument_list|)
operator|->
name|setCursor
argument_list|(
name|cursorWidget
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|qt_win_set_cursor
argument_list|(
name|cursorWidget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|qt_x11_enforce_cursor
argument_list|(
name|cursorWidget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|qt_symbian_set_cursor
argument_list|(
name|cursorWidget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
name|qt_qpa_set_cursor
argument_list|(
name|cursorWidget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* exported for the benefit of testing tools */
end_comment
begin_function
DECL|function|qt_tryModalHelper
name|Q_WIDGETS_EXPORT
name|bool
name|qt_tryModalHelper
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|rettop
parameter_list|)
block|{
return|return
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|widget
argument_list|,
name|rettop
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if \a widget is blocked by a modal window.  */
end_comment
begin_function
DECL|function|isBlockedByModal
name|bool
name|QApplicationPrivate
operator|::
name|isBlockedByModal
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|widget
operator|=
name|widget
operator|->
name|window
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|modalState
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|widget
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qt_modal_stack
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|modalWidget
init|=
name|qt_modal_stack
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
block|{
comment|// check if the active modal widget is our widget or a parent of our widget
name|QWidget
modifier|*
name|w
init|=
name|widget
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|==
name|modalWidget
condition|)
return|return
literal|false
return|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_WIN
if|if
condition|(
operator|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|||
name|widget
operator|->
name|data
operator|->
name|winid
operator|)
operator|&&
operator|(
name|modalWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|||
name|modalWidget
operator|->
name|data
operator|->
name|winid
operator|)
operator|&&
name|IsChild
argument_list|(
name|modalWidget
operator|->
name|data
operator|->
name|winid
argument_list|,
name|widget
operator|->
name|data
operator|->
name|winid
argument_list|)
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
block|}
name|Qt
operator|::
name|WindowModality
name|windowModality
init|=
name|modalWidget
operator|->
name|windowModality
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowModality
operator|==
name|Qt
operator|::
name|NonModal
condition|)
block|{
comment|// determine the modality type if it hasn't been set on the
comment|// modalWidget, this normally happens when waiting for a
comment|// native dialog. use WindowModal if we are the child of a
comment|// group leader; otherwise use ApplicationModal.
name|QWidget
modifier|*
name|m
init|=
name|modalWidget
decl_stmt|;
while|while
condition|(
name|m
operator|&&
operator|!
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|=
name|m
operator|->
name|window
argument_list|()
expr_stmt|;
block|}
name|windowModality
operator|=
operator|(
name|m
operator|&&
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
operator|)
condition|?
name|Qt
operator|::
name|WindowModal
else|:
name|Qt
operator|::
name|ApplicationModal
expr_stmt|;
block|}
switch|switch
condition|(
name|windowModality
condition|)
block|{
case|case
name|Qt
operator|::
name|ApplicationModal
case|:
block|{
name|QWidget
modifier|*
name|groupLeaderForWidget
init|=
name|widget
decl_stmt|;
while|while
condition|(
name|groupLeaderForWidget
operator|&&
operator|!
name|groupLeaderForWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
name|groupLeaderForWidget
operator|=
name|groupLeaderForWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupLeaderForWidget
condition|)
block|{
comment|// if \a widget has WA_GroupLeader, it can only be blocked by ApplicationModal children
name|QWidget
modifier|*
name|m
init|=
name|modalWidget
decl_stmt|;
while|while
condition|(
name|m
operator|&&
name|m
operator|!=
name|groupLeaderForWidget
operator|&&
operator|!
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
name|m
operator|=
name|m
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|groupLeaderForWidget
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|modalWidget
operator|!=
name|widget
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
block|}
case|case
name|Qt
operator|::
name|WindowModal
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
name|widget
decl_stmt|;
do|do
block|{
name|QWidget
modifier|*
name|m
init|=
name|modalWidget
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|w
condition|)
return|return
literal|true
return|;
name|m
operator|=
name|m
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|=
name|m
operator|->
name|window
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|w
operator|=
name|w
operator|->
name|window
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
break|break;
block|}
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QApplication"
argument_list|,
literal|"internal error, a modal widget cannot be modeless"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|enterModal
name|void
name|QApplicationPrivate
operator|::
name|enterModal
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QSet
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|blocked
decl_stmt|;
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|windows
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Tool
operator|&&
name|isBlockedByModal
argument_list|(
name|window
argument_list|)
condition|)
name|blocked
operator|.
name|insert
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
name|enterModal_sys
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|windows
operator|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WindowBlocked
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|blocked
operator|.
name|contains
argument_list|(
name|window
argument_list|)
operator|&&
name|window
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Tool
operator|&&
name|isBlockedByModal
argument_list|(
name|window
argument_list|)
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|leaveModal
name|void
name|QApplicationPrivate
operator|::
name|leaveModal
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QSet
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|blocked
decl_stmt|;
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|windows
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Tool
operator|&&
name|isBlockedByModal
argument_list|(
name|window
argument_list|)
condition|)
name|blocked
operator|.
name|insert
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
name|leaveModal_sys
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|windows
operator|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WindowUnblocked
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|windows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocked
operator|.
name|contains
argument_list|(
name|window
argument_list|)
operator|&&
name|window
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Tool
operator|&&
operator|!
name|isBlockedByModal
argument_list|(
name|window
argument_list|)
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|window
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!\internal    Called from qapplication_\e{platform}.cpp, returns true   if the widget should accept the event.  */
end_comment
begin_function
DECL|function|tryModalHelper
name|bool
name|QApplicationPrivate
operator|::
name|tryModalHelper
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|rettop
parameter_list|)
block|{
name|QWidget
modifier|*
name|top
init|=
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|rettop
condition|)
operator|*
name|rettop
operator|=
name|top
expr_stmt|;
comment|// the active popup widget always gets the input event
if|if
condition|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
condition|)
return|return
literal|true
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|top
operator|=
name|QApplicationPrivate
operator|::
name|tryModalHelper_sys
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|rettop
condition|)
operator|*
name|rettop
operator|=
name|top
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|isBlockedByModal
argument_list|(
name|widget
operator|->
name|window
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    \internal */
end_comment
begin_function
DECL|function|pickMouseReceiver
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|pickMouseReceiver
parameter_list|(
name|QWidget
modifier|*
name|candidate
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|globalPos
parameter_list|,
name|QPoint
modifier|*
name|pos
parameter_list|,
name|QEvent
operator|::
name|Type
name|type
parameter_list|,
name|Qt
operator|::
name|MouseButtons
name|buttons
parameter_list|,
name|QWidget
modifier|*
name|buttonDown
parameter_list|,
name|QWidget
modifier|*
name|alienWidget
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|mouseGrabber
init|=
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|buttons
operator|)
operator|||
operator|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|)
operator|)
operator|&&
operator|!
name|buttonDown
operator|&&
operator|!
name|mouseGrabber
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|alienWidget
operator|&&
name|alienWidget
operator|->
name|internalWinId
argument_list|()
condition|)
name|alienWidget
operator|=
literal|0
expr_stmt|;
name|QWidget
modifier|*
name|receiver
init|=
name|candidate
decl_stmt|;
if|if
condition|(
operator|!
name|mouseGrabber
condition|)
name|mouseGrabber
operator|=
operator|(
name|buttonDown
operator|&&
operator|!
name|isBlockedByModal
argument_list|(
name|buttonDown
argument_list|)
operator|)
condition|?
name|buttonDown
else|:
name|alienWidget
expr_stmt|;
if|if
condition|(
name|mouseGrabber
operator|&&
name|mouseGrabber
operator|!=
name|candidate
condition|)
block|{
name|receiver
operator|=
name|mouseGrabber
expr_stmt|;
operator|*
name|pos
operator|=
name|receiver
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"  ** receiver adjusted to:"
operator|<<
name|receiver
operator|<<
literal|"pos:"
operator|<<
name|pos
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|receiver
return|;
block|}
end_function
begin_comment
comment|/*    \internal */
end_comment
begin_function
DECL|function|sendMouseEvent
name|bool
name|QApplicationPrivate
operator|::
name|sendMouseEvent
parameter_list|(
name|QWidget
modifier|*
name|receiver
parameter_list|,
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|QWidget
modifier|*
name|alienWidget
parameter_list|,
name|QWidget
modifier|*
name|nativeWidget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|buttonDown
parameter_list|,
name|QPointer
argument_list|<
name|QWidget
argument_list|>
modifier|&
name|lastMouseReceiver
parameter_list|,
name|bool
name|spontaneous
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|nativeWidget
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|buttonDown
argument_list|)
expr_stmt|;
if|if
condition|(
name|alienWidget
operator|&&
operator|!
name|isAlien
argument_list|(
name|alienWidget
argument_list|)
condition|)
name|alienWidget
operator|=
literal|0
expr_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|receiverGuard
init|=
name|receiver
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|nativeGuard
init|=
name|nativeWidget
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|alienGuard
init|=
name|alienWidget
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|activePopupWidget
init|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|graphicsWidget
init|=
name|nativeWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|buttonDown
condition|)
block|{
if|if
condition|(
operator|!
name|graphicsWidget
condition|)
block|{
comment|// Register the widget that shall receive a leave event
comment|// after the last button is released.
if|if
condition|(
operator|(
name|alienWidget
operator|||
operator|!
name|receiver
operator|->
name|internalWinId
argument_list|()
operator|)
operator|&&
operator|!
name|leaveAfterRelease
operator|&&
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|leaveAfterRelease
operator|=
operator|*
name|buttonDown
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
operator|*
name|buttonDown
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lastMouseReceiver
condition|)
block|{
comment|// Dispatch enter/leave if we move:
comment|// 1) from an alien widget to another alien widget or
comment|//    from a native widget to an alien widget (first OR case)
comment|// 2) from an alien widget to a native widget (second OR case)
if|if
condition|(
operator|(
name|alienWidget
operator|&&
name|alienWidget
operator|!=
name|lastMouseReceiver
operator|)
operator|||
operator|(
name|isAlien
argument_list|(
name|lastMouseReceiver
argument_list|)
operator|&&
operator|!
name|alienWidget
operator|)
condition|)
block|{
if|if
condition|(
name|activePopupWidget
condition|)
block|{
if|if
condition|(
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|dispatchEnterLeave
argument_list|(
name|alienWidget
condition|?
name|alienWidget
else|:
name|nativeWidget
argument_list|,
name|lastMouseReceiver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dispatchEnterLeave
argument_list|(
name|receiver
argument_list|,
name|lastMouseReceiver
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::sendMouseEvent: receiver:"
operator|<<
name|receiver
operator|<<
literal|"pos:"
operator|<<
name|event
operator|->
name|pos
argument_list|()
operator|<<
literal|"alien"
operator|<<
name|alienWidget
operator|<<
literal|"button down"
operator|<<
operator|*
name|buttonDown
operator|<<
literal|"last"
operator|<<
name|lastMouseReceiver
operator|<<
literal|"leave after release"
operator|<<
name|leaveAfterRelease
expr_stmt|;
endif|#
directive|endif
comment|// We need this quard in case someone opens a modal dialog / popup. If that's the case
comment|// leaveAfterRelease is set to null, but we shall not update lastMouseReceiver.
specifier|const
name|bool
name|wasLeaveAfterRelease
init|=
name|leaveAfterRelease
operator|!=
literal|0
decl_stmt|;
name|bool
name|result
decl_stmt|;
if|if
condition|(
name|spontaneous
condition|)
name|result
operator|=
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|graphicsWidget
operator|&&
name|leaveAfterRelease
operator|&&
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
operator|&&
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
operator|!=
name|leaveAfterRelease
condition|)
block|{
comment|// Dispatch enter/leave if:
comment|// 1) the mouse grabber is an alien widget
comment|// 2) the button is released on an alien widget
name|QWidget
modifier|*
name|enter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nativeGuard
condition|)
name|enter
operator|=
name|alienGuard
condition|?
name|alienWidget
else|:
name|nativeWidget
expr_stmt|;
else|else
comment|// The receiver is typically deleted on mouse release with drag'n'drop.
name|enter
operator|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|dispatchEnterLeave
argument_list|(
name|enter
argument_list|,
name|leaveAfterRelease
argument_list|)
expr_stmt|;
name|leaveAfterRelease
operator|=
literal|0
expr_stmt|;
name|lastMouseReceiver
operator|=
name|enter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wasLeaveAfterRelease
condition|)
block|{
if|if
condition|(
name|activePopupWidget
condition|)
block|{
if|if
condition|(
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|lastMouseReceiver
operator|=
name|alienGuard
condition|?
name|alienWidget
else|:
operator|(
name|nativeGuard
condition|?
name|nativeWidget
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lastMouseReceiver
operator|=
name|receiverGuard
condition|?
name|receiver
else|:
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
end_if
begin_comment
comment|/*     This function should only be called when the widget changes visibility, i.e.     when the \a widget is shown, hidden or deleted. This function does nothing     if the widget is a top-level or native, i.e. not an alien widget. In that     case enter/leave events are genereated by the underlying windowing system. */
end_comment
begin_decl_stmt
specifier|extern
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|qt_last_mouse_receiver
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|QWidget
modifier|*
name|qt_button_down
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|sendSyntheticEnterLeave
name|void
name|QApplicationPrivate
operator|::
name|sendSyntheticEnterLeave
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
if|if
condition|(
operator|!
name|widget
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
else|#
directive|else
if|if
condition|(
operator|!
name|widget
operator|||
name|widget
operator|->
name|internalWinId
argument_list|()
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
endif|#
directive|endif
specifier|const
name|bool
name|widgetInShow
init|=
name|widget
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|widget
operator|->
name|data
operator|->
name|in_destructor
decl_stmt|;
if|if
condition|(
operator|!
name|widgetInShow
operator|&&
name|widget
operator|!=
name|qt_last_mouse_receiver
condition|)
return|return;
comment|// Widget was not under the cursor when it was hidden/deleted.
if|if
condition|(
name|widgetInShow
operator|&&
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|data
operator|->
name|in_show
condition|)
return|return;
comment|// Ingore recursive show.
name|QWidget
modifier|*
name|mouseGrabber
init|=
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
decl_stmt|;
if|if
condition|(
name|mouseGrabber
operator|&&
name|mouseGrabber
operator|!=
name|widget
condition|)
return|return;
comment|// Someone else has the grab; enter/leave should not occur.
name|QWidget
modifier|*
name|tlw
init|=
name|widget
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlw
operator|->
name|data
operator|->
name|in_destructor
operator|||
name|tlw
operator|->
name|data
operator|->
name|is_closing
condition|)
return|return;
comment|// Closing down the business.
if|if
condition|(
name|widgetInShow
operator|&&
operator|(
operator|!
name|qt_last_mouse_receiver
operator|||
name|qt_last_mouse_receiver
operator|->
name|window
argument_list|()
operator|!=
name|tlw
operator|)
condition|)
return|return;
comment|// Mouse cursor not inside the widget's top-level.
specifier|const
name|QPoint
name|globalPos
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|windowPos
init|=
name|tlw
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
decl_stmt|;
comment|// Find the current widget under the mouse. If this function was called from
comment|// the widget's destructor, we have to make sure childAt() doesn't take into
comment|// account widgets that are about to be destructed.
name|QWidget
modifier|*
name|widgetUnderCursor
init|=
name|tlw
operator|->
name|d_func
argument_list|()
operator|->
name|childAt_helper
argument_list|(
name|windowPos
argument_list|,
name|widget
operator|->
name|data
operator|->
name|in_destructor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widgetUnderCursor
condition|)
name|widgetUnderCursor
operator|=
name|tlw
expr_stmt|;
name|QPoint
name|pos
init|=
name|widgetUnderCursor
operator|->
name|mapFrom
argument_list|(
name|tlw
argument_list|,
name|windowPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|widgetInShow
operator|&&
name|widgetUnderCursor
operator|!=
name|widget
operator|&&
operator|!
name|widget
operator|->
name|isAncestorOf
argument_list|(
name|widgetUnderCursor
argument_list|)
condition|)
return|return;
comment|// Mouse cursor not inside the widget or any of its children.
if|if
condition|(
name|widget
operator|->
name|data
operator|->
name|in_destructor
operator|&&
name|qt_button_down
operator|==
name|widget
condition|)
name|qt_button_down
operator|=
literal|0
expr_stmt|;
comment|// Send enter/leave events followed by a mouse move on the entered widget.
name|QMouseEvent
name|e
argument_list|(
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|pos
argument_list|,
name|windowPos
argument_list|,
name|globalPos
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
name|sendMouseEvent
argument_list|(
name|widgetUnderCursor
argument_list|,
operator|&
name|e
argument_list|,
name|widgetUnderCursor
argument_list|,
name|tlw
argument_list|,
operator|&
name|qt_button_down
argument_list|,
name|qt_last_mouse_receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_CURSOR
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_WS_WIN || Q_WS_X11 || Q_WS_MAC
end_comment
begin_comment
comment|/*!     Returns the desktop widget (also called the root window).      The desktop may be composed of multiple screens, so it would be incorrect,     for example, to attempt to \e center some widget in the desktop's geometry.     QDesktopWidget has various functions for obtaining useful geometries upon     the desktop, such as QDesktopWidget::screenGeometry() and     QDesktopWidget::availableGeometry().      On X11, it is also possible to draw on the desktop. */
end_comment
begin_function
DECL|function|desktop
name|QDesktopWidget
modifier|*
name|QApplication
operator|::
name|desktop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qt_desktopWidget
operator|||
comment|// not created yet
operator|!
operator|(
name|qt_desktopWidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
comment|// reparented away
name|qt_desktopWidget
operator|=
operator|new
name|QDesktopWidget
argument_list|()
expr_stmt|;
block|}
return|return
name|qt_desktopWidget
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CLIPBOARD
argument_list|)
end_if
begin_comment
comment|/*!     Returns a pointer to the application global clipboard.      \note The QApplication object should already be constructed before     accessing the clipboard. */
end_comment
begin_function
DECL|function|clipboard
name|QClipboard
modifier|*
name|QApplication
operator|::
name|clipboard
parameter_list|()
block|{
if|if
condition|(
name|qt_clipboard
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qApp
condition|)
block|{
name|qWarning
argument_list|(
literal|"QApplication: Must construct a QApplication before accessing a QClipboard"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|qt_clipboard
operator|=
operator|new
name|QClipboard
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|qt_clipboard
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_WS_QPA&& QT_NO_CLIPBOARD
end_comment
begin_comment
comment|/*!     Sets whether Qt should use the system's standard colors, fonts, etc., to     \a on. By default, this is true.      This function must be called before creating the QApplication object, like     this:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 6      \sa desktopSettingsAware() */
end_comment
begin_function
DECL|function|setDesktopSettingsAware
name|void
name|QApplication
operator|::
name|setDesktopSettingsAware
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|obey_desktop_settings
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if Qt is set to use the system's standard colors, fonts, etc.;     otherwise returns false. The default is true.      \sa setDesktopSettingsAware() */
end_comment
begin_function
DECL|function|desktopSettingsAware
name|bool
name|QApplication
operator|::
name|desktopSettingsAware
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|obey_desktop_settings
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the modifier keys on the keyboard. The current     state is updated sychronously as the event queue is emptied of events that     will spontaneously change the keyboard state (QEvent::KeyPress and     QEvent::KeyRelease events).      It should be noted this may not reflect the actual keys held on the input     device at the time of calling but rather the modifiers as last reported in     one of the above events. If no keys are being held Qt::NoModifier is     returned.      \sa mouseButtons(), queryKeyboardModifiers() */
end_comment
begin_function
DECL|function|keyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QApplication
operator|::
name|keyboardModifiers
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|modifier_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     \fn Qt::KeyboardModifiers QApplication::queryKeyboardModifiers()      Queries and returns the state of the modifier keys on the keyboard.     Unlike keyboardModifiers, this method returns the actual keys held     on the input device at the time of calling the method.      It does not rely on the keypress events having been received by this     process, which makes it possible to check the modifiers while moving     a window, for instance. Note that in most cases, you should use     keyboardModifiers(), which is faster and more accurate since it contains     the state of the modifiers as they were when the currently processed     event was received.      \sa keyboardModifiers()      \since 4.8 */
end_comment
begin_function
DECL|function|queryKeyboardModifiers
name|Qt
operator|::
name|KeyboardModifiers
name|QApplication
operator|::
name|queryKeyboardModifiers
parameter_list|()
block|{
name|qWarning
argument_list|(
literal|"queryKeyboardModifiers() doesn't have a QPA implementation"
argument_list|)
expr_stmt|;
return|return
name|QApplicationPrivate
operator|::
name|modifier_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of the buttons on the mouse. The current state is     updated syncronously as the event queue is emptied of events that will     spontaneously change the mouse state (QEvent::MouseButtonPress and     QEvent::MouseButtonRelease events).      It should be noted this may not reflect the actual buttons held on the     input device at the time of calling but rather the mouse buttons as last     reported in one of the above events. If no mouse buttons are being held     Qt::NoButton is returned.      \sa keyboardModifiers() */
end_comment
begin_function
DECL|function|mouseButtons
name|Qt
operator|::
name|MouseButtons
name|QApplication
operator|::
name|mouseButtons
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|mouse_buttons
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QApplication::isSessionRestored() const      Returns true if the application has been restored from an earlier     \l{Session Management}{session}; otherwise returns false.      \sa sessionId(), commitData(), saveState() */
end_comment
begin_comment
comment|/*!     \fn QString QApplication::sessionId() const      Returns the current \l{Session Management}{session's} identifier.      If the application has been restored from an earlier session, this     identifier is the same as it was in that previous session. The session     identifier is guaranteed to be unique both for different applications     and for different instances of the same application.      \sa isSessionRestored(), sessionKey(), commitData(), saveState() */
end_comment
begin_comment
comment|/*!     \fn QString QApplication::sessionKey() const      Returns the session key in the current \l{Session Management}{session}.      If the application has been restored from an earlier session, this key is     the same as it was when the previous session ended.      The session key changes with every call of commitData() or saveState().      \sa isSessionRestored(), sessionId(), commitData(), saveState() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_function
DECL|function|isSessionRestored
name|bool
name|QApplication
operator|::
name|isSessionRestored
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_session_restored
return|;
block|}
end_function
begin_function
DECL|function|sessionId
name|QString
name|QApplication
operator|::
name|sessionId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_id
return|;
block|}
end_function
begin_function
DECL|function|sessionKey
name|QString
name|QApplication
operator|::
name|sessionKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QApplication
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|session_key
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.2     \fn void QApplication::commitDataRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     emitted when the QSessionManager wants the application to commit all its     data.      Usually this means saving all open files, after getting permission from     the user. Furthermore you may want to provide a means by which the user     can cancel the shutdown.      You should not exit the application within this signal. Instead,     the session manager may or may not do this afterwards, depending on the     context.      \warning Within this signal, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details and example     usage.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), saveState(), {Session Management} */
end_comment
begin_comment
comment|/*!     This function deals with \l{Session Management}{session management}. It is     invoked when the QSessionManager wants the application to commit all its     data.      Usually this means saving all open files, after getting permission from the     user. Furthermore you may want to provide a means by which the user can     cancel the shutdown.      You should not exit the application within this function. Instead, the     session manager may or may not do this afterwards, depending on the     context.      \warning Within this function, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details and example     usage.      The default implementation requests interaction and sends a close event to     all visible top-level widgets. If any event was rejected, the shutdown is     canceled.      \sa isSessionRestored(), sessionId(), saveState(), {Session Management} */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_function
DECL|function|commitData
name|void
name|QApplication
operator|::
name|commitData
parameter_list|(
name|QSessionManager
modifier|&
name|manager
parameter_list|)
block|{
emit|emit
name|commitDataRequest
argument_list|(
name|manager
argument_list|)
emit|;
if|if
condition|(
name|manager
operator|.
name|allowsInteraction
argument_list|()
condition|)
block|{
name|QWidgetList
name|done
decl_stmt|;
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
name|bool
name|cancelled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|cancelled
operator|&&
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|done
operator|.
name|contains
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|cancelled
operator|=
operator|!
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cancelled
condition|)
name|done
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|list
operator|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cancelled
condition|)
name|manager
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \fn void QApplication::saveStateRequest(QSessionManager&manager)      This signal deals with \l{Session Management}{session management}. It is     invoked when the \l{QSessionManager}{session manager} wants the application     to preserve its state for a future session.      For example, a text editor would create a temporary file that includes the     current contents of its edit buffers, the location of the cursor and other     aspects of the current editing session.      You should never exit the application within this signal. Instead, the     session manager may or may not do this afterwards, depending on the     context. Futhermore, most session managers will very likely request a saved     state immediately after the application has been started. This permits the     session manager to learn about the application's restart policy.      \warning Within this function, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details.      \note You should use Qt::DirectConnection when connecting to this signal.      \sa isSessionRestored(), sessionId(), commitData(), {Session Management} */
end_comment
begin_comment
comment|/*!     This function deals with \l{Session Management}{session management}. It is     invoked when the \l{QSessionManager}{session manager} wants the application     to preserve its state for a future session.      For example, a text editor would create a temporary file that includes the     current contents of its edit buffers, the location of the cursor and other     aspects of the current editing session.      You should never exit the application within this function. Instead, the     session manager may or may not do this afterwards, depending on the     context. Futhermore, most session managers will very likely request a saved     state immediately after the application has been started. This permits the     session manager to learn about the application's restart policy.      \warning Within this function, no user interaction is possible, \e     unless you ask the \a manager for explicit permission. See     QSessionManager::allowsInteraction() and     QSessionManager::allowsErrorInteraction() for details.      \sa isSessionRestored(), sessionId(), commitData(), {Session Management} */
end_comment
begin_function
DECL|function|saveState
name|void
name|QApplication
operator|::
name|saveState
parameter_list|(
name|QSessionManager
modifier|&
name|manager
parameter_list|)
block|{
emit|emit
name|saveStateRequest
argument_list|(
name|manager
argument_list|)
emit|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SESSIONMANAGER
end_comment
begin_comment
comment|/*   Sets the time after which a drag should start to \a ms ms.    \sa startDragTime() */
end_comment
begin_function
DECL|function|setStartDragTime
name|void
name|QApplication
operator|::
name|setStartDragTime
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|ms
argument_list|)
block|}
end_function
begin_comment
comment|/*!     \property QApplication::startDragTime     \brief the time in milliseconds that a mouse button must be held down     before a drag and drop operation will begin      If you support drag and drop in your application, and want to start a drag     and drop operation after the user has held down a mouse button for a     certain amount of time, you should use this property's value as the delay.      Qt also uses this delay internally, e.g. in QTextEdit and QLineEdit, for     starting a drag.      The default value is 500 ms.      \sa startDragDistance(), {Drag and Drop} */
end_comment
begin_function
DECL|function|startDragTime
name|int
name|QApplication
operator|::
name|startDragTime
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|startDragTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     Sets the distance after which a drag should start to \a l pixels.      \sa startDragDistance() */
end_comment
begin_function
DECL|function|setStartDragDistance
name|void
name|QApplication
operator|::
name|setStartDragDistance
parameter_list|(
name|int
name|l
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::startDragDistance      If you support drag and drop in your application, and want to start a drag     and drop operation after the user has moved the cursor a certain distance     with a button held down, you should use this property's value as the     minimum distance required.      For example, if the mouse position of the click is stored in \c startPos     and the current position (e.g. in the mouse move event) is \c currentPos,     you can find out if a drag should be started with code like this:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 7      Qt uses this value internally, e.g. in QFileDialog.      The default value is 4 pixels.      \sa startDragTime() QPoint::manhattanLength() {Drag and Drop} */
end_comment
begin_function
DECL|function|startDragDistance
name|int
name|QApplication
operator|::
name|startDragDistance
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|startDragDistance
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QApplication::setReverseLayout(bool reverse)      Use setLayoutDirection() instead. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::reverseLayout()      Use layoutDirection() instead. */
end_comment
begin_comment
comment|/*!     \obsolete      Strips out vertical alignment flags and transforms an alignment \a align     of Qt::AlignLeft into Qt::AlignLeft or Qt::AlignRight according to the     language used. */
end_comment
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called, then returns     the value that was set to exit() (which is 0 if exit() is called via     quit()).      It is necessary to call this function to start event handling. The main     event loop receives events from the window system and dispatches these to     the application widgets.      Generally, no user interaction can take place before calling exec(). As a     special case, modal widgets like QMessageBox can be used before calling     exec(), because modal widgets call exec() to start a local event loop.      To make your application perform idle processing, i.e., executing a special     function whenever there are no pending events, use a QTimer with 0 timeout.     More advanced idle processing schemes can be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your     application's \c{main()} function. This is because, on some platforms the     QApplication::exec() call may not return. For example, on the Windows     platform, when the user logs off, the system terminates the process after Qt     closes all top-level windows. Hence, there is \e{no guarantee} that the     application will have time to exit its event loop and execute code at the     end of the \c{main()} function, after the QApplication::exec() call.      \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),         QCoreApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QApplication
operator|::
name|exec
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|setRootObject
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QApplicationBase
operator|::
name|exec
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|notify
name|bool
name|QApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
comment|// no events are delivered after ~QCoreApplication() has started
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
comment|// serious error
name|qWarning
argument_list|(
literal|"QApplication::notify: Unexpected null receiver"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|d
operator|->
name|checkReceiverThread
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// capture the current mouse/keyboard state
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyRelease
condition|)
block|{
name|QKeyEvent
modifier|*
name|ke
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|ke
operator|->
name|modifiers
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
condition|)
block|{
name|QMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|me
operator|->
name|modifiers
argument_list|()
expr_stmt|;
if|if
condition|(
name|me
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
condition|)
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator||=
name|me
operator|->
name|button
argument_list|()
expr_stmt|;
else|else
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|&=
operator|~
name|me
operator|->
name|button
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_WHEELEVENT
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_TABLETEVENT
argument_list|)
elseif|else
if|if
condition|(
literal|false
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Wheel
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|TabletMove
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|TabletPress
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|TabletRelease
endif|#
directive|endif
condition|)
block|{
name|QInputEvent
modifier|*
name|ie
init|=
cast|static_cast
argument_list|<
name|QInputEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|ie
operator|->
name|modifiers
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// !QT_NO_WHEELEVENT || !QT_NO_TABLETEVENT
block|}
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
comment|// walk through parents and check for gestures
if|if
condition|(
name|d
operator|->
name|gestureManager
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Paint
case|:
case|case
name|QEvent
operator|::
name|MetaCall
case|:
case|case
name|QEvent
operator|::
name|DeferredDelete
case|:
case|case
name|QEvent
operator|::
name|DragEnter
case|:
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragResponse
case|:
case|case
name|QEvent
operator|::
name|ChildAdded
case|:
case|case
name|QEvent
operator|::
name|ChildPolished
case|:
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
case|case
name|QEvent
operator|::
name|UpdateRequest
case|:
case|case
name|QEvent
operator|::
name|UpdateLater
case|:
case|case
name|QEvent
operator|::
name|AccessibilityPrepare
case|:
case|case
name|QEvent
operator|::
name|LocaleChange
case|:
case|case
name|QEvent
operator|::
name|Style
case|:
case|case
name|QEvent
operator|::
name|IconDrag
case|:
case|case
name|QEvent
operator|::
name|StyleChange
case|:
case|case
name|QEvent
operator|::
name|AccessibilityHelp
case|:
case|case
name|QEvent
operator|::
name|AccessibilityDescription
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDrop
case|:
case|case
name|QEvent
operator|::
name|DynamicPropertyChange
case|:
case|case
name|QEvent
operator|::
name|NetworkReplyUpdated
case|:
break|break;
default|default:
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|gestureManager
operator|->
name|filterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// a special case for events that go to QGesture objects.
comment|// We pass the object to the gesture manager and it'll figure
comment|// out if it's QGesture or not.
if|if
condition|(
name|d
operator|->
name|gestureManager
operator|->
name|filterEvent
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
comment|// User input and window activation makes tooltips sleep
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Wheel
case|:
case|case
name|QEvent
operator|::
name|ActivationChange
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
case|case
name|QEvent
operator|::
name|FocusOut
case|:
case|case
name|QEvent
operator|::
name|FocusIn
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// fall-through
case|case
name|QEvent
operator|::
name|Leave
case|:
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|bool
name|res
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
block|{
name|bool
name|isWidget
init|=
name|receiver
operator|->
name|isWidgetType
argument_list|()
decl_stmt|;
name|bool
name|isGraphicsWidget
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|isGraphicsWidget
operator|=
operator|!
name|isWidget
operator|&&
name|qobject_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isWidget
operator|&&
operator|!
name|isGraphicsWidget
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|QKeyEvent
modifier|*
name|key
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
comment|// Try looking for a Shortcut before sending key events
if|if
condition|(
operator|(
name|res
operator|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|tryShortcutEvent
argument_list|(
name|receiver
argument_list|,
name|key
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
name|qt_in_tab_key_event
operator|=
operator|(
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Left
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Right
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
expr_stmt|;
block|}
name|bool
name|def
init|=
name|key
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|pr
init|=
name|receiver
decl_stmt|;
while|while
condition|(
name|receiver
condition|)
block|{
if|if
condition|(
name|def
condition|)
name|key
operator|->
name|accept
argument_list|()
expr_stmt|;
else|else
name|key
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|isWidget
condition|?
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QGraphicsWidget
modifier|*
name|gw
init|=
name|isGraphicsWidget
condition|?
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|&&
name|key
operator|->
name|isAccepted
argument_list|()
operator|)
comment|/*                        QLineEdit will emit a signal on Key_Return, but                        ignore the event, and sometimes the connected                        slot deletes the QLineEdit (common in itemview                        delegates), so we have to check if the widget                        was destroyed even if the event was ignored (to                        prevent a crash)                         note that we don't have to reset pw while                        propagating (because the original receiver will                        be destroyed if one of its ancestors is)                     */
operator|||
operator|!
name|pr
operator|||
operator|(
name|isWidget
operator|&&
operator|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
operator|!
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
operator|)
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
operator|(
name|isGraphicsWidget
operator|&&
operator|(
name|gw
operator|->
name|isWindow
argument_list|()
operator|||
operator|!
name|gw
operator|->
name|parentWidget
argument_list|()
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|receiver
operator|=
name|w
condition|?
operator|(
name|QObject
operator|*
operator|)
name|w
operator|->
name|parentWidget
argument_list|()
else|:
operator|(
name|QObject
operator|*
operator|)
name|gw
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
else|#
directive|else
name|receiver
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|qt_in_tab_key_event
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QMouseEvent
modifier|*
name|mouse
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|mouse
operator|->
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
condition|)
block|{
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|w
argument_list|,
name|Qt
operator|::
name|ClickFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
comment|// ### Qt 5 These dynamic tool tips should be an OPT-IN feature. Some platforms
comment|// like Mac OS X (probably others too), can optimize their views by not
comment|// dispatching mouse move events. We have attributes to control hover,
comment|// and mouse tracking, but as long as we are deciding to implement this
comment|// feature without choice of opting-in or out, you ALWAYS have to have
comment|// tracking enabled. Therefore, the other properties give a false sense of
comment|// performance enhancement.
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|mouse
operator|->
name|buttons
argument_list|()
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|toolTipWidget
operator|=
name|w
expr_stmt|;
name|d
operator|->
name|toolTipPos
operator|=
name|relpos
expr_stmt|;
name|d
operator|->
name|toolTipGlobalPos
operator|=
name|mouse
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|d
operator|->
name|toolTipWakeUp
operator|.
name|start
argument_list|(
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|isActive
argument_list|()
condition|?
literal|20
else|:
literal|700
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|eventAccepted
init|=
name|mouse
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|pw
init|=
name|w
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QMouseEvent
name|me
argument_list|(
name|mouse
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|mouse
operator|->
name|windowPos
argument_list|()
argument_list|,
name|mouse
operator|->
name|globalPos
argument_list|()
argument_list|,
name|mouse
operator|->
name|button
argument_list|()
argument_list|,
name|mouse
operator|->
name|buttons
argument_list|()
argument_list|,
name|mouse
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|me
operator|.
name|spont
operator|=
name|mouse
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|me
operator|.
name|setTimestamp
argument_list|(
name|mouse
operator|->
name|timestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// throw away any mouse-tracking-only mouse events
if|if
condition|(
operator|!
name|w
operator|->
name|hasMouseTracking
argument_list|()
operator|&&
name|mouse
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|mouse
operator|->
name|buttons
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// but still send them through all application event filters (normally done by notify_helper)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|d
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QApplication: Object event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
argument_list|)
condition|)
break|break;
block|}
name|res
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMouseReplay
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
argument_list|)
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
block|}
name|eventAccepted
operator|=
operator|(
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|eventAccepted
condition|)
break|break;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|mouse
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
condition|)
block|{
if|if
condition|(
operator|!
name|pw
condition|)
break|break;
name|w
operator|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|relpos
operator|=
name|mouse
operator|->
name|pos
argument_list|()
expr_stmt|;
name|QPoint
name|diff
init|=
name|relpos
operator|-
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|d
operator|->
name|hoverGlobalPos
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverMove
argument_list|,
name|relpos
argument_list|,
name|relpos
operator|-
name|diff
argument_list|,
name|mouse
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|hoverGlobalPos
operator|=
name|mouse
operator|->
name|globalPos
argument_list|()
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QWheelEvent
modifier|*
name|wheel
init|=
cast|static_cast
argument_list|<
name|QWheelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|wheel
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|wheel
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|w
argument_list|,
name|Qt
operator|::
name|WheelFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|w
condition|)
block|{
name|QWheelEvent
name|we
argument_list|(
name|relpos
argument_list|,
name|wheel
operator|->
name|globalPos
argument_list|()
argument_list|,
name|wheel
operator|->
name|delta
argument_list|()
argument_list|,
name|wheel
operator|->
name|buttons
argument_list|()
argument_list|,
name|wheel
operator|->
name|modifiers
argument_list|()
argument_list|,
name|wheel
operator|->
name|orientation
argument_list|()
argument_list|)
decl_stmt|;
name|we
operator|.
name|spont
operator|=
name|wheel
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|wheel
else|:
operator|&
name|we
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|wheel
else|:
operator|&
name|we
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|wheel
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QContextMenuEvent
modifier|*
name|context
init|=
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|context
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|context
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QContextMenuEvent
name|ce
argument_list|(
name|context
operator|->
name|reason
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|context
operator|->
name|globalPos
argument_list|()
argument_list|,
name|context
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|context
else|:
operator|&
name|ce
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|context
else|:
operator|&
name|ce
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|context
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QTabletEvent
modifier|*
name|tablet
init|=
cast|static_cast
argument_list|<
name|QTabletEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|tablet
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|tablet
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QTabletEvent
name|te
argument_list|(
name|tablet
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|tablet
operator|->
name|globalPos
argument_list|()
argument_list|,
name|tablet
operator|->
name|hiResGlobalPos
argument_list|()
argument_list|,
name|tablet
operator|->
name|device
argument_list|()
argument_list|,
name|tablet
operator|->
name|pointerType
argument_list|()
argument_list|,
name|tablet
operator|->
name|pressure
argument_list|()
argument_list|,
name|tablet
operator|->
name|xTilt
argument_list|()
argument_list|,
name|tablet
operator|->
name|yTilt
argument_list|()
argument_list|,
name|tablet
operator|->
name|tangentialPressure
argument_list|()
argument_list|,
name|tablet
operator|->
name|rotation
argument_list|()
argument_list|,
name|tablet
operator|->
name|z
argument_list|()
argument_list|,
name|tablet
operator|->
name|modifiers
argument_list|()
argument_list|,
name|tablet
operator|->
name|uniqueId
argument_list|()
argument_list|)
decl_stmt|;
name|te
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|tablet
else|:
operator|&
name|te
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|tablet
else|:
operator|&
name|te
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|tablet
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
name|qt_tabletChokeMouse
operator|=
name|tablet
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TOOLTIP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_WHATSTHIS
argument_list|)
case|case
name|QEvent
operator|::
name|ToolTip
case|:
case|case
name|QEvent
operator|::
name|WhatsThis
case|:
case|case
name|QEvent
operator|::
name|QueryWhatsThis
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QHelpEvent
modifier|*
name|help
init|=
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|help
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|help
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QHelpEvent
name|he
argument_list|(
name|help
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|help
operator|->
name|globalPos
argument_list|()
argument_list|)
decl_stmt|;
name|he
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|help
else|:
operator|&
name|he
argument_list|)
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
name|eventAccepted
operator|=
operator|(
name|w
operator|==
name|receiver
condition|?
name|help
else|:
operator|&
name|he
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|help
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_STATUSTIP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_WHATSTHIS
argument_list|)
case|case
name|QEvent
operator|::
name|StatusTip
case|:
case|case
name|QEvent
operator|::
name|WhatsThisClicked
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|e
operator|->
name|isAccepted
argument_list|()
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|QEvent
operator|::
name|DragEnter
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QDragEnterEvent
modifier|*
name|dragEvent
init|=
cast|static_cast
argument_list|<
name|QDragEnterEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// HIView has a slight difference in how it delivers events to children and parents
comment|// It will not give a leave to a child's parent when it enters a child.
name|QWidget
modifier|*
name|currentTarget
init|=
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|currentTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentTarget
condition|)
block|{
comment|// Assume currentTarget did not get a leave
name|QDragLeaveEvent
name|event
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|currentTarget
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// QGraphicsProxyWidget handles its own propagation,
comment|// and we must not change QDragManagers currentTarget.
name|QWExtra
modifier|*
name|extra
init|=
name|w
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|dragEvent
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|isEnabled
argument_list|()
operator|&&
name|w
operator|->
name|acceptDrops
argument_list|()
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|dragEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|dragEvent
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|setCurrentTarget
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|dragEvent
operator|->
name|p
operator|=
name|w
operator|->
name|mapToParent
argument_list|(
name|dragEvent
operator|->
name|p
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// QGraphicsProxyWidget handles its own propagation,
comment|// and we must not change QDragManagers currentTarget.
name|QWExtra
modifier|*
name|extra
init|=
name|w
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
name|bool
name|isProxyWidget
init|=
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
decl_stmt|;
if|if
condition|(
operator|!
name|isProxyWidget
condition|)
endif|#
directive|endif
name|w
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|currentTarget
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// HIView has a slight difference in how it delivers events to children and parents
comment|// It will not give an enter to a child's parent when it leaves the child.
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragLeave
condition|)
break|break;
comment|// Assume that w did not get an enter.
name|QDropEvent
modifier|*
name|dropEvent
init|=
cast|static_cast
argument_list|<
name|QDropEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QDragEnterEvent
name|dragEnterEvent
argument_list|(
name|dropEvent
operator|->
name|pos
argument_list|()
argument_list|,
name|dropEvent
operator|->
name|possibleActions
argument_list|()
argument_list|,
name|dropEvent
operator|->
name|mimeData
argument_list|()
argument_list|,
name|dropEvent
operator|->
name|mouseButtons
argument_list|()
argument_list|,
name|dropEvent
operator|->
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|receiver
argument_list|,
operator|&
name|dragEnterEvent
argument_list|)
expr_stmt|;
name|w
operator|=
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|currentTarget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragMove
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Drop
condition|)
block|{
name|QDropEvent
modifier|*
name|dragEvent
init|=
cast|static_cast
argument_list|<
name|QDropEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|origReciver
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|origReciver
operator|&&
name|w
operator|!=
name|origReciver
condition|)
block|{
name|dragEvent
operator|->
name|p
operator|=
name|origReciver
operator|->
name|mapToParent
argument_list|(
name|dragEvent
operator|->
name|p
argument_list|)
expr_stmt|;
name|origReciver
operator|=
name|origReciver
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|!=
name|QEvent
operator|::
name|DragMove
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|&&
operator|!
name|isProxyWidget
endif|#
directive|endif
condition|)
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|setCurrentTarget
argument_list|(
literal|0
argument_list|,
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Drop
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
comment|// Note: TouchUpdate and TouchEnd events are never propagated
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QTouchEvent
modifier|*
name|touchEvent
init|=
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
operator|&&
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
comment|// give the widget focus if the focus policy allows it
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|widget
argument_list|,
name|Qt
operator|::
name|ClickFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|widget
condition|)
block|{
comment|// first, try to deliver the touch event
name|bool
name|acceptTouchEvents
init|=
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
decl_stmt|;
name|touchEvent
operator|->
name|setWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|acceptTouchEvents
argument_list|)
expr_stmt|;
name|QWeakPointer
argument_list|<
name|QWidget
argument_list|>
name|p
init|=
name|widget
decl_stmt|;
name|res
operator|=
name|acceptTouchEvents
operator|&&
name|d
operator|->
name|notify_helper
argument_list|(
name|widget
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// widget was deleted
name|widget
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|,
name|res
operator|&&
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
name|touchEvent
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|eventAccepted
condition|)
block|{
comment|// the first widget to accept the TouchBegin gets an implicit grab.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|d
operator|->
name|widgetForTouchPointId
index|[
name|touchPoint
operator|.
name|id
argument_list|()
index|]
operator|=
name|widget
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|isNull
argument_list|()
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
operator|||
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
block|{
break|break;
block|}
name|QPoint
name|offset
init|=
name|widget
operator|->
name|pos
argument_list|()
decl_stmt|;
name|widget
operator|=
name|widget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|touchEvent
operator|->
name|setWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|_touchPoints
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|pt
init|=
name|touchEvent
operator|->
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
name|QRectF
name|rect
init|=
name|pt
operator|.
name|rect
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|startPos
operator|=
name|pt
operator|.
name|startPos
argument_list|()
operator|+
name|offset
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|lastPos
operator|=
name|pt
operator|.
name|lastPos
argument_list|()
operator|+
name|offset
expr_stmt|;
block|}
block|}
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|RequestSoftwareInputPanel
case|:
name|inputPanel
argument_list|()
operator|->
name|show
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|CloseSoftwareInputPanel
case|:
name|inputPanel
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|NativeGesture
case|:
block|{
comment|// only propagate the first gesture event (after the GID_BEGIN)
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|e
operator|->
name|isAccepted
argument_list|()
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|Gesture
case|:
case|case
name|QEvent
operator|::
name|GestureOverride
case|:
block|{
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QGestureEvent
modifier|*
name|gestureEvent
init|=
cast|static_cast
argument_list|<
name|QGestureEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|allGestures
init|=
name|gestureEvent
operator|->
name|gestures
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|gestureEvent
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|bool
name|wasAccepted
init|=
name|eventAccepted
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
comment|// send only gestures the widget expects
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|gestures
decl_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allGestures
operator|.
name|size
argument_list|()
condition|;
control|)
block|{
name|QGesture
modifier|*
name|g
init|=
name|allGestures
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|GestureType
name|type
init|=
name|g
operator|->
name|gestureType
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|Qt
operator|::
name|GestureType
argument_list|,
name|Qt
operator|::
name|GestureFlags
argument_list|>
operator|::
name|iterator
name|contextit
init|=
name|wd
operator|->
name|gestureContext
operator|.
name|find
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bool
name|deliver
init|=
name|contextit
operator|!=
name|wd
operator|->
name|gestureContext
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|g
operator|->
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|GestureStarted
operator|||
name|w
operator|==
name|receiver
operator|||
operator|(
name|contextit
operator|.
name|value
argument_list|()
operator|&
name|Qt
operator|::
name|ReceivePartialGestures
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|deliver
condition|)
block|{
name|allGestures
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gestures
operator|.
name|append
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we have gestures for this w
name|QGestureEvent
name|ge
argument_list|(
name|gestures
argument_list|)
decl_stmt|;
name|ge
operator|.
name|t
operator|=
name|gestureEvent
operator|->
name|t
expr_stmt|;
name|ge
operator|.
name|spont
operator|=
name|gestureEvent
operator|->
name|spont
expr_stmt|;
name|ge
operator|.
name|m_accept
operator|=
name|wasAccepted
expr_stmt|;
name|ge
operator|.
name|d_func
argument_list|()
operator|->
name|accepted
operator|=
name|gestureEvent
operator|->
name|d_func
argument_list|()
operator|->
name|accepted
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|ge
argument_list|)
expr_stmt|;
name|gestureEvent
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
name|eventAccepted
operator|=
name|ge
operator|.
name|isAccepted
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gestures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGesture
modifier|*
name|g
init|=
name|gestures
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Ignore res [event return value] because handling of multiple gestures
comment|// packed into a single QEvent depends on not consuming the event
if|if
condition|(
name|eventAccepted
operator|||
name|ge
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|// if the gesture was accepted, mark the target widget for it
name|gestureEvent
operator|->
name|d_func
argument_list|()
operator|->
name|targetWidgets
index|[
name|g
operator|->
name|gestureType
argument_list|()
index|]
operator|=
name|w
expr_stmt|;
name|gestureEvent
operator|->
name|setAccepted
argument_list|(
name|g
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the gesture was explicitly ignored by the application,
comment|// put it back so a parent can get it
name|allGestures
operator|.
name|append
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|allGestures
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// everything delivered
break|break;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|allGestures
control|)
name|gestureEvent
operator|->
name|setAccepted
argument_list|(
name|g
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|gestureEvent
operator|->
name|m_accept
operator|=
literal|false
expr_stmt|;
comment|// to make sure we check individual gestures
block|}
else|else
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
ifdef|#
directive|ifdef
name|Q_WS_MAC
case|case
name|QEvent
operator|::
name|Enter
case|:
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
condition|)
name|qt_widget_private
argument_list|(
name|w
argument_list|)
operator|->
name|registerTouchWindow
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Leave
case|:
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
condition|)
name|qt_widget_private
argument_list|(
name|w
argument_list|)
operator|->
name|registerTouchWindow
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|notify_helper
name|bool
name|QApplicationPrivate
operator|::
name|notify_helper
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// send to all application event filters
if|if
condition|(
name|sendThroughApplicationEventFilters
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_WINCE
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|GWES_ICONCURS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
operator|)
comment|// toggle HasMouse widget state on enter and leave
if|if
condition|(
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Enter
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragEnter
operator|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|widget
operator|->
name|window
argument_list|()
operator|)
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UnderMouse
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Leave
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragLeave
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UnderMouse
argument_list|,
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QLayout
modifier|*
name|layout
init|=
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
block|{
name|layout
operator|->
name|widgetEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// send to all receiver event filters
if|if
condition|(
name|sendThroughObjectEventFilters
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// deliver the event
name|bool
name|consumed
init|=
name|receiver
operator|->
name|event
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
return|return
name|consumed
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSessionManager     \brief The QSessionManager class provides access to the session manager.      \inmodule QtWidgets      A session manager in a desktop environment (in which Qt GUI applications     live) keeps track of a session, which is a group of running applications,     each of which has a particular state. The state of an application contains     (most notably) the documents the application has open and the position and     size of its windows.      The session manager is used to save the session, e.g., when the machine is     shut down, and to restore a session, e.g., when the machine is started up.     We recommend that you use QSettings to save an application's settings,     for example, window positions, recently used files, etc. When the     application is restarted by the session manager, you can restore the     settings.      QSessionManager provides an interface between the application and the     session manager so that the program can work well with the session manager.     In Qt, session management requests for action are handled by the two     virtual functions QApplication::commitData() and QApplication::saveState().     Both provide a reference to a session manager object as argument, to allow     the application to communicate with the session manager. The session     manager can only be accessed through these functions.      No user interaction is possible \e unless the application gets explicit     permission from the session manager. You ask for permission by calling     allowsInteraction() or, if it is really urgent, allowsErrorInteraction().     Qt does not enforce this, but the session manager may.      You can try to abort the shutdown process by calling cancel(). The default     commitData() function does this if some top-level window rejected its     closeEvent().      For sophisticated session managers provided on Unix/X11, QSessionManager     offers further possibilities to fine-tune an application's session     management behavior: setRestartCommand(), setDiscardCommand(),     setRestartHint(), setProperty(), requestPhase2(). See the respective     function descriptions for further details.      \sa QApplication, {Session Management} */
end_comment
begin_comment
comment|/*! \enum QSessionManager::RestartHint      This enum type defines the circumstances under which this application wants     to be restarted by the session manager. The current values are:      \value  RestartIfRunning    If the application is still running when the                                 session is shut down, it wants to be restarted                                 at the start of the next session.      \value  RestartAnyway       The application wants to be started at the                                 start of the next session, no matter what.                                 (This is useful for utilities that run just                                 after startup and then quit.)      \value  RestartImmediately  The application wants to be started immediately                                 whenever it is not running.      \value  RestartNever        The application does not want to be restarted                                 automatically.      The default hint is \c RestartIfRunning. */
end_comment
begin_comment
comment|/*!     \fn QString QSessionManager::sessionId() const      Returns the identifier of the current session.      If the application has been restored from an earlier session, this     identifier is the same as it was in the earlier session.      \sa sessionKey(), QApplication::sessionId() */
end_comment
begin_comment
comment|/*!     \fn QString QSessionManager::sessionKey() const      Returns the session key in the current session.      If the application has been restored from an earlier session, this key is     the same as it was when the previous session ended.      The session key changes with every call of commitData() or saveState().      \sa sessionId(), QApplication::sessionKey() */
end_comment
begin_comment
comment|/*!     \fn void* QSessionManager::handle() const      \internal */
end_comment
begin_comment
comment|/*!     \fn bool QSessionManager::allowsInteraction()      Asks the session manager for permission to interact with the user. Returns     true if interaction is permitted; otherwise returns false.      The rationale behind this mechanism is to make it possible to synchronize     user interaction during a shutdown. Advanced session managers may ask all     applications simultaneously to commit their data, resulting in a much     faster shutdown.      When the interaction is completed we strongly recommend releasing the user     interaction semaphore with a call to release(). This way, other     applications may get the chance to interact with the user while your     application is still busy saving data. (The semaphore is implicitly     released when the application exits.)      If the user decides to cancel the shutdown process during the interaction     phase, you must tell the session manager that this has happened by calling     cancel().      Here's an example of how an application's QApplication::commitData() might     be implemented:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 8      If an error occurred within the application while saving its data, you may     want to try allowsErrorInteraction() instead.      \sa QApplication::commitData(), release(), cancel() */
end_comment
begin_comment
comment|/*!     \fn bool QSessionManager::allowsErrorInteraction()      Returns true if error interaction is permitted; otherwise returns false.      This is similar to allowsInteraction(), but also enables the application to     tell the user about any errors that occur. Session managers may give error     interaction requests higher priority, which means that it is more likely     that an error interaction is permitted. However, you are still not     guaranteed that the session manager will allow interaction.      \sa allowsInteraction(), release(), cancel() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::release()      Releases the session manager's interaction semaphore after an interaction     phase.      \sa allowsInteraction(), allowsErrorInteraction() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::cancel()      Tells the session manager to cancel the shutdown process.  Applications     should not call this function without asking the user first.      \sa allowsInteraction(), allowsErrorInteraction() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::setRestartHint(RestartHint hint)      Sets the application's restart hint to \a hint. On application startup, the     hint is set to \c RestartIfRunning.      \note These flags are only hints, a session manager may or may not respect     them.      We recommend setting the restart hint in QApplication::saveState() because     most session managers perform a checkpoint shortly after an application's     startup.      \sa restartHint() */
end_comment
begin_comment
comment|/*!     \fn QSessionManager::RestartHint QSessionManager::restartHint() const      Returns the application's current restart hint. The default is     \c RestartIfRunning.      \sa setRestartHint() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::setRestartCommand(const QStringList& command)      If the session manager is capable of restoring sessions it will execute     \a command in order to restore the application. The command defaults to      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 9      The \c -session option is mandatory; otherwise QApplication cannot tell     whether it has been restored or what the current session identifier is.     See QApplication::isSessionRestored() and QApplication::sessionId() for     details.      If your application is very simple, it may be possible to store the entire     application state in additional command line options. This is usually a     very bad idea because command lines are often limited to a few hundred     bytes. Instead, use QSettings, temporary files, or a database for this     purpose. By marking the data with the unique sessionId(), you will be able     to restore the application in a future  session.      \sa restartCommand(), setDiscardCommand(), setRestartHint() */
end_comment
begin_comment
comment|/*!     \fn QStringList QSessionManager::restartCommand() const      Returns the currently set restart command.      To iterate over the list, you can use the \l foreach pseudo-keyword:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 10      \sa setRestartCommand(), restartHint() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::setDiscardCommand(const QStringList& list)      Sets the discard command to the given \a list.      \sa discardCommand(), setRestartCommand() */
end_comment
begin_comment
comment|/*!     \fn QStringList QSessionManager::discardCommand() const      Returns the currently set discard command.      To iterate over the list, you can use the \l foreach pseudo-keyword:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 11      \sa setDiscardCommand(), restartCommand(), setRestartCommand() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::setManagerProperty(const QString&name, const QString&value)     \overload      Low-level write access to the application's identification and state     records are kept in the session manager.      The property called \a name has its value set to the string \a value. */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::setManagerProperty(const QString& name,                                                  const QStringList& value)      Low-level write access to the application's identification and state record     are kept in the session manager.      The property called \a name has its value set to the string list \a value. */
end_comment
begin_comment
comment|/*!     \fn bool QSessionManager::isPhase2() const      Returns true if the session manager is currently performing a second     session management phase; otherwise returns false.      \sa requestPhase2() */
end_comment
begin_comment
comment|/*!     \fn void QSessionManager::requestPhase2()      Requests a second session management phase for the application. The     application may then return immediately from the QApplication::commitData()     or QApplication::saveState() function, and they will be called again once     most or all other applications have finished their session management.      The two phases are useful for applications such as the X11 window manager     that need to store information about another application's windows and     therefore have to wait until these applications have completed their     respective session management tasks.      \note If another application has requested a second phase it may get called     before, simultaneously with, or after your application's second phase.      \sa isPhase2() */
end_comment
begin_comment
comment|/*****************************************************************************   Stubbed session management support  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_function
DECL|function|qt_CoCreateGuid
name|HRESULT
name|qt_CoCreateGuid
parameter_list|(
name|GUID
modifier|*
name|guid
parameter_list|)
block|{
comment|// We will use the following information to create the GUID
comment|// 1. absolute path to application
name|wchar_t
name|tempFilename
index|[
name|MAX_PATH
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|GetModuleFileName
argument_list|(
literal|0
argument_list|,
name|tempFilename
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
return|return
name|S_FALSE
return|;
name|unsigned
name|int
name|hash
init|=
name|qHash
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tempFilename
argument_list|)
argument_list|)
decl_stmt|;
name|guid
operator|->
name|Data1
operator|=
name|hash
expr_stmt|;
comment|// 2. creation time of file
name|QFileInfo
name|info
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tempFilename
argument_list|)
argument_list|)
decl_stmt|;
name|guid
operator|->
name|Data2
operator|=
name|qHash
argument_list|(
name|info
operator|.
name|created
argument_list|()
operator|.
name|toTime_t
argument_list|()
argument_list|)
expr_stmt|;
comment|// 3. current system time
name|guid
operator|->
name|Data3
operator|=
name|qHash
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|S_OK
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OLE32_MCOMGUID
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_WINCE_FORCE_CREATE_GUID
argument_list|)
end_if
begin_define
DECL|macro|CoCreateGuid
define|#
directive|define
name|CoCreateGuid
value|qt_CoCreateGuid
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QSessionManagerPrivate
class|class
name|QSessionManagerPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
public|public:
DECL|member|restartCommand
name|QStringList
name|restartCommand
decl_stmt|;
DECL|member|discardCommand
name|QStringList
name|discardCommand
decl_stmt|;
DECL|member|sessionId
name|QString
name|sessionId
decl_stmt|;
DECL|member|sessionKey
name|QString
name|sessionKey
decl_stmt|;
DECL|member|restartHint
name|QSessionManager
operator|::
name|RestartHint
name|restartHint
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qt_session_manager_self
name|QSessionManager
modifier|*
name|qt_session_manager_self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QSessionManager
name|QSessionManager
operator|::
name|QSessionManager
parameter_list|(
name|QApplication
modifier|*
name|app
parameter_list|,
name|QString
modifier|&
name|id
parameter_list|,
name|QString
modifier|&
name|key
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QSessionManagerPrivate
argument_list|,
name|app
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSessionManager
argument_list|)
expr_stmt|;
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_sessionmanager"
argument_list|)
argument_list|)
expr_stmt|;
name|qt_session_manager_self
operator|=
name|this
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|wchar_t
name|guidstr
index|[
literal|40
index|]
decl_stmt|;
name|GUID
name|guid
decl_stmt|;
name|CoCreateGuid
argument_list|(
operator|&
name|guid
argument_list|)
expr_stmt|;
name|StringFromGUID2
argument_list|(
name|guid
argument_list|,
name|guidstr
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|id
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|guidstr
argument_list|)
expr_stmt|;
name|CoCreateGuid
argument_list|(
operator|&
name|guid
argument_list|)
expr_stmt|;
name|StringFromGUID2
argument_list|(
name|guid
argument_list|,
name|guidstr
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|key
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|guidstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sessionId
operator|=
name|id
expr_stmt|;
name|d
operator|->
name|sessionKey
operator|=
name|key
expr_stmt|;
name|d
operator|->
name|restartHint
operator|=
name|RestartIfRunning
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSessionManager
name|QSessionManager
operator|::
name|~
name|QSessionManager
parameter_list|()
block|{
name|qt_session_manager_self
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|sessionId
name|QString
name|QSessionManager
operator|::
name|sessionId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSessionManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sessionId
return|;
block|}
end_function
begin_function
DECL|function|sessionKey
name|QString
name|QSessionManager
operator|::
name|sessionKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSessionManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sessionKey
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
end_if
begin_function
DECL|function|handle
name|void
modifier|*
name|QSessionManager
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
end_if
begin_function
DECL|function|allowsInteraction
name|bool
name|QSessionManager
operator|::
name|allowsInteraction
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|allowsErrorInteraction
name|bool
name|QSessionManager
operator|::
name|allowsErrorInteraction
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QSessionManager
operator|::
name|release
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|cancel
name|void
name|QSessionManager
operator|::
name|cancel
parameter_list|()
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setRestartHint
name|void
name|QSessionManager
operator|::
name|setRestartHint
parameter_list|(
name|QSessionManager
operator|::
name|RestartHint
name|hint
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSessionManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|restartHint
operator|=
name|hint
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restartHint
name|QSessionManager
operator|::
name|RestartHint
name|QSessionManager
operator|::
name|restartHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSessionManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|restartHint
return|;
block|}
end_function
begin_function
DECL|function|setRestartCommand
name|void
name|QSessionManager
operator|::
name|setRestartCommand
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|command
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSessionManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|restartCommand
operator|=
name|command
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restartCommand
name|QStringList
name|QSessionManager
operator|::
name|restartCommand
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSessionManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|restartCommand
return|;
block|}
end_function
begin_function
DECL|function|setDiscardCommand
name|void
name|QSessionManager
operator|::
name|setDiscardCommand
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|command
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSessionManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|discardCommand
operator|=
name|command
expr_stmt|;
block|}
end_function
begin_function
DECL|function|discardCommand
name|QStringList
name|QSessionManager
operator|::
name|discardCommand
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSessionManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|discardCommand
return|;
block|}
end_function
begin_function
DECL|function|setManagerProperty
name|void
name|QSessionManager
operator|::
name|setManagerProperty
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|setManagerProperty
name|void
name|QSessionManager
operator|::
name|setManagerProperty
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
specifier|const
name|QStringList
modifier|&
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|isPhase2
name|bool
name|QSessionManager
operator|::
name|isPhase2
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|requestPhase2
name|void
name|QSessionManager
operator|::
name|requestPhase2
parameter_list|()
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SESSIONMANAGER
end_comment
begin_comment
comment|/*!     \typedef QApplication::ColorMode     \compat      Use ColorSpec instead. */
end_comment
begin_comment
comment|/*!     \fn Qt::MacintoshVersion QApplication::macVersion()      Use QSysInfo::MacintoshVersion instead. */
end_comment
begin_comment
comment|/*!     \fn QApplication::ColorMode QApplication::colorMode()      Use colorSpec() instead, and use ColorSpec as the enum type. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setColorMode(ColorMode mode)      Use setColorSpec() instead, and pass a ColorSpec value instead. */
end_comment
begin_comment
comment|/*!     \fn bool QApplication::hasGlobalMouseTracking()      This feature does not exist anymore. This function always returns true     in Qt 4. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setGlobalMouseTracking(bool dummy)      This function does nothing in Qt 4. The \a dummy parameter is ignored. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::flushX()      Use flush() instead. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setWinStyleHighlightColor(const QColor&c)      Use the palette instead.      \oldcode     app.setWinStyleHighlightColor(color);     \newcode     QPalette palette(QApplication::palette());     palette.setColor(QPalette::Highlight, color);     QApplication::setPalette(palette);     \endcode */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setPalette(const QPalette&pal, bool b, const char* className = 0)      Use the two-argument overload instead. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setFont(const QFont&font, bool b, const char* className = 0)      Use the two-argument overload instead. */
end_comment
begin_comment
comment|/*!     \fn const QColor&QApplication::winStyleHighlightColor()      Use QApplication::palette().color(QPalette::Active, QPalette::Highlight) instead. */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(int x, int y, bool child)      Use the two-argument widgetAt() overload to get the child widget. To get     the top-level widget do this:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 12 */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(const QPoint&point, bool child)      Use the single-argument widgetAt() overload to get the child widget. To get     the top-level widget do this:      \snippet doc/src/snippets/code/src_gui_kernel_qapplication.cpp 13 */
end_comment
begin_function
DECL|function|inPopupMode
name|bool
name|QApplicationPrivate
operator|::
name|inPopupMode
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::quitOnLastWindowClosed      \brief whether the application implicitly quits when the last window is     closed.      The default is true.      If this property is true, the applications quits when the last visible     primary window (i.e. window with no parent) with the Qt::WA_QuitOnClose     attribute set is closed. By default this attribute is set for all widgets     except for sub-windows. Refer to \l{Qt::WindowType} for a detailed list of     Qt::Window objects.      \sa quit(), QWidget::close()  */
end_comment
begin_function
DECL|function|setQuitOnLastWindowClosed
name|void
name|QApplication
operator|::
name|setQuitOnLastWindowClosed
parameter_list|(
name|bool
name|quit
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|quitOnLastWindowClosed
operator|=
name|quit
expr_stmt|;
block|}
end_function
begin_function
DECL|function|quitOnLastWindowClosed
name|bool
name|QApplication
operator|::
name|quitOnLastWindowClosed
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|quitOnLastWindowClosed
return|;
block|}
end_function
begin_function
DECL|function|emitLastWindowClosed
name|void
name|QApplicationPrivate
operator|::
name|emitLastWindowClosed
parameter_list|()
block|{
if|if
condition|(
name|qApp
operator|&&
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|quitOnLastWindowClosed
condition|)
block|{
comment|// get ready to quit, this event might be removed if the
comment|// event loop is re-entered, however
name|QApplication
operator|::
name|postEvent
argument_list|(
name|qApp
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|Quit
argument_list|)
argument_list|)
expr_stmt|;
block|}
emit|emit
name|qApp
operator|->
name|lastWindowClosed
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*! \variable QApplication::NormalColors     \compat      Use \l NormalColor instead. */
end_comment
begin_comment
comment|/*! \variable QApplication::CustomColors     \compat      Use \l CustomColor instead. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_comment
comment|/*!     Sets the kind of focus navigation Qt should use to \a mode.      This feature is available in Qt for Embedded Linux, Symbian and Windows CE     only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \note On Symbian, setting the mode to Qt::NavigationModeCursorAuto will enable a           virtual mouse cursor on non touchscreen devices, which is controlled           by the cursor keys if there is no analog pointer device.           On other platforms and on touchscreen devices, it has the same           meaning as Qt::NavigationModeNone.      \since 4.6      \sa keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|setNavigationMode
name|void
name|QApplication
operator|::
name|setNavigationMode
parameter_list|(
name|Qt
operator|::
name|NavigationMode
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|QApplicationPrivate
operator|::
name|setNavigationMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|QApplicationPrivate
operator|::
name|navigationMode
operator|=
name|mode
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns what kind of focus navigation Qt is using.      This feature is available in Qt for Embedded Linux, Symbian and Windows CE     only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \note On Symbian, the default mode is Qt::NavigationModeNone for touch           devices, and Qt::NavigationModeKeypadDirectional.      \since 4.6      \sa keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|navigationMode
name|Qt
operator|::
name|NavigationMode
name|QApplication
operator|::
name|navigationMode
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|navigationMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether Qt should use focus navigation suitable for use with a     minimal keypad.      This feature is available in Qt for Embedded Linux, Symbian and Windows CE     only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \deprecated      \sa setNavigationMode() */
end_comment
begin_function
DECL|function|setKeypadNavigationEnabled
name|void
name|QApplication
operator|::
name|setKeypadNavigationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|QApplication
operator|::
name|setNavigationMode
argument_list|(
name|Qt
operator|::
name|NavigationModeKeypadDirectional
argument_list|)
expr_stmt|;
else|#
directive|else
name|QApplication
operator|::
name|setNavigationMode
argument_list|(
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|QApplication
operator|::
name|setNavigationMode
argument_list|(
name|Qt
operator|::
name|NavigationModeNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if Qt is set to use keypad navigation; otherwise returns     false.  The default value is true on Symbian, but false on other platforms.      This feature is available in Qt for Embedded Linux, Symbian and Windows CE     only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \deprecated      \sa navigationMode() */
end_comment
begin_function
DECL|function|keypadNavigationEnabled
name|bool
name|QApplication
operator|::
name|keypadNavigationEnabled
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeKeypadDirectional
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QApplication::alert(QWidget *widget, int msec)     \since 4.3      Causes an alert to be shown for \a widget if the window is not the active     window. The alert is shown for \a msec miliseconds. If \a msec is zero (the     default), then the alert is shown indefinitely until the window becomes     active again.      Currently this function does nothing on Qt for Embedded Linux.      On Mac OS X, this works more at the application level and will cause the     application icon to bounce in the dock.      On Windows, this causes the window's taskbar entry to flash for a time. If     \a msec is zero, the flashing will stop and the taskbar entry will turn a     different color (currently orange).      On X11, this will cause the window to be marked as "demands attention", the     window must not be hidden (i.e. not have hide() called on it, but be     visible in some sort of way) in order for this to work. */
end_comment
begin_comment
comment|/*!     \property QApplication::cursorFlashTime     \brief the text cursor's flash (blink) time in milliseconds      The flash time is the time required to display, invert and restore the     caret display. Usually the text cursor is displayed for half the cursor     flash time, then hidden for the same amount of time, but this may vary.      The default value on X11 is 1000 milliseconds. On Windows, the     \gui{Control Panel} value is used and setting this property sets the cursor     flash time for all applications.      We recommend that widgets do not cache this value as it may change at any     time if the user changes the global desktop settings. */
end_comment
begin_function
DECL|function|setCursorFlashTime
name|void
name|QApplication
operator|::
name|setCursorFlashTime
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cursorFlashTime
name|int
name|QApplication
operator|::
name|cursorFlashTime
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|cursorFlashTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::doubleClickInterval     \brief the time limit in milliseconds that distinguishes a double click     from two consecutive mouse clicks      The default value on X11 is 400 milliseconds. On Windows and Mac OS, the     operating system's value is used.      Setting the interval is not supported anymore in Qt 5. */
end_comment
begin_function
DECL|function|setDoubleClickInterval
name|void
name|QApplication
operator|::
name|setDoubleClickInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|doubleClickInterval
name|int
name|QApplication
operator|::
name|doubleClickInterval
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|mouseDoubleClickInterval
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::keyboardInputInterval     \brief the time limit in milliseconds that distinguishes a key press     from two consecutive key presses     \since 4.2      The default value on X11 is 400 milliseconds. On Windows and Mac OS, the     operating system's value is used. */
end_comment
begin_function
DECL|function|setKeyboardInputInterval
name|void
name|QApplication
operator|::
name|setKeyboardInputInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|keyboardInputInterval
name|int
name|QApplication
operator|::
name|keyboardInputInterval
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|keyboardInputInterval
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::wheelScrollLines     \brief the number of lines to scroll a widget, when the     mouse wheel is rotated.      If the value exceeds the widget's number of visible lines, the widget     should interpret the scroll operation as a single \e{page up} or     \e{page down}. If the widget is an \l{QAbstractItemView}{item view class},     then the result of scrolling one \e line depends on the setting of the     widget's \l{QAbstractItemView::verticalScrollMode()}{scroll mode}. Scroll     one \e line can mean \l{QAbstractItemView::ScrollPerItem}{scroll one item}     or \l{QAbstractItemView::ScrollPerPixel}{scroll one pixel}.      By default, this property has a value of 3. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)      Enables the UI effect \a effect if \a enable is true, otherwise the effect     will not be used.      \note All effects are disabled on screens running at less than 16-bit color     depth.      \sa isEffectEnabled(), Qt::UIEffect, setDesktopSettingsAware() */
end_comment
begin_comment
comment|/*!     \fn bool QApplication::isEffectEnabled(Qt::UIEffect effect)      Returns true if \a effect is enabled; otherwise returns false.      By default, Qt will try to use the desktop settings. To prevent this, call     setDesktopSettingsAware(false).      \note All effects are disabled on screens running at less than 16-bit color     depth.      \sa setEffectEnabled(), Qt::UIEffect */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::mainWidget()      Returns the main application widget, or 0 if there is no main widget. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setMainWidget(QWidget *mainWidget)      Sets the application's main widget to \a mainWidget.      In most respects the main widget is like any other widget, except that if     it is closed, the application exits. QApplication does \e not take     ownership of the \a mainWidget, so if you create your main widget on the     heap you must delete it yourself.      You need not have a main widget; connecting lastWindowClosed() to quit()     is an alternative.      On X11, this function also resizes and moves the main widget according     to the \e -geometry command-line option, so you should set the default     geometry (using \l QWidget::setGeometry()) before calling setMainWidget().      \sa mainWidget(), exec(), quit() */
end_comment
begin_comment
comment|/*!     \fn void QApplication::beep()      Sounds the bell, using the default volume and sound. The function is \e not     available in Qt for Embedded Linux. */
end_comment
begin_comment
comment|/*!     \macro qApp     \relates QApplication      A global pointer referring to the unique application object. It is     equivalent to the pointer returned by the QCoreApplication::instance()     function except that, in GUI applications, it is a pointer to a     QApplication instance.      Only one application object can be created.      \sa QCoreApplication::instance() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IM
end_ifndef
begin_comment
comment|// ************************************************************************
end_comment
begin_comment
comment|// Input Method support
end_comment
begin_comment
comment|// ************************************************************************
end_comment
begin_comment
comment|/*!     This function replaces the QInputContext instance used by the application     with \a inputContext.      Qt takes ownership of the given \a inputContext.      \sa inputContext() */
end_comment
begin_function
DECL|function|setInputContext
name|void
name|QApplication
operator|::
name|setInputContext
parameter_list|(
name|QInputContext
modifier|*
name|inputContext
parameter_list|)
block|{
if|if
condition|(
name|inputContext
operator|==
name|QApplicationPrivate
operator|::
name|inputContext
condition|)
return|return;
if|if
condition|(
operator|!
name|inputContext
condition|)
block|{
name|qWarning
argument_list|(
literal|"QApplication::setInputContext: called with 0 input context"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|delete
name|QApplicationPrivate
operator|::
name|inputContext
expr_stmt|;
name|QApplicationPrivate
operator|::
name|inputContext
operator|=
name|inputContext
expr_stmt|;
name|QApplicationPrivate
operator|::
name|inputContext
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the QInputContext instance used by the application.      \sa setInputContext() */
end_comment
begin_function
DECL|function|inputContext
name|QInputContext
modifier|*
name|QApplication
operator|::
name|inputContext
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|inputContext
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IM
end_comment
begin_function
DECL|function|qt_sendSpontaneousEvent
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QApplicationBase
operator|::
name|sendSpontaneousEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|giveFocusAccordingToFocusPolicy
name|void
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|FocusPolicy
name|focusPolicy
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|)
block|{
name|QWidget
modifier|*
name|focusWidget
init|=
name|widget
decl_stmt|;
while|while
condition|(
name|focusWidget
condition|)
block|{
if|if
condition|(
name|focusWidget
operator|->
name|isEnabled
argument_list|()
operator|&&
name|QApplicationPrivate
operator|::
name|shouldSetFocus
argument_list|(
name|focusWidget
argument_list|,
name|focusPolicy
argument_list|)
condition|)
block|{
name|focusWidget
operator|->
name|setFocus
argument_list|(
name|focusReason
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|focusWidget
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|focusWidget
operator|=
name|focusWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|shouldSetFocus
name|bool
name|QApplicationPrivate
operator|::
name|shouldSetFocus
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|,
name|Qt
operator|::
name|FocusPolicy
name|policy
parameter_list|)
block|{
name|QWidget
modifier|*
name|f
init|=
name|w
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|f
operator|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|focusPolicy
argument_list|()
operator|&
name|policy
operator|)
operator|!=
name|policy
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|w
operator|!=
name|f
operator|&&
operator|(
name|f
operator|->
name|focusPolicy
argument_list|()
operator|&
name|policy
operator|)
operator|!=
name|policy
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \fn QDecoration&QApplication::qwsDecoration()     Return the QWSDecoration used for decorating windows.      \warning This method is non-portable. It is only available in     Qt for Embedded Linux.      \sa QDecoration */
end_comment
begin_comment
comment|/*!     \fn void QApplication::qwsSetDecoration(QDecoration *decoration)      Sets the QDecoration derived class to use for decorating the     windows used by Qt for Embedded Linux to the \a decoration     specified.      This method is non-portable. It is only available in Qt for Embedded Linux.      \sa QDecoration */
end_comment
begin_comment
comment|/*! \fn QDecoration* QApplication::qwsSetDecoration(const QString&decoration)     \overload      Requests a QDecoration object for \a decoration from the     QDecorationFactory.      The string must be one of the QDecorationFactory::keys(). Keys are case     insensitive.      A later call to the QApplication constructor will override the requested     style when a "-style" option is passed in as a commandline parameter.      Returns 0 if an unknown \a decoration is passed, otherwise the QStyle object     returned is set as the application's GUI style. */
end_comment
begin_comment
comment|/*!     \fn bool QApplication::qwsEventFilter(QWSEvent *event)      This virtual function is only implemented under Qt for Embedded Linux.      If you create an application that inherits QApplication and     reimplement this function, you get direct access to all QWS (Q     Window System) events that the are received from the QWS master     process. The events are passed in the \a event parameter.      Return true if you want to stop the event from being processed.     Return false for normal event dispatching. The default     implementation returns false. */
end_comment
begin_comment
comment|/*! \fn void QApplication::qwsSetCustomColors(QRgb *colorTable, int start, int numColors)     Set Qt for Embedded Linux custom color table.      Qt for Embedded Linux on 8-bpp displays allocates a standard 216 color cube.     The remaining 40 colors may be used by setting a custom color     table in the QWS master process before any clients connect.      \a colorTable is an array of up to 40 custom colors. \a start is     the starting index (0-39) and \a numColors is the number of colors     to be set (1-40).      This method is non-portable. It is available \e only in     Qt for Embedded Linux.      \note The custom colors will not be used by the default screen     driver. To make use of the new colors, implement a custom screen     driver, or use QDirectPainter. */
end_comment
begin_comment
comment|/*! \fn int QApplication::qwsProcessEvent(QWSEvent* event)     \internal */
end_comment
begin_comment
comment|/*! \fn int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)     \internal */
end_comment
begin_comment
comment|/*! \fn int QApplication::x11ProcessEvent(XEvent* event)     This function does the core processing of individual X     \a{event}s, normally by dispatching Qt events to the right     destination.      It returns 1 if the event was consumed by special handling, 0 if     the \a event was consumed by normal handling, and -1 if the \a     event was for an unrecognized widget.      \sa x11EventFilter() */
end_comment
begin_comment
comment|/*!     \fn bool QApplication::x11EventFilter(XEvent *event)      \warning This virtual function is only implemented under X11.      If you create an application that inherits QApplication and     reimplement this function, you get direct access to all X events     that the are received from the X server. The events are passed in     the \a event parameter.      Return true if you want to stop the event from being processed.     Return false for normal event dispatching. The default     implementation returns false.      It is only the directly addressed messages that are filtered.     You must install an event filter directly on the event     dispatcher, which is returned by     QAbstractEventDispatcher::instance(), to handle system wide     messages.      \sa x11ProcessEvent() */
end_comment
begin_comment
comment|/*! \fn void QApplication::winFocus(QWidget *widget, bool gotFocus)     \internal     \since 4.1      If \a gotFocus is true, \a widget will become the active window.     Otherwise the active window is reset to 0. */
end_comment
begin_comment
comment|/*! \fn void QApplication::winMouseButtonUp()   \internal  */
end_comment
begin_comment
comment|/*! \fn void QApplication::syncX()   Synchronizes with the X server in the X11 implementation.   This normally takes some time. Does nothing on other platforms. */
end_comment
begin_function
DECL|function|updateTouchPointsForWidget
name|void
name|QApplicationPrivate
operator|::
name|updateTouchPointsForWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QTouchEvent
modifier|*
name|touchEvent
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|->
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
comment|// preserve the sub-pixel resolution
name|QRectF
name|rect
init|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|screenPos
init|=
name|rect
operator|.
name|center
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|delta
init|=
name|screenPos
operator|-
name|screenPos
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|screenPos
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointPressed
condition|)
block|{
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|initializeMultitouch
name|void
name|QApplicationPrivate
operator|::
name|initializeMultitouch
parameter_list|()
block|{
name|widgetForTouchPointId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|appCurrentTouchPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
name|initializeMultitouch_sys
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanupMultitouch
name|void
name|QApplicationPrivate
operator|::
name|cleanupMultitouch
parameter_list|()
block|{
name|cleanupMultitouch_sys
argument_list|()
expr_stmt|;
name|widgetForTouchPointId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|appCurrentTouchPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findClosestTouchPointId
name|int
name|QApplicationPrivate
operator|::
name|findClosestTouchPointId
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|screenPos
parameter_list|)
block|{
name|int
name|closestTouchPointId
init|=
operator|-
literal|1
decl_stmt|;
name|qreal
name|closestDistance
init|=
name|qreal
argument_list|(
literal|0.
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
decl|,
name|appCurrentTouchPoints
control|)
block|{
name|qreal
name|distance
init|=
name|QLineF
argument_list|(
name|screenPos
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|closestTouchPointId
operator|==
operator|-
literal|1
operator|||
name|distance
operator|<
name|closestDistance
condition|)
block|{
name|closestTouchPointId
operator|=
name|touchPoint
operator|.
name|id
argument_list|()
expr_stmt|;
name|closestDistance
operator|=
name|distance
expr_stmt|;
block|}
block|}
return|return
name|closestTouchPointId
return|;
block|}
end_function
begin_function
DECL|function|translateRawTouchEvent
name|void
name|QApplicationPrivate
operator|::
name|translateRawTouchEvent
parameter_list|(
name|QWidget
modifier|*
name|window
parameter_list|,
name|QTouchEvent
operator|::
name|DeviceType
name|deviceType
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
modifier|&
name|touchPoints
parameter_list|)
block|{
name|QApplicationPrivate
modifier|*
name|d
init|=
name|self
decl_stmt|;
typedef|typedef
name|QPair
argument_list|<
name|Qt
operator|::
name|TouchPointStates
argument_list|,
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
argument_list|>
name|StatesAndTouchPoints
typedef|;
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
name|widgetsNeedingEvents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|touchPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// explicitly detach from the original touch point that we got, so even
comment|// if the touchpoint structs are reused, we will make a copy that we'll
comment|// deliver to the user (which might want to store the struct for later use).
name|touchPoint
operator|.
name|d
operator|=
name|touchPoint
operator|.
name|d
operator|->
name|detach
argument_list|()
expr_stmt|;
comment|// update state
name|QWeakPointer
argument_list|<
name|QWidget
argument_list|>
name|widget
decl_stmt|;
switch|switch
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
block|{
if|if
condition|(
name|deviceType
operator|==
name|QTouchEvent
operator|::
name|TouchPad
condition|)
block|{
comment|// on touch-pads, send all touch points to the same widget
name|widget
operator|=
name|d
operator|->
name|widgetForTouchPointId
operator|.
name|isEmpty
argument_list|()
condition|?
name|QWeakPointer
argument_list|<
name|QWidget
argument_list|>
argument_list|()
else|:
name|d
operator|->
name|widgetForTouchPointId
operator|.
name|constBegin
argument_list|()
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|widget
condition|)
block|{
comment|// determine which widget this event will go to
if|if
condition|(
operator|!
name|window
condition|)
name|window
operator|=
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
continue|continue;
name|widget
operator|=
name|window
operator|->
name|childAt
argument_list|(
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
name|widget
operator|=
name|window
expr_stmt|;
block|}
if|if
condition|(
name|deviceType
operator|==
name|QTouchEvent
operator|::
name|TouchScreen
condition|)
block|{
name|int
name|closestTouchPointId
init|=
name|d
operator|->
name|findClosestTouchPointId
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|closestWidget
init|=
name|d
operator|->
name|widgetForTouchPointId
operator|.
name|value
argument_list|(
name|closestTouchPointId
argument_list|)
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|closestWidget
operator|&&
operator|(
name|widget
operator|.
name|data
argument_list|()
operator|->
name|isAncestorOf
argument_list|(
name|closestWidget
argument_list|)
operator|||
name|closestWidget
operator|->
name|isAncestorOf
argument_list|(
name|widget
operator|.
name|data
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|widget
operator|=
name|closestWidget
expr_stmt|;
block|}
block|}
name|d
operator|->
name|widgetForTouchPointId
index|[
name|touchPoint
operator|.
name|id
argument_list|()
index|]
operator|=
name|widget
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|touchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|touchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
name|d
operator|->
name|appCurrentTouchPoints
operator|.
name|insert
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|,
name|touchPoint
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
block|{
name|widget
operator|=
name|d
operator|->
name|widgetForTouchPointId
operator|.
name|take
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
continue|continue;
name|QTouchEvent
operator|::
name|TouchPoint
name|previousTouchPoint
init|=
name|d
operator|->
name|appCurrentTouchPoints
operator|.
name|take
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|0.
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|widget
operator|=
name|d
operator|->
name|widgetForTouchPointId
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|appCurrentTouchPoints
operator|.
name|contains
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTouchEvent
operator|::
name|TouchPoint
name|previousTouchPoint
init|=
name|d
operator|->
name|appCurrentTouchPoints
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScreenPos
operator|=
name|previousTouchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScreenPos
operator|=
name|previousTouchPoint
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|previousTouchPoint
operator|.
name|startPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|previousTouchPoint
operator|.
name|pos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|startNormalizedPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastNormalizedPos
operator|=
name|previousTouchPoint
operator|.
name|normalizedPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|pressure
argument_list|()
operator|<
name|qreal
argument_list|(
literal|0.
argument_list|)
condition|)
name|touchPoint
operator|.
name|d
operator|->
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.
argument_list|)
expr_stmt|;
name|d
operator|->
name|appCurrentTouchPoints
index|[
name|touchPoint
operator|.
name|id
argument_list|()
index|]
operator|=
name|touchPoint
expr_stmt|;
break|break;
block|}
name|Q_ASSERT
argument_list|(
name|widget
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// make the *scene* functions return the same as the *screen* functions
name|touchPoint
operator|.
name|d
operator|->
name|sceneRect
operator|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startScenePos
operator|=
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastScenePos
operator|=
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
expr_stmt|;
name|StatesAndTouchPoints
modifier|&
name|maskAndPoints
init|=
name|widgetsNeedingEvents
index|[
name|widget
operator|.
name|data
argument_list|()
index|]
decl_stmt|;
name|maskAndPoints
operator|.
name|first
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|isPrimary
argument_list|()
condition|)
name|maskAndPoints
operator|.
name|first
operator||=
name|Qt
operator|::
name|TouchPointPrimary
expr_stmt|;
name|maskAndPoints
operator|.
name|second
operator|.
name|append
argument_list|(
name|touchPoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|widgetsNeedingEvents
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|widgetsNeedingEvents
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|end
init|=
name|widgetsNeedingEvents
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|widget
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|QEvent
operator|::
name|Type
name|eventType
decl_stmt|;
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
operator|&
name|Qt
operator|::
name|TouchPointStateMask
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchBegin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchEnd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointStationary
case|:
comment|// don't send the event if nothing changed
continue|continue;
default|default:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchUpdate
expr_stmt|;
break|break;
block|}
name|QTouchEvent
name|touchEvent
argument_list|(
name|eventType
argument_list|,
name|deviceType
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|second
argument_list|)
decl_stmt|;
name|updateTouchPointsForWidget
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|touchEvent
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
block|{
comment|// if the TouchBegin handler recurses, we assume that means the event
comment|// has been implicitly accepted and continue to send touch events
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|)
condition|)
block|{
if|if
condition|(
name|touchEvent
operator|.
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|TouchEnd
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|qt_translateRawTouchEvent
name|Q_WIDGETS_EXPORT
name|void
name|qt_translateRawTouchEvent
parameter_list|(
name|QWidget
modifier|*
name|window
parameter_list|,
name|QTouchEvent
operator|::
name|DeviceType
name|deviceType
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
modifier|&
name|touchPoints
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|translateRawTouchEvent
argument_list|(
name|window
argument_list|,
name|deviceType
argument_list|,
name|touchPoints
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_function
DECL|function|instance
name|QGestureManager
modifier|*
name|QGestureManager
operator|::
name|instance
parameter_list|()
block|{
name|QApplicationPrivate
modifier|*
name|qAppPriv
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qAppPriv
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|qAppPriv
operator|->
name|gestureManager
condition|)
name|qAppPriv
operator|->
name|gestureManager
operator|=
operator|new
name|QGestureManager
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
return|return
name|qAppPriv
operator|->
name|gestureManager
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qapplication.cpp"
end_include
end_unit
