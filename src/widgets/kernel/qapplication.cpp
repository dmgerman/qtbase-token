begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qcursor.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|"qstylefactory.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qtranslator.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"private/qdnd_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"qmessagebox.h"
end_include
begin_include
include|#
directive|include
file|"qwidgetwindow_qpa_p.h"
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicsproxywidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qstylehints.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformtheme.h>
end_include
begin_include
include|#
directive|include
file|"private/qkeymapper_p.h"
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qgesture.h"
end_include
begin_include
include|#
directive|include
file|"private/qgesturemanager_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformfontdatabase.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_smartphone
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_mobile
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_function_decl
specifier|extern
name|bool
name|qt_wince_is_pocket_pc
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qguifunctions_wince.cpp
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qpa/qplatformwindow.h>
end_include
begin_comment
comment|//#define ALIEN_DEBUG
end_comment
begin_function
DECL|function|initResources
specifier|static
name|void
name|initResources
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qstyle_wince
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qstyle_wince
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qstyle
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qstyle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_INIT_RESOURCE_EXTERN
argument_list|(
argument|qmessagebox
argument_list|)
name|Q_INIT_RESOURCE
argument_list|(
name|qmessagebox
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_CORE_EXPORT
name|void
name|qt_call_post_routines
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
DECL|member|self
name|QApplicationPrivate
modifier|*
name|QApplicationPrivate
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|initSystemPalette
specifier|static
name|void
name|initSystemPalette
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
block|{
name|QPalette
name|defaultPlatte
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
name|defaultPlatte
operator|=
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|standardPalette
argument_list|()
expr_stmt|;
if|if
condition|(
specifier|const
name|QPalette
modifier|*
name|themePalette
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
operator|->
name|palette
argument_list|()
condition|)
block|{
name|QApplicationPrivate
operator|::
name|setSystemPalette
argument_list|(
name|themePalette
operator|->
name|resolve
argument_list|(
name|defaultPlatte
argument_list|)
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|initializeWidgetPaletteHash
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QApplicationPrivate
operator|::
name|setSystemPalette
argument_list|(
name|defaultPlatte
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|clearSystemPalette
specifier|static
name|void
name|clearSystemPalette
parameter_list|()
block|{
operator|delete
name|QApplicationPrivate
operator|::
name|sys_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|sys_pal
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_decl_stmt
DECL|member|autoMaximizeThreshold
name|int
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|autoSipEnabled
name|bool
name|QApplicationPrivate
operator|::
name|autoSipEnabled
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|member|autoSipEnabled
name|bool
name|QApplicationPrivate
operator|::
name|autoSipEnabled
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QApplicationPrivate
name|QApplicationPrivate
operator|::
name|QApplicationPrivate
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|flags
parameter_list|)
member_init_list|:
name|QApplicationPrivateBase
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|flags
argument_list|)
block|{
name|application_type
operator|=
name|QApplicationPrivate
operator|::
name|Gui
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|gestureManager
operator|=
literal|0
expr_stmt|;
name|gestureWidget
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_GESTURES
if|if
condition|(
operator|!
name|self
condition|)
name|self
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QApplicationPrivate
name|QApplicationPrivate
operator|::
name|~
name|QApplicationPrivate
parameter_list|()
block|{
if|if
condition|(
name|self
operator|==
name|this
condition|)
name|self
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QApplication     \brief The QApplication class manages the GUI application's control     flow and main settings.      \inmodule QtWidgets      QApplication specializes QGuiApplication with some functionality needed     for QWidget-based applications. It handles widget specific initialization,     finalization.      For any GUI application using Qt, there is precisely \b one QApplication     object, no matter whether the application has 0, 1, 2 or more windows at     any given time. For non-QWidget based Qt applications, use QGuiApplication instead,     as it does not depend on the \l QtWidgets library.      Some GUI applications provide a special batch mode ie. provide command line     arguments for executing tasks without manual intervention. In such non-GUI     mode, it is often sufficient to instantiate a plain QCoreApplication to     avoid unnecessarily initializing resources needed for a graphical user     interface. The following example shows how to dynamically create an     appropriate type of application instance:      \snippet code/src_gui_kernel_qapplication.cpp 0      The QApplication object is accessible through the instance() function that     returns a pointer equivalent to the global qApp pointer.      QApplication's main areas of responsibility are:         \list             \li  It initializes the application with the user's desktop settings                 such as palette(), font() and doubleClickInterval(). It keeps                 track of these properties in case the user changes the desktop                 globally, for example through some kind of control panel.              \li  It performs event handling, meaning that it receives events                 from the underlying window system and dispatches them to the                 relevant widgets. By using sendEvent() and postEvent() you can                 send your own events to widgets.              \li  It parses common command line arguments and sets its internal                 state accordingly. See the \l{QApplication::QApplication()}                 {constructor documentation} below for more details.              \li  It defines the application's look and feel, which is                 encapsulated in a QStyle object. This can be changed at runtime                 with setStyle().              \li  It specifies how the application is to allocate colors. See                 setColorSpec() for details.              \li  It provides localization of strings that are visible to the                 user via translate().              \li  It provides some magical objects like the desktop() and the                 clipboard().              \li  It knows about the application's windows. You can ask which                 widget is at a certain position using widgetAt(), get a list of                 topLevelWidgets() and closeAllWindows(), etc.              \li  It manages the application's mouse cursor handling, see                 setOverrideCursor()         \endlist      Since the QApplication object does so much initialization, it \e{must} be     created before any other objects related to the user interface are created.     QApplication also deals with common command line arguments. Hence, it is     usually a good idea to create it \e before any interpretation or     modification of \c argv is done in the application itself.      \table     \header         \li{2,1} Groups of functions          \row         \li  System settings         \li  desktopSettingsAware(),             setDesktopSettingsAware(),             cursorFlashTime(),             setCursorFlashTime(),             doubleClickInterval(),             setDoubleClickInterval(),             setKeyboardInputInterval(),             wheelScrollLines(),             setWheelScrollLines(),             palette(),             setPalette(),             font(),             setFont(),             fontMetrics().          \row         \li  Event handling         \li  exec(),             processEvents(),             exit(),             quit().             sendEvent(),             postEvent(),             sendPostedEvents(),             removePostedEvents(),             hasPendingEvents(),             notify().          \row         \li  GUI Styles         \li  style(),             setStyle().          \row         \li  Color usage         \li  colorSpec(),             setColorSpec().          \row         \li  Text handling         \li  installTranslator(),             removeTranslator()             translate().          \row         \li  Widgets         \li  allWidgets(),             topLevelWidgets(),             desktop(),             activePopupWidget(),             activeModalWidget(),             clipboard(),             focusWidget(),             activeWindow(),             widgetAt().          \row         \li  Advanced cursor handling         \li  overrideCursor(),             setOverrideCursor(),             restoreOverrideCursor().          \row         \li  Miscellaneous         \li  closeAllWindows(),             startingUp(),             closingDown(),             type().     \endtable      \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop, QSettings */
end_comment
begin_comment
comment|/*!     \enum QApplication::ColorSpec      \value NormalColor the default color allocation policy     \value CustomColor the same as NormalColor for X11; allocates colors     to a palette on demand under Windows     \value ManyColor the right choice for applications that use thousands of     colors      See setColorSpec() for full details. */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::topLevelAt(const QPoint&point)      Returns the top-level widget at the given \a point; returns 0 if     there is no such widget. */
end_comment
begin_comment
comment|/*!     \fn QWidget *QApplication::topLevelAt(int x, int y)      \overload      Returns the top-level widget at the point (\a{x}, \a{y}); returns     0 if there is no such widget. */
end_comment
begin_comment
comment|/*     The qt_init() and qt_cleanup() functions are implemented in the     qapplication_xyz.cpp file. */
end_comment
begin_function_decl
name|void
name|qt_init
parameter_list|(
name|QApplicationPrivate
modifier|*
name|priv
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|qt_cleanup
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
DECL|member|app_style
name|QStyle
modifier|*
name|QApplicationPrivate
operator|::
name|app_style
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_style
comment|// default application style
end_comment
begin_decl_stmt
DECL|member|styleOverride
name|QString
name|QApplicationPrivate
operator|::
name|styleOverride
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|styleOverride
comment|// style override
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
end_ifndef
begin_decl_stmt
DECL|member|styleSheet
name|QString
name|QApplicationPrivate
operator|::
name|styleSheet
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|styleSheet
comment|// default application stylesheet
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|leaveAfterRelease
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|QApplicationPrivate
operator|::
name|leaveAfterRelease
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_cspec
name|int
name|QApplicationPrivate
operator|::
name|app_cspec
init|=
name|QApplication
operator|::
name|NormalColor
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|sys_pal
name|QPalette
modifier|*
name|QApplicationPrivate
operator|::
name|sys_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|sys_pal
comment|// default system palette
end_comment
begin_decl_stmt
DECL|member|set_pal
name|QPalette
modifier|*
name|QApplicationPrivate
operator|::
name|set_pal
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|set_pal
comment|// default palette set by programmer
end_comment
begin_decl_stmt
DECL|member|sys_font
name|QFont
modifier|*
name|QApplicationPrivate
operator|::
name|sys_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|sys_font
comment|// default system font
end_comment
begin_decl_stmt
DECL|member|set_font
name|QFont
modifier|*
name|QApplicationPrivate
operator|::
name|set_font
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|set_font
comment|// default font set by programmer
end_comment
begin_decl_stmt
DECL|member|app_icon
name|QIcon
modifier|*
name|QApplicationPrivate
operator|::
name|app_icon
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|main_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|main_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|main_widget
comment|// main application widget
end_comment
begin_decl_stmt
DECL|member|focus_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|focus_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|focus_widget
comment|// has keyboard input focus
end_comment
begin_decl_stmt
DECL|member|hidden_focus_widget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|hidden_focus_widget
comment|// will get keyboard input focus after show()
end_comment
begin_decl_stmt
DECL|member|active_window
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|active_window
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|active_window
comment|// toplevel with keyboard focus
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_decl_stmt
DECL|member|wheel_scroll_lines
name|int
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|wheel_scroll_lines
comment|// number of lines to scroll
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_in_tab_key_event
name|bool
name|qt_in_tab_key_event
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_antialiasing_threshold
name|int
name|qt_antialiasing_threshold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|app_strut
name|QSize
name|QApplicationPrivate
operator|::
name|app_strut
init|=
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_strut
comment|// no default application strut
end_comment
begin_decl_stmt
DECL|member|enabledAnimations
name|int
name|QApplicationPrivate
operator|::
name|enabledAnimations
init|=
name|QPlatformTheme
operator|::
name|GeneralUiEffect
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|widgetCount
name|bool
name|QApplicationPrivate
operator|::
name|widgetCount
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|load_testability
name|bool
name|QApplicationPrivate
operator|::
name|load_testability
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_decl_stmt
DECL|member|navigationMode
name|Qt
operator|::
name|NavigationMode
name|QApplicationPrivate
operator|::
name|navigationMode
init|=
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|oldEditFocus
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|oldEditFocus
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|qt_tabletChokeMouse
name|bool
name|qt_tabletChokeMouse
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isAlien
specifier|inline
name|bool
name|QApplicationPrivate
operator|::
name|isAlien
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
return|return
name|widget
operator|&&
operator|!
name|widget
operator|->
name|isWindow
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qt_tab_all_widgets
name|bool
name|Q_WIDGETS_EXPORT
name|qt_tab_all_widgets
parameter_list|()
block|{
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
return|return
name|theme
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|TabAllWidgets
argument_list|)
operator|.
name|toBool
argument_list|()
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// ######## move to QApplicationPrivate
end_comment
begin_comment
comment|// Default application palettes and fonts (per widget type)
end_comment
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|PaletteHash
argument_list|,
argument|app_palettes
argument_list|)
end_macro
begin_function
DECL|function|qt_app_palettes_hash
name|PaletteHash
modifier|*
name|qt_app_palettes_hash
parameter_list|()
block|{
return|return
name|app_palettes
argument_list|()
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|FontHash
argument_list|,
argument|app_fonts
argument_list|)
end_macro
begin_function
DECL|function|qt_app_fonts_hash
name|FontHash
modifier|*
name|qt_app_fonts_hash
parameter_list|()
block|{
return|return
name|app_fonts
argument_list|()
return|;
block|}
end_function
begin_decl_stmt
DECL|member|popupWidgets
name|QWidgetList
modifier|*
name|QApplicationPrivate
operator|::
name|popupWidgets
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|popupWidgets
comment|// has keyboard input focus
end_comment
begin_decl_stmt
DECL|variable|qt_desktopWidget
name|QDesktopWidget
modifier|*
name|qt_desktopWidget
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_desktopWidget
comment|// root window widgets
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|process_cmdline
name|void
name|QApplicationPrivate
operator|::
name|process_cmdline
parameter_list|()
block|{
comment|// process platform-indep command line
if|if
condition|(
operator|!
name|qt_is_gui_used
operator|||
operator|!
name|argc
condition|)
return|return;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|// if you add anything here, modify QCoreApplication::arguments()
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|arg
operator|=
name|arg
expr_stmt|;
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|"-qdevel"
operator|||
name|arg
operator|==
literal|"-qdebug"
condition|)
block|{
comment|// obsolete argument
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|indexOf
argument_list|(
literal|"-style="
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|.
name|right
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|7
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-style"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
operator|.
name|toLower
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
literal|"-stylesheet"
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|styleSheet
operator|=
name|QLatin1String
argument_list|(
literal|"file:///"
argument_list|)
expr_stmt|;
name|styleSheet
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|.
name|indexOf
argument_list|(
literal|"-stylesheet="
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|styleSheet
operator|=
name|QLatin1String
argument_list|(
literal|"file:///"
argument_list|)
expr_stmt|;
name|styleSheet
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|.
name|right
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|12
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|qstrcmp
argument_list|(
name|arg
argument_list|,
literal|"-widgetcount"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|widgetCount
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qstrcmp
argument_list|(
name|arg
argument_list|,
literal|"-testability"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load_testability
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|app_style
condition|)
block|{
operator|delete
name|app_style
expr_stmt|;
name|app_style
operator|=
literal|0
expr_stmt|;
block|}
name|styleOverride
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Initializes the window system and constructs an application object with     \a argc command line arguments in \a argv.      \warning The data referred to by \a argc and \a argv must stay valid for     the entire lifetime of the QApplication object. In addition, \a argc must     be greater than zero and \a argv must contain at least one valid character     string.      The global \c qApp pointer refers to this application object. Only one     application object should be created.      This application object must be constructed before any \l{QPaintDevice}     {paint devices} (including widgets, pixmaps, bitmaps etc.).      \note \a argc and \a argv might be changed as Qt removes command line     arguments that it recognizes.      All Qt programs automatically support the following command line options:     \list         \li  -style= \e style, sets the application GUI style. Possible values             depend on your system configuration. If you compiled Qt with             additional styles or have additional styles as plugins these will             be available to the \c -style command line option.  You can also             set the style for all Qt applications by setting the             \c QT_STYLE_OVERRIDE environment variable.         \li  -style \e style, is the same as listed above.         \li  -stylesheet= \e stylesheet, sets the application \l styleSheet. The             value must be a path to a file that contains the Style Sheet.             \note Relative URLs in the Style Sheet file are relative to the             Style Sheet file's path.         \li  -stylesheet \e stylesheet, is the same as listed above.         \li  -widgetcount, prints debug message at the end about number of             widgets left undestroyed and maximum number of widgets existed at             the same time         \li  -reverse, sets the application's layout direction to             Qt::RightToLeft         \li  -qmljsdebugger=, activates the QML/JS debugger with a specified port.             The value must be of format port:1234[,block], where block is optional             and will make the application wait until a debugger connects to it.     \endlist      \sa arguments() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_macro
DECL|function|QApplication
name|QApplication
end_macro
begin_expr_stmt
DECL|function|QApplication
operator|::
name|QApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
else|#
directive|else
name|QApplication
operator|::
name|QApplication
operator|(
name|int
operator|&
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|int
name|_internal
operator|)
endif|#
directive|endif
operator|:
name|QGuiApplication
argument_list|(
argument|*new QApplicationPrivate(argc, argv, _internal)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
block|;
name|d
operator|->
name|construct
argument_list|()
block|; }
comment|/*!     \internal */
DECL|function|construct
name|void
name|QApplicationPrivate
operator|::
name|construct
operator|(
operator|)
block|{
name|initResources
argument_list|()
block|;
name|qt_is_gui_used
operator|=
operator|(
name|application_type
operator|!=
name|QApplicationPrivate
operator|::
name|Tty
operator|)
block|;
name|process_cmdline
argument_list|()
block|;
comment|// Must be called before initialize()
name|qt_init
argument_list|(
name|this
argument_list|,
name|application_type
argument_list|)
block|;
name|initialize
argument_list|()
block|;
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
block|;
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_gui_eval_init
argument_list|(
name|uint
argument_list|)
block|;
name|qt_gui_eval_init
argument_list|(
name|application_type
argument_list|)
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
name|load_testability
condition|)
block|{
name|QLibrary
name|testLib
argument_list|(
name|QLatin1String
argument_list|(
literal|"qttestability"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|testLib
operator|.
name|load
argument_list|()
condition|)
block|{
typedef|typedef
name|void
function_decl|(
modifier|*
name|TasInitialize
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|TasInitialize
name|initFunction
init|=
operator|(
name|TasInitialize
operator|)
name|testLib
operator|.
name|resolve
argument_list|(
literal|"qt_testability_init"
argument_list|)
decl_stmt|;
if|if
condition|(
name|initFunction
condition|)
block|{
name|initFunction
argument_list|()
expr_stmt|;
block|}
end_expr_stmt
begin_else
else|else
block|{
name|qCritical
argument_list|(
literal|"Library qttestability resolve failed!"
argument_list|)
expr_stmt|;
block|}
end_else
begin_block
unit|} else
block|{
name|qCritical
argument_list|(
literal|"Library qttestability load failed!"
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
end_ifndef
begin_function_decl
name|void
name|qRegisterGuiStateMachine
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|void
name|qUnregisterGuiStateMachine
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn void QApplicationPrivate::initialize()    Initializes the QApplication object, called from the constructors. */
end_comment
begin_function
DECL|function|initialize
name|void
name|QApplicationPrivate
operator|::
name|initialize
parameter_list|()
block|{
name|QWidgetPrivate
operator|::
name|mapper
operator|=
operator|new
name|QWidgetMapper
expr_stmt|;
name|QWidgetPrivate
operator|::
name|allWidgets
operator|=
operator|new
name|QWidgetSet
expr_stmt|;
if|if
condition|(
name|application_type
operator|!=
name|QApplicationPrivate
operator|::
name|Tty
condition|)
operator|(
name|void
operator|)
name|QApplication
operator|::
name|style
argument_list|()
expr_stmt|;
comment|// trigger creation of application style
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
comment|// trigger registering of QStateMachine's GUI types
name|qRegisterGuiStateMachine
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|is_app_running
operator|=
literal|true
expr_stmt|;
comment|// no longer starting up
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|qgetenv
argument_list|(
literal|"QT_USE_NATIVE_WINDOWS"
argument_list|)
operator|.
name|toInt
argument_list|()
operator|>
literal|0
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_NativeWindows
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WINCE
ifdef|#
directive|ifdef
name|QT_AUTO_MAXIMIZE_THRESHOLD
name|autoMaximizeThreshold
operator|=
name|QT_AUTO_MAXIMIZE_THRESHOLD
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|qt_wince_is_mobile
argument_list|()
condition|)
name|autoMaximizeThreshold
operator|=
literal|50
expr_stmt|;
else|else
name|autoMaximizeThreshold
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|//QT_AUTO_MAXIMIZE_THRESHOLD
endif|#
directive|endif
comment|//Q_OS_WINCE
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qt_is_gui_used
condition|)
name|initializeMultitouch
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|desktopSettingsAware
argument_list|()
condition|)
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
name|QApplicationPrivate
operator|::
name|enabledAnimations
operator|=
name|theme
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|UiEffects
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Functions returning the active popup and modal widgets.  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Returns the active popup widget.      A popup widget is a special top-level widget that sets the \c     Qt::WType_Popup widget flag, e.g. the QMenu widget. When the application     opens a popup widget, all events are sent to the popup. Normal widgets and     modal widgets cannot be accessed before the popup widget is closed.      Only other popup widgets may be opened when a popup widget is shown. The     popup widgets are organized in a stack. This function returns the active     popup widget at the top of the stack.      \sa activeModalWidget(), topLevelWidgets() */
end_comment
begin_function
DECL|function|activePopupWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|activePopupWidget
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|isEmpty
argument_list|()
condition|?
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|last
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the active modal widget.      A modal widget is a special top-level widget which is a subclass of QDialog     that specifies the modal parameter of the constructor as true. A modal     widget must be closed before the user can continue with other parts of the     program.      Modal widgets are organized in a stack. This function returns the active     modal widget at the top of the stack.      \sa activePopupWidget(), topLevelWidgets() */
end_comment
begin_function
DECL|function|activeModalWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|activeModalWidget
parameter_list|()
block|{
name|QWidgetWindow
modifier|*
name|widgetWindow
init|=
name|qobject_cast
argument_list|<
name|QWidgetWindow
operator|*
argument_list|>
argument_list|(
name|modalWindow
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|widgetWindow
condition|?
name|widgetWindow
operator|->
name|widget
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Cleans up any window system resources that were allocated by this     application. Sets the global variable \c qApp to 0. */
end_comment
begin_destructor
DECL|function|~QApplication
name|QApplication
operator|::
name|~
name|QApplication
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
comment|//### this should probable be done even later
name|qt_call_post_routines
argument_list|()
expr_stmt|;
comment|// kill timers before closing down the dispatcher
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|QApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
operator|delete
name|QWidgetPrivate
operator|::
name|mapper
expr_stmt|;
name|QWidgetPrivate
operator|::
name|mapper
operator|=
literal|0
expr_stmt|;
comment|// delete all widgets
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
block|{
name|QWidgetSet
modifier|*
name|mySet
init|=
name|QWidgetPrivate
operator|::
name|allWidgets
decl_stmt|;
name|QWidgetPrivate
operator|::
name|allWidgets
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|QWidgetSet
operator|::
name|ConstIterator
name|it
init|=
name|mySet
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|mySet
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|parent
argument_list|()
condition|)
comment|// window
name|w
operator|->
name|destroy
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
operator|delete
name|mySet
expr_stmt|;
block|}
operator|delete
name|qt_desktopWidget
expr_stmt|;
name|qt_desktopWidget
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
literal|0
expr_stmt|;
name|clearSystemPalette
argument_list|()
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|set_pal
expr_stmt|;
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
literal|0
expr_stmt|;
name|app_palettes
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|sys_font
expr_stmt|;
name|QApplicationPrivate
operator|::
name|sys_font
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|set_font
expr_stmt|;
name|QApplicationPrivate
operator|::
name|set_font
operator|=
literal|0
expr_stmt|;
name|app_fonts
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_style
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|=
literal|0
expr_stmt|;
operator|delete
name|QApplicationPrivate
operator|::
name|app_icon
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|qt_is_gui_used
condition|)
operator|delete
name|QDragManager
operator|::
name|self
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|cleanupMultitouch
argument_list|()
expr_stmt|;
name|qt_cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|widgetCount
condition|)
name|qDebug
argument_list|(
literal|"Widgets left: %i    Max widgets: %i \n"
argument_list|,
name|QWidgetPrivate
operator|::
name|instanceCounter
argument_list|,
name|QWidgetPrivate
operator|::
name|maxInstances
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|obey_desktop_settings
operator|=
literal|true
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_strut
operator|=
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|enabledAnimations
operator|=
name|QPlatformTheme
operator|::
name|GeneralUiEffect
expr_stmt|;
name|QApplicationPrivate
operator|::
name|widgetCount
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STATEMACHINE
comment|// trigger unregistering of QStateMachine's GUI types
name|qUnregisterGuiStateMachine
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(const QPoint&point)      Returns the widget at global screen position \a point, or 0 if there is no     Qt widget there.      This function can be slow.      \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard() */
end_comment
begin_function
DECL|function|widgetAt
name|QWidget
modifier|*
name|QApplication
operator|::
name|widgetAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return
literal|0
return|;
name|QWidget
modifier|*
name|child
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TransparentForMouseEvents
argument_list|)
condition|)
name|child
operator|=
name|window
operator|->
name|childAt
argument_list|(
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
return|return
name|child
return|;
if|if
condition|(
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TransparentForMouseEvents
argument_list|)
condition|)
block|{
comment|//shoot a hole in the widget and try once again,
comment|//suboptimal on Qt for Embedded Linux where we do
comment|//know the stacking order of the toplevels.
name|int
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|QRegion
name|oldmask
init|=
name|window
operator|->
name|mask
argument_list|()
decl_stmt|;
name|QPoint
name|wpoint
init|=
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|QRegion
name|newmask
init|=
operator|(
name|oldmask
operator|.
name|isEmpty
argument_list|()
condition|?
name|QRegion
argument_list|(
name|window
operator|->
name|rect
argument_list|()
argument_list|)
else|:
name|oldmask
operator|)
operator|-
name|QRegion
argument_list|(
name|wpoint
operator|.
name|x
argument_list|()
argument_list|,
name|wpoint
operator|.
name|y
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|window
operator|->
name|setMask
argument_list|(
name|newmask
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|recurse
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|p
argument_list|)
operator|!=
name|window
condition|)
comment|// verify recursion will terminate
name|recurse
operator|=
name|widgetAt
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmask
operator|.
name|isEmpty
argument_list|()
condition|)
name|window
operator|->
name|clearMask
argument_list|()
expr_stmt|;
else|else
name|window
operator|->
name|setMask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
return|return
name|recurse
return|;
block|}
return|return
name|window
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QWidget *QApplication::widgetAt(int x, int y)      \overload      Returns the widget at global screen position (\a x, \a y), or 0 if there is     no Qt widget there. */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateRequest
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LayoutRequest
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Resize
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Move
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|InputMethod
operator|)
condition|)
block|{
for|for
control|(
name|QPostEventList
operator|::
name|const_iterator
name|it
init|=
name|postedEvents
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|postedEvents
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|cur
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|receiver
operator|!=
name|receiver
operator|||
name|cur
operator|.
name|event
operator|==
literal|0
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|!=
name|event
operator|->
name|type
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LayoutRequest
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|UpdateRequest
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Resize
condition|)
block|{
operator|(
operator|(
name|QResizeEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|)
operator|->
name|s
operator|=
operator|(
operator|(
name|QResizeEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Move
condition|)
block|{
operator|(
operator|(
name|QMoveEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|)
operator|->
name|p
operator|=
operator|(
operator|(
name|QMoveEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|InputMethod
condition|)
block|{
operator|*
operator|(
name|QInputMethodEvent
operator|*
operator|)
operator|(
name|cur
operator|.
name|event
operator|)
operator|=
operator|*
operator|(
name|QInputMethodEvent
operator|*
operator|)
name|event
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
return|return
name|QGuiApplication
operator|::
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
name|postedEvents
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::styleSheet     \brief the application style sheet     \since 4.2      By default, this property returns an empty string unless the user specifies     the \c{-stylesheet} option on the command line when running the application.      \sa QWidget::setStyle(), {Qt Style Sheets} */
end_comment
begin_comment
comment|/*!     \property QApplication::autoMaximizeThreshold     \since 4.4     \brief defines a threshold for auto maximizing widgets      \b{The auto maximize threshold is only available as part of Qt for     Windows CE.}      This property defines a threshold for the size of a window as a percentage     of the screen size. If the minimum size hint of a window exceeds the     threshold, calling show() will cause the window to be maximized     automatically.      Setting the threshold to 100 or greater means that the widget will always     be maximized. Alternatively, setting the threshold to 50 means that the     widget will be maximized only if the vertical minimum size hint is at least     50% of the vertical screen size.      Setting the threshold to -1 disables the feature.      On Windows CE the default is -1 (i.e., it is disabled).     On Windows Mobile the default is 40. */
end_comment
begin_comment
comment|/*!     \property QApplication::autoSipEnabled     \since 4.5     \brief toggles automatic SIP (software input panel) visibility      Set this property to \c true to automatically display the SIP when entering     widgets that accept keyboard input. This property only affects widgets with     the WA_InputMethodEnabled attribute set, and is typically used to launch     a virtual keyboard on devices which have very few or no keys.      \b{ The property only has an effect on platforms which use software input     panels, such as Windows CE.}      The default is platform dependent. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_function
DECL|function|setAutoMaximizeThreshold
name|void
name|QApplication
operator|::
name|setAutoMaximizeThreshold
parameter_list|(
specifier|const
name|int
name|threshold
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
operator|=
name|threshold
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoMaximizeThreshold
name|int
name|QApplication
operator|::
name|autoMaximizeThreshold
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|autoMaximizeThreshold
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setAutoSipEnabled
name|void
name|QApplication
operator|::
name|setAutoSipEnabled
parameter_list|(
specifier|const
name|bool
name|enabled
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|autoSipEnabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoSipEnabled
name|bool
name|QApplication
operator|::
name|autoSipEnabled
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|autoSipEnabled
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
end_ifndef
begin_function
DECL|function|styleSheet
name|QString
name|QApplication
operator|::
name|styleSheet
parameter_list|()
specifier|const
block|{
return|return
name|QApplicationPrivate
operator|::
name|styleSheet
return|;
block|}
end_function
begin_function
DECL|function|setStyleSheet
name|void
name|QApplication
operator|::
name|setStyleSheet
parameter_list|(
specifier|const
name|QString
modifier|&
name|styleSheet
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|styleSheet
operator|=
name|styleSheet
expr_stmt|;
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
argument_list|)
decl_stmt|;
if|if
condition|(
name|styleSheet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// application style sheet removed
if|if
condition|(
operator|!
name|proxy
condition|)
return|return;
comment|// there was no stylesheet before
name|setStyle
argument_list|(
name|proxy
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proxy
condition|)
block|{
comment|// style sheet update, just repolish
name|proxy
operator|->
name|repolish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// stylesheet set the first time
name|QStyleSheetStyle
modifier|*
name|newProxy
init|=
operator|new
name|QStyleSheetStyle
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
name|setStyle
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_STYLE_STYLESHEET
end_comment
begin_comment
comment|/*!     Returns the application's style object.      \sa setStyle(), QStyle */
end_comment
begin_function
DECL|function|style
name|QStyle
modifier|*
name|QApplication
operator|::
name|style
parameter_list|()
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
return|return
name|QApplicationPrivate
operator|::
name|app_style
return|;
if|if
condition|(
operator|!
name|qobject_cast
argument_list|<
name|QApplication
operator|*
argument_list|>
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
literal|"No style available without QApplication!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_style
condition|)
block|{
comment|// Compile-time search for default style
comment|//
name|QString
name|style
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
name|QString
name|envStyle
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_STYLE_OVERRIDE"
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|QString
name|envStyle
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleOverride
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|style
operator|=
name|QApplicationPrivate
operator|::
name|styleOverride
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|envStyle
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|style
operator|=
name|envStyle
expr_stmt|;
block|}
else|else
block|{
name|style
operator|=
name|QApplicationPrivate
operator|::
name|desktopStyleKey
argument_list|()
expr_stmt|;
block|}
name|QStyle
modifier|*
modifier|&
name|app_style
init|=
name|QApplicationPrivate
operator|::
name|app_style
decl_stmt|;
name|app_style
operator|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|app_style
condition|)
block|{
name|QStringList
name|styles
init|=
name|QStyleFactory
operator|::
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|styles
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|app_style
operator|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|styles
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|app_style
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
literal|"No styles available!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|// take ownership of the style
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
name|initSystemPalette
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
comment|// repolish set palette with the new style
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleSheet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|setStyleSheet
argument_list|(
name|QApplicationPrivate
operator|::
name|styleSheet
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
return|return
name|QApplicationPrivate
operator|::
name|app_style
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the application's GUI style to \a style. Ownership of the style object     is transferred to QApplication, so QApplication will delete the style     object on application exit or when a new style is set and the old style is     still the parent of the application object.      Example usage:     \snippet code/src_gui_kernel_qapplication.cpp 1      When switching application styles, the color palette is set back to the     initial colors or the system defaults. This is necessary since certain     styles have to adapt the color palette to be fully style-guide compliant.      Setting the style before a palette has been set, i.e., before creating     QApplication, will cause the application to use QStyle::standardPalette()     for the palette.      \warning Qt style sheets are currently not supported for custom QStyle     subclasses. We plan to address this in some future release.      \sa style(), QStyle, setPalette(), desktopSettingsAware() */
end_comment
begin_function
DECL|function|setStyle
name|void
name|QApplication
operator|::
name|setStyle
parameter_list|(
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
if|if
condition|(
operator|!
name|style
operator|||
name|style
operator|==
name|QApplicationPrivate
operator|::
name|app_style
condition|)
return|return;
name|QWidgetList
name|all
init|=
name|allWidgets
argument_list|()
decl_stmt|;
comment|// clean up the old style
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|&&
comment|// except desktop
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
block|{
comment|// has been polished
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|unpolish
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|unpolish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
block|}
name|QStyle
modifier|*
name|old
init|=
name|QApplicationPrivate
operator|::
name|app_style
decl_stmt|;
comment|// save
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|styleSheet
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|style
argument_list|)
condition|)
block|{
comment|// we have a stylesheet already and a new style is being set
name|QStyleSheetStyle
modifier|*
name|newProxy
init|=
operator|new
name|QStyleSheetStyle
argument_list|(
name|style
argument_list|)
decl_stmt|;
name|style
operator|->
name|setParent
argument_list|(
name|newProxy
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|=
name|newProxy
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|// QT_NO_STYLE_STYLESHEET
name|QApplicationPrivate
operator|::
name|app_style
operator|=
name|style
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|setParent
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
comment|// take ownership
comment|// take care of possible palette requirements of certain gui
comment|// styles. Do it before polishing the application since the style
comment|// might call QApplication::setPalette() itself
if|if
condition|(
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
block|{
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
block|{
name|QApplicationPrivate
operator|::
name|initializeWidgetPaletteHash
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|setPalette_helper
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_pal
argument_list|,
comment|/*className=*/
literal|0
argument_list|,
comment|/*clearWidgetPaletteHash=*/
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
condition|)
block|{
comment|// Initialize the sys_pal if it hasn't happened yet...
name|QApplicationPrivate
operator|::
name|setSystemPalette
argument_list|(
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|standardPalette
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// initialize the application with the new style
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
comment|// re-polish existing widgets if necessary
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it1
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it1
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it1
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it1
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|style
argument_list|()
operator|==
name|QApplicationPrivate
operator|::
name|app_style
condition|)
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// repolish
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
else|else
name|w
operator|->
name|setStyleSheet
argument_list|(
name|w
operator|->
name|styleSheet
argument_list|()
argument_list|)
expr_stmt|;
comment|// touch
endif|#
directive|endif
block|}
block|}
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it2
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it2
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it2
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it2
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|w
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|oldProxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|oldProxy
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|old
operator|&&
name|old
operator|->
name|parent
argument_list|()
operator|==
name|qApp
condition|)
block|{
operator|delete
name|old
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|focus_widget
condition|)
block|{
name|QFocusEvent
name|in
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplicationPrivate
operator|::
name|focus_widget
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|focus_widget
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Requests a QStyle object for \a style from the QStyleFactory.      The string must be one of the QStyleFactory::keys(), typically one of     "windows", "fusion", "windowsxp", or "macintosh". Style     names are case insensitive.      Returns 0 if an unknown \a style is passed, otherwise the QStyle object     returned is set as the application's GUI style.      \warning To ensure that the application's style is set correctly, it is     best to call this function before the QApplication constructor, if     possible. */
end_comment
begin_function
DECL|function|setStyle
name|QStyle
modifier|*
name|QApplication
operator|::
name|setStyle
parameter_list|(
specifier|const
name|QString
modifier|&
name|style
parameter_list|)
block|{
name|QStyle
modifier|*
name|s
init|=
name|QStyleFactory
operator|::
name|create
argument_list|(
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
name|setStyle
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the color specification.      \sa QApplication::setColorSpec() */
end_comment
begin_function
DECL|function|colorSpec
name|int
name|QApplication
operator|::
name|colorSpec
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_cspec
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the color specification for the application to \a spec.      The color specification controls how the application allocates colors when     run on a display with a limited amount of colors, e.g. 8 bit / 256 color     displays.      The color specification must be set before you create the QApplication     object.      The options are:     \list         \li  QApplication::NormalColor. This is the default color allocation             strategy. Use this option if your application uses buttons, menus,             texts and pixmaps with few colors. With this option, the             application uses system global colors. This works fine for most             applications under X11, but on the Windows platform, it may cause             dithering of non-standard colors.         \li  QApplication::CustomColor. Use this option if your application             needs a small number of custom colors. On X11, this option is the             same as NormalColor. On Windows, Qt creates a Windows palette, and             allocates colors to it on demand.         \li  QApplication::ManyColor. Use this option if your application is             very color hungry, e.g., it requires thousands of colors. \br             Under X11 the effect is:             \list                 \li  For 256-color displays which have at best a 256 color true                     color visual, the default visual is used, and colors are                     allocated from a color cube. The color cube is the 6x6x6                     (216 color) "Web palette" (the red, green, and blue                     components always have one of the following values: 0x00,                     0x33, 0x66, 0x99, 0xCC, or 0xFF), but the number of colors                     can be changed by the \e -ncols option. The user can force                     the application to use the true color visual with the                     \l{QApplication::QApplication()}{-visual} option.                 \li  For 256-color displays which have a true color visual with                     more than 256 colors, use that visual. Silicon Graphics X                     servers this feature, for example. They provide an 8 bit                     visual by default but can deliver true color when asked.             \endlist             On Windows, Qt creates a Windows palette, and fills it with a color             cube.     \endlist      Be aware that the CustomColor and ManyColor choices may lead to colormap     flashing: The foreground application gets (most) of the available colors,     while the background windows will look less attractive.      Example:      \snippet code/src_gui_kernel_qapplication.cpp 2      \sa colorSpec() */
end_comment
begin_function
DECL|function|setColorSpec
name|void
name|QApplication
operator|::
name|setColorSpec
parameter_list|(
name|int
name|spec
parameter_list|)
block|{
if|if
condition|(
name|qApp
condition|)
name|qWarning
argument_list|(
literal|"QApplication::setColorSpec: This function must be "
literal|"called before the QApplication object is created"
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_cspec
operator|=
name|spec
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::globalStrut     \brief the minimum size that any GUI element that the user can interact            with should have      For example, no button should be resized to be smaller than the global     strut size. The strut size should be considered when reimplementing GUI     controls that may be used on touch-screens or similar I/O devices.      Example:      \snippet code/src_gui_kernel_qapplication.cpp 3      By default, this property contains a QSize object with zero width and height. */
end_comment
begin_function
DECL|function|globalStrut
name|QSize
name|QApplication
operator|::
name|globalStrut
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_strut
return|;
block|}
end_function
begin_function
DECL|function|setGlobalStrut
name|void
name|QApplication
operator|::
name|setGlobalStrut
parameter_list|(
specifier|const
name|QSize
modifier|&
name|strut
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|app_strut
operator|=
name|strut
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPalette QApplication::palette(const QWidget* widget)     \overload      If a \a widget is passed, the default palette for the widget's class is     returned. This may or may not be the application palette. In most cases     there is no special palette for certain types of widgets, but one notable     exception is the popup menu under Windows, if the user has defined a     special background color for menus in the display settings.      \sa setPalette(), QWidget::palette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QApplication
operator|::
name|palette
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QPalette
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
for|for
control|(
name|it
operator|=
name|hash
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|w
operator|->
name|inherits
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
block|}
return|return
name|palette
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the palette for widgets of the given \a className.      \sa setPalette(), QWidget::palette() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QApplication
operator|::
name|palette
parameter_list|(
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_pal
condition|)
name|palette
argument_list|()
expr_stmt|;
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QPalette
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
return|;
block|}
end_function
begin_function
DECL|function|setPalette_helper
name|void
name|QApplicationPrivate
operator|::
name|setPalette_helper
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|,
name|bool
name|clearWidgetPaletteHash
parameter_list|)
block|{
name|QPalette
name|pal
init|=
name|palette
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_style
condition|)
name|QApplicationPrivate
operator|::
name|app_style
operator|->
name|polish
argument_list|(
name|pal
argument_list|)
expr_stmt|;
comment|// NB: non-const reference
name|bool
name|all
init|=
literal|false
decl_stmt|;
name|PaletteHash
modifier|*
name|hash
init|=
name|app_palettes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|className
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|app_pal
operator|&&
name|pal
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_pal
condition|)
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|app_pal
operator|=
name|pal
expr_stmt|;
if|if
condition|(
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|all
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|clearWidgetPaletteHash
condition|)
name|hash
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hash
condition|)
block|{
name|hash
operator|->
name|insert
argument_list|(
name|className
argument_list|,
name|pal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
comment|// Send ApplicationPaletteChange to qApp itself, and to the widgets.
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationPaletteChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|QWidgetList
name|wids
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|wids
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|wids
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|all
operator|||
operator|(
operator|!
name|className
operator|&&
name|w
operator|->
name|isWindow
argument_list|()
operator|)
operator|||
name|w
operator|->
name|inherits
argument_list|(
name|className
argument_list|)
condition|)
comment|// matching class
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Send to all scenes as well.
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QList
argument_list|<
name|QGraphicsScene
modifier|*
argument_list|>
modifier|&
name|scenes
init|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|scenes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|scenes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|*
name|it
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
if|if
condition|(
operator|!
name|className
operator|&&
operator|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_pal
operator|||
operator|!
name|palette
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_pal
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|set_pal
operator|=
name|palette
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Changes the default application palette to \a palette.      If \a className is passed, the change applies only to widgets that inherit     \a className (as reported by QObject::inherits()). If \a className is left     0, the change affects all widgets, thus overriding any previously set class     specific palettes.      The palette may be changed according to the current GUI style in     QStyle::polish().      \warning Do not use this function in conjunction with \l{Qt Style Sheets}.     When using style sheets, the palette of a widget can be customized using     the "color", "background-color", "selection-color",     "selection-background-color" and "alternate-background-color".      \note Some styles do not use the palette for all drawing, for instance, if     they make use of native theme engines. This is the case for the Windows XP,     Windows Vista, and Mac OS X styles.      \sa QWidget::setPalette(), palette(), QStyle::polish() */
end_comment
begin_function
DECL|function|setPalette
name|void
name|QApplication
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|setPalette_helper
argument_list|(
name|palette
argument_list|,
name|className
argument_list|,
comment|/*clearWidgetPaletteHash=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSystemPalette
name|void
name|QApplicationPrivate
operator|::
name|setSystemPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|)
block|{
name|QPalette
name|adjusted
decl_stmt|;
if|#
directive|if
literal|0
comment|// adjust the system palette to avoid dithering
block|QColormap cmap = QColormap::instance();     if (cmap.depths()> 4&& cmap.depths()< 24) {         for (int g = 0; g< QPalette::NColorGroups; g++)             for (int i = 0; i< QPalette::NColorRoles; i++) {                 QColor color = pal.color((QPalette::ColorGroup)g, (QPalette::ColorRole)i);                 color = cmap.colorAt(cmap.pixel(color));                 adjusted.setColor((QPalette::ColorGroup)g, (QPalette::ColorRole) i, color);             }     }
else|#
directive|else
name|adjusted
operator|=
name|pal
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sys_pal
condition|)
name|sys_pal
operator|=
operator|new
name|QPalette
argument_list|(
name|adjusted
argument_list|)
expr_stmt|;
else|else
operator|*
name|sys_pal
operator|=
name|adjusted
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_pal
condition|)
name|QApplication
operator|::
name|setPalette
argument_list|(
operator|*
name|sys_pal
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default application font.      \sa fontMetrics(), QWidget::font() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|()
block|{
return|return
name|QGuiApplication
operator|::
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the default font for the \a widget.      \sa fontMetrics(), QWidget::setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_MAC
comment|// short circuit for small and mini controls
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|)
condition|)
block|{
return|return
name|hash
operator|->
name|value
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"QSmallFont"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|)
condition|)
block|{
return|return
name|hash
operator|->
name|value
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"QMiniFont"
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QFont
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|widget
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
for|for
control|(
name|it
operator|=
name|hash
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|widget
operator|->
name|inherits
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
block|}
return|return
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the font for widgets of the given \a className.      \sa setFont(), QWidget::font() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QApplication
operator|::
name|font
parameter_list|(
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
if|if
condition|(
name|className
operator|&&
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QFont
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|hash
operator|->
name|constFind
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|hash
operator|->
name|constEnd
argument_list|()
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the default application font to \a font. If \a className is passed,     the change applies only to classes that inherit \a className (as reported     by QObject::inherits()).      On application start-up, the default font depends on the window system. It     can vary depending on both the window system version and the locale. This     function lets you override the default font; but overriding may be a bad     idea because, for example, some locales need extra large fonts to support     their special characters.      \warning Do not use this function in conjunction with \l{Qt Style Sheets}.     The font of an application can be customized using the "font" style sheet     property. To set a bold font for all QPushButtons, set the application     styleSheet() as "QPushButton { font: bold }"      \sa font(), fontMetrics(), QWidget::setFont() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QApplication
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|char
modifier|*
name|className
parameter_list|)
block|{
name|bool
name|all
init|=
literal|false
decl_stmt|;
name|FontHash
modifier|*
name|hash
init|=
name|app_fonts
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|className
condition|)
block|{
name|QGuiApplication
operator|::
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|&&
name|hash
operator|->
name|size
argument_list|()
condition|)
block|{
name|all
operator|=
literal|true
expr_stmt|;
name|hash
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hash
condition|)
block|{
name|hash
operator|->
name|insert
argument_list|(
name|className
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
comment|// Send ApplicationFontChange to qApp itself, and to the widgets.
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationFontChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|QWidgetList
name|wids
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|wids
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|wids
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|all
operator|||
operator|(
operator|!
name|className
operator|&&
name|w
operator|->
name|isWindow
argument_list|()
operator|)
operator|||
name|w
operator|->
name|inherits
argument_list|(
name|className
argument_list|)
condition|)
comment|// matching class
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// Send to all scenes as well.
name|QList
argument_list|<
name|QGraphicsScene
modifier|*
argument_list|>
modifier|&
name|scenes
init|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|scenes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|scenes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|*
name|it
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
if|if
condition|(
operator|!
name|className
operator|&&
operator|(
operator|!
name|QApplicationPrivate
operator|::
name|sys_font
operator|||
operator|!
name|font
operator|.
name|isCopyOf
argument_list|(
operator|*
name|QApplicationPrivate
operator|::
name|sys_font
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_font
condition|)
name|QApplicationPrivate
operator|::
name|set_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|QApplicationPrivate
operator|::
name|set_font
operator|=
name|font
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|setSystemFont
name|void
name|QApplicationPrivate
operator|::
name|setSystemFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sys_font
condition|)
name|sys_font
operator|=
operator|new
name|QFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
else|else
operator|*
name|sys_font
operator|=
name|font
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|set_font
condition|)
name|QApplication
operator|::
name|setFont
argument_list|(
operator|*
name|sys_font
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|desktopStyleKey
name|QString
name|QApplicationPrivate
operator|::
name|desktopStyleKey
parameter_list|()
block|{
comment|// The platform theme might return a style that is not available, find
comment|// first valid one.
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
block|{
specifier|const
name|QStringList
name|availableKeys
init|=
name|QStyleFactory
operator|::
name|keys
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|style
decl|,
name|theme
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|StyleNames
argument_list|)
operator|.
name|toStringList
argument_list|()
control|)
if|if
condition|(
name|availableKeys
operator|.
name|contains
argument_list|(
name|style
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
return|return
name|style
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::windowIcon     \brief the default window icon      \sa QWidget::setWindowIcon(), {Setting the Application Icon} */
end_comment
begin_function
DECL|function|windowIcon
name|QIcon
name|QApplication
operator|::
name|windowIcon
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|app_icon
condition|?
operator|*
name|QApplicationPrivate
operator|::
name|app_icon
else|:
name|QIcon
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setWindowIcon
name|void
name|QApplication
operator|::
name|setWindowIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|app_icon
condition|)
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
operator|new
name|QIcon
argument_list|()
expr_stmt|;
operator|*
name|QApplicationPrivate
operator|::
name|app_icon
operator|=
name|icon
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_running
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ApplicationWindowIconChange
argument_list|)
decl_stmt|;
name|QWidgetList
name|all
init|=
name|QApplication
operator|::
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|register
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of the top-level widgets (windows) in the application.      \note Some of the top-level widgets may be hidden, for example a tooltip if     no tooltip is currently shown.      Example:      \snippet code/src_gui_kernel_qapplication.cpp 4      \sa allWidgets(), QWidget::isWindow(), QWidget::isHidden() */
end_comment
begin_function
DECL|function|topLevelWidgets
name|QWidgetList
name|QApplication
operator|::
name|topLevelWidgets
parameter_list|()
block|{
name|QWidgetList
name|list
decl_stmt|;
name|QWidgetList
name|all
init|=
name|allWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|QWidgetList
operator|::
name|ConstIterator
name|it
init|=
name|all
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|all
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
name|list
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the widgets in the application.      The list is empty (QList::isEmpty()) if there are no widgets.      \note Some of the widgets may be hidden.      Example:     \snippet code/src_gui_kernel_qapplication.cpp 5      \sa topLevelWidgets(), QWidget::isVisible() */
end_comment
begin_function
DECL|function|allWidgets
name|QWidgetList
name|QApplication
operator|::
name|allWidgets
parameter_list|()
block|{
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
return|return
name|QWidgetPrivate
operator|::
name|allWidgets
operator|->
name|toList
argument_list|()
return|;
return|return
name|QWidgetList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the application widget that has the keyboard input focus, or 0 if     no widget in this application has the focus.      \sa QWidget::setFocus(), QWidget::hasFocus(), activeWindow(), focusChanged() */
end_comment
begin_function
DECL|function|focusWidget
name|QWidget
modifier|*
name|QApplication
operator|::
name|focusWidget
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|focus_widget
return|;
block|}
end_function
begin_function
DECL|function|setFocusWidget
name|void
name|QApplicationPrivate
operator|::
name|setFocusWidget
parameter_list|(
name|QWidget
modifier|*
name|focus
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|reason
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|focus
operator|&&
name|focus
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|hidden_focus_widget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|focus
operator|!=
name|focus_widget
condition|)
block|{
if|if
condition|(
name|focus
operator|&&
name|focus
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|hidden_focus_widget
operator|=
name|focus
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|focus
operator|&&
operator|(
name|reason
operator|==
name|Qt
operator|::
name|BacktabFocusReason
operator|||
name|reason
operator|==
name|Qt
operator|::
name|TabFocusReason
operator|)
operator|&&
name|qt_in_tab_key_event
condition|)
name|focus
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|focus
operator|&&
name|reason
operator|==
name|Qt
operator|::
name|ShortcutFocusReason
condition|)
block|{
name|focus
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
block|}
name|QWidget
modifier|*
name|prev
init|=
name|focus_widget
decl_stmt|;
name|focus_widget
operator|=
name|focus
expr_stmt|;
if|if
condition|(
name|focus_widget
condition|)
name|focus_widget
operator|->
name|d_func
argument_list|()
operator|->
name|setFocus_sys
argument_list|()
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|NoFocusReason
condition|)
block|{
comment|//send events
if|if
condition|(
name|prev
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|hasEditFocus
argument_list|()
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
condition|)
name|prev
operator|->
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QFocusEvent
name|out
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|prev
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|prev
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|focus
operator|&&
name|QApplicationPrivate
operator|::
name|focus_widget
operator|==
name|focus
condition|)
block|{
name|QFocusEvent
name|in
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|focus
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|focus
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
block|}
emit|emit
name|qApp
operator|->
name|focusChanged
argument_list|(
name|prev
argument_list|,
name|focus_widget
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the application top-level window that has the keyboard input focus,     or 0 if no application window has the focus. There might be an     activeWindow() even if there is no focusWidget(), for example if no widget     in that window accepts key events.      \sa QWidget::setFocus(), QWidget::hasFocus(), focusWidget() */
end_comment
begin_function
DECL|function|activeWindow
name|QWidget
modifier|*
name|QApplication
operator|::
name|activeWindow
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|active_window
return|;
block|}
end_function
begin_comment
comment|/*!     Returns display (screen) font metrics for the application font.      \sa font(), setFont(), QWidget::fontMetrics(), QPainter::fontMetrics() */
end_comment
begin_function
DECL|function|fontMetrics
name|QFontMetrics
name|QApplication
operator|::
name|fontMetrics
parameter_list|()
block|{
return|return
name|desktop
argument_list|()
operator|->
name|fontMetrics
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Closes all top-level windows.      This function is particularly useful for applications with many top-level     windows. It could, for example, be connected to a \uicontrol{Exit} entry in the     \uicontrol{File} menu:      \snippet mainwindows/mdi/mainwindow.cpp 0      The windows are closed in random order, until one window does not accept     the close event. The application quits when the last window was     successfully closed; this can be turned off by setting     \l quitOnLastWindowClosed to false.      \sa quitOnLastWindowClosed, lastWindowClosed(), QWidget::close(),     QWidget::closeEvent(), lastWindowClosed(), quit(), topLevelWidgets(),     QWidget::isWindow() */
end_comment
begin_function
DECL|function|closeAllWindows
name|void
name|QApplication
operator|::
name|closeAllWindows
parameter_list|()
block|{
name|bool
name|did_close
init|=
literal|true
decl_stmt|;
name|QWidget
modifier|*
name|w
decl_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|activeModalWidget
argument_list|()
operator|)
operator|&&
name|did_close
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|isVisible
argument_list|()
operator|||
name|w
operator|->
name|data
operator|->
name|is_closing
condition|)
break|break;
name|did_close
operator|=
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|did_close
operator|&&
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
operator|!
name|w
operator|->
name|data
operator|->
name|is_closing
condition|)
block|{
name|did_close
operator|=
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
name|list
operator|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Displays a simple message box about Qt. The message includes the version     number of Qt being used by the application.      This is useful for inclusion in the \uicontrol Help menu of an application, as     shown in the \l{mainwindows/menus}{Menus} example.      This function is a convenience slot for QMessageBox::aboutQt(). */
end_comment
begin_function
DECL|function|aboutQt
name|void
name|QApplication
operator|::
name|aboutQt
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_MESSAGEBOX
name|QMessageBox
operator|::
name|aboutQt
argument_list|(
name|activeWindow
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_MESSAGEBOX
block|}
end_function
begin_comment
comment|/*!     \since 4.1     \fn void QApplication::focusChanged(QWidget *old, QWidget *now)      This signal is emitted when the widget that has keyboard focus changed from     \a old to \a now, i.e., because the user pressed the tab-key, clicked into     a widget or changed the active window. Both \a old and \a now can be the     null-pointer.      The signal is emitted after both widget have been notified about the change     through QFocusEvent.      \sa QWidget::setFocus(), QWidget::clearFocus(), Qt::FocusReason */
end_comment
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Close
condition|)
block|{
name|QCloseEvent
modifier|*
name|ce
init|=
cast|static_cast
argument_list|<
name|QCloseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|ce
operator|->
name|accept
argument_list|()
expr_stmt|;
name|closeAllWindows
argument_list|()
expr_stmt|;
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|&&
operator|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Dialog
operator|)
operator|||
operator|!
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
block|{
name|ce
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ce
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|Q_OS_WIN
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LocaleChange
condition|)
block|{
comment|// on Windows the event propagation is taken care by the
comment|// WM_SETTINGCHANGE event handler.
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setLocale_helper
argument_list|(
name|QLocale
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
condition|)
block|{
name|QTimerEvent
modifier|*
name|te
init|=
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|te
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|toolTipWakeUp
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|toolTipWidget
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|d
operator|->
name|toolTipWidget
operator|->
name|window
argument_list|()
decl_stmt|;
comment|// show tooltip if WA_AlwaysShowToolTips is set, or if
comment|// any ancestor of d->toolTipWidget is the active
comment|// window
name|bool
name|showToolTip
init|=
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AlwaysShowToolTips
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
operator|&&
operator|!
name|showToolTip
condition|)
block|{
name|showToolTip
operator|=
name|w
operator|->
name|isActiveWindow
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
condition|?
name|w
operator|->
name|window
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|showToolTip
condition|)
block|{
name|QHelpEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ToolTip
argument_list|,
name|d
operator|->
name|toolTipPos
argument_list|,
name|d
operator|->
name|toolTipGlobalPos
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|toolTipWidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|isAccepted
argument_list|()
condition|)
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|start
argument_list|(
literal|2000
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|te
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LanguageChange
condition|)
block|{
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
name|postEvent
argument_list|(
name|w
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|QGuiApplication
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    \fn void QApplication::syncX()     Was used to synchronize with the X server in 4.x, here for source compatibility.     \internal     \obsolete */
end_comment
begin_function
DECL|function|notifyLayoutDirectionChange
name|void
name|QApplicationPrivate
operator|::
name|notifyLayoutDirectionChange
parameter_list|()
block|{
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QApplication::setActiveWindow(QWidget* active)      Sets the active window to the \a active widget in response to a system     event. The function is called from the platform specific event handlers.      \warning This function does \e not set the keyboard focus to the active     widget. Call QWidget::activateWindow() instead.      It sets the activeWindow() and focusWidget() attributes and sends proper     \l{QEvent::WindowActivate}{WindowActivate}/\l{QEvent::WindowDeactivate}     {WindowDeactivate} and \l{QEvent::FocusIn}{FocusIn}/\l{QEvent::FocusOut}     {FocusOut} events to all appropriate widgets. The window will then be     painted in active state (e.g. cursors in line edits will blink), and it     will have tool tips enabled.      \sa activeWindow(), QWidget::activateWindow() */
end_comment
begin_function
DECL|function|setActiveWindow
name|void
name|QApplication
operator|::
name|setActiveWindow
parameter_list|(
name|QWidget
modifier|*
name|act
parameter_list|)
block|{
name|QWidget
modifier|*
name|window
init|=
name|act
condition|?
name|act
operator|->
name|window
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
operator|==
name|window
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|window
operator|&&
name|window
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
comment|// Activate the proxy's view->viewport() ?
return|return;
block|}
endif|#
directive|endif
name|QWidgetList
name|toBeActivated
decl_stmt|;
name|QWidgetList
name|toBeDeactivated
decl_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Widget_ShareActivation
argument_list|,
literal|0
argument_list|,
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
condition|)
block|{
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|toBeDeactivated
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toBeDeactivated
operator|.
name|append
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|focus_widget
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|focus_widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|QFocusEvent
name|focusAboutToChange
argument_list|(
name|QEvent
operator|::
name|FocusAboutToChange
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|QApplicationPrivate
operator|::
name|focus_widget
argument_list|,
operator|&
name|focusAboutToChange
argument_list|)
expr_stmt|;
block|}
name|QApplicationPrivate
operator|::
name|active_window
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Widget_ShareActivation
argument_list|,
literal|0
argument_list|,
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
condition|)
block|{
name|QWidgetList
name|list
init|=
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|toBeActivated
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toBeActivated
operator|.
name|append
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|)
expr_stmt|;
block|}
block|}
comment|// first the activation/deactivation events
name|QEvent
name|activationChange
argument_list|(
name|QEvent
operator|::
name|ActivationChange
argument_list|)
decl_stmt|;
name|QEvent
name|windowActivate
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|QEvent
name|windowDeactivate
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toBeActivated
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|toBeActivated
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|windowActivate
argument_list|)
expr_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|activationChange
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toBeDeactivated
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|toBeDeactivated
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|windowDeactivate
argument_list|)
expr_stmt|;
name|sendSpontaneousEvent
argument_list|(
name|w
argument_list|,
operator|&
name|activationChange
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|==
literal|0
condition|)
block|{
comment|// !inPopupMode()
comment|// then focus events
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|active_window
operator|&&
name|QApplicationPrivate
operator|::
name|focus_widget
condition|)
block|{
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|active_window
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
comment|/*&& w->focusPolicy() != QWidget::NoFocus*/
condition|)
name|w
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|=
name|QApplicationPrivate
operator|::
name|focusNextPrevChild_helper
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the focus widget is not in the activate_window, clear the focus
name|w
operator|=
name|QApplicationPrivate
operator|::
name|focus_widget
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|&&
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
name|QApplicationPrivate
operator|::
name|active_window
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|isAncestorOf
argument_list|(
name|w
argument_list|)
condition|)
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!internal  * Helper function that returns the new focus widget, but does not set the focus reason.  * Returns 0 if a new focus widget could not be found.  * Shared with QGraphicsProxyWidgetPrivate::findFocusChild() */
end_comment
begin_function
DECL|function|focusNextPrevChild_helper
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|focusNextPrevChild_helper
parameter_list|(
name|QWidget
modifier|*
name|toplevel
parameter_list|,
name|bool
name|next
parameter_list|)
block|{
name|uint
name|focus_flag
init|=
name|qt_tab_all_widgets
argument_list|()
condition|?
name|Qt
operator|::
name|TabFocus
else|:
name|Qt
operator|::
name|StrongFocus
decl_stmt|;
name|QWidget
modifier|*
name|f
init|=
name|toplevel
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|f
operator|=
name|toplevel
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|f
decl_stmt|;
name|QWidget
modifier|*
name|test
init|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
decl_stmt|;
while|while
condition|(
name|test
operator|&&
name|test
operator|!=
name|f
condition|)
block|{
if|if
condition|(
operator|(
name|test
operator|->
name|focusPolicy
argument_list|()
operator|&
name|focus_flag
operator|)
operator|==
name|focus_flag
operator|&&
operator|!
operator|(
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
operator|)
operator|&&
name|test
operator|->
name|isVisibleTo
argument_list|(
name|toplevel
argument_list|)
operator|&&
name|test
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|SubWindow
operator|&&
operator|!
name|w
operator|->
name|isAncestorOf
argument_list|(
name|test
argument_list|)
operator|)
operator|&&
operator|(
name|toplevel
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|SubWindow
operator|||
name|toplevel
operator|->
name|isAncestorOf
argument_list|(
name|test
argument_list|)
operator|)
condition|)
block|{
name|w
operator|=
name|test
expr_stmt|;
if|if
condition|(
name|next
condition|)
break|break;
block|}
name|test
operator|=
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|qt_in_tab_key_event
condition|)
block|{
name|w
operator|->
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
name|w
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|w
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QApplicationPrivate::dispatchEnterLeave(QWidget* enter, QWidget* leave, const QPointF&globalPosF)     \internal      Creates the proper Enter/Leave event when widget \a enter is entered and     widget \a leave is left.  */
end_comment
begin_function
DECL|function|dispatchEnterLeave
name|void
name|QApplicationPrivate
operator|::
name|dispatchEnterLeave
parameter_list|(
name|QWidget
modifier|*
name|enter
parameter_list|,
name|QWidget
modifier|*
name|leave
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|globalPosF
parameter_list|)
block|{
specifier|const
name|QPoint
name|globalPos
init|=
name|globalPosF
operator|.
name|toPoint
argument_list|()
decl_stmt|;
if|#
directive|if
literal|0
block|if (leave) {         QEvent e(QEvent::Leave);         QApplication::sendEvent(leave,& e);     }     if (enter) {         const QPoint windowPos = enter->window()->mapFromGlobal(globalPos);         QEnterEvent e(enter->mapFromGlobal(globalPos), windowPos, globalPos);         QApplication::sendEvent(enter,& e);     }     return;
endif|#
directive|endif
name|QWidget
modifier|*
name|w
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|enter
operator|&&
operator|!
name|leave
operator|)
operator|||
operator|(
name|enter
operator|==
name|leave
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::dispatchEnterLeave, ENTER:"
operator|<<
name|enter
operator|<<
literal|"LEAVE:"
operator|<<
name|leave
expr_stmt|;
endif|#
directive|endif
name|QWidgetList
name|leaveList
decl_stmt|;
name|QWidgetList
name|enterList
decl_stmt|;
name|bool
name|sameWindow
init|=
name|leave
operator|&&
name|enter
operator|&&
name|leave
operator|->
name|window
argument_list|()
operator|==
name|enter
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|leave
operator|&&
operator|!
name|sameWindow
condition|)
block|{
name|w
operator|=
name|leave
expr_stmt|;
do|do
block|{
name|leaveList
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|enter
operator|&&
operator|!
name|sameWindow
condition|)
block|{
name|w
operator|=
name|enter
expr_stmt|;
do|do
block|{
name|enterList
operator|.
name|prepend
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|sameWindow
condition|)
block|{
name|int
name|enterDepth
init|=
literal|0
decl_stmt|;
name|int
name|leaveDepth
init|=
literal|0
decl_stmt|;
name|w
operator|=
name|enter
expr_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
name|enterDepth
operator|++
expr_stmt|;
name|w
operator|=
name|leave
expr_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
name|leaveDepth
operator|++
expr_stmt|;
name|QWidget
modifier|*
name|wenter
init|=
name|enter
decl_stmt|;
name|QWidget
modifier|*
name|wleave
init|=
name|leave
decl_stmt|;
while|while
condition|(
name|enterDepth
operator|>
name|leaveDepth
condition|)
block|{
name|wenter
operator|=
name|wenter
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|enterDepth
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|leaveDepth
operator|>
name|enterDepth
condition|)
block|{
name|wleave
operator|=
name|wleave
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|leaveDepth
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|wenter
operator|->
name|isWindow
argument_list|()
operator|&&
name|wenter
operator|!=
name|wleave
condition|)
block|{
name|wenter
operator|=
name|wenter
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|wleave
operator|=
name|wleave
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|leave
expr_stmt|;
while|while
condition|(
name|w
operator|!=
name|wleave
condition|)
block|{
name|leaveList
operator|.
name|append
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|enter
expr_stmt|;
while|while
condition|(
name|w
operator|!=
name|wenter
condition|)
block|{
name|enterList
operator|.
name|prepend
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|QEvent
name|leaveEvent
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaveList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|leaveList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|||
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|leaveEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|instance
argument_list|()
argument_list|)
expr_stmt|;
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverLeave
argument_list|,
name|QPoint
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|hoverGlobalPos
argument_list|)
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|enterList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QPoint
name|windowPos
init|=
name|enterList
operator|.
name|front
argument_list|()
operator|->
name|window
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enterList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|enterList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|||
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
condition|)
block|{
specifier|const
name|QPointF
name|localPos
init|=
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
decl_stmt|;
name|QEnterEvent
name|enterEvent
argument_list|(
name|localPos
argument_list|,
name|windowPos
argument_list|,
name|globalPosF
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|enterEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverEnter
argument_list|,
name|localPos
argument_list|,
name|QPoint
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|// Update cursor for alien/graphics widgets.
specifier|const
name|bool
name|enterOnAlien
init|=
operator|(
name|enter
operator|&&
operator|(
name|isAlien
argument_list|(
name|enter
argument_list|)
operator|||
name|enter
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|// Whenever we leave an alien widget on X11/QPA, we need to reset its nativeParentWidget()'s cursor.
comment|// This is not required on Windows as the cursor is reset on every single mouse move.
name|QWidget
modifier|*
name|parentOfLeavingCursor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaveList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|leaveList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAlien
argument_list|(
name|w
argument_list|)
condition|)
break|break;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
condition|)
block|{
name|QWidget
modifier|*
name|parent
init|=
name|w
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|data
operator|.
name|in_destructor
condition|)
name|parent
operator|=
name|parent
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|parentOfLeavingCursor
operator|=
name|parent
expr_stmt|;
comment|//continue looping, we need to find the downest alien widget with a cursor.
comment|// (downest on the screen)
block|}
block|}
comment|//check that we will not call qt_x11_enforce_cursor twice with the same native widget
if|if
condition|(
name|parentOfLeavingCursor
operator|&&
operator|(
operator|!
name|enterOnAlien
operator|||
name|parentOfLeavingCursor
operator|->
name|effectiveWinId
argument_list|()
operator|!=
name|enter
operator|->
name|effectiveWinId
argument_list|()
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
operator|!
name|parentOfLeavingCursor
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|enter
operator|==
name|QApplication
operator|::
name|desktop
argument_list|()
condition|)
block|{
name|qt_qpa_set_cursor
argument_list|(
name|enter
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_qpa_set_cursor
argument_list|(
name|parentOfLeavingCursor
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|enterOnAlien
condition|)
block|{
name|QWidget
modifier|*
name|cursorWidget
init|=
name|enter
decl_stmt|;
while|while
condition|(
operator|!
name|cursorWidget
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|cursorWidget
operator|->
name|isEnabled
argument_list|()
condition|)
name|cursorWidget
operator|=
name|cursorWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cursorWidget
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|cursorWidget
operator|->
name|window
argument_list|()
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
name|QWidgetPrivate
operator|::
name|nearestGraphicsProxyWidget
argument_list|(
name|cursorWidget
argument_list|)
operator|->
name|setCursor
argument_list|(
name|cursorWidget
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|qt_qpa_set_cursor
argument_list|(
name|cursorWidget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* exported for the benefit of testing tools */
end_comment
begin_function
DECL|function|qt_tryModalHelper
name|Q_WIDGETS_EXPORT
name|bool
name|qt_tryModalHelper
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|rettop
parameter_list|)
block|{
return|return
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|widget
argument_list|,
name|rettop
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if \a widget is blocked by a modal window.  */
end_comment
begin_function
DECL|function|isBlockedByModal
name|bool
name|QApplicationPrivate
operator|::
name|isBlockedByModal
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|widget
operator|=
name|widget
operator|->
name|window
argument_list|()
expr_stmt|;
return|return
name|self
operator|->
name|isWindowBlocked
argument_list|(
name|widget
operator|->
name|windowHandle
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isWindowBlocked
name|bool
name|QApplicationPrivate
operator|::
name|isWindowBlocked
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QWindow
modifier|*
modifier|*
name|blockingWindow
parameter_list|)
specifier|const
block|{
name|QWindow
modifier|*
name|unused
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|blockingWindow
condition|)
name|blockingWindow
operator|=
operator|&
name|unused
expr_stmt|;
if|if
condition|(
name|modalWindowList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QWidget
modifier|*
name|popupWidget
init|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
decl_stmt|;
name|QWindow
modifier|*
name|popupWindow
init|=
name|popupWidget
condition|?
name|popupWidget
operator|->
name|windowHandle
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|popupWindow
operator|==
name|window
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modalWindowList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWindow
modifier|*
name|modalWindow
init|=
name|modalWindowList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
block|{
comment|// check if the modal window is our window or a (transient) parent of our window
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|==
name|modalWindow
condition|)
block|{
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
comment|// Embedded in-process windows are not visible in normal parent-child chain,
comment|// so check the native parent chain, too.
specifier|const
name|QPlatformWindow
modifier|*
name|platWin
init|=
name|window
operator|->
name|handle
argument_list|()
decl_stmt|;
specifier|const
name|QPlatformWindow
modifier|*
name|modalPlatWin
init|=
name|modalWindow
operator|->
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
name|platWin
operator|&&
name|modalPlatWin
operator|&&
name|platWin
operator|->
name|isEmbedded
argument_list|(
name|modalPlatWin
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|Qt
operator|::
name|WindowModality
name|windowModality
init|=
name|modalWindow
operator|->
name|modality
argument_list|()
decl_stmt|;
name|QWidgetWindow
modifier|*
name|modalWidgetWindow
init|=
name|qobject_cast
argument_list|<
name|QWidgetWindow
operator|*
argument_list|>
argument_list|(
name|modalWindow
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowModality
operator|==
name|Qt
operator|::
name|NonModal
condition|)
block|{
comment|// determine the modality type if it hasn't been set on the
comment|// modalWindow's widget, this normally happens when waiting for a
comment|// native dialog. use WindowModal if we are the child of a group
comment|// leader; otherwise use ApplicationModal.
name|QWidget
modifier|*
name|m
init|=
name|modalWidgetWindow
condition|?
name|modalWidgetWindow
operator|->
name|widget
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|m
operator|&&
operator|!
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|=
name|m
operator|->
name|window
argument_list|()
expr_stmt|;
block|}
name|windowModality
operator|=
operator|(
name|m
operator|&&
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
operator|)
condition|?
name|Qt
operator|::
name|WindowModal
else|:
name|Qt
operator|::
name|ApplicationModal
expr_stmt|;
block|}
switch|switch
condition|(
name|windowModality
condition|)
block|{
case|case
name|Qt
operator|::
name|ApplicationModal
case|:
block|{
name|QWidgetWindow
modifier|*
name|widgetWindow
init|=
name|qobject_cast
argument_list|<
name|QWidgetWindow
operator|*
argument_list|>
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|groupLeaderForWidget
init|=
name|widgetWindow
condition|?
name|widgetWindow
operator|->
name|widget
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|groupLeaderForWidget
operator|&&
operator|!
name|groupLeaderForWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
name|groupLeaderForWidget
operator|=
name|groupLeaderForWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupLeaderForWidget
condition|)
block|{
comment|// if \a widget has WA_GroupLeader, it can only be blocked by ApplicationModal children
name|QWidget
modifier|*
name|m
init|=
name|modalWidgetWindow
condition|?
name|modalWidgetWindow
operator|->
name|widget
argument_list|()
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|m
operator|&&
name|m
operator|!=
name|groupLeaderForWidget
operator|&&
operator|!
name|m
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
name|m
operator|=
name|m
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|groupLeaderForWidget
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|m
operator|->
name|windowHandle
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|modalWindow
operator|!=
name|window
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|modalWindow
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
case|case
name|Qt
operator|::
name|WindowModal
case|:
block|{
name|QWindow
modifier|*
name|w
init|=
name|window
decl_stmt|;
do|do
block|{
name|QWindow
modifier|*
name|m
init|=
name|modalWindow
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|w
condition|)
block|{
operator|*
name|blockingWindow
operator|=
name|m
expr_stmt|;
return|return
literal|true
return|;
block|}
name|QWindow
modifier|*
name|p
init|=
name|m
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|m
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|m
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
name|QWindow
modifier|*
name|p
init|=
name|w
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|w
operator|->
name|transientParent
argument_list|()
expr_stmt|;
name|w
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
break|break;
block|}
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QApplication"
argument_list|,
literal|"internal error, a modal window cannot be modeless"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|blockingWindow
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!\internal    Called from qapplication_\e{platform}.cpp, returns true   if the widget should accept the event.  */
end_comment
begin_function
DECL|function|tryModalHelper
name|bool
name|QApplicationPrivate
operator|::
name|tryModalHelper
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|rettop
parameter_list|)
block|{
name|QWidget
modifier|*
name|top
init|=
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|rettop
condition|)
operator|*
name|rettop
operator|=
name|top
expr_stmt|;
comment|// the active popup widget always gets the input event
if|if
condition|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|isBlockedByModal
argument_list|(
name|widget
operator|->
name|window
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    \internal */
end_comment
begin_function
DECL|function|pickMouseReceiver
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|pickMouseReceiver
parameter_list|(
name|QWidget
modifier|*
name|candidate
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|windowPos
parameter_list|,
name|QPoint
modifier|*
name|pos
parameter_list|,
name|QEvent
operator|::
name|Type
name|type
parameter_list|,
name|Qt
operator|::
name|MouseButtons
name|buttons
parameter_list|,
name|QWidget
modifier|*
name|buttonDown
parameter_list|,
name|QWidget
modifier|*
name|alienWidget
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|mouseGrabber
init|=
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|buttons
operator|)
operator|||
operator|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|)
operator|)
operator|&&
operator|!
name|buttonDown
operator|&&
operator|!
name|mouseGrabber
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|alienWidget
operator|&&
name|alienWidget
operator|->
name|internalWinId
argument_list|()
condition|)
name|alienWidget
operator|=
literal|0
expr_stmt|;
name|QWidget
modifier|*
name|receiver
init|=
name|candidate
decl_stmt|;
if|if
condition|(
operator|!
name|mouseGrabber
condition|)
name|mouseGrabber
operator|=
operator|(
name|buttonDown
operator|&&
operator|!
name|isBlockedByModal
argument_list|(
name|buttonDown
argument_list|)
operator|)
condition|?
name|buttonDown
else|:
name|alienWidget
expr_stmt|;
if|if
condition|(
name|mouseGrabber
operator|&&
name|mouseGrabber
operator|!=
name|candidate
condition|)
block|{
name|receiver
operator|=
name|mouseGrabber
expr_stmt|;
operator|*
name|pos
operator|=
name|receiver
operator|->
name|mapFromGlobal
argument_list|(
name|candidate
operator|->
name|mapToGlobal
argument_list|(
name|windowPos
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"  ** receiver adjusted to:"
operator|<<
name|receiver
operator|<<
literal|"pos:"
operator|<<
name|pos
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|receiver
return|;
block|}
end_function
begin_comment
comment|/*    \internal */
end_comment
begin_function
DECL|function|sendMouseEvent
name|bool
name|QApplicationPrivate
operator|::
name|sendMouseEvent
parameter_list|(
name|QWidget
modifier|*
name|receiver
parameter_list|,
name|QMouseEvent
modifier|*
name|event
parameter_list|,
name|QWidget
modifier|*
name|alienWidget
parameter_list|,
name|QWidget
modifier|*
name|nativeWidget
parameter_list|,
name|QWidget
modifier|*
modifier|*
name|buttonDown
parameter_list|,
name|QPointer
argument_list|<
name|QWidget
argument_list|>
modifier|&
name|lastMouseReceiver
parameter_list|,
name|bool
name|spontaneous
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|nativeWidget
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|buttonDown
argument_list|)
expr_stmt|;
if|if
condition|(
name|alienWidget
operator|&&
operator|!
name|isAlien
argument_list|(
name|alienWidget
argument_list|)
condition|)
name|alienWidget
operator|=
literal|0
expr_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|receiverGuard
init|=
name|receiver
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|nativeGuard
init|=
name|nativeWidget
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|alienGuard
init|=
name|alienWidget
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|activePopupWidget
init|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|graphicsWidget
init|=
name|nativeWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
decl_stmt|;
name|bool
name|widgetUnderMouse
init|=
name|QRectF
argument_list|(
name|receiver
operator|->
name|rect
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|event
operator|->
name|localPos
argument_list|()
argument_list|)
decl_stmt|;
comment|// Clear the obsolete leaveAfterRelease value, if mouse button has been released but
comment|// leaveAfterRelease has not been updated.
comment|// This happens e.g. when modal dialog or popup is shown as a response to button click.
if|if
condition|(
name|leaveAfterRelease
operator|&&
operator|!
operator|*
name|buttonDown
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
name|leaveAfterRelease
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|buttonDown
condition|)
block|{
if|if
condition|(
operator|!
name|graphicsWidget
condition|)
block|{
comment|// Register the widget that shall receive a leave event
comment|// after the last button is released.
if|if
condition|(
operator|(
name|alienWidget
operator|||
operator|!
name|receiver
operator|->
name|internalWinId
argument_list|()
operator|)
operator|&&
operator|!
name|leaveAfterRelease
operator|&&
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|leaveAfterRelease
operator|=
operator|*
name|buttonDown
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
operator|*
name|buttonDown
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lastMouseReceiver
operator|&&
name|widgetUnderMouse
condition|)
block|{
comment|// Dispatch enter/leave if we move:
comment|// 1) from an alien widget to another alien widget or
comment|//    from a native widget to an alien widget (first OR case)
comment|// 2) from an alien widget to a native widget (second OR case)
if|if
condition|(
operator|(
name|alienWidget
operator|&&
name|alienWidget
operator|!=
name|lastMouseReceiver
operator|)
operator|||
operator|(
name|isAlien
argument_list|(
name|lastMouseReceiver
argument_list|)
operator|&&
operator|!
name|alienWidget
operator|)
condition|)
block|{
if|if
condition|(
name|activePopupWidget
condition|)
block|{
if|if
condition|(
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|dispatchEnterLeave
argument_list|(
name|alienWidget
condition|?
name|alienWidget
else|:
name|nativeWidget
argument_list|,
name|lastMouseReceiver
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dispatchEnterLeave
argument_list|(
name|receiver
argument_list|,
name|lastMouseReceiver
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::sendMouseEvent: receiver:"
operator|<<
name|receiver
operator|<<
literal|"pos:"
operator|<<
name|event
operator|->
name|pos
argument_list|()
operator|<<
literal|"alien"
operator|<<
name|alienWidget
operator|<<
literal|"button down"
operator|<<
operator|*
name|buttonDown
operator|<<
literal|"last"
operator|<<
name|lastMouseReceiver
operator|<<
literal|"leave after release"
operator|<<
name|leaveAfterRelease
expr_stmt|;
endif|#
directive|endif
comment|// We need this quard in case someone opens a modal dialog / popup. If that's the case
comment|// leaveAfterRelease is set to null, but we shall not update lastMouseReceiver.
specifier|const
name|bool
name|wasLeaveAfterRelease
init|=
name|leaveAfterRelease
operator|!=
literal|0
decl_stmt|;
name|bool
name|result
decl_stmt|;
if|if
condition|(
name|spontaneous
condition|)
name|result
operator|=
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|graphicsWidget
operator|&&
name|leaveAfterRelease
operator|&&
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
operator|&&
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
operator|!=
name|leaveAfterRelease
condition|)
block|{
comment|// Dispatch enter/leave if:
comment|// 1) the mouse grabber is an alien widget
comment|// 2) the button is released on an alien widget
name|QWidget
modifier|*
name|enter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nativeGuard
condition|)
name|enter
operator|=
name|alienGuard
condition|?
name|alienWidget
else|:
name|nativeWidget
expr_stmt|;
else|else
comment|// The receiver is typically deleted on mouse release with drag'n'drop.
name|enter
operator|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|dispatchEnterLeave
argument_list|(
name|enter
argument_list|,
name|leaveAfterRelease
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|leaveAfterRelease
operator|=
literal|0
expr_stmt|;
name|lastMouseReceiver
operator|=
name|enter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wasLeaveAfterRelease
condition|)
block|{
if|if
condition|(
name|activePopupWidget
condition|)
block|{
if|if
condition|(
operator|!
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
condition|)
name|lastMouseReceiver
operator|=
name|alienGuard
condition|?
name|alienWidget
else|:
operator|(
name|nativeGuard
condition|?
name|nativeWidget
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lastMouseReceiver
operator|=
name|receiverGuard
condition|?
name|receiver
else|:
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*     This function should only be called when the widget changes visibility, i.e.     when the \a widget is shown, hidden or deleted. This function does nothing     if the widget is a top-level or native, i.e. not an alien widget. In that     case enter/leave events are genereated by the underlying windowing system. */
end_comment
begin_decl_stmt
specifier|extern
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|qt_last_mouse_receiver
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|QWidget
modifier|*
name|qt_button_down
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|sendSyntheticEnterLeave
name|void
name|QApplicationPrivate
operator|::
name|sendSyntheticEnterLeave
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
operator|!
name|widget
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
specifier|const
name|bool
name|widgetInShow
init|=
name|widget
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|widget
operator|->
name|data
operator|->
name|in_destructor
decl_stmt|;
if|if
condition|(
operator|!
name|widgetInShow
operator|&&
name|widget
operator|!=
name|qt_last_mouse_receiver
condition|)
return|return;
comment|// Widget was not under the cursor when it was hidden/deleted.
if|if
condition|(
name|widgetInShow
operator|&&
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|data
operator|->
name|in_show
condition|)
return|return;
comment|// Ingore recursive show.
name|QWidget
modifier|*
name|mouseGrabber
init|=
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
decl_stmt|;
if|if
condition|(
name|mouseGrabber
operator|&&
name|mouseGrabber
operator|!=
name|widget
condition|)
return|return;
comment|// Someone else has the grab; enter/leave should not occur.
name|QWidget
modifier|*
name|tlw
init|=
name|widget
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlw
operator|->
name|data
operator|->
name|in_destructor
operator|||
name|tlw
operator|->
name|data
operator|->
name|is_closing
condition|)
return|return;
comment|// Closing down the business.
if|if
condition|(
name|widgetInShow
operator|&&
operator|(
operator|!
name|qt_last_mouse_receiver
operator|||
name|qt_last_mouse_receiver
operator|->
name|window
argument_list|()
operator|!=
name|tlw
operator|)
condition|)
return|return;
comment|// Mouse cursor not inside the widget's top-level.
specifier|const
name|QPoint
name|globalPos
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|windowPos
init|=
name|tlw
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
decl_stmt|;
comment|// Find the current widget under the mouse. If this function was called from
comment|// the widget's destructor, we have to make sure childAt() doesn't take into
comment|// account widgets that are about to be destructed.
name|QWidget
modifier|*
name|widgetUnderCursor
init|=
name|tlw
operator|->
name|d_func
argument_list|()
operator|->
name|childAt_helper
argument_list|(
name|windowPos
argument_list|,
name|widget
operator|->
name|data
operator|->
name|in_destructor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widgetUnderCursor
condition|)
name|widgetUnderCursor
operator|=
name|tlw
expr_stmt|;
name|QPoint
name|pos
init|=
name|widgetUnderCursor
operator|->
name|mapFrom
argument_list|(
name|tlw
argument_list|,
name|windowPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|widgetInShow
operator|&&
name|widgetUnderCursor
operator|!=
name|widget
operator|&&
operator|!
name|widget
operator|->
name|isAncestorOf
argument_list|(
name|widgetUnderCursor
argument_list|)
condition|)
return|return;
comment|// Mouse cursor not inside the widget or any of its children.
if|if
condition|(
name|widget
operator|->
name|data
operator|->
name|in_destructor
operator|&&
name|qt_button_down
operator|==
name|widget
condition|)
name|qt_button_down
operator|=
literal|0
expr_stmt|;
comment|// Send enter/leave events followed by a mouse move on the entered widget.
name|QMouseEvent
name|e
argument_list|(
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|pos
argument_list|,
name|windowPos
argument_list|,
name|globalPos
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
name|sendMouseEvent
argument_list|(
name|widgetUnderCursor
argument_list|,
operator|&
name|e
argument_list|,
name|widgetUnderCursor
argument_list|,
name|tlw
argument_list|,
operator|&
name|qt_button_down
argument_list|,
name|qt_last_mouse_receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_CURSOR
block|}
end_function
begin_comment
comment|/*!     Returns the desktop widget (also called the root window).      The desktop may be composed of multiple screens, so it would be incorrect,     for example, to attempt to \e center some widget in the desktop's geometry.     QDesktopWidget has various functions for obtaining useful geometries upon     the desktop, such as QDesktopWidget::screenGeometry() and     QDesktopWidget::availableGeometry().      On X11, it is also possible to draw on the desktop. */
end_comment
begin_function
DECL|function|desktop
name|QDesktopWidget
modifier|*
name|QApplication
operator|::
name|desktop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qt_desktopWidget
operator|||
comment|// not created yet
operator|!
operator|(
name|qt_desktopWidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
comment|// reparented away
name|qt_desktopWidget
operator|=
operator|new
name|QDesktopWidget
argument_list|()
expr_stmt|;
block|}
return|return
name|qt_desktopWidget
return|;
block|}
end_function
begin_comment
comment|/*   Sets the time after which a drag should start to \a ms ms.    \sa startDragTime() */
end_comment
begin_function
DECL|function|setStartDragTime
name|void
name|QApplication
operator|::
name|setStartDragTime
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|ms
argument_list|)
block|}
end_function
begin_comment
comment|/*!     \property QApplication::startDragTime     \brief the time in milliseconds that a mouse button must be held down     before a drag and drop operation will begin      If you support drag and drop in your application, and want to start a drag     and drop operation after the user has held down a mouse button for a     certain amount of time, you should use this property's value as the delay.      Qt also uses this delay internally, e.g. in QTextEdit and QLineEdit, for     starting a drag.      The default value is 500 ms.      \sa startDragDistance(), {Drag and Drop} */
end_comment
begin_function
DECL|function|startDragTime
name|int
name|QApplication
operator|::
name|startDragTime
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|startDragTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     Sets the distance after which a drag should start to \a l pixels.      \sa startDragDistance() */
end_comment
begin_function
DECL|function|setStartDragDistance
name|void
name|QApplication
operator|::
name|setStartDragDistance
parameter_list|(
name|int
name|l
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::startDragDistance      If you support drag and drop in your application, and want to start a drag     and drop operation after the user has moved the cursor a certain distance     with a button held down, you should use this property's value as the     minimum distance required.      For example, if the mouse position of the click is stored in \c startPos     and the current position (e.g. in the mouse move event) is \c currentPos,     you can find out if a drag should be started with code like this:      \snippet code/src_gui_kernel_qapplication.cpp 7      Qt uses this value internally, e.g. in QFileDialog.      The default value is 4 pixels.      \sa startDragTime(), QPoint::manhattanLength(), {Drag and Drop} */
end_comment
begin_function
DECL|function|startDragDistance
name|int
name|QApplication
operator|::
name|startDragDistance
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|startDragDistance
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called, then returns     the value that was set to exit() (which is 0 if exit() is called via     quit()).      It is necessary to call this function to start event handling. The main     event loop receives events from the window system and dispatches these to     the application widgets.      Generally, no user interaction can take place before calling exec(). As a     special case, modal widgets like QMessageBox can be used before calling     exec(), because modal widgets call exec() to start a local event loop.      To make your application perform idle processing, i.e., executing a special     function whenever there are no pending events, use a QTimer with 0 timeout.     More advanced idle processing schemes can be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your     application's \c{main()} function. This is because, on some platforms the     QApplication::exec() call may not return. For example, on the Windows     platform, when the user logs off, the system terminates the process after Qt     closes all top-level windows. Hence, there is \e{no guarantee} that the     application will have time to exit its event loop and execute code at the     end of the \c{main()} function, after the QApplication::exec() call.      \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),         QCoreApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QApplication
operator|::
name|exec
parameter_list|()
block|{
return|return
name|QGuiApplication
operator|::
name|exec
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|shouldQuit
name|bool
name|QApplicationPrivate
operator|::
name|shouldQuit
parameter_list|()
block|{
comment|/* if there is no non-withdrawn primary window left (except         the ones without QuitOnClose), we emit the lastWindowClosed         signal */
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|parentWidget
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_QuitOnClose
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
name|QGuiApplicationPrivate
operator|::
name|shouldQuit
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|closeAllPopups
specifier|static
specifier|inline
name|void
name|closeAllPopups
parameter_list|()
block|{
comment|// Close all popups: In case some popup refuses to close,
comment|// we give up after 1024 attempts (to avoid an infinite loop).
name|int
name|maxiter
init|=
literal|1024
decl_stmt|;
name|QWidget
modifier|*
name|popup
decl_stmt|;
while|while
condition|(
operator|(
name|popup
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|)
operator|&&
name|maxiter
operator|--
condition|)
name|popup
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|notify
name|bool
name|QApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
comment|// no events are delivered after ~QCoreApplication() has started
if|if
condition|(
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
comment|// serious error
name|qWarning
argument_list|(
literal|"QApplication::notify: Unexpected null receiver"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|d
operator|->
name|checkReceiverThread
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|receiver
operator|->
name|isWindowType
argument_list|()
condition|)
name|QGuiApplicationPrivate
operator|::
name|sendQWindowEventToQPlatformWindow
argument_list|(
cast|static_cast
argument_list|<
name|QWindow
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
comment|// Capture the current mouse and keyboard states. Doing so here is
comment|// required in order to support QTestLib synthesized events. Real mouse
comment|// and keyboard state updates from the platform plugin are managed by
comment|// QGuiApplicationPrivate::process(Mouse|Wheel|Key|Touch|Tablet)Event();
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
block|{
name|QMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|me
operator|->
name|modifiers
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator||=
name|me
operator|->
name|button
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
block|{
name|QMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|me
operator|->
name|modifiers
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|&=
operator|~
name|me
operator|->
name|button
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
endif|#
directive|endif
block|{
name|QInputEvent
modifier|*
name|ie
init|=
cast|static_cast
argument_list|<
name|QInputEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QApplicationPrivate
operator|::
name|modifier_buttons
operator|=
name|ie
operator|->
name|modifiers
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
comment|// walk through parents and check for gestures
if|if
condition|(
name|d
operator|->
name|gestureManager
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Paint
case|:
case|case
name|QEvent
operator|::
name|MetaCall
case|:
case|case
name|QEvent
operator|::
name|DeferredDelete
case|:
case|case
name|QEvent
operator|::
name|DragEnter
case|:
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragResponse
case|:
case|case
name|QEvent
operator|::
name|ChildAdded
case|:
case|case
name|QEvent
operator|::
name|ChildPolished
case|:
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
case|case
name|QEvent
operator|::
name|UpdateRequest
case|:
case|case
name|QEvent
operator|::
name|UpdateLater
case|:
case|case
name|QEvent
operator|::
name|LocaleChange
case|:
case|case
name|QEvent
operator|::
name|Style
case|:
case|case
name|QEvent
operator|::
name|IconDrag
case|:
case|case
name|QEvent
operator|::
name|StyleChange
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDrop
case|:
case|case
name|QEvent
operator|::
name|DynamicPropertyChange
case|:
case|case
name|QEvent
operator|::
name|NetworkReplyUpdated
case|:
break|break;
default|default:
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|gestureManager
operator|->
name|filterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// a special case for events that go to QGesture objects.
comment|// We pass the object to the gesture manager and it'll figure
comment|// out if it's QGesture or not.
if|if
condition|(
name|d
operator|->
name|gestureManager
operator|->
name|filterEvent
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ApplicationDeactivate
case|:
comment|// Close all popups (triggers when switching applications
comment|// by pressing ALT-TAB on Windows, which is not receive as key event.
name|closeAllPopups
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Wheel
case|:
comment|// User input and window activation makes tooltips sleep
case|case
name|QEvent
operator|::
name|ActivationChange
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
case|case
name|QEvent
operator|::
name|FocusOut
case|:
case|case
name|QEvent
operator|::
name|FocusIn
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// fall-through
case|case
name|QEvent
operator|::
name|Leave
case|:
name|d
operator|->
name|toolTipWakeUp
operator|.
name|stop
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
name|bool
name|res
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
block|{
name|bool
name|isWidget
init|=
name|receiver
operator|->
name|isWidgetType
argument_list|()
decl_stmt|;
name|bool
name|isGraphicsWidget
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|isGraphicsWidget
operator|=
operator|!
name|isWidget
operator|&&
name|qobject_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isWidget
operator|&&
operator|!
name|isGraphicsWidget
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|QKeyEvent
modifier|*
name|key
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
comment|// Try looking for a Shortcut before sending key events
if|if
condition|(
operator|(
name|res
operator|=
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|tryShortcutEvent
argument_list|(
name|receiver
argument_list|,
name|key
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
endif|#
directive|endif
name|qt_in_tab_key_event
operator|=
operator|(
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Left
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Right
operator|||
name|key
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
expr_stmt|;
block|}
name|bool
name|def
init|=
name|key
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|pr
init|=
name|receiver
decl_stmt|;
while|while
condition|(
name|receiver
condition|)
block|{
if|if
condition|(
name|def
condition|)
name|key
operator|->
name|accept
argument_list|()
expr_stmt|;
else|else
name|key
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|isWidget
condition|?
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QGraphicsWidget
modifier|*
name|gw
init|=
name|isGraphicsWidget
condition|?
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|res
operator|&&
name|key
operator|->
name|isAccepted
argument_list|()
operator|)
comment|/*                        QLineEdit will emit a signal on Key_Return, but                        ignore the event, and sometimes the connected                        slot deletes the QLineEdit (common in itemview                        delegates), so we have to check if the widget                        was destroyed even if the event was ignored (to                        prevent a crash)                         note that we don't have to reset pw while                        propagating (because the original receiver will                        be destroyed if one of its ancestors is)                     */
operator|||
operator|!
name|pr
operator|||
operator|(
name|isWidget
operator|&&
operator|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
operator|!
name|w
operator|->
name|parentWidget
argument_list|()
operator|)
operator|)
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
operator|(
name|isGraphicsWidget
operator|&&
operator|(
name|gw
operator|->
name|isWindow
argument_list|()
operator|||
operator|!
name|gw
operator|->
name|parentWidget
argument_list|()
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|receiver
operator|=
name|w
condition|?
operator|(
name|QObject
operator|*
operator|)
name|w
operator|->
name|parentWidget
argument_list|()
else|:
operator|(
name|QObject
operator|*
operator|)
name|gw
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
else|#
directive|else
name|receiver
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|qt_in_tab_key_event
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QMouseEvent
modifier|*
name|mouse
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|mouse
operator|->
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
condition|)
block|{
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|w
argument_list|,
name|Qt
operator|::
name|ClickFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
comment|// ### Qt 5 These dynamic tool tips should be an OPT-IN feature. Some platforms
comment|// like Mac OS X (probably others too), can optimize their views by not
comment|// dispatching mouse move events. We have attributes to control hover,
comment|// and mouse tracking, but as long as we are deciding to implement this
comment|// feature without choice of opting-in or out, you ALWAYS have to have
comment|// tracking enabled. Therefore, the other properties give a false sense of
comment|// performance enhancement.
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|mouse
operator|->
name|buttons
argument_list|()
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|toolTipWidget
operator|=
name|w
expr_stmt|;
name|d
operator|->
name|toolTipPos
operator|=
name|relpos
expr_stmt|;
name|d
operator|->
name|toolTipGlobalPos
operator|=
name|mouse
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|d
operator|->
name|toolTipWakeUp
operator|.
name|start
argument_list|(
name|d
operator|->
name|toolTipFallAsleep
operator|.
name|isActive
argument_list|()
condition|?
literal|20
else|:
literal|700
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|eventAccepted
init|=
name|mouse
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|pw
init|=
name|w
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QMouseEvent
name|me
argument_list|(
name|mouse
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|mouse
operator|->
name|windowPos
argument_list|()
argument_list|,
name|mouse
operator|->
name|globalPos
argument_list|()
argument_list|,
name|mouse
operator|->
name|button
argument_list|()
argument_list|,
name|mouse
operator|->
name|buttons
argument_list|()
argument_list|,
name|mouse
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|me
operator|.
name|spont
operator|=
name|mouse
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|me
operator|.
name|setTimestamp
argument_list|(
name|mouse
operator|->
name|timestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// throw away any mouse-tracking-only mouse events
if|if
condition|(
operator|!
name|w
operator|->
name|hasMouseTracking
argument_list|()
operator|&&
name|mouse
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
operator|&&
name|mouse
operator|->
name|buttons
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// but still send them through all application event filters (normally done by notify_helper)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|d
operator|->
name|extraData
operator|&&
name|i
operator|<
name|d
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|d
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QApplication: Object event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
argument_list|)
condition|)
break|break;
block|}
name|res
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMouseReplay
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
argument_list|)
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
block|}
name|eventAccepted
operator|=
operator|(
name|w
operator|==
name|receiver
condition|?
name|mouse
else|:
operator|&
name|me
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|eventAccepted
condition|)
break|break;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|mouse
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseMove
condition|)
block|{
if|if
condition|(
operator|!
name|pw
condition|)
break|break;
name|w
operator|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|relpos
operator|=
name|mouse
operator|->
name|pos
argument_list|()
expr_stmt|;
name|QPoint
name|diff
init|=
name|relpos
operator|-
name|w
operator|->
name|mapFromGlobal
argument_list|(
name|d
operator|->
name|hoverGlobalPos
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
operator|->
name|window
argument_list|()
operator|)
condition|)
block|{
name|QHoverEvent
name|he
argument_list|(
name|QEvent
operator|::
name|HoverMove
argument_list|,
name|relpos
argument_list|,
name|relpos
operator|-
name|diff
argument_list|,
name|mouse
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|he
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|hoverGlobalPos
operator|=
name|mouse
operator|->
name|globalPos
argument_list|()
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QWheelEvent
modifier|*
name|wheel
init|=
cast|static_cast
argument_list|<
name|QWheelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|wheel
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|wheel
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|w
argument_list|,
name|Qt
operator|::
name|WheelFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|w
condition|)
block|{
name|QWheelEvent
name|we
argument_list|(
name|relpos
argument_list|,
name|wheel
operator|->
name|globalPos
argument_list|()
argument_list|,
name|wheel
operator|->
name|pixelDelta
argument_list|()
argument_list|,
name|wheel
operator|->
name|angleDelta
argument_list|()
argument_list|,
name|wheel
operator|->
name|delta
argument_list|()
argument_list|,
name|wheel
operator|->
name|orientation
argument_list|()
argument_list|,
name|wheel
operator|->
name|buttons
argument_list|()
argument_list|,
name|wheel
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|we
operator|.
name|spont
operator|=
name|wheel
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|wheel
else|:
operator|&
name|we
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|wheel
else|:
operator|&
name|we
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|wheel
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QContextMenuEvent
modifier|*
name|context
init|=
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|context
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|context
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QContextMenuEvent
name|ce
argument_list|(
name|context
operator|->
name|reason
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|context
operator|->
name|globalPos
argument_list|()
argument_list|,
name|context
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|ce
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|context
else|:
operator|&
name|ce
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|context
else|:
operator|&
name|ce
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|context
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QTabletEvent
modifier|*
name|tablet
init|=
cast|static_cast
argument_list|<
name|QTabletEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPointF
name|relpos
init|=
name|tablet
operator|->
name|posF
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|tablet
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QTabletEvent
name|te
argument_list|(
name|tablet
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|tablet
operator|->
name|globalPosF
argument_list|()
argument_list|,
name|tablet
operator|->
name|device
argument_list|()
argument_list|,
name|tablet
operator|->
name|pointerType
argument_list|()
argument_list|,
name|tablet
operator|->
name|pressure
argument_list|()
argument_list|,
name|tablet
operator|->
name|xTilt
argument_list|()
argument_list|,
name|tablet
operator|->
name|yTilt
argument_list|()
argument_list|,
name|tablet
operator|->
name|tangentialPressure
argument_list|()
argument_list|,
name|tablet
operator|->
name|rotation
argument_list|()
argument_list|,
name|tablet
operator|->
name|z
argument_list|()
argument_list|,
name|tablet
operator|->
name|modifiers
argument_list|()
argument_list|,
name|tablet
operator|->
name|uniqueId
argument_list|()
argument_list|)
decl_stmt|;
name|te
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|tablet
else|:
operator|&
name|te
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
operator|(
operator|(
name|w
operator|==
name|receiver
operator|)
condition|?
name|tablet
else|:
operator|&
name|te
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|tablet
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
name|qt_tabletChokeMouse
operator|=
name|tablet
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TOOLTIP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_WHATSTHIS
argument_list|)
case|case
name|QEvent
operator|::
name|ToolTip
case|:
case|case
name|QEvent
operator|::
name|WhatsThis
case|:
case|case
name|QEvent
operator|::
name|QueryWhatsThis
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QHelpEvent
modifier|*
name|help
init|=
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPoint
name|relpos
init|=
name|help
operator|->
name|pos
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|help
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|QHelpEvent
name|he
argument_list|(
name|help
operator|->
name|type
argument_list|()
argument_list|,
name|relpos
argument_list|,
name|help
operator|->
name|globalPos
argument_list|()
argument_list|)
decl_stmt|;
name|he
operator|.
name|spont
operator|=
name|e
operator|->
name|spontaneous
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|w
operator|==
name|receiver
condition|?
name|help
else|:
operator|&
name|he
argument_list|)
expr_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
name|eventAccepted
operator|=
operator|(
name|w
operator|==
name|receiver
condition|?
name|help
else|:
operator|&
name|he
operator|)
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|relpos
operator|+=
name|w
operator|->
name|pos
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|help
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_STATUSTIP
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_WHATSTHIS
argument_list|)
case|case
name|QEvent
operator|::
name|StatusTip
case|:
case|case
name|QEvent
operator|::
name|WhatsThisClicked
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|e
operator|->
name|isAccepted
argument_list|()
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|QEvent
operator|::
name|DragEnter
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QDragEnterEvent
modifier|*
name|dragEvent
init|=
cast|static_cast
argument_list|<
name|QDragEnterEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// QGraphicsProxyWidget handles its own propagation,
comment|// and we must not change QDragManagers currentTarget.
name|QWExtra
modifier|*
name|extra
init|=
name|w
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|dragEvent
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|isEnabled
argument_list|()
operator|&&
name|w
operator|->
name|acceptDrops
argument_list|()
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|dragEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|dragEvent
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|setCurrentTarget
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|dragEvent
operator|->
name|p
operator|=
name|w
operator|->
name|mapToParent
argument_list|(
name|dragEvent
operator|->
name|p
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// QGraphicsProxyWidget handles its own propagation,
comment|// and we must not change QDragManagers currentTarget.
name|QWExtra
modifier|*
name|extra
init|=
name|w
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
name|bool
name|isProxyWidget
init|=
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
decl_stmt|;
if|if
condition|(
operator|!
name|isProxyWidget
condition|)
endif|#
directive|endif
name|w
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|currentTarget
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragMove
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Drop
condition|)
block|{
name|QDropEvent
modifier|*
name|dragEvent
init|=
cast|static_cast
argument_list|<
name|QDropEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|origReciver
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|origReciver
operator|&&
name|w
operator|!=
name|origReciver
condition|)
block|{
name|dragEvent
operator|->
name|p
operator|=
name|origReciver
operator|->
name|mapToParent
argument_list|(
name|dragEvent
operator|->
name|p
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
name|origReciver
operator|=
name|origReciver
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|!=
name|QEvent
operator|::
name|DragMove
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|&&
operator|!
name|isProxyWidget
endif|#
directive|endif
condition|)
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|setCurrentTarget
argument_list|(
literal|0
argument_list|,
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Drop
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QTouchEvent
modifier|*
name|touchEvent
init|=
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|acceptTouchEvents
init|=
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
decl_stmt|;
name|touchEvent
operator|->
name|setTarget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|acceptTouchEvents
argument_list|)
expr_stmt|;
name|res
operator|=
name|acceptTouchEvents
operator|&&
name|d
operator|->
name|notify_helper
argument_list|(
name|widget
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
comment|// If the touch event wasn't accepted, synthesize a mouse event and see if the widget wants it.
if|if
condition|(
operator|!
name|touchEvent
operator|->
name|isAccepted
argument_list|()
condition|)
name|res
operator|=
name|d
operator|->
name|translateTouchToMouse
argument_list|(
name|widget
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
comment|// Note: TouchUpdate and TouchEnd events are never propagated
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QTouchEvent
modifier|*
name|touchEvent
init|=
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
operator|&&
name|e
operator|->
name|spontaneous
argument_list|()
condition|)
block|{
comment|// give the widget focus if the focus policy allows it
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
argument_list|(
name|widget
argument_list|,
name|Qt
operator|::
name|ClickFocus
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|widget
condition|)
block|{
comment|// first, try to deliver the touch event
name|bool
name|acceptTouchEvents
init|=
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
decl_stmt|;
name|touchEvent
operator|->
name|setTarget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|acceptTouchEvents
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|p
init|=
name|widget
decl_stmt|;
name|res
operator|=
name|acceptTouchEvents
operator|&&
name|d
operator|->
name|notify_helper
argument_list|(
name|widget
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
comment|// If the touch event wasn't accepted, synthesize a mouse event and see if the widget wants it.
if|if
condition|(
operator|!
name|touchEvent
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
name|res
operator|=
name|d
operator|->
name|translateTouchToMouse
argument_list|(
name|widget
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|eventAccepted
condition|)
break|break;
block|}
name|eventAccepted
operator|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// widget was deleted
name|widget
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|,
name|res
operator|&&
name|eventAccepted
argument_list|)
expr_stmt|;
block|}
name|touchEvent
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|eventAccepted
condition|)
block|{
comment|// the first widget to accept the TouchBegin gets an implicit grab.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|d
operator|->
name|activeTouchPoints
index|[
name|QGuiApplicationPrivate
operator|::
name|ActiveTouchPointsKey
argument_list|(
name|touchEvent
operator|->
name|device
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
index|]
operator|.
name|target
operator|=
name|widget
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|isNull
argument_list|()
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
operator|||
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|)
condition|)
block|{
break|break;
block|}
name|QPoint
name|offset
init|=
name|widget
operator|->
name|pos
argument_list|()
decl_stmt|;
name|widget
operator|=
name|widget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|touchEvent
operator|->
name|setTarget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|_touchPoints
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|pt
init|=
name|touchEvent
operator|->
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
name|QRectF
name|rect
init|=
name|pt
operator|.
name|rect
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|startPos
operator|=
name|pt
operator|.
name|startPos
argument_list|()
operator|+
name|offset
expr_stmt|;
name|pt
operator|.
name|d
operator|->
name|lastPos
operator|=
name|pt
operator|.
name|lastPos
argument_list|()
operator|+
name|offset
expr_stmt|;
block|}
block|}
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|RequestSoftwareInputPanel
case|:
name|inputMethod
argument_list|()
operator|->
name|show
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|CloseSoftwareInputPanel
case|:
name|inputMethod
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|NativeGesture
case|:
block|{
comment|// only propagate the first gesture event (after the GID_BEGIN)
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|&&
name|e
operator|->
name|isAccepted
argument_list|()
operator|)
operator|||
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|Gesture
case|:
case|case
name|QEvent
operator|::
name|GestureOverride
case|:
block|{
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QGestureEvent
modifier|*
name|gestureEvent
init|=
cast|static_cast
argument_list|<
name|QGestureEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|allGestures
init|=
name|gestureEvent
operator|->
name|gestures
argument_list|()
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|gestureEvent
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
name|bool
name|wasAccepted
init|=
name|eventAccepted
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
comment|// send only gestures the widget expects
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|gestures
decl_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allGestures
operator|.
name|size
argument_list|()
condition|;
control|)
block|{
name|QGesture
modifier|*
name|g
init|=
name|allGestures
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|GestureType
name|type
init|=
name|g
operator|->
name|gestureType
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|Qt
operator|::
name|GestureType
argument_list|,
name|Qt
operator|::
name|GestureFlags
argument_list|>
operator|::
name|iterator
name|contextit
init|=
name|wd
operator|->
name|gestureContext
operator|.
name|find
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|bool
name|deliver
init|=
name|contextit
operator|!=
name|wd
operator|->
name|gestureContext
operator|.
name|end
argument_list|()
operator|&&
operator|(
name|g
operator|->
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|GestureStarted
operator|||
name|w
operator|==
name|receiver
operator|||
operator|(
name|contextit
operator|.
name|value
argument_list|()
operator|&
name|Qt
operator|::
name|ReceivePartialGestures
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|deliver
condition|)
block|{
name|allGestures
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gestures
operator|.
name|append
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we have gestures for this w
name|QGestureEvent
name|ge
argument_list|(
name|gestures
argument_list|)
decl_stmt|;
name|ge
operator|.
name|t
operator|=
name|gestureEvent
operator|->
name|t
expr_stmt|;
name|ge
operator|.
name|spont
operator|=
name|gestureEvent
operator|->
name|spont
expr_stmt|;
name|ge
operator|.
name|m_accept
operator|=
name|wasAccepted
expr_stmt|;
name|ge
operator|.
name|m_accepted
operator|=
name|gestureEvent
operator|->
name|m_accepted
expr_stmt|;
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|w
argument_list|,
operator|&
name|ge
argument_list|)
expr_stmt|;
name|gestureEvent
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
name|eventAccepted
operator|=
name|ge
operator|.
name|isAccepted
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gestures
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGesture
modifier|*
name|g
init|=
name|gestures
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Ignore res [event return value] because handling of multiple gestures
comment|// packed into a single QEvent depends on not consuming the event
if|if
condition|(
name|eventAccepted
operator|||
name|ge
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|// if the gesture was accepted, mark the target widget for it
name|gestureEvent
operator|->
name|m_targetWidgets
index|[
name|g
operator|->
name|gestureType
argument_list|()
index|]
operator|=
name|w
expr_stmt|;
name|gestureEvent
operator|->
name|setAccepted
argument_list|(
name|g
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the gesture was explicitly ignored by the application,
comment|// put it back so a parent can get it
name|allGestures
operator|.
name|append
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|allGestures
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// everything delivered
break|break;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|allGestures
control|)
name|gestureEvent
operator|->
name|setAccepted
argument_list|(
name|g
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|gestureEvent
operator|->
name|m_accept
operator|=
literal|false
expr_stmt|;
comment|// to make sure we check individual gestures
block|}
else|else
block|{
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
default|default:
name|res
operator|=
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|notify_helper
name|bool
name|QApplicationPrivate
operator|::
name|notify_helper
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// send to all application event filters
if|if
condition|(
name|sendThroughApplicationEventFilters
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|GWES_ICONCURS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
operator|)
comment|// toggle HasMouse widget state on enter and leave
if|if
condition|(
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Enter
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragEnter
operator|)
operator|&&
operator|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|||
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|widget
operator|->
name|window
argument_list|()
operator|)
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UnderMouse
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Leave
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragLeave
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UnderMouse
argument_list|,
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QLayout
modifier|*
name|layout
init|=
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
block|{
name|layout
operator|->
name|widgetEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// send to all receiver event filters
if|if
condition|(
name|sendThroughObjectEventFilters
argument_list|(
name|receiver
argument_list|,
name|e
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// deliver the event
name|bool
name|consumed
init|=
name|receiver
operator|->
name|event
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|e
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
return|return
name|consumed
return|;
block|}
end_function
begin_function
DECL|function|inPopupMode
name|bool
name|QApplicationPrivate
operator|::
name|inPopupMode
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|!=
literal|0
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_comment
comment|/*!     Sets the kind of focus navigation Qt should use to \a mode.      This feature is available in Qt for Embedded Linux, and Windows CE     only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \since 4.6      \sa keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|setNavigationMode
name|void
name|QApplication
operator|::
name|setNavigationMode
parameter_list|(
name|Qt
operator|::
name|NavigationMode
name|mode
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|navigationMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns what kind of focus navigation Qt is using.      This feature is available in Qt for Embedded Linux, and Windows CE only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \since 4.6      \sa keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|navigationMode
name|Qt
operator|::
name|NavigationMode
name|QApplication
operator|::
name|navigationMode
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|navigationMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether Qt should use focus navigation suitable for use with a     minimal keypad.      This feature is available in Qt for Embedded Linux, and Windows CE only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \deprecated      \sa setNavigationMode() */
end_comment
begin_function
DECL|function|setKeypadNavigationEnabled
name|void
name|QApplication
operator|::
name|setKeypadNavigationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
name|QApplication
operator|::
name|setNavigationMode
argument_list|(
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QApplication
operator|::
name|setNavigationMode
argument_list|(
name|Qt
operator|::
name|NavigationModeNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if Qt is set to use keypad navigation; otherwise returns     false.  The default value is false.      This feature is available in Qt for Embedded Linux, and Windows CE only.      \note On Windows CE this feature is disabled by default for touch device           mkspecs. To enable keypad navigation, build Qt with           QT_KEYPAD_NAVIGATION defined.      \deprecated      \sa navigationMode() */
end_comment
begin_function
DECL|function|keypadNavigationEnabled
name|bool
name|QApplication
operator|::
name|keypadNavigationEnabled
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeKeypadDirectional
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QApplication::alert(QWidget *widget, int msec)     \since 4.3      Causes an alert to be shown for \a widget if the window is not the active     window. The alert is shown for \a msec miliseconds. If \a msec is zero (the     default), then the alert is shown indefinitely until the window becomes     active again.      Currently this function does nothing on Qt for Embedded Linux.      On Mac OS X, this works more at the application level and will cause the     application icon to bounce in the dock.      On Windows, this causes the window's taskbar entry to flash for a time. If     \a msec is zero, the flashing will stop and the taskbar entry will turn a     different color (currently orange).      On X11, this will cause the window to be marked as "demands attention", the     window must not be hidden (i.e. not have hide() called on it, but be     visible in some sort of way) in order for this to work. */
end_comment
begin_comment
comment|/*!     \property QApplication::cursorFlashTime     \brief the text cursor's flash (blink) time in milliseconds      The flash time is the time required to display, invert and restore the     caret display. Usually the text cursor is displayed for half the cursor     flash time, then hidden for the same amount of time, but this may vary.      The default value on X11 is 1000 milliseconds. On Windows, the     \uicontrol{Control Panel} value is used and setting this property sets the cursor     flash time for all applications.      We recommend that widgets do not cache this value as it may change at any     time if the user changes the global desktop settings. */
end_comment
begin_function
DECL|function|setCursorFlashTime
name|void
name|QApplication
operator|::
name|setCursorFlashTime
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cursorFlashTime
name|int
name|QApplication
operator|::
name|cursorFlashTime
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|cursorFlashTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::doubleClickInterval     \brief the time limit in milliseconds that distinguishes a double click     from two consecutive mouse clicks      The default value on X11 is 400 milliseconds. On Windows and Mac OS, the     operating system's value is used.      Setting the interval is not supported anymore in Qt 5. */
end_comment
begin_function
DECL|function|setDoubleClickInterval
name|void
name|QApplication
operator|::
name|setDoubleClickInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|doubleClickInterval
name|int
name|QApplication
operator|::
name|doubleClickInterval
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|mouseDoubleClickInterval
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QApplication::keyboardInputDirection()     \since 4.2     \deprecated      Returns the current keyboard input direction. Replaced with QInputPanel::inputDirection()     \sa QInputPanel::inputDirection() */
end_comment
begin_comment
comment|/*!     \property QApplication::keyboardInputInterval     \brief the time limit in milliseconds that distinguishes a key press     from two consecutive key presses     \since 4.2      The default value on X11 is 400 milliseconds. On Windows and Mac OS, the     operating system's value is used. */
end_comment
begin_function
DECL|function|setKeyboardInputInterval
name|void
name|QApplication
operator|::
name|setKeyboardInputInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|keyboardInputInterval
name|int
name|QApplication
operator|::
name|keyboardInputInterval
parameter_list|()
block|{
return|return
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|keyboardInputInterval
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QApplication::wheelScrollLines     \brief the number of lines to scroll a widget, when the     mouse wheel is rotated.      If the value exceeds the widget's number of visible lines, the widget     should interpret the scroll operation as a single \e{page up} or     \e{page down}. If the widget is an \l{QAbstractItemView}{item view class},     then the result of scrolling one \e line depends on the setting of the     widget's \l{QAbstractItemView::verticalScrollMode()}{scroll mode}. Scroll     one \e line can mean \l{QAbstractItemView::ScrollPerItem}{scroll one item}     or \l{QAbstractItemView::ScrollPerPixel}{scroll one pixel}.      By default, this property has a value of 3. */
end_comment
begin_comment
comment|/*!     \fn void QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)      Enables the UI effect \a effect if \a enable is true, otherwise the effect     will not be used.      \note All effects are disabled on screens running at less than 16-bit color     depth.      \sa isEffectEnabled(), Qt::UIEffect, setDesktopSettingsAware() */
end_comment
begin_comment
comment|/*!     \fn bool QApplication::isEffectEnabled(Qt::UIEffect effect)      Returns true if \a effect is enabled; otherwise returns false.      By default, Qt will try to use the desktop settings. To prevent this, call     setDesktopSettingsAware(false).      \note All effects are disabled on screens running at less than 16-bit color     depth.      \sa setEffectEnabled(), Qt::UIEffect */
end_comment
begin_comment
comment|/*!     \fn void QApplication::beep()      Sounds the bell, using the default volume and sound. The function is \e not     available in Qt for Embedded Linux. */
end_comment
begin_comment
comment|/*!     \macro qApp     \relates QApplication      A global pointer referring to the unique application object. It is     equivalent to the pointer returned by the QCoreApplication::instance()     function except that, in GUI applications, it is a pointer to a     QApplication instance.      Only one application object can be created.      \sa QCoreApplication::instance() */
end_comment
begin_comment
comment|/*!     \fn QLocale QApplication::keyboardInputLocale()     \since 4.2     \obsolete      Returns the current keyboard input locale. Replaced with QInputMethod::locale() */
end_comment
begin_function
DECL|function|qt_sendSpontaneousEvent
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QGuiApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|giveFocusAccordingToFocusPolicy
name|void
name|QApplicationPrivate
operator|::
name|giveFocusAccordingToFocusPolicy
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|FocusPolicy
name|focusPolicy
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|)
block|{
name|QWidget
modifier|*
name|focusWidget
init|=
name|widget
decl_stmt|;
while|while
condition|(
name|focusWidget
condition|)
block|{
if|if
condition|(
name|focusWidget
operator|->
name|isEnabled
argument_list|()
operator|&&
name|QApplicationPrivate
operator|::
name|shouldSetFocus
argument_list|(
name|focusWidget
argument_list|,
name|focusPolicy
argument_list|)
condition|)
block|{
name|focusWidget
operator|->
name|setFocus
argument_list|(
name|focusReason
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|focusWidget
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|focusWidget
operator|=
name|focusWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|shouldSetFocus
name|bool
name|QApplicationPrivate
operator|::
name|shouldSetFocus
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|,
name|Qt
operator|::
name|FocusPolicy
name|policy
parameter_list|)
block|{
name|QWidget
modifier|*
name|f
init|=
name|w
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|f
operator|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|focusPolicy
argument_list|()
operator|&
name|policy
operator|)
operator|!=
name|policy
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|w
operator|!=
name|f
operator|&&
operator|(
name|f
operator|->
name|focusPolicy
argument_list|()
operator|&
name|policy
operator|)
operator|!=
name|policy
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|updateTouchPointsForWidget
name|void
name|QApplicationPrivate
operator|::
name|updateTouchPointsForWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QTouchEvent
modifier|*
name|touchEvent
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|->
name|_touchPoints
index|[
name|i
index|]
decl_stmt|;
comment|// preserve the sub-pixel resolution
name|QRectF
name|rect
init|=
name|touchPoint
operator|.
name|screenRect
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|screenPos
init|=
name|rect
operator|.
name|center
argument_list|()
decl_stmt|;
specifier|const
name|QPointF
name|delta
init|=
name|screenPos
operator|-
name|screenPos
operator|.
name|toPoint
argument_list|()
decl_stmt|;
name|rect
operator|.
name|moveCenter
argument_list|(
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|screenPos
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|startPos
operator|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|startScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
name|touchPoint
operator|.
name|d
operator|->
name|lastPos
operator|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|lastScreenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initializeMultitouch
name|void
name|QApplicationPrivate
operator|::
name|initializeMultitouch
parameter_list|()
block|{
name|initializeMultitouch_sys
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanupMultitouch
name|void
name|QApplicationPrivate
operator|::
name|cleanupMultitouch
parameter_list|()
block|{
name|cleanupMultitouch_sys
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findClosestTouchPointTarget
name|QWidget
modifier|*
name|QApplicationPrivate
operator|::
name|findClosestTouchPointTarget
parameter_list|(
name|QTouchDevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|screenPos
parameter_list|)
block|{
name|int
name|closestTouchPointId
init|=
operator|-
literal|1
decl_stmt|;
name|QObject
modifier|*
name|closestTarget
init|=
literal|0
decl_stmt|;
name|qreal
name|closestDistance
init|=
name|qreal
argument_list|(
literal|0.
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|ActiveTouchPointsKey
argument_list|,
name|ActiveTouchPointsValue
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|ite
init|=
name|activeTouchPoints
operator|.
name|constEnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ite
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|key
argument_list|()
operator|.
name|device
operator|==
name|device
condition|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|it
operator|->
name|touchPoint
decl_stmt|;
name|qreal
name|dx
init|=
name|screenPos
operator|.
name|x
argument_list|()
operator|-
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
name|screenPos
operator|.
name|y
argument_list|()
operator|-
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|distance
init|=
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
decl_stmt|;
if|if
condition|(
name|closestTouchPointId
operator|==
operator|-
literal|1
operator|||
name|distance
operator|<
name|closestDistance
condition|)
block|{
name|closestTouchPointId
operator|=
name|touchPoint
operator|.
name|id
argument_list|()
expr_stmt|;
name|closestDistance
operator|=
name|distance
expr_stmt|;
name|closestTarget
operator|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|target
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
block|}
operator|++
name|it
expr_stmt|;
block|}
return|return
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|closestTarget
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|WidgetAttributeSaver
class|class
name|WidgetAttributeSaver
block|{
public|public:
DECL|function|WidgetAttributeSaver
specifier|explicit
name|WidgetAttributeSaver
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|,
name|bool
name|forcedValue
parameter_list|)
member_init_list|:
name|m_widget
argument_list|(
name|widget
argument_list|)
member_init_list|,
name|m_attribute
argument_list|(
name|attribute
argument_list|)
member_init_list|,
name|m_savedValue
argument_list|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|attribute
argument_list|)
argument_list|)
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|attribute
argument_list|,
name|forcedValue
argument_list|)
expr_stmt|;
block|}
DECL|function|~WidgetAttributeSaver
name|~
name|WidgetAttributeSaver
parameter_list|()
block|{
name|m_widget
operator|->
name|setAttribute
argument_list|(
name|m_attribute
argument_list|,
name|m_savedValue
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|member|m_widget
name|QWidget
modifier|*
specifier|const
name|m_widget
decl_stmt|;
DECL|member|m_attribute
specifier|const
name|Qt
operator|::
name|WidgetAttribute
name|m_attribute
decl_stmt|;
DECL|member|m_savedValue
specifier|const
name|bool
name|m_savedValue
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|translateTouchToMouse
name|bool
name|QApplicationPrivate
operator|::
name|translateTouchToMouse
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QTouchEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
comment|// Check if the platform wants synthesized mouse events.
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QPlatformIntegration
operator|::
name|SynthesizeMouseFromTouchEvents
argument_list|)
operator|.
name|toBool
argument_list|()
condition|)
return|return
literal|false
return|;
name|Q_FOREACH
argument_list|(
argument|const QTouchEvent::TouchPoint&p
argument_list|,
argument|event->touchPoints()
argument_list|)
block|{
specifier|const
name|QEvent
operator|::
name|Type
name|eventType
init|=
operator|(
name|p
operator|.
name|state
argument_list|()
operator|&
name|Qt
operator|::
name|TouchPointPressed
operator|)
condition|?
name|QEvent
operator|::
name|MouseButtonPress
else|:
operator|(
name|p
operator|.
name|state
argument_list|()
operator|&
name|Qt
operator|::
name|TouchPointReleased
operator|)
condition|?
name|QEvent
operator|::
name|MouseButtonRelease
else|:
operator|(
name|p
operator|.
name|state
argument_list|()
operator|&
name|Qt
operator|::
name|TouchPointMoved
operator|)
condition|?
name|QEvent
operator|::
name|MouseMove
else|:
name|QEvent
operator|::
name|None
decl_stmt|;
if|if
condition|(
name|eventType
operator|==
name|QEvent
operator|::
name|None
condition|)
continue|continue;
specifier|const
name|QPoint
name|pos
init|=
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|p
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
decl_stmt|;
name|QMouseEvent
name|mouseEvent
argument_list|(
name|eventType
argument_list|,
name|pos
argument_list|,
name|Qt
operator|::
name|LeftButton
argument_list|,
name|Qt
operator|::
name|LeftButton
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|mouseEvent
operator|.
name|setAccepted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setTimestamp
argument_list|(
name|event
operator|->
name|timestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure our synthesized mouse event doesn't propagate
comment|// we want to control the propagation ourself to get a chance to
comment|// deliver a proper touch event higher up in the hierarchy if that
comment|// widget doesn't pick up the mouse event either.
name|WidgetAttributeSaver
name|saver
argument_list|(
name|widget
argument_list|,
name|Qt
operator|::
name|WA_NoMousePropagation
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Note it has to be a spontaneous event if we want the focus management
comment|// and input method support to behave properly. Quite some of the code
comment|// related to those aspect check for the spontaneous flag.
specifier|const
name|bool
name|res
init|=
name|q
operator|->
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|mouseEvent
argument_list|)
decl_stmt|;
name|event
operator|->
name|setAccepted
argument_list|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
condition|)
return|return
name|res
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|translateRawTouchEvent
name|void
name|QApplicationPrivate
operator|::
name|translateRawTouchEvent
parameter_list|(
name|QWidget
modifier|*
name|window
parameter_list|,
name|QTouchDevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
modifier|&
name|touchPoints
parameter_list|,
name|ulong
name|timestamp
parameter_list|)
block|{
name|QApplicationPrivate
modifier|*
name|d
init|=
name|self
decl_stmt|;
typedef|typedef
name|QPair
argument_list|<
name|Qt
operator|::
name|TouchPointStates
argument_list|,
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
argument_list|>
name|StatesAndTouchPoints
typedef|;
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
name|widgetsNeedingEvents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
name|touchPoint
init|=
name|touchPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// explicitly detach from the original touch point that we got, so even
comment|// if the touchpoint structs are reused, we will make a copy that we'll
comment|// deliver to the user (which might want to store the struct for later use).
name|touchPoint
operator|.
name|d
operator|=
name|touchPoint
operator|.
name|d
operator|->
name|detach
argument_list|()
expr_stmt|;
comment|// update state
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|target
decl_stmt|;
name|ActiveTouchPointsKey
name|touchInfoKey
argument_list|(
name|device
argument_list|,
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|ActiveTouchPointsValue
modifier|&
name|touchInfo
init|=
name|d
operator|->
name|activeTouchPoints
index|[
name|touchInfoKey
index|]
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointPressed
condition|)
block|{
if|if
condition|(
name|device
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
comment|// on touch-pads, send all touch points to the same widget
name|target
operator|=
name|d
operator|->
name|activeTouchPoints
operator|.
name|isEmpty
argument_list|()
condition|?
name|QPointer
argument_list|<
name|QObject
argument_list|>
argument_list|()
else|:
name|d
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
operator|.
name|value
argument_list|()
operator|.
name|target
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
condition|)
block|{
comment|// determine which widget this event will go to
if|if
condition|(
operator|!
name|window
condition|)
name|window
operator|=
name|QApplication
operator|::
name|topLevelAt
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
continue|continue;
name|target
operator|=
name|window
operator|->
name|childAt
argument_list|(
name|window
operator|->
name|mapFromGlobal
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|window
expr_stmt|;
block|}
if|if
condition|(
name|device
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchScreen
condition|)
block|{
name|QWidget
modifier|*
name|closestWidget
init|=
name|d
operator|->
name|findClosestTouchPointTarget
argument_list|(
name|device
argument_list|,
name|touchPoint
operator|.
name|screenPos
argument_list|()
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|closestWidget
operator|&&
operator|(
name|widget
operator|->
name|isAncestorOf
argument_list|(
name|closestWidget
argument_list|)
operator|||
name|closestWidget
operator|->
name|isAncestorOf
argument_list|(
name|widget
argument_list|)
operator|)
condition|)
block|{
name|target
operator|=
name|closestWidget
expr_stmt|;
block|}
block|}
name|touchInfo
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|touchInfo
operator|.
name|target
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
continue|continue;
block|}
name|Q_ASSERT
argument_list|(
name|target
operator|.
name|data
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|StatesAndTouchPoints
modifier|&
name|maskAndPoints
init|=
name|widgetsNeedingEvents
index|[
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
operator|.
name|data
argument_list|()
argument_list|)
index|]
decl_stmt|;
name|maskAndPoints
operator|.
name|first
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
name|maskAndPoints
operator|.
name|second
operator|.
name|append
argument_list|(
name|touchPoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|widgetsNeedingEvents
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|widgetsNeedingEvents
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QWidget
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|end
init|=
name|widgetsNeedingEvents
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|tryModalHelper
argument_list|(
name|widget
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|QEvent
operator|::
name|Type
name|eventType
decl_stmt|;
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchBegin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchEnd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointStationary
case|:
comment|// don't send the event if nothing changed
continue|continue;
default|default:
name|eventType
operator|=
name|QEvent
operator|::
name|TouchUpdate
expr_stmt|;
break|break;
block|}
name|QTouchEvent
name|touchEvent
argument_list|(
name|eventType
argument_list|,
name|device
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
argument_list|,
name|it
operator|.
name|value
argument_list|()
operator|.
name|second
argument_list|)
decl_stmt|;
name|updateTouchPointsForWidget
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|window
operator|->
name|windowHandle
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTarget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|touchEvent
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
block|{
comment|// if the TouchBegin handler recurses, we assume that means the event
comment|// has been implicitly accepted and continue to send touch events
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|)
condition|)
block|{
if|if
condition|(
name|touchEvent
operator|.
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|TouchEnd
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_AcceptedTouchBeginEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|translateTouchCancel
name|void
name|QApplicationPrivate
operator|::
name|translateTouchCancel
parameter_list|(
name|QTouchDevice
modifier|*
name|device
parameter_list|,
name|ulong
name|timestamp
parameter_list|)
block|{
name|QTouchEvent
name|touchEvent
argument_list|(
name|QEvent
operator|::
name|TouchCancel
argument_list|,
name|device
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|ActiveTouchPointsKey
argument_list|,
name|ActiveTouchPointsValue
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|ite
init|=
name|self
operator|->
name|activeTouchPoints
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QSet
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|widgetsNeedingCancel
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|ite
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|it
operator|->
name|target
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
condition|)
name|widgetsNeedingCancel
operator|.
name|insert
argument_list|(
name|widget
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
for|for
control|(
name|QSet
argument_list|<
name|QWidget
operator|*
argument_list|>
operator|::
name|const_iterator
name|widIt
init|=
name|widgetsNeedingCancel
operator|.
name|constBegin
argument_list|()
init|,
name|widItEnd
init|=
name|widgetsNeedingCancel
operator|.
name|constEnd
argument_list|()
init|;
name|widIt
operator|!=
name|widItEnd
condition|;
operator|++
name|widIt
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
operator|*
name|widIt
decl_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|widget
operator|->
name|windowHandle
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTarget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|notifyThemeChanged
name|void
name|QApplicationPrivate
operator|::
name|notifyThemeChanged
parameter_list|()
block|{
name|QGuiApplicationPrivate
operator|::
name|notifyThemeChanged
argument_list|()
expr_stmt|;
name|clearSystemPalette
argument_list|()
expr_stmt|;
name|initSystemPalette
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_function
DECL|function|notifyDragStarted
name|void
name|QApplicationPrivate
operator|::
name|notifyDragStarted
parameter_list|(
specifier|const
name|QDrag
modifier|*
name|drag
parameter_list|)
block|{
comment|// Prevent pickMouseReceiver() from using the widget where the drag was started after a drag operation.
name|QGuiApplicationPrivate
operator|::
name|notifyDragStarted
argument_list|(
name|drag
argument_list|)
expr_stmt|;
name|qt_button_down
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_function
DECL|function|instance
name|QGestureManager
modifier|*
name|QGestureManager
operator|::
name|instance
parameter_list|()
block|{
name|QApplicationPrivate
modifier|*
name|qAppPriv
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qAppPriv
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|qAppPriv
operator|->
name|gestureManager
condition|)
name|qAppPriv
operator|->
name|gestureManager
operator|=
operator|new
name|QGestureManager
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
return|return
name|qAppPriv
operator|->
name|gestureManager
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_function
DECL|function|applyQIconStyleHelper
name|QPixmap
name|QApplicationPrivate
operator|::
name|applyQIconStyleHelper
parameter_list|(
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|base
parameter_list|)
specifier|const
block|{
name|QStyleOption
name|opt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|opt
operator|.
name|palette
operator|=
name|QGuiApplication
operator|::
name|palette
argument_list|()
expr_stmt|;
return|return
name|QApplication
operator|::
name|style
argument_list|()
operator|->
name|generatedIconPixmap
argument_list|(
name|mode
argument_list|,
name|base
argument_list|,
operator|&
name|opt
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qapplication.cpp"
end_include
end_unit
