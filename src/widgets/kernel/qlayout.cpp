begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qlayoutengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qmenubar.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbar.h"
end_include
begin_include
include|#
directive|include
file|"qsizegrip.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qformlayout.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|menuBarHeightForWidth
specifier|static
name|int
name|menuBarHeightForWidth
parameter_list|(
name|QWidget
modifier|*
name|menubar
parameter_list|,
name|int
name|w
parameter_list|)
block|{
if|if
condition|(
name|menubar
operator|&&
operator|!
name|menubar
operator|->
name|isHidden
argument_list|()
operator|&&
operator|!
name|menubar
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|int
name|result
init|=
name|menubar
operator|->
name|heightForWidth
argument_list|(
name|qMax
argument_list|(
name|w
argument_list|,
name|menubar
operator|->
name|minimumWidth
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
return|return
name|result
return|;
name|result
operator|=
name|menubar
operator|->
name|sizeHint
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|menubar
operator|->
name|minimumSize
argument_list|()
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|menubar
operator|->
name|minimumSizeHint
argument_list|()
argument_list|)
operator|.
name|boundedTo
argument_list|(
name|menubar
operator|->
name|maximumSize
argument_list|()
argument_list|)
operator|.
name|height
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
return|return
name|result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \class QLayout     \brief The QLayout class is the base class of geometry managers.      \ingroup geomanagement     \inmodule QtWidgets      This is an abstract base class inherited by the concrete classes     QBoxLayout, QGridLayout, QFormLayout, and QStackedLayout.      For users of QLayout subclasses or of QMainWindow there is seldom     any need to use the basic functions provided by QLayout, such as     setSizeConstraint() or setMenuBar(). See \l{Layout Management}     for more information.      To make your own layout manager, implement the functions     addItem(), sizeHint(), setGeometry(), itemAt() and takeAt(). You     should also implement minimumSize() to ensure your layout isn't     resized to zero size if there is too little space. To support     children whose heights depend on their widths, implement     hasHeightForWidth() and heightForWidth(). See the     \l{layouts/borderlayout}{Border Layout} and     \l{layouts/flowlayout}{Flow Layout} examples for     more information about implementing custom layout managers.      Geometry management stops when the layout manager is deleted.      \sa QLayoutItem, {Layout Management}, {Basic Layouts Example},         {Border Layout Example}, {Flow Layout Example} */
end_comment
begin_comment
comment|/*!     Constructs a new top-level QLayout, with parent \a parent.     \a parent may not be 0.      There can be only one top-level layout for a widget. It is     returned by QWidget::layout(). */
end_comment
begin_constructor
DECL|function|QLayout
name|QLayout
operator|::
name|QLayout
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QLayoutPrivate
argument_list|,
name|parent
argument_list|)
block|{
if|if
condition|(
operator|!
name|parent
condition|)
return|return;
name|parent
operator|->
name|setLayout
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a new child QLayout.      This layout has to be inserted into another layout before geometry     management will work. */
end_comment
begin_constructor
DECL|function|QLayout
name|QLayout
operator|::
name|QLayout
parameter_list|()
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QLayoutPrivate
argument_list|,
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QLayout
name|QLayout
operator|::
name|QLayout
parameter_list|(
name|QLayoutPrivate
modifier|&
name|dd
parameter_list|,
name|QLayout
modifier|*
name|lay
parameter_list|,
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|lay
condition|?
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|lay
argument_list|)
else|:
cast|static_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|w
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|lay
condition|)
block|{
name|lay
operator|->
name|addItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|layout
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLayout: Attempting to add QLayout \"%s\" to %s \"%s\", which"
literal|" already has a layout"
argument_list|,
name|qPrintable
argument_list|(
name|QObject
operator|::
name|objectName
argument_list|()
argument_list|)
argument_list|,
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|w
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|topLevel
operator|=
literal|true
expr_stmt|;
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|=
name|this
expr_stmt|;
name|QT_TRY
block|{
name|invalidate
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|=
literal|0
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
block|}
block|}
end_constructor
begin_constructor
DECL|function|QLayoutPrivate
name|QLayoutPrivate
operator|::
name|QLayoutPrivate
parameter_list|()
member_init_list|:
name|QObjectPrivate
argument_list|()
member_init_list|,
name|insideSpacing
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|userLeftMargin
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|userTopMargin
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|userRightMargin
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|userBottomMargin
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|topLevel
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|enabled
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|activated
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|autoNewChild
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|constraint
argument_list|(
name|QLayout
operator|::
name|SetDefaultConstraint
argument_list|)
member_init_list|,
name|menubar
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|getMargin
name|void
name|QLayoutPrivate
operator|::
name|getMargin
parameter_list|(
name|int
modifier|*
name|result
parameter_list|,
name|int
name|userMargin
parameter_list|,
name|QStyle
operator|::
name|PixelMetric
name|pm
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|result
condition|)
return|return;
name|Q_Q
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|userMargin
operator|>=
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|userMargin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|topLevel
condition|)
block|{
operator|*
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QWidget
modifier|*
name|pw
init|=
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
operator|*
name|result
operator|=
name|pw
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
name|pw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Static item factory functions that allow for hooking things in Designer
end_comment
begin_decl_stmt
DECL|member|widgetItemFactoryMethod
name|QLayoutPrivate
operator|::
name|QWidgetItemFactoryMethod
name|QLayoutPrivate
operator|::
name|widgetItemFactoryMethod
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|spacerItemFactoryMethod
name|QLayoutPrivate
operator|::
name|QSpacerItemFactoryMethod
name|QLayoutPrivate
operator|::
name|spacerItemFactoryMethod
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|createWidgetItem
name|QWidgetItem
modifier|*
name|QLayoutPrivate
operator|::
name|createWidgetItem
parameter_list|(
specifier|const
name|QLayout
modifier|*
name|layout
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|widgetItemFactoryMethod
condition|)
if|if
condition|(
name|QWidgetItem
modifier|*
name|wi
init|=
call|(
modifier|*
name|widgetItemFactoryMethod
call|)
argument_list|(
name|layout
argument_list|,
name|widget
argument_list|)
condition|)
return|return
name|wi
return|;
return|return
operator|new
name|QWidgetItemV2
argument_list|(
name|widget
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createSpacerItem
name|QSpacerItem
modifier|*
name|QLayoutPrivate
operator|::
name|createSpacerItem
parameter_list|(
specifier|const
name|QLayout
modifier|*
name|layout
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QSizePolicy
operator|::
name|Policy
name|hPolicy
parameter_list|,
name|QSizePolicy
operator|::
name|Policy
name|vPolicy
parameter_list|)
block|{
if|if
condition|(
name|spacerItemFactoryMethod
condition|)
if|if
condition|(
name|QSpacerItem
modifier|*
name|si
init|=
call|(
modifier|*
name|spacerItemFactoryMethod
call|)
argument_list|(
name|layout
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|hPolicy
argument_list|,
name|vPolicy
argument_list|)
condition|)
return|return
name|si
return|;
return|return
operator|new
name|QSpacerItem
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|hPolicy
argument_list|,
name|vPolicy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLayout::addItem(QLayoutItem *item)      Implemented in subclasses to add an \a item. How it is added is     specific to each subclass.      This function is not usually called in application code. To add a widget     to a layout, use the addWidget() function; to add a child layout, use the     addLayout() function provided by the relevant QLayout subclass.      \b{Note:} The ownership of \a item is transferred to the layout, and it's     the layout's responsibility to delete it.      \sa addWidget(), QBoxLayout::addLayout(), QGridLayout::addLayout() */
end_comment
begin_comment
comment|/*!     Adds widget \a w to this layout in a manner specific to the     layout. This function uses addItem(). */
end_comment
begin_function
DECL|function|addWidget
name|void
name|QLayout
operator|::
name|addWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|addChildWidget
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|QLayoutPrivate
operator|::
name|createWidgetItem
argument_list|(
name|this
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the alignment for widget \a w to \a alignment and returns     true if \a w is found in this layout (not including child     layouts); otherwise returns false. */
end_comment
begin_function
DECL|function|setAlignment
name|bool
name|QLayout
operator|::
name|setAlignment
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|,
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
init|=
name|itemAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|widget
argument_list|()
operator|==
name|w
condition|)
block|{
name|item
operator|->
name|setAlignment
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
operator|++
name|i
expr_stmt|;
name|item
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \overload    Sets the alignment for the layout \a l to \a alignment and   returns true if \a l is found in this layout (not including child   layouts); otherwise returns false. */
end_comment
begin_function
DECL|function|setAlignment
name|bool
name|QLayout
operator|::
name|setAlignment
parameter_list|(
name|QLayout
modifier|*
name|l
parameter_list|,
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
init|=
name|itemAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|layout
argument_list|()
operator|==
name|l
condition|)
block|{
name|item
operator|->
name|setAlignment
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
operator|++
name|i
expr_stmt|;
name|item
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLayout::setAlignment(Qt::Alignment alignment)      Sets the alignment of this item to \a alignment.      \sa QLayoutItem::setAlignment() */
end_comment
begin_comment
comment|/*!     \property QLayout::margin     \brief the width of the outside border of the layout     \obsolete      Use setContentsMargins() and getContentsMargins() instead.      \sa contentsRect(), spacing */
end_comment
begin_comment
comment|/*!     \obsolete */
end_comment
begin_function
DECL|function|margin
name|int
name|QLayout
operator|::
name|margin
parameter_list|()
specifier|const
block|{
name|int
name|left
decl_stmt|,
name|top
decl_stmt|,
name|right
decl_stmt|,
name|bottom
decl_stmt|;
name|getContentsMargins
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|right
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|top
operator|&&
name|top
operator|==
name|right
operator|&&
name|right
operator|==
name|bottom
condition|)
block|{
return|return
name|left
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QLayout::spacing     \brief the spacing between widgets inside the layout      If no value is explicitly set, the layout's spacing is inherited     from the parent layout, or from the style settings for the parent     widget.      For QGridLayout and QFormLayout, it is possible to set different horizontal and     vertical spacings using \l{QGridLayout::}{setHorizontalSpacing()}     and \l{QGridLayout::}{setVerticalSpacing()}. In that case,     spacing() returns -1.      \sa contentsRect(), getContentsMargins(), QStyle::layoutSpacing(),         QStyle::pixelMetric() */
end_comment
begin_function
DECL|function|spacing
name|int
name|QLayout
operator|::
name|spacing
parameter_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|QBoxLayout
modifier|*
name|boxlayout
init|=
name|qobject_cast
argument_list|<
specifier|const
name|QBoxLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|boxlayout
operator|->
name|spacing
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|QGridLayout
modifier|*
name|gridlayout
init|=
name|qobject_cast
argument_list|<
specifier|const
name|QGridLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|gridlayout
operator|->
name|spacing
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|QFormLayout
modifier|*
name|formlayout
init|=
name|qobject_cast
argument_list|<
specifier|const
name|QFormLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|formlayout
operator|->
name|spacing
argument_list|()
return|;
block|}
else|else
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|insideSpacing
operator|>=
literal|0
condition|)
block|{
return|return
name|d
operator|->
name|insideSpacing
return|;
block|}
else|else
block|{
comment|// arbitrarily prefer horizontal spacing to vertical spacing
return|return
name|qSmartSpacing
argument_list|(
name|this
argument_list|,
name|QStyle
operator|::
name|PM_LayoutHorizontalSpacing
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \obsolete */
end_comment
begin_function
DECL|function|setMargin
name|void
name|QLayout
operator|::
name|setMargin
parameter_list|(
name|int
name|margin
parameter_list|)
block|{
name|setContentsMargins
argument_list|(
name|margin
argument_list|,
name|margin
argument_list|,
name|margin
argument_list|,
name|margin
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSpacing
name|void
name|QLayout
operator|::
name|setSpacing
parameter_list|(
name|int
name|spacing
parameter_list|)
block|{
if|if
condition|(
name|QBoxLayout
modifier|*
name|boxlayout
init|=
name|qobject_cast
argument_list|<
name|QBoxLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|boxlayout
operator|->
name|setSpacing
argument_list|(
name|spacing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QGridLayout
modifier|*
name|gridlayout
init|=
name|qobject_cast
argument_list|<
name|QGridLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|gridlayout
operator|->
name|setSpacing
argument_list|(
name|spacing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QFormLayout
modifier|*
name|formlayout
init|=
name|qobject_cast
argument_list|<
name|QFormLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|formlayout
operator|->
name|setSpacing
argument_list|(
name|spacing
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|insideSpacing
operator|=
name|spacing
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Sets the \a left, \a top, \a right, and \a bottom margins to use     around the layout.      By default, QLayout uses the values provided by the style. On     most platforms, the margin is 11 pixels in all directions.      \sa getContentsMargins(), QStyle::pixelMetric(),         {QStyle::}{PM_LayoutLeftMargin},         {QStyle::}{PM_LayoutTopMargin},         {QStyle::}{PM_LayoutRightMargin},         {QStyle::}{PM_LayoutBottomMargin} */
end_comment
begin_function
DECL|function|setContentsMargins
name|void
name|QLayout
operator|::
name|setContentsMargins
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|userLeftMargin
operator|==
name|left
operator|&&
name|d
operator|->
name|userTopMargin
operator|==
name|top
operator|&&
name|d
operator|->
name|userRightMargin
operator|==
name|right
operator|&&
name|d
operator|->
name|userBottomMargin
operator|==
name|bottom
condition|)
return|return;
name|d
operator|->
name|userLeftMargin
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|userTopMargin
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|userRightMargin
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|userBottomMargin
operator|=
name|bottom
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the \a margins to use around the layout.      By default, QLayout uses the values provided by the style. On     most platforms, the margin is 11 pixels in all directions.      \sa contentsMargins() */
end_comment
begin_function
DECL|function|setContentsMargins
name|void
name|QLayout
operator|::
name|setContentsMargins
parameter_list|(
specifier|const
name|QMargins
modifier|&
name|margins
parameter_list|)
block|{
name|setContentsMargins
argument_list|(
name|margins
operator|.
name|left
argument_list|()
argument_list|,
name|margins
operator|.
name|top
argument_list|()
argument_list|,
name|margins
operator|.
name|right
argument_list|()
argument_list|,
name|margins
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Extracts the left, top, right, and bottom margins used around the     layout, and assigns them to *\a left, *\a top, *\a right, and *\a     bottom (unless they are null pointers).      By default, QLayout uses the values provided by the style. On     most platforms, the margin is 11 pixels in all directions.      \sa setContentsMargins(), QStyle::pixelMetric(),         {QStyle::}{PM_LayoutLeftMargin},         {QStyle::}{PM_LayoutTopMargin},         {QStyle::}{PM_LayoutRightMargin},         {QStyle::}{PM_LayoutBottomMargin} */
end_comment
begin_function
DECL|function|getContentsMargins
name|void
name|QLayout
operator|::
name|getContentsMargins
parameter_list|(
name|int
modifier|*
name|left
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|right
parameter_list|,
name|int
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|getMargin
argument_list|(
name|left
argument_list|,
name|d
operator|->
name|userLeftMargin
argument_list|,
name|QStyle
operator|::
name|PM_LayoutLeftMargin
argument_list|)
expr_stmt|;
name|d
operator|->
name|getMargin
argument_list|(
name|top
argument_list|,
name|d
operator|->
name|userTopMargin
argument_list|,
name|QStyle
operator|::
name|PM_LayoutTopMargin
argument_list|)
expr_stmt|;
name|d
operator|->
name|getMargin
argument_list|(
name|right
argument_list|,
name|d
operator|->
name|userRightMargin
argument_list|,
name|QStyle
operator|::
name|PM_LayoutRightMargin
argument_list|)
expr_stmt|;
name|d
operator|->
name|getMargin
argument_list|(
name|bottom
argument_list|,
name|d
operator|->
name|userBottomMargin
argument_list|,
name|QStyle
operator|::
name|PM_LayoutBottomMargin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the margins used around the layout.      By default, QLayout uses the values provided by the style. On     most platforms, the margin is 11 pixels in all directions.      \sa setContentsMargins() */
end_comment
begin_function
DECL|function|contentsMargins
name|QMargins
name|QLayout
operator|::
name|contentsMargins
parameter_list|()
specifier|const
block|{
name|int
name|left
decl_stmt|,
name|top
decl_stmt|,
name|right
decl_stmt|,
name|bottom
decl_stmt|;
name|getContentsMargins
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|right
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
return|return
name|QMargins
argument_list|(
name|left
argument_list|,
name|top
argument_list|,
name|right
argument_list|,
name|bottom
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns the layout's geometry() rectangle, but taking into account the     contents margins.      \sa setContentsMargins(), getContentsMargins() */
end_comment
begin_function
DECL|function|contentsRect
name|QRect
name|QLayout
operator|::
name|contentsRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|left
decl_stmt|,
name|top
decl_stmt|,
name|right
decl_stmt|,
name|bottom
decl_stmt|;
name|getContentsMargins
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|right
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
operator|+
name|left
argument_list|,
operator|+
name|top
argument_list|,
operator|-
name|right
argument_list|,
operator|-
name|bottom
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parent widget of this layout, or 0 if this layout is     not installed on any widget.      If the layout is a sub-layout, this function returns the parent     widget of the parent layout.      \sa parent() */
end_comment
begin_function
DECL|function|parentWidget
name|QWidget
modifier|*
name|QLayout
operator|::
name|parentWidget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|topLevel
condition|)
block|{
if|if
condition|(
name|parent
argument_list|()
condition|)
block|{
name|QLayout
modifier|*
name|parentLayout
init|=
name|qobject_cast
argument_list|<
name|QLayout
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentLayout
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLayout::parentWidget: A layout can only have another layout as a parent."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|parentLayout
operator|->
name|parentWidget
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|parent
argument_list|()
operator|&&
name|parent
argument_list|()
operator|->
name|isWidgetType
argument_list|()
argument_list|)
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QLayout
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
init|=
name|itemAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
operator|++
name|i
expr_stmt|;
name|item
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|controlTypes
name|QSizePolicy
operator|::
name|ControlTypes
name|QLayout
operator|::
name|controlTypes
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|count
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QSizePolicy
operator|::
name|DefaultType
return|;
name|QSizePolicy
operator|::
name|ControlTypes
name|types
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|types
operator||=
name|itemAt
argument_list|(
name|i
argument_list|)
operator|->
name|controlTypes
argument_list|()
expr_stmt|;
return|return
name|types
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QLayout
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|rect
operator|=
name|r
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|geometry
name|QRect
name|QLayout
operator|::
name|geometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|invalidate
name|void
name|QLayout
operator|::
name|invalidate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|rect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeWidgetRecursively
specifier|static
name|bool
name|removeWidgetRecursively
parameter_list|(
name|QLayoutItem
modifier|*
name|li
parameter_list|,
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|QLayout
modifier|*
name|lay
init|=
name|li
operator|->
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lay
condition|)
return|return
literal|false
return|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|child
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|lay
operator|->
name|itemAt
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|widget
argument_list|()
operator|==
name|w
condition|)
block|{
operator|delete
name|lay
operator|->
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|lay
operator|->
name|invalidate
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|removeWidgetRecursively
argument_list|(
name|child
argument_list|,
name|w
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|doResize
name|void
name|QLayoutPrivate
operator|::
name|doResize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|r
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|mbh
init|=
name|menuBarHeightForWidth
argument_list|(
name|menubar
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|mw
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|QRect
name|rect
init|=
name|mw
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutOnEntireRect
argument_list|)
condition|?
name|mw
operator|->
name|rect
argument_list|()
else|:
name|mw
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
name|rect
operator|.
name|setTop
argument_list|(
name|rect
operator|.
name|top
argument_list|()
operator|+
name|mbh
argument_list|)
expr_stmt|;
name|q
operator|->
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
if|if
condition|(
name|menubar
condition|)
name|menubar
operator|->
name|setGeometry
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|mbh
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     Performs child widget layout when the parent widget is     resized.  Also handles removal of widgets. \a e is the     event */
end_comment
begin_function
DECL|function|widgetEvent
name|void
name|QLayout
operator|::
name|widgetEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|enabled
condition|)
return|return;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Resize
case|:
if|if
condition|(
name|d
operator|->
name|activated
condition|)
block|{
name|QResizeEvent
modifier|*
name|r
init|=
operator|(
name|QResizeEvent
operator|*
operator|)
name|e
decl_stmt|;
name|d
operator|->
name|doResize
argument_list|(
name|r
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|activate
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
block|{
name|QChildEvent
modifier|*
name|c
init|=
operator|(
name|QChildEvent
operator|*
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|child
argument_list|()
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
operator|(
name|QWidget
operator|*
operator|)
name|c
operator|->
name|child
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
if|if
condition|(
name|w
operator|==
name|d
operator|->
name|menubar
condition|)
name|d
operator|->
name|menubar
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|removeWidgetRecursively
argument_list|(
name|this
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|LayoutRequest
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
operator|->
name|isVisible
argument_list|()
condition|)
name|activate
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|childEvent
name|void
name|QLayout
operator|::
name|childEvent
parameter_list|(
name|QChildEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|enabled
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ChildRemoved
condition|)
block|{
name|QChildEvent
modifier|*
name|c
init|=
operator|(
name|QChildEvent
operator|*
operator|)
name|e
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
decl_stmt|;
while|while
condition|(
operator|(
name|item
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|item
operator|==
cast|static_cast
argument_list|<
name|QLayout
operator|*
argument_list|>
argument_list|(
name|c
operator|->
name|child
argument_list|()
argument_list|)
condition|)
block|{
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \internal   Also takes contentsMargins and menu bar into account. */
end_comment
begin_function
DECL|function|totalHeightForWidth
name|int
name|QLayout
operator|::
name|totalHeightForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|side
init|=
literal|0
decl_stmt|,
name|top
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|topLevel
condition|)
block|{
name|QWidget
modifier|*
name|parent
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|parent
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|parent
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|side
operator|+=
name|wd
operator|->
name|leftmargin
operator|+
name|wd
operator|->
name|rightmargin
expr_stmt|;
name|top
operator|+=
name|wd
operator|->
name|topmargin
operator|+
name|wd
operator|->
name|bottommargin
expr_stmt|;
block|}
name|int
name|h
init|=
name|heightForWidth
argument_list|(
name|w
operator|-
name|side
argument_list|)
operator|+
name|top
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
name|h
operator|+=
name|menuBarHeightForWidth
argument_list|(
name|d
operator|->
name|menubar
argument_list|,
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|h
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Also takes contentsMargins and menu bar into account. */
end_comment
begin_function
DECL|function|totalMinimumSize
name|QSize
name|QLayout
operator|::
name|totalMinimumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|side
init|=
literal|0
decl_stmt|,
name|top
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|topLevel
condition|)
block|{
name|QWidget
modifier|*
name|pw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|pw
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|pw
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|side
operator|+=
name|wd
operator|->
name|leftmargin
operator|+
name|wd
operator|->
name|rightmargin
expr_stmt|;
name|top
operator|+=
name|wd
operator|->
name|topmargin
operator|+
name|wd
operator|->
name|bottommargin
expr_stmt|;
block|}
name|QSize
name|s
init|=
name|minimumSize
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
name|top
operator|+=
name|menuBarHeightForWidth
argument_list|(
name|d
operator|->
name|menubar
argument_list|,
name|s
operator|.
name|width
argument_list|()
operator|+
name|side
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s
operator|+
name|QSize
argument_list|(
name|side
argument_list|,
name|top
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Also takes contentsMargins and menu bar into account. */
end_comment
begin_function
DECL|function|totalSizeHint
name|QSize
name|QLayout
operator|::
name|totalSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|side
init|=
literal|0
decl_stmt|,
name|top
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|topLevel
condition|)
block|{
name|QWidget
modifier|*
name|pw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|pw
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|pw
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|side
operator|+=
name|wd
operator|->
name|leftmargin
operator|+
name|wd
operator|->
name|rightmargin
expr_stmt|;
name|top
operator|+=
name|wd
operator|->
name|topmargin
operator|+
name|wd
operator|->
name|bottommargin
expr_stmt|;
block|}
name|QSize
name|s
init|=
name|sizeHint
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasHeightForWidth
argument_list|()
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|heightForWidth
argument_list|(
name|s
operator|.
name|width
argument_list|()
operator|+
name|side
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
name|top
operator|+=
name|menuBarHeightForWidth
argument_list|(
name|d
operator|->
name|menubar
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s
operator|+
name|QSize
argument_list|(
name|side
argument_list|,
name|top
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Also takes contentsMargins and menu bar into account. */
end_comment
begin_function
DECL|function|totalMaximumSize
name|QSize
name|QLayout
operator|::
name|totalMaximumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|side
init|=
literal|0
decl_stmt|,
name|top
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|topLevel
condition|)
block|{
name|QWidget
modifier|*
name|pw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|pw
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|pw
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|side
operator|+=
name|wd
operator|->
name|leftmargin
operator|+
name|wd
operator|->
name|rightmargin
expr_stmt|;
name|top
operator|+=
name|wd
operator|->
name|topmargin
operator|+
name|wd
operator|->
name|bottommargin
expr_stmt|;
block|}
name|QSize
name|s
init|=
name|maximumSize
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
name|top
operator|+=
name|menuBarHeightForWidth
argument_list|(
name|d
operator|->
name|menubar
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|topLevel
condition|)
name|s
operator|=
name|QSize
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|width
argument_list|()
operator|+
name|side
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|s
operator|.
name|height
argument_list|()
operator|+
name|top
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Destroys the layout, deleting all child layouts.   Geometry management stops when a top-level layout is deleted.    The layout classes will probably be fatally confused if you delete   a sublayout. */
end_comment
begin_destructor
DECL|function|~QLayout
name|QLayout
operator|::
name|~
name|QLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
comment|/*       This function may be called during the QObject destructor,       when the parent no longer is a QWidget.     */
if|if
condition|(
name|d
operator|->
name|topLevel
operator|&&
name|parent
argument_list|()
operator|&&
name|parent
argument_list|()
operator|->
name|isWidgetType
argument_list|()
operator|&&
operator|(
operator|(
name|QWidget
operator|*
operator|)
name|parent
argument_list|()
operator|)
operator|->
name|layout
argument_list|()
operator|==
name|this
condition|)
operator|(
operator|(
name|QWidget
operator|*
operator|)
name|parent
argument_list|()
operator|)
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     This function is called from \c addLayout() or \c insertLayout() functions in     subclasses to add layout \a l as a sub-layout.      The only scenario in which you need to call it directly is if you     implement a custom layout that supports nested layouts.      \sa QBoxLayout::addLayout(), QBoxLayout::insertLayout(), QGridLayout::addLayout() */
end_comment
begin_function
DECL|function|addChildLayout
name|void
name|QLayout
operator|::
name|addChildLayout
parameter_list|(
name|QLayout
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
operator|->
name|parent
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLayout::addChildLayout: layout \"%s\" already has a parent"
argument_list|,
name|l
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|mw
init|=
name|parentWidget
argument_list|()
condition|)
block|{
name|l
operator|->
name|d_func
argument_list|()
operator|->
name|reparentChildWidgets
argument_list|(
name|mw
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!    \internal  */
end_comment
begin_function
DECL|function|adoptLayout
name|bool
name|QLayout
operator|::
name|adoptLayout
parameter_list|(
name|QLayout
modifier|*
name|layout
parameter_list|)
block|{
specifier|const
name|bool
name|ok
init|=
operator|!
name|layout
operator|->
name|parent
argument_list|()
decl_stmt|;
name|addChildLayout
argument_list|(
name|layout
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEBUG
end_ifdef
begin_function
DECL|function|layoutDebug
specifier|static
name|bool
name|layoutDebug
parameter_list|()
block|{
specifier|static
name|int
name|checked_env
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|checked_env
operator|==
operator|-
literal|1
condition|)
name|checked_env
operator|=
operator|!
operator|!
name|qgetenv
argument_list|(
literal|"QT_LAYOUT_DEBUG"
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
return|return
name|checked_env
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|reparentChildWidgets
name|void
name|QLayoutPrivate
operator|::
name|reparentChildWidgets
parameter_list|(
name|QWidget
modifier|*
name|mw
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|q
operator|->
name|count
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
if|if
condition|(
name|menubar
operator|&&
name|menubar
operator|->
name|parentWidget
argument_list|()
operator|!=
name|mw
condition|)
block|{
name|menubar
operator|->
name|setParent
argument_list|(
name|mw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bool
name|mwVisible
init|=
name|mw
operator|&&
name|mw
operator|->
name|isVisible
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QLayoutItem
modifier|*
name|item
init|=
name|q
operator|->
name|itemAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|item
operator|->
name|widget
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|pw
init|=
name|w
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|pw
operator|&&
name|pw
operator|!=
name|mw
operator|&&
name|layoutDebug
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLayout::addChildLayout: widget %s \"%s\" in wrong parent; moved to correct parent"
argument_list|,
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|w
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bool
name|needShow
init|=
name|mwVisible
operator|&&
operator|!
operator|(
name|w
operator|->
name|isHidden
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|pw
operator|!=
name|mw
condition|)
name|w
operator|->
name|setParent
argument_list|(
name|mw
argument_list|)
expr_stmt|;
if|if
condition|(
name|needShow
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|w
argument_list|,
literal|"_q_showIfNotHidden"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|//show later
block|}
elseif|else
if|if
condition|(
name|QLayout
modifier|*
name|l
init|=
name|item
operator|->
name|layout
argument_list|()
condition|)
block|{
name|l
operator|->
name|d_func
argument_list|()
operator|->
name|reparentChildWidgets
argument_list|(
name|mw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called from \c addWidget() functions in     subclasses to add \a w as a managed widget of a layout.      If \a w is already managed by a layout, this function will give a warning     and remove \a w from that layout. This function must therefore be     called before adding \a w to the layout's data structure. */
end_comment
begin_function
DECL|function|addChildWidget
name|void
name|QLayout
operator|::
name|addChildWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|QWidget
modifier|*
name|mw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|pw
init|=
name|w
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
comment|//Qt::WA_LaidOut is never reset. It only means that the widget at some point has
comment|//been in a layout.
if|if
condition|(
name|pw
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LaidOut
argument_list|)
condition|)
block|{
name|QLayout
modifier|*
name|l
init|=
name|pw
operator|->
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|&&
name|removeWidgetRecursively
argument_list|(
name|l
argument_list|,
name|w
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|layoutDebug
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QLayout::addChildWidget: %s \"%s\" is already in a layout; moved to new layout"
argument_list|,
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|w
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|pw
operator|&&
name|mw
operator|&&
name|pw
operator|!=
name|mw
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|layoutDebug
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QLayout::addChildWidget: %s \"%s\" in wrong parent; moved to correct parent"
argument_list|,
name|w
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|w
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
literal|0
expr_stmt|;
block|}
name|bool
name|needShow
init|=
name|mw
operator|&&
name|mw
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|isHidden
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|pw
operator|&&
name|mw
condition|)
name|w
operator|->
name|setParent
argument_list|(
name|mw
argument_list|)
expr_stmt|;
name|w
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_LaidOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|needShow
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|w
argument_list|,
literal|"_q_showIfNotHidden"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|//show later
block|}
end_function
begin_comment
comment|/*!     Tells the geometry manager to place the menu bar \a widget at the     top of parentWidget(), outside QWidget::contentsMargins(). All     child widgets are placed below the bottom edge of the menu bar. */
end_comment
begin_function
DECL|function|setMenuBar
name|void
name|QLayout
operator|::
name|setMenuBar
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WINCE_WM
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|size
argument_list|()
operator|.
name|height
argument_list|()
operator|>
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|widget
condition|)
endif|#
directive|endif
name|addChildWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|d
operator|->
name|menubar
operator|=
name|widget
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the menu bar set for this layout, or 0 if no menu bar is     set. */
end_comment
begin_function
DECL|function|menuBar
name|QWidget
modifier|*
name|QLayout
operator|::
name|menuBar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|menubar
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum size of this layout. This is the smallest     size that the layout can have while still respecting the     specifications.      The returned value doesn't include the space required by     QWidget::setContentsMargins() or menuBar().      The default implementation allows unlimited resizing. */
end_comment
begin_function
DECL|function|minimumSize
name|QSize
name|QLayout
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum size of this layout. This is the largest size     that the layout can have while still respecting the     specifications.      The returned value doesn't include the space required by     QWidget::setContentsMargins() or menuBar().      The default implementation allows unlimited resizing. */
end_comment
begin_function
DECL|function|maximumSize
name|QSize
name|QLayout
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns whether this layout can make use of more space than     sizeHint(). A value of Qt::Vertical or Qt::Horizontal means that     it wants to grow in only one dimension, whereas Qt::Vertical |     Qt::Horizontal means that it wants to grow in both dimensions.      The default implementation returns Qt::Horizontal | Qt::Vertical.     Subclasses reimplement it to return a meaningful value based on     their child widgets's \l{QSizePolicy}{size policies}.      \sa sizeHint() */
end_comment
begin_function
DECL|function|expandingDirections
name|Qt
operator|::
name|Orientations
name|QLayout
operator|::
name|expandingDirections
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|Horizontal
operator||
name|Qt
operator|::
name|Vertical
return|;
block|}
end_function
begin_function
DECL|function|activateRecursiveHelper
name|void
name|QLayout
operator|::
name|activateRecursiveHelper
parameter_list|(
name|QLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|item
operator|->
name|invalidate
argument_list|()
expr_stmt|;
name|QLayout
modifier|*
name|layout
init|=
name|item
operator|->
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
name|layout
condition|)
block|{
name|QLayoutItem
modifier|*
name|child
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|layout
operator|->
name|itemAt
argument_list|(
name|i
operator|++
argument_list|)
operator|)
condition|)
name|activateRecursiveHelper
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|layout
operator|->
name|d_func
argument_list|()
operator|->
name|activated
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Updates the layout for parentWidget().    You should generally not need to call this because it is   automatically called at the most appropriate times.    \sa activate(), invalidate() */
end_comment
begin_function
DECL|function|update
name|void
name|QLayout
operator|::
name|update
parameter_list|()
block|{
name|QLayout
modifier|*
name|layout
init|=
name|this
decl_stmt|;
while|while
condition|(
name|layout
operator|&&
name|layout
operator|->
name|d_func
argument_list|()
operator|->
name|activated
condition|)
block|{
name|layout
operator|->
name|d_func
argument_list|()
operator|->
name|activated
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|layout
operator|->
name|d_func
argument_list|()
operator|->
name|topLevel
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|layout
operator|->
name|parent
argument_list|()
operator|->
name|isWidgetType
argument_list|()
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|mw
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|layout
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|postEvent
argument_list|(
name|mw
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|layout
operator|=
cast|static_cast
argument_list|<
name|QLayout
operator|*
argument_list|>
argument_list|(
name|layout
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Redoes the layout for parentWidget() if necessary.      You should generally not need to call this because it is     automatically called at the most appropriate times. It returns     true if the layout was redone.      \sa update(), QWidget::updateGeometry() */
end_comment
begin_function
DECL|function|activate
name|bool
name|QLayout
operator|::
name|activate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|enabled
operator|||
operator|!
name|parent
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|topLevel
condition|)
return|return
cast|static_cast
argument_list|<
name|QLayout
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
operator|->
name|activate
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|activated
condition|)
return|return
literal|false
return|;
name|QWidget
modifier|*
name|mw
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mw
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLayout::activate: %s \"%s\" does not have a main widget"
argument_list|,
name|QObject
operator|::
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|QObject
operator|::
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|activateRecursiveHelper
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|md
init|=
name|mw
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|uint
name|explMin
init|=
name|md
operator|->
name|extra
condition|?
name|md
operator|->
name|extra
operator|->
name|explicitMinSize
else|:
literal|0
decl_stmt|;
name|uint
name|explMax
init|=
name|md
operator|->
name|extra
condition|?
name|md
operator|->
name|extra
operator|->
name|explicitMaxSize
else|:
literal|0
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|constraint
condition|)
block|{
case|case
name|SetFixedSize
case|:
comment|// will trigger resize
name|mw
operator|->
name|setFixedSize
argument_list|(
name|totalSizeHint
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SetMinimumSize
case|:
name|mw
operator|->
name|setMinimumSize
argument_list|(
name|totalMinimumSize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SetMaximumSize
case|:
name|mw
operator|->
name|setMaximumSize
argument_list|(
name|totalMaximumSize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SetMinAndMaxSize
case|:
name|mw
operator|->
name|setMinimumSize
argument_list|(
name|totalMinimumSize
argument_list|()
argument_list|)
expr_stmt|;
name|mw
operator|->
name|setMaximumSize
argument_list|(
name|totalMaximumSize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SetDefaultConstraint
case|:
block|{
name|bool
name|widthSet
init|=
name|explMin
operator|&
name|Qt
operator|::
name|Horizontal
decl_stmt|;
name|bool
name|heightSet
init|=
name|explMin
operator|&
name|Qt
operator|::
name|Vertical
decl_stmt|;
if|if
condition|(
name|mw
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QSize
name|ms
init|=
name|totalMinimumSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|widthSet
condition|)
name|ms
operator|.
name|setWidth
argument_list|(
name|mw
operator|->
name|minimumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|heightSet
condition|)
name|ms
operator|.
name|setHeight
argument_list|(
name|mw
operator|->
name|minimumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|heightSet
operator|||
operator|!
name|widthSet
operator|)
operator|&&
name|hasHeightForWidth
argument_list|()
condition|)
block|{
name|int
name|h
init|=
name|minimumHeightForWidth
argument_list|(
name|ms
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|>
name|ms
operator|.
name|height
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|heightSet
condition|)
name|ms
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widthSet
condition|)
name|ms
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mw
operator|->
name|setMinimumSize
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|widthSet
operator|||
operator|!
name|heightSet
condition|)
block|{
name|QSize
name|ms
init|=
name|mw
operator|->
name|minimumSize
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|widthSet
condition|)
name|ms
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|heightSet
condition|)
name|ms
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mw
operator|->
name|setMinimumSize
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SetNoConstraint
case|:
break|break;
block|}
name|d
operator|->
name|doResize
argument_list|(
name|mw
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|extra
condition|)
block|{
name|md
operator|->
name|extra
operator|->
name|explicitMinSize
operator|=
name|explMin
expr_stmt|;
name|md
operator|->
name|extra
operator|->
name|explicitMaxSize
operator|=
name|explMax
expr_stmt|;
block|}
comment|// ideally only if sizeHint() or sizePolicy() has changed
name|mw
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QLayoutItem *QLayout::itemAt(int index) const      Must be implemented in subclasses to return the layout item at \a     index. If there is no such item, the function must return 0.     Items are numbered consecutively from 0. If an item is deleted, other items will be renumbered.      This function can be used to iterate over a layout. The following     code will draw a rectangle for each layout item in the layout structure of the widget.      \snippet code/src_gui_kernel_qlayout.cpp 0      \sa count(), takeAt() */
end_comment
begin_comment
comment|/*!     \fn QLayoutItem *QLayout::takeAt(int index)      Must be implemented in subclasses to remove the layout item at \a     index from the layout, and return the item. If there is no such     item, the function must do nothing and return 0.  Items are numbered     consecutively from 0. If an item is removed, other items will be     renumbered.      The following code fragment shows a safe way to remove all items     from a layout:      \snippet code/src_gui_kernel_qlayout.cpp 1      \sa itemAt(), count() */
end_comment
begin_comment
comment|/*!     \fn int *QLayout::count() const      Must be implemented in subclasses to return the number of items     in the layout.      \sa itemAt() */
end_comment
begin_comment
comment|/*!     Searches for widget \a widget in this layout (not including child     layouts).      Returns the index of \a widget, or -1 if \a widget is not found.      The default implementation iterates over all items using itemAt() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QLayout
operator|::
name|indexOf
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
init|=
name|itemAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|widget
argument_list|()
operator|==
name|widget
condition|)
return|return
name|i
return|;
operator|++
name|i
expr_stmt|;
name|item
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QLayout::SizeConstraint      The possible values are:      \value SetDefaultConstraint The main widget's minimum size is set                     to minimumSize(), unless the widget already has                     a minimum size.      \value SetFixedSize The main widget's size is set to sizeHint(); it                     cannot be resized at all.     \value SetMinimumSize  The main widget's minimum size is set to                     minimumSize(); it cannot be smaller.      \value SetMaximumSize  The main widget's maximum size is set to                     maximumSize(); it cannot be larger.      \value SetMinAndMaxSize  The main widget's minimum size is set to                     minimumSize() and its maximum size is set to                     maximumSize().      \value SetNoConstraint  The widget is not constrained.      \sa setSizeConstraint() */
end_comment
begin_comment
comment|/*!     \property QLayout::sizeConstraint     \brief the resize mode of the layout      The default mode is \l {QLayout::SetDefaultConstraint}     {SetDefaultConstraint}. */
end_comment
begin_function
DECL|function|setSizeConstraint
name|void
name|QLayout
operator|::
name|setSizeConstraint
parameter_list|(
name|SizeConstraint
name|constraint
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint
operator|==
name|d
operator|->
name|constraint
condition|)
return|return;
name|d
operator|->
name|constraint
operator|=
name|constraint
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sizeConstraint
name|QLayout
operator|::
name|SizeConstraint
name|QLayout
operator|::
name|sizeConstraint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|constraint
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the rectangle that should be covered when the geometry of     this layout is set to \a r, provided that this layout supports     setAlignment().      The result is derived from sizeHint() and expanding(). It is never     larger than \a r. */
end_comment
begin_function
DECL|function|alignmentRect
name|QRect
name|QLayout
operator|::
name|alignmentRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QSize
name|s
init|=
name|sizeHint
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|Alignment
name|a
init|=
name|alignment
argument_list|()
decl_stmt|;
comment|/*       This is a hack to obtain the real maximum size, not       QSize(QLAYOUTSIZE_MAX, QLAYOUTSIZE_MAX), the value consistently       returned by QLayoutItems that have an alignment.     */
name|QLayout
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QLayout
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|setAlignment
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QSize
name|ms
init|=
name|that
operator|->
name|maximumSize
argument_list|()
decl_stmt|;
name|that
operator|->
name|setAlignment
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Horizontal
operator|)
operator|||
operator|!
operator|(
name|a
operator|&
name|Qt
operator|::
name|AlignHorizontal_Mask
operator|)
condition|)
block|{
name|s
operator|.
name|setWidth
argument_list|(
name|qMin
argument_list|(
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|ms
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
operator|)
operator|||
operator|!
operator|(
name|a
operator|&
name|Qt
operator|::
name|AlignVertical_Mask
operator|)
condition|)
block|{
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|ms
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasHeightForWidth
argument_list|()
condition|)
block|{
name|int
name|hfw
init|=
name|heightForWidth
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|hfw
operator|<
name|s
operator|.
name|height
argument_list|()
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|hfw
argument_list|,
name|ms
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|.
name|boundedTo
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|y
operator|+=
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|s
operator|.
name|height
argument_list|()
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|a
operator|&
name|Qt
operator|::
name|AlignTop
operator|)
condition|)
name|y
operator|+=
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|s
operator|.
name|height
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
name|QWidget
modifier|*
name|parent
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|a
operator|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|parent
condition|?
name|parent
operator|->
name|layoutDirection
argument_list|()
else|:
name|QApplication
operator|::
name|layoutDirection
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|x
operator|+=
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|s
operator|.
name|width
argument_list|()
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|a
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
condition|)
name|x
operator|+=
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|s
operator|.
name|width
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the widget \a widget from the layout. After this call, it     is the caller's responsibility to give the widget a reasonable     geometry or to put the widget back into a layout.      \b{Note:} The ownership of \a widget remains the same as     when it was added.      \sa removeItem(), QWidget::setGeometry(), addWidget() */
end_comment
begin_function
DECL|function|removeWidget
name|void
name|QLayout
operator|::
name|removeWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|child
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|widget
argument_list|()
operator|==
name|widget
condition|)
block|{
operator|delete
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Removes the layout item \a item from the layout. It is the     caller's responsibility to delete the item.      Notice that \a item can be a layout (since QLayout inherits     QLayoutItem).      \sa removeWidget(), addItem() */
end_comment
begin_function
DECL|function|removeItem
name|void
name|QLayout
operator|::
name|removeItem
parameter_list|(
name|QLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|child
decl_stmt|;
while|while
condition|(
operator|(
name|child
operator|=
name|itemAt
argument_list|(
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|child
operator|==
name|item
condition|)
block|{
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Enables this layout if \a enable is true, otherwise disables it.      An enabled layout adjusts dynamically to changes; a disabled     layout acts as if it did not exist.      By default all layouts are enabled.      \sa isEnabled() */
end_comment
begin_function
DECL|function|setEnabled
name|void
name|QLayout
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|enabled
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the layout is enabled; otherwise returns false.      \sa setEnabled() */
end_comment
begin_function
DECL|function|isEnabled
name|bool
name|QLayout
operator|::
name|isEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|enabled
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a size that satisfies all size constraints on \a widget,     including heightForWidth() and that is as close as possible to \a     size. */
end_comment
begin_function
DECL|function|closestAcceptableSize
name|QSize
name|QLayout
operator|::
name|closestAcceptableSize
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|QSize
name|result
init|=
name|size
operator|.
name|boundedTo
argument_list|(
name|qSmartMaxSize
argument_list|(
name|widget
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|result
operator|.
name|expandedTo
argument_list|(
name|qSmartMinSize
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|QLayout
modifier|*
name|l
init|=
name|widget
operator|->
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|&&
name|l
operator|->
name|hasHeightForWidth
argument_list|()
operator|&&
name|result
operator|.
name|height
argument_list|()
operator|<
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|result
operator|.
name|width
argument_list|()
argument_list|)
condition|)
block|{
name|QSize
name|current
init|=
name|widget
operator|->
name|size
argument_list|()
decl_stmt|;
name|int
name|currentHfw
init|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|current
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|newHfw
init|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|result
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|height
argument_list|()
operator|<
name|currentHfw
operator|||
name|currentHfw
operator|==
name|newHfw
condition|)
block|{
comment|//handle the constant hfw case and the vertical-only case, as well as the
comment|// current-size-is-not-correct case
name|result
operator|.
name|setHeight
argument_list|(
name|newHfw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// binary search; assume hfw is decreasing ###
name|int
name|maxw
init|=
name|qMax
argument_list|(
name|widget
operator|->
name|width
argument_list|()
argument_list|,
name|result
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|maxh
init|=
name|qMax
argument_list|(
name|widget
operator|->
name|height
argument_list|()
argument_list|,
name|result
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minw
init|=
name|qMin
argument_list|(
name|widget
operator|->
name|width
argument_list|()
argument_list|,
name|result
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minh
init|=
name|qMin
argument_list|(
name|widget
operator|->
name|height
argument_list|()
argument_list|,
name|result
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minhfw
init|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|minw
argument_list|)
decl_stmt|;
name|int
name|maxhfw
init|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|maxw
argument_list|)
decl_stmt|;
while|while
condition|(
name|minw
operator|<
name|maxw
condition|)
block|{
if|if
condition|(
name|minhfw
operator|>
name|maxh
condition|)
block|{
comment|//assume decreasing
name|minw
operator|=
name|maxw
operator|-
operator|(
name|maxw
operator|-
name|minw
operator|)
operator|/
literal|2
expr_stmt|;
name|minhfw
operator|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|minw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxhfw
operator|<
name|minh
condition|)
block|{
comment|//assume decreasing
name|maxw
operator|=
name|minw
operator|+
operator|(
name|maxw
operator|-
name|minw
operator|)
operator|/
literal|2
expr_stmt|;
name|maxhfw
operator|=
name|l
operator|->
name|minimumHeightForWidth
argument_list|(
name|maxw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|result
operator|=
name|result
operator|.
name|expandedTo
argument_list|(
name|QSize
argument_list|(
name|minw
argument_list|,
name|minhfw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|setControlType
name|void
name|QSizePolicy
operator|::
name|setControlType
parameter_list|(
name|ControlType
name|type
parameter_list|)
block|{
comment|/*         The control type is a flag type, with values 0x1, 0x2, 0x4, 0x8, 0x10,         etc. In memory, we pack it onto the available bits (CTSize) in         setControlType(), and unpack it here.          Example:              0x00000001 maps to 0             0x00000002 maps to 1             0x00000004 maps to 2             0x00000008 maps to 3             etc.     */
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|type
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
condition|)
block|{
name|bits
operator|.
name|ctype
operator|=
name|i
expr_stmt|;
return|return;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|controlType
name|QSizePolicy
operator|::
name|ControlType
name|QSizePolicy
operator|::
name|controlType
parameter_list|()
specifier|const
block|{
return|return
name|QSizePolicy
operator|::
name|ControlType
argument_list|(
literal|1
operator|<<
name|bits
operator|.
name|ctype
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QSizePolicy     \since 4.2      Writes the size \a policy to the data stream \a stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QSizePolicy
modifier|&
name|policy
parameter_list|)
block|{
comment|// The order here is for historical reasons. (compatibility with Qt4)
name|quint32
name|data
init|=
operator|(
name|policy
operator|.
name|bits
operator|.
name|horPolicy
operator||
comment|// [0, 3]
name|policy
operator|.
name|bits
operator|.
name|verPolicy
operator|<<
literal|4
operator||
comment|// [4, 7]
name|policy
operator|.
name|bits
operator|.
name|hfw
operator|<<
literal|8
operator||
comment|// [8]
name|policy
operator|.
name|bits
operator|.
name|ctype
operator|<<
literal|9
operator||
comment|// [9, 13]
name|policy
operator|.
name|bits
operator|.
name|wfh
operator|<<
literal|14
operator||
comment|// [14]
comment|//policy.bits.padding<< 15 |     // [15]
name|policy
operator|.
name|bits
operator|.
name|verStretch
operator|<<
literal|16
operator||
comment|// [16, 23]
name|policy
operator|.
name|bits
operator|.
name|horStretch
operator|<<
literal|24
operator|)
decl_stmt|;
comment|// [24, 31]
return|return
name|stream
operator|<<
name|data
return|;
block|}
end_function
begin_define
DECL|macro|VALUE_OF_BITS
define|#
directive|define
name|VALUE_OF_BITS
parameter_list|(
name|data
parameter_list|,
name|bitstart
parameter_list|,
name|bitcount
parameter_list|)
value|((data>> bitstart)& ((1<< bitcount) -1))
end_define
begin_comment
comment|/*!     \relates QSizePolicy     \since 4.2      Reads the size \a policy from the data stream \a stream.      \sa{Serializing Qt Data Types}{Format of the QDataStream operators} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QSizePolicy
modifier|&
name|policy
parameter_list|)
block|{
name|quint32
name|data
decl_stmt|;
name|stream
operator|>>
name|data
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|horPolicy
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|verPolicy
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|hfw
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|ctype
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|9
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|wfh
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|14
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|padding
operator|=
literal|0
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|verStretch
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|policy
operator|.
name|bits
operator|.
name|horStretch
operator|=
name|VALUE_OF_BITS
argument_list|(
name|data
argument_list|,
literal|24
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
