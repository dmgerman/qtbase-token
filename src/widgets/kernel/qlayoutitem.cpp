begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qlayoutengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qmenubar.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbar.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|fromLayoutItemRect
specifier|inline
specifier|static
name|QRect
name|fromLayoutItemRect
parameter_list|(
name|QWidgetPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
return|return
name|rect
operator|.
name|adjusted
argument_list|(
name|priv
operator|->
name|leftLayoutItemMargin
argument_list|,
name|priv
operator|->
name|topLayoutItemMargin
argument_list|,
operator|-
name|priv
operator|->
name|rightLayoutItemMargin
argument_list|,
operator|-
name|priv
operator|->
name|bottomLayoutItemMargin
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fromLayoutItemSize
specifier|inline
specifier|static
name|QSize
name|fromLayoutItemSize
parameter_list|(
name|QWidgetPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
return|return
name|fromLayoutItemRect
argument_list|(
name|priv
argument_list|,
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|toLayoutItemRect
specifier|inline
specifier|static
name|QRect
name|toLayoutItemRect
parameter_list|(
name|QWidgetPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
return|return
name|rect
operator|.
name|adjusted
argument_list|(
operator|-
name|priv
operator|->
name|leftLayoutItemMargin
argument_list|,
operator|-
name|priv
operator|->
name|topLayoutItemMargin
argument_list|,
name|priv
operator|->
name|rightLayoutItemMargin
argument_list|,
name|priv
operator|->
name|bottomLayoutItemMargin
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toLayoutItemSize
specifier|inline
specifier|static
name|QSize
name|toLayoutItemSize
parameter_list|(
name|QWidgetPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
return|return
name|toLayoutItemRect
argument_list|(
name|priv
argument_list|,
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    Returns a QVariant storing this QSizePolicy. */
end_comment
begin_function
DECL|function|operator QVariant
name|QSizePolicy
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|SizePolicy
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QLayoutItem     \brief The QLayoutItem class provides an abstract item that a     QLayout manipulates.      \ingroup geomanagement     \inmodule QtWidgets      This is used by custom layouts.      Pure virtual functions are provided to return information about     the layout, including, sizeHint(), minimumSize(), maximumSize()     and expanding().      The layout's geometry can be set and retrieved with setGeometry()     and geometry(), and its alignment with setAlignment() and     alignment().      isEmpty() returns whether the layout item is empty. If the     concrete item is a QWidget, it can be retrieved using widget().     Similarly for layout() and spacerItem().      Some layouts have width and height interdependencies. These can     be expressed using hasHeightForWidth(), heightForWidth(), and     minimumHeightForWidth(). For more explanation see the \e{Qt     Quarterly} article     \l{http://qt.nokia.com/doc/qq/qq04-height-for-width.html}{Trading     Height for Width}.      \sa QLayout */
end_comment
begin_comment
comment|/*!     \class QSpacerItem     \ingroup geomanagement     \brief The QSpacerItem class provides blank space in a layout.      \inmodule QtWidgets      Normally, you don't need to use this class directly. Qt's     built-in layout managers provide the following functions for     manipulating empty space in layouts:      \table     \header \li Class             \li Functions     \row    \li QHBoxLayout             \li \l{QBoxLayout::addSpacing()}{addSpacing()},                \l{QBoxLayout::addStretch()}{addStretch()},                \l{QBoxLayout::insertSpacing()}{insertSpacing()},                \l{QBoxLayout::insertStretch()}{insertStretch()}     \row    \li QGridLayout             \li \l{QGridLayout::setRowMinimumHeight()}{setRowMinimumHeight()},                \l{QGridLayout::setRowStretch()}{setRowStretch()},                \l{QGridLayout::setColumnMinimumWidth()}{setColumnMinimumWidth()},                \l{QGridLayout::setColumnStretch()}{setColumnStretch()}     \endtable      \sa QLayout, QWidgetItem, QLayoutItem::spacerItem() */
end_comment
begin_comment
comment|/*!     \class QWidgetItem     \ingroup geomanagement     \brief The QWidgetItem class is a layout item that represents a widget.      \inmodule QtWidgets       Normally, you don't need to use this class directly. Qt's     built-in layout managers provide the following functions for     manipulating widgets in layouts:      \table     \header \li Class             \li Functions     \row    \li QBoxLayout             \li \l{QBoxLayout::addWidget()}{addWidget()},                \l{QBoxLayout::insertWidget()}{insertWidget()},                \l{QBoxLayout::setStretchFactor()}{setStretchFactor()}     \row    \li QGridLayout             \li \l{QGridLayout::addWidget()}{addWidget()}     \row    \li QStackedLayout             \li \l{QStackedLayout::addWidget()}{addWidget()},                \l{QStackedLayout::insertWidget()}{insertWidget()},                \l{QStackedLayout::currentWidget()}{currentWidget()},                \l{QStackedLayout::setCurrentWidget()}{setCurrentWidget()},                \l{QStackedLayout::widget()}{widget()}     \endtable      \sa QLayout, QSpacerItem, QLayoutItem::widget() */
end_comment
begin_comment
comment|/*!     \fn QLayoutItem::QLayoutItem(Qt::Alignment alignment)      Constructs a layout item with an \a alignment.     Not all subclasses support alignment. */
end_comment
begin_comment
comment|/*!     \fn Qt::Alignment QLayoutItem::alignment() const      Returns the alignment of this item. */
end_comment
begin_comment
comment|/*!     Sets the alignment of this item to \a alignment.      \b{Note:} Item alignment is only supported by QLayoutItem subclasses     where it would have a visual effect. Except for QSpacerItem, which provides     blank space for layouts, all public Qt classes that inherit QLayoutItem     support item alignment. */
end_comment
begin_function
DECL|function|setAlignment
name|void
name|QLayoutItem
operator|::
name|setAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|align
operator|=
name|alignment
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QLayoutItem::maximumSize() const      Implemented in subclasses to return the maximum size of this item. */
end_comment
begin_comment
comment|/*!     \fn QSize QLayoutItem::minimumSize() const      Implemented in subclasses to return the minimum size of this item. */
end_comment
begin_comment
comment|/*!     \fn QSize QLayoutItem::sizeHint() const      Implemented in subclasses to return the preferred size of this item. */
end_comment
begin_comment
comment|/*!     \fn Qt::Orientations QLayoutItem::expandingDirections() const      Returns whether this layout item can make use of more space than     sizeHint(). A value of Qt::Vertical or Qt::Horizontal means that     it wants to grow in only one dimension, whereas Qt::Vertical |     Qt::Horizontal means that it wants to grow in both dimensions. */
end_comment
begin_comment
comment|/*!     \fn void QLayoutItem::setGeometry(const QRect&r)      Implemented in subclasses to set this item's geometry to \a r.      \sa geometry() */
end_comment
begin_comment
comment|/*!     \fn QRect QLayoutItem::geometry() const      Returns the rectangle covered by this layout item.      \sa setGeometry() */
end_comment
begin_comment
comment|/*!     \fn virtual bool QLayoutItem::isEmpty() const      Implemented in subclasses to return whether this item is empty,     i.e. whether it contains any widgets. */
end_comment
begin_comment
comment|/*!     \fn QSpacerItem::QSpacerItem(int w, int h, QSizePolicy::Policy hPolicy, QSizePolicy::Policy vPolicy)      Constructs a spacer item with preferred width \a w, preferred     height \a h, horizontal size policy \a hPolicy and vertical size     policy \a vPolicy.      The default values provide a gap that is able to stretch if     nothing else wants the space. */
end_comment
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QSpacerItem
name|QSpacerItem
operator|::
name|~
name|QSpacerItem
parameter_list|()
block|{}
end_destructor
begin_comment
comment|/*!     Changes this spacer item to have preferred width \a w, preferred     height \a h, horizontal size policy \a hPolicy and vertical size     policy \a vPolicy.      The default values provide a gap that is able to stretch if     nothing else wants the space.      Note that if changeSize() is called after the spacer item has been added     to a layout, it is necessary to invalidate the layout in order for the     spacer item's new size to take effect.      \sa QSpacerItem::invalidate() */
end_comment
begin_function
DECL|function|changeSize
name|void
name|QSpacerItem
operator|::
name|changeSize
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QSizePolicy
operator|::
name|Policy
name|hPolicy
parameter_list|,
name|QSizePolicy
operator|::
name|Policy
name|vPolicy
parameter_list|)
block|{
name|width
operator|=
name|w
expr_stmt|;
name|height
operator|=
name|h
expr_stmt|;
name|sizeP
operator|=
name|QSizePolicy
argument_list|(
name|hPolicy
argument_list|,
name|vPolicy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QWidgetItem::QWidgetItem(QWidget *widget)      Creates an item containing the given \a widget. */
end_comment
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QWidgetItem
name|QWidgetItem
operator|::
name|~
name|QWidgetItem
parameter_list|()
block|{}
end_destructor
begin_comment
comment|/*!     Destroys the QLayoutItem. */
end_comment
begin_destructor
DECL|function|~QLayoutItem
name|QLayoutItem
operator|::
name|~
name|QLayoutItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Invalidates any cached information in this layout item. */
end_comment
begin_function
DECL|function|invalidate
name|void
name|QLayoutItem
operator|::
name|invalidate
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     If this item is a QLayout, it is returned as a QLayout; otherwise     0 is returned. This function provides type-safe casting. */
end_comment
begin_function
DECL|function|layout
name|QLayout
modifier|*
name|QLayoutItem
operator|::
name|layout
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     If this item is a QSpacerItem, it is returned as a QSpacerItem;     otherwise 0 is returned. This function provides type-safe casting. */
end_comment
begin_function
DECL|function|spacerItem
name|QSpacerItem
modifier|*
name|QLayoutItem
operator|::
name|spacerItem
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|layout
name|QLayout
modifier|*
name|QLayout
operator|::
name|layout
parameter_list|()
block|{
return|return
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to this object. */
end_comment
begin_function
DECL|function|spacerItem
name|QSpacerItem
modifier|*
name|QSpacerItem
operator|::
name|spacerItem
parameter_list|()
block|{
return|return
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     If this item is a QWidget, it is returned as a QWidget; otherwise     0 is returned. This function provides type-safe casting. */
end_comment
begin_function
DECL|function|widget
name|QWidget
modifier|*
name|QLayoutItem
operator|::
name|widget
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget managed by this item. */
end_comment
begin_function
DECL|function|widget
name|QWidget
modifier|*
name|QWidgetItem
operator|::
name|widget
parameter_list|()
block|{
return|return
name|wid
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this layout's preferred height depends on its     width; otherwise returns false. The default implementation returns     false.      Reimplement this function in layout managers that support height     for width.      \sa heightForWidth(), QWidget::heightForWidth() */
end_comment
begin_function
DECL|function|hasHeightForWidth
name|bool
name|QLayoutItem
operator|::
name|hasHeightForWidth
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum height this widget needs for the given width,     \a w. The default implementation simply returns heightForWidth(\a     w). */
end_comment
begin_function
DECL|function|minimumHeightForWidth
name|int
name|QLayoutItem
operator|::
name|minimumHeightForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
return|return
name|heightForWidth
argument_list|(
name|w
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the preferred height for this layout item, given the width     \a w.      The default implementation returns -1, indicating that the     preferred height is independent of the width of the item. Using     the function hasHeightForWidth() will typically be much faster     than calling this function and testing for -1.      Reimplement this function in layout managers that support height     for width. A typical implementation will look like this:     \snippet code/src_gui_kernel_qlayoutitem.cpp 0      Caching is strongly recommended; without it layout will take     exponential time.      \sa hasHeightForWidth() */
end_comment
begin_function
DECL|function|heightForWidth
name|int
name|QLayoutItem
operator|::
name|heightForWidth
parameter_list|(
name|int
comment|/* w */
parameter_list|)
specifier|const
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the control type(s) for the layout item. For a     QWidgetItem, the control type comes from the widget's size     policy; for a QLayoutItem, the control types is derived from the     layout's contents.      \sa QSizePolicy::controlType() */
end_comment
begin_function
DECL|function|controlTypes
name|QSizePolicy
operator|::
name|ControlTypes
name|QLayoutItem
operator|::
name|controlTypes
parameter_list|()
specifier|const
block|{
return|return
name|QSizePolicy
operator|::
name|DefaultType
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QSpacerItem
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|rect
operator|=
name|r
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QWidgetItem
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return;
name|QRect
name|r
init|=
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|fromLayoutItemRect
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|rect
argument_list|)
else|:
name|rect
decl_stmt|;
specifier|const
name|QSize
name|widgetRectSurplus
init|=
name|r
operator|.
name|size
argument_list|()
operator|-
name|rect
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/*         For historical reasons, this code is done using widget rect         coordinates, not layout item rect coordinates. However,         QWidgetItem's sizeHint(), maximumSize(), and heightForWidth()         all work in terms of layout item rect coordinates, so we have to         add or subtract widgetRectSurplus here and there. The code could         be much simpler if we did everything using layout item rect         coordinates and did the conversion right before the call to         QWidget::setGeometry().       */
name|QSize
name|s
init|=
name|r
operator|.
name|size
argument_list|()
operator|.
name|boundedTo
argument_list|(
name|maximumSize
argument_list|()
operator|+
name|widgetRectSurplus
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|align
operator|&
operator|(
name|Qt
operator|::
name|AlignHorizontal_Mask
operator||
name|Qt
operator|::
name|AlignVertical_Mask
operator|)
condition|)
block|{
name|QSize
name|pref
argument_list|(
name|sizeHint
argument_list|()
argument_list|)
decl_stmt|;
name|QSizePolicy
name|sp
init|=
name|wid
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|sp
operator|.
name|horizontalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|pref
operator|.
name|setWidth
argument_list|(
name|wid
operator|->
name|sizeHint
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|wid
operator|->
name|minimumSize
argument_list|()
argument_list|)
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|.
name|verticalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|pref
operator|.
name|setHeight
argument_list|(
name|wid
operator|->
name|sizeHint
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|wid
operator|->
name|minimumSize
argument_list|()
argument_list|)
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|pref
operator|+=
name|widgetRectSurplus
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignHorizontal_Mask
condition|)
name|s
operator|.
name|setWidth
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|pref
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignVertical_Mask
condition|)
block|{
if|if
condition|(
name|hasHeightForWidth
argument_list|()
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|heightForWidth
argument_list|(
name|s
operator|.
name|width
argument_list|()
operator|-
name|widgetRectSurplus
operator|.
name|width
argument_list|()
argument_list|)
operator|+
name|widgetRectSurplus
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|pref
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Qt
operator|::
name|Alignment
name|alignHoriz
init|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|wid
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|align
argument_list|)
decl_stmt|;
if|if
condition|(
name|alignHoriz
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|x
operator|=
name|x
operator|+
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|s
operator|.
name|width
argument_list|()
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|alignHoriz
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
condition|)
name|x
operator|=
name|x
operator|+
operator|(
name|r
operator|.
name|width
argument_list|()
operator|-
name|s
operator|.
name|width
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|y
operator|=
name|y
operator|+
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|s
operator|.
name|height
argument_list|()
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|align
operator|&
name|Qt
operator|::
name|AlignTop
operator|)
condition|)
name|y
operator|=
name|y
operator|+
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|s
operator|.
name|height
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
name|wid
operator|->
name|setGeometry
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|geometry
name|QRect
name|QSpacerItem
operator|::
name|geometry
parameter_list|()
specifier|const
block|{
return|return
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|geometry
name|QRect
name|QWidgetItem
operator|::
name|geometry
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|toLayoutItemRect
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|wid
operator|->
name|geometry
argument_list|()
argument_list|)
else|:
name|wid
operator|->
name|geometry
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hasHeightForWidth
name|bool
name|QWidgetItem
operator|::
name|hasHeightForWidth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|wid
operator|->
name|hasHeightForWidth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|heightForWidth
name|int
name|QWidgetItem
operator|::
name|heightForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|w
operator|=
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|fromLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|QSize
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|width
argument_list|()
else|:
name|w
expr_stmt|;
name|int
name|hfw
decl_stmt|;
if|if
condition|(
name|wid
operator|->
name|layout
argument_list|()
condition|)
name|hfw
operator|=
name|wid
operator|->
name|layout
argument_list|()
operator|->
name|totalHeightForWidth
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|hfw
operator|=
name|wid
operator|->
name|heightForWidth
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfw
operator|>
name|wid
operator|->
name|maximumHeight
argument_list|()
condition|)
name|hfw
operator|=
name|wid
operator|->
name|maximumHeight
argument_list|()
expr_stmt|;
if|if
condition|(
name|hfw
operator|<
name|wid
operator|->
name|minimumHeight
argument_list|()
condition|)
name|hfw
operator|=
name|wid
operator|->
name|minimumHeight
argument_list|()
expr_stmt|;
name|hfw
operator|=
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|QSize
argument_list|(
literal|0
argument_list|,
name|hfw
argument_list|)
argument_list|)
operator|.
name|height
argument_list|()
else|:
name|hfw
expr_stmt|;
if|if
condition|(
name|hfw
operator|<
literal|0
condition|)
name|hfw
operator|=
literal|0
expr_stmt|;
return|return
name|hfw
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|expandingDirections
name|Qt
operator|::
name|Orientations
name|QSpacerItem
operator|::
name|expandingDirections
parameter_list|()
specifier|const
block|{
return|return
name|sizeP
operator|.
name|expandingDirections
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|expandingDirections
name|Qt
operator|::
name|Orientations
name|QWidgetItem
operator|::
name|expandingDirections
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|Qt
operator|::
name|Orientations
argument_list|(
literal|0
argument_list|)
return|;
name|Qt
operator|::
name|Orientations
name|e
init|=
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|expandingDirections
argument_list|()
decl_stmt|;
comment|/*       If the layout is expanding, we make the widget expanding, even if       its own size policy isn't expanding.     */
if|if
condition|(
name|wid
operator|->
name|layout
argument_list|()
condition|)
block|{
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|horizontalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|GrowFlag
operator|&&
operator|(
name|wid
operator|->
name|layout
argument_list|()
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Horizontal
operator|)
condition|)
name|e
operator||=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|verticalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|GrowFlag
operator|&&
operator|(
name|wid
operator|->
name|layout
argument_list|()
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
operator|)
condition|)
name|e
operator||=
name|Qt
operator|::
name|Vertical
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignHorizontal_Mask
condition|)
name|e
operator|&=
operator|~
name|Qt
operator|::
name|Horizontal
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignVertical_Mask
condition|)
name|e
operator|&=
operator|~
name|Qt
operator|::
name|Vertical
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|minimumSize
name|QSize
name|QSpacerItem
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
name|sizeP
operator|.
name|horizontalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|ShrinkFlag
condition|?
literal|0
else|:
name|width
argument_list|,
name|sizeP
operator|.
name|verticalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|ShrinkFlag
condition|?
literal|0
else|:
name|height
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|minimumSize
name|QSize
name|QWidgetItem
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|qSmartMinSize
argument_list|(
name|this
argument_list|)
argument_list|)
else|:
name|qSmartMinSize
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|maximumSize
name|QSize
name|QSpacerItem
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
name|sizeP
operator|.
name|horizontalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|GrowFlag
condition|?
name|QLAYOUTSIZE_MAX
else|:
name|width
argument_list|,
name|sizeP
operator|.
name|verticalPolicy
argument_list|()
operator|&
name|QSizePolicy
operator|::
name|GrowFlag
condition|?
name|QLAYOUTSIZE_MAX
else|:
name|height
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|maximumSize
name|QSize
name|QWidgetItem
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|qSmartMaxSize
argument_list|(
name|this
argument_list|,
name|align
argument_list|)
argument_list|)
else|:
name|qSmartMaxSize
argument_list|(
name|this
argument_list|,
name|align
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QSpacerItem
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QWidgetItem
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|QSize
name|s
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|=
name|wid
operator|->
name|sizeHint
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|wid
operator|->
name|minimumSizeHint
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|.
name|boundedTo
argument_list|(
name|wid
operator|->
name|maximumSize
argument_list|()
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|wid
operator|->
name|minimumSize
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|=
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|s
argument_list|)
else|:
name|s
expr_stmt|;
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|horizontalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|s
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|verticalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|s
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QSpacerItem
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the widget is hidden; otherwise returns false.      \sa QWidget::isHidden() */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QWidgetItem
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|wid
operator|->
name|isHidden
argument_list|()
operator|||
name|wid
operator|->
name|isWindow
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the control type associated with the widget for which     this size policy applies.      \sa QSizePolicy::controlType()  */
end_comment
begin_function
DECL|function|controlTypes
name|QSizePolicy
operator|::
name|ControlTypes
name|QWidgetItem
operator|::
name|controlTypes
parameter_list|()
specifier|const
block|{
return|return
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|controlType
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QWidgetItemV2     \internal */
end_comment
begin_function
DECL|function|useSizeCache
specifier|inline
name|bool
name|QWidgetItemV2
operator|::
name|useSizeCache
parameter_list|()
specifier|const
block|{
return|return
name|wid
operator|->
name|d_func
argument_list|()
operator|->
name|widgetItem
operator|==
name|this
return|;
block|}
end_function
begin_function
DECL|function|updateCacheIfNecessary
name|void
name|QWidgetItemV2
operator|::
name|updateCacheIfNecessary
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|q_cachedMinimumSize
operator|.
name|width
argument_list|()
operator|!=
name|Dirty
condition|)
return|return;
specifier|const
name|QSize
name|sizeHint
argument_list|(
name|wid
operator|->
name|sizeHint
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|minimumSizeHint
argument_list|(
name|wid
operator|->
name|minimumSizeHint
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|minimumSize
argument_list|(
name|wid
operator|->
name|minimumSize
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|maximumSize
argument_list|(
name|wid
operator|->
name|maximumSize
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QSizePolicy
name|sizePolicy
argument_list|(
name|wid
operator|->
name|sizePolicy
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|expandedSizeHint
argument_list|(
name|sizeHint
operator|.
name|expandedTo
argument_list|(
name|minimumSizeHint
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|smartMinSize
argument_list|(
name|qSmartMinSize
argument_list|(
name|sizeHint
argument_list|,
name|minimumSizeHint
argument_list|,
name|minimumSize
argument_list|,
name|maximumSize
argument_list|,
name|sizePolicy
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|smartMaxSize
argument_list|(
name|qSmartMaxSize
argument_list|(
name|expandedSizeHint
argument_list|,
name|minimumSize
argument_list|,
name|maximumSize
argument_list|,
name|sizePolicy
argument_list|,
name|align
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|useLayoutItemRect
init|=
operator|!
name|wid
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_LayoutUsesWidgetRect
argument_list|)
decl_stmt|;
name|q_cachedMinimumSize
operator|=
name|useLayoutItemRect
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|smartMinSize
argument_list|)
else|:
name|smartMinSize
expr_stmt|;
name|q_cachedSizeHint
operator|=
name|expandedSizeHint
expr_stmt|;
name|q_cachedSizeHint
operator|=
name|q_cachedSizeHint
operator|.
name|boundedTo
argument_list|(
name|maximumSize
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|minimumSize
argument_list|)
expr_stmt|;
name|q_cachedSizeHint
operator|=
name|useLayoutItemRect
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|q_cachedSizeHint
argument_list|)
else|:
name|q_cachedSizeHint
expr_stmt|;
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|horizontalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|q_cachedSizeHint
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wid
operator|->
name|sizePolicy
argument_list|()
operator|.
name|verticalPolicy
argument_list|()
operator|==
name|QSizePolicy
operator|::
name|Ignored
condition|)
name|q_cachedSizeHint
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q_cachedMaximumSize
operator|=
name|useLayoutItemRect
condition|?
name|toLayoutItemSize
argument_list|(
name|wid
operator|->
name|d_func
argument_list|()
argument_list|,
name|smartMaxSize
argument_list|)
else|:
name|smartMaxSize
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QWidgetItemV2
name|QWidgetItemV2
operator|::
name|QWidgetItemV2
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QWidgetItem
argument_list|(
name|widget
argument_list|)
member_init_list|,
name|q_cachedMinimumSize
argument_list|(
name|Dirty
argument_list|,
name|Dirty
argument_list|)
member_init_list|,
name|q_cachedSizeHint
argument_list|(
name|Dirty
argument_list|,
name|Dirty
argument_list|)
member_init_list|,
name|q_cachedMaximumSize
argument_list|(
name|Dirty
argument_list|,
name|Dirty
argument_list|)
member_init_list|,
name|q_firstCachedHfw
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|q_hfwCacheSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
block|{
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|wid
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wd
operator|->
name|widgetItem
condition|)
name|wd
operator|->
name|widgetItem
operator|=
name|this
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWidgetItemV2
name|QWidgetItemV2
operator|::
name|~
name|QWidgetItemV2
parameter_list|()
block|{
if|if
condition|(
name|wid
condition|)
block|{
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|wid
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
operator|->
name|widgetItem
operator|==
name|this
condition|)
name|wd
operator|->
name|widgetItem
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|sizeHint
name|QSize
name|QWidgetItemV2
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|useSizeCache
argument_list|()
condition|)
block|{
name|updateCacheIfNecessary
argument_list|()
expr_stmt|;
return|return
name|q_cachedSizeHint
return|;
block|}
else|else
block|{
return|return
name|QWidgetItem
operator|::
name|sizeHint
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|minimumSize
name|QSize
name|QWidgetItemV2
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|useSizeCache
argument_list|()
condition|)
block|{
name|updateCacheIfNecessary
argument_list|()
expr_stmt|;
return|return
name|q_cachedMinimumSize
return|;
block|}
else|else
block|{
return|return
name|QWidgetItem
operator|::
name|minimumSize
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|maximumSize
name|QSize
name|QWidgetItemV2
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|useSizeCache
argument_list|()
condition|)
block|{
name|updateCacheIfNecessary
argument_list|()
expr_stmt|;
return|return
name|q_cachedMaximumSize
return|;
block|}
else|else
block|{
return|return
name|QWidgetItem
operator|::
name|maximumSize
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*     The height-for-width cache is organized as a circular buffer. The entries          q_hfwCachedHfws[q_firstCachedHfw],         ...,         q_hfwCachedHfws[(q_firstCachedHfw + q_hfwCacheSize - 1) % HfwCacheMaxSize]      contain the last cached values. When the cache is full, the first entry to     be erased is the entry before q_hfwCachedHfws[q_firstCachedHfw]. When     values are looked up, we try to move q_firstCachedHfw to point to that new     entry (unless the cache is not full, in which case it would leave the cache     in a broken state), so that the most recently used entry is also the last     to be erased. */
end_comment
begin_function
DECL|function|heightForWidth
name|int
name|QWidgetItemV2
operator|::
name|heightForWidth
parameter_list|(
name|int
name|width
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_hfwCacheSize
condition|;
operator|++
name|i
control|)
block|{
name|int
name|offset
init|=
name|q_firstCachedHfw
operator|+
name|i
decl_stmt|;
specifier|const
name|QSize
modifier|&
name|size
init|=
name|q_cachedHfws
index|[
name|offset
operator|%
name|HfwCacheMaxSize
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|.
name|width
argument_list|()
operator|==
name|width
condition|)
block|{
if|if
condition|(
name|q_hfwCacheSize
operator|==
name|HfwCacheMaxSize
condition|)
name|q_firstCachedHfw
operator|=
name|offset
expr_stmt|;
return|return
name|size
operator|.
name|height
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|q_hfwCacheSize
operator|<
name|HfwCacheMaxSize
condition|)
operator|++
name|q_hfwCacheSize
expr_stmt|;
name|q_firstCachedHfw
operator|=
operator|(
name|q_firstCachedHfw
operator|+
name|HfwCacheMaxSize
operator|-
literal|1
operator|)
operator|%
name|HfwCacheMaxSize
expr_stmt|;
name|int
name|height
init|=
name|QWidgetItem
operator|::
name|heightForWidth
argument_list|(
name|width
argument_list|)
decl_stmt|;
name|q_cachedHfws
index|[
name|q_firstCachedHfw
index|]
operator|=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|height
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QSizePolicy
modifier|&
name|p
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QSizePolicy(horizontalPolicy = "
operator|<<
name|p
operator|.
name|horizontalPolicy
argument_list|()
operator|<<
literal|", verticalPolicy = "
operator|<<
name|p
operator|.
name|verticalPolicy
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
