begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qopenglwidget.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLContext>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLFramebufferObject>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOffscreenSurface>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLFunctions>
end_include
begin_include
include|#
directive|include
file|<QtGui/QWindow>
end_include
begin_include
include|#
directive|include
file|<QtGui/QGuiApplication>
end_include
begin_include
include|#
directive|include
file|<QtGui/QScreen>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLPaintDevice>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpa/qplatformwindow.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopenglextensions_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopenglpaintdevice_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qopenglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/private/qwidget_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!   \class QOpenGLWidget   \inmodule QtWidgets   \since 5.4    \brief The QOpenGLWidget class is a widget for rendering OpenGL graphics.    QOpenGLWidget provides functionality for displaying OpenGL graphics   integrated into a Qt application. It is very simple to use: Make   your class inherit from it and use the subclass like any other   QWidget, except that you have the choice between using QPainter and   standard OpenGL rendering commands.    QOpenGLWidget provides three convenient virtual functions that you   can reimplement in your subclass to perform the typical OpenGL   tasks:    \list   \li paintGL() - Renders the OpenGL scene. Gets called whenever the widget   needs to be updated.   \li resizeGL() - Sets up the OpenGL viewport, projection, etc. Gets   called whenever the widget has been resized (and also when it   is shown for the first time because all newly created widgets get a   resize event automatically).   \li initializeGL() - Sets up the OpenGL resources and state. Gets called   once before the first time resizeGL() or paintGL() is called.   \endlist    If you need to trigger a repaint from places other than paintGL() (a   typical example is when using \l{QTimer}{timers} to animate scenes),   you should call the widget's update() function to schedule an update.    Your widget's OpenGL rendering context is made current when   paintGL(), resizeGL(), or initializeGL() is called. If you need to   call the standard OpenGL API functions from other places (e.g. in   your widget's constructor or in your own paint functions), you   must call makeCurrent() first.    All rendering happens into an OpenGL framebuffer   object. makeCurrent() ensure that it is bound in the context. Keep   this in mind when creating and binding additional framebuffer   objects in the rendering code in paintGL(). Never re-bind the   framebuffer with ID 0. Instead, call defaultFramebufferObject() to   get the ID that should be bound.    QOpenGLWidget allows using different OpenGL versions and profiles   when the platform supports it. Just set the requested format via   setFormat(). Keep in mind however that having multiple QOpenGLWidget   instances in the same window requires that they all use the same   format, or at least formats that do not make the contexts   non-sharable. To overcome this issue, prefer using   QSurfaceFormat::setDefaultFormat() instead of setFormat().    \section1 Painting Techniques    As described above, subclass QOpenGLWidget to render pure 3D content in the   following way:    \list    \li Reimplement the initializeGL() and resizeGL() functions to   set up the OpenGL state and provide a perspective transformation.    \li Reimplement paintGL() to paint the 3D scene, calling only   OpenGL functions.    \endlist    It is also possible to draw 2D graphics onto a QOpenGLWidget subclass using QPainter:    \list    \li In paintGL(), instead of issuing OpenGL commands, construct a QPainter       object for use on the widget.    \li Draw primitives using QPainter's member functions.    \li Direct OpenGL commands can still be issued. However, you must make sure   these are enclosed by a call to the painter's beginNativePainting() and   endNativePainting().    \endlist    When performing drawing using QPainter only, it is also possible to perform   the painting like it is done for ordinary widgets: by reimplementing paintEvent().    \list    \li Reimplement the paintEvent() function.    \li Construct a QPainter object targeting the widget. Either pass the widget to the   constructor or the QPainter::begin() function.    \li Draw primitives using QPainter's member functions.    \li Painting finishes then the QPainter instance is destroyed. Alternatively,   call QPainter::end() explicitly.    \endlist    \section1 OpenGL Function Calls, Headers and QOpenGLFunctions    When making OpenGL function calls, it is strongly recommended to avoid calling   the functions directly. Instead, prefer using QOpenGLFunctions (when making   portable applications) or the versioned variants (for example,   QOpenGLFunctions_3_2_Core and similar, when targeting modern, desktop-only   OpenGL). This way the application will work correctly in all Qt build   configurations, including the ones that perform dynamic OpenGL implementation   loading which means applications are not directly linking to an GL   implementation and thus direct function calls are not feasible.    In paintGL() the current context is always accessible by caling   QOpenGLContext::currentContext(). From this context an already initialized,   ready-to-be-used QOpenGLFunctions instance is retrievable by calling   QOpenGLContext::functions(). An alternative to prefixing every GL call is to   inherit from QOpenGLFunctions and call   QOpenGLFunctions::initializeOpenGLFunctions() in initializeGL().    As for the OpenGL headers, note that in most cases there will be no need to   directly include any headers like GL.h. The OpenGL-related Qt headers will   include qopengl.h which will in turn include an appropriate header for the   system. This might be an OpenGL ES 3.x or 2.0 header, the highest version that   is available, or a system-provided gl.h. In addition, a copy of the extension   headers (called glext.h on some systems) is provided as part of Qt both for   OpenGL and OpenGL ES. These will get included automatically on platforms where   feasible. This means that constants and function pointer typedefs from ARB,   EXT, OES extensions are automatically available.    \section1 Code Examples    To get started, the simplest QOpenGLWidget subclass could like like the following:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 0    Alternatively, the prefixing of each and every OpenGL call can be avoided by deriving   from QOpenGLFunctions instead:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 1    To get a context compatible with a given OpenGL version or profile, or to   request depth and stencil buffers, call setFormat():    \snippet code/doc_gui_widgets_qopenglwidget.cpp 2    With OpenGL 3.0+ contexts, when portability is not important, the versioned   QOpenGLFunctions variants give easy access to all the modern OpenGL functions   available in a given version:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 3    As described above, it is simpler and more robust to set the requested format   globally so that it applies to all windows and contexts during the lifetime of   the application. Below is an example of this:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 6    \section1 Relation to QGLWidget    The legacy QtOpenGL module (classes prefixed with QGL) provides a widget   called QGLWidget. QOpenGLWidget is intended to be a modern replacement for   it. Therefore, especially in new applications, the general recommendation is   to use QOpenGLWidget.    While the API is very similar, there is an important difference between the   two: QOpenGLWidget always renders offscreen, using framebuffer   objects. QGLWidget on the other hand uses a native window and surface. The   latter causes issues when using it in complex user interfaces since, depending   on the platform, such native child widgets may have various limitations,   regarding stacking orders for example. QOpenGLWidget avoids this by not   creating a separate native window.    Due to being backed by a framebuffer object, the behavior of QOpenGLWidget is   very similar to QOpenGLWindow with the update behavior set to \c   PartialUpdateBlit or \c PartialUpdateBlend. This means that the contents are   preserved between paintGL() calls so that incremental rendering is   possible. With QGLWidget (and naturally QOpenGLWindow with the default update   behavior) this is usually not the case because swapping the buffers leaves the   back buffer with undefined contents.    \note Most applications do not need incremental rendering because they will   render everything in the view on every paint call. In this case it is   important to call glClear() as early as possible in paintGL(). This helps   mobile GPUs that use a tile-based architecture to recognize that the tile   buffer does not need to be reloaded with the framebuffer's previous   contents. Omitting the clear call can lead to significant performance drops on   such systems.    \note Avoid calling winId() on a QOpenGLWidget. This function triggers the creation of   a native window, resulting in reduced performance and possibly rendering glitches.    \section1 Differences to QGLWidget    Besides the main conceptual difference of being backed by a framebuffer object, there   are a number of smaller, internal differences between QOpenGLWidget and the older   QGLWidget:    \list    \li OpenGL state when invoking paintGL(). QOpenGLWidget sets up the viewport via   glViewport(). It does not perform any clearing.    \li Clearing when starting to paint via QPainter. Unlike regular widgets, QGLWidget   defaulted to a value of \c true for   \l{QWidget::autoFillBackground()}{autoFillBackground}. It then performed clearing to the   palette's background color every time QPainter::begin() was used. QOpenGLWidget does not   follow this: \l{QWidget::autoFillBackground()}{autoFillBackground} defaults to false,   like for any other widget. The only exception is when being used as a viewport for other   widgets like QGraphicsView. In such a case autoFillBackground will be automatically set   to true to ensure compatibility with QGLWidget-based viewports.    \endlist    \section1 Multisampling    To enable multisampling, set the number of requested samples on the   QSurfaceFormat that is passed to setFormat(). On systems that do not support   it the request may get ignored.    Multisampling support requires support for multisampled renderbuffers and   framebuffer blits. On OpenGL ES 2.0 implementations it is likely that these   will not be present. This means that multisampling will not be available. With   modern OpenGL versions and OpenGL ES 3.0 and up this is usually not a problem   anymore.    \section1 Threading    Performing offscreen rendering on worker threads, for example to generate   textures that are then used in the GUI/main thread in paintGL(), are supported   by exposing the widget's QOpenGLContext so that additional contexts sharing   with it can be created on each thread.    Drawing directly to the QOpenGLWidget's framebuffer outside the GUI/main   thread is possible by reimplementing paintEvent() to do nothing. The context's   thread affinity has to be changed via QObject::moveToThread(). After that,   makeCurrent() and doneCurrent() are usable on the worker thread. Be careful to   move the context back to the GUI/main thread afterwards.    Unlike QGLWidget, triggering a buffer swap just for the QOpenGLWidget is not   possible since there is no real, onscreen native surface for it. Instead, it   is up to the widget stack to manage composition and buffer swaps on the gui   thread. When a thread is done updating the framebuffer, call update() \b{on   the GUI/main thread} to schedule composition.    Extra care has to be taken to avoid using the framebuffer when the GUI/main   thread is performing compositing. The signals aboutToCompose() and   frameSwapped() will be emitted when the composition is starting and   ending. They are emitted on the GUI/main thread. This means that by using a   direct connection aboutToCompose() can block the GUI/main thread until the   worker thread has finished its rendering. After that, the worker thread must   perform no further rendering until the frameSwapped() signal is emitted. If   this is not acceptable, the worker thread has to implement a double buffering   mechanism. This involves drawing using an alternative render target, that is   fully controlled by the thread, e.g. an additional framebuffer object, and   blitting to the QOpenGLWidget's framebuffer at a suitable time.    \section1 Context Sharing    When multiple QOpenGLWidgets are added as children to the same top-level   widget, their contexts will share with each other. This does not apply for   QOpenGLWidget instances that belong to different windows.    This means that all QOpenGLWidgets in the same window can access each other's   sharable resources, like textures, and there is no need for an extra "global   share" context, as was the case with QGLWidget.    To set up sharing between QOpenGLWidget instances belonging to different   windows, set the Qt::AA_ShareOpenGLContexts application attribute before   instantiating QApplication. This will trigger sharing between all   QOpenGLWidget instances without any further steps.    Creating extra QOpenGLContext instances that share resources like textures   with the QOpenGLWidget's context is also possible. Simply pass the pointer   returned from context() to QOpenGLContext::setShareContext() before calling   QOpenGLContext::create(). The resulting context can also be used on a   different thread, allowing threaded generation of textures and asynchronous   texture uploads.    Note that QOpenGLWidget expects a standard conformant implementation of   resource sharing when it comes to the underlying graphics drivers. For   example, some drivers, in particular for mobile and embedded hardware, have   issues with setting up sharing between an existing context and others that are   created later. Some other drivers may behave in unexpected ways when trying to   utilize shared resources between different threads.    \section1 Resource Initialization and Cleanup    The QOpenGLWidget's associated OpenGL context is guaranteed to be current   whenever initializeGL() and paintGL() are invoked. Do not attempt to create   OpenGL resources before initializeGL() is called. For example, attempting to   compile shaders, initialize vertex buffer objects or upload texture data will   fail when done in a subclass's constructor. These operations must be deferred   to initializeGL(). Some of Qt's OpenGL helper classes, like QOpenGLBuffer or   QOpenGLVertexArrayObject, have a matching deferred behavior: they can be   instantiated without a context, but all initialization is deferred until a   create(), or similar, call. This means that they can be used as normal   (non-pointer) member variables in a QOpenGLWidget subclass, but the create()   or similar function can only be called from initializeGL(). Be aware however   that not all classes are designed like this. When in doubt, make the member   variable a pointer and create and destroy the instance dynamically in   initializeGL() and the destructor, respectively.    Releasing the resources also needs the context to be current. Therefore   destructors that perform such cleanup are expected to call makeCurrent()   before moving on to destroy any OpenGL resources or wrappers. Avoid deferred   deletion via \l{QObject::deleteLater()}{deleteLater()} or the parenting   mechanism of QObject. There is no guarantee the correct context will be   current at the time the instance in question is really destroyed.    A typical subclass will therefore often look like the following when it comes   to resource initialization and destruction:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 4    This is naturally not the only possible solution. One alternative is to use   the \l{QOpenGLContext::aboutToBeDestroyed()}{aboutToBeDestroyed()} signal of   QOpenGLContext. By connecting a slot, using direct connection, to this signal,   it is possible to perform cleanup whenever the the underlying native context   handle, or the entire QOpenGLContext instance, is going to be released. The   following snippet is in principal equivalent to the previous one:    \snippet code/doc_gui_widgets_qopenglwidget.cpp 5    \note For widgets that change their associated top-level window multiple times   during their lifetime, a combined approach is essential. Whenever the widget   or a parent of it gets reparented so that the top-level window becomes   different, the widget's associated context is destroyed and a new one is   created. This is then followed by a call to initializeGL() where all OpenGL   resources must get reinitialized. Due to this the only option to perform   proper cleanup is to connect to the context's aboutToBeDestroyed()   signal. Note that the context in question may not be the current one when the   signal gets emitted. Therefore it is good practice to call makeCurrent() in   the connected slot. Additionally, the same cleanup steps must be performed   from the derived class' destructor, since the slot connected to the signal   will not get invoked when the widget is being destroyed.    \note When Qt::AA_ShareOpenGLContexts is set, the widget's context never   changes, not even when reparenting because the widget's associated texture is   guaranteed to be accessible also from the new top-level's context.    Proper cleanup is especially important due to context sharing. Even though   each QOpenGLWidget's associated context is destroyed together with the   QOpenGLWidget, the sharable resources in that context, like textures, will   stay valid until the top-level window, in which the QOpenGLWidget lived, is   destroyed. Additionally, settings like Qt::AA_ShareOpenGLContexts and some Qt   modules may trigger an even wider scope for sharing contexts, potentially   leading to keeping the resources in question alive for the entire lifetime of   the application. Therefore the safest and most robust is always to perform   explicit cleanup for all resources and resource wrappers used in the   QOpenGLWidget.    \section1 Limitations    Putting other widgets underneath and making the QOpenGLWidget transparent will   not lead to the expected results: The widgets underneath will not be   visible. This is because in practice the QOpenGLWidget is drawn before all   other regular, non-OpenGL widgets, and so see-through type of solutions are   not feasible. Other type of layouts, like having widgets on top of the   QOpenGLWidget, will function as expected.    When absolutely necessary, this limitation can be overcome by setting the   Qt::WA_AlwaysStackOnTop attribute on the QOpenGLWidget. Be aware however that   this breaks stacking order, for example it will not be possible to have other   widgets on top of the QOpenGLWidget, so it should only be used in situations   where a semi-transparent QOpenGLWidget with other widgets visible underneath   is required.    Note that this does not apply when there are no other widgets underneath and   the intention is to have a semi-transparent window. In that case the   traditional approach of setting Qt::WA_TranslucentBackground is sufficient.    QOpenGLWidget supports multiple update behaviors, just like QOpenGLWindow. In   preserved mode the rendered content from the previous paintGL() call is   available in the next one, allowing incremental rendering. In non-preserved   mode the content is lost and paintGL() implementations are expected to redraw   everything in the view.    Before Qt 5.5 the default behavior of QOpenGLWidget was to preserve the   rendered contents between paintGL() calls. Since Qt 5.5 the default behavior   is non-preserved because this provides better performance and the majority of   applications have no need for the previous content. This also resembles the   semantics of an OpenGL-based QWindow and matches the default behavior of   QOpenGLWindow in that the color and ancillary buffers are invalidated for   each frame. To restore the preserved behavior, call setUpdateBehavior() with   \c PartialUpdate.    \section1 Alternatives    Adding a QOpenGLWidget into a window turns on OpenGL-based   compositing for the entire window.  In some special cases this may   not be ideal, and the old QGLWidget-style behavior with a separate,   native child window is desired. Desktop applications that understand   the limitations of this approach (for example when it comes to   overlaps, transparency, scroll views and MDI areas), can use   QOpenGLWindow with QWidget::createWindowContainer(). This is a   modern alternative to QGLWidget and is faster than QOpenGLWidget due   to the lack of the additional composition step. It is strongly   recommended to limit the usage of this approach to cases where there   is no other choice. Note that this option is not suitable for most   embedded and mobile platforms, and it is known to have issues on   certain desktop platforms (e.g. OS X) too. The stable,   cross-platform solution is always QOpenGLWidget.    \e{OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other   countries.}    \sa QOpenGLFunctions, QOpenGLWindow, Qt::AA_ShareOpenGLContexts, UpdateBehavior */
end_comment
begin_comment
comment|/*!     \fn void QOpenGLWidget::aboutToCompose()      This signal is emitted when the widget's top-level window is about to begin     composing the textures of its QOpenGLWidget children and the other widgets. */
end_comment
begin_comment
comment|/*!     \fn void QOpenGLWidget::frameSwapped()      This signal is emitted after the widget's top-level window has finished     composition and returned from its potentially blocking     QOpenGLContext::swapBuffers() call. */
end_comment
begin_comment
comment|/*!     \fn void QOpenGLWidget::aboutToResize()      This signal is emitted when the widget's size is changed and therefore the     framebuffer object is going to be recreated. */
end_comment
begin_comment
comment|/*!     \fn void QOpenGLWidget::resized()      This signal is emitted right after the framebuffer object has been recreated     due to resizing the widget. */
end_comment
begin_comment
comment|/*!     \enum QOpenGLWidget::UpdateBehavior     \since 5.5      This enum describes the update semantics of QOpenGLWidget.      \value NoPartialUpdate QOpenGLWidget will discard the     contents of the color buffer and the ancillary buffers after the     QOpenGLWidget is rendered to screen. This is the same behavior that can be     expected by calling QOpenGLContext::swapBuffers with a default opengl     enabled QWindow as the argument. NoPartialUpdate can have some performance     benefits on certain hardware architectures common in the mobile and     embedded space when a framebuffer object is used as the rendering target.     The framebuffer object is invalidated between frames with     glDiscardFramebufferEXT if supported or a glClear. Please see the     documentation of EXT_discard_framebuffer for more information:     https://www.khronos.org/registry/gles/extensions/EXT/EXT_discard_framebuffer.txt      \value PartialUpdate The framebuffer objects color buffer and ancillary     buffers are not invalidated between frames.      \sa updateBehavior(), setUpdateBehavior() */
end_comment
begin_class
DECL|class|QOpenGLWidgetPaintDevicePrivate
class|class
name|QOpenGLWidgetPaintDevicePrivate
super|:
specifier|public
name|QOpenGLPaintDevicePrivate
block|{
public|public:
DECL|function|QOpenGLWidgetPaintDevicePrivate
name|QOpenGLWidgetPaintDevicePrivate
parameter_list|(
name|QOpenGLWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QOpenGLPaintDevicePrivate
argument_list|(
name|QSize
argument_list|()
argument_list|)
member_init_list|,
name|w
argument_list|(
name|widget
argument_list|)
block|{ }
DECL|member|Q_DECL_OVERRIDE
name|void
name|beginPaint
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|w
name|QOpenGLWidget
modifier|*
name|w
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QOpenGLWidgetPaintDevice
class|class
name|QOpenGLWidgetPaintDevice
super|:
specifier|public
name|QOpenGLPaintDevice
block|{
public|public:
DECL|function|QOpenGLWidgetPaintDevice
name|QOpenGLWidgetPaintDevice
parameter_list|(
name|QOpenGLWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QOpenGLPaintDevice
argument_list|(
operator|*
operator|new
name|QOpenGLWidgetPaintDevicePrivate
argument_list|(
name|widget
argument_list|)
argument_list|)
block|{ }
DECL|member|Q_DECL_OVERRIDE
name|void
name|ensureActiveTarget
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
block|}
class|;
end_class
begin_class
DECL|class|QOpenGLWidgetPrivate
class|class
name|QOpenGLWidgetPrivate
super|:
specifier|public
name|QWidgetPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QOpenGLWidget
parameter_list|)
specifier|public
private|:
DECL|function|QOpenGLWidgetPrivate
name|QOpenGLWidgetPrivate
parameter_list|()
member_init_list|:
name|context
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fbo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|resolvedFbo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|surface
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|initialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|fakeHidden
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inBackingStorePaint
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|hasBeenComposed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|flushPending
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|paintDevice
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|updateBehavior
argument_list|(
name|QOpenGLWidget
operator|::
name|NoPartialUpdate
argument_list|)
block|{
name|requestedFormat
operator|=
name|QSurfaceFormat
operator|::
name|defaultFormat
argument_list|()
expr_stmt|;
block|}
DECL|function|~QOpenGLWidgetPrivate
name|~
name|QOpenGLWidgetPrivate
parameter_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
name|void
name|reset
parameter_list|()
function_decl|;
name|void
name|recreateFbo
parameter_list|()
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|GLuint
name|textureId
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
function_decl|;
name|void
name|initialize
parameter_list|()
function_decl|;
name|void
name|invokeUserPaint
parameter_list|()
function_decl|;
name|void
name|render
parameter_list|()
function_decl|;
name|void
name|invalidateFbo
parameter_list|()
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|QImage
name|grabFramebuffer
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
name|void
name|beginBackingStorePainting
parameter_list|()
name|Q_DECL_OVERRIDE
block|{
name|inBackingStorePaint
operator|=
literal|true
expr_stmt|;
block|}
name|void
name|endBackingStorePainting
parameter_list|()
name|Q_DECL_OVERRIDE
block|{
name|inBackingStorePaint
operator|=
literal|false
expr_stmt|;
block|}
DECL|member|Q_DECL_OVERRIDE
name|void
name|beginCompose
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|void
name|endCompose
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|void
name|initializeViewportFramebuffer
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|void
name|resizeViewportFramebuffer
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|Q_DECL_OVERRIDE
name|void
name|resolveSamples
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
DECL|member|context
name|QOpenGLContext
modifier|*
name|context
decl_stmt|;
DECL|member|fbo
name|QOpenGLFramebufferObject
modifier|*
name|fbo
decl_stmt|;
DECL|member|resolvedFbo
name|QOpenGLFramebufferObject
modifier|*
name|resolvedFbo
decl_stmt|;
DECL|member|surface
name|QOffscreenSurface
modifier|*
name|surface
decl_stmt|;
DECL|member|initialized
name|bool
name|initialized
decl_stmt|;
DECL|member|fakeHidden
name|bool
name|fakeHidden
decl_stmt|;
DECL|member|inBackingStorePaint
name|bool
name|inBackingStorePaint
decl_stmt|;
DECL|member|hasBeenComposed
name|bool
name|hasBeenComposed
decl_stmt|;
DECL|member|flushPending
name|bool
name|flushPending
decl_stmt|;
DECL|member|paintDevice
name|QOpenGLPaintDevice
modifier|*
name|paintDevice
decl_stmt|;
DECL|member|requestedFormat
name|QSurfaceFormat
name|requestedFormat
decl_stmt|;
DECL|member|updateBehavior
name|QOpenGLWidget
operator|::
name|UpdateBehavior
name|updateBehavior
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|beginPaint
name|void
name|QOpenGLWidgetPaintDevicePrivate
operator|::
name|beginPaint
parameter_list|()
block|{
comment|// NB! autoFillBackground is and must be false by default. Otherwise we would clear on
comment|// every QPainter begin() which is not desirable. This is only for legacy use cases,
comment|// like using QOpenGLWidget as the viewport of a graphics view, that expect clearing
comment|// with the palette's background color.
if|if
condition|(
name|w
operator|->
name|autoFillBackground
argument_list|()
condition|)
block|{
name|QOpenGLFunctions
modifier|*
name|f
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|functions
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
condition|)
block|{
name|f
operator|->
name|glClearColor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QColor
name|c
init|=
name|w
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|w
operator|->
name|backgroundRole
argument_list|()
argument_list|)
operator|.
name|color
argument_list|()
decl_stmt|;
name|float
name|alpha
init|=
name|c
operator|.
name|alphaF
argument_list|()
decl_stmt|;
name|f
operator|->
name|glClearColor
argument_list|(
name|c
operator|.
name|redF
argument_list|()
operator|*
name|alpha
argument_list|,
name|c
operator|.
name|greenF
argument_list|()
operator|*
name|alpha
argument_list|,
name|c
operator|.
name|blueF
argument_list|()
operator|*
name|alpha
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureActiveTarget
name|void
name|QOpenGLWidgetPaintDevice
operator|::
name|ensureActiveTarget
parameter_list|()
block|{
name|QOpenGLWidgetPaintDevicePrivate
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QOpenGLWidgetPaintDevicePrivate
operator|*
argument_list|>
argument_list|(
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|QOpenGLWidgetPrivate
modifier|*
name|wd
init|=
cast|static_cast
argument_list|<
name|QOpenGLWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|QWidgetPrivate
operator|::
name|get
argument_list|(
name|d
operator|->
name|w
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wd
operator|->
name|initialized
condition|)
return|return;
if|if
condition|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|!=
name|wd
operator|->
name|context
condition|)
name|d
operator|->
name|w
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
else|else
name|wd
operator|->
name|fbo
operator|->
name|bind
argument_list|()
expr_stmt|;
comment|// When used as a viewport, drawing is done via opening a QPainter on the widget
comment|// without going through paintEvent(). We will have to make sure a glFlush() is done
comment|// before the texture is accessed also in this case.
name|wd
operator|->
name|flushPending
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textureId
name|GLuint
name|QOpenGLWidgetPrivate
operator|::
name|textureId
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|q
operator|->
name|internalWinId
argument_list|()
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QOpenGLWidget cannot be used as a native child widget."
operator|<<
literal|"Consider setting Qt::AA_DontCreateNativeWidgetAncestors and Siblings."
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|resolvedFbo
condition|?
name|resolvedFbo
operator|->
name|texture
argument_list|()
else|:
operator|(
name|fbo
condition|?
name|fbo
operator|->
name|texture
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|reset
name|void
name|QOpenGLWidgetPrivate
operator|::
name|reset
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
comment|// Destroy the OpenGL resources first. These need the context to be current.
if|if
condition|(
name|initialized
condition|)
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
operator|delete
name|paintDevice
expr_stmt|;
name|paintDevice
operator|=
literal|0
expr_stmt|;
operator|delete
name|fbo
expr_stmt|;
name|fbo
operator|=
literal|0
expr_stmt|;
operator|delete
name|resolvedFbo
expr_stmt|;
name|resolvedFbo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
name|q
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
comment|// Delete the context first, then the surface. Slots connected to
comment|// the context's aboutToBeDestroyed() may still call makeCurrent()
comment|// to perform some cleanup.
operator|delete
name|context
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
operator|delete
name|surface
expr_stmt|;
name|surface
operator|=
literal|0
expr_stmt|;
name|initialized
operator|=
name|fakeHidden
operator|=
name|inBackingStorePaint
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recreateFbo
name|void
name|QOpenGLWidgetPrivate
operator|::
name|recreateFbo
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|aboutToResize
argument_list|()
emit|;
name|context
operator|->
name|makeCurrent
argument_list|(
name|surface
argument_list|)
expr_stmt|;
operator|delete
name|fbo
expr_stmt|;
name|fbo
operator|=
literal|0
expr_stmt|;
operator|delete
name|resolvedFbo
expr_stmt|;
name|resolvedFbo
operator|=
literal|0
expr_stmt|;
name|int
name|samples
init|=
name|context
operator|->
name|format
argument_list|()
operator|.
name|samples
argument_list|()
decl_stmt|;
name|QOpenGLExtensions
modifier|*
name|extfuncs
init|=
cast|static_cast
argument_list|<
name|QOpenGLExtensions
operator|*
argument_list|>
argument_list|(
name|context
operator|->
name|functions
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extfuncs
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|FramebufferMultisample
argument_list|)
condition|)
name|samples
operator|=
literal|0
expr_stmt|;
name|QOpenGLFramebufferObjectFormat
name|format
decl_stmt|;
name|format
operator|.
name|setAttachment
argument_list|(
name|QOpenGLFramebufferObject
operator|::
name|CombinedDepthStencil
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSamples
argument_list|(
name|samples
argument_list|)
expr_stmt|;
specifier|const
name|QSize
name|deviceSize
init|=
name|q
operator|->
name|size
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
decl_stmt|;
name|fbo
operator|=
operator|new
name|QOpenGLFramebufferObject
argument_list|(
name|deviceSize
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|>
literal|0
condition|)
name|resolvedFbo
operator|=
operator|new
name|QOpenGLFramebufferObject
argument_list|(
name|deviceSize
argument_list|)
expr_stmt|;
name|fbo
operator|->
name|bind
argument_list|()
expr_stmt|;
name|context
operator|->
name|functions
argument_list|()
operator|->
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
argument_list|)
expr_stmt|;
name|paintDevice
operator|->
name|setSize
argument_list|(
name|deviceSize
argument_list|)
expr_stmt|;
name|paintDevice
operator|->
name|setDevicePixelRatio
argument_list|(
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|resized
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|beginCompose
name|void
name|QOpenGLWidgetPrivate
operator|::
name|beginCompose
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushPending
condition|)
block|{
name|flushPending
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
cast|static_cast
argument_list|<
name|QOpenGLExtensions
operator|*
argument_list|>
argument_list|(
name|context
operator|->
name|functions
argument_list|()
argument_list|)
operator|->
name|flushShared
argument_list|()
expr_stmt|;
block|}
name|hasBeenComposed
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|aboutToCompose
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|endCompose
name|void
name|QOpenGLWidgetPrivate
operator|::
name|endCompose
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|frameSwapped
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|initialize
name|void
name|QOpenGLWidgetPrivate
operator|::
name|initialize
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
return|return;
comment|// Get our toplevel's context with which we will share in order to make the
comment|// texture usable by the underlying window's backingstore.
name|QWidget
modifier|*
name|tlw
init|=
name|q
operator|->
name|window
argument_list|()
decl_stmt|;
name|QOpenGLContext
modifier|*
name|shareContext
init|=
name|get
argument_list|(
name|tlw
argument_list|)
operator|->
name|shareContext
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shareContext
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLWidget: Cannot be used without a context shared with the toplevel."
argument_list|)
expr_stmt|;
return|return;
block|}
name|QScopedPointer
argument_list|<
name|QOpenGLContext
argument_list|>
name|ctx
argument_list|(
operator|new
name|QOpenGLContext
argument_list|)
decl_stmt|;
name|ctx
operator|->
name|setShareContext
argument_list|(
name|shareContext
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|setFormat
argument_list|(
name|requestedFormat
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|setScreen
argument_list|(
name|shareContext
operator|->
name|screen
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|create
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLWidget: Failed to create context"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Propagate settings that make sense only for the tlw.
name|QSurfaceFormat
name|tlwFormat
init|=
name|tlw
operator|->
name|windowHandle
argument_list|()
operator|->
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|requestedFormat
operator|.
name|swapInterval
argument_list|()
operator|!=
name|tlwFormat
operator|.
name|swapInterval
argument_list|()
condition|)
block|{
comment|// Most platforms will pick up the changed swap interval on the next
comment|// makeCurrent or swapBuffers.
name|tlwFormat
operator|.
name|setSwapInterval
argument_list|(
name|requestedFormat
operator|.
name|swapInterval
argument_list|()
argument_list|)
expr_stmt|;
name|tlw
operator|->
name|windowHandle
argument_list|()
operator|->
name|setFormat
argument_list|(
name|tlwFormat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requestedFormat
operator|.
name|swapBehavior
argument_list|()
operator|!=
name|tlwFormat
operator|.
name|swapBehavior
argument_list|()
condition|)
block|{
name|tlwFormat
operator|.
name|setSwapBehavior
argument_list|(
name|requestedFormat
operator|.
name|swapBehavior
argument_list|()
argument_list|)
expr_stmt|;
name|tlw
operator|->
name|windowHandle
argument_list|()
operator|->
name|setFormat
argument_list|(
name|tlwFormat
argument_list|)
expr_stmt|;
block|}
comment|// The top-level window's surface is not good enough since it causes way too
comment|// much trouble with regards to the QSurfaceFormat for example. So just like
comment|// in QQuickWidget, use a dedicated QOffscreenSurface.
name|surface
operator|=
operator|new
name|QOffscreenSurface
expr_stmt|;
name|surface
operator|->
name|setFormat
argument_list|(
name|ctx
operator|->
name|format
argument_list|()
argument_list|)
expr_stmt|;
name|surface
operator|->
name|setScreen
argument_list|(
name|ctx
operator|->
name|screen
argument_list|()
argument_list|)
expr_stmt|;
name|surface
operator|->
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|makeCurrent
argument_list|(
name|surface
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLWidget: Failed to make context current"
argument_list|)
expr_stmt|;
return|return;
block|}
name|paintDevice
operator|=
operator|new
name|QOpenGLWidgetPaintDevice
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|paintDevice
operator|->
name|setSize
argument_list|(
name|q
operator|->
name|size
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|paintDevice
operator|->
name|setDevicePixelRatio
argument_list|(
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|context
operator|=
name|ctx
operator|.
name|take
argument_list|()
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
name|q
operator|->
name|initializeGL
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveSamples
name|void
name|QOpenGLWidgetPrivate
operator|::
name|resolveSamples
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolvedFbo
condition|)
block|{
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|QRect
name|rect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fbo
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QOpenGLFramebufferObject
operator|::
name|blitFramebuffer
argument_list|(
name|resolvedFbo
argument_list|,
name|rect
argument_list|,
name|fbo
argument_list|,
name|rect
argument_list|)
expr_stmt|;
name|flushPending
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invokeUserPaint
name|void
name|QOpenGLWidgetPrivate
operator|::
name|invokeUserPaint
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
name|QOpenGLContext
modifier|*
name|ctx
init|=
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ctx
operator|&&
name|fbo
argument_list|)
expr_stmt|;
name|QOpenGLFunctions
modifier|*
name|f
init|=
name|ctx
operator|->
name|functions
argument_list|()
decl_stmt|;
name|QOpenGLContextPrivate
operator|::
name|get
argument_list|(
name|ctx
argument_list|)
operator|->
name|defaultFboRedirect
operator|=
name|fbo
operator|->
name|handle
argument_list|()
expr_stmt|;
name|f
operator|->
name|glViewport
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|width
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|,
name|q
operator|->
name|height
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|paintGL
argument_list|()
expr_stmt|;
name|flushPending
operator|=
literal|true
expr_stmt|;
name|QOpenGLContextPrivate
operator|::
name|get
argument_list|(
name|ctx
argument_list|)
operator|->
name|defaultFboRedirect
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|render
name|void
name|QOpenGLWidgetPrivate
operator|::
name|render
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|fakeHidden
operator|||
operator|!
name|initialized
condition|)
return|return;
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|updateBehavior
operator|==
name|QOpenGLWidget
operator|::
name|NoPartialUpdate
operator|&&
name|hasBeenComposed
condition|)
block|{
name|invalidateFbo
argument_list|()
expr_stmt|;
name|hasBeenComposed
operator|=
literal|false
expr_stmt|;
block|}
name|invokeUserPaint
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invalidateFbo
name|void
name|QOpenGLWidgetPrivate
operator|::
name|invalidateFbo
parameter_list|()
block|{
name|QOpenGLExtensions
modifier|*
name|f
init|=
cast|static_cast
argument_list|<
name|QOpenGLExtensions
operator|*
argument_list|>
argument_list|(
name|QOpenGLContext
operator|::
name|currentContext
argument_list|()
operator|->
name|functions
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|hasOpenGLExtension
argument_list|(
name|QOpenGLExtensions
operator|::
name|DiscardFramebuffer
argument_list|)
condition|)
block|{
specifier|const
name|int
name|gl_color_attachment0
init|=
literal|0x8CE0
decl_stmt|;
comment|// GL_COLOR_ATTACHMENT0
specifier|const
name|int
name|gl_depth_attachment
init|=
literal|0x8D00
decl_stmt|;
comment|// GL_DEPTH_ATTACHMENT
specifier|const
name|int
name|gl_stencil_attachment
init|=
literal|0x8D20
decl_stmt|;
comment|// GL_STENCIL_ATTACHMENT
specifier|const
name|GLenum
name|attachments
index|[]
init|=
block|{
name|gl_color_attachment0
block|,
name|gl_depth_attachment
block|,
name|gl_stencil_attachment
block|}
decl_stmt|;
name|f
operator|->
name|glDiscardFramebufferEXT
argument_list|(
name|GL_FRAMEBUFFER
argument_list|,
sizeof|sizeof
name|attachments
operator|/
sizeof|sizeof
expr|*
name|attachments
argument_list|,
name|attachments
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f
operator|->
name|glClear
argument_list|(
name|GL_COLOR_BUFFER_BIT
operator||
name|GL_DEPTH_BUFFER_BIT
operator||
name|GL_STENCIL_BUFFER_BIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|extern
name|Q_GUI_EXPORT
name|QImage
name|qt_gl_read_framebuffer
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|bool
name|alpha_format
parameter_list|,
name|bool
name|include_alpha
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|grabFramebuffer
name|QImage
name|QOpenGLWidgetPrivate
operator|::
name|grabFramebuffer
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
return|return
name|QImage
argument_list|()
return|;
name|render
argument_list|()
expr_stmt|;
name|resolveSamples
argument_list|()
expr_stmt|;
name|q
operator|->
name|makeCurrent
argument_list|()
expr_stmt|;
name|QImage
name|res
init|=
name|qt_gl_read_framebuffer
argument_list|(
name|q
operator|->
name|size
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|res
operator|.
name|setDevicePixelRatio
argument_list|(
name|q
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|initializeViewportFramebuffer
name|void
name|QOpenGLWidgetPrivate
operator|::
name|initializeViewportFramebuffer
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
comment|// Legacy behavior for compatibility with QGLWidget when used as a graphics view
comment|// viewport: enable clearing on each painter begin.
name|q
operator|->
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resizeViewportFramebuffer
name|void
name|QOpenGLWidgetPrivate
operator|::
name|resizeViewportFramebuffer
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
if|if
condition|(
operator|!
name|fbo
operator|||
name|q
operator|->
name|size
argument_list|()
operator|*
name|q
operator|->
name|devicePixelRatio
argument_list|()
operator|!=
name|fbo
operator|->
name|size
argument_list|()
condition|)
name|recreateFbo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Constructs a widget which is a child of \a parent, with widget flags set to \a f.  */
end_comment
begin_constructor
DECL|function|QOpenGLWidget
name|QOpenGLWidget
operator|::
name|QOpenGLWidget
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|(
operator|new
name|QOpenGLWidgetPrivate
operator|)
argument_list|,
name|parent
argument_list|,
name|f
argument_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|RasterGLSurface
argument_list|)
condition|)
name|d
operator|->
name|setRenderToTexture
argument_list|()
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QOpenGLWidget is not supported on this platform."
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the QOpenGLWidget instance, freeing its resources.    The QOpenGLWidget's context is made current in the destructor, allowing for   safe destruction of any child object that may need to release OpenGL   resources belonging to the context provided by this widget.    \warning if you have objects wrapping OpenGL resources (such as   QOpenGLBuffer, QOpenGLShaderProgram, etc.) as members of a OpenGLWidget   subclass, you may need to add a call to makeCurrent() in that subclass'   destructor as well. Due to the rules of C++ object destruction, those objects   will be destroyed \e{before} calling this function (but after that the   destructor of the subclass has run), therefore making the OpenGL context   current in this function happens too late for their safe disposal.    \sa makeCurrent */
end_comment
begin_destructor
DECL|function|~QOpenGLWidget
name|QOpenGLWidget
operator|::
name|~
name|QOpenGLWidget
parameter_list|()
block|{
name|makeCurrent
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   Sets this widget's update behavior to \a updateBehavior.   \since 5.5 */
end_comment
begin_function
DECL|function|setUpdateBehavior
name|void
name|QOpenGLWidget
operator|::
name|setUpdateBehavior
parameter_list|(
name|UpdateBehavior
name|updateBehavior
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateBehavior
operator|=
name|updateBehavior
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \return the update behavior of the widget.   \since 5.5 */
end_comment
begin_function
DECL|function|updateBehavior
name|QOpenGLWidget
operator|::
name|UpdateBehavior
name|QOpenGLWidget
operator|::
name|updateBehavior
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|updateBehavior
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the requested surface \a format.    When the format is not explicitly set via this function, the format returned by   QSurfaceFormat::defaultFormat() will be used. This means that when having multiple   OpenGL widgets, individual calls to this function can be replaced by one single call to   QSurfaceFormat::setDefaultFormat() before creating the first widget.    \note Requesting an alpha buffer via this function, or by setting   Qt::WA_TranslucentBackground, will not lead to the desired results when the intention is   to make other widgets beneath visible. Instead, use Qt::WA_AlwaysStackOnTop to enable   semi-transparent QOpenGLWidget instances with other widgets visible underneath. Keep in   mind however that this breaks the stacking order, so it will no longer be possible to   have other widgets on top of the QOpenGLWidget. When the intention is to have a   semi-transparent top-level window, Qt::WA_TranslucentBackground is sufficient.    \sa format(), Qt::WA_AlwaysStackOnTop, QSurfaceFormat::setDefaultFormat()  */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QOpenGLWidget
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|initialized
condition|)
block|{
name|qWarning
argument_list|(
literal|"QOpenGLWidget: Already initialized, setting the format has no effect"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|requestedFormat
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the context and surface format used by this widget and its toplevel     window.      After the widget and its toplevel have both been created, resized and shown,     this function will return the actual format of the context. This may differ     from the requested format if the request could not be fulfilled by the     platform. It is also possible to get larger color buffer sizes than     requested.      When the widget's window and the related OpenGL resources are not yet     initialized, the return value is the format that has been set via     setFormat().      \sa setFormat(), context()  */
end_comment
begin_function
DECL|function|format
name|QSurfaceFormat
name|QOpenGLWidget
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|initialized
condition|?
name|d
operator|->
name|context
operator|->
name|format
argument_list|()
else|:
name|d
operator|->
name|requestedFormat
return|;
block|}
end_function
begin_comment
comment|/*!   \return \e true if the widget and OpenGL resources, like the context, have   been successfully initialized. Note that the return value is always false   until the widget is shown. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QOpenGLWidget
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|initialized
operator|&&
name|d
operator|->
name|context
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Prepares for rendering OpenGL content for this widget by making the   corresponding context current and binding the framebuffer object in that   context.    It is not necessary to call this function in most cases, because it   is called automatically before invoking paintGL().    \sa context(), paintGL(), doneCurrent()  */
end_comment
begin_function
DECL|function|makeCurrent
name|void
name|QOpenGLWidget
operator|::
name|makeCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
return|return;
name|d
operator|->
name|context
operator|->
name|makeCurrent
argument_list|(
name|d
operator|->
name|surface
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fbo
condition|)
comment|// there may not be one if we are in reset()
name|d
operator|->
name|fbo
operator|->
name|bind
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Releases the context.    It is not necessary to call this function in most cases, since the   widget will make sure the context is bound and released properly   when invoking paintGL().  */
end_comment
begin_function
DECL|function|doneCurrent
name|void
name|QOpenGLWidget
operator|::
name|doneCurrent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
return|return;
name|d
operator|->
name|context
operator|->
name|doneCurrent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \return The QOpenGLContext used by this widget or \c 0 if not yet initialized.    \note The context and the framebuffer object used by the widget changes when   reparenting the widget via setParent().    \sa QOpenGLContext::setShareContext(), defaultFramebufferObject()  */
end_comment
begin_function
DECL|function|context
name|QOpenGLContext
modifier|*
name|QOpenGLWidget
operator|::
name|context
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|context
return|;
block|}
end_function
begin_comment
comment|/*!   \return The framebuffer object handle or \c 0 if not yet initialized.    \note The framebuffer object belongs to the context returned by context()   and may not be accessible from other contexts.    \note The context and the framebuffer object used by the widget changes when   reparenting the widget via setParent(). In addition, the framebuffer object   changes on each resize.    \sa context()  */
end_comment
begin_function
DECL|function|defaultFramebufferObject
name|GLuint
name|QOpenGLWidget
operator|::
name|defaultFramebufferObject
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fbo
condition|?
name|d
operator|->
name|fbo
operator|->
name|handle
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   This virtual function is called once before the first call to   paintGL() or resizeGL(). Reimplement it in a subclass.    This function should set up any required OpenGL resources and state.    There is no need to call makeCurrent() because this has already been   done when this function is called. Note however that the framebuffer   is not yet available at this stage, so avoid issuing draw calls from   here. Defer such calls to paintGL() instead.    \sa paintGL(), resizeGL() */
end_comment
begin_function
DECL|function|initializeGL
name|void
name|QOpenGLWidget
operator|::
name|initializeGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   This virtual function is called whenever the widget has been   resized. Reimplement it in a subclass. The new size is passed in   \a w and \a h.    There is no need to call makeCurrent() because this has already been   done when this function is called. Additionally, the framebuffer is   also bound.    \sa initializeGL(), paintGL() */
end_comment
begin_function
DECL|function|resizeGL
name|void
name|QOpenGLWidget
operator|::
name|resizeGL
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This virtual function is called whenever the widget needs to be   painted. Reimplement it in a subclass.    There is no need to call makeCurrent() because this has already   been done when this function is called.    Before invoking this function, the context and the framebuffer are   bound, and the viewport is set up by a call to glViewport(). No   other state is set and no clearing or drawing is performed by the   framework.    \sa initializeGL(), resizeGL() */
end_comment
begin_function
DECL|function|paintGL
name|void
name|QOpenGLWidget
operator|::
name|paintGL
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   Handles resize events that are passed in the \a e event parameter.   Calls the virtual function resizeGL().    \note Avoid overriding this function in derived classes. If that is not   feasible, make sure that QOpenGLWidget's implementation is invoked   too. Otherwise the underlying framebuffer object and related resources will   not get resized properly and will lead to incorrect rendering. */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QOpenGLWidget
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|size
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|fakeHidden
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|fakeHidden
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
return|return;
name|d
operator|->
name|recreateFbo
argument_list|()
expr_stmt|;
name|resizeGL
argument_list|(
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|invokeUserPaint
argument_list|()
expr_stmt|;
name|d
operator|->
name|resolveSamples
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Handles paint events.    Calling QWidget::update() will lead to sending a paint event \a e,   and thus invoking this function. (NB this is asynchronous and will   happen at some point after returning from update()). This function   will then, after some preparation, call the virtual paintGL() to   update the contents of the QOpenGLWidget's framebuffer. The widget's   top-level window will then composite the framebuffer's texture with   the rest of the window. */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QOpenGLWidget
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
return|return;
if|if
condition|(
name|updatesEnabled
argument_list|()
condition|)
name|d
operator|->
name|render
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Renders and returns a 32-bit RGB image of the framebuffer.    \note This is a potentially expensive operation because it relies on glReadPixels()   to read back the pixels. This may be slow and can stall the GPU pipeline. */
end_comment
begin_function
DECL|function|grabFramebuffer
name|QImage
name|QOpenGLWidget
operator|::
name|grabFramebuffer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|grabFramebuffer
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|metric
name|int
name|QOpenGLWidget
operator|::
name|metric
parameter_list|(
name|QPaintDevice
operator|::
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|inBackingStorePaint
condition|)
return|return
name|QWidget
operator|::
name|metric
argument_list|(
name|metric
argument_list|)
return|;
name|QWidget
modifier|*
name|tlw
init|=
name|window
argument_list|()
decl_stmt|;
name|QScreen
modifier|*
name|screen
init|=
name|tlw
operator|&&
name|tlw
operator|->
name|windowHandle
argument_list|()
condition|?
name|tlw
operator|->
name|windowHandle
argument_list|()
operator|->
name|screen
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|screen
operator|&&
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
condition|)
name|screen
operator|=
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
expr_stmt|;
specifier|const
name|float
name|dpmx
init|=
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
specifier|const
name|float
name|dpmy
init|=
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100.
operator|/
literal|2.54
decl_stmt|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmWidth
case|:
return|return
name|width
argument_list|()
return|;
case|case
name|PdmHeight
case|:
return|return
name|height
argument_list|()
return|;
case|case
name|PdmDepth
case|:
return|return
literal|32
return|;
case|case
name|PdmWidthMM
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|width
argument_list|()
operator|*
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
return|;
else|else
return|return
name|width
argument_list|()
operator|*
literal|1000
operator|/
name|dpmx
return|;
case|case
name|PdmHeightMM
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|height
argument_list|()
operator|*
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
return|;
else|else
return|return
name|height
argument_list|()
operator|*
literal|1000
operator|/
name|dpmy
return|;
case|case
name|PdmNumColors
case|:
return|return
literal|0
return|;
case|case
name|PdmDpiX
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|qRound
argument_list|(
name|screen
operator|->
name|logicalDotsPerInchX
argument_list|()
argument_list|)
return|;
else|else
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmDpiY
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|qRound
argument_list|(
name|screen
operator|->
name|logicalDotsPerInchY
argument_list|()
argument_list|)
return|;
else|else
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiX
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|qRound
argument_list|(
name|screen
operator|->
name|physicalDotsPerInchX
argument_list|()
argument_list|)
return|;
else|else
return|return
name|qRound
argument_list|(
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmPhysicalDpiY
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|qRound
argument_list|(
name|screen
operator|->
name|physicalDotsPerInchY
argument_list|()
argument_list|)
return|;
else|else
return|return
name|qRound
argument_list|(
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
case|case
name|PdmDevicePixelRatio
case|:
if|if
condition|(
name|screen
condition|)
return|return
name|screen
operator|->
name|devicePixelRatio
argument_list|()
return|;
else|else
return|return
literal|1.0
return|;
default|default:
name|qWarning
argument_list|(
literal|"QOpenGLWidget::metric(): unknown metric %d"
argument_list|,
name|metric
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|redirected
name|QPaintDevice
modifier|*
name|QOpenGLWidget
operator|::
name|redirected
parameter_list|(
name|QPoint
modifier|*
name|p
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|inBackingStorePaint
condition|)
return|return
name|QWidget
operator|::
name|redirected
argument_list|(
name|p
argument_list|)
return|;
return|return
name|d
operator|->
name|paintDevice
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QOpenGLWidget
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QOpenGLWidget
argument_list|)
expr_stmt|;
comment|// QWidget needs to "punch a hole" into the backingstore. This needs the
comment|// normal paint engine and device, not the GL one. So in this mode, behave
comment|// like a normal widget.
if|if
condition|(
name|d
operator|->
name|inBackingStorePaint
condition|)
return|return
name|QWidget
operator|::
name|paintEngine
argument_list|()
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|paintDevice
operator|->
name|paintEngine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|event
name|bool
name|QOpenGLWidget
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QOpenGLWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|WindowChangeInternal
case|:
if|if
condition|(
name|qGuiApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_ShareOpenGLContexts
argument_list|)
condition|)
break|break;
if|if
condition|(
name|d
operator|->
name|initialized
condition|)
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
comment|// FALLTHROUGH
case|case
name|QEvent
operator|::
name|Show
case|:
comment|// reparenting may not lead to a resize so reinitalize on Show too
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
operator|&&
operator|!
name|size
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|window
argument_list|()
operator|&&
name|window
argument_list|()
operator|->
name|windowHandle
argument_list|()
condition|)
block|{
name|d
operator|->
name|initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|initialized
condition|)
name|d
operator|->
name|recreateFbo
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|ScreenChangeInternal
case|:
if|if
condition|(
name|d
operator|->
name|initialized
operator|&&
name|d
operator|->
name|paintDevice
operator|->
name|devicePixelRatio
argument_list|()
operator|!=
name|devicePixelRatio
argument_list|()
condition|)
name|d
operator|->
name|recreateFbo
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
