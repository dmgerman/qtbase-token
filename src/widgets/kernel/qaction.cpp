begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qaction.h"
end_include
begin_include
include|#
directive|include
file|"qactiongroup.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACTION
end_ifndef
begin_include
include|#
directive|include
file|"qaction_p.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<private/qshortcutmap_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmenu_p.h>
end_include
begin_define
DECL|macro|QAPP_CHECK
define|#
directive|define
name|QAPP_CHECK
parameter_list|(
name|functionName
parameter_list|)
define|\
value|if (!qApp) { \         qWarning("QAction: Initialize QApplication before calling '" functionName "'."); \         return; \     }
end_define
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*   internal: guesses a descriptive text from a text suited for a menu entry  */
DECL|function|qt_strippedText
specifier|static
name|QString
name|qt_strippedText
parameter_list|(
name|QString
name|s
parameter_list|)
block|{
name|s
operator|.
name|remove
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"..."
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|.
name|size
argument_list|()
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|s
operator|.
name|size
argument_list|()
operator|&&
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|i
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|trimmed
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QActionPrivate
name|QActionPrivate
operator|::
name|QActionPrivate
parameter_list|()
member_init_list|:
name|group
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|enabled
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|forceDisabled
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|visible
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|forceInvisible
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|checkable
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|checked
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|separator
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fontSet
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|forceEnabledInSoftkeys
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|menuActionSoftkeys
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|iconVisibleInMenu
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|menuRole
argument_list|(
name|QAction
operator|::
name|TextHeuristicRole
argument_list|)
member_init_list|,
name|softKeyRole
argument_list|(
name|QAction
operator|::
name|NoSoftKey
argument_list|)
member_init_list|,
name|priority
argument_list|(
name|QAction
operator|::
name|NormalPriority
argument_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|shortcutId
operator|=
literal|0
expr_stmt|;
name|shortcutContext
operator|=
name|Qt
operator|::
name|WindowShortcut
expr_stmt|;
name|autorepeat
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QActionPrivate
name|QActionPrivate
operator|::
name|~
name|QActionPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|showStatusText
name|bool
name|QActionPrivate
operator|::
name|showStatusText
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_STATUSTIP
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|QObject
modifier|*
name|object
init|=
name|widget
condition|?
name|widget
else|:
name|parent
condition|)
block|{
name|QStatusTipEvent
name|tip
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|object
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|sendDataChanged
name|void
name|QActionPrivate
operator|::
name|sendDataChanged
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|QActionEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ActionChanged
argument_list|,
name|q
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|widgets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|widgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|graphicsWidgets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsWidget
modifier|*
name|w
init|=
name|graphicsWidgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|changed
argument_list|()
emit|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_function
DECL|function|redoGrab
name|void
name|QActionPrivate
operator|::
name|redoGrab
parameter_list|(
name|QShortcutMap
modifier|&
name|map
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortcutId
condition|)
name|map
operator|.
name|removeShortcut
argument_list|(
name|shortcutId
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortcut
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|shortcutId
operator|=
name|map
operator|.
name|addShortcut
argument_list|(
name|q
argument_list|,
name|shortcut
argument_list|,
name|shortcutContext
argument_list|,
name|qWidgetShortcutContextMatcher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
condition|)
name|map
operator|.
name|setShortcutEnabled
argument_list|(
literal|false
argument_list|,
name|shortcutId
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|autorepeat
condition|)
name|map
operator|.
name|setShortcutAutoRepeat
argument_list|(
literal|false
argument_list|,
name|shortcutId
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|redoGrabAlternate
name|void
name|QActionPrivate
operator|::
name|redoGrabAlternate
parameter_list|(
name|QShortcutMap
modifier|&
name|map
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternateShortcutIds
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
specifier|const
name|int
name|id
init|=
name|alternateShortcutIds
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|map
operator|.
name|removeShortcut
argument_list|(
name|id
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|alternateShortcutIds
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|alternateShortcuts
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternateShortcuts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QKeySequence
modifier|&
name|alternate
init|=
name|alternateShortcuts
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alternate
operator|.
name|isEmpty
argument_list|()
condition|)
name|alternateShortcutIds
operator|.
name|append
argument_list|(
name|map
operator|.
name|addShortcut
argument_list|(
name|q
argument_list|,
name|alternate
argument_list|,
name|shortcutContext
argument_list|,
name|qWidgetShortcutContextMatcher
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|alternateShortcutIds
operator|.
name|append
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternateShortcutIds
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|id
init|=
name|alternateShortcutIds
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|map
operator|.
name|setShortcutEnabled
argument_list|(
literal|false
argument_list|,
name|id
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|autorepeat
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternateShortcutIds
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|id
init|=
name|alternateShortcutIds
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|map
operator|.
name|setShortcutAutoRepeat
argument_list|(
literal|false
argument_list|,
name|id
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|setShortcutEnabled
name|void
name|QActionPrivate
operator|::
name|setShortcutEnabled
parameter_list|(
name|bool
name|enable
parameter_list|,
name|QShortcutMap
modifier|&
name|map
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortcutId
condition|)
name|map
operator|.
name|setShortcutEnabled
argument_list|(
name|enable
argument_list|,
name|shortcutId
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alternateShortcutIds
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
specifier|const
name|int
name|id
init|=
name|alternateShortcutIds
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|map
operator|.
name|setShortcutEnabled
argument_list|(
name|enable
argument_list|,
name|id
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SHORTCUT
end_comment
begin_comment
comment|/*!     \class QAction     \brief The QAction class provides an abstract user interface     action that can be inserted into widgets.      \ingroup mainwindow-classes     \inmodule QtWidgets      \omit         * parent and widget are different         * parent does not define context     \endomit      In applications many common commands can be invoked via menus,     toolbar buttons, and keyboard shortcuts. Since the user expects     each command to be performed in the same way, regardless of the     user interface used, it is useful to represent each command as     an \e action.      Actions can be added to menus and toolbars, and will     automatically keep them in sync. For example, in a word processor,     if the user presses a Bold toolbar button, the Bold menu item     will automatically be checked.      Actions can be created as independent objects, but they may     also be created during the construction of menus; the QMenu class     contains convenience functions for creating actions suitable for     use as menu items.      A QAction may contain an icon, menu text, a shortcut, status text,     "What's This?" text, and a tooltip. Most of these can be set in     the constructor. They can also be set independently with     setIcon(), setText(), setIconText(), setShortcut(),     setStatusTip(), setWhatsThis(), and setToolTip(). For menu items,     it is possible to set an individual font with setFont().      Actions are added to widgets using QWidget::addAction() or     QGraphicsWidget::addAction(). Note that an action must be added to a     widget before it can be used; this is also true when the shortcut should     be global (i.e., Qt::ApplicationShortcut as Qt::ShortcutContext).      Once a QAction has been created it should be added to the relevant     menu and toolbar, then connected to the slot which will perform     the action. For example:      \snippet mainwindows/application/mainwindow.cpp 19     \codeline     \snippet mainwindows/application/mainwindow.cpp 28     \snippet mainwindows/application/mainwindow.cpp 31      We recommend that actions are created as children of the window     they are used in. In most cases actions will be children of     the application's main window.      \sa QMenu, QToolBar, {Application Example} */
end_comment
begin_comment
comment|/*!     \fn void QAction::trigger()      This is a convenience slot that calls activate(Trigger). */
end_comment
begin_comment
comment|/*!     \fn void QAction::hover()      This is a convenience slot that calls activate(Hover). */
end_comment
begin_comment
comment|/*!     \enum QAction::MenuRole      This enum describes how an action should be moved into the application menu on Mac OS X.      \value NoRole This action should not be put into the application menu     \value TextHeuristicRole This action should be put in the application menu based on the action's text            as described in the QMenuBar documentation.     \value ApplicationSpecificRole This action should be put in the application menu with an application specific role     \value AboutQtRole This action matches handles the "About Qt" menu item.     \value AboutRole This action should be placed where the "About" menu item is in the application menu. The text of            the menu item will be set to "About<application name>". The application name is fetched from the            \c{Info.plist} file in the application's bundle (See \l{Deploying an Application on Mac OS X}).     \value PreferencesRole This action should be placed where the  "Preferences..." menu item is in the application menu.     \value QuitRole This action should be placed where the Quit menu item is in the application menu.      Setting this value only has effect on items that are in the immediate menus     of the menubar, not the submenus of those menus. For example, if you have     File menu in your menubar and the File menu has a submenu, setting the     MenuRole for the actions in that submenu have no effect. They will never be moved. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|qdoc
end_ifndef
begin_comment
comment|/*! \since 4.6      \enum QAction::SoftKeyRole      This enum describes how an action should be placed in the softkey bar. Currently this enum only     has an effect on the Symbian platform.      \value NoSoftKey This action should not be used as a softkey     \value PositiveSoftKey This action is used to describe a softkey with a positive or non-destructive            role such as Ok, Select, or Options.     \value NegativeSoftKey This action is used to describe a soft ey with a negative or destructive role            role such as Cancel, Discard, or Close.     \value SelectSoftKey This action is used to describe a role that selects a particular item or widget            in the application.      Actions with a softkey role defined are only visible in the softkey bar when the widget containing     the action has focus. If no widget currently has focus, the softkey framework will traverse up the     widget parent hierarchy looking for a widget containing softkey actions.  */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Constructs an action with \a parent. If \a parent is an action     group the action will be automatically inserted into the group. */
end_comment
begin_constructor
DECL|function|QAction
name|QAction
operator|::
name|QAction
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QActionPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|group
operator|=
name|qobject_cast
argument_list|<
name|QActionGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|addAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an action with some \a text and \a parent. If \a     parent is an action group the action will be automatically     inserted into the group.      The action uses a stripped version of \a text (e.g. "\&Menu     Option..." becomes "Menu Option") as descriptive text for     tool buttons. You can override this by setting a specific     description with setText(). The same text will be used for     tooltips unless you specify a different text using     setToolTip().  */
end_comment
begin_constructor
DECL|function|QAction
name|QAction
operator|::
name|QAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QActionPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|group
operator|=
name|qobject_cast
argument_list|<
name|QActionGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|addAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an action with an \a icon and some \a text and \a     parent. If \a parent is an action group the action will be     automatically inserted into the group.      The action uses a stripped version of \a text (e.g. "\&Menu     Option..." becomes "Menu Option") as descriptive text for     tool buttons. You can override this by setting a specific     description with setText(). The same text will be used for     tooltips unless you specify a different text using     setToolTip(). */
end_comment
begin_constructor
DECL|function|QAction
name|QAction
operator|::
name|QAction
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QActionPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|icon
operator|=
name|icon
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|group
operator|=
name|qobject_cast
argument_list|<
name|QActionGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|addAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAction
name|QAction
operator|::
name|QAction
parameter_list|(
name|QActionPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|group
operator|=
name|qobject_cast
argument_list|<
name|QActionGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|addAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Returns the parent widget. */
end_comment
begin_function
DECL|function|parentWidget
name|QWidget
modifier|*
name|QAction
operator|::
name|parentWidget
parameter_list|()
specifier|const
block|{
name|QObject
modifier|*
name|ret
init|=
name|parent
argument_list|()
decl_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|!
name|ret
operator|->
name|isWidgetType
argument_list|()
condition|)
name|ret
operator|=
name|ret
operator|->
name|parent
argument_list|()
expr_stmt|;
return|return
operator|(
name|QWidget
operator|*
operator|)
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.2   Returns a list of widgets this action has been added to.    \sa QWidget::addAction(), associatedGraphicsWidgets() */
end_comment
begin_function
DECL|function|associatedWidgets
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|QAction
operator|::
name|associatedWidgets
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|widgets
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_comment
comment|/*!   \since 4.5   Returns a list of widgets this action has been added to.    \sa QWidget::addAction(), associatedWidgets() */
end_comment
begin_function
DECL|function|associatedGraphicsWidgets
name|QList
argument_list|<
name|QGraphicsWidget
modifier|*
argument_list|>
name|QAction
operator|::
name|associatedGraphicsWidgets
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|graphicsWidgets
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_comment
comment|/*!     \property QAction::shortcut     \brief the action's primary shortcut key      Valid keycodes for this property can be found in \l Qt::Key and     \l Qt::Modifier. There is no default shortcut key. */
end_comment
begin_function
DECL|function|setShortcut
name|void
name|QAction
operator|::
name|setShortcut
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|shortcut
parameter_list|)
block|{
name|QAPP_CHECK
argument_list|(
literal|"setShortcut"
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcut
operator|==
name|shortcut
condition|)
return|return;
name|d
operator|->
name|shortcut
operator|=
name|shortcut
expr_stmt|;
name|d
operator|->
name|redoGrab
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets \a shortcuts as the list of shortcuts that trigger the     action. The first element of the list is the primary shortcut.      \sa shortcut */
end_comment
begin_function
DECL|function|setShortcuts
name|void
name|QAction
operator|::
name|setShortcuts
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QKeySequence
argument_list|>
modifier|&
name|shortcuts
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QKeySequence
argument_list|>
name|listCopy
init|=
name|shortcuts
decl_stmt|;
name|QKeySequence
name|primary
decl_stmt|;
if|if
condition|(
operator|!
name|listCopy
operator|.
name|isEmpty
argument_list|()
condition|)
name|primary
operator|=
name|listCopy
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcut
operator|==
name|primary
operator|&&
name|d
operator|->
name|alternateShortcuts
operator|==
name|listCopy
condition|)
return|return;
name|QAPP_CHECK
argument_list|(
literal|"setShortcuts"
argument_list|)
expr_stmt|;
name|d
operator|->
name|shortcut
operator|=
name|primary
expr_stmt|;
name|d
operator|->
name|alternateShortcuts
operator|=
name|listCopy
expr_stmt|;
name|d
operator|->
name|redoGrab
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|redoGrabAlternate
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets a platform dependent list of shortcuts based on the \a key.     The result of calling this function will depend on the currently running platform.     Note that more than one shortcut can assigned by this action.     If only the primary shortcut is required, use setShortcut instead.      \sa QKeySequence::keyBindings() */
end_comment
begin_function
DECL|function|setShortcuts
name|void
name|QAction
operator|::
name|setShortcuts
parameter_list|(
name|QKeySequence
operator|::
name|StandardKey
name|key
parameter_list|)
block|{
name|QList
argument_list|<
name|QKeySequence
argument_list|>
name|list
init|=
name|QKeySequence
operator|::
name|keyBindings
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|setShortcuts
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the primary shortcut.      \sa setShortcuts() */
end_comment
begin_function
DECL|function|shortcut
name|QKeySequence
name|QAction
operator|::
name|shortcut
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shortcut
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the list of shortcuts, with the primary shortcut as     the first element of the list.      \sa setShortcuts() */
end_comment
begin_function
DECL|function|shortcuts
name|QList
argument_list|<
name|QKeySequence
argument_list|>
name|QAction
operator|::
name|shortcuts
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QKeySequence
argument_list|>
name|shortcuts
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|shortcut
operator|.
name|isEmpty
argument_list|()
condition|)
name|shortcuts
operator|<<
name|d
operator|->
name|shortcut
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|alternateShortcuts
operator|.
name|isEmpty
argument_list|()
condition|)
name|shortcuts
operator|<<
name|d
operator|->
name|alternateShortcuts
expr_stmt|;
return|return
name|shortcuts
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::shortcutContext     \brief the context for the action's shortcut      Valid values for this property can be found in \l Qt::ShortcutContext.     The default value is Qt::WindowShortcut. */
end_comment
begin_function
DECL|function|setShortcutContext
name|void
name|QAction
operator|::
name|setShortcutContext
parameter_list|(
name|Qt
operator|::
name|ShortcutContext
name|context
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcutContext
operator|==
name|context
condition|)
return|return;
name|QAPP_CHECK
argument_list|(
literal|"setShortcutContext"
argument_list|)
expr_stmt|;
name|d
operator|->
name|shortcutContext
operator|=
name|context
expr_stmt|;
name|d
operator|->
name|redoGrab
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|redoGrabAlternate
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|shortcutContext
name|Qt
operator|::
name|ShortcutContext
name|QAction
operator|::
name|shortcutContext
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shortcutContext
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::autoRepeat     \brief whether the action can auto repeat     \since 4.2      If true, the action will auto repeat when the keyboard shortcut     combination is held down, provided that keyboard auto repeat is     enabled on the system.     The default value is true. */
end_comment
begin_function
DECL|function|setAutoRepeat
name|void
name|QAction
operator|::
name|setAutoRepeat
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autorepeat
operator|==
name|on
condition|)
return|return;
name|QAPP_CHECK
argument_list|(
literal|"setAutoRepeat"
argument_list|)
expr_stmt|;
name|d
operator|->
name|autorepeat
operator|=
name|on
expr_stmt|;
name|d
operator|->
name|redoGrab
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|redoGrabAlternate
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoRepeat
name|bool
name|QAction
operator|::
name|autoRepeat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autorepeat
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SHORTCUT
end_comment
begin_comment
comment|/*!     \property QAction::font     \brief the action's font      The font property is used to render the text set on the     QAction. The font will can be considered a hint as it will not be     consulted in all cases based upon application and style.      By default, this property contains the application's default font.      \sa QAction::setText(), QStyle */
end_comment
begin_function
DECL|function|setFont
name|void
name|QAction
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|font
operator|==
name|font
condition|)
return|return;
name|d
operator|->
name|fontSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|font
name|QFont
name|QAction
operator|::
name|font
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|font
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and frees allocated resources. */
end_comment
begin_destructor
DECL|function|~QAction
name|QAction
operator|::
name|~
name|QAction
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|widgets
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|d
operator|->
name|widgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|w
operator|->
name|removeAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|graphicsWidgets
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QGraphicsWidget
modifier|*
name|w
init|=
name|d
operator|->
name|graphicsWidgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|w
operator|->
name|removeAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|removeAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|d
operator|->
name|shortcutId
operator|&&
name|qApp
condition|)
block|{
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|removeShortcut
argument_list|(
name|d
operator|->
name|shortcutId
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|alternateShortcutIds
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|id
init|=
name|d
operator|->
name|alternateShortcutIds
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|removeShortcut
argument_list|(
name|id
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!   Sets this action group to \a group. The action will be automatically   added to the group's list of actions.    Actions within the group will be mutually exclusive.    \sa QActionGroup, QAction::actionGroup() */
end_comment
begin_function
DECL|function|setActionGroup
name|void
name|QAction
operator|::
name|setActionGroup
parameter_list|(
name|QActionGroup
modifier|*
name|group
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|d
operator|->
name|group
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|removeAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|group
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|group
condition|)
name|group
operator|->
name|addAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the action group for this action. If no action group manages   this action then 0 will be returned.    \sa QActionGroup, QAction::setActionGroup() */
end_comment
begin_function
DECL|function|actionGroup
name|QActionGroup
modifier|*
name|QAction
operator|::
name|actionGroup
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|group
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::icon     \brief the action's icon      In toolbars, the icon is used as the tool button icon; in menus,     it is displayed to the left of the menu text. There is no default     icon.      If a null icon (QIcon::isNull() is passed into this function,     the icon of the action is cleared. */
end_comment
begin_function
DECL|function|setIcon
name|void
name|QAction
operator|::
name|setIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|icon
operator|=
name|icon
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|icon
name|QIcon
name|QAction
operator|::
name|icon
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|icon
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MENU
end_ifndef
begin_comment
comment|/*!   Returns the menu contained by this action. Actions that contain   menus can be used to create menu items with submenus, or inserted   into toolbars to create buttons with popup menus.    \sa QMenu::addAction() */
end_comment
begin_function
DECL|function|menu
name|QMenu
modifier|*
name|QAction
operator|::
name|menu
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|menu
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the menu contained by this action to the specified \a menu. */
end_comment
begin_function
DECL|function|setMenu
name|void
name|QAction
operator|::
name|setMenu
parameter_list|(
name|QMenu
modifier|*
name|menu
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|menu
condition|)
name|d
operator|->
name|menu
operator|->
name|d_func
argument_list|()
operator|->
name|setOverrideMenuAction
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//we reset the default action of any previous menu
name|d
operator|->
name|menu
operator|=
name|menu
expr_stmt|;
if|if
condition|(
name|menu
condition|)
name|menu
operator|->
name|d_func
argument_list|()
operator|->
name|setOverrideMenuAction
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MENU
end_comment
begin_comment
comment|/*!   If \a b is true then this action will be considered a separator.    How a separator is represented depends on the widget it is inserted   into. Under most circumstances the text, submenu, and icon will be   ignored for separator actions.    \sa QAction::isSeparator() */
end_comment
begin_function
DECL|function|setSeparator
name|void
name|QAction
operator|::
name|setSeparator
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|separator
operator|==
name|b
condition|)
return|return;
name|d
operator|->
name|separator
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this action is a separator action; otherwise it   returns false.    \sa QAction::setSeparator() */
end_comment
begin_function
DECL|function|isSeparator
name|bool
name|QAction
operator|::
name|isSeparator
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|separator
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::text     \brief the action's descriptive text      If the action is added to a menu, the menu option will consist of     the icon (if there is one), the text, and the shortcut (if there     is one). If the text is not explicitly set in the constructor, or     by using setText(), the action's description icon text will be     used as text. There is no default text.      \sa iconText */
end_comment
begin_function
DECL|function|setText
name|void
name|QAction
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|==
name|text
condition|)
return|return;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|text
name|QString
name|QAction
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
name|QString
name|s
init|=
name|d
operator|->
name|text
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|=
name|d
operator|->
name|iconText
expr_stmt|;
name|s
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"&&"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::iconText     \brief the action's descriptive icon text      If QToolBar::toolButtonStyle is set to a value that permits text to     be displayed, the text defined held in this property appears as a     label in the relevant tool button.      It also serves as the default text in menus and tooltips if the action     has not been defined with setText() or setToolTip(), and will     also be used in toolbar buttons if no icon has been defined using setIcon().      If the icon text is not explicitly set, the action's normal text will be     used for the icon text.      By default, this property contains an empty string.      \sa setToolTip(), setStatusTip() */
end_comment
begin_function
DECL|function|setIconText
name|void
name|QAction
operator|::
name|setIconText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconText
operator|==
name|text
condition|)
return|return;
name|d
operator|->
name|iconText
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|iconText
name|QString
name|QAction
operator|::
name|iconText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconText
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|qt_strippedText
argument_list|(
name|d
operator|->
name|text
argument_list|)
return|;
return|return
name|d
operator|->
name|iconText
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::toolTip     \brief the action's tooltip      This text is used for the tooltip. If no tooltip is specified,     the action's text is used.      By default, this property contains the action's text.      \sa setStatusTip(), setShortcut() */
end_comment
begin_function
DECL|function|setToolTip
name|void
name|QAction
operator|::
name|setToolTip
parameter_list|(
specifier|const
name|QString
modifier|&
name|tooltip
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tooltip
operator|==
name|tooltip
condition|)
return|return;
name|d
operator|->
name|tooltip
operator|=
name|tooltip
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toolTip
name|QString
name|QAction
operator|::
name|toolTip
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tooltip
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|qt_strippedText
argument_list|(
name|d
operator|->
name|text
argument_list|)
return|;
return|return
name|qt_strippedText
argument_list|(
name|d
operator|->
name|iconText
argument_list|)
return|;
block|}
return|return
name|d
operator|->
name|tooltip
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::statusTip     \brief the action's status tip      The status tip is displayed on all status bars provided by the     action's top-level parent widget.      By default, this property contains an empty string.      \sa setToolTip(), showStatusText() */
end_comment
begin_function
DECL|function|setStatusTip
name|void
name|QAction
operator|::
name|setStatusTip
parameter_list|(
specifier|const
name|QString
modifier|&
name|statustip
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|statustip
operator|==
name|statustip
condition|)
return|return;
name|d
operator|->
name|statustip
operator|=
name|statustip
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|statusTip
name|QString
name|QAction
operator|::
name|statusTip
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|statustip
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::whatsThis     \brief the action's "What's This?" help text      The "What's This?" text is used to provide a brief description of     the action. The text may contain rich text. There is no default     "What's This?" text.      \sa QWhatsThis */
end_comment
begin_function
DECL|function|setWhatsThis
name|void
name|QAction
operator|::
name|setWhatsThis
parameter_list|(
specifier|const
name|QString
modifier|&
name|whatsthis
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|whatsthis
operator|==
name|whatsthis
condition|)
return|return;
name|d
operator|->
name|whatsthis
operator|=
name|whatsthis
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|whatsThis
name|QString
name|QAction
operator|::
name|whatsThis
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|whatsthis
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QAction::Priority     \since 4.6      This enum defines priorities for actions in user interface.      \value LowPriority The action should not be prioritized in     the user interface.      \value NormalPriority      \value HighPriority The action should be prioritized in     the user interface.      \sa priority */
end_comment
begin_comment
comment|/*!     \property QAction::priority     \since 4.6      \brief the actions's priority in the user interface.      This property can be set to indicate how the action should be prioritized     in the user interface.      For instance, when toolbars have the Qt::ToolButtonTextBesideIcon     mode set, then actions with LowPriority will not show the text     labels. */
end_comment
begin_function
DECL|function|setPriority
name|void
name|QAction
operator|::
name|setPriority
parameter_list|(
name|Priority
name|priority
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|priority
operator|==
name|priority
condition|)
return|return;
name|d
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|priority
name|QAction
operator|::
name|Priority
name|QAction
operator|::
name|priority
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|priority
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::checkable     \brief whether the action is a checkable action      A checkable action is one which has an on/off state. For example,     in a word processor, a Bold toolbar button may be either on or     off. An action which is not a toggle action is a command action;     a command action is simply executed, e.g. file save.     By default, this property is false.      In some situations, the state of one toggle action should depend     on the state of others. For example, "Left Align", "Center" and     "Right Align" toggle actions are mutually exclusive. To achieve     exclusive toggling, add the relevant toggle actions to a     QActionGroup with the QActionGroup::exclusive property set to     true.      \sa QAction::setChecked() */
end_comment
begin_function
DECL|function|setCheckable
name|void
name|QAction
operator|::
name|setCheckable
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|checkable
operator|==
name|b
condition|)
return|return;
name|d
operator|->
name|checkable
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|checked
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isCheckable
name|bool
name|QAction
operator|::
name|isCheckable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|checkable
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAction::toggle()      This is a convenience function for the \l checked property.     Connect to it to change the checked state to its opposite state. */
end_comment
begin_function
DECL|function|toggle
name|void
name|QAction
operator|::
name|toggle
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|setChecked
argument_list|(
operator|!
name|d
operator|->
name|checked
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::checked     \brief whether the action is checked.      Only checkable actions can be checked.  By default, this is false     (the action is unchecked).      \sa checkable */
end_comment
begin_function
DECL|function|setChecked
name|void
name|QAction
operator|::
name|setChecked
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|checkable
operator|||
name|d
operator|->
name|checked
operator|==
name|b
condition|)
return|return;
name|QPointer
argument_list|<
name|QAction
argument_list|>
name|guard
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|d
operator|->
name|checked
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
emit|emit
name|toggled
argument_list|(
name|b
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|isChecked
name|bool
name|QAction
operator|::
name|isChecked
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|checked
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAction::setDisabled(bool b)      This is a convenience function for the \l enabled property, that     is useful for signals--slots connections. If \a b is true the     action is disabled; otherwise it is enabled. */
end_comment
begin_comment
comment|/*!     \property QAction::enabled     \brief whether the action is enabled      Disabled actions cannot be chosen by the user. They do not     disappear from menus or toolbars, but they are displayed in a way     which indicates that they are unavailable. For example, they might     be displayed using only shades of gray.      \uicontrol{What's This?} help on disabled actions is still available, provided     that the QAction::whatsThis property is set.      An action will be disabled when all widgets to which it is added     (with QWidget::addAction()) are disabled or not visible. When an     action is disabled, it is not possible to trigger it through its     shortcut.      By default, this property is true (actions are enabled).      \sa text */
end_comment
begin_function
DECL|function|setEnabled
name|void
name|QAction
operator|::
name|setEnabled
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|d
operator|->
name|enabled
operator|&&
name|b
operator|!=
name|d
operator|->
name|forceDisabled
condition|)
return|return;
name|d
operator|->
name|forceDisabled
operator|=
operator|!
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|&&
operator|(
operator|!
name|d
operator|->
name|visible
operator|||
operator|(
name|d
operator|->
name|group
operator|&&
operator|!
name|d
operator|->
name|group
operator|->
name|isEnabled
argument_list|()
operator|)
operator|)
condition|)
return|return;
name|QAPP_CHECK
argument_list|(
literal|"setEnabled"
argument_list|)
expr_stmt|;
name|d
operator|->
name|enabled
operator|=
name|b
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|d
operator|->
name|setShortcutEnabled
argument_list|(
name|b
argument_list|,
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isEnabled
name|bool
name|QAction
operator|::
name|isEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|enabled
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAction::visible     \brief whether the action can be seen (e.g. in menus and toolbars)      If \e visible is true the action can be seen (e.g. in menus and     toolbars) and chosen by the user; if \e visible is false the     action cannot be seen or chosen by the user.      Actions which are not visible are \e not grayed out; they do not     appear at all.      By default, this property is true (actions are visible). */
end_comment
begin_function
DECL|function|setVisible
name|void
name|QAction
operator|::
name|setVisible
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|d
operator|->
name|visible
operator|&&
name|b
operator|!=
name|d
operator|->
name|forceInvisible
condition|)
return|return;
name|QAPP_CHECK
argument_list|(
literal|"setVisible"
argument_list|)
expr_stmt|;
name|d
operator|->
name|forceInvisible
operator|=
operator|!
name|b
expr_stmt|;
name|d
operator|->
name|visible
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|enabled
operator|=
name|b
operator|&&
operator|!
name|d
operator|->
name|forceDisabled
operator|&&
operator|(
operator|!
name|d
operator|->
name|group
operator|||
name|d
operator|->
name|group
operator|->
name|isEnabled
argument_list|()
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|d
operator|->
name|setShortcutEnabled
argument_list|(
name|d
operator|->
name|enabled
argument_list|,
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isVisible
name|bool
name|QAction
operator|::
name|isVisible
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|visible
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
name|bool
DECL|function|event
name|QAction
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Shortcut
condition|)
block|{
name|QShortcutEvent
modifier|*
name|se
init|=
cast|static_cast
argument_list|<
name|QShortcutEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|se
operator|->
name|key
argument_list|()
operator|==
name|d_func
argument_list|()
operator|->
name|shortcut
operator|||
name|d_func
argument_list|()
operator|->
name|alternateShortcuts
operator|.
name|contains
argument_list|(
name|se
operator|->
name|key
argument_list|()
argument_list|)
argument_list|,
literal|"QAction::event"
argument_list|,
literal|"Received shortcut event from incorrect shortcut"
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|isAmbiguous
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QAction::eventFilter: Ambiguous shortcut overload: %s"
argument_list|,
name|se
operator|->
name|key
argument_list|()
operator|.
name|toString
argument_list|(
name|QKeySequence
operator|::
name|NativeText
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|activate
argument_list|(
name|Trigger
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the user data as set in QAction::setData.    \sa setData() */
end_comment
begin_function
name|QVariant
DECL|function|data
name|QAction
operator|::
name|data
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|userData
return|;
block|}
end_function
begin_comment
comment|/*!   \fn void QAction::setData(const QVariant&userData)    Sets the action's internal data to the given \a userData.    \sa data() */
end_comment
begin_function
name|void
DECL|function|setData
name|QAction
operator|::
name|setData
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
name|d
operator|->
name|userData
operator|=
name|data
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Updates the relevant status bar for the \a widget specified by sending a   QStatusTipEvent to its parent widget. Returns true if an event was sent;   otherwise returns false.    If a null widget is specified, the event is sent to the action's parent.    \sa statusTip */
end_comment
begin_function
name|bool
DECL|function|showStatusText
name|QAction
operator|::
name|showStatusText
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|showStatusText
argument_list|(
name|widget
argument_list|,
name|statusTip
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Sends the relevant signals for ActionEvent \a event.    Action based widgets use this API to cause the QAction   to emit signals as well as emitting their own. */
end_comment
begin_function
DECL|function|activate
name|void
name|QAction
operator|::
name|activate
parameter_list|(
name|ActionEvent
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|Trigger
condition|)
block|{
name|QPointer
argument_list|<
name|QObject
argument_list|>
name|guard
init|=
name|this
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|checkable
condition|)
block|{
comment|// the checked action of an exclusive group cannot be  unchecked
if|if
condition|(
name|d
operator|->
name|checked
operator|&&
operator|(
name|d
operator|->
name|group
operator|&&
name|d
operator|->
name|group
operator|->
name|isExclusive
argument_list|()
operator|&&
name|d
operator|->
name|group
operator|->
name|checkedAction
argument_list|()
operator|==
name|this
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|guard
operator|.
name|isNull
argument_list|()
condition|)
emit|emit
name|triggered
argument_list|(
literal|true
argument_list|)
emit|;
return|return;
block|}
name|setChecked
argument_list|(
operator|!
name|d
operator|->
name|checked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|guard
operator|.
name|isNull
argument_list|()
condition|)
emit|emit
name|triggered
argument_list|(
name|d
operator|->
name|checked
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|Hover
condition|)
block|{
emit|emit
name|hovered
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QAction::triggered(bool checked)      This signal is emitted when an action is activated by the user;     for example, when the user clicks a menu option, toolbar button,     or presses an action's shortcut key combination, or when trigger()     was called. Notably, it is \e not emitted when setChecked() or     toggle() is called.      If the action is checkable, \a checked is true if the action is     checked, or false if the action is unchecked.      \sa QAction::activate(), QAction::toggled(), checked */
end_comment
begin_comment
comment|/*!     \fn void QAction::toggled(bool checked)      This signal is emitted whenever a checkable action changes its     isChecked() status. This can be the result of a user interaction,     or because setChecked() was called.      \a checked is true if the action is checked, or false if the     action is unchecked.      \sa QAction::activate(), QAction::triggered(), checked */
end_comment
begin_comment
comment|/*!     \fn void QAction::hovered()      This signal is emitted when an action is highlighted by the user;     for example, when the user pauses with the cursor over a menu option,     toolbar button, or presses an action's shortcut key combination.      \sa QAction::activate() */
end_comment
begin_comment
comment|/*!     \fn void QAction::changed()      This signal is emitted when an action has changed. If you     are only interested in actions in a given widget, you can     watch for QWidget::actionEvent() sent with an     QEvent::ActionChanged.      \sa QWidget::actionEvent() */
end_comment
begin_comment
comment|/*!     \enum QAction::ActionEvent      This enum type is used when calling QAction::activate()      \value Trigger this will cause the QAction::triggered() signal to be emitted.      \value Hover this will cause the QAction::hovered() signal to be emitted. */
end_comment
begin_comment
comment|/*!     \property QAction::menuRole     \brief the action's menu role     \since 4.2      This indicates what role the action serves in the application menu on Mac     OS X. By default all action have the TextHeuristicRole, which means that     the action is added based on its text (see QMenuBar for more information).      The menu role can only be changed before the actions are put into the menu     bar in Mac OS X (usually just before the first application window is     shown). */
end_comment
begin_function
DECL|function|setMenuRole
name|void
name|QAction
operator|::
name|setMenuRole
parameter_list|(
name|MenuRole
name|menuRole
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|menuRole
operator|==
name|menuRole
condition|)
return|return;
name|d
operator|->
name|menuRole
operator|=
name|menuRole
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|menuRole
name|QAction
operator|::
name|MenuRole
name|QAction
operator|::
name|menuRole
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|menuRole
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|qdoc
end_ifndef
begin_comment
comment|/*!     \property QAction::softKeyRole     \brief the action's softkey role     \since 4.6      This indicates what type of role this action describes in the softkey framework     on platforms where such a framework is supported. Currently this is only     supported on the Symbian platform.      The softkey role can be changed any time. */
end_comment
begin_function
DECL|function|setSoftKeyRole
name|void
name|QAction
operator|::
name|setSoftKeyRole
parameter_list|(
name|SoftKeyRole
name|softKeyRole
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|softKeyRole
operator|==
name|softKeyRole
condition|)
return|return;
name|d
operator|->
name|softKeyRole
operator|=
name|softKeyRole
expr_stmt|;
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|softKeyRole
name|QAction
operator|::
name|SoftKeyRole
name|QAction
operator|::
name|softKeyRole
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|softKeyRole
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \property QAction::iconVisibleInMenu     \brief Whether or not an action should show an icon in a menu     \since 4.4      In some applications, it may make sense to have actions with icons in the     toolbar, but not in menus. If true, the icon (if valid) is shown in the menu, when it     is false, it is not shown.      The default is to follow whether the Qt::AA_DontShowIconsInMenus attribute     is set for the application. Explicitly settings this property overrides     the presence (or abscence) of the attribute.      For example:     \snippet code/src_gui_kernel_qaction.cpp 0      \sa QAction::icon, QApplication::setAttribute() */
end_comment
begin_function
DECL|function|setIconVisibleInMenu
name|void
name|QAction
operator|::
name|setIconVisibleInMenu
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconVisibleInMenu
operator|==
operator|-
literal|1
operator|||
name|visible
operator|!=
name|bool
argument_list|(
name|d
operator|->
name|iconVisibleInMenu
argument_list|)
condition|)
block|{
name|int
name|oldValue
init|=
name|d
operator|->
name|iconVisibleInMenu
decl_stmt|;
name|d
operator|->
name|iconVisibleInMenu
operator|=
name|visible
expr_stmt|;
comment|// Only send data changed if we really need to.
if|if
condition|(
name|oldValue
operator|!=
operator|-
literal|1
operator|||
operator|(
name|oldValue
operator|==
operator|-
literal|1
operator|&&
name|visible
operator|==
operator|!
name|QApplication
operator|::
name|instance
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontShowIconsInMenus
argument_list|)
operator|)
condition|)
block|{
name|d
operator|->
name|sendDataChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|isIconVisibleInMenu
name|bool
name|QAction
operator|::
name|isIconVisibleInMenu
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconVisibleInMenu
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|!
name|QApplication
operator|::
name|instance
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontShowIconsInMenus
argument_list|)
return|;
block|}
return|return
name|d
operator|->
name|iconVisibleInMenu
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qaction.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ACTION
end_comment
end_unit
