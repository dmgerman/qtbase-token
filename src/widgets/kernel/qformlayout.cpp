begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qformlayout.h"
end_include
begin_include
include|#
directive|include
file|"qlabel.h"
end_include
begin_include
include|#
directive|include
file|"qlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qlayoutengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_namespace
namespace|namespace
block|{
comment|// Fixed column matrix, stores items as [i11, i12, i21, i22...],
comment|// with FORTRAN-style index operator(r, c).
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
class|class
DECL|class|FixedColumnMatrix
name|FixedColumnMatrix
block|{
public|public:
DECL|typedef|Storage
typedef|typedef
name|QVector
argument_list|<
name|T
argument_list|>
name|Storage
typedef|;
DECL|function|FixedColumnMatrix
name|FixedColumnMatrix
parameter_list|()
block|{ }
DECL|function|clear
name|void
name|clear
parameter_list|()
block|{
name|m_storage
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|operator ()
specifier|const
name|T
modifier|&
name|operator
name|()
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|c
parameter_list|)
specifier|const
block|{
return|return
name|m_storage
index|[
name|r
operator|*
name|NumColumns
operator|+
name|c
index|]
return|;
block|}
DECL|function|operator ()
name|T
modifier|&
name|operator
name|()
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|c
parameter_list|)
block|{
return|return
name|m_storage
index|[
name|r
operator|*
name|NumColumns
operator|+
name|c
index|]
return|;
block|}
DECL|function|rowCount
name|int
name|rowCount
parameter_list|()
specifier|const
block|{
return|return
name|m_storage
operator|.
name|size
argument_list|()
operator|/
name|NumColumns
return|;
block|}
name|void
name|addRow
parameter_list|(
specifier|const
name|T
modifier|&
name|value
parameter_list|)
function_decl|;
name|void
name|insertRow
parameter_list|(
name|int
name|r
parameter_list|,
specifier|const
name|T
modifier|&
name|value
parameter_list|)
function_decl|;
name|void
name|removeRow
parameter_list|(
name|int
name|r
parameter_list|)
function_decl|;
name|bool
name|find
parameter_list|(
specifier|const
name|T
modifier|&
name|value
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|int
modifier|*
name|colPtr
parameter_list|)
specifier|const
function_decl|;
DECL|function|count
name|int
name|count
parameter_list|(
specifier|const
name|T
modifier|&
name|value
parameter_list|)
specifier|const
block|{
return|return
name|m_storage
operator|.
name|count
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|// Hmmpf.. Some things are faster that way.
DECL|function|storage
specifier|const
name|Storage
modifier|&
name|storage
parameter_list|()
specifier|const
block|{
return|return
name|m_storage
return|;
block|}
specifier|static
name|void
name|storageIndexToPosition
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|int
modifier|*
name|colPtr
parameter_list|)
function_decl|;
private|private:
DECL|member|m_storage
name|Storage
name|m_storage
decl_stmt|;
block|}
class|;
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
DECL|function|addRow
name|void
name|FixedColumnMatrix
argument_list|<
name|T
argument_list|,
name|NumColumns
argument_list|>
operator|::
name|addRow
parameter_list|(
specifier|const
name|T
modifier|&
name|value
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumColumns
condition|;
operator|++
name|i
control|)
name|m_storage
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
DECL|function|insertRow
name|void
name|FixedColumnMatrix
argument_list|<
name|T
argument_list|,
name|NumColumns
argument_list|>
operator|::
name|insertRow
parameter_list|(
name|int
name|r
parameter_list|,
specifier|const
name|T
modifier|&
name|value
parameter_list|)
block|{
typename|typename
name|Storage
operator|::
name|iterator
name|it
init|=
name|m_storage
operator|.
name|begin
argument_list|()
decl_stmt|;
name|it
operator|+=
name|r
operator|*
name|NumColumns
expr_stmt|;
name|m_storage
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|NumColumns
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
DECL|function|removeRow
name|void
name|FixedColumnMatrix
argument_list|<
name|T
argument_list|,
name|NumColumns
argument_list|>
operator|::
name|removeRow
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|m_storage
operator|.
name|remove
argument_list|(
name|r
operator|*
name|NumColumns
argument_list|,
name|NumColumns
argument_list|)
expr_stmt|;
block|}
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
DECL|function|find
name|bool
name|FixedColumnMatrix
argument_list|<
name|T
argument_list|,
name|NumColumns
argument_list|>
operator|::
name|find
parameter_list|(
specifier|const
name|T
modifier|&
name|value
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|int
modifier|*
name|colPtr
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|idx
init|=
name|m_storage
operator|.
name|indexOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|storageIndexToPosition
argument_list|(
name|idx
argument_list|,
name|rowPtr
argument_list|,
name|colPtr
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
template|template
parameter_list|<
name|class
name|T
parameter_list|,
name|int
name|NumColumns
parameter_list|>
DECL|function|storageIndexToPosition
name|void
name|FixedColumnMatrix
argument_list|<
name|T
argument_list|,
name|NumColumns
argument_list|>
operator|::
name|storageIndexToPosition
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|int
modifier|*
name|colPtr
parameter_list|)
block|{
operator|*
name|rowPtr
operator|=
name|idx
operator|/
name|NumColumns
expr_stmt|;
operator|*
name|colPtr
operator|=
name|idx
operator|%
name|NumColumns
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|// special values for unset fields; must not clash with values of FieldGrowthPolicy or
end_comment
begin_comment
comment|// RowWrapPolicy
end_comment
begin_decl_stmt
DECL|variable|DefaultFieldGrowthPolicy
specifier|const
name|uint
name|DefaultFieldGrowthPolicy
init|=
literal|255
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|DefaultRowWrapPolicy
specifier|const
name|uint
name|DefaultRowWrapPolicy
init|=
literal|255
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|ColumnCount
enum|enum
block|{
name|ColumnCount
init|=
literal|2
block|}
enum|;
end_enum
begin_comment
comment|// -- our data structure for our items
end_comment
begin_comment
comment|// This owns the QLayoutItem
end_comment
begin_struct
DECL|struct|QFormLayoutItem
struct|struct
name|QFormLayoutItem
block|{
DECL|function|QFormLayoutItem
name|QFormLayoutItem
parameter_list|(
name|QLayoutItem
modifier|*
name|i
parameter_list|)
member_init_list|:
name|item
argument_list|(
name|i
argument_list|)
member_init_list|,
name|fullRow
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isHfw
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|~QFormLayoutItem
name|~
name|QFormLayoutItem
parameter_list|()
block|{
operator|delete
name|item
expr_stmt|;
block|}
comment|// Wrappers
DECL|function|widget
name|QWidget
modifier|*
name|widget
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|widget
argument_list|()
return|;
block|}
DECL|function|layout
name|QLayout
modifier|*
name|layout
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|layout
argument_list|()
return|;
block|}
DECL|function|hasHeightForWidth
name|bool
name|hasHeightForWidth
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|hasHeightForWidth
argument_list|()
return|;
block|}
DECL|function|heightForWidth
name|int
name|heightForWidth
parameter_list|(
name|int
name|width
parameter_list|)
specifier|const
block|{
return|return
name|item
operator|->
name|heightForWidth
argument_list|(
name|width
argument_list|)
return|;
block|}
DECL|function|minimumHeightForWidth
name|int
name|minimumHeightForWidth
parameter_list|(
name|int
name|width
parameter_list|)
specifier|const
block|{
return|return
name|item
operator|->
name|minimumHeightForWidth
argument_list|(
name|width
argument_list|)
return|;
block|}
DECL|function|expandingDirections
name|Qt
operator|::
name|Orientations
name|expandingDirections
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|expandingDirections
argument_list|()
return|;
block|}
DECL|function|controlTypes
name|QSizePolicy
operator|::
name|ControlTypes
name|controlTypes
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|controlTypes
argument_list|()
return|;
block|}
DECL|function|vStretch
name|int
name|vStretch
parameter_list|()
specifier|const
block|{
return|return
name|widget
argument_list|()
condition|?
name|widget
argument_list|()
operator|->
name|sizePolicy
argument_list|()
operator|.
name|verticalStretch
argument_list|()
else|:
literal|0
return|;
block|}
DECL|function|setGeometry
name|void
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|item
operator|->
name|setGeometry
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
DECL|function|geometry
name|QRect
name|geometry
parameter_list|()
specifier|const
block|{
return|return
name|item
operator|->
name|geometry
argument_list|()
return|;
block|}
comment|// For use with FixedColumnMatrix
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QFormLayoutItem
modifier|&
name|other
parameter_list|)
block|{
return|return
name|item
operator|==
name|other
operator|.
name|item
return|;
block|}
DECL|member|item
name|QLayoutItem
modifier|*
name|item
decl_stmt|;
DECL|member|fullRow
name|bool
name|fullRow
decl_stmt|;
comment|// set by updateSizes
DECL|member|isHfw
name|bool
name|isHfw
decl_stmt|;
DECL|member|minSize
name|QSize
name|minSize
decl_stmt|;
DECL|member|sizeHint
name|QSize
name|sizeHint
decl_stmt|;
DECL|member|maxSize
name|QSize
name|maxSize
decl_stmt|;
comment|// also set by updateSizes
DECL|member|sbsHSpace
name|int
name|sbsHSpace
decl_stmt|;
comment|// only used for side by side, for the field item only (not label)
DECL|member|vSpace
name|int
name|vSpace
decl_stmt|;
comment|// This is the spacing to the item in the row above
comment|// set by setupVerticalLayoutData
DECL|member|sideBySide
name|bool
name|sideBySide
decl_stmt|;
DECL|member|vLayoutIndex
name|int
name|vLayoutIndex
decl_stmt|;
comment|// set by setupHorizontalLayoutData
DECL|member|layoutPos
name|int
name|layoutPos
decl_stmt|;
DECL|member|layoutWidth
name|int
name|layoutWidth
decl_stmt|;
block|}
struct|;
end_struct
begin_class
DECL|class|QFormLayoutPrivate
class|class
name|QFormLayoutPrivate
super|:
specifier|public
name|QLayoutPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QFormLayout
parameter_list|)
specifier|public
private|:
DECL|typedef|ItemMatrix
typedef|typedef
name|FixedColumnMatrix
argument_list|<
name|QFormLayoutItem
modifier|*
argument_list|,
name|ColumnCount
argument_list|>
name|ItemMatrix
typedef|;
name|QFormLayoutPrivate
parameter_list|()
constructor_decl|;
DECL|function|~QFormLayoutPrivate
name|~
name|QFormLayoutPrivate
parameter_list|()
block|{ }
name|int
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|)
function_decl|;
name|void
name|insertRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
name|void
name|setItem
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QLayoutItem
modifier|*
name|item
parameter_list|)
function_decl|;
name|void
name|setLayout
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QLayout
modifier|*
name|layout
parameter_list|)
function_decl|;
name|void
name|setWidget
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
function_decl|;
name|void
name|arrangeWidgets
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QLayoutStruct
argument_list|>
modifier|&
name|layouts
parameter_list|,
name|QRect
modifier|&
name|rect
parameter_list|)
function_decl|;
name|void
name|updateSizes
parameter_list|()
function_decl|;
name|void
name|setupVerticalLayoutData
parameter_list|(
name|int
name|width
parameter_list|)
function_decl|;
name|void
name|setupHorizontalLayoutData
parameter_list|(
name|int
name|width
parameter_list|)
function_decl|;
name|QStyle
modifier|*
name|getStyle
parameter_list|()
specifier|const
function_decl|;
DECL|function|haveHfwCached
specifier|inline
name|bool
name|haveHfwCached
parameter_list|(
name|int
name|width
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|hfw_width
operator|==
name|width
operator|)
operator|||
operator|(
name|width
operator|==
name|sh_width
operator|&&
name|hfw_sh_height
operator|>=
literal|0
operator|)
return|;
block|}
name|void
name|recalcHFW
parameter_list|(
name|int
name|w
parameter_list|)
function_decl|;
name|void
name|setupHfwLayoutData
parameter_list|()
function_decl|;
name|uint
name|fieldGrowthPolicy
range|:
literal|8
decl_stmt|;
name|uint
name|rowWrapPolicy
range|:
literal|8
decl_stmt|;
name|uint
name|has_hfw
range|:
literal|2
decl_stmt|;
name|uint
name|dirty
range|:
literal|2
decl_stmt|;
comment|// have we laid out yet?
name|uint
name|sizesDirty
range|:
literal|2
decl_stmt|;
comment|// have we (not) gathered layout item sizes?
name|uint
name|expandVertical
range|:
literal|1
decl_stmt|;
comment|// Do we expand vertically?
name|uint
name|expandHorizontal
range|:
literal|1
decl_stmt|;
comment|// Do we expand horizonally?
DECL|member|labelAlignment
name|Qt
operator|::
name|Alignment
name|labelAlignment
decl_stmt|;
DECL|member|formAlignment
name|Qt
operator|::
name|Alignment
name|formAlignment
decl_stmt|;
DECL|member|m_matrix
name|ItemMatrix
name|m_matrix
decl_stmt|;
DECL|member|m_things
name|QList
argument_list|<
name|QFormLayoutItem
modifier|*
argument_list|>
name|m_things
decl_stmt|;
DECL|member|layoutWidth
name|int
name|layoutWidth
decl_stmt|;
comment|// the last width that we called setupVerticalLayoutData on (for vLayouts)
DECL|member|hfw_width
name|int
name|hfw_width
decl_stmt|;
comment|// the last width we calculated HFW for
DECL|member|hfw_height
name|int
name|hfw_height
decl_stmt|;
comment|// what that height was
DECL|member|hfw_minheight
name|int
name|hfw_minheight
decl_stmt|;
comment|// what that minheight was
DECL|member|hfw_sh_height
name|int
name|hfw_sh_height
decl_stmt|;
comment|// the hfw for sh_width
DECL|member|hfw_sh_minheight
name|int
name|hfw_sh_minheight
decl_stmt|;
comment|// the minhfw for sh_width
DECL|member|min_width
name|int
name|min_width
decl_stmt|;
comment|// the width that gets turned into minSize (from updateSizes)
DECL|member|sh_width
name|int
name|sh_width
decl_stmt|;
comment|// the width that gets turned into prefSize (from updateSizes)
DECL|member|thresh_width
name|int
name|thresh_width
decl_stmt|;
comment|// the width that we start splitting label/field pairs at (from updateSizes)
DECL|member|minSize
name|QSize
name|minSize
decl_stmt|;
DECL|member|prefSize
name|QSize
name|prefSize
decl_stmt|;
DECL|member|formMaxWidth
name|int
name|formMaxWidth
decl_stmt|;
name|void
name|calcSizeHints
parameter_list|()
function_decl|;
DECL|member|vLayouts
name|QVector
argument_list|<
name|QLayoutStruct
argument_list|>
name|vLayouts
decl_stmt|;
comment|// set by setupVerticalLayoutData;
DECL|member|vLayoutCount
name|int
name|vLayoutCount
decl_stmt|;
comment|// Number of rows we calculated in setupVerticalLayoutData
DECL|member|maxLabelWidth
name|int
name|maxLabelWidth
decl_stmt|;
comment|// the label width we calculated in setupVerticalLayoutData
DECL|member|hfwLayouts
name|QVector
argument_list|<
name|QLayoutStruct
argument_list|>
name|hfwLayouts
decl_stmt|;
DECL|member|hSpacing
name|int
name|hSpacing
decl_stmt|;
DECL|member|vSpacing
name|int
name|vSpacing
decl_stmt|;
DECL|member|Q_DECL_OVERRIDE
name|QLayoutItem
modifier|*
name|replaceAt
parameter_list|(
name|int
name|index
parameter_list|,
name|QLayoutItem
modifier|*
parameter_list|)
name|Q_DECL_OVERRIDE
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QFormLayoutPrivate
name|QFormLayoutPrivate
operator|::
name|QFormLayoutPrivate
parameter_list|()
member_init_list|:
name|fieldGrowthPolicy
argument_list|(
name|DefaultFieldGrowthPolicy
argument_list|)
member_init_list|,
name|rowWrapPolicy
argument_list|(
name|DefaultRowWrapPolicy
argument_list|)
member_init_list|,
name|has_hfw
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dirty
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|sizesDirty
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|expandVertical
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|expandHorizontal
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|labelAlignment
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|formAlignment
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|layoutWidth
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|hfw_width
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|hfw_sh_height
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|min_width
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|sh_width
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|thresh_width
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|)
member_init_list|,
name|hSpacing
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|vSpacing
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|fixedAlignment
specifier|static
name|Qt
operator|::
name|Alignment
name|fixedAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|,
name|Qt
operator|::
name|LayoutDirection
name|layoutDirection
parameter_list|)
block|{
if|if
condition|(
name|layoutDirection
operator|==
name|Qt
operator|::
name|RightToLeft
operator|&&
name|alignment
operator|&
name|Qt
operator|::
name|AlignAbsolute
condition|)
block|{
comment|// swap left and right, and eliminate absolute flag
return|return
name|Qt
operator|::
name|Alignment
argument_list|(
operator|(
name|alignment
operator|&
operator|~
operator|(
name|Qt
operator|::
name|AlignLeft
operator||
name|Qt
operator|::
name|AlignRight
operator||
name|Qt
operator|::
name|AlignAbsolute
operator|)
operator|)
operator||
operator|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
condition|?
name|Qt
operator|::
name|AlignLeft
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
condition|?
name|Qt
operator|::
name|AlignRight
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|alignment
operator|&
operator|~
name|Qt
operator|::
name|AlignAbsolute
return|;
block|}
block|}
end_function
begin_function
DECL|function|storageIndexFromLayoutItem
specifier|static
name|int
name|storageIndexFromLayoutItem
parameter_list|(
specifier|const
name|QFormLayoutPrivate
operator|::
name|ItemMatrix
modifier|&
name|m
parameter_list|,
name|QFormLayoutItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
name|item
condition|)
block|{
return|return
name|m
operator|.
name|storage
argument_list|()
operator|.
name|indexOf
argument_list|(
name|item
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|updateFormLayoutItem
specifier|static
name|void
name|updateFormLayoutItem
parameter_list|(
name|QFormLayoutItem
modifier|*
name|item
parameter_list|,
name|int
name|userVSpacing
parameter_list|,
name|QFormLayout
operator|::
name|FieldGrowthPolicy
name|fieldGrowthPolicy
parameter_list|,
name|bool
name|fullRow
parameter_list|)
block|{
name|item
operator|->
name|minSize
operator|=
name|item
operator|->
name|item
operator|->
name|minimumSize
argument_list|()
expr_stmt|;
name|item
operator|->
name|sizeHint
operator|=
name|item
operator|->
name|item
operator|->
name|sizeHint
argument_list|()
expr_stmt|;
name|item
operator|->
name|maxSize
operator|=
name|item
operator|->
name|item
operator|->
name|maximumSize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fullRow
operator|&&
operator|(
name|fieldGrowthPolicy
operator|==
name|QFormLayout
operator|::
name|FieldsStayAtSizeHint
operator|||
operator|(
name|fieldGrowthPolicy
operator|==
name|QFormLayout
operator|::
name|ExpandingFieldsGrow
operator|&&
operator|!
operator|(
name|item
operator|->
name|item
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Horizontal
operator|)
operator|)
operator|)
condition|)
name|item
operator|->
name|maxSize
operator|.
name|setWidth
argument_list|(
name|item
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|item
operator|->
name|isHfw
operator|=
name|item
operator|->
name|item
operator|->
name|hasHeightForWidth
argument_list|()
expr_stmt|;
name|item
operator|->
name|vSpace
operator|=
name|userVSpacing
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    Iterate over all the controls and gather their size information    (min, sizeHint and max). Also work out what the spacing between    pairs of controls should be, and figure out the min and sizeHint    widths. */
end_comment
begin_function
DECL|function|updateSizes
name|void
name|QFormLayoutPrivate
operator|::
name|updateSizes
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizesDirty
condition|)
block|{
name|QFormLayout
operator|::
name|RowWrapPolicy
name|wrapPolicy
init|=
name|q
operator|->
name|rowWrapPolicy
argument_list|()
decl_stmt|;
name|bool
name|wrapAllRows
init|=
operator|(
name|wrapPolicy
operator|==
name|QFormLayout
operator|::
name|WrapAllRows
operator|)
decl_stmt|;
name|bool
name|dontWrapRows
init|=
operator|(
name|wrapPolicy
operator|==
name|QFormLayout
operator|::
name|DontWrapRows
operator|)
decl_stmt|;
name|int
name|rr
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
name|has_hfw
operator|=
literal|false
expr_stmt|;
comment|// If any control can expand, so can this layout
comment|// Wrapping doesn't affect expansion, though, just the minsize
name|bool
name|expandH
init|=
literal|false
decl_stmt|;
name|bool
name|expandV
init|=
literal|false
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|prevLbl
init|=
literal|0
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|prevFld
init|=
literal|0
decl_stmt|;
name|QWidget
modifier|*
name|parent
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|parent
condition|?
name|parent
operator|->
name|style
argument_list|()
else|:
literal|0
decl_stmt|;
name|int
name|userVSpacing
init|=
name|q
operator|->
name|verticalSpacing
argument_list|()
decl_stmt|;
name|int
name|userHSpacing
init|=
name|wrapAllRows
condition|?
literal|0
else|:
name|q
operator|->
name|horizontalSpacing
argument_list|()
decl_stmt|;
name|int
name|maxMinLblWidth
init|=
literal|0
decl_stmt|;
name|int
name|maxMinFldWidth
init|=
literal|0
decl_stmt|;
comment|// field with label
name|int
name|maxMinIfldWidth
init|=
literal|0
decl_stmt|;
comment|// independent field
name|int
name|maxShLblWidth
init|=
literal|0
decl_stmt|;
name|int
name|maxShFldWidth
init|=
literal|0
decl_stmt|;
name|int
name|maxShIfldWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Skip empty rows
if|if
condition|(
operator|!
name|label
operator|&&
operator|!
name|field
condition|)
continue|continue;
if|if
condition|(
name|label
condition|)
block|{
name|updateFormLayoutItem
argument_list|(
name|label
argument_list|,
name|userVSpacing
argument_list|,
name|q
operator|->
name|fieldGrowthPolicy
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|->
name|isHfw
condition|)
name|has_hfw
operator|=
literal|true
expr_stmt|;
name|Qt
operator|::
name|Orientations
name|o
init|=
name|label
operator|->
name|expandingDirections
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|&
name|Qt
operator|::
name|Vertical
condition|)
name|expandV
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|o
operator|&
name|Qt
operator|::
name|Horizontal
condition|)
name|expandH
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
name|updateFormLayoutItem
argument_list|(
name|field
argument_list|,
name|userVSpacing
argument_list|,
name|q
operator|->
name|fieldGrowthPolicy
argument_list|()
argument_list|,
operator|!
name|label
operator|&&
name|field
operator|->
name|fullRow
argument_list|)
expr_stmt|;
name|field
operator|->
name|sbsHSpace
operator|=
operator|(
operator|!
name|label
operator|&&
name|field
operator|->
name|fullRow
operator|)
condition|?
literal|0
else|:
name|userHSpacing
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|isHfw
condition|)
name|has_hfw
operator|=
literal|true
expr_stmt|;
name|Qt
operator|::
name|Orientations
name|o
init|=
name|field
operator|->
name|expandingDirections
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|&
name|Qt
operator|::
name|Vertical
condition|)
name|expandV
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|o
operator|&
name|Qt
operator|::
name|Horizontal
condition|)
name|expandH
operator|=
literal|true
expr_stmt|;
block|}
comment|// See if we need to calculate default spacings
if|if
condition|(
operator|(
name|userHSpacing
operator|<
literal|0
operator|||
name|userVSpacing
operator|<
literal|0
operator|)
operator|&&
name|style
condition|)
block|{
name|QSizePolicy
operator|::
name|ControlTypes
name|lbltypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|label
condition|?
name|label
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlTypes
name|fldtypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|field
condition|?
name|field
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
comment|// VSpacing
if|if
condition|(
name|userVSpacing
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|wrapAllRows
condition|)
block|{
comment|// label spacing is to a previous item
name|QFormLayoutItem
modifier|*
name|lbltop
init|=
name|prevFld
condition|?
name|prevFld
else|:
name|prevLbl
decl_stmt|;
comment|// field spacing is to the label (or a previous item)
name|QFormLayoutItem
modifier|*
name|fldtop
init|=
name|label
condition|?
name|label
else|:
name|lbltop
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlTypes
name|lbltoptypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|lbltop
condition|?
name|lbltop
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlTypes
name|fldtoptypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|fldtop
condition|?
name|fldtop
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|&&
name|lbltop
condition|)
name|label
operator|->
name|vSpace
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|lbltoptypes
argument_list|,
name|lbltypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&&
name|fldtop
condition|)
name|field
operator|->
name|vSpace
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|fldtoptypes
argument_list|,
name|fldtypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Side by side..  we have to also consider the spacings to empty cells, which can strangely be more than
comment|// non empty cells..
name|QFormLayoutItem
modifier|*
name|lbltop
init|=
name|prevLbl
condition|?
name|prevLbl
else|:
name|prevFld
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|fldtop
init|=
name|prevFld
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlTypes
name|lbltoptypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|lbltop
condition|?
name|lbltop
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlTypes
name|fldtoptypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|fldtop
condition|?
name|fldtop
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
comment|// To be compatible to QGridLayout, we have to compare solitary labels& fields with both predecessors
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|int
name|lblspacing
init|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|lbltoptypes
argument_list|,
name|lbltypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|int
name|fldspacing
init|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|fldtoptypes
argument_list|,
name|lbltypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|label
operator|->
name|vSpace
operator|=
name|qMax
argument_list|(
name|lblspacing
argument_list|,
name|fldspacing
argument_list|)
expr_stmt|;
block|}
else|else
name|label
operator|->
name|vSpace
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|lbltoptypes
argument_list|,
name|lbltypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
comment|// check spacing against both the previous label and field
if|if
condition|(
operator|!
name|label
condition|)
block|{
name|int
name|lblspacing
init|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|lbltoptypes
argument_list|,
name|fldtypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|int
name|fldspacing
init|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|fldtoptypes
argument_list|,
name|fldtypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|field
operator|->
name|vSpace
operator|=
name|qMax
argument_list|(
name|lblspacing
argument_list|,
name|fldspacing
argument_list|)
expr_stmt|;
block|}
else|else
name|field
operator|->
name|vSpace
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|fldtoptypes
argument_list|,
name|fldtypes
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// HSpacing
comment|// hard-coded the left and right control types so that all the rows have the same
comment|// inter-column spacing (otherwise the right column isn't always left aligned)
if|if
condition|(
name|userHSpacing
operator|<
literal|0
operator|&&
operator|!
name|wrapAllRows
operator|&&
operator|(
name|label
operator|||
operator|!
name|field
operator|->
name|fullRow
operator|)
operator|&&
name|field
condition|)
name|field
operator|->
name|sbsHSpace
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|QSizePolicy
operator|::
name|Label
argument_list|,
name|QSizePolicy
operator|::
name|LineEdit
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Now update our min/sizehint widths
comment|// We choose to put the spacing in the field side in sbs, so
comment|// the right edge of the labels will align, but fields may
comment|// be a little ragged.. since different controls may have
comment|// different appearances, a slight raggedness in the left
comment|// edges of fields can be tolerated.
comment|// (Note - field->sbsHSpace is 0 for WrapAllRows mode)
if|if
condition|(
name|label
condition|)
block|{
name|maxMinLblWidth
operator|=
name|qMax
argument_list|(
name|maxMinLblWidth
argument_list|,
name|label
operator|->
name|minSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|maxShLblWidth
operator|=
name|qMax
argument_list|(
name|maxShLblWidth
argument_list|,
name|label
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|maxMinFldWidth
operator|=
name|qMax
argument_list|(
name|maxMinFldWidth
argument_list|,
name|field
operator|->
name|minSize
operator|.
name|width
argument_list|()
operator|+
name|field
operator|->
name|sbsHSpace
argument_list|)
expr_stmt|;
name|maxShFldWidth
operator|=
name|qMax
argument_list|(
name|maxShFldWidth
argument_list|,
name|field
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
operator|+
name|field
operator|->
name|sbsHSpace
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
condition|)
block|{
name|maxMinIfldWidth
operator|=
name|qMax
argument_list|(
name|maxMinIfldWidth
argument_list|,
name|field
operator|->
name|minSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|maxShIfldWidth
operator|=
name|qMax
argument_list|(
name|maxShIfldWidth
argument_list|,
name|field
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|prevLbl
operator|=
name|label
expr_stmt|;
name|prevFld
operator|=
name|field
expr_stmt|;
block|}
comment|// Now, finally update the min/sizeHint widths
if|if
condition|(
name|wrapAllRows
condition|)
block|{
name|sh_width
operator|=
name|qMax
argument_list|(
name|maxShLblWidth
argument_list|,
name|qMax
argument_list|(
name|maxShIfldWidth
argument_list|,
name|maxShFldWidth
argument_list|)
argument_list|)
expr_stmt|;
name|min_width
operator|=
name|qMax
argument_list|(
name|maxMinLblWidth
argument_list|,
name|qMax
argument_list|(
name|maxMinIfldWidth
argument_list|,
name|maxMinFldWidth
argument_list|)
argument_list|)
expr_stmt|;
comment|// in two line, we don't care as much about the threshold width
name|thresh_width
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dontWrapRows
condition|)
block|{
comment|// This is just the max widths glommed together
name|sh_width
operator|=
name|qMax
argument_list|(
name|maxShLblWidth
operator|+
name|maxShFldWidth
argument_list|,
name|maxShIfldWidth
argument_list|)
expr_stmt|;
name|min_width
operator|=
name|qMax
argument_list|(
name|maxMinLblWidth
operator|+
name|maxMinFldWidth
argument_list|,
name|maxMinIfldWidth
argument_list|)
expr_stmt|;
name|thresh_width
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
block|}
else|else
block|{
comment|// This is just the max widths glommed together
name|sh_width
operator|=
name|qMax
argument_list|(
name|maxShLblWidth
operator|+
name|maxShFldWidth
argument_list|,
name|maxShIfldWidth
argument_list|)
expr_stmt|;
comment|// min width needs to be the min when everything is wrapped,
comment|// otherwise we'll never get set with a width that causes wrapping
name|min_width
operator|=
name|qMax
argument_list|(
name|maxMinLblWidth
argument_list|,
name|qMax
argument_list|(
name|maxMinIfldWidth
argument_list|,
name|maxMinFldWidth
argument_list|)
argument_list|)
expr_stmt|;
comment|// We split a pair at label sh + field min (### for now..)
name|thresh_width
operator|=
name|maxShLblWidth
operator|+
name|maxMinFldWidth
expr_stmt|;
block|}
comment|// Update the expansions
name|expandVertical
operator|=
name|expandV
expr_stmt|;
name|expandHorizontal
operator|=
name|expandH
expr_stmt|;
block|}
name|sizesDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recalcHFW
name|void
name|QFormLayoutPrivate
operator|::
name|recalcHFW
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|setupHfwLayoutData
argument_list|()
expr_stmt|;
name|int
name|h
init|=
literal|0
decl_stmt|;
name|int
name|mh
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|vLayoutCount
condition|;
operator|++
name|r
control|)
block|{
name|int
name|spacing
init|=
name|hfwLayouts
operator|.
name|at
argument_list|(
name|r
argument_list|)
operator|.
name|spacing
decl_stmt|;
name|h
operator|+=
name|hfwLayouts
operator|.
name|at
argument_list|(
name|r
argument_list|)
operator|.
name|sizeHint
operator|+
name|spacing
expr_stmt|;
name|mh
operator|+=
name|hfwLayouts
operator|.
name|at
argument_list|(
name|r
argument_list|)
operator|.
name|minimumSize
operator|+
name|spacing
expr_stmt|;
block|}
if|if
condition|(
name|sh_width
operator|>
literal|0
operator|&&
name|sh_width
operator|==
name|w
condition|)
block|{
name|hfw_sh_height
operator|=
name|qMin
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|hfw_sh_minheight
operator|=
name|qMin
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|,
name|mh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hfw_width
operator|=
name|w
expr_stmt|;
name|hfw_height
operator|=
name|qMin
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|hfw_minheight
operator|=
name|qMin
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|,
name|mh
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setupHfwLayoutData
name|void
name|QFormLayoutPrivate
operator|::
name|setupHfwLayoutData
parameter_list|()
block|{
comment|// setupVerticalLayoutData must be called before this
comment|// setupHorizontalLayoutData must also be called before this
comment|// copies non hfw data into hfw
comment|// then updates size and min
comment|// Note: QGridLayout doesn't call minimumHeightForWidth,
comment|// but instead uses heightForWidth for both min and sizeHint.
comment|// For the common case where minimumHeightForWidth just calls
comment|// heightForWidth, we do the calculation twice, which can be
comment|// very expensive for word wrapped QLabels/QTextEdits, for example.
comment|// So we just use heightForWidth as well.
name|int
name|i
decl_stmt|;
name|int
name|rr
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
name|hfwLayouts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|hfwLayouts
operator|.
name|resize
argument_list|(
name|vLayoutCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vLayoutCount
condition|;
operator|++
name|i
control|)
name|hfwLayouts
index|[
name|i
index|]
operator|=
name|vLayouts
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
if|if
condition|(
name|label
operator|->
name|isHfw
condition|)
block|{
comment|// We don't check sideBySide here, since a label is only
comment|// ever side by side with its field
name|int
name|hfw
init|=
name|label
operator|->
name|heightForWidth
argument_list|(
name|label
operator|->
name|layoutWidth
argument_list|)
decl_stmt|;
name|hfwLayouts
index|[
name|label
operator|->
name|vLayoutIndex
index|]
operator|.
name|minimumSize
operator|=
name|hfw
expr_stmt|;
name|hfwLayouts
index|[
name|label
operator|->
name|vLayoutIndex
index|]
operator|.
name|sizeHint
operator|=
name|hfw
expr_stmt|;
block|}
else|else
block|{
comment|// Reset these here, so the field can do a qMax below (the previous value may have
comment|// been the fields non-hfw values, which are often larger than hfw)
name|hfwLayouts
index|[
name|label
operator|->
name|vLayoutIndex
index|]
operator|.
name|sizeHint
operator|=
name|label
operator|->
name|sizeHint
operator|.
name|height
argument_list|()
expr_stmt|;
name|hfwLayouts
index|[
name|label
operator|->
name|vLayoutIndex
index|]
operator|.
name|minimumSize
operator|=
name|label
operator|->
name|minSize
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|field
condition|)
block|{
name|int
name|hfw
init|=
name|field
operator|->
name|isHfw
condition|?
name|field
operator|->
name|heightForWidth
argument_list|(
name|field
operator|->
name|layoutWidth
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|h
init|=
name|field
operator|->
name|isHfw
condition|?
name|hfw
else|:
name|field
operator|->
name|sizeHint
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|mh
init|=
name|field
operator|->
name|isHfw
condition|?
name|hfw
else|:
name|field
operator|->
name|minSize
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|->
name|sideBySide
condition|)
block|{
name|int
name|oh
init|=
name|hfwLayouts
operator|.
name|at
argument_list|(
name|field
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|sizeHint
decl_stmt|;
name|int
name|omh
init|=
name|hfwLayouts
operator|.
name|at
argument_list|(
name|field
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|minimumSize
decl_stmt|;
name|hfwLayouts
index|[
name|field
operator|->
name|vLayoutIndex
index|]
operator|.
name|sizeHint
operator|=
name|qMax
argument_list|(
name|h
argument_list|,
name|oh
argument_list|)
expr_stmt|;
name|hfwLayouts
index|[
name|field
operator|->
name|vLayoutIndex
index|]
operator|.
name|minimumSize
operator|=
name|qMax
argument_list|(
name|mh
argument_list|,
name|omh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hfwLayouts
index|[
name|field
operator|->
name|vLayoutIndex
index|]
operator|.
name|sizeHint
operator|=
name|h
expr_stmt|;
name|hfwLayouts
index|[
name|field
operator|->
name|vLayoutIndex
index|]
operator|.
name|minimumSize
operator|=
name|mh
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*   Given up to four items involved in a vertical spacing calculation   (two rows * two columns), return the max vertical spacing for the   row containing item1 (which may also include item2)   We assume parent and item1 are not null.    If a particular row is split, then the spacings for that row and   the following row are affected, and this function should be   called with recalculate = true for both rows (note: only rows with both   a label and a field can be split).    In particular:    1) the split label's row vspace needs to be changed to qMax(label/prevLabel, label/prevField)     [call with item1 = label, item2 = null, prevItem1& prevItem2 as before]   2) the split field's row vspace needs to be changed to the label/field spacing     [call with item1 = field, item2 = null, prevItem1 = label, prevItem2 = null]   [if the next row has one item, 'item']   3a) the following row's vspace needs to be changed to item/field spacing (would       previously been the qMax(item/label, item/field) spacings)     [call with item1 = item, item2 = null, prevItem1 = field, prevItem2 = null]    [if the next row has two items, 'label2' and 'field2']   3b) the following row's vspace needs to be changed to be qMax(field/label2, field/field2) spacing     [call with item1 = label2, item2 = field2, prevItem1 = field, prevItem2 = null]    In the (common) non split case, we can just use the precalculated vspace (possibly qMaxed between   label and field).    If recalculate is true, we expect:   -  parent != null   -  item1 != null   -  item2 can be null   -  prevItem1 can be null   -  if item2 is not null, prevItem2 will be null (e.g. steps 1 or 3 above)   -  if prevItem1 is null, prevItem2 will be null */
end_comment
begin_function
DECL|function|spacingHelper
specifier|static
specifier|inline
name|int
name|spacingHelper
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|QStyle
modifier|*
name|style
parameter_list|,
name|int
name|userVSpacing
parameter_list|,
name|bool
name|recalculate
parameter_list|,
name|QFormLayoutItem
modifier|*
name|item1
parameter_list|,
name|QFormLayoutItem
modifier|*
name|item2
parameter_list|,
name|QFormLayoutItem
modifier|*
name|prevItem1
parameter_list|,
name|QFormLayoutItem
modifier|*
name|prevItem2
parameter_list|)
block|{
name|int
name|spacing
init|=
name|userVSpacing
decl_stmt|;
if|if
condition|(
name|spacing
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|recalculate
condition|)
block|{
if|if
condition|(
name|item1
condition|)
name|spacing
operator|=
name|item1
operator|->
name|vSpace
expr_stmt|;
if|if
condition|(
name|item2
condition|)
name|spacing
operator|=
name|qMax
argument_list|(
name|spacing
argument_list|,
name|item2
operator|->
name|vSpace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|style
operator|&&
name|prevItem1
condition|)
block|{
name|QSizePolicy
operator|::
name|ControlTypes
name|itemtypes
init|=
name|QSizePolicy
operator|::
name|ControlTypes
argument_list|(
name|item1
condition|?
name|item1
operator|->
name|controlTypes
argument_list|()
else|:
name|QSizePolicy
operator|::
name|DefaultType
argument_list|)
decl_stmt|;
name|int
name|spacing2
init|=
literal|0
decl_stmt|;
name|spacing
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|itemtypes
argument_list|,
name|prevItem1
operator|->
name|controlTypes
argument_list|()
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|// At most of one of item2 and prevItem2 will be nonnull
if|if
condition|(
name|item2
condition|)
name|spacing2
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|item2
operator|->
name|controlTypes
argument_list|()
argument_list|,
name|prevItem1
operator|->
name|controlTypes
argument_list|()
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prevItem2
condition|)
name|spacing2
operator|=
name|style
operator|->
name|combinedLayoutSpacing
argument_list|(
name|itemtypes
argument_list|,
name|prevItem2
operator|->
name|controlTypes
argument_list|()
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|spacing
operator|=
name|qMax
argument_list|(
name|spacing
argument_list|,
name|spacing2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|prevItem1
condition|)
block|{
name|QWidget
modifier|*
name|wid
init|=
name|prevItem1
operator|->
name|item
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|wid
condition|)
name|spacing
operator|=
name|qMax
argument_list|(
name|spacing
argument_list|,
name|prevItem1
operator|->
name|geometry
argument_list|()
operator|.
name|top
argument_list|()
operator|-
name|wid
operator|->
name|geometry
argument_list|()
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevItem2
condition|)
block|{
name|QWidget
modifier|*
name|wid
init|=
name|prevItem2
operator|->
name|item
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|wid
condition|)
name|spacing
operator|=
name|qMax
argument_list|(
name|spacing
argument_list|,
name|prevItem2
operator|->
name|geometry
argument_list|()
operator|.
name|top
argument_list|()
operator|-
name|wid
operator|->
name|geometry
argument_list|()
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|qMax
argument_list|(
name|spacing
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|initLayoutStruct
specifier|static
specifier|inline
name|void
name|initLayoutStruct
parameter_list|(
name|QLayoutStruct
modifier|&
name|sl
parameter_list|,
name|QFormLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|sl
operator|.
name|init
argument_list|(
name|item
operator|->
name|vStretch
argument_list|()
argument_list|,
name|item
operator|->
name|minSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|sl
operator|.
name|sizeHint
operator|=
name|item
operator|->
name|sizeHint
operator|.
name|height
argument_list|()
expr_stmt|;
name|sl
operator|.
name|maximumSize
operator|=
name|item
operator|->
name|maxSize
operator|.
name|height
argument_list|()
expr_stmt|;
name|sl
operator|.
name|expansive
operator|=
operator|(
name|item
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
operator|)
expr_stmt|;
name|sl
operator|.
name|empty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupVerticalLayoutData
name|void
name|QFormLayoutPrivate
operator|::
name|setupVerticalLayoutData
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
comment|// Early out if we have no changes that would cause a change in vertical layout
if|if
condition|(
operator|(
name|width
operator|==
name|layoutWidth
operator|||
operator|(
name|width
operator|>=
name|thresh_width
operator|&&
name|layoutWidth
operator|>=
name|thresh_width
operator|)
operator|)
operator|&&
operator|!
name|dirty
operator|&&
operator|!
name|sizesDirty
condition|)
return|return;
name|layoutWidth
operator|=
name|width
expr_stmt|;
name|int
name|rr
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
name|int
name|vidx
init|=
literal|1
decl_stmt|;
name|QFormLayout
operator|::
name|RowWrapPolicy
name|rowWrapPolicy
init|=
name|q
operator|->
name|rowWrapPolicy
argument_list|()
decl_stmt|;
name|bool
name|wrapAllRows
init|=
operator|(
name|rowWrapPolicy
operator|==
name|QFormLayout
operator|::
name|WrapAllRows
operator|)
decl_stmt|;
name|bool
name|addTopBottomStretch
init|=
literal|true
decl_stmt|;
name|vLayouts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|vLayouts
operator|.
name|resize
argument_list|(
operator|(
literal|2
operator|*
name|rr
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|// a max, some may be unused
name|QStyle
modifier|*
name|style
init|=
literal|0
decl_stmt|;
name|int
name|userVSpacing
init|=
name|q
operator|->
name|verticalSpacing
argument_list|()
decl_stmt|;
if|if
condition|(
name|userVSpacing
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|widget
init|=
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
name|style
operator|=
name|widget
operator|->
name|style
argument_list|()
expr_stmt|;
block|}
comment|// make sure our sizes are up to date
name|updateSizes
argument_list|()
expr_stmt|;
comment|// Grab the widest label width here
comment|// This might be different from the value computed during
comment|// sizeHint/minSize, since we don't count label/field pairs that
comment|// are split.
name|maxLabelWidth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|wrapAllRows
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|&&
operator|(
name|label
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
operator|+
operator|(
name|field
condition|?
name|field
operator|->
name|minSize
operator|.
name|width
argument_list|()
else|:
literal|0
operator|)
operator|<=
name|width
operator|)
condition|)
name|maxLabelWidth
operator|=
name|qMax
argument_list|(
name|maxLabelWidth
argument_list|,
name|label
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxLabelWidth
operator|=
name|width
expr_stmt|;
block|}
name|QFormLayoutItem
modifier|*
name|prevItem1
init|=
literal|0
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|prevItem2
init|=
literal|0
decl_stmt|;
name|bool
name|prevRowSplit
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Totally ignore empty rows...
if|if
condition|(
operator|!
name|label
operator|&&
operator|!
name|field
condition|)
continue|continue;
name|QSize
name|min1
decl_stmt|;
name|QSize
name|min2
decl_stmt|;
name|QSize
name|sh1
decl_stmt|;
name|QSize
name|sh2
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|min1
operator|=
name|label
operator|->
name|minSize
expr_stmt|;
name|sh1
operator|=
name|label
operator|->
name|sizeHint
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
name|min2
operator|=
name|field
operator|->
name|minSize
expr_stmt|;
name|sh2
operator|=
name|field
operator|->
name|sizeHint
expr_stmt|;
block|}
comment|// In separate lines, we make a vLayout for everything that isn't null
comment|// in side by side, we only separate label/field if we're going to wrap it
name|bool
name|splitSideBySide
init|=
operator|(
name|rowWrapPolicy
operator|==
name|QFormLayout
operator|::
name|WrapLongRows
operator|)
operator|&&
operator|(
operator|(
name|maxLabelWidth
operator|<
name|sh1
operator|.
name|width
argument_list|()
operator|)
operator|||
operator|(
name|width
operator|<
operator|(
name|maxLabelWidth
operator|+
name|min2
operator|.
name|width
argument_list|()
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|wrapAllRows
operator|||
name|splitSideBySide
condition|)
block|{
if|if
condition|(
name|label
condition|)
block|{
name|initLayoutStruct
argument_list|(
name|vLayouts
index|[
name|vidx
index|]
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|vidx
operator|>
literal|1
condition|)
name|vLayouts
index|[
name|vidx
operator|-
literal|1
index|]
operator|.
name|spacing
operator|=
name|spacingHelper
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|,
name|style
argument_list|,
name|userVSpacing
argument_list|,
name|splitSideBySide
operator|||
name|prevRowSplit
argument_list|,
name|label
argument_list|,
literal|0
argument_list|,
name|prevItem1
argument_list|,
name|prevItem2
argument_list|)
expr_stmt|;
name|label
operator|->
name|vLayoutIndex
operator|=
name|vidx
expr_stmt|;
name|label
operator|->
name|sideBySide
operator|=
literal|false
expr_stmt|;
name|prevItem1
operator|=
name|label
expr_stmt|;
name|prevItem2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|stretch
operator|>
literal|0
condition|)
name|addTopBottomStretch
operator|=
literal|false
expr_stmt|;
operator|++
name|vidx
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
name|initLayoutStruct
argument_list|(
name|vLayouts
index|[
name|vidx
index|]
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|vidx
operator|>
literal|1
condition|)
name|vLayouts
index|[
name|vidx
operator|-
literal|1
index|]
operator|.
name|spacing
operator|=
name|spacingHelper
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|,
name|style
argument_list|,
name|userVSpacing
argument_list|,
name|splitSideBySide
operator|||
name|prevRowSplit
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
name|prevItem1
argument_list|,
name|prevItem2
argument_list|)
expr_stmt|;
name|field
operator|->
name|vLayoutIndex
operator|=
name|vidx
expr_stmt|;
name|field
operator|->
name|sideBySide
operator|=
literal|false
expr_stmt|;
name|prevItem1
operator|=
name|field
expr_stmt|;
name|prevItem2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|stretch
operator|>
literal|0
condition|)
name|addTopBottomStretch
operator|=
literal|false
expr_stmt|;
operator|++
name|vidx
expr_stmt|;
block|}
name|prevRowSplit
operator|=
name|splitSideBySide
expr_stmt|;
block|}
else|else
block|{
comment|// we're in side by side mode, and we have enough space to do that
name|QSize
name|max1
argument_list|(
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
decl_stmt|;
name|QSize
name|max2
argument_list|(
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
decl_stmt|;
name|int
name|stretch1
init|=
literal|0
decl_stmt|;
name|int
name|stretch2
init|=
literal|0
decl_stmt|;
name|bool
name|expanding
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|max1
operator|=
name|label
operator|->
name|maxSize
expr_stmt|;
if|if
condition|(
name|label
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
condition|)
name|expanding
operator|=
literal|true
expr_stmt|;
name|label
operator|->
name|sideBySide
operator|=
operator|(
name|field
operator|!=
literal|0
operator|)
expr_stmt|;
name|label
operator|->
name|vLayoutIndex
operator|=
name|vidx
expr_stmt|;
name|stretch1
operator|=
name|label
operator|->
name|vStretch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
name|max2
operator|=
name|field
operator|->
name|maxSize
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
condition|)
name|expanding
operator|=
literal|true
expr_stmt|;
name|field
operator|->
name|sideBySide
operator|=
operator|(
name|label
operator|||
operator|!
name|field
operator|->
name|fullRow
operator|)
expr_stmt|;
name|field
operator|->
name|vLayoutIndex
operator|=
name|vidx
expr_stmt|;
name|stretch2
operator|=
name|field
operator|->
name|vStretch
argument_list|()
expr_stmt|;
block|}
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|init
argument_list|(
name|qMax
argument_list|(
name|stretch1
argument_list|,
name|stretch2
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|min1
operator|.
name|height
argument_list|()
argument_list|,
name|min2
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|sizeHint
operator|=
name|qMax
argument_list|(
name|sh1
operator|.
name|height
argument_list|()
argument_list|,
name|sh2
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|maximumSize
operator|=
name|qMin
argument_list|(
name|max1
operator|.
name|height
argument_list|()
argument_list|,
name|max2
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|expansive
operator|=
name|expanding
operator|||
operator|(
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|stretch
operator|>
literal|0
operator|)
expr_stmt|;
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|empty
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|stretch
operator|>
literal|0
condition|)
name|addTopBottomStretch
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|vidx
operator|>
literal|1
condition|)
name|vLayouts
index|[
name|vidx
operator|-
literal|1
index|]
operator|.
name|spacing
operator|=
name|spacingHelper
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|,
name|style
argument_list|,
name|userVSpacing
argument_list|,
name|prevRowSplit
argument_list|,
name|label
argument_list|,
name|field
argument_list|,
name|prevItem1
argument_list|,
name|prevItem2
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|prevItem1
operator|=
name|label
expr_stmt|;
name|prevItem2
operator|=
name|field
expr_stmt|;
block|}
else|else
block|{
name|prevItem1
operator|=
name|field
expr_stmt|;
name|prevItem2
operator|=
literal|0
expr_stmt|;
block|}
name|prevRowSplit
operator|=
literal|false
expr_stmt|;
operator|++
name|vidx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addTopBottomStretch
condition|)
block|{
name|Qt
operator|::
name|Alignment
name|formAlignment
init|=
name|q
operator|->
name|formAlignment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|formAlignment
operator|&
name|Qt
operator|::
name|AlignBottom
operator|)
condition|)
block|{
comment|// AlignTop (default if unspecified) or AlignVCenter: We add a stretch at the bottom
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|init
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vLayouts
index|[
name|vidx
index|]
operator|.
name|expansive
operator|=
literal|true
expr_stmt|;
operator|++
name|vidx
expr_stmt|;
block|}
if|if
condition|(
name|formAlignment
operator|&
operator|(
name|Qt
operator|::
name|AlignVCenter
operator||
name|Qt
operator|::
name|AlignBottom
operator|)
condition|)
block|{
comment|// AlignVCenter or AlignBottom: We add a stretch at the top
name|vLayouts
index|[
literal|0
index|]
operator|.
name|init
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vLayouts
index|[
literal|0
index|]
operator|.
name|expansive
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|vLayouts
index|[
literal|0
index|]
operator|.
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vLayouts
index|[
literal|0
index|]
operator|.
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vLayoutCount
operator|=
name|vidx
expr_stmt|;
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupHorizontalLayoutData
name|void
name|QFormLayoutPrivate
operator|::
name|setupHorizontalLayoutData
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
comment|// requires setupVerticalLayoutData to be called first
name|int
name|fieldMaxWidth
init|=
literal|0
decl_stmt|;
name|int
name|rr
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
name|bool
name|wrapAllRows
init|=
operator|(
name|q
operator|->
name|rowWrapPolicy
argument_list|()
operator|==
name|QFormLayout
operator|::
name|WrapAllRows
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Totally ignore empty rows...
if|if
condition|(
operator|!
name|label
operator|&&
operator|!
name|field
condition|)
continue|continue;
if|if
condition|(
name|label
condition|)
block|{
comment|// if there is a field, and we're side by side, we use maxLabelWidth
comment|// otherwise we just use the sizehint
name|label
operator|->
name|layoutWidth
operator|=
operator|(
name|field
operator|&&
name|label
operator|->
name|sideBySide
operator|)
condition|?
name|maxLabelWidth
else|:
name|label
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
expr_stmt|;
name|label
operator|->
name|layoutPos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
comment|// This is the default amount allotted to fields in sbs
name|int
name|fldwidth
init|=
name|width
operator|-
name|maxLabelWidth
operator|-
name|field
operator|->
name|sbsHSpace
decl_stmt|;
comment|// If we've split a row, we still decide to align
comment|// the field with all the other field if it will fit
comment|// Fields in sbs mode get the remnants of the maxLabelWidth
if|if
condition|(
operator|!
name|field
operator|->
name|sideBySide
condition|)
block|{
if|if
condition|(
name|wrapAllRows
operator|||
operator|(
operator|!
name|label
operator|&&
name|field
operator|->
name|fullRow
operator|)
operator|||
name|field
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
operator|>
name|fldwidth
condition|)
block|{
name|field
operator|->
name|layoutWidth
operator|=
name|width
expr_stmt|;
name|field
operator|->
name|layoutPos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|field
operator|->
name|layoutWidth
operator|=
name|fldwidth
expr_stmt|;
name|field
operator|->
name|layoutPos
operator|=
name|width
operator|-
name|fldwidth
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We're sbs, so we should have a label
name|field
operator|->
name|layoutWidth
operator|=
name|fldwidth
expr_stmt|;
name|field
operator|->
name|layoutPos
operator|=
name|width
operator|-
name|fldwidth
expr_stmt|;
block|}
name|fieldMaxWidth
operator|=
name|qMax
argument_list|(
name|fieldMaxWidth
argument_list|,
name|field
operator|->
name|maxSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|formMaxWidth
operator|=
name|maxLabelWidth
operator|+
name|fieldMaxWidth
expr_stmt|;
block|}
end_function
begin_function
DECL|function|calcSizeHints
name|void
name|QFormLayoutPrivate
operator|::
name|calcSizeHints
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|leftMargin
decl_stmt|,
name|topMargin
decl_stmt|,
name|rightMargin
decl_stmt|,
name|bottomMargin
decl_stmt|;
name|q
operator|->
name|getContentsMargins
argument_list|(
operator|&
name|leftMargin
argument_list|,
operator|&
name|topMargin
argument_list|,
operator|&
name|rightMargin
argument_list|,
operator|&
name|bottomMargin
argument_list|)
expr_stmt|;
name|updateSizes
argument_list|()
expr_stmt|;
name|setupVerticalLayoutData
argument_list|(
name|QLAYOUTSIZE_MAX
argument_list|)
expr_stmt|;
comment|// Don't need to call setupHorizontal here
name|int
name|h
init|=
name|topMargin
operator|+
name|bottomMargin
decl_stmt|;
name|int
name|mh
init|=
name|topMargin
operator|+
name|bottomMargin
decl_stmt|;
comment|// The following are set in updateSizes
name|int
name|w
init|=
name|sh_width
operator|+
name|leftMargin
operator|+
name|rightMargin
decl_stmt|;
name|int
name|mw
init|=
name|min_width
operator|+
name|leftMargin
operator|+
name|rightMargin
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vLayoutCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|spacing
init|=
name|vLayouts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|spacing
decl_stmt|;
name|h
operator|+=
name|vLayouts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sizeHint
operator|+
name|spacing
expr_stmt|;
name|mh
operator|+=
name|vLayouts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|minimumSize
operator|+
name|spacing
expr_stmt|;
block|}
name|minSize
operator|.
name|rwidth
argument_list|()
operator|=
name|qMin
argument_list|(
name|mw
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
expr_stmt|;
name|minSize
operator|.
name|rheight
argument_list|()
operator|=
name|qMin
argument_list|(
name|mh
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
expr_stmt|;
name|prefSize
operator|.
name|rwidth
argument_list|()
operator|=
name|qMin
argument_list|(
name|w
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
expr_stmt|;
name|prefSize
operator|.
name|rheight
argument_list|()
operator|=
name|qMin
argument_list|(
name|h
argument_list|,
name|QLAYOUTSIZE_MAX
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|insertRow
name|int
name|QFormLayoutPrivate
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|int
name|rowCnt
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|row
argument_list|)
operator|>
name|uint
argument_list|(
name|rowCnt
argument_list|)
condition|)
name|row
operator|=
name|rowCnt
expr_stmt|;
name|insertRows
argument_list|(
name|row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|row
return|;
block|}
end_function
begin_function
DECL|function|insertRows
name|void
name|QFormLayoutPrivate
operator|::
name|insertRows
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|count
parameter_list|)
block|{
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|m_matrix
operator|.
name|insertRow
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setItem
name|void
name|QFormLayoutPrivate
operator|::
name|setItem
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QLayoutItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|bool
name|fullRow
init|=
name|role
operator|==
name|QFormLayout
operator|::
name|SpanningRole
decl_stmt|;
specifier|const
name|int
name|column
init|=
name|role
operator|==
name|QFormLayout
operator|::
name|SpanningRole
condition|?
literal|1
else|:
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|row
argument_list|)
operator|>=
name|uint
argument_list|(
name|m_matrix
operator|.
name|rowCount
argument_list|()
argument_list|)
operator|||
name|uint
argument_list|(
name|column
argument_list|)
operator|>
literal|1U
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFormLayoutPrivate::setItem: Invalid cell (%d, %d)"
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|item
condition|)
return|return;
if|if
condition|(
name|m_matrix
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFormLayoutPrivate::setItem: Cell (%d, %d) already occupied"
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
return|return;
block|}
name|QFormLayoutItem
modifier|*
name|i
init|=
operator|new
name|QFormLayoutItem
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|i
operator|->
name|fullRow
operator|=
name|fullRow
expr_stmt|;
name|m_matrix
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
operator|=
name|i
expr_stmt|;
name|m_things
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setLayout
name|void
name|QFormLayoutPrivate
operator|::
name|setLayout
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QLayout
modifier|*
name|layout
parameter_list|)
block|{
if|if
condition|(
name|layout
condition|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|adoptLayout
argument_list|(
name|layout
argument_list|)
condition|)
name|setItem
argument_list|(
name|row
argument_list|,
name|role
argument_list|,
name|layout
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setWidget
name|void
name|QFormLayoutPrivate
operator|::
name|setWidget
parameter_list|(
name|int
name|row
parameter_list|,
name|QFormLayout
operator|::
name|ItemRole
name|role
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|widget
condition|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|q
operator|->
name|addChildWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|setItem
argument_list|(
name|row
argument_list|,
name|role
argument_list|,
name|QLayoutPrivate
operator|::
name|createWidgetItem
argument_list|(
name|q
argument_list|,
name|widget
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getStyle
name|QStyle
modifier|*
name|QFormLayoutPrivate
operator|::
name|getStyle
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
comment|// ### cache
if|if
condition|(
name|QWidget
modifier|*
name|parentWidget
init|=
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
return|return
name|parentWidget
operator|->
name|style
argument_list|()
return|;
else|else
return|return
name|QApplication
operator|::
name|style
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|replaceAt
name|QLayoutItem
modifier|*
name|QFormLayoutPrivate
operator|::
name|replaceAt
parameter_list|(
name|int
name|index
parameter_list|,
name|QLayoutItem
modifier|*
name|newitem
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newitem
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|storageIndex
init|=
name|storageIndexFromLayoutItem
argument_list|(
name|m_matrix
argument_list|,
name|m_things
operator|.
name|value
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ### Qt6 - fix warning too when this class becomes public
name|qWarning
argument_list|(
literal|"QFormLayoutPrivate::replaceAt: Invalid index %d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|QFormLayoutPrivate
operator|::
name|ItemMatrix
operator|::
name|storageIndexToPosition
argument_list|(
name|storageIndex
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|QFormLayoutItem
modifier|*
name|item
init|=
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|QLayoutItem
modifier|*
name|olditem
init|=
name|item
operator|->
name|item
decl_stmt|;
name|item
operator|->
name|item
operator|=
name|newitem
expr_stmt|;
name|q
operator|->
name|invalidate
argument_list|()
expr_stmt|;
return|return
name|olditem
return|;
block|}
end_function
begin_comment
comment|/*!     \class QFormLayout     \since 4.4     \brief The QFormLayout class manages forms of input widgets and their associated labels.      \ingroup geomanagement     \inmodule QtWidgets      QFormLayout is a convenience layout class that lays out its     children in a two-column form. The left column consists of labels     and the right column consists of "field" widgets (line editors,     spin boxes, etc.).      Traditionally, such two-column form layouts were achieved using     QGridLayout. QFormLayout is a higher-level alternative that     provides the following advantages:      \list     \li \b{Adherence to the different platform's look and feel guidelines.}          For example, the         \l{http://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html}{Mac OS X Aqua} and KDE guidelines specify that the         labels should be right-aligned, whereas Windows and GNOME         applications normally use left-alignment.      \li \b{Support for wrapping long rows.}         For devices with small displays, QFormLayout can be set to        \l{WrapLongRows}{wrap long rows}, or even to        \l{WrapAllRows}{wrap all rows}.      \li \b{Convenient API for creating label--field pairs.}         The addRow() overload that takes a QString and a QWidget *        creates a QLabel behind the scenes and automatically set up        its buddy. We can then write code like this:      \snippet code/src_gui_kernel_qformlayout.cpp 0         Compare this with the following code, written using QGridLayout:      \snippet code/src_gui_kernel_qformlayout.cpp 1     \endlist      The table below shows the default appearance in different styles.      \table     \header         \li QCommonStyle derived styles (except QPlastiqueStyle)         \li QMacStyle         \li QPlastiqueStyle         \li Qt Extended styles     \row         \li \inlineimage qformlayout-win.png         \li \inlineimage qformlayout-mac.png         \li \inlineimage qformlayout-kde.png         \li \inlineimage qformlayout-qpe.png     \row         \li Traditional style used for Windows, GNOME, and earlier            versions of KDE. Labels are left aligned, and expanding            fields grow to fill the available space. (This normally            corresponds to what we would get using a two-column            QGridLayout.)         \li Style based on the            \l{http://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html}{Mac OS X Aqua} guidelines. Labels are right-aligned,            the fields don't grow beyond their size hint, and the            form is horizontally centered.         \li Recommended style for            \l{KDE applications}. Similar to MacStyle, except that the form            is left-aligned and all fields grow to fill the available            space.         \li Default style for Qt Extended styles. Labels are right-aligned,            expanding fields grow to fill the available space, and row            wrapping is enabled for long lines.     \endtable      The form styles can be also be overridden individually by calling     setLabelAlignment(), setFormAlignment(), setFieldGrowthPolicy(),     and setRowWrapPolicy().  For example, to simulate the form layout     appearance of QMacStyle on all platforms, but with left-aligned     labels, you could write:      \snippet code/src_gui_kernel_qformlayout.cpp 2      \sa QGridLayout, QBoxLayout, QStackedLayout */
end_comment
begin_comment
comment|/*!     \enum QFormLayout::FieldGrowthPolicy      This enum specifies the different policies that can be used to     control the way in which the form's fields grow.      \value FieldsStayAtSizeHint            The fields never grow beyond their            \l{QWidgetItem::sizeHint()}{effective size hint}. This is            the default for QMacStyle.      \value ExpandingFieldsGrow            Fields with an horizontal \l{QSizePolicy}{size policy} of            \l{QSizePolicy::}{Expanding} or            \l{QSizePolicy::}{MinimumExpanding} will grow to fill the            available space. The other fields will not grow beyond            their effective size hint. This is the default policy for            Plastique.      \value AllNonFixedFieldsGrow            All fields with a size policy that allows them to grow            will grow to fill the available space. This is the default            policy for most styles.      \sa fieldGrowthPolicy */
end_comment
begin_comment
comment|/*!     \enum QFormLayout::RowWrapPolicy      This enum specifies the different policies that can be used to     control the way in which the form's rows wrap.      \value DontWrapRows            Fields are always laid out next to their label.  This is            the default policy for all styles except Qt Extended styles.      \value WrapLongRows            Labels are given enough horizontal space to fit the widest label,            and the rest of the space is given to the fields. If the minimum            size of a field pair is wider than the available space, the field            is wrapped to the next line.  This is the default policy for            Qt Extended styles.      \value WrapAllRows            Fields are always laid out below their label.      \sa rowWrapPolicy */
end_comment
begin_comment
comment|/*!     \enum QFormLayout::ItemRole      This enum specifies the types of widgets (or other layout items)     that may appear in a row.      \value LabelRole A label widget.     \value FieldRole A field widget.     \value SpanningRole A widget that spans label and field columns.      \sa itemAt(), getItemPosition() */
end_comment
begin_comment
comment|/*!     Constructs a new form layout with the given \a parent widget.      \sa QWidget::setLayout() */
end_comment
begin_constructor
DECL|function|QFormLayout
name|QFormLayout
operator|::
name|QFormLayout
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QLayout
argument_list|(
operator|*
operator|new
name|QFormLayoutPrivate
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the form layout. */
end_comment
begin_destructor
DECL|function|~QFormLayout
name|QFormLayout
operator|::
name|~
name|QFormLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
comment|/*         The clearing and destruction order here is important. We start by clearing         m_things so that QLayout and the rest of the world know that we don't babysit         the layout items anymore and don't care if they are destroyed.     */
name|d
operator|->
name|m_things
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|m_matrix
operator|.
name|storage
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_matrix
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Adds a new row to the bottom of this form layout, with the given     \a label and \a field.      \sa insertRow() */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
name|QWidget
modifier|*
name|label
parameter_list|,
name|QWidget
modifier|*
name|field
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|label
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
name|QWidget
modifier|*
name|label
parameter_list|,
name|QLayout
modifier|*
name|field
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|label
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      This overload automatically creates a QLabel behind the scenes     with \a labelText as its text. The \a field is set as the new     QLabel's \l{QLabel::setBuddy()}{buddy}. */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
specifier|const
name|QString
modifier|&
name|labelText
parameter_list|,
name|QWidget
modifier|*
name|field
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|labelText
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      This overload automatically creates a QLabel behind the scenes     with \a labelText as its text. */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
specifier|const
name|QString
modifier|&
name|labelText
parameter_list|,
name|QLayout
modifier|*
name|field
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|labelText
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Adds the specified \a widget at the end of this form layout. The     \a widget spans both columns. */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Adds the specified \a layout at the end of this form layout. The     \a layout spans both columns. */
end_comment
begin_function
DECL|function|addRow
name|void
name|QFormLayout
operator|::
name|addRow
parameter_list|(
name|QLayout
modifier|*
name|layout
parameter_list|)
block|{
name|insertRow
argument_list|(
operator|-
literal|1
argument_list|,
name|layout
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts a new row at position \a row in this form layout, with     the given \a label and \a field. If \a row is out of bounds, the     new row is added at the end.      \sa addRow() */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
name|QWidget
modifier|*
name|label
parameter_list|,
name|QWidget
modifier|*
name|field
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|row
operator|=
name|d
operator|->
name|insertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|d
operator|->
name|setWidget
argument_list|(
name|row
argument_list|,
name|LabelRole
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
name|d
operator|->
name|setWidget
argument_list|(
name|row
argument_list|,
name|FieldRole
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
name|QWidget
modifier|*
name|label
parameter_list|,
name|QLayout
modifier|*
name|field
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|row
operator|=
name|d
operator|->
name|insertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|d
operator|->
name|setWidget
argument_list|(
name|row
argument_list|,
name|LabelRole
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
name|d
operator|->
name|setLayout
argument_list|(
name|row
argument_list|,
name|FieldRole
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      This overload automatically creates a QLabel behind the scenes     with \a labelText as its text. The \a field is set as the new     QLabel's \l{QLabel::setBuddy()}{buddy}. */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QString
modifier|&
name|labelText
parameter_list|,
name|QWidget
modifier|*
name|field
parameter_list|)
block|{
name|QLabel
modifier|*
name|label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|labelText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|label
operator|=
operator|new
name|QLabel
argument_list|(
name|labelText
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|label
operator|->
name|setBuddy
argument_list|(
name|field
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|insertRow
argument_list|(
name|row
argument_list|,
name|label
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      This overload automatically creates a QLabel behind the scenes     with \a labelText as its text. */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
specifier|const
name|QString
modifier|&
name|labelText
parameter_list|,
name|QLayout
modifier|*
name|field
parameter_list|)
block|{
name|insertRow
argument_list|(
name|row
argument_list|,
name|labelText
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|new
name|QLabel
argument_list|(
name|labelText
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Inserts the specified \a widget at position \a row in this form     layout. The \a widget spans both columns. If \a row is out of     bounds, the widget is added at the end. */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFormLayout: Cannot add null field to %s"
argument_list|,
name|qPrintable
argument_list|(
name|objectName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|row
operator|=
name|d
operator|->
name|insertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWidget
argument_list|(
name|row
argument_list|,
name|SpanningRole
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Inserts the specified \a layout at position \a row in this form     layout. The \a layout spans both columns. If \a row is out of     bounds, the widget is added at the end. */
end_comment
begin_function
DECL|function|insertRow
name|void
name|QFormLayout
operator|::
name|insertRow
parameter_list|(
name|int
name|row
parameter_list|,
name|QLayout
modifier|*
name|layout
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layout
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFormLayout: Cannot add null field to %s"
argument_list|,
name|qPrintable
argument_list|(
name|objectName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|row
operator|=
name|d
operator|->
name|insertRow
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLayout
argument_list|(
name|row
argument_list|,
name|SpanningRole
argument_list|,
name|layout
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|addItem
name|void
name|QFormLayout
operator|::
name|addItem
parameter_list|(
name|QLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|row
init|=
name|d
operator|->
name|insertRow
argument_list|(
name|d
operator|->
name|m_matrix
operator|.
name|rowCount
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|setItem
argument_list|(
name|row
argument_list|,
name|FieldRole
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|count
name|int
name|QFormLayout
operator|::
name|count
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_things
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|itemAt
name|QLayoutItem
modifier|*
name|QFormLayout
operator|::
name|itemAt
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|QFormLayoutItem
modifier|*
name|formItem
init|=
name|d
operator|->
name|m_things
operator|.
name|value
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|formItem
operator|->
name|item
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|takeAt
name|QLayoutItem
modifier|*
name|QFormLayout
operator|::
name|takeAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
specifier|const
name|int
name|storageIndex
init|=
name|storageIndexFromLayoutItem
argument_list|(
name|d
operator|->
name|m_matrix
argument_list|,
name|d
operator|->
name|m_things
operator|.
name|value
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFormLayout::takeAt: Invalid index %d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|QFormLayoutPrivate
operator|::
name|ItemMatrix
operator|::
name|storageIndexToPosition
argument_list|(
name|storageIndex
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|QFormLayoutItem
modifier|*
name|item
init|=
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_things
operator|.
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|=
literal|0
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
comment|// grab ownership back from the QFormLayoutItem
name|QLayoutItem
modifier|*
name|i
init|=
name|item
operator|->
name|item
decl_stmt|;
name|item
operator|->
name|item
operator|=
literal|0
expr_stmt|;
operator|delete
name|item
expr_stmt|;
if|if
condition|(
name|QLayout
modifier|*
name|l
init|=
name|i
operator|->
name|layout
argument_list|()
condition|)
block|{
comment|// sanity check in case the user passed something weird to QObject::setParent()
if|if
condition|(
name|l
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
name|l
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|expandingDirections
name|Qt
operator|::
name|Orientations
name|QFormLayout
operator|::
name|expandingDirections
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
name|QFormLayoutPrivate
modifier|*
name|e
init|=
cast|const_cast
argument_list|<
name|QFormLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|e
operator|->
name|updateSizes
argument_list|()
expr_stmt|;
name|Qt
operator|::
name|Orientations
name|o
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|expandHorizontal
condition|)
name|o
operator|=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|expandVertical
condition|)
name|o
operator||=
name|Qt
operator|::
name|Vertical
expr_stmt|;
return|return
name|o
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hasHeightForWidth
name|bool
name|QFormLayout
operator|::
name|hasHeightForWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
name|QFormLayoutPrivate
modifier|*
name|e
init|=
cast|const_cast
argument_list|<
name|QFormLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|e
operator|->
name|updateSizes
argument_list|()
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|has_hfw
operator|||
name|rowWrapPolicy
argument_list|()
operator|==
name|WrapLongRows
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|heightForWidth
name|int
name|QFormLayout
operator|::
name|heightForWidth
parameter_list|(
name|int
name|width
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasHeightForWidth
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|leftMargin
decl_stmt|,
name|topMargin
decl_stmt|,
name|rightMargin
decl_stmt|,
name|bottomMargin
decl_stmt|;
name|getContentsMargins
argument_list|(
operator|&
name|leftMargin
argument_list|,
operator|&
name|topMargin
argument_list|,
operator|&
name|rightMargin
argument_list|,
operator|&
name|bottomMargin
argument_list|)
expr_stmt|;
name|int
name|targetWidth
init|=
name|width
operator|-
name|leftMargin
operator|-
name|rightMargin
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|haveHfwCached
argument_list|(
name|targetWidth
argument_list|)
condition|)
block|{
name|QFormLayoutPrivate
modifier|*
name|dat
init|=
cast|const_cast
argument_list|<
name|QFormLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|dat
operator|->
name|setupVerticalLayoutData
argument_list|(
name|targetWidth
argument_list|)
expr_stmt|;
name|dat
operator|->
name|setupHorizontalLayoutData
argument_list|(
name|targetWidth
argument_list|)
expr_stmt|;
name|dat
operator|->
name|recalcHFW
argument_list|(
name|targetWidth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetWidth
operator|==
name|d
operator|->
name|sh_width
condition|)
return|return
name|d
operator|->
name|hfw_sh_height
operator|+
name|topMargin
operator|+
name|bottomMargin
return|;
else|else
return|return
name|d
operator|->
name|hfw_height
operator|+
name|topMargin
operator|+
name|bottomMargin
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QFormLayout
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
operator|||
name|rect
operator|!=
name|geometry
argument_list|()
condition|)
block|{
name|QRect
name|cr
init|=
name|rect
decl_stmt|;
name|int
name|leftMargin
decl_stmt|,
name|topMargin
decl_stmt|,
name|rightMargin
decl_stmt|,
name|bottomMargin
decl_stmt|;
name|getContentsMargins
argument_list|(
operator|&
name|leftMargin
argument_list|,
operator|&
name|topMargin
argument_list|,
operator|&
name|rightMargin
argument_list|,
operator|&
name|bottomMargin
argument_list|)
expr_stmt|;
name|cr
operator|.
name|adjust
argument_list|(
operator|+
name|leftMargin
argument_list|,
operator|+
name|topMargin
argument_list|,
operator|-
name|rightMargin
argument_list|,
operator|-
name|bottomMargin
argument_list|)
expr_stmt|;
name|bool
name|hfw
init|=
name|hasHeightForWidth
argument_list|()
decl_stmt|;
name|d
operator|->
name|setupVerticalLayoutData
argument_list|(
name|cr
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|setupHorizontalLayoutData
argument_list|(
name|cr
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfw
operator|&&
operator|(
operator|!
name|d
operator|->
name|haveHfwCached
argument_list|(
name|cr
operator|.
name|width
argument_list|()
argument_list|)
operator|||
name|d
operator|->
name|hfwLayouts
operator|.
name|size
argument_list|()
operator|!=
name|d
operator|->
name|vLayoutCount
operator|)
condition|)
name|d
operator|->
name|recalcHFW
argument_list|(
name|cr
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfw
condition|)
block|{
name|qGeomCalc
argument_list|(
name|d
operator|->
name|hfwLayouts
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|vLayoutCount
argument_list|,
name|cr
operator|.
name|y
argument_list|()
argument_list|,
name|cr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|arrangeWidgets
argument_list|(
name|d
operator|->
name|hfwLayouts
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qGeomCalc
argument_list|(
name|d
operator|->
name|vLayouts
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|vLayoutCount
argument_list|,
name|cr
operator|.
name|y
argument_list|()
argument_list|,
name|cr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|arrangeWidgets
argument_list|(
name|d
operator|->
name|vLayouts
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
name|QLayout
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QFormLayout
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|prefSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QFormLayoutPrivate
modifier|*
name|dat
init|=
cast|const_cast
argument_list|<
name|QFormLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|dat
operator|->
name|calcSizeHints
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|prefSize
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|minimumSize
name|QSize
name|QFormLayout
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
comment|// ### fix minimumSize if hfw
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|minSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QFormLayoutPrivate
modifier|*
name|dat
init|=
cast|const_cast
argument_list|<
name|QFormLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|dat
operator|->
name|calcSizeHints
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|minSize
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|invalidate
name|void
name|QFormLayout
operator|::
name|invalidate
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|sizesDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|minSize
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|d
operator|->
name|prefSize
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|d
operator|->
name|formMaxWidth
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|hfw_width
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|sh_width
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|layoutWidth
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|hfw_sh_height
operator|=
operator|-
literal|1
expr_stmt|;
name|QLayout
operator|::
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of rows in the form.      \sa QLayout::count() */
end_comment
begin_function
DECL|function|rowCount
name|int
name|QFormLayout
operator|::
name|rowCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m_matrix
operator|.
name|rowCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the layout item in the given \a row with the specified \a     role (column). Returns 0 if there is no such item.      \sa QLayout::itemAt(), setItem() */
end_comment
begin_function
DECL|function|itemAt
name|QLayoutItem
modifier|*
name|QFormLayout
operator|::
name|itemAt
parameter_list|(
name|int
name|row
parameter_list|,
name|ItemRole
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|row
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|m_matrix
operator|.
name|rowCount
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|role
condition|)
block|{
case|case
name|SpanningRole
case|:
if|if
condition|(
name|QFormLayoutItem
modifier|*
name|item
init|=
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
literal|1
argument_list|)
condition|)
if|if
condition|(
name|item
operator|->
name|fullRow
condition|)
return|return
name|item
operator|->
name|item
return|;
break|break;
case|case
name|LabelRole
case|:
case|case
name|FieldRole
case|:
if|if
condition|(
name|QFormLayoutItem
modifier|*
name|item
init|=
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
operator|(
name|role
operator|==
name|LabelRole
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
condition|)
return|return
name|item
operator|->
name|item
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Retrieves the row and role (column) of the item at the specified     \a index. If \a index is out of bounds, *\a rowPtr is set to -1;     otherwise the row is stored in *\a rowPtr and the role is stored     in *\a rolePtr.      \sa itemAt(), count(), getLayoutPosition(), getWidgetPosition() */
end_comment
begin_function
DECL|function|getItemPosition
name|void
name|QFormLayout
operator|::
name|getItemPosition
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|ItemRole
modifier|*
name|rolePtr
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|col
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|row
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|storageIndex
init|=
name|storageIndexFromLayoutItem
argument_list|(
name|d
operator|->
name|m_matrix
argument_list|,
name|d
operator|->
name|m_things
operator|.
name|value
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageIndex
operator|!=
operator|-
literal|1
condition|)
name|QFormLayoutPrivate
operator|::
name|ItemMatrix
operator|::
name|storageIndexToPosition
argument_list|(
name|storageIndex
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowPtr
condition|)
operator|*
name|rowPtr
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|rolePtr
operator|&&
name|col
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|bool
name|spanning
init|=
name|col
operator|==
literal|1
operator|&&
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
operator|->
name|fullRow
decl_stmt|;
if|if
condition|(
name|spanning
condition|)
block|{
operator|*
name|rolePtr
operator|=
name|SpanningRole
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rolePtr
operator|=
name|ItemRole
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Retrieves the row and role (column) of the specified child \a     layout. If \a layout is not in the form layout, *\a rowPtr is set     to -1; otherwise the row is stored in *\a rowPtr and the role is stored     in *\a rolePtr. */
end_comment
begin_function
DECL|function|getLayoutPosition
name|void
name|QFormLayout
operator|::
name|getLayoutPosition
parameter_list|(
name|QLayout
modifier|*
name|layout
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|ItemRole
modifier|*
name|rolePtr
parameter_list|)
specifier|const
block|{
name|int
name|n
init|=
name|count
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|itemAt
argument_list|(
name|index
argument_list|)
operator|==
name|layout
condition|)
break|break;
operator|++
name|index
expr_stmt|;
block|}
name|getItemPosition
argument_list|(
name|index
argument_list|,
name|rowPtr
argument_list|,
name|rolePtr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Retrieves the row and role (column) of the specified \a widget in     the layout. If \a widget is not in the layout, *\a rowPtr is set     to -1; otherwise the row is stored in *\a rowPtr and the role is stored     in *\a rolePtr.      \sa getItemPosition(), itemAt() */
end_comment
begin_function
DECL|function|getWidgetPosition
name|void
name|QFormLayout
operator|::
name|getWidgetPosition
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|int
modifier|*
name|rowPtr
parameter_list|,
name|ItemRole
modifier|*
name|rolePtr
parameter_list|)
specifier|const
block|{
name|getItemPosition
argument_list|(
name|indexOf
argument_list|(
name|widget
argument_list|)
argument_list|,
name|rowPtr
argument_list|,
name|rolePtr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// ### eliminate labelForField()
end_comment
begin_comment
comment|/*!     Returns the label associated with the given \a field.      \sa itemAt() */
end_comment
begin_function
DECL|function|labelForField
name|QWidget
modifier|*
name|QFormLayout
operator|::
name|labelForField
parameter_list|(
name|QWidget
modifier|*
name|field
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|row
decl_stmt|;
name|ItemRole
name|role
decl_stmt|;
name|getWidgetPosition
argument_list|(
name|field
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
operator|-
literal|1
operator|&&
name|role
operator|==
name|FieldRole
condition|)
block|{
if|if
condition|(
name|QFormLayoutItem
modifier|*
name|label
init|=
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|LabelRole
argument_list|)
condition|)
return|return
name|label
operator|->
name|widget
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|labelForField
name|QWidget
modifier|*
name|QFormLayout
operator|::
name|labelForField
parameter_list|(
name|QLayout
modifier|*
name|field
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|row
decl_stmt|;
name|ItemRole
name|role
decl_stmt|;
name|getLayoutPosition
argument_list|(
name|field
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
operator|-
literal|1
operator|&&
name|role
operator|==
name|FieldRole
condition|)
block|{
if|if
condition|(
name|QFormLayoutItem
modifier|*
name|label
init|=
name|d
operator|->
name|m_matrix
argument_list|(
name|row
argument_list|,
name|LabelRole
argument_list|)
condition|)
return|return
name|label
operator|->
name|widget
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::fieldGrowthPolicy     \brief the way in which the form's fields grow      The default value depends on the widget or application style. For     QMacStyle, the default is FieldsStayAtSizeHint; for QCommonStyle     derived styles (like Plastique and Windows), the default     is ExpandingFieldsGrow; for Qt Extended styles, the default is     AllNonFixedFieldsGrow.      If none of the fields can grow and the form is resized, extra     space is distributed according to the current     \l{formAlignment}{form alignment}.      \sa formAlignment, rowWrapPolicy */
end_comment
begin_function
DECL|function|setFieldGrowthPolicy
name|void
name|QFormLayout
operator|::
name|setFieldGrowthPolicy
parameter_list|(
name|FieldGrowthPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|FieldGrowthPolicy
argument_list|(
name|d
operator|->
name|fieldGrowthPolicy
argument_list|)
operator|!=
name|policy
condition|)
block|{
name|d
operator|->
name|fieldGrowthPolicy
operator|=
name|policy
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fieldGrowthPolicy
name|QFormLayout
operator|::
name|FieldGrowthPolicy
name|QFormLayout
operator|::
name|fieldGrowthPolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fieldGrowthPolicy
operator|==
name|DefaultFieldGrowthPolicy
condition|)
block|{
return|return
name|QFormLayout
operator|::
name|FieldGrowthPolicy
argument_list|(
name|d
operator|->
name|getStyle
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_FormLayoutFieldGrowthPolicy
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QFormLayout
operator|::
name|FieldGrowthPolicy
argument_list|(
name|d
operator|->
name|fieldGrowthPolicy
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::rowWrapPolicy     \brief the way in which the form's rows wrap      The default value depends on the widget or application style. For     Qt Extended styles, the default is WrapLongRows;     for the other styles, the default is DontWrapRows.      If you want to display each label above its associated field     (instead of next to it), set this property to WrapAllRows.      \sa fieldGrowthPolicy */
end_comment
begin_function
DECL|function|setRowWrapPolicy
name|void
name|QFormLayout
operator|::
name|setRowWrapPolicy
parameter_list|(
name|RowWrapPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|RowWrapPolicy
argument_list|(
name|d
operator|->
name|rowWrapPolicy
argument_list|)
operator|!=
name|policy
condition|)
block|{
name|d
operator|->
name|rowWrapPolicy
operator|=
name|policy
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|rowWrapPolicy
name|QFormLayout
operator|::
name|RowWrapPolicy
name|QFormLayout
operator|::
name|rowWrapPolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rowWrapPolicy
operator|==
name|DefaultRowWrapPolicy
condition|)
block|{
return|return
name|QFormLayout
operator|::
name|RowWrapPolicy
argument_list|(
name|d
operator|->
name|getStyle
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_FormLayoutWrapPolicy
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QFormLayout
operator|::
name|RowWrapPolicy
argument_list|(
name|d
operator|->
name|rowWrapPolicy
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::labelAlignment     \brief the horizontal alignment of the labels      The default value depends on the widget or application style. For     QCommonStyle derived styles, except for QPlastiqueStyle, the     default is Qt::AlignLeft; for the other styles, the default is     Qt::AlignRight.      \sa formAlignment */
end_comment
begin_function
DECL|function|setLabelAlignment
name|void
name|QFormLayout
operator|::
name|setLabelAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|labelAlignment
operator|!=
name|alignment
condition|)
block|{
name|d
operator|->
name|labelAlignment
operator|=
name|alignment
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|labelAlignment
name|Qt
operator|::
name|Alignment
name|QFormLayout
operator|::
name|labelAlignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|labelAlignment
condition|)
block|{
return|return
name|Qt
operator|::
name|Alignment
argument_list|(
name|d
operator|->
name|getStyle
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_FormLayoutLabelAlignment
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|d
operator|->
name|labelAlignment
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::formAlignment     \brief the alignment of the form layout's contents within the layout's geometry      The default value depends on the widget or application style. For     QMacStyle, the default is Qt::AlignHCenter | Qt::AlignTop; for the     other styles, the default is Qt::AlignLeft | Qt::AlignTop.      \sa labelAlignment, rowWrapPolicy */
end_comment
begin_function
DECL|function|setFormAlignment
name|void
name|QFormLayout
operator|::
name|setFormAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|formAlignment
operator|!=
name|alignment
condition|)
block|{
name|d
operator|->
name|formAlignment
operator|=
name|alignment
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|formAlignment
name|Qt
operator|::
name|Alignment
name|QFormLayout
operator|::
name|formAlignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|formAlignment
condition|)
block|{
return|return
name|Qt
operator|::
name|Alignment
argument_list|(
name|d
operator|->
name|getStyle
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_FormLayoutFormAlignment
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|d
operator|->
name|formAlignment
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::horizontalSpacing     \brief the spacing between widgets that are laid out side by side      By default, if no value is explicitly set, the layout's horizontal     spacing is inherited from the parent layout, or from the style settings     for the parent widget.      \sa verticalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing} */
end_comment
begin_function
DECL|function|setHorizontalSpacing
name|void
name|QFormLayout
operator|::
name|setHorizontalSpacing
parameter_list|(
name|int
name|spacing
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|spacing
operator|!=
name|d
operator|->
name|hSpacing
condition|)
block|{
name|d
operator|->
name|hSpacing
operator|=
name|spacing
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|horizontalSpacing
name|int
name|QFormLayout
operator|::
name|horizontalSpacing
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hSpacing
operator|>=
literal|0
condition|)
block|{
return|return
name|d
operator|->
name|hSpacing
return|;
block|}
else|else
block|{
return|return
name|qSmartSpacing
argument_list|(
name|this
argument_list|,
name|QStyle
operator|::
name|PM_LayoutHorizontalSpacing
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QFormLayout::verticalSpacing     \brief the spacing between widgets that are laid out vertically      By default, if no value is explicitly set, the layout's vertical spacing is     inherited from the parent layout, or from the style settings for the parent     widget.      \sa horizontalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing} */
end_comment
begin_function
DECL|function|setVerticalSpacing
name|void
name|QFormLayout
operator|::
name|setVerticalSpacing
parameter_list|(
name|int
name|spacing
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|spacing
operator|!=
name|d
operator|->
name|vSpacing
condition|)
block|{
name|d
operator|->
name|vSpacing
operator|=
name|spacing
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|verticalSpacing
name|int
name|QFormLayout
operator|::
name|verticalSpacing
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QFormLayout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|vSpacing
operator|>=
literal|0
condition|)
block|{
return|return
name|d
operator|->
name|vSpacing
return|;
block|}
else|else
block|{
return|return
name|qSmartSpacing
argument_list|(
name|this
argument_list|,
name|QStyle
operator|::
name|PM_LayoutVerticalSpacing
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function sets both the vertical and horizontal spacing to     \a spacing.      \sa setVerticalSpacing(), setHorizontalSpacing() */
end_comment
begin_function
DECL|function|setSpacing
name|void
name|QFormLayout
operator|::
name|setSpacing
parameter_list|(
name|int
name|spacing
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|vSpacing
operator|=
name|d
operator|->
name|hSpacing
operator|=
name|spacing
expr_stmt|;
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the vertical spacing is equal to the horizontal spacing,     this function returns that value; otherwise it returns -1.      \sa setSpacing(), verticalSpacing(), horizontalSpacing() */
end_comment
begin_function
DECL|function|spacing
name|int
name|QFormLayout
operator|::
name|spacing
parameter_list|()
specifier|const
block|{
name|int
name|hSpacing
init|=
name|horizontalSpacing
argument_list|()
decl_stmt|;
if|if
condition|(
name|hSpacing
operator|==
name|verticalSpacing
argument_list|()
condition|)
block|{
return|return
name|hSpacing
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|arrangeWidgets
name|void
name|QFormLayoutPrivate
operator|::
name|arrangeWidgets
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QLayoutStruct
argument_list|>
modifier|&
name|layouts
parameter_list|,
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|rr
init|=
name|m_matrix
operator|.
name|rowCount
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|LayoutDirection
name|layoutDirection
init|=
name|w
condition|?
name|w
operator|->
name|layoutDirection
argument_list|()
else|:
name|QApplication
operator|::
name|layoutDirection
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|Alignment
name|formAlignment
init|=
name|fixedAlignment
argument_list|(
name|q
operator|->
name|formAlignment
argument_list|()
argument_list|,
name|layoutDirection
argument_list|)
decl_stmt|;
name|int
name|leftOffset
init|=
literal|0
decl_stmt|;
name|int
name|delta
init|=
name|rect
operator|.
name|width
argument_list|()
operator|-
name|formMaxWidth
decl_stmt|;
if|if
condition|(
name|formAlignment
operator|&
operator|(
name|Qt
operator|::
name|AlignHCenter
operator||
name|Qt
operator|::
name|AlignRight
operator|)
operator|&&
name|delta
operator|>
literal|0
condition|)
block|{
name|leftOffset
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|formAlignment
operator|&
name|Qt
operator|::
name|AlignHCenter
condition|)
name|leftOffset
operator|>>=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rr
condition|;
operator|++
name|i
control|)
block|{
name|QFormLayoutItem
modifier|*
name|label
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QFormLayoutItem
modifier|*
name|field
init|=
name|m_matrix
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|int
name|height
init|=
name|layouts
operator|.
name|at
argument_list|(
name|label
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|label
operator|->
name|expandingDirections
argument_list|()
operator|&
name|Qt
operator|::
name|Vertical
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*                     If the field on the right-hand side is tall,                     we want the label to be top-aligned, but not too                     much. So we introduce a 7 / 4 factor so that it                     gets some extra pixels at the top.                 */
name|height
operator|=
name|qMin
argument_list|(
name|height
argument_list|,
name|qMin
argument_list|(
name|label
operator|->
name|sizeHint
operator|.
name|height
argument_list|()
operator|*
literal|7
operator|/
literal|4
argument_list|,
name|label
operator|->
name|maxSize
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QSize
name|sz
argument_list|(
name|qMin
argument_list|(
name|label
operator|->
name|layoutWidth
argument_list|,
name|label
operator|->
name|sizeHint
operator|.
name|width
argument_list|()
argument_list|)
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|leftOffset
operator|+
name|rect
operator|.
name|x
argument_list|()
operator|+
name|label
operator|->
name|layoutPos
decl_stmt|;
if|if
condition|(
name|fixedAlignment
argument_list|(
name|q
operator|->
name|labelAlignment
argument_list|()
argument_list|,
name|layoutDirection
argument_list|)
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|x
operator|+=
name|label
operator|->
name|layoutWidth
operator|-
name|sz
operator|.
name|width
argument_list|()
expr_stmt|;
name|QPoint
name|p
argument_list|(
name|x
argument_list|,
name|layouts
operator|.
name|at
argument_list|(
name|label
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|pos
argument_list|)
decl_stmt|;
comment|// ### expansion& sizepolicy stuff
name|label
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|layoutDirection
argument_list|,
name|rect
argument_list|,
name|QRect
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
condition|)
block|{
name|QSize
name|sz
argument_list|(
name|field
operator|->
name|layoutWidth
argument_list|,
name|layouts
operator|.
name|at
argument_list|(
name|field
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|size
argument_list|)
decl_stmt|;
name|QPoint
name|p
argument_list|(
name|field
operator|->
name|layoutPos
operator|+
name|leftOffset
operator|+
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|layouts
operator|.
name|at
argument_list|(
name|field
operator|->
name|vLayoutIndex
argument_list|)
operator|.
name|pos
argument_list|)
decl_stmt|;
comment|/*             if ((field->widget()&& field->widget()->sizePolicy().horizontalPolicy()& (QSizePolicy::GrowFlag | QSizePolicy::ExpandFlag | QSizePolicy::IgnoreFlag))                 || (field->layout()&& sz.width()< field->maxSize.width())) {                 sz.rwidth() = field->layoutWidth;             } */
if|if
condition|(
name|field
operator|->
name|maxSize
operator|.
name|isValid
argument_list|()
condition|)
name|sz
operator|=
name|sz
operator|.
name|boundedTo
argument_list|(
name|field
operator|->
name|maxSize
argument_list|)
expr_stmt|;
name|field
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|layoutDirection
argument_list|,
name|rect
argument_list|,
name|QRect
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the widget in the given \a row for the given \a role to \a widget, extending the     layout with empty rows if necessary.      If the cell is already occupied, the \a widget is not inserted and an error message is     sent to the console.      \b{Note:} For most applications, addRow() or insertRow() should be used instead of setWidget().      \sa setLayout() */
end_comment
begin_function
DECL|function|setWidget
name|void
name|QFormLayout
operator|::
name|setWidget
parameter_list|(
name|int
name|row
parameter_list|,
name|ItemRole
name|role
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|rowCnt
init|=
name|rowCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|row
operator|>=
name|rowCnt
condition|)
name|d
operator|->
name|insertRows
argument_list|(
name|rowCnt
argument_list|,
name|row
operator|-
name|rowCnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWidget
argument_list|(
name|row
argument_list|,
name|role
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the sub-layout in the given \a row for the given \a role to \a layout, extending the     form layout with empty rows if necessary.      If the cell is already occupied, the \a layout is not inserted and an error message is     sent to the console.      \b{Note:} For most applications, addRow() or insertRow() should be used instead of setLayout().      \sa setWidget() */
end_comment
begin_function
DECL|function|setLayout
name|void
name|QFormLayout
operator|::
name|setLayout
parameter_list|(
name|int
name|row
parameter_list|,
name|ItemRole
name|role
parameter_list|,
name|QLayout
modifier|*
name|layout
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|rowCnt
init|=
name|rowCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|row
operator|>=
name|rowCnt
condition|)
name|d
operator|->
name|insertRows
argument_list|(
name|rowCnt
argument_list|,
name|row
operator|-
name|rowCnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLayout
argument_list|(
name|row
argument_list|,
name|role
argument_list|,
name|layout
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the item in the given \a row for the given \a role to \a item, extending the     layout with empty rows if necessary.      If the cell is already occupied, the \a item is not inserted and an error message is     sent to the console.     The \a item spans both columns.      \warning Do not use this function to add child layouts or child     widget items. Use setLayout() or setWidget() instead.      \sa setLayout() */
end_comment
begin_function
DECL|function|setItem
name|void
name|QFormLayout
operator|::
name|setItem
parameter_list|(
name|int
name|row
parameter_list|,
name|ItemRole
name|role
parameter_list|,
name|QLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|int
name|rowCnt
init|=
name|rowCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|row
operator|>=
name|rowCnt
condition|)
name|d
operator|->
name|insertRows
argument_list|(
name|rowCnt
argument_list|,
name|row
operator|-
name|rowCnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|setItem
argument_list|(
name|row
argument_list|,
name|role
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      \internal  */
end_comment
begin_function
DECL|function|resetFieldGrowthPolicy
name|void
name|QFormLayout
operator|::
name|resetFieldGrowthPolicy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|fieldGrowthPolicy
operator|=
name|DefaultFieldGrowthPolicy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      \internal  */
end_comment
begin_function
DECL|function|resetRowWrapPolicy
name|void
name|QFormLayout
operator|::
name|resetRowWrapPolicy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|rowWrapPolicy
operator|=
name|DefaultRowWrapPolicy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      \internal  */
end_comment
begin_function
DECL|function|resetFormAlignment
name|void
name|QFormLayout
operator|::
name|resetFormAlignment
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|formAlignment
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      \internal  */
end_comment
begin_function
DECL|function|resetLabelAlignment
name|void
name|QFormLayout
operator|::
name|resetLabelAlignment
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QFormLayout
argument_list|)
expr_stmt|;
name|d
operator|->
name|labelAlignment
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|void QFormLayout::dump() const {     Q_D(const QFormLayout);     for (int i = 0; i< rowCount(); ++i) {         for (int j = 0; j< 2; ++j) {             qDebug("m_matrix(%d, %d) = %p", i, j, d->m_matrix(i, j));         }     }     for (int i = 0; i< d->m_things.count(); ++i)         qDebug("m_things[%d] = %p", i, d->m_things.at(i)); }
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
