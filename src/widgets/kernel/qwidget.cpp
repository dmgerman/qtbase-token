begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qbrush.h"
end_include
begin_include
include|#
directive|include
file|"qcursor.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qmenu.h"
end_include
begin_include
include|#
directive|include
file|"qmetaobject.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qpointer.h"
end_include
begin_include
include|#
directive|include
file|"qstack.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstylefactory.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|"qstylehints.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"qt_mac_p.h"
end_include
begin_include
include|#
directive|include
file|"qt_cocoa_helpers_mac_p.h"
end_include
begin_include
include|#
directive|include
file|"qmainwindow.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbar.h"
end_include
begin_include
include|#
directive|include
file|<private/qmainwindowlayout_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qpa/qplatformwindow.h>
end_include
begin_include
include|#
directive|include
file|"private/qwidgetwindow_qpa_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qtooltip.h"
end_include
begin_include
include|#
directive|include
file|"qwhatsthis.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstyle_p.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicseffect_p.h>
end_include
begin_include
include|#
directive|include
file|<qbackingstore.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidgetbackingstore_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qpaintengine_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qwindow_p.h>
end_include
begin_include
include|#
directive|include
file|"qaction_p.h"
end_include
begin_include
include|#
directive|include
file|"qlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qgraphicsproxywidget.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"private/qgraphicsproxywidget_p.h"
end_include
begin_include
include|#
directive|include
file|"QtWidgets/qabstractscrollarea.h"
end_include
begin_include
include|#
directive|include
file|"private/qabstractscrollarea_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qgesturemanager_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_include
include|#
directive|include
file|"qtabwidget.h"
end_include
begin_comment
comment|// Needed in inTabWidget()
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_KEYPAD_NAVIGATION
end_comment
begin_comment
comment|// widget/widget data creation count
end_comment
begin_comment
comment|//#define QWIDGET_EXTRA_DEBUG
end_comment
begin_comment
comment|//#define ALIEN_DEBUG
end_comment
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_enable_backingstore
specifier|static
name|bool
name|qt_enable_backingstore
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_X11
end_ifdef
begin_comment
comment|// for compatibility with Qt 4.0
end_comment
begin_function
DECL|function|qt_x11_set_global_double_buffer
name|Q_WIDGETS_EXPORT
name|void
name|qt_x11_set_global_double_buffer
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|qt_enable_backingstore
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_decl_stmt
DECL|variable|qt_mac_clearDirtyOnWidgetInsideDrawWidget
name|bool
name|qt_mac_clearDirtyOnWidgetInsideDrawWidget
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qRectIntersects
specifier|static
specifier|inline
name|bool
name|qRectIntersects
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r1
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r2
parameter_list|)
block|{
return|return
operator|(
name|qMax
argument_list|(
name|r1
operator|.
name|left
argument_list|()
argument_list|,
name|r2
operator|.
name|left
argument_list|()
argument_list|)
operator|<=
name|qMin
argument_list|(
name|r1
operator|.
name|right
argument_list|()
argument_list|,
name|r2
operator|.
name|right
argument_list|()
argument_list|)
operator|&&
name|qMax
argument_list|(
name|r1
operator|.
name|top
argument_list|()
argument_list|,
name|r2
operator|.
name|top
argument_list|()
argument_list|)
operator|<=
name|qMin
argument_list|(
name|r1
operator|.
name|bottom
argument_list|()
argument_list|,
name|r2
operator|.
name|bottom
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|hasBackingStoreSupport
specifier|static
specifier|inline
name|bool
name|hasBackingStoreSupport
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_define
DECL|macro|QT_NO_PAINT_DEBUG
define|#
directive|define
name|QT_NO_PAINT_DEBUG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|extern
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
parameter_list|,
name|QEvent
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// qapplication.cpp
end_comment
begin_decl_stmt
specifier|extern
name|QDesktopWidget
modifier|*
name|qt_desktopWidget
decl_stmt|;
end_decl_stmt
begin_comment
comment|// qapplication.cpp
end_comment
begin_comment
comment|/*!     \internal     \class QWidgetBackingStoreTracker     \brief Class which allows tracking of which widgets are using a given backing store      QWidgetBackingStoreTracker is a thin wrapper around a QWidgetBackingStore pointer,     which maintains a list of the QWidgets which are currently using the backing     store.  This list is modified via the registerWidget and unregisterWidget functions.  */
end_comment
begin_constructor
DECL|function|QWidgetBackingStoreTracker
name|QWidgetBackingStoreTracker
operator|::
name|QWidgetBackingStoreTracker
parameter_list|()
member_init_list|:
name|m_ptr
argument_list|(
literal|0
argument_list|)
block|{  }
end_constructor
begin_destructor
DECL|function|~QWidgetBackingStoreTracker
name|QWidgetBackingStoreTracker
operator|::
name|~
name|QWidgetBackingStoreTracker
parameter_list|()
block|{
operator|delete
name|m_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal     Destroy the contained QWidgetBackingStore, if not null, and clear the list of     widgets using the backing store, then create a new QWidgetBackingStore, providing     the QWidget.  */
end_comment
begin_function
DECL|function|create
name|void
name|QWidgetBackingStoreTracker
operator|::
name|create
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|destroy
argument_list|()
expr_stmt|;
name|m_ptr
operator|=
operator|new
name|QWidgetBackingStore
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Destroy the contained QWidgetBackingStore, if not null, and clear the list of     widgets using the backing store.  */
end_comment
begin_function
DECL|function|destroy
name|void
name|QWidgetBackingStoreTracker
operator|::
name|destroy
parameter_list|()
block|{
operator|delete
name|m_ptr
expr_stmt|;
name|m_ptr
operator|=
literal|0
expr_stmt|;
name|m_widgets
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Add the widget to the list of widgets currently using the backing store.     If the widget was already in the list, this function is a no-op.  */
end_comment
begin_function
DECL|function|registerWidget
name|void
name|QWidgetBackingStoreTracker
operator|::
name|registerWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m_ptr
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|w
operator|->
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qt_widget_private
argument_list|(
name|w
argument_list|)
operator|->
name|maybeBackingStore
argument_list|()
operator|==
name|m_ptr
argument_list|)
expr_stmt|;
name|m_widgets
operator|.
name|insert
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Remove the widget from the list of widgets currently using the backing store.     If the widget was in the list, and removing it causes the list to be empty,     the backing store is deleted.     If the widget was not in the list, this function is a no-op.  */
end_comment
begin_function
DECL|function|unregisterWidget
name|void
name|QWidgetBackingStoreTracker
operator|::
name|unregisterWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
if|if
condition|(
name|m_widgets
operator|.
name|remove
argument_list|(
name|w
argument_list|)
operator|&&
name|m_widgets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|delete
name|m_ptr
expr_stmt|;
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Recursively remove widget and all of its descendents.  */
end_comment
begin_function
DECL|function|unregisterWidgetSubtree
name|void
name|QWidgetBackingStoreTracker
operator|::
name|unregisterWidgetSubtree
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|unregisterWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QObject
modifier|*
name|child
decl|,
name|widget
operator|->
name|children
argument_list|()
control|)
if|if
condition|(
name|QWidget
modifier|*
name|childWidget
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
condition|)
name|unregisterWidgetSubtree
argument_list|(
name|childWidget
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QWidgetPrivate
name|QWidgetPrivate
operator|::
name|QWidgetPrivate
parameter_list|(
name|int
name|version
parameter_list|)
member_init_list|:
name|QObjectPrivate
argument_list|(
name|version
argument_list|)
member_init_list|,
name|extra
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|focus_next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|focus_prev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|focus_child
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|layout
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|needsFlush
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|redirectDev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|widgetItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|extraPaintEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|polished
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|graphicsEffect
argument_list|(
literal|0
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
member_init_list|,
name|imHints
argument_list|(
name|Qt
operator|::
name|ImhNone
argument_list|)
endif|#
directive|endif
member_init_list|,
name|inheritedFontResolveMask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|inheritedPaletteResolveMask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|leftmargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|topmargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|rightmargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bottommargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|leftLayoutItemMargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|topLayoutItemMargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|rightLayoutItemMargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bottomLayoutItemMargin
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hd
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|size_policy
argument_list|(
name|QSizePolicy
operator|::
name|Preferred
argument_list|,
name|QSizePolicy
operator|::
name|Preferred
argument_list|)
member_init_list|,
name|fg_role
argument_list|(
name|QPalette
operator|::
name|NoRole
argument_list|)
member_init_list|,
name|bg_role
argument_list|(
name|QPalette
operator|::
name|NoRole
argument_list|)
member_init_list|,
name|dirtyOpaqueChildren
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|isOpaque
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|inDirtyList
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|isScrolled
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|isMoved
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|usesDoubleBufferedGLContext
argument_list|(
literal|0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_IM
member_init_list|,
name|inheritsInputMethodHints
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
member_init_list|,
name|noPaintOnScreen
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
member_init_list|,
name|picture
argument_list|(
literal|0
argument_list|)
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
member_init_list|,
name|nativeGesturePanEnabled
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
member_init_list|,
name|needWindowChange
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|window_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|qd_hd
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|qApp
condition|)
block|{
name|qFatal
argument_list|(
literal|"QWidget: Must construct a QApplication before a QPaintDevice"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|version
operator|!=
name|QObjectPrivateVersion
condition|)
name|qFatal
argument_list|(
literal|"Cannot mix incompatible Qt libraries"
argument_list|)
expr_stmt|;
name|isWidget
operator|=
literal|true
expr_stmt|;
name|memset
argument_list|(
name|high_attributes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|high_attributes
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|drawRectOriginalAdded
operator|=
literal|false
expr_stmt|;
name|originalDrawMethod
operator|=
literal|true
expr_stmt|;
name|changeMethods
operator|=
literal|false
expr_stmt|;
name|isInUnifiedToolbar
operator|=
literal|false
expr_stmt|;
name|unifiedSurface
operator|=
literal|0
expr_stmt|;
name|toolbar_ancestor
operator|=
literal|0
expr_stmt|;
name|flushRequested
operator|=
literal|false
expr_stmt|;
name|touchEventsEnabled
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|// Q_WS_MAC
ifdef|#
directive|ifdef
name|QWIDGET_EXTRA_DEBUG
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"widgets"
operator|<<
operator|++
name|count
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QWidgetPrivate
name|QWidgetPrivate
operator|::
name|~
name|QWidgetPrivate
parameter_list|()
block|{
if|if
condition|(
name|widgetItem
condition|)
name|widgetItem
operator|->
name|wid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|deleteExtra
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
operator|delete
name|graphicsEffect
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|scrollChildren
name|void
name|QWidgetPrivate
operator|::
name|scrollChildren
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|children
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// scroll children
name|QPoint
name|pd
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
decl_stmt|;
name|QObjectList
name|childObjects
init|=
name|q
operator|->
name|children
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childObjects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// move all children
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childObjects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QPoint
name|oldp
init|=
name|w
operator|->
name|pos
argument_list|()
decl_stmt|;
name|QRect
name|r
argument_list|(
name|w
operator|->
name|pos
argument_list|()
operator|+
name|pd
argument_list|,
name|w
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|w
operator|->
name|data
operator|->
name|crect
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setWSGeometry
argument_list|()
expr_stmt|;
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
name|QMoveEvent
name|e
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|,
name|oldp
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|updateWidgetTransform
name|void
name|QWidgetPrivate
operator|::
name|updateWidgetTransform
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|qGuiApp
operator|->
name|focusObject
argument_list|()
condition|)
block|{
name|QTransform
name|t
decl_stmt|;
name|QPoint
name|p
init|=
name|q
operator|->
name|mapTo
argument_list|(
name|q
operator|->
name|topLevelWidget
argument_list|()
argument_list|,
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|.
name|translate
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|setInputItemTransform
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_decl_stmt
DECL|member|editingWidget
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|QWidgetPrivate
operator|::
name|editingWidget
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Returns true if this widget currently has edit focus; otherwise false.      This feature is only available in Qt for Embedded Linux.      \sa setEditFocus(), QApplication::keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|hasEditFocus
name|bool
name|QWidget
operator|::
name|hasEditFocus
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|w
operator|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
return|return
name|QWidgetPrivate
operator|::
name|editingWidget
operator|==
name|w
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QWidget::setEditFocus(bool enable)      If \a enable is true, make this widget have edit focus, in which     case Qt::Key_Up and Qt::Key_Down will be delivered to the widget     normally; otherwise, Qt::Key_Up and Qt::Key_Down are used to     change focus.      This feature is only available in Qt for Embedded Linux.      \sa hasEditFocus(), QApplication::keypadNavigationEnabled() */
end_comment
begin_function
DECL|function|setEditFocus
name|void
name|QWidget
operator|::
name|setEditFocus
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|QWidget
modifier|*
name|f
init|=
name|this
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|f
operator|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
if|if
condition|(
name|QWidgetPrivate
operator|::
name|editingWidget
operator|&&
name|QWidgetPrivate
operator|::
name|editingWidget
operator|!=
name|f
condition|)
name|QWidgetPrivate
operator|::
name|editingWidget
operator|->
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|!
name|f
operator|->
name|hasFocus
argument_list|()
condition|)
name|f
operator|->
name|setFocus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|on
operator|&&
operator|!
name|QWidgetPrivate
operator|::
name|editingWidget
operator|)
operator|||
operator|(
name|on
operator|&&
name|QWidgetPrivate
operator|::
name|editingWidget
operator|==
name|f
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|on
operator|&&
name|QWidgetPrivate
operator|::
name|editingWidget
operator|==
name|f
condition|)
block|{
name|QWidgetPrivate
operator|::
name|editingWidget
operator|=
literal|0
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|LeaveEditFocus
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|f
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|f
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|on
condition|)
block|{
name|QWidgetPrivate
operator|::
name|editingWidget
operator|=
name|f
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|EnterEditFocus
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|f
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|f
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \property QWidget::autoFillBackground     \brief whether the widget background is filled automatically     \since 4.1      If enabled, this property will cause Qt to fill the background of the     widget before invoking the paint event. The color used is defined by the     QPalette::Window color role from the widget's \l{QPalette}{palette}.      In addition, Windows are always filled with QPalette::Window, unless the     WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.      This property cannot be turned off (i.e., set to false) if a widget's     parent has a static gradient for its background.      \warning Use this property with caution in conjunction with     \l{Qt Style Sheets}. When a widget has a style sheet with a valid     background or a border-image, this property is automatically disabled.      By default, this property is false.      \sa Qt::WA_OpaquePaintEvent, Qt::WA_NoSystemBackground,     {QWidget#Transparency and Double Buffering}{Transparency and Double Buffering} */
end_comment
begin_function
DECL|function|autoFillBackground
name|bool
name|QWidget
operator|::
name|autoFillBackground
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|autoFillBackground
return|;
block|}
end_function
begin_function
DECL|function|setAutoFillBackground
name|void
name|QWidget
operator|::
name|setAutoFillBackground
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
condition|)
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|->
name|autoFillBackground
operator|==
name|enabled
condition|)
return|return;
name|d
operator|->
name|extra
operator|->
name|autoFillBackground
operator|=
name|enabled
expr_stmt|;
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QWidget     \brief The QWidget class is the base class of all user interface objects.      \ingroup basicwidgets     \inmodule QtWidgets      The widget is the atom of the user interface: it receives mouse, keyboard     and other events from the window system, and paints a representation of     itself on the screen. Every widget is rectangular, and they are sorted in a     Z-order. A widget is clipped by its parent and by the widgets in front of     it.      A widget that is not embedded in a parent widget is called a window.     Usually, windows have a frame and a title bar, although it is also possible     to create windows without such decoration using suitable     \l{Qt::WindowFlags}{window flags}). In Qt, QMainWindow and the various     subclasses of QDialog are the most common window types.      Every widget's constructor accepts one or two standard arguments:      \list 1         \li  \c{QWidget *parent = 0} is the parent of the new widget. If it is 0             (the default), the new widget will be a window. If not, it will be             a child of \e parent, and be constrained by \e parent's geometry             (unless you specify Qt::Window as window flag).         \li  \c{Qt::WindowFlags f = 0} (where available) sets the window flags;             the default is suitable for almost all widgets, but to get, for             example, a window without a window system frame, you must use             special flags.     \endlist      QWidget has many member functions, but some of them have little direct     functionality; for example, QWidget has a font property, but never uses     this itself. There are many subclasses which provide real functionality,     such as QLabel, QPushButton, QListWidget, and QTabWidget.       \section1 Top-Level and Child Widgets      A widget without a parent widget is always an independent window (top-level     widget). For these widgets, setWindowTitle() and setWindowIcon() set the     title bar and icon respectively.      Non-window widgets are child widgets, displayed within their parent     widgets. Most widgets in Qt are mainly useful as child widgets. For     example, it is possible to display a button as a top-level window, but most     people prefer to put their buttons inside other widgets, such as QDialog.      \image parent-child-widgets.png A parent widget containing various child widgets.      The diagram above shows a QGroupBox widget being used to hold various child     widgets in a layout provided by QGridLayout. The QLabel child widgets have     been outlined to indicate their full sizes.      If you want to use a QWidget to hold child widgets you will usually want to     add a layout to the parent QWidget. See \l{Layout Management} for more     information.       \section1 Composite Widgets      When a widget is used as a container to group a number of child widgets, it     is known as a composite widget. These can be created by constructing a     widget with the required visual properties - a QFrame, for example - and     adding child widgets to it, usually managed by a layout. The above diagram     shows such a composite widget that was created using Qt Designer.      Composite widgets can also be created by subclassing a standard widget,     such as QWidget or QFrame, and adding the necessary layout and child     widgets in the constructor of the subclass. Many of the \l{Qt Examples}     {examples provided with Qt} use this approach, and it is also covered in     the Qt \l{Tutorials}.       \section1 Custom Widgets and Painting      Since QWidget is a subclass of QPaintDevice, subclasses can be used to     display custom content that is composed using a series of painting     operations with an instance of the QPainter class. This approach contrasts     with the canvas-style approach used by the \l{Graphics View}     {Graphics View Framework} where items are added to a scene by the     application and are rendered by the framework itself.      Each widget performs all painting operations from within its paintEvent()     function. This is called whenever the widget needs to be redrawn, either     as a result of some external change or when requested by the application.      The \l{widgets/analogclock}{Analog Clock example} shows how a simple widget     can handle paint events.       \section1 Size Hints and Size Policies      When implementing a new widget, it is almost always useful to reimplement     sizeHint() to provide a reasonable default size for the widget and to set     the correct size policy with setSizePolicy().      By default, composite widgets which do not provide a size hint will be     sized according to the space requirements of their child widgets.      The size policy lets you supply good default behavior for the layout     management system, so that other widgets can contain and manage yours     easily. The default size policy indicates that the size hint represents     the preferred size of the widget, and this is often good enough for many     widgets.      \note The size of top-level widgets are constrained to 2/3 of the desktop's     height and width. You can resize() the widget manually if these bounds are     inadequate.       \section1 Events      Widgets respond to events that are typically caused by user actions. Qt     delivers events to widgets by calling specific event handler functions with     instances of QEvent subclasses containing information about each event.      If your widget only contains child widgets, you probably do not need to     implement any event handlers. If you want to detect a mouse click in a     child widget call the child's underMouse() function inside the widget's     mousePressEvent().      The \l{widgets/scribble}{Scribble example} implements a wider set of     events to handle mouse movement, button presses, and window resizing.      You will need to supply the behavior and content for your own widgets, but     here is a brief overview of the events that are relevant to QWidget,     starting with the most common ones:      \list         \li  paintEvent() is called whenever the widget needs to be repainted.             Every widget displaying custom content must implement it. Painting             using a QPainter can only take place in a paintEvent() or a             function called by a paintEvent().         \li  resizeEvent() is called when the widget has been resized.         \li  mousePressEvent() is called when a mouse button is pressed while             the mouse cursor is inside the widget, or when the widget has             grabbed the mouse using grabMouse(). Pressing the mouse without             releasing it is effectively the same as calling grabMouse().         \li  mouseReleaseEvent() is called when a mouse button is released. A             widget receives mouse release events when it has received the             corresponding mouse press event. This means that if the user             presses the mouse inside \e your widget, then drags the mouse             somewhere else before releasing the mouse button, \e your widget             receives the release event. There is one exception: if a popup menu             appears while the mouse button is held down, this popup immediately             steals the mouse events.         \li  mouseDoubleClickEvent() is called when the user double-clicks in             the widget. If the user double-clicks, the widget receives a mouse             press event, a mouse release event, (a mouse click event,) a second             mouse press, this event and finally a second mouse release event.             (Some mouse move events may also be             received if the mouse is not held steady during this operation.) It             is \e{not possible} to distinguish a click from a double-click             until the second click arrives. (This is one reason why most GUI             books recommend that double-clicks be an extension of             single-clicks, rather than trigger a different action.)     \endlist      Widgets that accept keyboard input need to reimplement a few more event     handlers:      \list         \li  keyPressEvent() is called whenever a key is pressed, and again when             a key has been held down long enough for it to auto-repeat. The             \uicontrol Tab and \uicontrol Shift+Tab keys are only passed to the widget if             they are not used by the focus-change mechanisms. To force those             keys to be processed by your widget, you must reimplement             QWidget::event().         \li  focusInEvent() is called when the widget gains keyboard focus             (assuming you have called setFocusPolicy()). Well-behaved widgets             indicate that they own the keyboard focus in a clear but discreet             way.         \li  focusOutEvent() is called when the widget loses keyboard focus.     \endlist      You may be required to also reimplement some of the less common event     handlers:      \list         \li  mouseMoveEvent() is called whenever the mouse moves while a mouse             button is held down. This can be useful during drag and drop             operations. If you call \l{setMouseTracking()}{setMouseTracking}(true),             you get mouse move events even when no buttons are held down.             (See also the \l{Drag and Drop} guide.)         \li  keyReleaseEvent() is called whenever a key is released and while it             is held down (if the key is auto-repeating). In that case, the             widget will receive a pair of key release and key press event for             every repeat. The \uicontrol Tab and \uicontrol Shift+Tab keys are only passed             to the widget if they are not used by the focus-change mechanisms.             To force those keys to be processed by your widget, you must             reimplement QWidget::event().         \li  wheelEvent() is called whenever the user turns the mouse wheel             while the widget has the focus.         \li  enterEvent() is called when the mouse enters the widget's screen             space. (This excludes screen space owned by any of the widget's             children.)         \li  leaveEvent() is called when the mouse leaves the widget's screen             space. If the mouse enters a child widget it will not cause a             leaveEvent().         \li  moveEvent() is called when the widget has been moved relative to             its parent.         \li  closeEvent() is called when the user closes the widget (or when             close() is called).     \endlist      There are also some rather obscure events described in the documentation     for QEvent::Type. To handle these events, you need to reimplement event()     directly.      The default implementation of event() handles \uicontrol Tab and \uicontrol Shift+Tab     (to move the keyboard focus), and passes on most of the other events to     one of the more specialized handlers above.      Events and the mechanism used to deliver them are covered in      \l{The Event System}.      \section1 Groups of Functions and Properties      \table     \header \li Context \li Functions and Properties      \row \li Window functions \li         show(),         hide(),         raise(),         lower(),         close().      \row \li Top-level windows \li         \l windowModified, \l windowTitle, \l windowIcon, \l windowIconText,         \l isActiveWindow, activateWindow(), \l minimized, showMinimized(),         \l maximized, showMaximized(), \l fullScreen, showFullScreen(),         showNormal().      \row \li Window contents \li         update(),         repaint(),         scroll().      \row \li Geometry \li         \l pos, x(), y(), \l rect, \l size, width(), height(), move(), resize(),         \l sizePolicy, sizeHint(), minimumSizeHint(),         updateGeometry(), layout(),         \l frameGeometry, \l geometry, \l childrenRect, \l childrenRegion,         adjustSize(),         mapFromGlobal(), mapToGlobal(),         mapFromParent(), mapToParent(),         \l maximumSize, \l minimumSize, \l sizeIncrement,         \l baseSize, setFixedSize()      \row \li Mode \li         \l visible, isVisibleTo(),         \l enabled, isEnabledTo(),         \l modal,         isWindow(),         \l mouseTracking,         \l updatesEnabled,         visibleRegion().      \row \li Look and feel \li         style(),         setStyle(),         \l styleSheet,         \l cursor,         \l font,         \l palette,         backgroundRole(), setBackgroundRole(),         fontInfo(), fontMetrics().      \row \li Keyboard focus functions \li         \l focus, \l focusPolicy,         setFocus(), clearFocus(), setTabOrder(), setFocusProxy(),         focusNextChild(), focusPreviousChild().      \row \li Mouse and keyboard grabbing \li         grabMouse(), releaseMouse(),         grabKeyboard(), releaseKeyboard(),         mouseGrabber(), keyboardGrabber().      \row \li Event handlers \li         event(),         mousePressEvent(),         mouseReleaseEvent(),         mouseDoubleClickEvent(),         mouseMoveEvent(),         keyPressEvent(),         keyReleaseEvent(),         focusInEvent(),         focusOutEvent(),         wheelEvent(),         enterEvent(),         leaveEvent(),         paintEvent(),         moveEvent(),         resizeEvent(),         closeEvent(),         dragEnterEvent(),         dragMoveEvent(),         dragLeaveEvent(),         dropEvent(),         childEvent(),         showEvent(),         hideEvent(),         customEvent().         changeEvent(),      \row \li System functions \li         parentWidget(), window(), setParent(), winId(),         find(), metric().      \row \li Interactive help \li         setToolTip(), setWhatsThis()      \endtable       \section1 Widget Style Sheets      In addition to the standard widget styles for each platform, widgets can     also be styled according to rules specified in a \l{styleSheet}     {style sheet}. This feature enables you to customize the appearance of     specific widgets to provide visual cues to users about their purpose. For     example, a button could be styled in a particular way to indicate that it     performs a destructive action.      The use of widget style sheets is described in more detail in the     \l{Qt Style Sheets} document.       \section1 Transparency and Double Buffering      Since Qt 4.0, QWidget automatically double-buffers its painting, so there     is no need to write double-buffering code in paintEvent() to avoid     flicker.      Since Qt 4.1, the Qt::WA_ContentsPropagated widget attribute has been     deprecated. Instead, the contents of parent widgets are propagated by     default to each of their children as long as Qt::WA_PaintOnScreen is not     set. Custom widgets can be written to take advantage of this feature by     updating irregular regions (to create non-rectangular child widgets), or     painting with colors that have less than full alpha component. The     following diagram shows how attributes and properties of a custom widget     can be fine-tuned to achieve different effects.      \image propagation-custom.png      In the above diagram, a semi-transparent rectangular child widget with an     area removed is constructed and added to a parent widget (a QLabel showing     a pixmap). Then, different properties and widget attributes are set to     achieve different effects:      \list         \li  The left widget has no additional properties or widget attributes             set. This default state suits most custom widgets using             transparency, are irregularly-shaped, or do not paint over their             entire area with an opaque brush.         \li  The center widget has the \l autoFillBackground property set. This             property is used with custom widgets that rely on the widget to             supply a default background, and do not paint over their entire             area with an opaque brush.         \li  The right widget has the Qt::WA_OpaquePaintEvent widget attribute             set. This indicates that the widget will paint over its entire area             with opaque colors. The widget's area will initially be             \e{uninitialized}, represented in the diagram with a red diagonal             grid pattern that shines through the overpainted area. The             Qt::WA_OpaquePaintArea attribute is useful for widgets that need to             paint their own specialized contents quickly and do not need a             default filled background.     \endlist      To rapidly update custom widgets with simple background colors, such as     real-time plotting or graphing widgets, it is better to define a suitable     background color (using setBackgroundRole() with the     QPalette::Window role), set the \l autoFillBackground property, and only     implement the necessary drawing functionality in the widget's paintEvent().      To rapidly update custom widgets that constantly paint over their entire     areas with opaque content, e.g., video streaming widgets, it is better to     set the widget's Qt::WA_OpaquePaintEvent, avoiding any unnecessary overhead     associated with repainting the widget's background.      If a widget has both the Qt::WA_OpaquePaintEvent widget attribute \e{and}     the \l autoFillBackground property set, the Qt::WA_OpaquePaintEvent     attribute takes precedence. Depending on your requirements, you should     choose either one of them.      Since Qt 4.1, the contents of parent widgets are also propagated to     standard Qt widgets. This can lead to some unexpected results if the     parent widget is decorated in a non-standard way, as shown in the diagram     below.      \image propagation-standard.png      The scope for customizing the painting behavior of standard Qt widgets,     without resorting to subclassing, is slightly less than that possible for     custom widgets. Usually, the desired appearance of a standard widget can be     achieved by setting its \l autoFillBackground property.       \section1 Creating Translucent Windows      Since Qt 4.5, it has been possible to create windows with translucent regions     on window systems that support compositing.      To enable this feature in a top-level widget, set its Qt::WA_TranslucentBackground     attribute with setAttribute() and ensure that its background is painted with     non-opaque colors in the regions you want to be partially transparent.      Platform notes:      \list     \li X11: This feature relies on the use of an X server that supports ARGB visuals     and a compositing window manager.     \li Windows: The widget needs to have the Qt::FramelessWindowHint window flag set     for the translucency to work.     \endlist       \section1 Native Widgets vs Alien Widgets      Introduced in Qt 4.4, alien widgets are widgets unknown to the windowing     system. They do not have a native window handle associated with them. This     feature significantly speeds up widget painting, resizing, and removes flicker.      Should you require the old behavior with native windows, you can choose     one of the following options:      \list 1         \li  Use the \c{QT_USE_NATIVE_WINDOWS=1} in your environment.         \li  Set the Qt::AA_NativeWindows attribute on your application. All             widgets will be native widgets.         \li  Set the Qt::WA_NativeWindow attribute on widgets: The widget itself             and all of its ancestors will become native (unless             Qt::WA_DontCreateNativeAncestors is set).         \li  Call QWidget::winId to enforce a native window (this implies 3).         \li  Set the Qt::WA_PaintOnScreen attribute to enforce a native window             (this implies 3).     \endlist      \sa QEvent, QPainter, QGridLayout, QBoxLayout  */
end_comment
begin_decl_stmt
DECL|member|mapper
name|QWidgetMapper
modifier|*
name|QWidgetPrivate
operator|::
name|mapper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|mapper
comment|// widget with wid
end_comment
begin_decl_stmt
DECL|member|allWidgets
name|QWidgetSet
modifier|*
name|QWidgetPrivate
operator|::
name|allWidgets
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|allWidgets
comment|// widgets with no wid
end_comment
begin_comment
comment|/*****************************************************************************   QWidget utility functions  *****************************************************************************/
end_comment
begin_function
DECL|function|qt_dirtyRegion
name|QRegion
name|qt_dirtyRegion
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|qt_widget_private
argument_list|(
name|widget
argument_list|)
operator|->
name|maybeBackingStore
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bs
condition|)
return|return
name|QRegion
argument_list|()
return|;
return|return
name|bs
operator|->
name|dirtyRegion
argument_list|(
name|widget
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QWidget member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*     Widget state flags:   \list   \li Qt::WA_WState_Created The widget has a valid winId().   \li Qt::WA_WState_Visible The widget is currently visible.   \li Qt::WA_WState_Hidden The widget is hidden, i.e. it won't   become visible unless you call show() on it. Qt::WA_WState_Hidden   implies !Qt::WA_WState_Visible.   \li Qt::WA_WState_CompressKeys Compress keyboard events.   \li Qt::WA_WState_BlockUpdates Repaints and updates are disabled.   \li Qt::WA_WState_InPaintEvent Currently processing a paint event.   \li Qt::WA_WState_Reparented The widget has been reparented.   \li Qt::WA_WState_ConfigPending A configuration (resize/move) event is pending.   \li Qt::WA_WState_DND (Deprecated) The widget supports drag and drop, see setAcceptDrops().   \endlist */
end_comment
begin_struct
DECL|struct|QWidgetExceptionCleaner
struct|struct
name|QWidgetExceptionCleaner
block|{
comment|/* this cleans up when the constructor throws an exception */
DECL|function|cleanup
specifier|static
specifier|inline
name|void
name|cleanup
parameter_list|(
name|QWidget
modifier|*
name|that
parameter_list|,
name|QWidgetPrivate
modifier|*
name|d
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
name|Q_UNUSED
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|QWidgetPrivate
operator|::
name|allWidgets
operator|->
name|remove
argument_list|(
name|that
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|focus_next
operator|!=
name|that
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|focus_next
condition|)
name|d
operator|->
name|focus_next
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|d
operator|->
name|focus_prev
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|focus_prev
condition|)
name|d
operator|->
name|focus_prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|d
operator|->
name|focus_next
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
struct|;
end_struct
begin_comment
comment|/*!     Constructs a widget which is a child of \a parent, with  widget     flags set to \a f.      If \a parent is 0, the new widget becomes a window. If     \a parent is another widget, this widget becomes a child window     inside \a parent. The new widget is deleted when its \a parent is     deleted.      The widget flags argument, \a f, is normally 0, but it can be set     to customize the frame of a window (i.e. \a     parent must be 0). To customize the frame, use a value composed     from the bitwise OR of any of the \l{Qt::WindowFlags}{window flags}.      If you add a child widget to an already visible widget you must     explicitly show the child to make it visible.      Note that the X11 version of Qt may not be able to deliver all     combinations of style flags on all systems. This is because on     X11, Qt can only ask the window manager, and the window manager     can override the application's settings. On Windows, Qt can set     whatever flags you want.      \sa windowFlags */
end_comment
begin_constructor
DECL|function|QWidget
name|QWidget
operator|::
name|QWidget
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QWidgetPrivate
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|QPaintDevice
argument_list|()
block|{
name|QT_TRY
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|(
name|parent
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|QWidgetExceptionCleaner
operator|::
name|cleanup
argument_list|(
name|this
argument_list|,
name|d_func
argument_list|()
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*! \internal */
end_comment
begin_constructor
DECL|function|QWidget
name|QWidget
operator|::
name|QWidget
parameter_list|(
name|QWidgetPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|QPaintDevice
argument_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|init
argument_list|(
name|parent
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|QWidgetExceptionCleaner
operator|::
name|cleanup
argument_list|(
name|this
argument_list|,
name|d_func
argument_list|()
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QWidget
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Widget
return|;
block|}
end_function
begin_comment
comment|//### w is a "this" ptr, passed as a param because QWorkspace needs special logic
end_comment
begin_function
DECL|function|adjustFlags
name|void
name|QWidgetPrivate
operator|::
name|adjustFlags
parameter_list|(
name|Qt
operator|::
name|WindowFlags
modifier|&
name|flags
parameter_list|,
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|bool
name|customize
init|=
operator|(
name|flags
operator|&
operator|(
name|Qt
operator|::
name|CustomizeWindowHint
operator||
name|Qt
operator|::
name|FramelessWindowHint
operator||
name|Qt
operator|::
name|WindowTitleHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator||
name|Qt
operator|::
name|WindowMinimizeButtonHint
operator||
name|Qt
operator|::
name|WindowMaximizeButtonHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
operator||
name|Qt
operator|::
name|WindowContextHelpButtonHint
operator|)
operator|)
decl_stmt|;
name|uint
name|type
init|=
operator|(
name|flags
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|Qt
operator|::
name|Widget
operator|||
name|type
operator|==
name|Qt
operator|::
name|SubWindow
operator|)
operator|&&
name|w
operator|&&
operator|!
name|w
operator|->
name|parent
argument_list|()
condition|)
block|{
name|type
operator|=
name|Qt
operator|::
name|Window
expr_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|Window
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|CustomizeWindowHint
condition|)
block|{
comment|// modify window flags to make them consistent.
comment|// Only enable this on non-Mac platforms. Since the old way of doing this would
comment|// interpret WindowSystemMenuHint as a close button and we can't change that behavior
comment|// we can't just add this in.
ifndef|#
directive|ifndef
name|Q_WS_MAC
if|if
condition|(
name|flags
operator|&
operator|(
name|Qt
operator|::
name|WindowMinMaxButtonsHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
operator||
name|Qt
operator|::
name|WindowContextHelpButtonHint
operator|)
condition|)
block|{
name|flags
operator||=
name|Qt
operator|::
name|WindowSystemMenuHint
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flags
operator|&
operator|(
name|Qt
operator|::
name|WindowMinMaxButtonsHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator|)
condition|)
block|{
endif|#
directive|endif
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
expr_stmt|;
name|flags
operator|&=
operator|~
name|Qt
operator|::
name|FramelessWindowHint
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|customize
operator|&&
operator|!
operator|(
name|flags
operator|&
name|Qt
operator|::
name|FramelessWindowHint
operator|)
condition|)
block|{
comment|// if any of the window hints that affect the titlebar are set
comment|// and the window is supposed to have frame, we add a titlebar
comment|// and system menu by default.
name|flags
operator||=
name|Qt
operator|::
name|WindowSystemMenuHint
expr_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
expr_stmt|;
block|}
if|if
condition|(
name|customize
condition|)
empty_stmt|;
comment|// don't modify window flags if the user explicitly set them.
elseif|else
if|if
condition|(
name|type
operator|==
name|Qt
operator|::
name|Dialog
operator|||
name|type
operator|==
name|Qt
operator|::
name|Sheet
condition|)
ifndef|#
directive|ifndef
name|Q_OS_WINCE
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator||
name|Qt
operator|::
name|WindowContextHelpButtonHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
expr_stmt|;
else|#
directive|else
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|type
operator|==
name|Qt
operator|::
name|Tool
condition|)
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
expr_stmt|;
else|else
name|flags
operator||=
name|Qt
operator|::
name|WindowTitleHint
operator||
name|Qt
operator|::
name|WindowSystemMenuHint
operator||
name|Qt
operator|::
name|WindowMinimizeButtonHint
operator||
name|Qt
operator|::
name|WindowMaximizeButtonHint
operator||
name|Qt
operator|::
name|WindowCloseButtonHint
operator||
name|Qt
operator|::
name|WindowFullscreenButtonHint
expr_stmt|;
block|}
DECL|function|init
name|void
name|QWidgetPrivate
operator|::
name|init
parameter_list|(
name|QWidget
modifier|*
name|parentWidget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qobject_cast
argument_list|<
name|QApplication
operator|*
argument_list|>
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"QWidget: Cannot create a QWidget without QApplication"
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|allWidgets
argument_list|)
expr_stmt|;
if|if
condition|(
name|allWidgets
condition|)
name|allWidgets
operator|->
name|insert
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|desktopWidget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parentWidget
operator|&&
name|parentWidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
block|{
name|desktopWidget
operator|=
name|parentWidget
expr_stmt|;
name|parentWidget
operator|=
literal|0
expr_stmt|;
block|}
name|q
operator|->
name|data
operator|=
operator|&
name|data
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
if|if
condition|(
operator|!
name|parent
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|q
operator|->
name|thread
argument_list|()
operator|==
name|qApp
operator|->
name|thread
argument_list|()
argument_list|,
literal|"QWidget"
argument_list|,
literal|"Widgets must be created in the GUI thread."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|desktopWidget
condition|)
block|{
comment|// make sure the widget is created on the same screen as the
comment|// programmer specified desktop widget
name|xinfo
operator|=
name|desktopWidget
operator|->
name|d_func
argument_list|()
operator|->
name|xinfo
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|desktopWidget
condition|)
block|{
specifier|const
name|int
name|screen
init|=
name|desktopWidget
operator|->
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
operator|->
name|screenIndex
decl_stmt|;
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|q
operator|->
name|windowHandle
argument_list|()
condition|)
name|window
operator|->
name|setScreen
argument_list|(
name|QGuiApplication
operator|::
name|screens
argument_list|()
operator|.
name|value
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|fstrut_dirty
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|winid
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|widget_attributes
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|window_flags
operator|=
name|f
expr_stmt|;
name|data
operator|.
name|window_state
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|focus_policy
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|context_menu_policy
operator|=
name|Qt
operator|::
name|DefaultContextMenu
expr_stmt|;
name|data
operator|.
name|window_modality
operator|=
name|Qt
operator|::
name|NonModal
expr_stmt|;
name|data
operator|.
name|sizehint_forced
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|is_closing
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|in_show
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|in_set_window_state
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|in_destructor
operator|=
literal|false
expr_stmt|;
comment|// Widgets with Qt::MSWindowsOwnDC (typically QGLWidget) must have a window handle.
if|if
condition|(
name|f
operator|&
name|Qt
operator|::
name|MSWindowsOwnDC
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
comment|//#ifdef Q_WS_MAC
comment|//    q->setAttribute(Qt::WA_NativeWindow);
comment|//#endif
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_QuitOnClose
argument_list|)
expr_stmt|;
comment|// might be cleared in adjustQuitOnCloseAttribute()
name|adjustQuitOnCloseAttribute
argument_list|()
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
expr_stmt|;
comment|//give potential windows a bigger "pre-initial" size; create_sys() will give them a new size later
name|data
operator|.
name|crect
operator|=
name|parentWidget
condition|?
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|30
argument_list|)
else|:
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|640
argument_list|,
literal|480
argument_list|)
expr_stmt|;
name|focus_next
operator|=
name|focus_prev
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|==
name|Qt
operator|::
name|Desktop
condition|)
name|q
operator|->
name|create
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parentWidget
condition|)
name|q
operator|->
name|setParent
argument_list|(
name|parentWidget
argument_list|,
name|data
operator|.
name|window_flags
argument_list|)
expr_stmt|;
else|else
block|{
name|adjustFlags
argument_list|(
name|data
operator|.
name|window_flags
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|resolveLayoutDirection
argument_list|()
expr_stmt|;
comment|// opaque system background?
specifier|const
name|QBrush
modifier|&
name|background
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Window
argument_list|)
decl_stmt|;
name|setOpaque
argument_list|(
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|background
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
name|background
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|fnt
operator|=
name|QFont
argument_list|(
name|data
operator|.
name|fnt
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|data
operator|.
name|fnt
operator|.
name|x11SetScreen
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_WS_X11
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingMoveEvent
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|QWidgetPrivate
operator|::
name|instanceCounter
operator|>
name|QWidgetPrivate
operator|::
name|maxInstances
condition|)
name|QWidgetPrivate
operator|::
name|maxInstances
operator|=
name|QWidgetPrivate
operator|::
name|instanceCounter
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_ImmediateWidgetCreation
argument_list|)
condition|)
name|q
operator|->
name|create
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|Create
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|postEvent
argument_list|(
name|q
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|PolishRequest
argument_list|)
argument_list|)
expr_stmt|;
name|extraPaintEngine
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// If we add a child to the unified toolbar, we have to redirect the painting.
if|if
condition|(
name|parentWidget
operator|&&
name|parentWidget
operator|->
name|d_func
argument_list|()
operator|&&
name|parentWidget
operator|->
name|d_func
argument_list|()
operator|->
name|isInUnifiedToolbar
condition|)
block|{
if|if
condition|(
name|parentWidget
operator|->
name|d_func
argument_list|()
operator|->
name|unifiedSurface
condition|)
block|{
name|QWidget
modifier|*
name|toolbar
init|=
name|parentWidget
operator|->
name|d_func
argument_list|()
operator|->
name|toolbar_ancestor
decl_stmt|;
name|parentWidget
operator|->
name|d_func
argument_list|()
operator|->
name|unifiedSurface
operator|->
name|recursiveRedirect
argument_list|(
name|toolbar
argument_list|,
name|toolbar
argument_list|,
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|toolbar_offset
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
block|}
DECL|function|createRecursively
name|void
name|QWidgetPrivate
operator|::
name|createRecursively
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|q
operator|->
name|create
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|&&
operator|!
name|child
operator|->
name|isHidden
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|createRecursively
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*!     Creates a new widget window if \a window is 0, otherwise sets the     widget's window to \a window.      Initializes the window (sets the geometry etc.) if \a     initializeWindow is true. If \a initializeWindow is false, no     initialization is performed. This parameter only makes sense if \a     window is a valid window.      Destroys the old window if \a destroyOldWindow is true. If \a     destroyOldWindow is false, you are responsible for destroying the     window yourself (using platform native code).      The QWidget constructor calls create(0,true,true) to create a     window for this widget. */
DECL|function|create
name|void
name|QWidget
operator|::
name|create
parameter_list|(
name|WId
name|window
parameter_list|,
name|bool
name|initializeWindow
parameter_list|,
name|bool
name|destroyOldWindow
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|window
operator|==
literal|0
operator|&&
name|internalWinId
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|data
operator|.
name|in_destructor
condition|)
return|return;
name|Qt
operator|::
name|WindowType
name|type
init|=
name|windowType
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|WindowFlags
modifier|&
name|flags
init|=
name|data
operator|->
name|window_flags
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|Qt
operator|::
name|Widget
operator|||
name|type
operator|==
name|Qt
operator|::
name|SubWindow
operator|)
operator|&&
operator|!
name|parentWidget
argument_list|()
condition|)
block|{
name|type
operator|=
name|Qt
operator|::
name|Window
expr_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|Window
expr_stmt|;
block|}
if|if
condition|(
name|QWidget
modifier|*
name|parent
init|=
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|&
name|Qt
operator|::
name|Window
condition|)
block|{
if|if
condition|(
operator|!
name|parent
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|parent
operator|->
name|createWinId
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
operator|&&
operator|!
name|parent
operator|->
name|internalWinId
argument_list|()
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
condition|)
block|{
comment|// We're about to create a native child widget that doesn't have a native parent;
comment|// enforce a native handle for the parent unless the Qt::WA_DontCreateNativeAncestors
comment|// attribute is set.
name|d
operator|->
name|createWinId
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|// Nothing more to do.
name|Q_ASSERT
argument_list|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|static
name|int
name|paintOnScreenEnv
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|paintOnScreenEnv
operator|==
operator|-
literal|1
condition|)
name|paintOnScreenEnv
operator|=
name|qgetenv
argument_list|(
literal|"QT_ONSCREEN_PAINT"
argument_list|)
operator|.
name|toInt
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|paintOnScreenEnv
operator|==
literal|1
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_NativeWindows
argument_list|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWidget::create:"
operator|<<
name|this
operator|<<
literal|"parent:"
operator|<<
name|parentWidget
argument_list|()
operator|<<
literal|"Alien?"
operator|<<
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DRAGANDDROP
argument_list|)
comment|// Unregister the dropsite (if already registered) before we
comment|// re-create the widget with a native window.
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
operator|!
name|internalWinId
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
operator|&&
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|dropTarget
condition|)
block|{
name|d
operator|->
name|registerDropSite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// defined (Q_WS_WIN)&& !defined(QT_NO_DRAGANDDROP)
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
expr_stmt|;
comment|// set created flag
name|d
operator|->
name|create_sys
argument_list|(
name|window
argument_list|,
name|initializeWindow
argument_list|,
name|destroyOldWindow
argument_list|)
expr_stmt|;
comment|// a real toplevel window needs a backing store
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
name|d
operator|->
name|topData
argument_list|()
operator|->
name|backingStoreTracker
operator|.
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasBackingStoreSupport
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|backingStoreTracker
operator|.
name|create
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setModal_sys
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
name|parentWidget
argument_list|()
operator|&&
name|parentWidget
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|,
literal|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_eval_init_widget
argument_list|(
name|QWidget
operator|*
name|w
argument_list|)
decl_stmt|;
name|qt_eval_init_widget
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// need to force the resting of the icon after changing parents
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetWindowIcon
argument_list|)
condition|)
name|d
operator|->
name|setWindowIcon_sys
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|topData
argument_list|()
operator|->
name|iconText
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|setWindowIconText_helper
argument_list|(
name|d
operator|->
name|topData
argument_list|()
operator|->
name|iconText
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|topData
argument_list|()
operator|->
name|caption
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|setWindowTitle_helper
argument_list|(
name|d
operator|->
name|topData
argument_list|()
operator|->
name|caption
argument_list|)
expr_stmt|;
if|if
condition|(
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
name|d
operator|->
name|updateSystemBackground
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetWindowIcon
argument_list|)
condition|)
name|d
operator|->
name|setWindowIcon_sys
argument_list|()
expr_stmt|;
block|}
comment|// Frame strut update needed in cases where there are native widgets such as QGLWidget,
comment|// as those force native window creation on their ancestors before they are shown.
comment|// If the strut is not updated, any subsequent move of the top level window before show
comment|// will cause window frame to be ignored when positioning the window.
comment|// Note that this only helps on platforms that handle window creation synchronously.
name|d
operator|->
name|updateFrameStrut
argument_list|()
expr_stmt|;
block|}
comment|/*!     Destroys the widget.      All this widget's children are deleted first. The application     exits if this widget is the main widget. */
DECL|function|~QWidget
name|QWidget
operator|::
name|~
name|QWidget
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
operator|.
name|in_destructor
operator|=
literal|true
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_STATE
argument_list|)
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QWidget: %s (%s) deleted while being painted"
argument_list|,
name|className
argument_list|()
argument_list|,
name|name
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|type
decl|,
name|d
operator|->
name|gestureContext
operator|.
name|keys
argument_list|()
control|)
name|ungrabGesture
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// force acceptDrops false before winId is destroyed.
name|d
operator|->
name|registerDropSite
argument_list|(
literal|false
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACTION
comment|// remove all actions from this widget
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|actions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QActionPrivate
modifier|*
name|apriv
init|=
name|d
operator|->
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|widgets
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|actions
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
comment|// Remove all shortcuts grabbed by this
comment|// widget, unless application is closing
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GrabbedShortcut
argument_list|)
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|removeShortcut
argument_list|(
literal|0
argument_list|,
name|this
argument_list|,
name|QKeySequence
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// delete layout while we still are a valid widget
operator|delete
name|d
operator|->
name|layout
expr_stmt|;
name|d
operator|->
name|layout
operator|=
literal|0
expr_stmt|;
comment|// Remove myself from focus list
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|focus_next
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|==
name|this
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|focus_prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|==
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|focus_next
operator|!=
name|this
condition|)
block|{
name|d
operator|->
name|focus_next
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|d
operator|->
name|focus_prev
expr_stmt|;
name|d
operator|->
name|focus_prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|d
operator|->
name|focus_next
expr_stmt|;
name|d
operator|->
name|focus_next
operator|=
name|d
operator|->
name|focus_prev
operator|=
literal|0
expr_stmt|;
block|}
name|QT_TRY
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|w
operator|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
name|QWidget
modifier|*
name|window
init|=
name|w
operator|->
name|window
argument_list|()
decl_stmt|;
name|QWExtra
modifier|*
name|e
init|=
name|window
condition|?
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|extra
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|||
operator|!
name|e
operator|->
name|proxyWidget
condition|)
endif|#
directive|endif
name|clearFocus
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// swallow this problem because we are in a destructor
block|}
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|isVisible
argument_list|()
operator|&&
name|internalWinId
argument_list|()
condition|)
block|{
name|QT_TRY
block|{
name|d
operator|->
name|close_helper
argument_list|(
name|QWidgetPrivate
operator|::
name|CloseNoEvent
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// if we're out of memory, at least hide the window.
name|QT_TRY
block|{
name|hide
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// and if that also doesn't work, then give up
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
elseif|else
if|if
condition|(
operator|!
name|internalWinId
argument_list|()
operator|&&
name|isVisible
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|sendSyntheticEnterLeave
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|sendSyntheticEnterLeave
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|d
operator|->
name|maybeBackingStore
argument_list|()
condition|)
block|{
name|bs
operator|->
name|removeDirtyWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StaticContents
argument_list|)
condition|)
name|bs
operator|->
name|removeStaticWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
operator|delete
name|d
operator|->
name|needsFlush
expr_stmt|;
name|d
operator|->
name|needsFlush
operator|=
literal|0
expr_stmt|;
comment|// The next 20 lines are duplicated from QObject, but required here
comment|// since QWidget deletes is children itself
name|bool
name|blocked
init|=
name|d
operator|->
name|blockSig
decl_stmt|;
name|d
operator|->
name|blockSig
operator|=
literal|0
expr_stmt|;
comment|// unblock signals so we always emit destroyed()
if|if
condition|(
name|d
operator|->
name|isSignalConnected
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|QT_TRY
block|{
emit|emit
name|destroyed
argument_list|(
name|this
argument_list|)
emit|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// all the signal/slots connections are still in place - if we don't
comment|// quit now, we will crash pretty soon.
name|qWarning
argument_list|(
literal|"Detected an unexpected exception in ~QWidget while emitting destroyed()."
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|declarativeData
condition|)
block|{
name|QAbstractDeclarativeData
operator|::
name|destroyed
argument_list|(
name|d
operator|->
name|declarativeData
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|declarativeData
operator|=
literal|0
expr_stmt|;
comment|// don't activate again in ~QObject
block|}
name|d
operator|->
name|blockSig
operator|=
name|blocked
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// QCocoaView holds a pointer back to this widget. Clear it now
comment|// to make sure it's not followed later on. The lifetime of the
comment|// QCocoaView might exceed the lifetime of this widget in cases
comment|// where Cocoa itself holds references to it.
specifier|extern
name|void
name|qt_mac_clearCocoaViewQWidgetPointers
argument_list|(
name|QWidget
operator|*
argument_list|)
decl_stmt|;
name|qt_mac_clearCocoaViewQWidgetPointers
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|deleteChildren
argument_list|()
expr_stmt|;
name|QApplication
operator|::
name|removePostedEvents
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|destroy
argument_list|()
expr_stmt|;
comment|// platform-dependent cleanup
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// if this fails we can't do anything about it but at least we are not allowed to throw.
block|}
operator|--
name|QWidgetPrivate
operator|::
name|instanceCounter
expr_stmt|;
if|if
condition|(
name|QWidgetPrivate
operator|::
name|allWidgets
condition|)
comment|// might have been deleted by ~QApplication
name|QWidgetPrivate
operator|::
name|allWidgets
operator|->
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|Destroy
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::exception&
argument_list|)
block|{
comment|// if this fails we can't do anything about it but at least we are not allowed to throw.
block|}
block|}
DECL|member|instanceCounter
name|int
name|QWidgetPrivate
operator|::
name|instanceCounter
init|=
literal|0
decl_stmt|;
comment|// Current number of widget instances
DECL|member|maxInstances
name|int
name|QWidgetPrivate
operator|::
name|maxInstances
init|=
literal|0
decl_stmt|;
comment|// Maximum number of widget instances
DECL|function|setWinId
name|void
name|QWidgetPrivate
operator|::
name|setWinId
parameter_list|(
name|WId
name|id
parameter_list|)
comment|// set widget identifier
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// the user might create a widget with Qt::Desktop window
comment|// attribute (or create another QDesktopWidget instance), which
comment|// will have the same windowid (the root window id) as the
comment|// qt_desktopWidget. We should not add the second desktop widget
comment|// to the mapper.
name|bool
name|userDesktopWidget
init|=
name|qt_desktopWidget
operator|!=
literal|0
operator|&&
name|qt_desktopWidget
operator|!=
name|q
operator|&&
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
decl_stmt|;
if|if
condition|(
name|mapper
operator|&&
name|data
operator|.
name|winid
operator|&&
operator|!
name|userDesktopWidget
condition|)
block|{
name|mapper
operator|->
name|remove
argument_list|(
name|data
operator|.
name|winid
argument_list|)
expr_stmt|;
block|}
specifier|const
name|WId
name|oldWinId
init|=
name|data
operator|.
name|winid
decl_stmt|;
name|data
operator|.
name|winid
operator|=
name|id
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|hd
operator|=
name|id
expr_stmt|;
comment|// X11: hd == ident
endif|#
directive|endif
if|if
condition|(
name|mapper
operator|&&
name|id
operator|&&
operator|!
name|userDesktopWidget
condition|)
block|{
name|mapper
operator|->
name|insert
argument_list|(
name|data
operator|.
name|winid
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldWinId
operator|!=
name|id
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WinIdChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createTLExtra
name|void
name|QWidgetPrivate
operator|::
name|createTLExtra
parameter_list|()
block|{
if|if
condition|(
operator|!
name|extra
condition|)
name|createExtra
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|extra
operator|->
name|topextra
condition|)
block|{
name|QTLWExtra
modifier|*
name|x
init|=
name|extra
operator|->
name|topextra
operator|=
operator|new
name|QTLWExtra
decl_stmt|;
name|x
operator|->
name|icon
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|backingStore
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|sharedPainter
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|incw
operator|=
name|x
operator|->
name|inch
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|basew
operator|=
name|x
operator|->
name|baseh
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|frameStrut
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|->
name|normalGeometry
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|x
operator|->
name|savedFlags
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|opacity
operator|=
literal|255
expr_stmt|;
name|x
operator|->
name|posIncludesFrame
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|sizeAdjusted
operator|=
literal|false
expr_stmt|;
name|x
operator|->
name|inTopLevelResize
operator|=
literal|false
expr_stmt|;
name|x
operator|->
name|inRepaint
operator|=
literal|false
expr_stmt|;
name|x
operator|->
name|embedded
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|x
operator|->
name|wasMaximized
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|// Q_WS_MAC
name|createTLSysExtra
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QWIDGET_EXTRA_DEBUG
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"tlextra"
operator|<<
operator|++
name|count
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*!   \internal   Creates the widget extra data. */
DECL|function|createExtra
name|void
name|QWidgetPrivate
operator|::
name|createExtra
parameter_list|()
block|{
if|if
condition|(
operator|!
name|extra
condition|)
block|{
comment|// if not exists
name|extra
operator|=
operator|new
name|QWExtra
expr_stmt|;
name|extra
operator|->
name|glContext
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|topextra
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|extra
operator|->
name|proxyWidget
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|extra
operator|->
name|curs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|extra
operator|->
name|minw
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|minh
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|maxw
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
name|extra
operator|->
name|maxh
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
name|extra
operator|->
name|customDpiX
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|customDpiY
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|explicitMinSize
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|explicitMaxSize
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|autoFillBackground
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|nativeChildrenForced
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|inRenderWithPainter
operator|=
literal|0
expr_stmt|;
name|extra
operator|->
name|hasMask
operator|=
literal|0
expr_stmt|;
name|createSysExtra
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QWIDGET_EXTRA_DEBUG
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"extra"
operator|<<
operator|++
name|count
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*!   \internal   Deletes the widget extra data. */
DECL|function|deleteExtra
name|void
name|QWidgetPrivate
operator|::
name|deleteExtra
parameter_list|()
block|{
if|if
condition|(
name|extra
condition|)
block|{
comment|// if exists
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
operator|delete
name|extra
operator|->
name|curs
expr_stmt|;
endif|#
directive|endif
name|deleteSysExtra
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
comment|// dereference the stylesheet style
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|extra
operator|->
name|style
argument_list|)
condition|)
name|proxy
operator|->
name|deref
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|extra
operator|->
name|topextra
condition|)
block|{
name|deleteTLSysExtra
argument_list|()
expr_stmt|;
comment|// extra->topextra->backingStore destroyed in QWidgetPrivate::deleteTLSysExtra()
operator|delete
name|extra
operator|->
name|topextra
operator|->
name|icon
expr_stmt|;
operator|delete
name|extra
operator|->
name|topextra
expr_stmt|;
block|}
operator|delete
name|extra
expr_stmt|;
comment|// extra->xic destroyed in QWidget::destroy()
name|extra
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*   Returns true if there are widgets above this which overlap with   \a rect, which is in parent's coordinate system (same as crect). */
DECL|function|isOverlapped
name|bool
name|QWidgetPrivate
operator|::
name|isOverlapped
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
name|QRect
name|r
init|=
name|rect
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
return|return
literal|false
return|;
name|QWidgetPrivate
modifier|*
name|pd
init|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|bool
name|above
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|sibling
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|pd
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sibling
operator|||
operator|!
name|sibling
operator|->
name|isVisible
argument_list|()
operator|||
name|sibling
operator|->
name|isWindow
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|above
condition|)
block|{
name|above
operator|=
operator|(
name|sibling
operator|==
name|w
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qRectIntersects
argument_list|(
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|effectiveRectFor
argument_list|(
name|sibling
operator|->
name|data
operator|->
name|crect
argument_list|)
argument_list|,
name|r
argument_list|)
condition|)
block|{
specifier|const
name|QWExtra
modifier|*
name|siblingExtra
init|=
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|siblingExtra
operator|&&
name|siblingExtra
operator|->
name|hasMask
operator|&&
operator|!
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|graphicsEffect
operator|&&
operator|!
name|siblingExtra
operator|->
name|mask
operator|.
name|translated
argument_list|(
name|sibling
operator|->
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|.
name|intersects
argument_list|(
name|r
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
literal|true
return|;
block|}
block|}
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|pd
operator|->
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|function|syncBackingStore
name|void
name|QWidgetPrivate
operator|::
name|syncBackingStore
parameter_list|()
block|{
if|if
condition|(
name|paintOnScreen
argument_list|()
condition|)
block|{
name|repaint_sys
argument_list|(
name|dirty
argument_list|)
expr_stmt|;
name|dirty
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|maybeBackingStore
argument_list|()
condition|)
block|{
name|bs
operator|->
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|syncBackingStore
name|void
name|QWidgetPrivate
operator|::
name|syncBackingStore
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
if|if
condition|(
name|paintOnScreen
argument_list|()
condition|)
name|repaint_sys
argument_list|(
name|region
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|maybeBackingStore
argument_list|()
condition|)
block|{
name|bs
operator|->
name|sync
argument_list|(
name|q_func
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setUpdatesEnabled_helper
name|void
name|QWidgetPrivate
operator|::
name|setUpdatesEnabled_helper
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|&&
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|updatesEnabled
argument_list|()
condition|)
return|return;
comment|// nothing we can do
if|if
condition|(
name|enable
operator|!=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_UpdatesDisabled
argument_list|)
condition|)
return|return;
comment|// nothing to do
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UpdatesDisabled
argument_list|,
operator|!
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
name|Qt
operator|::
name|WidgetAttribute
name|attribute
init|=
name|enable
condition|?
name|Qt
operator|::
name|WA_ForceUpdatesDisabled
else|:
name|Qt
operator|::
name|WA_UpdatesDisabled
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|attribute
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setUpdatesEnabled_helper
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \internal      Propagate this widget's palette to all children, except style sheet     widgets, and windows that don't enable window propagation (palettes don't     normally propagate to windows). */
DECL|function|propagatePaletteChange
name|void
name|QWidgetPrivate
operator|::
name|propagatePaletteChange
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// Propagate a new inherited mask to all children.
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|QGraphicsProxyWidget
modifier|*
name|p
init|=
name|extra
operator|->
name|proxyWidget
decl_stmt|;
name|inheritedPaletteResolveMask
operator|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|inheritedPaletteResolveMask
operator||
name|p
operator|->
name|palette
argument_list|()
operator|.
name|resolve
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
condition|)
block|{
name|inheritedPaletteResolveMask
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|mask
init|=
name|data
operator|.
name|pal
operator|.
name|resolve
argument_list|()
operator||
name|inheritedPaletteResolveMask
decl_stmt|;
name|QEvent
name|pc
argument_list|(
name|QEvent
operator|::
name|PaletteChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
operator|&&
operator|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
operator|)
condition|)
block|{
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|wd
operator|->
name|inheritedPaletteResolveMask
operator|=
name|mask
expr_stmt|;
name|wd
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*   Returns the widget's clipping rectangle. */
DECL|function|clipRect
name|QRect
name|QWidgetPrivate
operator|::
name|clipRect
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|isVisible
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QRect
name|r
init|=
name|effectiveRectFor
argument_list|(
name|q
operator|->
name|rect
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|ox
init|=
literal|0
decl_stmt|;
name|int
name|oy
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
name|ox
operator|-=
name|w
operator|->
name|x
argument_list|()
expr_stmt|;
name|oy
operator|-=
name|w
operator|->
name|y
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|r
operator|&=
name|QRect
argument_list|(
name|ox
argument_list|,
name|oy
argument_list|,
name|w
operator|->
name|width
argument_list|()
argument_list|,
name|w
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/*   Returns the widget's clipping region (without siblings). */
DECL|function|clipRegion
name|QRegion
name|QWidgetPrivate
operator|::
name|clipRegion
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isVisible
argument_list|()
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|QRegion
name|r
argument_list|(
name|q
operator|->
name|rect
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
specifier|const
name|QWidget
modifier|*
name|ignoreUpTo
decl_stmt|;
name|int
name|ox
init|=
literal|0
decl_stmt|;
name|int
name|oy
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
name|ox
operator|-=
name|w
operator|->
name|x
argument_list|()
expr_stmt|;
name|oy
operator|-=
name|w
operator|->
name|y
argument_list|()
expr_stmt|;
name|ignoreUpTo
operator|=
name|w
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|r
operator|&=
name|QRegion
argument_list|(
name|ox
argument_list|,
name|oy
argument_list|,
name|w
operator|->
name|width
argument_list|()
argument_list|,
name|w
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
operator|!=
cast|static_cast
argument_list|<
specifier|const
name|QObject
operator|*
argument_list|>
argument_list|(
name|ignoreUpTo
argument_list|)
condition|)
empty_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|sibling
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sibling
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|sibling
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QRect
name|siblingRect
argument_list|(
name|ox
operator|+
name|sibling
operator|->
name|x
argument_list|()
argument_list|,
name|oy
operator|+
name|sibling
operator|->
name|y
argument_list|()
argument_list|,
name|sibling
operator|->
name|width
argument_list|()
argument_list|,
name|sibling
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qRectIntersects
argument_list|(
name|siblingRect
argument_list|,
name|q
operator|->
name|rect
argument_list|()
argument_list|)
condition|)
name|r
operator|-=
name|QRegion
argument_list|(
name|siblingRect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|r
return|;
block|}
DECL|function|setSystemClip
name|void
name|QWidgetPrivate
operator|::
name|setSystemClip
parameter_list|(
name|QPaintDevice
modifier|*
name|paintDevice
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
comment|// Transform the system clip region from device-independent pixels to device pixels
comment|// Qt 5.0.0: This is a Mac-only code path for now, can be made cross-platform once
comment|// it has been tested.
name|QPaintEngine
modifier|*
name|paintEngine
init|=
name|paintDevice
operator|->
name|paintEngine
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
specifier|const
name|qreal
name|devicePixelRatio
init|=
operator|(
name|paintDevice
operator|->
name|physicalDpiX
argument_list|()
operator|==
literal|0
operator|||
name|paintDevice
operator|->
name|logicalDpiX
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|1.0
else|:
operator|(
name|paintDevice
operator|->
name|physicalDpiX
argument_list|()
operator|/
name|paintDevice
operator|->
name|logicalDpiX
argument_list|()
operator|)
decl_stmt|;
name|QTransform
name|scaleTransform
decl_stmt|;
name|scaleTransform
operator|.
name|scale
argument_list|(
name|devicePixelRatio
argument_list|,
name|devicePixelRatio
argument_list|)
expr_stmt|;
name|paintEngine
operator|->
name|d_func
argument_list|()
operator|->
name|systemClip
operator|=
name|scaleTransform
operator|.
name|map
argument_list|(
name|region
argument_list|)
expr_stmt|;
else|#
directive|else
name|paintEngine
operator|->
name|d_func
argument_list|()
operator|->
name|systemClip
operator|=
name|region
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
DECL|function|invalidateGraphicsEffectsRecursively
name|void
name|QWidgetPrivate
operator|::
name|invalidateGraphicsEffectsRecursively
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|graphicsEffect
argument_list|()
condition|)
block|{
name|QWidgetEffectSourcePrivate
modifier|*
name|sourced
init|=
cast|static_cast
argument_list|<
name|QWidgetEffectSourcePrivate
operator|*
argument_list|>
argument_list|(
name|w
operator|->
name|graphicsEffect
argument_list|()
operator|->
name|source
argument_list|()
operator|->
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourced
operator|->
name|updateDueToGraphicsEffect
condition|)
name|w
operator|->
name|graphicsEffect
argument_list|()
operator|->
name|source
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|invalidateCache
argument_list|()
expr_stmt|;
block|}
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
DECL|function|setDirtyOpaqueRegion
name|void
name|QWidgetPrivate
operator|::
name|setDirtyOpaqueRegion
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|dirtyOpaqueChildren
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|invalidateGraphicsEffectsRecursively
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
name|QWidget
modifier|*
name|parent
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
return|return;
comment|// TODO: instead of setting dirtyflag, manipulate the dirtyregion directly?
name|QWidgetPrivate
modifier|*
name|pd
init|=
name|parent
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
operator|->
name|dirtyOpaqueChildren
condition|)
name|pd
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
block|}
DECL|function|getOpaqueChildren
specifier|const
name|QRegion
modifier|&
name|QWidgetPrivate
operator|::
name|getOpaqueChildren
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dirtyOpaqueChildren
condition|)
return|return
name|opaqueChildren
return|;
name|QWidgetPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|opaqueChildren
operator|=
name|QRegion
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
operator|!
name|child
operator|->
name|isVisible
argument_list|()
operator|||
name|child
operator|->
name|isWindow
argument_list|()
condition|)
continue|continue;
specifier|const
name|QPoint
name|offset
init|=
name|child
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QWidgetPrivate
modifier|*
name|childd
init|=
name|child
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QRegion
name|r
init|=
name|childd
operator|->
name|isOpaque
condition|?
name|child
operator|->
name|rect
argument_list|()
else|:
name|childd
operator|->
name|getOpaqueChildren
argument_list|()
decl_stmt|;
if|if
condition|(
name|childd
operator|->
name|extra
operator|&&
name|childd
operator|->
name|extra
operator|->
name|hasMask
condition|)
name|r
operator|&=
name|childd
operator|->
name|extra
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|r
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|that
operator|->
name|opaqueChildren
operator|+=
name|r
expr_stmt|;
block|}
name|that
operator|->
name|opaqueChildren
operator|&=
name|q_func
argument_list|()
operator|->
name|rect
argument_list|()
expr_stmt|;
name|that
operator|->
name|dirtyOpaqueChildren
operator|=
literal|false
expr_stmt|;
return|return
name|that
operator|->
name|opaqueChildren
return|;
block|}
DECL|function|subtractOpaqueChildren
name|void
name|QWidgetPrivate
operator|::
name|subtractOpaqueChildren
parameter_list|(
name|QRegion
modifier|&
name|source
parameter_list|,
specifier|const
name|QRect
modifier|&
name|clipRect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|children
operator|.
name|isEmpty
argument_list|()
operator|||
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|QRegion
modifier|&
name|r
init|=
name|getOpaqueChildren
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
name|source
operator|-=
operator|(
name|r
operator|&
name|clipRect
operator|)
expr_stmt|;
block|}
comment|//subtract any relatives that are higher up than me --- this is too expensive !!!
DECL|function|subtractOpaqueSiblings
name|void
name|QWidgetPrivate
operator|::
name|subtractOpaqueSiblings
parameter_list|(
name|QRegion
modifier|&
name|sourceRegion
parameter_list|,
name|bool
modifier|*
name|hasDirtySiblingsAbove
parameter_list|,
name|bool
name|alsoNonOpaque
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|static
name|int
name|disableSubtractOpaqueSiblings
init|=
name|qgetenv
argument_list|(
literal|"QT_NO_SUBTRACTOPAQUESIBLINGS"
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|disableSubtractOpaqueSiblings
operator|||
name|q
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|q
operator|->
name|d_func
argument_list|()
operator|->
name|isInUnifiedToolbar
condition|)
return|return;
endif|#
directive|endif
comment|// Q_WS_MAC
name|QRect
name|clipBoundingRect
decl_stmt|;
name|bool
name|dirtyClipBoundingRect
init|=
literal|true
decl_stmt|;
name|QRegion
name|parentClip
decl_stmt|;
name|bool
name|dirtyParentClip
init|=
literal|true
decl_stmt|;
name|QPoint
name|parentOffset
init|=
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|QWidgetPrivate
modifier|*
name|pd
init|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
decl_stmt|;
specifier|const
name|int
name|myIndex
init|=
name|pd
operator|->
name|children
operator|.
name|indexOf
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|w
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|widgetGeometry
init|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|effectiveRectFor
argument_list|(
name|w
operator|->
name|data
operator|->
name|crect
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|myIndex
operator|+
literal|1
init|;
name|i
operator|<
name|pd
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|sibling
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|pd
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sibling
operator|||
operator|!
name|sibling
operator|->
name|isVisible
argument_list|()
operator|||
name|sibling
operator|->
name|isWindow
argument_list|()
condition|)
continue|continue;
specifier|const
name|QRect
name|siblingGeometry
init|=
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|effectiveRectFor
argument_list|(
name|sibling
operator|->
name|data
operator|->
name|crect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qRectIntersects
argument_list|(
name|siblingGeometry
argument_list|,
name|widgetGeometry
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dirtyClipBoundingRect
condition|)
block|{
name|clipBoundingRect
operator|=
name|sourceRegion
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|dirtyClipBoundingRect
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qRectIntersects
argument_list|(
name|siblingGeometry
argument_list|,
name|clipBoundingRect
operator|.
name|translated
argument_list|(
name|parentOffset
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dirtyParentClip
condition|)
block|{
name|parentClip
operator|=
name|sourceRegion
operator|.
name|translated
argument_list|(
name|parentOffset
argument_list|)
expr_stmt|;
name|dirtyParentClip
operator|=
literal|false
expr_stmt|;
block|}
specifier|const
name|QPoint
name|siblingPos
argument_list|(
name|sibling
operator|->
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|siblingClipRect
argument_list|(
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|clipRect
argument_list|()
argument_list|)
decl_stmt|;
name|QRegion
name|siblingDirty
argument_list|(
name|parentClip
argument_list|)
decl_stmt|;
name|siblingDirty
operator|&=
operator|(
name|siblingClipRect
operator|.
name|translated
argument_list|(
name|siblingPos
argument_list|)
operator|)
expr_stmt|;
specifier|const
name|bool
name|hasMask
init|=
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|hasMask
operator|&&
operator|!
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|graphicsEffect
decl_stmt|;
if|if
condition|(
name|hasMask
condition|)
name|siblingDirty
operator|&=
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|mask
operator|.
name|translated
argument_list|(
name|siblingPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|siblingDirty
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|isOpaque
operator|||
name|alsoNonOpaque
condition|)
block|{
if|if
condition|(
name|hasMask
condition|)
block|{
name|siblingDirty
operator|.
name|translate
argument_list|(
operator|-
name|parentOffset
argument_list|)
expr_stmt|;
name|sourceRegion
operator|-=
name|siblingDirty
expr_stmt|;
block|}
else|else
block|{
name|sourceRegion
operator|-=
name|siblingGeometry
operator|.
name|translated
argument_list|(
operator|-
name|parentOffset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hasDirtySiblingsAbove
condition|)
operator|*
name|hasDirtySiblingsAbove
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QRegion
name|opaqueSiblingChildren
argument_list|(
name|sibling
operator|->
name|d_func
argument_list|()
operator|->
name|getOpaqueChildren
argument_list|()
argument_list|)
decl_stmt|;
name|opaqueSiblingChildren
operator|.
name|translate
argument_list|(
operator|-
name|parentOffset
operator|+
name|siblingPos
argument_list|)
expr_stmt|;
name|sourceRegion
operator|-=
name|opaqueSiblingChildren
expr_stmt|;
block|}
if|if
condition|(
name|sourceRegion
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|dirtyClipBoundingRect
operator|=
literal|true
expr_stmt|;
name|dirtyParentClip
operator|=
literal|true
expr_stmt|;
block|}
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|parentOffset
operator|+=
name|pd
operator|->
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|dirtyParentClip
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|clipToEffectiveMask
name|void
name|QWidgetPrivate
operator|::
name|clipToEffectiveMask
parameter_list|(
name|QRegion
modifier|&
name|region
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
name|QPoint
name|offset
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|graphicsEffect
condition|)
block|{
name|w
operator|=
name|q
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|offset
operator|-=
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
while|while
condition|(
name|w
condition|)
block|{
specifier|const
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
operator|->
name|extra
operator|&&
name|wd
operator|->
name|extra
operator|->
name|hasMask
condition|)
name|region
operator|&=
operator|(
name|w
operator|!=
name|q
operator|)
condition|?
name|wd
operator|->
name|extra
operator|->
name|mask
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
else|:
name|wd
operator|->
name|extra
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
name|offset
operator|-=
name|wd
operator|->
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|paintOnScreen
name|bool
name|QWidgetPrivate
operator|::
name|paintOnScreen
parameter_list|()
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_BACKINGSTORE
argument_list|)
return|return
literal|true
return|;
else|#
directive|else
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
operator|||
operator|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|q
operator|->
name|window
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|!
name|qt_enable_backingstore
return|;
endif|#
directive|endif
block|}
DECL|function|updateIsOpaque
name|void
name|QWidgetPrivate
operator|::
name|updateIsOpaque
parameter_list|()
block|{
comment|// hw: todo: only needed if opacity actually changed
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|graphicsEffect
condition|)
block|{
comment|// ### We should probably add QGraphicsEffect::isOpaque at some point.
name|setOpaque
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_X11
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_X11OpenGLOverlay
argument_list|)
condition|)
block|{
name|setOpaque
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_OpaquePaintEvent
argument_list|)
operator|||
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
condition|)
block|{
name|setOpaque
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|QPalette
modifier|&
name|pal
init|=
name|q
operator|->
name|palette
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|autoFillBackground
argument_list|()
condition|)
block|{
specifier|const
name|QBrush
modifier|&
name|autoFillBrush
init|=
name|pal
operator|.
name|brush
argument_list|(
name|q
operator|->
name|backgroundRole
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|autoFillBrush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
name|autoFillBrush
operator|.
name|isOpaque
argument_list|()
condition|)
block|{
name|setOpaque
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
condition|)
block|{
specifier|const
name|QBrush
modifier|&
name|windowBrush
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Window
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowBrush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
operator|&&
name|windowBrush
operator|.
name|isOpaque
argument_list|()
condition|)
block|{
name|setOpaque
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|setOpaque
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|setOpaque
name|void
name|QWidgetPrivate
operator|::
name|setOpaque
parameter_list|(
name|bool
name|opaque
parameter_list|)
block|{
if|if
condition|(
name|isOpaque
operator|!=
name|opaque
condition|)
block|{
name|isOpaque
operator|=
name|opaque
expr_stmt|;
name|updateIsTranslucent
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|updateIsTranslucent
name|void
name|QWidgetPrivate
operator|::
name|updateIsTranslucent
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWindow
modifier|*
name|window
init|=
name|q
operator|->
name|windowHandle
argument_list|()
condition|)
block|{
name|QSurfaceFormat
name|format
init|=
name|window
operator|->
name|format
argument_list|()
decl_stmt|;
specifier|const
name|int
name|oldAlpha
init|=
name|format
operator|.
name|alphaBufferSize
argument_list|()
decl_stmt|;
specifier|const
name|int
name|newAlpha
init|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
condition|?
literal|8
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|oldAlpha
operator|!=
name|newAlpha
condition|)
block|{
name|format
operator|.
name|setAlphaBufferSize
argument_list|(
name|newAlpha
argument_list|)
expr_stmt|;
name|window
operator|->
name|setFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|fillRegion
specifier|static
specifier|inline
name|void
name|fillRegion
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|painter
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// Optimize pattern filling on mac by using HITheme directly
comment|// when filling with the standard widget background.
comment|// Defined in qmacstyle_mac.cpp
specifier|extern
name|void
name|qt_mac_fill_background
argument_list|(
name|QPainter
operator|*
name|painter
argument_list|,
specifier|const
name|QRegion
operator|&
name|rgn
argument_list|,
specifier|const
name|QBrush
operator|&
name|brush
argument_list|)
decl_stmt|;
name|qt_mac_fill_background
argument_list|(
name|painter
argument_list|,
name|rgn
argument_list|,
name|brush
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
specifier|const
name|QRect
name|rect
argument_list|(
name|rgn
operator|.
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
name|painter
operator|->
name|setClipRegion
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawTiledPixmap
argument_list|(
name|rect
argument_list|,
name|brush
operator|.
name|texture
argument_list|()
argument_list|,
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
block|}
elseif|else
if|if
condition|(
name|brush
operator|.
name|gradient
argument_list|()
operator|&&
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|coordinateMode
argument_list|()
operator|==
name|QGradient
operator|::
name|ObjectBoundingMode
condition|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setClipRegion
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|painter
operator|->
name|fillRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
argument_list|,
name|brush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
init|=
name|rgn
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|painter
operator|->
name|fillRect
argument_list|(
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|brush
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|paintBackground
name|void
name|QWidgetPrivate
operator|::
name|paintBackground
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|,
name|int
name|flags
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SCROLLAREA
name|bool
name|resetBrushOrigin
init|=
literal|false
decl_stmt|;
name|QPointF
name|oldBrushOrigin
decl_stmt|;
comment|//If we are painting the viewport of a scrollarea, we must apply an offset to the brush in case we are drawing a texture
name|QAbstractScrollArea
modifier|*
name|scrollArea
init|=
name|qobject_cast
argument_list|<
name|QAbstractScrollArea
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|scrollArea
operator|&&
name|scrollArea
operator|->
name|viewport
argument_list|()
operator|==
name|q
condition|)
block|{
name|QObjectData
modifier|*
name|scrollPrivate
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|scrollArea
argument_list|)
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|QAbstractScrollAreaPrivate
modifier|*
name|priv
init|=
cast|static_cast
argument_list|<
name|QAbstractScrollAreaPrivate
operator|*
argument_list|>
argument_list|(
name|scrollPrivate
argument_list|)
decl_stmt|;
name|oldBrushOrigin
operator|=
name|painter
operator|->
name|brushOrigin
argument_list|()
expr_stmt|;
name|resetBrushOrigin
operator|=
literal|true
expr_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
operator|-
name|priv
operator|->
name|contentsOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_SCROLLAREA
specifier|const
name|QBrush
name|autoFillBrush
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|q
operator|->
name|backgroundRole
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DrawAsRoot
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|autoFillBackground
argument_list|()
operator|&&
name|autoFillBrush
operator|.
name|isOpaque
argument_list|()
operator|)
condition|)
block|{
specifier|const
name|QBrush
name|bg
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DontSetCompositionMode
operator|)
condition|)
block|{
comment|//copy alpha straight in
name|QPainter
operator|::
name|CompositionMode
name|oldMode
init|=
name|painter
operator|->
name|compositionMode
argument_list|()
decl_stmt|;
name|painter
operator|->
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|fillRegion
argument_list|(
name|painter
argument_list|,
name|rgn
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setCompositionMode
argument_list|(
name|oldMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fillRegion
argument_list|(
name|painter
argument_list|,
name|rgn
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|autoFillBackground
argument_list|()
condition|)
name|fillRegion
argument_list|(
name|painter
argument_list|,
name|rgn
argument_list|,
name|autoFillBrush
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyledBackground
argument_list|)
condition|)
block|{
name|painter
operator|->
name|setClipRegion
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|QStyleOption
name|opt
decl_stmt|;
name|opt
operator|.
name|initFrom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_Widget
argument_list|,
operator|&
name|opt
argument_list|,
name|painter
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_SCROLLAREA
if|if
condition|(
name|resetBrushOrigin
condition|)
name|painter
operator|->
name|setBrushOrigin
argument_list|(
name|oldBrushOrigin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_SCROLLAREA
block|}
comment|/*   \internal   This function is called when a widget is hidden or destroyed.   It resets some application global pointers that should only refer active,   visible widgets. */
ifdef|#
directive|ifdef
name|Q_WS_MAC
specifier|extern
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|qt_button_down
decl_stmt|;
else|#
directive|else
specifier|extern
name|QWidget
modifier|*
name|qt_button_down
decl_stmt|;
endif|#
directive|endif
DECL|function|deactivateWidgetCleanup
name|void
name|QWidgetPrivate
operator|::
name|deactivateWidgetCleanup
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// If this was the active application window, reset it
if|if
condition|(
name|QApplication
operator|::
name|activeWindow
argument_list|()
operator|==
name|q
condition|)
name|QApplication
operator|::
name|setActiveWindow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// If the is the active mouse press widget, reset it
if|if
condition|(
name|q
operator|==
name|qt_button_down
condition|)
name|qt_button_down
operator|=
literal|0
expr_stmt|;
block|}
comment|/*!     Returns a pointer to the widget with window identifer/handle \a     id.      The window identifier type depends on the underlying window     system, see \c qwindowdefs.h for the actual definition. If there     is no widget with this identifier, 0 is returned. */
DECL|function|find
name|QWidget
modifier|*
name|QWidget
operator|::
name|find
parameter_list|(
name|WId
name|id
parameter_list|)
block|{
return|return
name|QWidgetPrivate
operator|::
name|mapper
condition|?
name|QWidgetPrivate
operator|::
name|mapper
operator|->
name|value
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
else|:
literal|0
return|;
block|}
comment|/*!     \fn WId QWidget::internalWinId() const     \internal     Returns the window system identifier of the widget, or 0 if the widget is not created yet.  */
comment|/*!     \fn WId QWidget::winId() const      Returns the window system identifier of the widget.      Portable in principle, but if you use it you are probably about to     do something non-portable. Be careful.      If a widget is non-native (alien) and winId() is invoked on it, that widget     will be provided a native handle.      On Mac OS X, the type returned depends on which framework Qt was linked     against. If Qt is using Carbon, the {WId} is actually an HIViewRef. If Qt     is using Cocoa, {WId} is a pointer to an NSView.      This value may change at run-time. An event with type QEvent::WinIdChange     will be sent to the widget following a change in window system identifier.      \sa find() */
DECL|function|winId
name|WId
name|QWidget
operator|::
name|winId
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|||
operator|!
name|internalWinId
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWidget::winId: creating native window for"
operator|<<
name|this
expr_stmt|;
endif|#
directive|endif
name|QWidget
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
name|that
operator|->
name|d_func
argument_list|()
operator|->
name|createWinId
argument_list|()
expr_stmt|;
return|return
name|that
operator|->
name|data
operator|->
name|winid
return|;
block|}
return|return
name|data
operator|->
name|winid
return|;
block|}
DECL|function|createWinId
name|void
name|QWidgetPrivate
operator|::
name|createWinId
parameter_list|(
name|WId
name|winid
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWidgetPrivate::createWinId for"
operator|<<
name|q
operator|<<
name|winid
expr_stmt|;
endif|#
directive|endif
specifier|const
name|bool
name|forceNativeWindow
init|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|||
operator|(
name|forceNativeWindow
operator|&&
operator|!
name|q
operator|->
name|internalWinId
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|parent
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|QWidgetPrivate
modifier|*
name|pd
init|=
name|parent
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|forceNativeWindow
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
condition|)
name|parent
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|internalWinId
argument_list|()
condition|)
block|{
name|pd
operator|->
name|createWinId
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|pd
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|||
operator|(
operator|!
name|w
operator|->
name|internalWinId
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|!=
name|q
condition|)
block|{
name|w
operator|->
name|create
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|create
argument_list|(
name|winid
argument_list|)
expr_stmt|;
comment|// if the window has already been created, we
comment|// need to raise it to its proper stacking position
if|if
condition|(
name|winid
condition|)
name|w
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|q
operator|->
name|create
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*! \internal Ensures that the widget has a window system identifier, i.e. that it is known to the windowing system.  */
DECL|function|createWinId
name|void
name|QWidget
operator|::
name|createWinId
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIEN_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWidget::createWinId"
operator|<<
name|this
expr_stmt|;
endif|#
directive|endif
comment|//    qWarning("QWidget::createWinId is obsolete, please fix your code.");
name|d
operator|->
name|createWinId
argument_list|()
expr_stmt|;
block|}
comment|/*!     \since 4.4      Returns the effective window system identifier of the widget, i.e. the     native parent's window system identifier.      If the widget is native, this function returns the native widget ID.     Otherwise, the window ID of the first native parent widget, i.e., the     top-level widget that contains this widget, is returned.      \note We recommend that you do not store this value as it is likely to     change at run-time.      \sa nativeParentWidget() */
DECL|function|effectiveWinId
name|WId
name|QWidget
operator|::
name|effectiveWinId
parameter_list|()
specifier|const
block|{
specifier|const
name|WId
name|id
init|=
name|internalWinId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|||
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
return|return
name|id
return|;
if|if
condition|(
specifier|const
name|QWidget
modifier|*
name|realParent
init|=
name|nativeParentWidget
argument_list|()
condition|)
return|return
name|realParent
operator|->
name|internalWinId
argument_list|()
return|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
comment|/*!     \property QWidget::styleSheet     \brief the widget's style sheet     \since 4.2      The style sheet contains a textual description of customizations to the     widget's style, as described in the \l{Qt Style Sheets} document.      Since Qt 4.5, Qt style sheets fully supports Mac OS X.      \warning Qt style sheets are currently not supported for custom QStyle     subclasses. We plan to address this in some future release.      \sa setStyle(), QApplication::styleSheet, {Qt Style Sheets} */
DECL|function|styleSheet
name|QString
name|QWidget
operator|::
name|styleSheet
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|extra
operator|->
name|styleSheet
return|;
block|}
DECL|function|setStyleSheet
name|void
name|QWidget
operator|::
name|setStyleSheet
parameter_list|(
specifier|const
name|QString
modifier|&
name|styleSheet
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|extra
operator|->
name|style
argument_list|)
decl_stmt|;
name|d
operator|->
name|extra
operator|->
name|styleSheet
operator|=
name|styleSheet
expr_stmt|;
if|if
condition|(
name|styleSheet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// stylesheet removed
if|if
condition|(
operator|!
name|proxy
condition|)
return|return;
name|d
operator|->
name|inheritStyle
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|proxy
condition|)
block|{
comment|// style sheet update
name|proxy
operator|->
name|repolish
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
block|{
name|d
operator|->
name|setStyle_helper
argument_list|(
operator|new
name|QStyleSheetStyle
argument_list|(
name|d
operator|->
name|extra
operator|->
name|style
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setStyle_helper
argument_list|(
operator|new
name|QStyleSheetStyle
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_STYLE_STYLESHEET
comment|/*!     \sa QWidget::setStyle(), QApplication::setStyle(), QApplication::style() */
DECL|function|style
name|QStyle
modifier|*
name|QWidget
operator|::
name|style
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|style
condition|)
return|return
name|d
operator|->
name|extra
operator|->
name|style
return|;
return|return
name|QApplication
operator|::
name|style
argument_list|()
return|;
block|}
comment|/*!     Sets the widget's GUI style to \a style. The ownership of the style     object is not transferred.      If no style is set, the widget uses the application's style,     QApplication::style() instead.      Setting a widget's style has no effect on existing or future child     widgets.      \warning This function is particularly useful for demonstration     purposes, where you want to show Qt's styling capabilities. Real     applications should avoid it and use one consistent GUI style     instead.      \warning Qt style sheets are currently not supported for custom QStyle     subclasses. We plan to address this in some future release.      \sa style(), QStyle, QApplication::style(), QApplication::setStyle() */
DECL|function|setStyle
name|void
name|QWidget
operator|::
name|setStyle
parameter_list|(
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|,
name|style
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|style
argument_list|)
condition|)
block|{
comment|//if for some reason someone try to set a QStyleSheetStyle, ref it
comment|//(this may happen for exemple in QButtonDialogBox which propagates its style)
name|proxy
operator|->
name|ref
argument_list|()
expr_stmt|;
name|d
operator|->
name|setStyle_helper
argument_list|(
name|style
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|extra
operator|->
name|style
argument_list|)
operator|||
operator|!
name|qApp
operator|->
name|styleSheet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if we have an application stylesheet or have a proxy already, propagate
name|d
operator|->
name|setStyle_helper
argument_list|(
operator|new
name|QStyleSheetStyle
argument_list|(
name|style
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|d
operator|->
name|setStyle_helper
argument_list|(
name|style
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|function|setStyle_helper
name|void
name|QWidgetPrivate
operator|::
name|setStyle_helper
parameter_list|(
name|QStyle
modifier|*
name|newStyle
parameter_list|,
name|bool
name|propagate
parameter_list|,
name|bool
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|metalHack
endif|#
directive|endif
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QStyle
modifier|*
name|oldStyle
init|=
name|q
operator|->
name|style
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
name|QPointer
argument_list|<
name|QStyle
argument_list|>
name|origStyle
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// the metalhack boolean allows Qt/Mac to do a proper re-polish depending
comment|// on how the Qt::WA_MacBrushedMetal attribute is set. It is only ever
comment|// set when changing that attribute and passes the widget's CURRENT style.
comment|// therefore no need to do a reassignment.
if|if
condition|(
operator|!
name|metalHack
condition|)
endif|#
directive|endif
block|{
name|createExtra
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
name|origStyle
operator|=
name|extra
operator|->
name|style
operator|.
name|data
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|extra
operator|->
name|style
operator|=
name|newStyle
expr_stmt|;
block|}
comment|// repolish
if|if
condition|(
name|q
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
if|if
condition|(
name|polished
condition|)
block|{
name|oldStyle
operator|->
name|unpolish
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|metalHack
condition|)
name|macUpdateMetalAttribute
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|style
argument_list|()
operator|->
name|polish
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
block|}
elseif|else
if|if
condition|(
name|metalHack
condition|)
block|{
name|macUpdateMetalAttribute
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|propagate
condition|)
block|{
comment|// We copy the list because the order may be modified
specifier|const
name|QObjectList
name|childrenList
init|=
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childrenList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|c
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childrenList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
name|c
operator|->
name|d_func
argument_list|()
operator|->
name|inheritStyle
argument_list|()
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
operator|!
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|newStyle
argument_list|)
condition|)
block|{
if|if
condition|(
specifier|const
name|QStyleSheetStyle
modifier|*
name|cssStyle
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|origStyle
operator|.
name|data
argument_list|()
argument_list|)
condition|)
block|{
name|cssStyle
operator|->
name|clearWidgetFont
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
comment|// dereference the old stylesheet style
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|origStyle
operator|.
name|data
argument_list|()
argument_list|)
condition|)
name|proxy
operator|->
name|deref
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|// Inherits style from the current parent and propagates it as necessary
DECL|function|inheritStyle
name|void
name|QWidgetPrivate
operator|::
name|inheritStyle
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|extra
condition|?
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|extra
operator|->
name|style
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|styleSheet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
name|proxy
operator|->
name|repolish
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
name|QStyle
modifier|*
name|origStyle
init|=
name|proxy
condition|?
name|proxy
operator|->
name|base
else|:
operator|(
name|extra
condition|?
operator|(
name|QStyle
operator|*
operator|)
name|extra
operator|->
name|style
else|:
literal|0
operator|)
decl_stmt|;
name|QWidget
modifier|*
name|parent
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|QStyle
modifier|*
name|parentStyle
init|=
operator|(
name|parent
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|)
condition|?
operator|(
name|QStyle
operator|*
operator|)
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|style
else|:
literal|0
decl_stmt|;
comment|// If we have stylesheet on app or parent has stylesheet style, we need
comment|// to be running a proxy
if|if
condition|(
operator|!
name|qApp
operator|->
name|styleSheet
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|parentStyle
argument_list|)
condition|)
block|{
name|QStyle
modifier|*
name|newStyle
init|=
name|parentStyle
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
name|newStyle
operator|=
operator|new
name|QStyleSheetStyle
argument_list|(
name|origStyle
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|newProxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|parentStyle
argument_list|)
condition|)
name|newProxy
operator|->
name|ref
argument_list|()
expr_stmt|;
name|setStyle_helper
argument_list|(
name|newStyle
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// So, we have no stylesheet on parent/app and we have an empty stylesheet
comment|// we just need our original style back
if|if
condition|(
name|origStyle
operator|==
operator|(
name|extra
condition|?
operator|(
name|QStyle
operator|*
operator|)
name|extra
operator|->
name|style
else|:
literal|0
operator|)
condition|)
comment|// is it any different?
return|return;
comment|// We could have inherited the proxy from our parent (which has a custom style)
comment|// In such a case we need to start following the application style (i.e revert
comment|// the propagation behavior of QStyleSheetStyle)
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
name|origStyle
operator|=
literal|0
expr_stmt|;
name|setStyle_helper
argument_list|(
name|origStyle
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_STYLE_STYLESHEET
block|}
comment|/*!     \fn bool QWidget::isWindow() const      Returns true if the widget is an independent window, otherwise     returns false.      A window is a widget that isn't visually the child of any other     widget and that usually has a frame and a     \l{QWidget::setWindowTitle()}{window title}.      A window can have a \l{QWidget::parentWidget()}{parent widget}.     It will then be grouped with its parent and deleted when the     parent is deleted, minimized when the parent is minimized etc. If     supported by the window manager, it will also have a common     taskbar entry with its parent.      QDialog and QMainWindow widgets are by default windows, even if a     parent widget is specified in the constructor. This behavior is     specified by the Qt::Window flag.      \sa window(), isModal(), parentWidget() */
comment|/*!     \property QWidget::modal     \brief whether the widget is a modal widget      This property only makes sense for windows. A modal widget     prevents widgets in all other windows from getting any input.      By default, this property is false.      \sa isWindow(), windowModality, QDialog */
comment|/*!     \property QWidget::windowModality     \brief which windows are blocked by the modal widget     \since 4.1      This property only makes sense for windows. A modal widget     prevents widgets in other windows from getting input. The value of     this property controls which windows are blocked when the widget     is visible. Changing this property while the window is visible has     no effect; you must hide() the widget first, then show() it again.      By default, this property is Qt::NonModal.      \sa isWindow(), QWidget::modal, QDialog */
DECL|function|windowModality
name|Qt
operator|::
name|WindowModality
name|QWidget
operator|::
name|windowModality
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|Qt
operator|::
name|WindowModality
argument_list|>
argument_list|(
name|data
operator|->
name|window_modality
argument_list|)
return|;
block|}
DECL|function|setWindowModality
name|void
name|QWidget
operator|::
name|setWindowModality
parameter_list|(
name|Qt
operator|::
name|WindowModality
name|windowModality
parameter_list|)
block|{
name|data
operator|->
name|window_modality
operator|=
name|windowModality
expr_stmt|;
comment|// setModal_sys() will be called by setAttribute()
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_ShowModal
argument_list|,
operator|(
name|data
operator|->
name|window_modality
operator|!=
name|Qt
operator|::
name|NonModal
operator|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetWindowModality
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*!     \fn bool QWidget::underMouse() const      Returns true if the widget is under the mouse cursor; otherwise     returns false.      This value is not updated properly during drag and drop     operations.      \sa enterEvent(), leaveEvent() */
comment|/*!     \property QWidget::minimized     \brief whether this widget is minimized (iconified)      This property is only relevant for windows.      By default, this property is false.      \sa showMinimized(), visible, show(), hide(), showNormal(), maximized */
DECL|function|isMinimized
name|bool
name|QWidget
operator|::
name|isMinimized
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|->
name|window_state
operator|&
name|Qt
operator|::
name|WindowMinimized
return|;
block|}
comment|/*!     Shows the widget minimized, as an icon.      Calling this function only affects \l{isWindow()}{windows}.      \sa showNormal(), showMaximized(), show(), hide(), isVisible(),         isMinimized() */
DECL|function|showMinimized
name|void
name|QWidget
operator|::
name|showMinimized
parameter_list|()
block|{
name|bool
name|isMin
init|=
name|isMinimized
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMin
operator|&&
name|isVisible
argument_list|()
condition|)
return|return;
name|ensurePolished
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isMin
condition|)
name|setWindowState
argument_list|(
operator|(
name|windowState
argument_list|()
operator|&
operator|~
name|Qt
operator|::
name|WindowActive
operator|)
operator||
name|Qt
operator|::
name|WindowMinimized
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::maximized     \brief whether this widget is maximized      This property is only relevant for windows.      \note Due to limitations on some window systems, this does not always     report the expected results (e.g., if the user on X11 maximizes the     window via the window manager, Qt has no way of distinguishing this     from any other resize). This is expected to improve as window manager     protocols evolve.      By default, this property is false.      \sa windowState(), showMaximized(), visible, show(), hide(), showNormal(), minimized */
DECL|function|isMaximized
name|bool
name|QWidget
operator|::
name|isMaximized
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|->
name|window_state
operator|&
name|Qt
operator|::
name|WindowMaximized
return|;
block|}
comment|/*!     Returns the current window state. The window state is a OR'ed     combination of Qt::WindowState: Qt::WindowMinimized,     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.    \sa Qt::WindowState, setWindowState()  */
DECL|function|windowState
name|Qt
operator|::
name|WindowStates
name|QWidget
operator|::
name|windowState
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|WindowStates
argument_list|(
name|data
operator|->
name|window_state
argument_list|)
return|;
block|}
comment|/*!\internal     The function sets the window state on child widgets similar to    setWindowState(). The difference is that the window state changed    event has the isOverride() flag set. It exists mainly to keep    QWorkspace working.  */
DECL|function|overrideWindowState
name|void
name|QWidget
operator|::
name|overrideWindowState
parameter_list|(
name|Qt
operator|::
name|WindowStates
name|newstate
parameter_list|)
block|{
name|QWindowStateChangeEvent
name|e
argument_list|(
name|Qt
operator|::
name|WindowStates
argument_list|(
name|data
operator|->
name|window_state
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|data
operator|->
name|window_state
operator|=
name|newstate
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::setWindowState(Qt::WindowStates windowState)      Sets the window state to \a windowState. The window state is a OR'ed     combination of Qt::WindowState: Qt::WindowMinimized,     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.      If the window is not visible (i.e. isVisible() returns false), the     window state will take effect when show() is called. For visible     windows, the change is immediate. For example, to toggle between     full-screen and normal mode, use the following code:      \snippet code/src_gui_kernel_qwidget.cpp 0      In order to restore and activate a minimized window (while     preserving its maximized and/or full-screen state), use the following:      \snippet code/src_gui_kernel_qwidget.cpp 1      Calling this function will hide the widget. You must call show() to make     the widget visible again.      \note On some window systems Qt::WindowActive is not immediate, and may be     ignored in certain cases.      When the window state changes, the widget receives a changeEvent()     of type QEvent::WindowStateChange.      \sa Qt::WindowState, windowState() */
comment|/*!     \property QWidget::fullScreen     \brief whether the widget is shown in full screen mode      A widget in full screen mode occupies the whole screen area and does not     display window decorations, such as a title bar.      By default, this property is false.      \sa windowState(), minimized, maximized */
DECL|function|isFullScreen
name|bool
name|QWidget
operator|::
name|isFullScreen
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|->
name|window_state
operator|&
name|Qt
operator|::
name|WindowFullScreen
return|;
block|}
comment|/*!     Shows the widget in full-screen mode.      Calling this function only affects \l{isWindow()}{windows}.      To return from full-screen mode, call showNormal().      Full-screen mode works fine under Windows, but has certain     problems under X. These problems are due to limitations of the     ICCCM protocol that specifies the communication between X11     clients and the window manager. ICCCM simply does not understand     the concept of non-decorated full-screen windows. Therefore, the     best we can do is to request a borderless window and place and     resize it to fill the entire screen. Depending on the window     manager, this may or may not work. The borderless window is     requested using MOTIF hints, which are at least partially     supported by virtually all modern window managers.      An alternative would be to bypass the window manager entirely and     create a window with the Qt::X11BypassWindowManagerHint flag. This     has other severe problems though, like totally broken keyboard focus     and very strange effects on desktop changes or when the user raises     other windows.      X11 window managers that follow modern post-ICCCM specifications     support full-screen mode properly.      \sa showNormal(), showMaximized(), show(), hide(), isVisible() */
DECL|function|showFullScreen
name|void
name|QWidget
operator|::
name|showFullScreen
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// If the unified toolbar is enabled, we have to disable it before going fullscreen.
name|QMainWindow
modifier|*
name|mainWindow
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainWindow
operator|&&
name|mainWindow
operator|->
name|unifiedTitleAndToolBarOnMac
argument_list|()
condition|)
block|{
name|mainWindow
operator|->
name|setUnifiedTitleAndToolBarOnMac
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QMainWindowLayout
modifier|*
name|mainLayout
init|=
name|qobject_cast
argument_list|<
name|QMainWindowLayout
operator|*
argument_list|>
argument_list|(
name|mainWindow
operator|->
name|layout
argument_list|()
argument_list|)
decl_stmt|;
name|mainLayout
operator|->
name|activateUnifiedToolbarAfterFullScreen
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|ensurePolished
argument_list|()
expr_stmt|;
name|setWindowState
argument_list|(
operator|(
name|windowState
argument_list|()
operator|&
operator|~
operator|(
name|Qt
operator|::
name|WindowMinimized
operator||
name|Qt
operator|::
name|WindowMaximized
operator|)
operator|)
operator||
name|Qt
operator|::
name|WindowFullScreen
argument_list|)
expr_stmt|;
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|activateWindow
argument_list|()
expr_stmt|;
block|}
comment|/*!     Shows the widget maximized.      Calling this function only affects \l{isWindow()}{windows}.      On X11, this function may not work properly with certain window     managers. See the \l{Window Geometry} documentation for an explanation.      \sa setWindowState(), showNormal(), showMinimized(), show(), hide(), isVisible() */
DECL|function|showMaximized
name|void
name|QWidget
operator|::
name|showMaximized
parameter_list|()
block|{
name|ensurePolished
argument_list|()
expr_stmt|;
name|setWindowState
argument_list|(
operator|(
name|windowState
argument_list|()
operator|&
operator|~
operator|(
name|Qt
operator|::
name|WindowMinimized
operator||
name|Qt
operator|::
name|WindowFullScreen
operator|)
operator|)
operator||
name|Qt
operator|::
name|WindowMaximized
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// If the unified toolbar was enabled before going fullscreen, we have to enable it back.
name|QMainWindow
modifier|*
name|mainWindow
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainWindow
condition|)
block|{
name|QMainWindowLayout
modifier|*
name|mainLayout
init|=
name|qobject_cast
argument_list|<
name|QMainWindowLayout
operator|*
argument_list|>
argument_list|(
name|mainWindow
operator|->
name|layout
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainLayout
operator|->
name|activateUnifiedToolbarAfterFullScreen
condition|)
block|{
name|mainWindow
operator|->
name|setUnifiedTitleAndToolBarOnMac
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mainLayout
operator|->
name|activateUnifiedToolbarAfterFullScreen
operator|=
literal|false
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*!     Restores the widget after it has been maximized or minimized.      Calling this function only affects \l{isWindow()}{windows}.      \sa setWindowState(), showMinimized(), showMaximized(), show(), hide(), isVisible() */
DECL|function|showNormal
name|void
name|QWidget
operator|::
name|showNormal
parameter_list|()
block|{
name|ensurePolished
argument_list|()
expr_stmt|;
name|setWindowState
argument_list|(
name|windowState
argument_list|()
operator|&
operator|~
operator|(
name|Qt
operator|::
name|WindowMinimized
operator||
name|Qt
operator|::
name|WindowMaximized
operator||
name|Qt
operator|::
name|WindowFullScreen
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// If the unified toolbar was enabled before going fullscreen, we have to enable it back.
name|QMainWindow
modifier|*
name|mainWindow
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainWindow
condition|)
block|{
name|QMainWindowLayout
modifier|*
name|mainLayout
init|=
name|qobject_cast
argument_list|<
name|QMainWindowLayout
operator|*
argument_list|>
argument_list|(
name|mainWindow
operator|->
name|layout
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mainLayout
operator|->
name|activateUnifiedToolbarAfterFullScreen
condition|)
block|{
name|mainWindow
operator|->
name|setUnifiedTitleAndToolBarOnMac
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|mainLayout
operator|->
name|activateUnifiedToolbarAfterFullScreen
operator|=
literal|false
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*!     Returns true if this widget would become enabled if \a ancestor is     enabled; otherwise returns false.        This is the case if neither the widget itself nor every parent up     to but excluding \a ancestor has been explicitly disabled.      isEnabledTo(0) is equivalent to isEnabled().      \sa setEnabled(), enabled */
DECL|function|isEnabledTo
name|bool
name|QWidget
operator|::
name|isEnabledTo
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|ancestor
parameter_list|)
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceDisabled
argument_list|)
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
operator|!=
name|ancestor
condition|)
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
return|return
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceDisabled
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_ACTION
comment|/*!     Appends the action \a action to this widget's list of actions.      All QWidgets have a list of \l{QAction}s, however they can be     represented graphically in many different ways. The default use of     the QAction list (as returned by actions()) is to create a context     QMenu.      A QWidget should only have one of each action and adding an action     it already has will not cause the same action to be in the widget twice.      The ownership of \a action is not transferred to this QWidget.      \sa removeAction(), insertAction(), actions(), QMenu */
DECL|function|addAction
name|void
name|QWidget
operator|::
name|addAction
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
block|{
name|insertAction
argument_list|(
literal|0
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
comment|/*!     Appends the actions \a actions to this widget's list of actions.      \sa removeAction(), QMenu, addAction() */
DECL|function|addActions
name|void
name|QWidget
operator|::
name|addActions
parameter_list|(
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|actions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|actions
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
name|insertAction
argument_list|(
literal|0
argument_list|,
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*!     Inserts the action \a action to this widget's list of actions,     before the action \a before. It appends the action if \a before is 0 or     \a before is not a valid action for this widget.      A QWidget should only have one of each action.      \sa removeAction(), addAction(), QMenu, contextMenuPolicy, actions() */
DECL|function|insertAction
name|void
name|QWidget
operator|::
name|insertAction
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|,
name|QAction
modifier|*
name|action
parameter_list|)
block|{
if|if
condition|(
operator|!
name|action
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::insertAction: Attempt to insert null action"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|actions
operator|.
name|contains
argument_list|(
name|action
argument_list|)
condition|)
name|removeAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|d
operator|->
name|actions
operator|.
name|indexOf
argument_list|(
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|before
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|d
operator|->
name|actions
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|actions
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|QActionPrivate
modifier|*
name|apriv
init|=
name|action
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|widgets
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QActionEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ActionAdded
argument_list|,
name|action
argument_list|,
name|before
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     Inserts the actions \a actions to this widget's list of actions,     before the action \a before. It appends the action if \a before is 0 or     \a before is not a valid action for this widget.      A QWidget can have at most one of each action.      \sa removeAction(), QMenu, insertAction(), contextMenuPolicy */
DECL|function|insertActions
name|void
name|QWidget
operator|::
name|insertActions
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|,
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|actions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|actions
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|insertAction
argument_list|(
name|before
argument_list|,
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*!     Removes the action \a action from this widget's list of actions.     \sa insertAction(), actions(), insertAction() */
DECL|function|removeAction
name|void
name|QWidget
operator|::
name|removeAction
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
block|{
if|if
condition|(
operator|!
name|action
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QActionPrivate
modifier|*
name|apriv
init|=
name|action
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|widgets
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|actions
operator|.
name|removeAll
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|QActionEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ActionRemoved
argument_list|,
name|action
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     Returns the (possibly empty) list of this widget's actions.      \sa contextMenuPolicy, insertAction(), removeAction() */
DECL|function|actions
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|QWidget
operator|::
name|actions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|actions
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_ACTION
comment|/*!   \fn bool QWidget::isEnabledToTLW() const   \obsolete    This function is deprecated. It is equivalent to isEnabled() */
comment|/*!     \property QWidget::enabled     \brief whether the widget is enabled      In general an enabled widget handles keyboard and mouse events; a disabled     widget does not. An exception is made with \l{QAbstractButton}.      Some widgets display themselves differently when they are     disabled. For example a button might draw its label grayed out. If     your widget needs to know when it becomes enabled or disabled, you     can use the changeEvent() with type QEvent::EnabledChange.      Disabling a widget implicitly disables all its children. Enabling     respectively enables all child widgets unless they have been     explicitly disabled.      By default, this property is true.      \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent() */
DECL|function|setEnabled
name|void
name|QWidget
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceDisabled
argument_list|,
operator|!
name|enable
argument_list|)
expr_stmt|;
name|d
operator|->
name|setEnabled_helper
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
DECL|function|setEnabled_helper
name|void
name|QWidgetPrivate
operator|::
name|setEnabled_helper
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|&&
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|isEnabled
argument_list|()
condition|)
return|return;
comment|// nothing we can do
if|if
condition|(
name|enable
operator|!=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Disabled
argument_list|)
condition|)
return|return;
comment|// nothing to do
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Disabled
argument_list|,
operator|!
name|enable
argument_list|)
expr_stmt|;
name|updateSystemBackground
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|enable
operator|&&
name|q
operator|->
name|window
argument_list|()
operator|->
name|focusWidget
argument_list|()
operator|==
name|q
condition|)
block|{
name|bool
name|parentIsEnabled
init|=
operator|(
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|||
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|isEnabled
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentIsEnabled
operator|||
operator|!
name|q
operator|->
name|focusNextChild
argument_list|()
condition|)
name|q
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
block|}
name|Qt
operator|::
name|WidgetAttribute
name|attribute
init|=
name|enable
condition|?
name|Qt
operator|::
name|WA_ForceDisabled
else|:
name|Qt
operator|::
name|WA_Disabled
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|attribute
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setEnabled_helper
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
operator|||
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
comment|// enforce the windows behavior of clearing the cursor on
comment|// disabled widgets
name|qt_x11_enforce_cursor
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
operator|||
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
comment|// enforce the windows behavior of clearing the cursor on
comment|// disabled widgets
name|qt_qpa_set_cursor
argument_list|(
name|q
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|setEnabled_helper_sys
argument_list|(
name|enable
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
operator|&&
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|focusWidget
init|=
name|effectiveFocusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|focusWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_IM
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|EnabledChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::acceptDrops     \brief whether drop events are enabled for this widget      Setting this property to true announces to the system that this     widget \e may be able to accept drop events.      If the widget is the desktop (windowType() == Qt::Desktop), this may     fail if another application is using the desktop; you can call     acceptDrops() to test if this occurs.      \warning Do not modify this property in a drag and drop event handler.      By default, this property is false.      \sa {Drag and Drop} */
DECL|function|acceptDrops
name|bool
name|QWidget
operator|::
name|acceptDrops
parameter_list|()
specifier|const
block|{
return|return
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptDrops
argument_list|)
return|;
block|}
DECL|function|setAcceptDrops
name|void
name|QWidget
operator|::
name|setAcceptDrops
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptDrops
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
comment|/*!     Disables widget input events if \a disable is true; otherwise     enables input events.      See the \l enabled documentation for more information.      \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent() */
DECL|function|setDisabled
name|void
name|QWidget
operator|::
name|setDisabled
parameter_list|(
name|bool
name|disable
parameter_list|)
block|{
name|setEnabled
argument_list|(
operator|!
name|disable
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::frameGeometry     \brief geometry of the widget relative to its parent including any     window frame      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      By default, this property contains a value that depends on the user's     platform and screen geometry.      \sa geometry(), x(), y(), pos() */
DECL|function|frameGeometry
name|QRect
name|QWidget
operator|::
name|frameGeometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
block|{
name|QRect
name|fs
init|=
name|d
operator|->
name|frameStrut
argument_list|()
decl_stmt|;
return|return
name|QRect
argument_list|(
name|data
operator|->
name|crect
operator|.
name|x
argument_list|()
operator|-
name|fs
operator|.
name|left
argument_list|()
argument_list|,
name|data
operator|->
name|crect
operator|.
name|y
argument_list|()
operator|-
name|fs
operator|.
name|top
argument_list|()
argument_list|,
name|data
operator|->
name|crect
operator|.
name|width
argument_list|()
operator|+
name|fs
operator|.
name|left
argument_list|()
operator|+
name|fs
operator|.
name|right
argument_list|()
argument_list|,
name|data
operator|->
name|crect
operator|.
name|height
argument_list|()
operator|+
name|fs
operator|.
name|top
argument_list|()
operator|+
name|fs
operator|.
name|bottom
argument_list|()
argument_list|)
return|;
block|}
return|return
name|data
operator|->
name|crect
return|;
block|}
comment|/*!     \property QWidget::x      \brief the x coordinate of the widget relative to its parent including     any window frame      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      By default, this property has a value of 0.      \sa frameGeometry, y, pos */
DECL|function|x
name|int
name|QWidget
operator|::
name|x
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
return|return
name|data
operator|->
name|crect
operator|.
name|x
argument_list|()
operator|-
name|d
operator|->
name|frameStrut
argument_list|()
operator|.
name|left
argument_list|()
return|;
return|return
name|data
operator|->
name|crect
operator|.
name|x
argument_list|()
return|;
block|}
comment|/*!     \property QWidget::y     \brief the y coordinate of the widget relative to its parent and     including any window frame      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      By default, this property has a value of 0.      \sa frameGeometry, x, pos */
DECL|function|y
name|int
name|QWidget
operator|::
name|y
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
return|return
name|data
operator|->
name|crect
operator|.
name|y
argument_list|()
operator|-
name|d
operator|->
name|frameStrut
argument_list|()
operator|.
name|top
argument_list|()
return|;
return|return
name|data
operator|->
name|crect
operator|.
name|y
argument_list|()
return|;
block|}
comment|/*!     \property QWidget::pos     \brief the position of the widget within its parent widget      If the widget is a window, the position is that of the widget on     the desktop, including its frame.      When changing the position, the widget, if visible, receives a     move event (moveEvent()) immediately. If the widget is not     currently visible, it is guaranteed to receive an event before it     is shown.      By default, this property contains a position that refers to the     origin.      \warning Calling move() or setGeometry() inside moveEvent() can     lead to infinite recursion.      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      \sa frameGeometry, size, x(), y() */
DECL|function|pos
name|QPoint
name|QWidget
operator|::
name|pos
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QPoint
name|result
init|=
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
if|if
condition|(
operator|!
name|d
operator|->
name|maybeTopData
argument_list|()
operator|||
operator|!
name|d
operator|->
name|maybeTopData
argument_list|()
operator|->
name|posIncludesFrame
condition|)
name|result
operator|-=
name|d
operator|->
name|frameStrut
argument_list|()
operator|.
name|topLeft
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*!     \property QWidget::geometry     \brief the geometry of the widget relative to its parent and     excluding the window frame      When changing the geometry, the widget, if visible, receives a     move event (moveEvent()) and/or a resize event (resizeEvent())     immediately. If the widget is not currently visible, it is     guaranteed to receive appropriate events before it is shown.      The size component is adjusted if it lies outside the range     defined by minimumSize() and maximumSize().      \warning Calling setGeometry() inside resizeEvent() or moveEvent()     can lead to infinite recursion.      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      By default, this property contains a value that depends on the user's     platform and screen geometry.      \sa frameGeometry(), rect(), move(), resize(), moveEvent(),         resizeEvent(), minimumSize(), maximumSize() */
comment|/*!     \property QWidget::normalGeometry      \brief the geometry of the widget as it will appear when shown as     a normal (not maximized or full screen) top-level widget      For child widgets this property always holds an empty rectangle.      By default, this property contains an empty rectangle.      \sa QWidget::windowState(), QWidget::geometry */
comment|/*!     \property QWidget::size     \brief the size of the widget excluding any window frame      If the widget is visible when it is being resized, it receives a resize event     (resizeEvent()) immediately. If the widget is not currently     visible, it is guaranteed to receive an event before it is shown.      The size is adjusted if it lies outside the range defined by     minimumSize() and maximumSize().      By default, this property contains a value that depends on the user's     platform and screen geometry.      \warning Calling resize() or setGeometry() inside resizeEvent() can     lead to infinite recursion.      \note Setting the size to \c{QSize(0, 0)} will cause the widget to not     appear on screen. This also applies to windows.      \sa pos, geometry, minimumSize, maximumSize, resizeEvent(), adjustSize() */
comment|/*!     \property QWidget::width     \brief the width of the widget excluding any window frame      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      \note Do not use this function to find the width of a screen on     a \l{QDesktopWidget}{multiple screen desktop}. Read     \l{QDesktopWidget#Screen Geometry}{this note} for details.      By default, this property contains a value that depends on the user's     platform and screen geometry.      \sa geometry, height, size */
comment|/*!     \property QWidget::height     \brief the height of the widget excluding any window frame      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      \note Do not use this function to find the height of a screen     on a \l{QDesktopWidget}{multiple screen desktop}. Read     \l{QDesktopWidget#Screen Geometry}{this note} for details.      By default, this property contains a value that depends on the user's     platform and screen geometry.      \sa geometry, width, size */
comment|/*!     \property QWidget::rect     \brief the internal geometry of the widget excluding any window     frame      The rect property equals QRect(0, 0, width(), height()).      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      By default, this property contains a value that depends on the user's     platform and screen geometry.      \sa size */
DECL|function|normalGeometry
name|QRect
name|QWidget
operator|::
name|normalGeometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
operator|||
operator|!
name|d
operator|->
name|extra
operator|->
name|topextra
condition|)
return|return
name|QRect
argument_list|()
return|;
if|if
condition|(
operator|!
name|isMaximized
argument_list|()
operator|&&
operator|!
name|isFullScreen
argument_list|()
condition|)
return|return
name|geometry
argument_list|()
return|;
return|return
name|d
operator|->
name|topData
argument_list|()
operator|->
name|normalGeometry
return|;
block|}
comment|/*!     \property QWidget::childrenRect     \brief the bounding rectangle of the widget's children      Hidden children are excluded.      By default, for a widget with no children, this property contains a     rectangle with zero width and height located at the origin.      \sa childrenRegion(), geometry() */
DECL|function|childrenRect
name|QRect
name|QWidget
operator|::
name|childrenRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QRect
name|r
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isHidden
argument_list|()
condition|)
name|r
operator||=
name|w
operator|->
name|geometry
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/*!     \property QWidget::childrenRegion     \brief the combined region occupied by the widget's children      Hidden children are excluded.      By default, for a widget with no children, this property contains an     empty region.      \sa childrenRect(), geometry(), mask() */
DECL|function|childrenRegion
name|QRegion
name|QWidget
operator|::
name|childrenRegion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QRegion
name|r
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|QRegion
name|mask
init|=
name|w
operator|->
name|mask
argument_list|()
decl_stmt|;
if|if
condition|(
name|mask
operator|.
name|isEmpty
argument_list|()
condition|)
name|r
operator||=
name|w
operator|->
name|geometry
argument_list|()
expr_stmt|;
else|else
name|r
operator||=
name|mask
operator|.
name|translated
argument_list|(
name|w
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/*!     \property QWidget::minimumSize     \brief the widget's minimum size      The widget cannot be resized to a smaller size than the minimum     widget size. The widget's size is forced to the minimum size if     the current size is smaller.      The minimum size set by this function will override the minimum size     defined by QLayout. In order to unset the minimum size, use a     value of \c{QSize(0, 0)}.      By default, this property contains a size with zero width and height.      \sa minimumWidth, minimumHeight, maximumSize, sizeIncrement */
DECL|function|minimumSize
name|QSize
name|QWidget
operator|::
name|minimumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extra
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|extra
operator|->
name|minw
argument_list|,
name|d
operator|->
name|extra
operator|->
name|minh
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::maximumSize     \brief the widget's maximum size in pixels      The widget cannot be resized to a larger size than the maximum     widget size.      By default, this property contains a size in which both width and height     have values of 16777215.      \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size     of widgets.      \sa maximumWidth, maximumHeight, minimumSize, sizeIncrement */
DECL|function|maximumSize
name|QSize
name|QWidget
operator|::
name|maximumSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extra
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|extra
operator|->
name|maxw
argument_list|,
name|d
operator|->
name|extra
operator|->
name|maxh
argument_list|)
else|:
name|QSize
argument_list|(
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::minimumWidth     \brief the widget's minimum width in pixels      This property corresponds to the width held by the \l minimumSize property.      By default, this property has a value of 0.      \sa minimumSize, minimumHeight */
comment|/*!     \property QWidget::minimumHeight     \brief the widget's minimum height in pixels      This property corresponds to the height held by the \l minimumSize property.      By default, this property has a value of 0.      \sa minimumSize, minimumWidth */
comment|/*!     \property QWidget::maximumWidth     \brief the widget's maximum width in pixels      This property corresponds to the width held by the \l maximumSize property.      By default, this property contains a value of 16777215.      \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size     of widgets.      \sa maximumSize, maximumHeight */
comment|/*!     \property QWidget::maximumHeight     \brief the widget's maximum height in pixels      This property corresponds to the height held by the \l maximumSize property.      By default, this property contains a value of 16777215.      \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size     of widgets.      \sa maximumSize, maximumWidth */
comment|/*!     \property QWidget::sizeIncrement     \brief the size increment of the widget      When the user resizes the window, the size will move in steps of     sizeIncrement().width() pixels horizontally and     sizeIncrement.height() pixels vertically, with baseSize() as the     basis. Preferred widget sizes are for non-negative integers \e i     and \e j:     \snippet code/src_gui_kernel_qwidget.cpp 2      Note that while you can set the size increment for all widgets, it     only affects windows.      By default, this property contains a size with zero width and height.      \warning The size increment has no effect under Windows, and may     be disregarded by the window manager on X11.      \sa size, minimumSize, maximumSize */
DECL|function|sizeIncrement
name|QSize
name|QWidget
operator|::
name|sizeIncrement
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|)
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|incw
argument_list|,
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|inch
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::baseSize     \brief the base size of the widget      The base size is used to calculate a proper widget size if the     widget defines sizeIncrement().      By default, for a newly-created widget, this property contains a size with     zero width and height.      \sa setSizeIncrement() */
DECL|function|baseSize
name|QSize
name|QWidget
operator|::
name|baseSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|extra
operator|!=
literal|0
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|!=
literal|0
operator|)
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|basew
argument_list|,
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|baseh
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setMinimumSize_helper
name|bool
name|QWidgetPrivate
operator|::
name|setMinimumSize_helper
parameter_list|(
name|int
modifier|&
name|minw
parameter_list|,
name|int
modifier|&
name|minh
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|int
name|mw
init|=
name|minw
decl_stmt|,
name|mh
init|=
name|minh
decl_stmt|;
if|if
condition|(
name|mw
operator|==
name|QWIDGETSIZE_MAX
condition|)
name|mw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|QWIDGETSIZE_MAX
condition|)
name|mh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minw
operator|>
name|QWIDGETSIZE_MAX
operator|||
name|minh
operator|>
name|QWIDGETSIZE_MAX
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setMinimumSize: (%s/%s) "
literal|"The largest allowed size is (%d,%d)"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
name|minw
operator|=
name|mw
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|minw
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
name|minh
operator|=
name|mh
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|minh
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minw
operator|<
literal|0
operator|||
name|minh
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setMinimumSize: (%s/%s) Negative sizes (%d,%d) "
literal|"are not possible"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|minw
argument_list|,
name|minh
argument_list|)
expr_stmt|;
name|minw
operator|=
name|mw
operator|=
name|qMax
argument_list|(
name|minw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minh
operator|=
name|mh
operator|=
name|qMax
argument_list|(
name|minh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|createExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|extra
operator|->
name|minw
operator|==
name|mw
operator|&&
name|extra
operator|->
name|minh
operator|==
name|mh
condition|)
return|return
literal|false
return|;
name|extra
operator|->
name|minw
operator|=
name|mw
expr_stmt|;
name|extra
operator|->
name|minh
operator|=
name|mh
expr_stmt|;
name|extra
operator|->
name|explicitMinSize
operator|=
operator|(
name|mw
condition|?
name|Qt
operator|::
name|Horizontal
else|:
literal|0
operator|)
operator||
operator|(
name|mh
condition|?
name|Qt
operator|::
name|Vertical
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*!     \overload      This function corresponds to setMinimumSize(QSize(minw, minh)).     Sets the minimum width to \a minw and the minimum height to \a     minh. */
DECL|function|setMinimumSize
name|void
name|QWidget
operator|::
name|setMinimumSize
parameter_list|(
name|int
name|minw
parameter_list|,
name|int
name|minh
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|setMinimumSize_helper
argument_list|(
name|minw
argument_list|,
name|minh
argument_list|)
condition|)
return|return;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|setConstraints_sys
argument_list|()
expr_stmt|;
if|if
condition|(
name|minw
operator|>
name|width
argument_list|()
operator|||
name|minh
operator|>
name|height
argument_list|()
condition|)
block|{
name|bool
name|resized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|bool
name|maximized
init|=
name|isMaximized
argument_list|()
decl_stmt|;
name|resize
argument_list|(
name|qMax
argument_list|(
name|minw
argument_list|,
name|width
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|minh
argument_list|,
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|resized
argument_list|)
expr_stmt|;
comment|//not a user resize
if|if
condition|(
name|maximized
condition|)
name|data
operator|->
name|window_state
operator|=
name|data
operator|->
name|window_state
operator||
name|Qt
operator|::
name|WindowMaximized
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|d
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|extra
operator|->
name|proxyWidget
condition|)
name|d
operator|->
name|extra
operator|->
name|proxyWidget
operator|->
name|setMinimumSize
argument_list|(
name|minw
argument_list|,
name|minh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|updateGeometry_helper
argument_list|(
name|d
operator|->
name|extra
operator|->
name|minw
operator|==
name|d
operator|->
name|extra
operator|->
name|maxw
operator|&&
name|d
operator|->
name|extra
operator|->
name|minh
operator|==
name|d
operator|->
name|extra
operator|->
name|maxh
argument_list|)
expr_stmt|;
block|}
DECL|function|setMaximumSize_helper
name|bool
name|QWidgetPrivate
operator|::
name|setMaximumSize_helper
parameter_list|(
name|int
modifier|&
name|maxw
parameter_list|,
name|int
modifier|&
name|maxh
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxw
operator|>
name|QWIDGETSIZE_MAX
operator|||
name|maxh
operator|>
name|QWIDGETSIZE_MAX
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setMaximumSize: (%s/%s) "
literal|"The largest allowed size is (%d,%d)"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
name|maxw
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxw
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
name|maxh
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxh
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxw
operator|<
literal|0
operator|||
name|maxh
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setMaximumSize: (%s/%s) Negative sizes (%d,%d) "
literal|"are not possible"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|maxw
argument_list|,
name|maxh
argument_list|)
expr_stmt|;
name|maxw
operator|=
name|qMax
argument_list|(
name|maxw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxh
operator|=
name|qMax
argument_list|(
name|maxh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|createExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|extra
operator|->
name|maxw
operator|==
name|maxw
operator|&&
name|extra
operator|->
name|maxh
operator|==
name|maxh
condition|)
return|return
literal|false
return|;
name|extra
operator|->
name|maxw
operator|=
name|maxw
expr_stmt|;
name|extra
operator|->
name|maxh
operator|=
name|maxh
expr_stmt|;
name|extra
operator|->
name|explicitMaxSize
operator|=
operator|(
name|maxw
operator|!=
name|QWIDGETSIZE_MAX
condition|?
name|Qt
operator|::
name|Horizontal
else|:
literal|0
operator|)
operator||
operator|(
name|maxh
operator|!=
name|QWIDGETSIZE_MAX
condition|?
name|Qt
operator|::
name|Vertical
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*!     \overload      This function corresponds to setMaximumSize(QSize(\a maxw, \a     maxh)). Sets the maximum width to \a maxw and the maximum height     to \a maxh. */
DECL|function|setMaximumSize
name|void
name|QWidget
operator|::
name|setMaximumSize
parameter_list|(
name|int
name|maxw
parameter_list|,
name|int
name|maxh
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|setMaximumSize_helper
argument_list|(
name|maxw
argument_list|,
name|maxh
argument_list|)
condition|)
return|return;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|setConstraints_sys
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxw
operator|<
name|width
argument_list|()
operator|||
name|maxh
operator|<
name|height
argument_list|()
condition|)
block|{
name|bool
name|resized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|resize
argument_list|(
name|qMin
argument_list|(
name|maxw
argument_list|,
name|width
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|maxh
argument_list|,
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|resized
argument_list|)
expr_stmt|;
comment|//not a user resize
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|d
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|extra
operator|->
name|proxyWidget
condition|)
name|d
operator|->
name|extra
operator|->
name|proxyWidget
operator|->
name|setMaximumSize
argument_list|(
name|maxw
argument_list|,
name|maxh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|updateGeometry_helper
argument_list|(
name|d
operator|->
name|extra
operator|->
name|minw
operator|==
name|d
operator|->
name|extra
operator|->
name|maxw
operator|&&
name|d
operator|->
name|extra
operator|->
name|minh
operator|==
name|d
operator|->
name|extra
operator|->
name|maxh
argument_list|)
expr_stmt|;
block|}
comment|/*!     \overload      Sets the x (width) size increment to \a w and the y (height) size     increment to \a h. */
DECL|function|setSizeIncrement
name|void
name|QWidget
operator|::
name|setSizeIncrement
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createTLExtra
argument_list|()
expr_stmt|;
name|QTLWExtra
modifier|*
name|x
init|=
name|d
operator|->
name|topData
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|incw
operator|==
name|w
operator|&&
name|x
operator|->
name|inch
operator|==
name|h
condition|)
return|return;
name|x
operator|->
name|incw
operator|=
name|w
expr_stmt|;
name|x
operator|->
name|inch
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|setConstraints_sys
argument_list|()
expr_stmt|;
block|}
comment|/*!     \overload      This corresponds to setBaseSize(QSize(\a basew, \a baseh)). Sets     the widgets base size to width \a basew and height \a baseh. */
DECL|function|setBaseSize
name|void
name|QWidget
operator|::
name|setBaseSize
parameter_list|(
name|int
name|basew
parameter_list|,
name|int
name|baseh
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createTLExtra
argument_list|()
expr_stmt|;
name|QTLWExtra
modifier|*
name|x
init|=
name|d
operator|->
name|topData
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|basew
operator|==
name|basew
operator|&&
name|x
operator|->
name|baseh
operator|==
name|baseh
condition|)
return|return;
name|x
operator|->
name|basew
operator|=
name|basew
expr_stmt|;
name|x
operator|->
name|baseh
operator|=
name|baseh
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|setConstraints_sys
argument_list|()
expr_stmt|;
block|}
comment|/*!     Sets both the minimum and maximum sizes of the widget to \a s,     thereby preventing it from ever growing or shrinking.      This will override the default size constraints set by QLayout.      To remove constraints, set the size to QWIDGETSIZE_MAX.      Alternatively, if you want the widget to have a     fixed size based on its contents, you can call     QLayout::setSizeConstraint(QLayout::SetFixedSize);      \sa maximumSize, minimumSize */
DECL|function|setFixedSize
name|void
name|QWidget
operator|::
name|setFixedSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
block|{
name|setFixedSize
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::setFixedSize(int w, int h)     \overload      Sets the width of the widget to \a w and the height to \a h. */
DECL|function|setFixedSize
name|void
name|QWidget
operator|::
name|setFixedSize
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|bool
name|minSizeSet
init|=
name|d
operator|->
name|setMinimumSize_helper
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|bool
name|maxSizeSet
init|=
name|d
operator|->
name|setMaximumSize_helper
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|minSizeSet
operator|&&
operator|!
name|maxSizeSet
condition|)
return|return;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|setConstraints_sys
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|updateGeometry_helper
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|QWIDGETSIZE_MAX
operator|||
name|h
operator|!=
name|QWIDGETSIZE_MAX
condition|)
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
DECL|function|setMinimumWidth
name|void
name|QWidget
operator|::
name|setMinimumWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|expl
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator||
operator|(
name|w
condition|?
name|Qt
operator|::
name|Horizontal
else|:
literal|0
operator|)
decl_stmt|;
name|setMinimumSize
argument_list|(
name|w
argument_list|,
name|minimumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator|=
name|expl
expr_stmt|;
block|}
DECL|function|setMinimumHeight
name|void
name|QWidget
operator|::
name|setMinimumHeight
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|expl
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator||
operator|(
name|h
condition|?
name|Qt
operator|::
name|Vertical
else|:
literal|0
operator|)
decl_stmt|;
name|setMinimumSize
argument_list|(
name|minimumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator|=
name|expl
expr_stmt|;
block|}
DECL|function|setMaximumWidth
name|void
name|QWidget
operator|::
name|setMaximumWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|expl
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator||
operator|(
name|w
operator|==
name|QWIDGETSIZE_MAX
condition|?
literal|0
else|:
name|Qt
operator|::
name|Horizontal
operator|)
decl_stmt|;
name|setMaximumSize
argument_list|(
name|w
argument_list|,
name|maximumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator|=
name|expl
expr_stmt|;
block|}
DECL|function|setMaximumHeight
name|void
name|QWidget
operator|::
name|setMaximumHeight
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|expl
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator||
operator|(
name|h
operator|==
name|QWIDGETSIZE_MAX
condition|?
literal|0
else|:
name|Qt
operator|::
name|Vertical
operator|)
decl_stmt|;
name|setMaximumSize
argument_list|(
name|maximumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator|=
name|expl
expr_stmt|;
block|}
comment|/*!     Sets both the minimum and maximum width of the widget to \a w     without changing the heights. Provided for convenience.      \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize() */
DECL|function|setFixedWidth
name|void
name|QWidget
operator|::
name|setFixedWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|explMin
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator||
name|Qt
operator|::
name|Horizontal
decl_stmt|;
name|uint
name|explMax
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator||
name|Qt
operator|::
name|Horizontal
decl_stmt|;
name|setMinimumSize
argument_list|(
name|w
argument_list|,
name|minimumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|setMaximumSize
argument_list|(
name|w
argument_list|,
name|maximumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator|=
name|explMin
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator|=
name|explMax
expr_stmt|;
block|}
comment|/*!     Sets both the minimum and maximum heights of the widget to \a h     without changing the widths. Provided for convenience.      \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize() */
DECL|function|setFixedHeight
name|void
name|QWidget
operator|::
name|setFixedHeight
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|uint
name|explMin
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator||
name|Qt
operator|::
name|Vertical
decl_stmt|;
name|uint
name|explMax
init|=
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator||
name|Qt
operator|::
name|Vertical
decl_stmt|;
name|setMinimumSize
argument_list|(
name|minimumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|setMaximumSize
argument_list|(
name|maximumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMinSize
operator|=
name|explMin
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|explicitMaxSize
operator|=
name|explMax
expr_stmt|;
block|}
comment|/*!     Translates the widget coordinate \a pos to the coordinate system     of \a parent. The \a parent must not be 0 and must be a parent     of the calling widget.      \sa mapFrom(), mapToParent(), mapToGlobal(), underMouse() */
DECL|function|mapTo
name|QPoint
name|QWidget
operator|::
name|mapTo
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|QPoint
name|p
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
operator|!=
name|parent
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|w
argument_list|,
literal|"QWidget::mapTo(const QWidget *parent, const QPoint&pos)"
argument_list|,
literal|"parent must be in parent hierarchy"
argument_list|)
expr_stmt|;
name|p
operator|=
name|w
operator|->
name|mapToParent
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
comment|/*!     Translates the widget coordinate \a pos from the coordinate system     of \a parent to this widget's coordinate system. The \a parent     must not be 0 and must be a parent of the calling widget.      \sa mapTo(), mapFromParent(), mapFromGlobal(), underMouse() */
DECL|function|mapFrom
name|QPoint
name|QWidget
operator|::
name|mapFrom
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|QPoint
name|p
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
operator|!=
name|parent
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|w
argument_list|,
literal|"QWidget::mapFrom(const QWidget *parent, const QPoint&pos)"
argument_list|,
literal|"parent must be in parent hierarchy"
argument_list|)
expr_stmt|;
name|p
operator|=
name|w
operator|->
name|mapFromParent
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
comment|/*!     Translates the widget coordinate \a pos to a coordinate in the     parent widget.      Same as mapToGlobal() if the widget has no parent.      \sa mapFromParent(), mapTo(), mapToGlobal(), underMouse() */
DECL|function|mapToParent
name|QPoint
name|QWidget
operator|::
name|mapToParent
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
return|return
name|pos
operator|+
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
return|;
block|}
comment|/*!     Translates the parent widget coordinate \a pos to widget     coordinates.      Same as mapFromGlobal() if the widget has no parent.      \sa mapToParent(), mapFrom(), mapFromGlobal(), underMouse() */
DECL|function|mapFromParent
name|QPoint
name|QWidget
operator|::
name|mapFromParent
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
return|return
name|pos
operator|-
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
return|;
block|}
comment|/*!     Returns the window for this widget, i.e. the next ancestor widget     that has (or could have) a window-system frame.      If the widget is a window, the widget itself is returned.      Typical usage is changing the window title:      \snippet code/src_gui_kernel_qwidget.cpp 3      \sa isWindow() */
DECL|function|window
name|QWidget
modifier|*
name|QWidget
operator|::
name|window
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
operator|(
name|QWidget
operator|*
operator|)
name|this
decl_stmt|;
name|QWidget
modifier|*
name|p
init|=
name|w
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|p
condition|)
block|{
name|w
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
comment|/*!     \since 4.4      Returns the native parent for this widget, i.e. the next ancestor widget     that has a system identifier, or 0 if it does not have any native parent.      \sa effectiveWinId() */
DECL|function|nativeParentWidget
name|QWidget
modifier|*
name|QWidget
operator|::
name|nativeParentWidget
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|parent
init|=
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|internalWinId
argument_list|()
condition|)
name|parent
operator|=
name|parent
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
return|return
name|parent
return|;
block|}
comment|/*! \fn QWidget *QWidget::topLevelWidget() const     \obsolete      Use window() instead. */
comment|/*!   Returns the background role of the widget.    The background role defines the brush from the widget's \l palette that   is used to render the background.    If no explicit background role is set, the widget inherts its parent   widget's background role.    \sa setBackgroundRole(), foregroundRole()  */
DECL|function|backgroundRole
name|QPalette
operator|::
name|ColorRole
name|QWidget
operator|::
name|backgroundRole
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
do|do
block|{
name|QPalette
operator|::
name|ColorRole
name|role
init|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|bg_role
decl_stmt|;
if|if
condition|(
name|role
operator|!=
name|QPalette
operator|::
name|NoRole
condition|)
return|return
name|role
return|;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|SubWindow
condition|)
break|break;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|w
condition|)
do|;
return|return
name|QPalette
operator|::
name|Window
return|;
block|}
comment|/*!   Sets the background role of the widget to \a role.    The background role defines the brush from the widget's \l palette that   is used to render the background.    If \a role is QPalette::NoRole, then the widget inherits its   parent's background role.    Note that styles are free to choose any color from the palette.   You can modify the palette or set a style sheet if you don't   achieve the result you want with setBackgroundRole().    \sa backgroundRole(), foregroundRole()  */
DECL|function|setBackgroundRole
name|void
name|QWidget
operator|::
name|setBackgroundRole
parameter_list|(
name|QPalette
operator|::
name|ColorRole
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|bg_role
operator|=
name|role
expr_stmt|;
name|d
operator|->
name|updateSystemBackground
argument_list|()
expr_stmt|;
name|d
operator|->
name|propagatePaletteChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
block|}
comment|/*!   Returns the foreground role.    The foreground role defines the color from the widget's \l palette that   is used to draw the foreground.    If no explicit foreground role is set, the function returns a role   that contrasts with the background role.    \sa setForegroundRole(), backgroundRole()  */
DECL|function|foregroundRole
name|QPalette
operator|::
name|ColorRole
name|QWidget
operator|::
name|foregroundRole
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QPalette
operator|::
name|ColorRole
name|rl
init|=
name|QPalette
operator|::
name|ColorRole
argument_list|(
name|d
operator|->
name|fg_role
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
name|QPalette
operator|::
name|NoRole
condition|)
return|return
name|rl
return|;
name|QPalette
operator|::
name|ColorRole
name|role
init|=
name|QPalette
operator|::
name|WindowText
decl_stmt|;
switch|switch
condition|(
name|backgroundRole
argument_list|()
condition|)
block|{
case|case
name|QPalette
operator|::
name|Button
case|:
name|role
operator|=
name|QPalette
operator|::
name|ButtonText
expr_stmt|;
break|break;
case|case
name|QPalette
operator|::
name|Base
case|:
name|role
operator|=
name|QPalette
operator|::
name|Text
expr_stmt|;
break|break;
case|case
name|QPalette
operator|::
name|Dark
case|:
case|case
name|QPalette
operator|::
name|Shadow
case|:
name|role
operator|=
name|QPalette
operator|::
name|Light
expr_stmt|;
break|break;
case|case
name|QPalette
operator|::
name|Highlight
case|:
name|role
operator|=
name|QPalette
operator|::
name|HighlightedText
expr_stmt|;
break|break;
case|case
name|QPalette
operator|::
name|ToolTipBase
case|:
name|role
operator|=
name|QPalette
operator|::
name|ToolTipText
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|role
return|;
block|}
comment|/*!   Sets the foreground role of the widget to \a role.    The foreground role defines the color from the widget's \l palette that   is used to draw the foreground.    If \a role is QPalette::NoRole, the widget uses a foreground role   that contrasts with the background role.    Note that styles are free to choose any color from the palette.   You can modify the palette or set a style sheet if you don't   achieve the result you want with setForegroundRole().    \sa foregroundRole(), backgroundRole()  */
DECL|function|setForegroundRole
name|void
name|QWidget
operator|::
name|setForegroundRole
parameter_list|(
name|QPalette
operator|::
name|ColorRole
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|fg_role
operator|=
name|role
expr_stmt|;
name|d
operator|->
name|updateSystemBackground
argument_list|()
expr_stmt|;
name|d
operator|->
name|propagatePaletteChange
argument_list|()
expr_stmt|;
block|}
comment|/*!     \property QWidget::palette     \brief the widget's palette      This property describes the widget's palette. The palette is used by the     widget's style when rendering standard components, and is available as a     means to ensure that custom widgets can maintain consistency with the     native platform's look and feel. It's common that different platforms, or     different styles, have different palettes.      When you assign a new palette to a widget, the color roles from this     palette are combined with the widget's default palette to form the     widget's final palette. The palette entry for the widget's background role     is used to fill the widget's background (see QWidget::autoFillBackground),     and the foreground role initializes QPainter's pen.      The default depends on the system environment. QApplication maintains a     system/theme palette which serves as a default for all widgets.  There may     also be special palette defaults for certain types of widgets (e.g., on     Windows XP and Vista, all classes that derive from QMenuBar have a special     default palette). You can also define default palettes for widgets     yourself by passing a custom palette and the name of a widget to     QApplication::setPalette(). Finally, the style always has the option of     polishing the palette as it's assigned (see QStyle::polish()).      QWidget propagates explicit palette roles from parent to child. If you     assign a brush or color to a specific role on a palette and assign that     palette to a widget, that role will propagate to all the widget's     children, overriding any system defaults for that role. Note that palettes     by default don't propagate to windows (see isWindow()) unless the     Qt::WA_WindowPropagation attribute is enabled.      QWidget's palette propagation is similar to its font propagation.      The current style, which is used to render the content of all standard Qt     widgets, is free to choose colors and brushes from the widget palette, or     in some cases, to ignore the palette (partially, or completely). In     particular, certain styles like GTK style, Mac style, Windows XP, and     Vista style, depend on third party APIs to render the content of widgets,     and these styles typically do not follow the palette. Because of this,     assigning roles to a widget's palette is not guaranteed to change the     appearance of the widget. Instead, you may choose to apply a \l     styleSheet. You can refer to our Knowledge Base article     \l{http://qt.nokia.com/developer/knowledgebase/22}{here} for more     information.      \warning Do not use this function in conjunction with \l{Qt Style Sheets}.     When using style sheets, the palette of a widget can be customized using     the "color", "background-color", "selection-color",     "selection-background-color" and "alternate-background-color".      \sa QApplication::palette(), QWidget::font() */
DECL|function|palette
specifier|const
name|QPalette
modifier|&
name|QWidget
operator|::
name|palette
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
block|{
name|data
operator|->
name|pal
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Disabled
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|isVisible
argument_list|()
operator|||
name|isActiveWindow
argument_list|()
operator|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|QApplicationPrivate
operator|::
name|isBlockedByModal
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|data
operator|->
name|pal
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Active
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
specifier|extern
name|bool
name|qt_mac_can_clickThrough
argument_list|(
specifier|const
name|QWidget
operator|*
argument_list|)
decl_stmt|;
comment|//qwidget_mac.cpp
if|if
condition|(
name|qt_mac_can_clickThrough
argument_list|(
name|this
argument_list|)
condition|)
name|data
operator|->
name|pal
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Active
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|data
operator|->
name|pal
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Inactive
argument_list|)
expr_stmt|;
block|}
return|return
name|data
operator|->
name|pal
return|;
block|}
DECL|function|setPalette
name|void
name|QWidget
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetPalette
argument_list|,
name|palette
operator|.
name|resolve
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// Determine which palette is inherited from this widget's ancestors and
comment|// QApplication::palette, resolve this against \a palette (attributes from
comment|// the inherited palette are copied over this widget's palette). Then
comment|// propagate this palette to this widget's children.
name|QPalette
name|naturalPalette
init|=
name|d
operator|->
name|naturalWidgetPalette
argument_list|(
name|d
operator|->
name|inheritedPaletteResolveMask
argument_list|)
decl_stmt|;
name|QPalette
name|resolvedPalette
init|=
name|palette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
decl_stmt|;
name|d
operator|->
name|setPalette_helper
argument_list|(
name|resolvedPalette
argument_list|)
expr_stmt|;
block|}
comment|/*!     \internal      Returns the palette that the widget \a w inherits from its ancestors and     QApplication::palette. \a inheritedMask is the combination of the widget's     ancestors palette request masks (i.e., which attributes from the parent     widget's palette are implicitly imposed on this widget by the user). Note     that this font does not take into account the palette set on \a w itself. */
DECL|function|naturalWidgetPalette
name|QPalette
name|QWidgetPrivate
operator|::
name|naturalWidgetPalette
parameter_list|(
name|uint
name|inheritedMask
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QPalette
name|naturalPalette
init|=
name|QApplication
operator|::
name|palette
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
operator|&&
operator|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|||
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
operator|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
operator|)
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
operator|)
condition|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|p
init|=
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|naturalPalette
operator|.
name|isCopyOf
argument_list|(
name|QApplication
operator|::
name|palette
argument_list|()
argument_list|)
condition|)
block|{
name|QPalette
name|inheritedPalette
init|=
name|p
operator|->
name|palette
argument_list|()
decl_stmt|;
name|inheritedPalette
operator|.
name|resolve
argument_list|(
name|inheritedMask
argument_list|)
expr_stmt|;
name|naturalPalette
operator|=
name|inheritedPalette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|naturalPalette
operator|=
name|p
operator|->
name|palette
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
elseif|else
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|QPalette
name|inheritedPalette
init|=
name|extra
operator|->
name|proxyWidget
operator|->
name|palette
argument_list|()
decl_stmt|;
name|inheritedPalette
operator|.
name|resolve
argument_list|(
name|inheritedMask
argument_list|)
expr_stmt|;
name|naturalPalette
operator|=
name|inheritedPalette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
name|naturalPalette
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|naturalPalette
return|;
block|}
comment|/*!     \internal      Determine which palette is inherited from this widget's ancestors and     QApplication::palette, resolve this against this widget's palette     (attributes from the inherited palette are copied over this widget's     palette). Then propagate this palette to this widget's children. */
DECL|function|resolvePalette
name|void
name|QWidgetPrivate
operator|::
name|resolvePalette
parameter_list|()
block|{
name|QPalette
name|naturalPalette
init|=
name|naturalWidgetPalette
argument_list|(
name|inheritedPaletteResolveMask
argument_list|)
decl_stmt|;
name|QPalette
name|resolvedPalette
init|=
name|data
operator|.
name|pal
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
decl_stmt|;
name|setPalette_helper
argument_list|(
name|resolvedPalette
argument_list|)
expr_stmt|;
block|}
DECL|function|setPalette_helper
name|void
name|QWidgetPrivate
operator|::
name|setPalette_helper
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|pal
operator|==
name|palette
operator|&&
name|data
operator|.
name|pal
operator|.
name|resolve
argument_list|()
operator|==
name|palette
operator|.
name|resolve
argument_list|()
condition|)
return|return;
name|data
operator|.
name|pal
operator|=
name|palette
expr_stmt|;
name|updateSystemBackground
argument_list|()
expr_stmt|;
name|propagatePaletteChange
argument_list|()
expr_stmt|;
name|updateIsOpaque
argument_list|()
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
name|updateIsOpaque
argument_list|()
expr_stmt|;
block|}
comment|/*!     \property QWidget::font     \brief the font currently set for the widget      This property describes the widget's requested font. The font is used by     the widget's style when rendering standard components, and is available as     a means to ensure that custom widgets can maintain consistency with the     native platform's look and feel. It's common that different platforms, or     different styles, define different fonts for an application.      When you assign a new font to a widget, the properties from this font are     combined with the widget's default font to form the widget's final     font. You can call fontInfo() to get a copy of the widget's final     font. The final font is also used to initialize QPainter's font.      The default depends on the system environment. QApplication maintains a     system/theme font which serves as a default for all widgets.  There may     also be special font defaults for certain types of widgets. You can also     define default fonts for widgets yourself by passing a custom font and the     name of a widget to QApplication::setFont(). Finally, the font is matched     against Qt's font database to find the best match.      QWidget propagates explicit font properties from parent to child. If you     change a specific property on a font and assign that font to a widget,     that property will propagate to all the widget's children, overriding any     system defaults for that property. Note that fonts by default don't     propagate to windows (see isWindow()) unless the Qt::WA_WindowPropagation     attribute is enabled.      QWidget's font propagation is similar to its palette propagation.      The current style, which is used to render the content of all standard Qt     widgets, is free to choose to use the widget font, or in some cases, to     ignore it (partially, or completely). In particular, certain styles like     GTK style, Mac style, Windows XP, and Vista style, apply special     modifications to the widget font to match the platform's native look and     feel. Because of this, assigning properties to a widget's font is not     guaranteed to change the appearance of the widget. Instead, you may choose     to apply a \l styleSheet.      \note If \l{Qt Style Sheets} are used on the same widget as setFont(),     style sheets will take precedence if the settings conflict.      \sa fontInfo(), fontMetrics() */
DECL|function|setFont
name|void
name|QWidget
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
specifier|const
name|QStyleSheetStyle
modifier|*
name|style
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
operator|(
name|style
operator|=
name|qobject_cast
argument_list|<
specifier|const
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|extra
operator|->
name|style
argument_list|)
operator|)
condition|)
block|{
name|style
operator|->
name|saveWidgetFont
argument_list|(
name|this
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetFont
argument_list|,
name|font
operator|.
name|resolve
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// Determine which font is inherited from this widget's ancestors and
comment|// QApplication::font, resolve this against \a font (attributes from the
comment|// inherited font are copied over). Then propagate this font to this
comment|// widget's children.
name|QFont
name|naturalFont
init|=
name|d
operator|->
name|naturalWidgetFont
argument_list|(
name|d
operator|->
name|inheritedFontResolveMask
argument_list|)
decl_stmt|;
name|QFont
name|resolvedFont
init|=
name|font
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
decl_stmt|;
name|d
operator|->
name|setFont_helper
argument_list|(
name|resolvedFont
argument_list|)
expr_stmt|;
block|}
comment|/*     \internal      Returns the font that the widget \a w inherits from its ancestors and     QApplication::font. \a inheritedMask is the combination of the widget's     ancestors font request masks (i.e., which attributes from the parent     widget's font are implicitly imposed on this widget by the user). Note     that this font does not take into account the font set on \a w itself.      ### Stylesheet has a different font propagation mechanism. When a stylesheet         is applied, fonts are not propagated anymore */
DECL|function|naturalWidgetFont
name|QFont
name|QWidgetPrivate
operator|::
name|naturalWidgetFont
parameter_list|(
name|uint
name|inheritedMask
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QFont
name|naturalFont
init|=
name|QApplication
operator|::
name|font
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
operator|&&
operator|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|||
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|||
operator|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
operator|)
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
operator|)
condition|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|p
init|=
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|naturalFont
operator|.
name|isCopyOf
argument_list|(
name|QApplication
operator|::
name|font
argument_list|()
argument_list|)
condition|)
block|{
name|QFont
name|inheritedFont
init|=
name|p
operator|->
name|font
argument_list|()
decl_stmt|;
name|inheritedFont
operator|.
name|resolve
argument_list|(
name|inheritedMask
argument_list|)
expr_stmt|;
name|naturalFont
operator|=
name|inheritedFont
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|naturalFont
operator|=
name|p
operator|->
name|font
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
elseif|else
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|QFont
name|inheritedFont
init|=
name|extra
operator|->
name|proxyWidget
operator|->
name|font
argument_list|()
decl_stmt|;
name|inheritedFont
operator|.
name|resolve
argument_list|(
name|inheritedMask
argument_list|)
expr_stmt|;
name|naturalFont
operator|=
name|inheritedFont
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
block|}
name|naturalFont
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|naturalFont
return|;
block|}
comment|/*!     \internal      Determine which font is implicitly imposed on this widget by its ancestors     and QApplication::font, resolve this against its own font (attributes from     the implicit font are copied over). Then propagate this font to this     widget's children. */
DECL|function|resolveFont
name|void
name|QWidgetPrivate
operator|::
name|resolveFont
parameter_list|()
block|{
name|QFont
name|naturalFont
init|=
name|naturalWidgetFont
argument_list|(
name|inheritedFontResolveMask
argument_list|)
decl_stmt|;
name|QFont
name|resolvedFont
init|=
name|data
operator|.
name|fnt
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
decl_stmt|;
name|setFont_helper
argument_list|(
name|resolvedFont
argument_list|)
expr_stmt|;
block|}
comment|/*!     \internal      Assign \a font to this widget, and propagate it to all children, except     style sheet widgets (handled differently) and windows that don't enable     window propagation.  \a implicitMask is the union of all ancestor widgets'     font request masks, and determines which attributes from this widget's     font should propagate. */
DECL|function|updateFont
name|void
name|QWidgetPrivate
operator|::
name|updateFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
specifier|const
name|QStyleSheetStyle
modifier|*
name|cssStyle
decl_stmt|;
name|cssStyle
operator|=
name|extra
condition|?
name|qobject_cast
argument_list|<
specifier|const
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|extra
operator|->
name|style
argument_list|)
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
name|data
operator|.
name|fnt
operator|=
name|QFont
argument_list|(
name|font
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
comment|// make sure the font set on this widget is associated with the correct screen
name|data
operator|.
name|fnt
operator|.
name|x11SetScreen
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Combine new mask with natural mask and propagate to children.
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
block|{
name|QGraphicsProxyWidget
modifier|*
name|p
init|=
name|extra
operator|->
name|proxyWidget
decl_stmt|;
name|inheritedFontResolveMask
operator|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|inheritedFontResolveMask
operator||
name|p
operator|->
name|font
argument_list|()
operator|.
name|resolve
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
condition|)
block|{
name|inheritedFontResolveMask
operator|=
literal|0
expr_stmt|;
block|}
name|uint
name|newMask
init|=
name|data
operator|.
name|fnt
operator|.
name|resolve
argument_list|()
operator||
name|inheritedFontResolveMask
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
condition|)
block|{
comment|// Style sheets follow a different font propagation scheme.
if|if
condition|(
name|cssStyle
condition|)
name|cssStyle
operator|->
name|updateStyleSheetFont
argument_list|(
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
operator|)
condition|)
block|{
comment|// Propagate font changes.
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|wd
operator|->
name|inheritedFontResolveMask
operator|=
name|newMask
expr_stmt|;
name|wd
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|cssStyle
condition|)
block|{
name|cssStyle
operator|->
name|updateStyleSheetFont
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|FontChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
DECL|function|setLayoutDirection_helper
name|void
name|QWidgetPrivate
operator|::
name|setLayoutDirection_helper
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|direction
operator|==
name|Qt
operator|::
name|RightToLeft
operator|)
operator|==
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_RightToLeft
argument_list|)
condition|)
return|return;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_RightToLeft
argument_list|,
operator|(
name|direction
operator|==
name|Qt
operator|::
name|RightToLeft
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setLayoutDirection_helper
argument_list|(
name|direction
argument_list|)
expr_stmt|;
block|}
block|}
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|LayoutDirectionChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
DECL|function|resolveLayoutDirection
name|void
name|QWidgetPrivate
operator|::
name|resolveLayoutDirection
parameter_list|()
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|)
condition|)
name|setLayoutDirection_helper
argument_list|(
name|q
operator|->
name|isWindow
argument_list|()
condition|?
name|QApplication
operator|::
name|layoutDirection
argument_list|()
else|:
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|layoutDirection
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::layoutDirection      \brief the layout direction for this widget      By default, this property is set to Qt::LeftToRight.      When the layout direction is set on a widget, it will propagate to     the widget's children, but not to a child that is a window and not     to a child for which setLayoutDirection() has been explicitly     called. Also, child widgets added \e after setLayoutDirection()     has been called for the parent do not inherit the parent's layout     direction.      This method no longer affects text layout direction since Qt 4.7.      \sa QApplication::layoutDirection */
DECL|function|setLayoutDirection
name|void
name|QWidget
operator|::
name|setLayoutDirection
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|Qt
operator|::
name|LayoutDirectionAuto
condition|)
block|{
name|unsetLayoutDirection
argument_list|()
expr_stmt|;
return|return;
block|}
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLayoutDirection_helper
argument_list|(
name|direction
argument_list|)
expr_stmt|;
block|}
DECL|function|layoutDirection
name|Qt
operator|::
name|LayoutDirection
name|QWidget
operator|::
name|layoutDirection
parameter_list|()
specifier|const
block|{
return|return
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_RightToLeft
argument_list|)
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
return|;
block|}
DECL|function|unsetLayoutDirection
name|void
name|QWidget
operator|::
name|unsetLayoutDirection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|resolveLayoutDirection
argument_list|()
expr_stmt|;
block|}
comment|/*!     \fn QFontMetrics QWidget::fontMetrics() const      Returns the font metrics for the widget's current font.     Equivalent to QFontMetrics(widget->font()).      \sa font(), fontInfo(), setFont() */
comment|/*!     \fn QFontInfo QWidget::fontInfo() const      Returns the font info for the widget's current font.     Equivalent to QFontInto(widget->font()).      \sa font(), fontMetrics(), setFont() */
comment|/*!     \property QWidget::cursor     \brief the cursor shape for this widget      The mouse cursor will assume this shape when it's over this     widget. See the \l{Qt::CursorShape}{list of predefined cursor objects} for a range of useful shapes.      An editor widget might use an I-beam cursor:     \snippet code/src_gui_kernel_qwidget.cpp 6      If no cursor has been set, or after a call to unsetCursor(), the     parent's cursor is used.      By default, this property contains a cursor with the Qt::ArrowCursor     shape.      Some underlying window implementations will reset the cursor if it     leaves a widget even if the mouse is grabbed. If you want to have     a cursor set for all widgets, even when outside the window, consider     QApplication::setOverrideCursor().      \sa QApplication::setOverrideCursor() */
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
DECL|function|cursor
name|QCursor
name|QWidget
operator|::
name|cursor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
condition|)
return|return
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|curs
operator|)
condition|?
operator|*
name|d
operator|->
name|extra
operator|->
name|curs
else|:
name|QCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
return|;
if|if
condition|(
name|isWindow
argument_list|()
operator|||
operator|!
name|parentWidget
argument_list|()
condition|)
return|return
name|QCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
return|;
return|return
name|parentWidget
argument_list|()
operator|->
name|cursor
argument_list|()
return|;
block|}
DECL|function|setCursor
name|void
name|QWidget
operator|::
name|setCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// On Mac we must set the cursor even if it is the ArrowCursor.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|cursor
operator|.
name|shape
argument_list|()
operator|!=
name|Qt
operator|::
name|ArrowCursor
operator|||
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|curs
operator|)
condition|)
endif|#
directive|endif
block|{
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|QCursor
modifier|*
name|newCursor
init|=
operator|new
name|QCursor
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
operator|delete
name|d
operator|->
name|extra
operator|->
name|curs
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|curs
operator|=
name|newCursor
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCursor_sys
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|CursorChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
DECL|function|unsetCursor
name|void
name|QWidget
operator|::
name|unsetCursor
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
condition|)
block|{
operator|delete
name|d
operator|->
name|extra
operator|->
name|curs
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|curs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|unsetCursor_sys
argument_list|()
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|CursorChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*!     \enum QWidget::RenderFlag      This enum describes how to render the widget when calling QWidget::render().      \value DrawWindowBackground If you enable this option, the widget's background     is rendered into the target even if autoFillBackground is not set. By default,     this option is enabled.      \value DrawChildren If you enable this option, the widget's children     are rendered recursively into the target. By default, this option is enabled.      \value IgnoreMask If you enable this option, the widget's QWidget::mask()     is ignored when rendering into the target. By default, this option is disabled.      \since 4.3 */
comment|/*!     \since 4.3      Renders the \a sourceRegion of this widget into the \a target     using \a renderFlags to determine how to render. Rendering     starts at \a targetOffset in the \a target. For example:      \snippet code/src_gui_kernel_qwidget.cpp 7      If \a sourceRegion is a null region, this function will use QWidget::rect() as     the region, i.e. the entire widget.      Ensure that you call QPainter::end() for the \a target device's     active painter (if any) before rendering. For example:      \snippet code/src_gui_kernel_qwidget.cpp 8      \note To obtain the contents of an OpenGL widget, use QGLWidget::grabFrameBuffer()     or QGLWidget::renderPixmap() instead. */
DECL|function|render
name|void
name|QWidget
operator|::
name|render
parameter_list|(
name|QPaintDevice
modifier|*
name|target
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|targetOffset
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|sourceRegion
parameter_list|,
name|RenderFlags
name|renderFlags
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|render
argument_list|(
name|target
argument_list|,
name|targetOffset
argument_list|,
name|sourceRegion
argument_list|,
name|renderFlags
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/*!     \overload      Renders the widget into the \a painter's QPainter::device().      Transformations and settings applied to the \a painter will be used     when rendering.      \note The \a painter must be active. On Mac OS X the widget will be     rendered into a QPixmap and then drawn by the \a painter.      \sa QPainter::device() */
DECL|function|render
name|void
name|QWidget
operator|::
name|render
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|targetOffset
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|sourceRegion
parameter_list|,
name|RenderFlags
name|renderFlags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|painter
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::render: Null pointer to painter"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|painter
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::render: Cannot render with an inactive painter"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|qreal
name|opacity
init|=
name|painter
operator|->
name|opacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|opacity
argument_list|)
condition|)
return|return;
comment|// Fully transparent.
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|inRenderWithPainter
init|=
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|inRenderWithPainter
decl_stmt|;
specifier|const
name|QRegion
name|toBePainted
init|=
operator|!
name|inRenderWithPainter
condition|?
name|d
operator|->
name|prepareToRender
argument_list|(
name|sourceRegion
argument_list|,
name|renderFlags
argument_list|)
else|:
name|sourceRegion
decl_stmt|;
if|if
condition|(
name|toBePainted
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
condition|)
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|inRenderWithPainter
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|d
operator|->
name|render_helper
argument_list|(
name|painter
argument_list|,
name|targetOffset
argument_list|,
name|toBePainted
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
else|#
directive|else
name|QPaintEngine
modifier|*
name|engine
init|=
name|painter
operator|->
name|paintEngine
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|QPaintEnginePrivate
modifier|*
name|enginePriv
init|=
name|engine
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|enginePriv
argument_list|)
expr_stmt|;
name|QPaintDevice
modifier|*
name|target
init|=
name|engine
operator|->
name|paintDevice
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|// Render via a pixmap when dealing with non-opaque painters or printers.
if|if
condition|(
operator|!
name|inRenderWithPainter
operator|&&
operator|(
name|opacity
operator|<
literal|1.0
operator|||
operator|(
name|target
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Printer
operator|)
operator|)
condition|)
block|{
name|d
operator|->
name|render_helper
argument_list|(
name|painter
argument_list|,
name|targetOffset
argument_list|,
name|toBePainted
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|inRenderWithPainter
operator|=
literal|false
expr_stmt|;
return|return;
block|}
comment|// Set new shared painter.
name|QPainter
modifier|*
name|oldPainter
init|=
name|d
operator|->
name|sharedPainter
argument_list|()
decl_stmt|;
name|d
operator|->
name|setSharedPainter
argument_list|(
name|painter
argument_list|)
expr_stmt|;
comment|// Save current system clip, viewport and transform,
specifier|const
name|QTransform
name|oldTransform
init|=
name|enginePriv
operator|->
name|systemTransform
decl_stmt|;
specifier|const
name|QRegion
name|oldSystemClip
init|=
name|enginePriv
operator|->
name|systemClip
decl_stmt|;
specifier|const
name|QRegion
name|oldSystemViewport
init|=
name|enginePriv
operator|->
name|systemViewport
decl_stmt|;
comment|// This ensures that all painting triggered by render() is clipped to the current engine clip.
if|if
condition|(
name|painter
operator|->
name|hasClipping
argument_list|()
condition|)
block|{
specifier|const
name|QRegion
name|painterClip
init|=
name|painter
operator|->
name|deviceTransform
argument_list|()
operator|.
name|map
argument_list|(
name|painter
operator|->
name|clipRegion
argument_list|()
argument_list|)
decl_stmt|;
name|enginePriv
operator|->
name|setSystemViewport
argument_list|(
name|oldSystemClip
operator|.
name|isEmpty
argument_list|()
condition|?
name|painterClip
else|:
name|oldSystemClip
operator|&
name|painterClip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enginePriv
operator|->
name|setSystemViewport
argument_list|(
name|oldSystemClip
argument_list|)
expr_stmt|;
block|}
name|render
argument_list|(
name|target
argument_list|,
name|targetOffset
argument_list|,
name|toBePainted
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
comment|// Restore system clip, viewport and transform.
name|enginePriv
operator|->
name|systemClip
operator|=
name|oldSystemClip
expr_stmt|;
name|enginePriv
operator|->
name|setSystemViewport
argument_list|(
name|oldSystemViewport
argument_list|)
expr_stmt|;
name|enginePriv
operator|->
name|setSystemTransform
argument_list|(
name|oldTransform
argument_list|)
expr_stmt|;
comment|// Restore shared painter.
name|d
operator|->
name|setSharedPainter
argument_list|(
name|oldPainter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|extra
operator|->
name|inRenderWithPainter
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|sendResizeEvents
specifier|static
name|void
name|sendResizeEvents
parameter_list|(
name|QWidget
modifier|*
name|target
parameter_list|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|target
operator|->
name|size
argument_list|()
argument_list|,
name|QSize
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
specifier|const
name|QObjectList
name|children
init|=
name|target
operator|->
name|children
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|isWidgetType
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isWindow
argument_list|()
operator|&&
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
condition|)
name|sendResizeEvents
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \since 5.0      Renders the widget into a pixmap restricted by the     given \a rectangle. If the widget has any children, then     they are also painted in the appropriate positions.      If a rectangle with an invalid size is specified  (the default),     the entire widget is painted.      \sa render(), QPixmap */
comment|/* INVOKABLE since used by QPixmap::grabWidget(). */
DECL|function|grab
name|QPixmap
name|QWidget
operator|::
name|grab
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rectangle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
operator|||
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|sendResizeEvents
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
operator|::
name|RenderFlags
name|renderFlags
init|=
name|QWidget
operator|::
name|DrawWindowBackground
operator||
name|QWidget
operator|::
name|DrawChildren
operator||
name|QWidget
operator|::
name|IgnoreMask
decl_stmt|;
specifier|const
name|bool
name|oldDirtyOpaqueChildren
init|=
name|d
operator|->
name|dirtyOpaqueChildren
decl_stmt|;
name|QRect
name|r
argument_list|(
name|rectangle
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|width
argument_list|()
operator|<
literal|0
operator|||
name|r
operator|.
name|height
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|// For grabbing widgets that haven't been shown yet,
comment|// we trigger the layouting mechanism to determine the widget's size.
name|r
operator|=
name|d
operator|->
name|prepareToRender
argument_list|(
name|QRegion
argument_list|()
argument_list|,
name|renderFlags
argument_list|)
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|r
operator|.
name|setTopLeft
argument_list|(
name|rectangle
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
operator|.
name|intersects
argument_list|(
name|rect
argument_list|()
argument_list|)
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QPixmap
name|res
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isOpaque
condition|)
name|res
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|render
argument_list|(
operator|&
name|res
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|QRegion
argument_list|(
name|r
argument_list|)
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirtyOpaqueChildren
operator|=
name|oldDirtyOpaqueChildren
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/*!     \brief The graphicsEffect function returns a pointer to the     widget's graphics effect.      If the widget has no graphics effect, 0 is returned.      \since 4.6      \sa setGraphicsEffect() */
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
DECL|function|graphicsEffect
name|QGraphicsEffect
modifier|*
name|QWidget
operator|::
name|graphicsEffect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|graphicsEffect
return|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
comment|/*!    \brief The setGraphicsEffect function is for setting the widget's graphics effect.      Sets \a effect as the widget's effect. If there already is an effect installed     on this widget, QWidget will delete the existing effect before installing     the new \a effect.      If \a effect is the installed on a different widget, setGraphicsEffect() will remove     the effect from the widget and install it on this widget.      QWidget takes ownership of \a effect.      \note This function will apply the effect on itself and all its children.      \since 4.6      \sa graphicsEffect() */
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
DECL|function|setGraphicsEffect
name|void
name|QWidget
operator|::
name|setGraphicsEffect
parameter_list|(
name|QGraphicsEffect
modifier|*
name|effect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|graphicsEffect
operator|==
name|effect
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|graphicsEffect
condition|)
block|{
name|d
operator|->
name|invalidateBuffer
argument_list|(
name|rect
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|graphicsEffect
expr_stmt|;
name|d
operator|->
name|graphicsEffect
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|effect
condition|)
block|{
comment|// Set new effect.
name|QGraphicsEffectSourcePrivate
modifier|*
name|sourced
init|=
operator|new
name|QWidgetEffectSourcePrivate
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QGraphicsEffectSource
modifier|*
name|source
init|=
operator|new
name|QGraphicsEffectSource
argument_list|(
operator|*
name|sourced
argument_list|)
decl_stmt|;
name|d
operator|->
name|graphicsEffect
operator|=
name|effect
expr_stmt|;
name|effect
operator|->
name|d_func
argument_list|()
operator|->
name|setGraphicsEffectSource
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
DECL|function|isAboutToShow
name|bool
name|QWidgetPrivate
operator|::
name|isAboutToShow
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|data
operator|.
name|in_show
condition|)
return|return
literal|true
return|;
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isHidden
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// The widget will be shown if any of its ancestors are about to show.
name|QWidget
modifier|*
name|parent
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
return|return
name|parent
condition|?
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|isAboutToShow
argument_list|()
else|:
literal|false
return|;
block|}
DECL|function|prepareToRender
name|QRegion
name|QWidgetPrivate
operator|::
name|prepareToRender
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
name|QWidget
operator|::
name|RenderFlags
name|renderFlags
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|isVisible
init|=
name|q
operator|->
name|isVisible
argument_list|()
decl_stmt|;
comment|// Make sure the widget is laid out correctly.
if|if
condition|(
operator|!
name|isVisible
operator|&&
operator|!
name|isAboutToShow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|topLevel
init|=
name|q
operator|->
name|window
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
expr_stmt|;
comment|// Make sure we at least have top-data.
name|topLevel
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
comment|// Invalidate the layout of hidden ancestors (incl. myself) and pretend
comment|// they're not explicitly hidden.
name|QWidget
modifier|*
name|widget
init|=
name|q
decl_stmt|;
name|QWidgetList
name|hiddenWidgets
decl_stmt|;
while|while
condition|(
name|widget
condition|)
block|{
if|if
condition|(
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hiddenWidgets
operator|.
name|append
argument_list|(
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
operator|->
name|isWindow
argument_list|()
operator|&&
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|updateGeometry_helper
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|widget
operator|=
name|widget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
comment|// Activate top-level layout.
if|if
condition|(
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
comment|// Adjust size if necessary.
name|QTLWExtra
modifier|*
name|topLevelExtra
init|=
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|topLevelExtra
operator|&&
operator|!
name|topLevelExtra
operator|->
name|sizeAdjusted
operator|&&
operator|!
name|topLevel
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
condition|)
block|{
name|topLevel
operator|->
name|adjustSize
argument_list|()
expr_stmt|;
name|topLevel
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Activate child layouts.
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|activateChildLayoutsRecursively
argument_list|()
expr_stmt|;
comment|// We're not cheating with WA_WState_Hidden anymore.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hiddenWidgets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|hiddenWidgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
operator|->
name|isWindow
argument_list|()
operator|&&
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isVisible
condition|)
block|{
name|q
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|sendPendingMoveAndResizeEvents
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Calculate the region to be painted.
name|QRegion
name|toBePainted
init|=
operator|!
name|region
operator|.
name|isEmpty
argument_list|()
condition|?
name|region
else|:
name|QRegion
argument_list|(
name|q
operator|->
name|rect
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|renderFlags
operator|&
name|QWidget
operator|::
name|IgnoreMask
operator|)
operator|&&
name|extra
operator|&&
name|extra
operator|->
name|hasMask
condition|)
name|toBePainted
operator|&=
name|extra
operator|->
name|mask
expr_stmt|;
return|return
name|toBePainted
return|;
block|}
DECL|function|render_helper
name|void
name|QWidgetPrivate
operator|::
name|render_helper
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|targetOffset
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|toBePainted
parameter_list|,
name|QWidget
operator|::
name|RenderFlags
name|renderFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|painter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|toBePainted
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
specifier|const
name|QTransform
name|originalTransform
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|useDeviceCoordinates
init|=
name|originalTransform
operator|.
name|isScaling
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|useDeviceCoordinates
condition|)
block|{
endif|#
directive|endif
comment|// Render via a pixmap.
specifier|const
name|QRect
name|rect
init|=
name|toBePainted
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
specifier|const
name|QSize
name|size
init|=
name|rect
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|QPixmap
name|pixmap
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|renderFlags
operator|&
name|QWidget
operator|::
name|DrawWindowBackground
operator|)
operator|||
operator|!
name|isOpaque
condition|)
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|q
operator|->
name|render
argument_list|(
operator|&
name|pixmap
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|toBePainted
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|restore
init|=
operator|!
operator|(
name|painter
operator|->
name|renderHints
argument_list|()
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
operator|)
decl_stmt|;
name|painter
operator|->
name|setRenderHints
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|targetOffset
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore
condition|)
name|painter
operator|->
name|setRenderHints
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
literal|false
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
block|}
else|else
block|{
comment|// Render via a pixmap in device coordinates (to avoid pixmap scaling).
name|QTransform
name|transform
init|=
name|originalTransform
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|targetOffset
operator|.
name|x
argument_list|()
argument_list|,
name|targetOffset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|QPaintDevice
modifier|*
name|device
init|=
name|painter
operator|->
name|device
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|// Calculate device rect.
specifier|const
name|QRectF
name|rect
argument_list|(
name|toBePainted
operator|.
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|deviceRect
init|=
name|transform
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|deviceRect
operator|&=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|device
operator|->
name|width
argument_list|()
argument_list|,
name|device
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QPixmap
name|pixmap
argument_list|(
name|deviceRect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
comment|// Create a pixmap device coordinate painter.
name|QPainter
name|pixmapPainter
argument_list|(
operator|&
name|pixmap
argument_list|)
decl_stmt|;
name|pixmapPainter
operator|.
name|setRenderHints
argument_list|(
name|painter
operator|->
name|renderHints
argument_list|()
argument_list|)
expr_stmt|;
name|transform
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|deviceRect
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|deviceRect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|setTransform
argument_list|(
name|transform
argument_list|)
expr_stmt|;
name|q
operator|->
name|render
argument_list|(
operator|&
name|pixmapPainter
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|toBePainted
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|end
argument_list|()
expr_stmt|;
comment|// And then draw the pixmap.
name|painter
operator|->
name|setTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|deviceRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setTransform
argument_list|(
name|originalTransform
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
DECL|function|drawWidget
name|void
name|QWidgetPrivate
operator|::
name|drawWidget
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|,
name|int
name|flags
parameter_list|,
name|QPainter
modifier|*
name|sharedPainter
parameter_list|,
name|QWidgetBackingStore
modifier|*
name|backingStore
parameter_list|)
block|{
if|if
condition|(
name|rgn
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|qt_mac_clearDirtyOnWidgetInsideDrawWidget
condition|)
name|dirtyOnWidget
operator|=
name|QRegion
argument_list|()
expr_stmt|;
comment|// We disable the rendering of QToolBar in the backingStore if
comment|// it's supposed to be in the unified toolbar on Mac OS X.
if|if
condition|(
name|backingStore
operator|&&
name|isInUnifiedToolbar
condition|)
return|return;
endif|#
directive|endif
comment|// Q_WS_MAC
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|graphicsEffect
operator|&&
name|graphicsEffect
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|QGraphicsEffectSource
modifier|*
name|source
init|=
name|graphicsEffect
operator|->
name|d_func
argument_list|()
operator|->
name|source
decl_stmt|;
name|QWidgetEffectSourcePrivate
modifier|*
name|sourced
init|=
cast|static_cast
argument_list|<
name|QWidgetEffectSourcePrivate
operator|*
argument_list|>
argument_list|(
name|source
operator|->
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourced
operator|->
name|context
condition|)
block|{
name|QWidgetPaintContext
name|context
argument_list|(
name|pdev
argument_list|,
name|rgn
argument_list|,
name|offset
argument_list|,
name|flags
argument_list|,
name|sharedPainter
argument_list|,
name|backingStore
argument_list|)
decl_stmt|;
name|sourced
operator|->
name|context
operator|=
operator|&
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|sharedPainter
condition|)
block|{
name|setSystemClip
argument_list|(
name|pdev
argument_list|,
name|rgn
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|p
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|context
operator|.
name|painter
operator|=
operator|&
name|p
expr_stmt|;
name|graphicsEffect
operator|->
name|draw
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|setSystemClip
argument_list|(
name|pdev
argument_list|,
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|.
name|painter
operator|=
name|sharedPainter
expr_stmt|;
if|if
condition|(
name|sharedPainter
operator|->
name|worldTransform
argument_list|()
operator|!=
name|sourced
operator|->
name|lastEffectTransform
condition|)
block|{
name|sourced
operator|->
name|invalidateCache
argument_list|()
expr_stmt|;
name|sourced
operator|->
name|lastEffectTransform
operator|=
name|sharedPainter
operator|->
name|worldTransform
argument_list|()
expr_stmt|;
block|}
name|sharedPainter
operator|->
name|save
argument_list|()
expr_stmt|;
name|sharedPainter
operator|->
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|graphicsEffect
operator|->
name|draw
argument_list|(
name|sharedPainter
argument_list|)
expr_stmt|;
name|sharedPainter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
name|sourced
operator|->
name|context
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_GRAFFICSEFFECT
specifier|const
name|bool
name|asRoot
init|=
name|flags
operator|&
name|DrawAsRoot
decl_stmt|;
specifier|const
name|bool
name|alsoOnScreen
init|=
name|flags
operator|&
name|DrawPaintOnScreen
decl_stmt|;
specifier|const
name|bool
name|recursive
init|=
name|flags
operator|&
name|DrawRecursive
decl_stmt|;
specifier|const
name|bool
name|alsoInvisible
init|=
name|flags
operator|&
name|DrawInvisible
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|sharedPainter
condition|?
name|sharedPainter
operator|->
name|isActive
argument_list|()
else|:
literal|true
argument_list|)
expr_stmt|;
name|QRegion
name|toBePainted
argument_list|(
name|rgn
argument_list|)
decl_stmt|;
if|if
condition|(
name|asRoot
operator|&&
operator|!
name|alsoInvisible
condition|)
name|toBePainted
operator|&=
name|clipRect
argument_list|()
expr_stmt|;
comment|//(rgn& visibleRegion());
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DontSubtractOpaqueChildren
operator|)
condition|)
name|subtractOpaqueChildren
argument_list|(
name|toBePainted
argument_list|,
name|q
operator|->
name|rect
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toBePainted
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|onScreen
init|=
name|paintOnScreen
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|onScreen
operator|||
name|alsoOnScreen
condition|)
block|{
comment|//update the "in paint event" flag
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"QWidget::repaint: Recursive repaint detected"
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|)
expr_stmt|;
comment|//clip away the new area
ifndef|#
directive|ifndef
name|QT_NO_PAINT_DEBUG
name|bool
name|flushed
init|=
name|QWidgetBackingStore
operator|::
name|flushPaint
argument_list|(
name|q
argument_list|,
name|toBePainted
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QPaintEngine
modifier|*
name|paintEngine
init|=
name|pdev
operator|->
name|paintEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|paintEngine
condition|)
block|{
name|setRedirected
argument_list|(
name|pdev
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// (Alien support) Special case for Mac when redirecting: If the paint device
comment|// is of the Widget type we need to set WA_WState_InPaintEvent since painting
comment|// outside the paint event is not supported on QWidgets. The attributeis
comment|// restored further down.
if|if
condition|(
name|pdev
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|pdev
argument_list|)
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sharedPainter
condition|)
name|setSystemClip
argument_list|(
name|pdev
argument_list|,
name|toBePainted
argument_list|)
expr_stmt|;
else|else
name|paintEngine
operator|->
name|d_func
argument_list|()
operator|->
name|systemRect
operator|=
name|q
operator|->
name|data
operator|->
name|crect
expr_stmt|;
comment|//paint the background
if|if
condition|(
operator|(
name|asRoot
operator|||
name|q
operator|->
name|autoFillBackground
argument_list|()
operator|||
name|onScreen
operator|||
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyledBackground
argument_list|)
operator|)
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_OpaquePaintEvent
argument_list|)
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
condition|)
block|{
name|QPainter
name|p
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|paintBackground
argument_list|(
operator|&
name|p
argument_list|,
name|toBePainted
argument_list|,
operator|(
name|asRoot
operator|||
name|onScreen
operator|)
condition|?
name|flags
operator||
name|DrawAsRoot
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sharedPainter
condition|)
name|setSystemClip
argument_list|(
name|pdev
argument_list|,
name|toBePainted
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onScreen
operator|&&
operator|!
name|asRoot
operator|&&
operator|!
name|isOpaque
operator|&&
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TintedBackground
argument_list|)
condition|)
block|{
name|QPainter
name|p
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|QColor
name|tint
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|window
argument_list|()
operator|.
name|color
argument_list|()
decl_stmt|;
name|tint
operator|.
name|setAlphaF
argument_list|(
name|qreal
argument_list|(
literal|.6
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|toBePainted
operator|.
name|boundingRect
argument_list|()
argument_list|,
name|tint
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|qDebug()<< "painting"<< q<< "opaque =="<< isOpaque();             qDebug()<< "clipping to"<< toBePainted<< "location == "<< offset<< "geometry =="<< QRect(q->mapTo(q->window(), QPoint(0, 0)), q->size());
endif|#
directive|endif
comment|//actually send the paint event
name|QPaintEvent
name|e
argument_list|(
name|toBePainted
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|// Native widgets need to be marked dirty on screen so painting will be done in correct context
if|if
condition|(
name|backingStore
operator|&&
operator|!
name|onScreen
operator|&&
operator|!
name|asRoot
operator|&&
operator|(
name|q
operator|->
name|internalWinId
argument_list|()
operator|||
operator|!
name|q
operator|->
name|nativeParentWidget
argument_list|()
operator|->
name|isWindow
argument_list|()
operator|)
condition|)
name|backingStore
operator|->
name|markDirtyOnScreen
argument_list|(
name|toBePainted
argument_list|,
name|q
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|//restore
if|if
condition|(
name|paintEngine
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|pdev
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|pdev
argument_list|)
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restoreRedirected
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sharedPainter
condition|)
name|paintEngine
operator|->
name|d_func
argument_list|()
operator|->
name|systemRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
else|else
name|paintEngine
operator|->
name|d_func
argument_list|()
operator|->
name|currentClipDevice
operator|=
literal|0
expr_stmt|;
name|setSystemClip
argument_list|(
name|pdev
argument_list|,
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|paintingActive
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QWidget::repaint: It is dangerous to leave painters active on a widget outside of the PaintEvent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|paintEngine
operator|&&
name|paintEngine
operator|->
name|autoDestruct
argument_list|()
condition|)
block|{
operator|delete
name|paintEngine
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_PAINT_DEBUG
if|if
condition|(
name|flushed
condition|)
name|QWidgetBackingStore
operator|::
name|unflushPaint
argument_list|(
name|q
argument_list|,
name|toBePainted
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QPaintEngine
modifier|*
name|engine
init|=
name|pdev
operator|->
name|paintEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
condition|)
block|{
name|QPainter
name|p
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|p
operator|.
name|setClipRegion
argument_list|(
name|toBePainted
argument_list|)
expr_stmt|;
specifier|const
name|QBrush
name|bg
init|=
name|q
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Window
argument_list|)
decl_stmt|;
if|if
condition|(
name|bg
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
name|p
operator|.
name|drawTiledPixmap
argument_list|(
name|q
operator|->
name|rect
argument_list|()
argument_list|,
name|bg
operator|.
name|texture
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|.
name|fillRect
argument_list|(
name|q
operator|->
name|rect
argument_list|()
argument_list|,
name|bg
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|autoDestruct
argument_list|()
condition|)
operator|delete
name|engine
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|recursive
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|paintSiblingsRecursive
argument_list|(
name|pdev
argument_list|,
name|children
argument_list|,
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|rgn
argument_list|,
name|offset
argument_list|,
name|flags
operator|&
operator|~
name|DrawAsRoot
argument_list|,
name|sharedPainter
argument_list|,
name|backingStore
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|render
name|void
name|QWidgetPrivate
operator|::
name|render
parameter_list|(
name|QPaintDevice
modifier|*
name|target
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|targetOffset
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|sourceRegion
parameter_list|,
name|QWidget
operator|::
name|RenderFlags
name|renderFlags
parameter_list|,
name|bool
name|readyToRender
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::render: null pointer to paint device"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|bool
name|inRenderWithPainter
init|=
name|extra
operator|&&
name|extra
operator|->
name|inRenderWithPainter
decl_stmt|;
name|QRegion
name|paintRegion
init|=
operator|!
name|inRenderWithPainter
operator|&&
operator|!
name|readyToRender
condition|?
name|prepareToRender
argument_list|(
name|sourceRegion
argument_list|,
name|renderFlags
argument_list|)
else|:
name|sourceRegion
decl_stmt|;
if|if
condition|(
name|paintRegion
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
ifndef|#
directive|ifndef
name|Q_WS_MAC
name|QPainter
modifier|*
name|oldSharedPainter
init|=
name|inRenderWithPainter
condition|?
name|sharedPainter
argument_list|()
else|:
literal|0
decl_stmt|;
comment|// Use the target's shared painter if set (typically set when doing
comment|// "other->render(widget);" in the widget's paintEvent.
if|if
condition|(
name|target
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|QWidgetPrivate
modifier|*
name|targetPrivate
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetPrivate
operator|->
name|extra
operator|&&
name|targetPrivate
operator|->
name|extra
operator|->
name|inRenderWithPainter
condition|)
block|{
name|QPainter
modifier|*
name|targetPainter
init|=
name|targetPrivate
operator|->
name|sharedPainter
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetPainter
operator|&&
name|targetPainter
operator|->
name|isActive
argument_list|()
condition|)
name|setSharedPainter
argument_list|(
name|targetPainter
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Use the target's redirected device if set and adjust offset and paint
comment|// region accordingly. This is typically the case when people call render
comment|// from the paintEvent.
name|QPoint
name|offset
init|=
name|targetOffset
decl_stmt|;
name|offset
operator|-=
name|paintRegion
operator|.
name|boundingRect
argument_list|()
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|QPoint
name|redirectionOffset
decl_stmt|;
name|QPaintDevice
modifier|*
name|redirected
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
name|redirected
operator|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|target
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|redirected
argument_list|(
operator|&
name|redirectionOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirected
condition|)
name|redirected
operator|=
name|QPainter
operator|::
name|redirected
argument_list|(
name|target
argument_list|,
operator|&
name|redirectionOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirected
condition|)
block|{
name|target
operator|=
name|redirected
expr_stmt|;
name|offset
operator|-=
name|redirectionOffset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inRenderWithPainter
condition|)
block|{
comment|// Clip handled by shared painter (in qpainter.cpp).
if|if
condition|(
name|QPaintEngine
modifier|*
name|targetEngine
init|=
name|target
operator|->
name|paintEngine
argument_list|()
condition|)
block|{
specifier|const
name|QRegion
name|targetSystemClip
init|=
name|targetEngine
operator|->
name|systemClip
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|targetSystemClip
operator|.
name|isEmpty
argument_list|()
condition|)
name|paintRegion
operator|&=
name|targetSystemClip
operator|.
name|translated
argument_list|(
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set backingstore flags.
name|int
name|flags
init|=
name|DrawPaintOnScreen
operator||
name|DrawInvisible
decl_stmt|;
if|if
condition|(
name|renderFlags
operator|&
name|QWidget
operator|::
name|DrawWindowBackground
condition|)
name|flags
operator||=
name|DrawAsRoot
expr_stmt|;
if|if
condition|(
name|renderFlags
operator|&
name|QWidget
operator|::
name|DrawChildren
condition|)
name|flags
operator||=
name|DrawRecursive
expr_stmt|;
else|else
name|flags
operator||=
name|DontSubtractOpaqueChildren
expr_stmt|;
name|flags
operator||=
name|DontSetCompositionMode
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Printer
condition|)
block|{
name|QPainter
name|p
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|render_helper
argument_list|(
operator|&
name|p
argument_list|,
name|targetOffset
argument_list|,
name|paintRegion
argument_list|,
name|renderFlags
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|Q_WS_MAC
comment|// Render via backingstore.
name|drawWidget
argument_list|(
name|target
argument_list|,
name|paintRegion
argument_list|,
name|offset
argument_list|,
name|flags
argument_list|,
name|sharedPainter
argument_list|()
argument_list|)
expr_stmt|;
comment|// Restore shared painter.
if|if
condition|(
name|oldSharedPainter
condition|)
name|setSharedPainter
argument_list|(
name|oldSharedPainter
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Render via backingstore (no shared painter).
name|drawWidget
argument_list|(
name|target
argument_list|,
name|paintRegion
argument_list|,
name|offset
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|paintSiblingsRecursive
name|void
name|QWidgetPrivate
operator|::
name|paintSiblingsRecursive
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|,
specifier|const
name|QObjectList
modifier|&
name|siblings
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|,
name|int
name|flags
parameter_list|,
name|QPainter
modifier|*
name|sharedPainter
parameter_list|,
name|QWidgetBackingStore
modifier|*
name|backingStore
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
literal|0
decl_stmt|;
name|QRect
name|boundingRect
decl_stmt|;
name|bool
name|dirtyBoundingRect
init|=
literal|true
decl_stmt|;
specifier|const
name|bool
name|exludeOpaqueChildren
init|=
operator|(
name|flags
operator|&
name|DontDrawOpaqueChildren
operator|)
decl_stmt|;
specifier|const
name|bool
name|excludeNativeChildren
init|=
operator|(
name|flags
operator|&
name|DontDrawNativeChildren
operator|)
decl_stmt|;
do|do
block|{
name|QWidget
modifier|*
name|x
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|siblings
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|&&
operator|!
operator|(
name|exludeOpaqueChildren
operator|&&
name|x
operator|->
name|d_func
argument_list|()
operator|->
name|isOpaque
operator|)
operator|&&
operator|!
name|x
operator|->
name|isHidden
argument_list|()
operator|&&
operator|!
name|x
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|excludeNativeChildren
operator|&&
name|x
operator|->
name|internalWinId
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|dirtyBoundingRect
condition|)
block|{
name|boundingRect
operator|=
name|rgn
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|dirtyBoundingRect
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|qRectIntersects
argument_list|(
name|boundingRect
argument_list|,
name|x
operator|->
name|d_func
argument_list|()
operator|->
name|effectiveRectFor
argument_list|(
name|x
operator|->
name|data
operator|->
name|crect
argument_list|)
argument_list|)
condition|)
block|{
name|w
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
operator|--
name|index
expr_stmt|;
block|}
do|while
condition|(
name|index
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|widgetPos
argument_list|(
name|w
operator|->
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|hasMask
init|=
name|wd
operator|->
name|extra
operator|&&
name|wd
operator|->
name|extra
operator|->
name|hasMask
operator|&&
operator|!
name|wd
operator|->
name|graphicsEffect
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|QRegion
name|wr
argument_list|(
name|rgn
argument_list|)
decl_stmt|;
if|if
condition|(
name|wd
operator|->
name|isOpaque
condition|)
name|wr
operator|-=
name|hasMask
condition|?
name|wd
operator|->
name|extra
operator|->
name|mask
operator|.
name|translated
argument_list|(
name|widgetPos
argument_list|)
else|:
name|w
operator|->
name|data
operator|->
name|crect
expr_stmt|;
name|paintSiblingsRecursive
argument_list|(
name|pdev
argument_list|,
name|siblings
argument_list|,
operator|--
name|index
argument_list|,
name|wr
argument_list|,
name|offset
argument_list|,
name|flags
argument_list|,
name|sharedPainter
argument_list|,
name|backingStore
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|updatesEnabled
argument_list|()
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
operator|&&
operator|(
operator|!
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|||
operator|!
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|proxyWidget
operator|)
endif|#
directive|endif
comment|//QT_NO_GRAPHICSVIEW
condition|)
block|{
name|QRegion
name|wRegion
argument_list|(
name|rgn
argument_list|)
decl_stmt|;
name|wRegion
operator|&=
name|wd
operator|->
name|effectiveRectFor
argument_list|(
name|w
operator|->
name|data
operator|->
name|crect
argument_list|)
expr_stmt|;
name|wRegion
operator|.
name|translate
argument_list|(
operator|-
name|widgetPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasMask
condition|)
name|wRegion
operator|&=
name|wd
operator|->
name|extra
operator|->
name|mask
expr_stmt|;
name|wd
operator|->
name|drawWidget
argument_list|(
name|pdev
argument_list|,
name|wRegion
argument_list|,
name|offset
operator|+
name|widgetPos
argument_list|,
name|flags
argument_list|,
name|sharedPainter
argument_list|,
name|backingStore
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
DECL|function|boundingRect
name|QRectF
name|QWidgetEffectSourcePrivate
operator|::
name|boundingRect
parameter_list|(
name|Qt
operator|::
name|CoordinateSystem
name|system
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|system
operator|!=
name|Qt
operator|::
name|DeviceCoordinates
condition|)
return|return
name|m_widget
operator|->
name|rect
argument_list|()
return|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
comment|// Device coordinates without context not yet supported.
name|qWarning
argument_list|(
literal|"QGraphicsEffectSource::boundingRect: Not yet implemented, lacking device context"
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|()
return|;
block|}
return|return
name|context
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|m_widget
operator|->
name|rect
argument_list|()
argument_list|)
return|;
block|}
DECL|function|draw
name|void
name|QWidgetEffectSourcePrivate
operator|::
name|draw
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|||
name|context
operator|->
name|painter
operator|!=
name|painter
condition|)
block|{
name|m_widget
operator|->
name|render
argument_list|(
name|painter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// The region saved in the context is neither clipped to the rect
comment|// nor the mask, so we have to clip it here before calling drawWidget.
name|QRegion
name|toBePainted
init|=
name|context
operator|->
name|rgn
decl_stmt|;
name|toBePainted
operator|&=
name|m_widget
operator|->
name|rect
argument_list|()
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|wd
init|=
name|qt_widget_private
argument_list|(
name|m_widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|wd
operator|->
name|extra
operator|&&
name|wd
operator|->
name|extra
operator|->
name|hasMask
condition|)
name|toBePainted
operator|&=
name|wd
operator|->
name|extra
operator|->
name|mask
expr_stmt|;
name|wd
operator|->
name|drawWidget
argument_list|(
name|context
operator|->
name|pdev
argument_list|,
name|toBePainted
argument_list|,
name|context
operator|->
name|offset
argument_list|,
name|context
operator|->
name|flags
argument_list|,
name|context
operator|->
name|sharedPainter
argument_list|,
name|context
operator|->
name|backingStore
argument_list|)
expr_stmt|;
block|}
DECL|function|pixmap
name|QPixmap
name|QWidgetEffectSourcePrivate
operator|::
name|pixmap
parameter_list|(
name|Qt
operator|::
name|CoordinateSystem
name|system
parameter_list|,
name|QPoint
modifier|*
name|offset
parameter_list|,
name|QGraphicsEffect
operator|::
name|PixmapPadMode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|bool
name|deviceCoordinates
init|=
operator|(
name|system
operator|==
name|Qt
operator|::
name|DeviceCoordinates
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|&&
name|deviceCoordinates
condition|)
block|{
comment|// Device coordinates without context not yet supported.
name|qWarning
argument_list|(
literal|"QGraphicsEffectSource::pixmap: Not yet implemented, lacking device context"
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
name|QPoint
name|pixmapOffset
decl_stmt|;
name|QRectF
name|sourceRect
init|=
name|m_widget
operator|->
name|rect
argument_list|()
decl_stmt|;
if|if
condition|(
name|deviceCoordinates
condition|)
block|{
specifier|const
name|QTransform
modifier|&
name|painterTransform
init|=
name|context
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
name|sourceRect
operator|=
name|painterTransform
operator|.
name|mapRect
argument_list|(
name|sourceRect
argument_list|)
expr_stmt|;
name|pixmapOffset
operator|=
name|painterTransform
operator|.
name|map
argument_list|(
name|pixmapOffset
argument_list|)
expr_stmt|;
block|}
name|QRect
name|effectRect
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QGraphicsEffect
operator|::
name|PadToEffectiveBoundingRect
condition|)
name|effectRect
operator|=
name|m_widget
operator|->
name|graphicsEffect
argument_list|()
operator|->
name|boundingRectFor
argument_list|(
name|sourceRect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|QGraphicsEffect
operator|::
name|PadToTransparentBorder
condition|)
name|effectRect
operator|=
name|sourceRect
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
else|else
name|effectRect
operator|=
name|sourceRect
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|effectRect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|pixmapOffset
operator|-=
name|effectRect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|QPixmap
name|pixmap
argument_list|(
name|effectRect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|m_widget
operator|->
name|render
argument_list|(
operator|&
name|pixmap
argument_list|,
name|pixmapOffset
argument_list|,
name|QRegion
argument_list|()
argument_list|,
name|QWidget
operator|::
name|DrawChildren
argument_list|)
expr_stmt|;
return|return
name|pixmap
return|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|/*!     \internal      Finds the nearest widget embedded in a graphics proxy widget along the chain formed by this     widget and its ancestors. The search starts at \a origin (inclusive).     If successful, the function returns the proxy that embeds the widget, or 0 if no embedded     widget was found. */
DECL|function|nearestGraphicsProxyWidget
name|QGraphicsProxyWidget
modifier|*
name|QWidgetPrivate
operator|::
name|nearestGraphicsProxyWidget
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|origin
parameter_list|)
block|{
if|if
condition|(
name|origin
condition|)
block|{
name|QWExtra
modifier|*
name|extra
init|=
name|origin
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|proxyWidget
condition|)
return|return
name|extra
operator|->
name|proxyWidget
return|;
return|return
name|nearestGraphicsProxyWidget
argument_list|(
name|origin
operator|->
name|parentWidget
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*!     \property QWidget::locale     \brief the widget's locale     \since 4.3      As long as no special locale has been set, this is either     the parent's locale or (if this widget is a top level widget),     the default locale.      If the widget displays dates or numbers, these should be formatted     using the widget's locale.      \sa QLocale, QLocale::setDefault() */
DECL|function|setLocale_helper
name|void
name|QWidgetPrivate
operator|::
name|setLocale_helper
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|loc
parameter_list|,
name|bool
name|forceUpdate
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|loc
operator|&&
operator|!
name|forceUpdate
condition|)
return|return;
name|locale
operator|=
name|loc
expr_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
condition|)
continue|continue;
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|setLocale_helper
argument_list|(
name|loc
argument_list|,
name|forceUpdate
argument_list|)
expr_stmt|;
block|}
block|}
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|LocaleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
DECL|function|setLocale
name|void
name|QWidget
operator|::
name|setLocale
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLocale_helper
argument_list|(
name|locale
argument_list|)
expr_stmt|;
block|}
DECL|function|locale
name|QLocale
name|QWidget
operator|::
name|locale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|locale
return|;
block|}
DECL|function|resolveLocale
name|void
name|QWidgetPrivate
operator|::
name|resolveLocale
parameter_list|()
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|)
condition|)
block|{
name|setLocale_helper
argument_list|(
name|q
operator|->
name|isWindow
argument_list|()
condition|?
name|QLocale
argument_list|()
else|:
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|locale
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|unsetLocale
name|void
name|QWidget
operator|::
name|unsetLocale
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLocale
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|resolveLocale
argument_list|()
expr_stmt|;
block|}
comment|/*!     \property QWidget::windowTitle     \brief the window title (caption)      This property only makes sense for top-level widgets, such as     windows and dialogs. If no caption has been set, the title is based of the     \l windowFilePath. If neither of these is set, then the title is     an empty string.      If you use the \l windowModified mechanism, the window title must     contain a "[*]" placeholder, which indicates where the '*' should     appear. Normally, it should appear right after the file name     (e.g., "document1.txt[*] - Text Editor"). If the \l     windowModified property is false (the default), the placeholder     is simply removed.      On some desktop platforms (including Windows and Unix), the application name     (from QGuiApplication::applicationDisplayName) is added at the end of the     window title, if set. This is done by the QPA plugin, so it is shown to the     user, but isn't part of the \l windowTitle string.      \sa windowIcon, windowIconText, windowModified, windowFilePath */
DECL|function|windowTitle
name|QString
name|QWidget
operator|::
name|windowTitle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|caption
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|caption
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|filePath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QFileInfo
argument_list|(
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|filePath
argument_list|)
operator|.
name|fileName
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"[*]"
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
comment|/*!     Returns a modified window title with the [*] place holder     replaced according to the rules described in QWidget::setWindowTitle      This function assumes that "[*]" can be quoted by another     "[*]", so it will replace two place holders by one and     a single last one by either "*" or nothing depending on     the modified flag.      \internal */
DECL|function|qt_setWindowTitle_helperHelper
name|QString
name|qt_setWindowTitle_helperHelper
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|widget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|QString
name|qt_eval_adapt_window_title
argument_list|(
specifier|const
name|QString
operator|&
name|title
argument_list|)
decl_stmt|;
name|QString
name|cap
init|=
name|qt_eval_adapt_window_title
argument_list|(
name|title
argument_list|)
decl_stmt|;
else|#
directive|else
name|QString
name|cap
init|=
name|title
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|cap
return|;
name|QLatin1String
name|placeHolder
argument_list|(
literal|"[*]"
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cap
operator|.
name|indexOf
argument_list|(
name|placeHolder
argument_list|)
decl_stmt|;
comment|// here the magic begins
while|while
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|index
operator|+=
name|placeHolder
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cap
operator|.
name|indexOf
argument_list|(
name|placeHolder
argument_list|,
name|index
argument_list|)
operator|==
name|index
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|index
operator|+=
name|placeHolder
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|%
literal|2
condition|)
block|{
comment|// odd number of [*] -> replace last one
name|int
name|lastIndex
init|=
name|cap
operator|.
name|lastIndexOf
argument_list|(
name|placeHolder
argument_list|,
name|index
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|isWindowModified
argument_list|()
operator|&&
name|widget
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_TitleBar_ModifyNotification
argument_list|,
literal|0
argument_list|,
name|widget
argument_list|)
condition|)
name|cap
operator|.
name|replace
argument_list|(
name|lastIndex
argument_list|,
literal|3
argument_list|,
name|QWidget
operator|::
name|tr
argument_list|(
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cap
operator|.
name|remove
argument_list|(
name|lastIndex
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|cap
operator|.
name|indexOf
argument_list|(
name|placeHolder
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|cap
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"[*][*]"
argument_list|)
argument_list|,
name|placeHolder
argument_list|)
expr_stmt|;
return|return
name|cap
return|;
block|}
DECL|function|setWindowTitle_helper
name|void
name|QWidgetPrivate
operator|::
name|setWindowTitle_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|setWindowTitle_sys
argument_list|(
name|qt_setWindowTitle_helperHelper
argument_list|(
name|title
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|setWindowIconText_helper
name|void
name|QWidgetPrivate
operator|::
name|setWindowIconText_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|setWindowIconText_sys
argument_list|(
name|qt_setWindowTitle_helperHelper
argument_list|(
name|title
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|setWindowIconText
name|void
name|QWidget
operator|::
name|setWindowIconText
parameter_list|(
specifier|const
name|QString
modifier|&
name|iconText
parameter_list|)
block|{
if|if
condition|(
name|QWidget
operator|::
name|windowIconText
argument_list|()
operator|==
name|iconText
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|topData
argument_list|()
operator|->
name|iconText
operator|=
name|iconText
expr_stmt|;
name|d
operator|->
name|setWindowIconText_helper
argument_list|(
name|iconText
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|IconTextChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
DECL|function|setWindowTitle
name|void
name|QWidget
operator|::
name|setWindowTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
if|if
condition|(
name|QWidget
operator|::
name|windowTitle
argument_list|()
operator|==
name|title
operator|&&
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|title
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|topData
argument_list|()
operator|->
name|caption
operator|=
name|title
expr_stmt|;
name|d
operator|->
name|setWindowTitle_helper
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WindowTitleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::windowIcon     \brief the widget's icon      This property only makes sense for windows. If no icon     has been set, windowIcon() returns the application icon     (QApplication::windowIcon()).      \sa windowIconText, windowTitle */
DECL|function|windowIcon
name|QIcon
name|QWidget
operator|::
name|windowIcon
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
specifier|const
name|QWidgetPrivate
modifier|*
name|d
init|=
name|w
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|icon
condition|)
return|return
operator|*
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|icon
return|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
return|return
name|QApplication
operator|::
name|windowIcon
argument_list|()
return|;
block|}
DECL|function|setWindowIcon_helper
name|void
name|QWidgetPrivate
operator|::
name|setWindowIcon_helper
parameter_list|()
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WindowIconChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q_func
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setWindowIcon
name|void
name|QWidget
operator|::
name|setWindowIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetWindowIcon
argument_list|,
operator|!
name|icon
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|createTLExtra
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|icon
condition|)
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|icon
operator|=
operator|new
name|QIcon
argument_list|()
expr_stmt|;
operator|*
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|icon
operator|=
name|icon
expr_stmt|;
name|d
operator|->
name|setWindowIcon_sys
argument_list|()
expr_stmt|;
name|d
operator|->
name|setWindowIcon_helper
argument_list|()
expr_stmt|;
block|}
comment|/*!     \property QWidget::windowIconText     \brief the widget's icon text      This property only makes sense for windows. If no icon     text has been set, this functions returns an empty string.      \sa windowIcon, windowTitle */
DECL|function|windowIconText
name|QString
name|QWidget
operator|::
name|windowIconText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|)
condition|?
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|iconText
else|:
name|QString
argument_list|()
return|;
block|}
comment|/*!     \property QWidget::windowFilePath     \since 4.4     \brief the file path associated with a widget      This property only makes sense for windows. It associates a file path with     a window. If you set the file path, but have not set the window title, Qt     sets the window title to the file name of the specified path, obtained using     QFileInfo::fileName().      If the window title is set at any point, then the window title takes precedence and     will be shown instead of the file path string.      Additionally, on Mac OS X, this has an added benefit that it sets the     \l{http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGWindows/chapter_17_section_3.html}{proxy icon}     for the window, assuming that the file path exists.      If no file path is set, this property contains an empty string.      By default, this property contains an empty string.      \sa windowTitle, windowIcon */
DECL|function|windowFilePath
name|QString
name|QWidget
operator|::
name|windowFilePath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|)
condition|?
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|filePath
else|:
name|QString
argument_list|()
return|;
block|}
DECL|function|setWindowFilePath
name|void
name|QWidget
operator|::
name|setWindowFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
if|if
condition|(
name|filePath
operator|==
name|windowFilePath
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createTLExtra
argument_list|()
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|filePath
operator|=
name|filePath
expr_stmt|;
name|d
operator|->
name|setWindowFilePath_helper
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
block|}
DECL|function|setWindowFilePath_helper
name|void
name|QWidgetPrivate
operator|::
name|setWindowFilePath_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|filePath
parameter_list|)
block|{
if|if
condition|(
name|extra
operator|->
name|topextra
operator|&&
name|extra
operator|->
name|topextra
operator|->
name|caption
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|setWindowTitle_helper
argument_list|(
name|QFileInfo
argument_list|(
name|filePath
argument_list|)
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
name|setWindowTitle_helper
argument_list|(
name|q
operator|->
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|setWindowFilePath_sys
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*!     Returns the window's role, or an empty string.      \sa windowIcon, windowTitle */
DECL|function|windowRole
name|QString
name|QWidget
operator|::
name|windowRole
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|topextra
operator|)
condition|?
name|d
operator|->
name|extra
operator|->
name|topextra
operator|->
name|role
else|:
name|QString
argument_list|()
return|;
block|}
comment|/*!     Sets the window's role to \a role. This only makes sense for     windows on X11. */
DECL|function|setWindowRole
name|void
name|QWidget
operator|::
name|setWindowRole
parameter_list|(
specifier|const
name|QString
modifier|&
name|role
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|topData
argument_list|()
operator|->
name|role
operator|=
name|role
expr_stmt|;
name|d
operator|->
name|setWindowRole
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|role
argument_list|)
endif|#
directive|endif
block|}
comment|/*!     \property QWidget::mouseTracking     \brief whether mouse tracking is enabled for the widget      If mouse tracking is disabled (the default), the widget only     receives mouse move events when at least one mouse button is     pressed while the mouse is being moved.      If mouse tracking is enabled, the widget receives mouse move     events even if no buttons are pressed.      \sa mouseMoveEvent() */
comment|/*!     Sets the widget's focus proxy to widget \a w. If \a w is 0, the     function resets this widget to have no focus proxy.      Some widgets can "have focus", but create a child widget, such as     QLineEdit, to actually handle the focus. In this case, the widget     can set the line edit to be its focus proxy.      setFocusProxy() sets the widget which will actually get focus when     "this widget" gets it. If there is a focus proxy, setFocus() and     hasFocus() operate on the focus proxy.      \sa focusProxy() */
DECL|function|setFocusProxy
name|void
name|QWidget
operator|::
name|setFocusProxy
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|&&
operator|!
name|d
operator|->
name|extra
condition|)
return|return;
for|for
control|(
name|QWidget
modifier|*
name|fp
init|=
name|w
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|focusProxy
argument_list|()
control|)
block|{
if|if
condition|(
name|fp
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget: %s (%s) already in focus proxy chain"
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|focus_proxy
operator|=
name|w
expr_stmt|;
block|}
comment|/*!     Returns the focus proxy, or 0 if there is no focus proxy.      \sa setFocusProxy() */
DECL|function|focusProxy
name|QWidget
modifier|*
name|QWidget
operator|::
name|focusProxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extra
condition|?
operator|(
name|QWidget
operator|*
operator|)
name|d
operator|->
name|extra
operator|->
name|focus_proxy
else|:
literal|0
return|;
block|}
comment|/*!     \property QWidget::focus     \brief whether this widget (or its focus proxy) has the keyboard     input focus      By default, this property is false.      \note Obtaining the value of this property for a widget is effectively equivalent     to checking whether QApplication::focusWidget() refers to the widget.      \sa setFocus(), clearFocus(), setFocusPolicy(), QApplication::focusWidget() */
DECL|function|hasFocus
name|bool
name|QWidget
operator|::
name|hasFocus
parameter_list|()
specifier|const
block|{
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|w
operator|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|window
init|=
name|w
operator|->
name|window
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QWExtra
modifier|*
name|e
init|=
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|proxyWidget
operator|&&
name|e
operator|->
name|proxyWidget
operator|->
name|hasFocus
argument_list|()
operator|&&
name|window
operator|->
name|focusWidget
argument_list|()
operator|==
name|w
condition|)
return|return
literal|true
return|;
endif|#
directive|endif
block|}
return|return
operator|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|==
name|w
operator|)
return|;
block|}
comment|/*!     Gives the keyboard input focus to this widget (or its focus     proxy) if this widget or one of its parents is the \l{isActiveWindow()}{active window}. The \a reason argument will     be passed into any focus event sent from this function, it is used     to give an explanation of what caused the widget to get focus.     If the window is not active, the widget will be given the focus when     the window becomes active.      First, a focus about to change event is sent to the focus widget (if any) to     tell it that it is about to lose the focus. Then focus is changed, a     focus out event is sent to the previous focus item and a focus in event is sent     to the new item to tell it that it just received the focus.     (Nothing happens if the focus in and focus out widgets are the     same.)      \note On embedded platforms, setFocus() will not cause an input panel     to be opened by the input method. If you want this to happen, you     have to send a QEvent::RequestSoftwareInputPanel event to the     widget yourself.      setFocus() gives focus to a widget regardless of its focus policy,     but does not clear any keyboard grab (see grabKeyboard()).      Be aware that if the widget is hidden, it will not accept focus     until it is shown.      \warning If you call setFocus() in a function which may itself be     called from focusOutEvent() or focusInEvent(), you may get an     infinite recursion.      \sa hasFocus(), clearFocus(), focusInEvent(), focusOutEvent(),     setFocusPolicy(), focusWidget(), QApplication::focusWidget(), grabKeyboard(),     grabMouse(), {Keyboard Focus in Widgets}, QEvent::RequestSoftwareInputPanel */
DECL|function|setFocus
name|void
name|QWidget
operator|::
name|setFocus
parameter_list|(
name|Qt
operator|::
name|FocusReason
name|reason
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
return|return;
name|QWidget
modifier|*
name|f
init|=
name|this
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|&&
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|f
operator|=
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|extra
operator|->
name|focus_proxy
expr_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|==
name|f
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|&&
name|GetFocus
argument_list|()
operator|==
name|f
operator|->
name|internalWinId
argument_list|()
endif|#
directive|endif
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QWidget
modifier|*
name|previousProxyFocus
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QWExtra
modifier|*
name|topData
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|topData
operator|->
name|proxyWidget
operator|&&
name|topData
operator|->
name|proxyWidget
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
name|previousProxyFocus
operator|=
name|topData
operator|->
name|proxyWidget
operator|->
name|widget
argument_list|()
operator|->
name|focusWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|previousProxyFocus
operator|&&
name|previousProxyFocus
operator|->
name|focusProxy
argument_list|()
condition|)
name|previousProxyFocus
operator|=
name|previousProxyFocus
operator|->
name|focusProxy
argument_list|()
expr_stmt|;
if|if
condition|(
name|previousProxyFocus
operator|==
name|this
operator|&&
operator|!
name|topData
operator|->
name|proxyWidget
operator|->
name|d_func
argument_list|()
operator|->
name|proxyIsGivingFocus
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// Update proxy state
if|if
condition|(
name|QWExtra
modifier|*
name|topData
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|topData
operator|->
name|proxyWidget
operator|&&
operator|!
name|topData
operator|->
name|proxyWidget
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|updateFocusChild
argument_list|()
expr_stmt|;
name|topData
operator|->
name|proxyWidget
operator|->
name|d_func
argument_list|()
operator|->
name|focusFromWidgetToProxy
operator|=
literal|1
expr_stmt|;
name|topData
operator|->
name|proxyWidget
operator|->
name|setFocus
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|topData
operator|->
name|proxyWidget
operator|->
name|d_func
argument_list|()
operator|->
name|focusFromWidgetToProxy
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|f
operator|->
name|isActiveWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|prev
init|=
name|QApplicationPrivate
operator|::
name|focus_widget
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|MenuBarFocusReason
operator|&&
name|prev
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|NoFocusReason
condition|)
block|{
name|QFocusEvent
name|focusAboutToChange
argument_list|(
name|QEvent
operator|::
name|FocusAboutToChange
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|prev
argument_list|,
operator|&
name|focusAboutToChange
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|updateFocusChild
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
name|f
argument_list|,
name|reason
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// The negation of the condition in setFocus_sys
if|if
condition|(
operator|!
operator|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|window
argument_list|()
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Popup
operator|&&
name|internalWinId
argument_list|()
operator|)
condition|)
comment|//setFocusWidget will already post a focus event for us (that the AT client receives) on Windows
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_UNIX
comment|// menus update the focus manually and this would create bogus events
if|if
condition|(
operator|!
operator|(
name|f
operator|->
name|inherits
argument_list|(
literal|"QMenuBar"
argument_list|)
operator|||
name|f
operator|->
name|inherits
argument_list|(
literal|"QMenu"
argument_list|)
operator|||
name|f
operator|->
name|inherits
argument_list|(
literal|"QMenuItem"
argument_list|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|QAccessibleEvent
name|event
argument_list|(
name|f
argument_list|,
name|QAccessible
operator|::
name|Focus
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QWExtra
modifier|*
name|topData
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|topData
operator|->
name|proxyWidget
condition|)
block|{
if|if
condition|(
name|previousProxyFocus
operator|&&
name|previousProxyFocus
operator|!=
name|f
condition|)
block|{
comment|// Send event to self
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|previousProxyFocus
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|previousProxyFocus
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isHidden
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// Update proxy state
if|if
condition|(
name|QWExtra
modifier|*
name|topData
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|extra
condition|)
if|if
condition|(
name|topData
operator|->
name|proxyWidget
operator|&&
name|topData
operator|->
name|proxyWidget
operator|->
name|hasFocus
argument_list|()
condition|)
name|topData
operator|->
name|proxyWidget
operator|->
name|d_func
argument_list|()
operator|->
name|updateProxyInputMethodAcceptanceFromWidget
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Send event to self
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|reason
argument_list|)
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|f
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|f
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|that
operator|->
name|style
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|updateFocusChild
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|QTLWExtra
modifier|*
name|extra
init|=
name|f
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
condition|)
block|{
if|if
condition|(
name|extra
operator|->
name|window
condition|)
emit|emit
name|extra
operator|->
name|window
operator|->
name|focusObjectChanged
argument_list|(
name|f
argument_list|)
emit|;
block|}
block|}
comment|// updates focus_child on parent widgets to point into this widget
DECL|function|updateFocusChild
name|void
name|QWidgetPrivate
operator|::
name|updateFocusChild
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|q
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|isHidden
argument_list|()
condition|)
block|{
while|while
condition|(
name|w
operator|&&
name|w
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_child
operator|=
name|q
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|isWindow
argument_list|()
condition|?
literal|0
else|:
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_child
operator|=
name|q
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|isWindow
argument_list|()
condition|?
literal|0
else|:
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*!     \fn void QWidget::setFocus()     \overload      Gives the keyboard input focus to this widget (or its focus     proxy) if this widget or one of its parents is the     \l{isActiveWindow()}{active window}. */
comment|/*!     Takes keyboard input focus from the widget.      If the widget has active focus, a \l{focusOutEvent()}{focus out event} is sent to this widget to tell it that it has     lost the focus.      This widget must enable focus setting in order to get the keyboard     input focus, i.e. it must call setFocusPolicy().      \sa hasFocus(), setFocus(), focusInEvent(), focusOutEvent(),     setFocusPolicy(), QApplication::focusWidget() */
DECL|function|clearFocus
name|void
name|QWidget
operator|::
name|clearFocus
parameter_list|()
block|{
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|QFocusEvent
name|focusAboutToChange
argument_list|(
name|QEvent
operator|::
name|FocusAboutToChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|focusAboutToChange
argument_list|)
expr_stmt|;
block|}
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_child
operator|==
name|this
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_child
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
name|QWExtra
modifier|*
name|topData
init|=
name|d_func
argument_list|()
operator|->
name|extra
decl_stmt|;
if|if
condition|(
name|topData
operator|&&
name|topData
operator|->
name|proxyWidget
condition|)
name|topData
operator|->
name|proxyWidget
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
comment|// Update proxy state
name|QApplicationPrivate
operator|::
name|setFocusWidget
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
if|if
condition|(
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|&&
name|GetFocus
argument_list|()
operator|==
name|internalWinId
argument_list|()
condition|)
name|SetFocus
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|Focus
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/*!     \fn bool QWidget::focusNextChild()      Finds a new widget to give the keyboard focus to, as appropriate     for \uicontrol Tab, and returns true if it can find a new widget, or     false if it can't.      \sa focusPreviousChild() */
comment|/*!     \fn bool QWidget::focusPreviousChild()      Finds a new widget to give the keyboard focus to, as appropriate     for \uicontrol Shift+Tab, and returns true if it can find a new widget,     or false if it can't.      \sa focusNextChild() */
comment|/*!     Finds a new widget to give the keyboard focus to, as appropriate     for Tab and Shift+Tab, and returns true if it can find a new     widget, or false if it can't.      If \a next is true, this function searches forward, if \a next     is false, it searches backward.      Sometimes, you will want to reimplement this function. For     example, a web browser might reimplement it to move its "current     active link" forward or backward, and call     focusNextPrevChild() only when it reaches the last or     first link on the "page".      Child widgets call focusNextPrevChild() on their parent widgets,     but only the window that contains the child widgets decides where     to redirect focus. By reimplementing this function for an object,     you thus gain control of focus traversal for all child widgets.      \sa focusNextChild(), focusPreviousChild() */
DECL|function|focusNextPrevChild
name|bool
name|QWidget
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|p
init|=
name|parentWidget
argument_list|()
decl_stmt|;
name|bool
name|isSubWindow
init|=
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|SubWindow
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
operator|!
name|isSubWindow
operator|&&
name|p
condition|)
return|return
name|p
operator|->
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|proxyWidget
condition|)
return|return
name|d
operator|->
name|extra
operator|->
name|proxyWidget
operator|->
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
endif|#
directive|endif
name|QWidget
modifier|*
name|w
init|=
name|QApplicationPrivate
operator|::
name|focusNextPrevChild_helper
argument_list|(
name|this
argument_list|,
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
literal|false
return|;
name|w
operator|->
name|setFocus
argument_list|(
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*!     Returns the last child of this widget that setFocus had been     called on.  For top level widgets this is the widget that will get     focus in case this window gets activated      This is not the same as QApplication::focusWidget(), which returns     the focus widget in the currently active window. */
DECL|function|focusWidget
name|QWidget
modifier|*
name|QWidget
operator|::
name|focusWidget
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
operator|->
name|focus_child
argument_list|)
return|;
block|}
comment|/*!     Returns the next widget in this widget's focus chain.      \sa previousInFocusChain() */
DECL|function|nextInFocusChain
name|QWidget
modifier|*
name|QWidget
operator|::
name|nextInFocusChain
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
operator|->
name|focus_next
argument_list|)
return|;
block|}
comment|/*!     \brief The previousInFocusChain function returns the previous     widget in this widget's focus chain.      \sa nextInFocusChain()      \since 4.6 */
DECL|function|previousInFocusChain
name|QWidget
modifier|*
name|QWidget
operator|::
name|previousInFocusChain
parameter_list|()
specifier|const
block|{
return|return
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
operator|->
name|focus_prev
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::isActiveWindow     \brief whether this widget's window is the active window      The active window is the window that contains the widget that has     keyboard focus (The window may still have focus if it has no     widgets or none of its widgets accepts keyboard focus).      When popup windows are visible, this property is true for both the     active window \e and for the popup.      By default, this property is false.      \sa activateWindow(), QApplication::activeWindow() */
DECL|function|isActiveWindow
name|bool
name|QWidget
operator|::
name|isActiveWindow
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|tlw
init|=
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlw
operator|==
name|QApplication
operator|::
name|activeWindow
argument_list|()
operator|||
operator|(
name|isVisible
argument_list|()
operator|&&
operator|(
name|tlw
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|)
condition|)
return|return
literal|true
return|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QWExtra
modifier|*
name|tlwExtra
init|=
name|tlw
operator|->
name|d_func
argument_list|()
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
name|tlwExtra
operator|->
name|proxyWidget
condition|)
return|return
name|tlwExtra
operator|->
name|proxyWidget
operator|->
name|isActiveWindow
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Widget_ShareActivation
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
name|tlw
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Tool
operator|&&
operator|!
name|tlw
operator|->
name|isModal
argument_list|()
operator|&&
operator|(
operator|!
name|tlw
operator|->
name|parentWidget
argument_list|()
operator|||
name|tlw
operator|->
name|parentWidget
argument_list|()
operator|->
name|isActiveWindow
argument_list|()
operator|)
condition|)
return|return
literal|true
return|;
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|activeWindow
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
operator|&&
name|tlw
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Tool
operator|&&
operator|!
name|w
operator|->
name|isModal
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
operator|->
name|window
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|tlw
condition|)
return|return
literal|true
return|;
block|}
block|}
comment|// Check if platform adaptation thinks the window is active. This is necessary for
comment|// example in case of ActiveQt servers that are embedded into another application.
comment|// Those are separate processes that are not part of the parent application Qt window/widget
comment|// hierarchy, so they need to rely on native methods to determine if they are part of the
comment|// active window.
if|if
condition|(
specifier|const
name|QWindow
modifier|*
name|w
init|=
name|tlw
operator|->
name|windowHandle
argument_list|()
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|handle
argument_list|()
condition|)
return|return
name|w
operator|->
name|handle
argument_list|()
operator|->
name|isActive
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/*!     Puts the \a second widget after the \a first widget in the focus order.      Note that since the tab order of the \a second widget is changed, you     should order a chain like this:      \snippet code/src_gui_kernel_qwidget.cpp 9      \e not like this:      \snippet code/src_gui_kernel_qwidget.cpp 10      If \a first or \a second has a focus proxy, setTabOrder()     correctly substitutes the proxy.      \sa setFocusPolicy(), setFocusProxy(), {Keyboard Focus in Widgets} */
DECL|function|setTabOrder
name|void
name|QWidget
operator|::
name|setTabOrder
parameter_list|(
name|QWidget
modifier|*
name|first
parameter_list|,
name|QWidget
modifier|*
name|second
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
operator|||
operator|!
name|second
operator|||
name|first
operator|->
name|focusPolicy
argument_list|()
operator|==
name|Qt
operator|::
name|NoFocus
operator|||
name|second
operator|->
name|focusPolicy
argument_list|()
operator|==
name|Qt
operator|::
name|NoFocus
condition|)
return|return;
if|if
condition|(
name|first
operator|->
name|window
argument_list|()
operator|!=
name|second
operator|->
name|window
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setTabOrder: 'first' and 'second' must be in the same window"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QWidget
modifier|*
name|fp
init|=
name|first
operator|->
name|focusProxy
argument_list|()
decl_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
comment|// If first is redirected, set first to the last child of first
comment|// that can take keyboard focus so that second is inserted after
comment|// that last child, and the focus order within first is (more
comment|// likely to be) preserved.
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|l
init|=
name|first
operator|->
name|findChildren
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|l
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QWidget
modifier|*
name|next
init|=
name|l
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|window
argument_list|()
operator|==
name|fp
operator|->
name|window
argument_list|()
condition|)
block|{
name|fp
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
break|break;
block|}
block|}
name|first
operator|=
name|fp
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|second
condition|)
return|return;
if|if
condition|(
name|QWidget
modifier|*
name|sp
init|=
name|second
operator|->
name|focusProxy
argument_list|()
condition|)
name|second
operator|=
name|sp
expr_stmt|;
comment|//    QWidget *fp = first->d_func()->focus_prev;
name|QWidget
modifier|*
name|fn
init|=
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|second
operator|||
name|first
operator|==
name|second
condition|)
return|return;
name|QWidget
modifier|*
name|sp
init|=
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
decl_stmt|;
name|QWidget
modifier|*
name|sn
init|=
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
decl_stmt|;
name|fn
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|second
expr_stmt|;
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|second
expr_stmt|;
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|fn
expr_stmt|;
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|first
expr_stmt|;
name|sp
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|sn
expr_stmt|;
name|sn
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|sp
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|==
name|first
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|==
name|first
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|==
name|second
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|==
name|second
argument_list|)
expr_stmt|;
block|}
comment|/*!\internal    Moves the relevant subwidgets of this widget from the \a oldtlw's   tab chain to that of the new parent, if there's anything to move and   we're really moving    This function is called from QWidget::reparent() *after* the widget   has been reparented.    \sa reparent() */
DECL|function|reparentFocusWidgets
name|void
name|QWidgetPrivate
operator|::
name|reparentFocusWidgets
parameter_list|(
name|QWidget
modifier|*
name|oldtlw
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtlw
operator|==
name|q
operator|->
name|window
argument_list|()
condition|)
return|return;
comment|// nothing to do
if|if
condition|(
name|focus_child
condition|)
name|focus_child
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
comment|// separate the focus chain into new (children of myself) and old (the rest)
name|QWidget
modifier|*
name|firstOld
init|=
literal|0
decl_stmt|;
comment|//QWidget *firstNew = q; //invariant
name|QWidget
modifier|*
name|o
init|=
literal|0
decl_stmt|;
comment|// last in the old list
name|QWidget
modifier|*
name|n
init|=
name|q
decl_stmt|;
comment|// last in the new list
name|bool
name|prevWasNew
init|=
literal|true
decl_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|focus_next
decl_stmt|;
comment|//Note: for efficiency, we do not maintain the list invariant inside the loop
comment|//we append items to the relevant list, and we optimize by not changing pointers
comment|//when subsequent items are going into the same list.
while|while
condition|(
name|w
operator|!=
name|q
condition|)
block|{
name|bool
name|currentIsNew
init|=
name|q
operator|->
name|isAncestorOf
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentIsNew
condition|)
block|{
if|if
condition|(
operator|!
name|prevWasNew
condition|)
block|{
comment|//prev was old -- append to new list
name|n
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevWasNew
condition|)
block|{
comment|//prev was new -- append to old list, if there is one
if|if
condition|(
name|o
condition|)
block|{
name|o
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
comment|// "create" the old list
name|firstOld
operator|=
name|w
expr_stmt|;
block|}
block|}
name|o
operator|=
name|w
expr_stmt|;
block|}
name|w
operator|=
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
expr_stmt|;
name|prevWasNew
operator|=
name|currentIsNew
expr_stmt|;
block|}
comment|//repair the old list:
if|if
condition|(
name|firstOld
condition|)
block|{
name|o
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|firstOld
expr_stmt|;
name|firstOld
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|topLevel
init|=
name|q
operator|->
name|window
argument_list|()
decl_stmt|;
comment|//insert new chain into toplevel's chain
name|QWidget
modifier|*
name|prev
init|=
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
decl_stmt|;
name|topLevel
operator|->
name|d_func
argument_list|()
operator|->
name|focus_prev
operator|=
name|n
expr_stmt|;
name|prev
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|q
expr_stmt|;
name|focus_prev
operator|=
name|prev
expr_stmt|;
name|n
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|topLevel
expr_stmt|;
block|}
else|else
block|{
comment|//repair the new list
name|n
operator|->
name|d_func
argument_list|()
operator|->
name|focus_next
operator|=
name|q
expr_stmt|;
name|focus_prev
operator|=
name|n
expr_stmt|;
block|}
block|}
comment|/*!\internal    Measures the shortest distance from a point to a rect.    This function is called from QDesktopwidget::screen(QPoint) to find the   closest screen for a point.   In directional KeypadNavigation, it is called to find the closest   widget to the current focus widget center. */
DECL|function|pointToRect
name|int
name|QWidgetPrivate
operator|::
name|pointToRect
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|dy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|x
argument_list|()
operator|<
name|r
operator|.
name|left
argument_list|()
condition|)
name|dx
operator|=
name|r
operator|.
name|left
argument_list|()
operator|-
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|x
argument_list|()
operator|>
name|r
operator|.
name|right
argument_list|()
condition|)
name|dx
operator|=
name|p
operator|.
name|x
argument_list|()
operator|-
name|r
operator|.
name|right
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|y
argument_list|()
operator|<
name|r
operator|.
name|top
argument_list|()
condition|)
name|dy
operator|=
name|r
operator|.
name|top
argument_list|()
operator|-
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|y
argument_list|()
operator|>
name|r
operator|.
name|bottom
argument_list|()
condition|)
name|dy
operator|=
name|p
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|bottom
argument_list|()
expr_stmt|;
return|return
name|dx
operator|+
name|dy
return|;
block|}
comment|/*!     \property QWidget::frameSize     \brief the size of the widget including any window frame      By default, this property contains a value that depends on the user's     platform and screen geometry. */
DECL|function|frameSize
name|QSize
name|QWidget
operator|::
name|frameSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
block|{
name|QRect
name|fs
init|=
name|d
operator|->
name|frameStrut
argument_list|()
decl_stmt|;
return|return
name|QSize
argument_list|(
name|data
operator|->
name|crect
operator|.
name|width
argument_list|()
operator|+
name|fs
operator|.
name|left
argument_list|()
operator|+
name|fs
operator|.
name|right
argument_list|()
argument_list|,
name|data
operator|->
name|crect
operator|.
name|height
argument_list|()
operator|+
name|fs
operator|.
name|top
argument_list|()
operator|+
name|fs
operator|.
name|bottom
argument_list|()
argument_list|)
return|;
block|}
return|return
name|data
operator|->
name|crect
operator|.
name|size
argument_list|()
return|;
block|}
comment|/*! \fn void QWidget::move(int x, int y)      \overload      This corresponds to move(QPoint(\a x, \a y)). */
DECL|function|move
name|void
name|QWidget
operator|::
name|move
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
block|{
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|posIncludesFrame
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|setGeometry_sys
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|+
name|geometry
argument_list|()
operator|.
name|x
argument_list|()
operator|-
name|QWidget
operator|::
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
operator|+
name|geometry
argument_list|()
operator|.
name|y
argument_list|()
operator|-
name|QWidget
operator|::
name|y
argument_list|()
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no frame yet: see also QWidgetPrivate::fixPosIncludesFrame(), QWindowPrivate::PositionPolicy.
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|posIncludesFrame
operator|=
literal|true
expr_stmt|;
name|data
operator|->
name|crect
operator|.
name|moveTopLeft
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// no frame yet
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingMoveEvent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*! \fn void QWidget::resize(int w, int h)     \overload      This corresponds to resize(QSize(\a w, \a h)). */
DECL|function|resize
name|void
name|QWidget
operator|::
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
block|{
name|d
operator|->
name|fixPosIncludesFrame
argument_list|()
expr_stmt|;
name|d
operator|->
name|setGeometry_sys
argument_list|(
name|geometry
argument_list|()
operator|.
name|x
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|y
argument_list|()
argument_list|,
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|crect
operator|.
name|setSize
argument_list|(
name|s
operator|.
name|boundedTo
argument_list|(
name|maximumSize
argument_list|()
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|minimumSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|setGeometry
name|void
name|QWidget
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|posIncludesFrame
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
block|{
name|d
operator|->
name|setGeometry_sys
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|crect
operator|.
name|setTopLeft
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|->
name|crect
operator|.
name|setSize
argument_list|(
name|r
operator|.
name|size
argument_list|()
operator|.
name|boundedTo
argument_list|(
name|maximumSize
argument_list|()
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|minimumSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingMoveEvent
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \since 4.2     Saves the current geometry and state for top-level widgets.      To save the geometry when the window closes, you can     implement a close event like this:      \snippet code/src_gui_kernel_qwidget.cpp 11      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      Use QMainWindow::saveState() to save the geometry and the state of     toolbars and dock widgets.      \sa restoreGeometry(), QMainWindow::saveState(), QMainWindow::restoreState() */
DECL|function|saveGeometry
name|QByteArray
name|QWidget
operator|::
name|saveGeometry
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// We check if the window was maximized during this invocation. If so, we need to record the
comment|// starting position as 0,0.
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QRect
name|newFramePosition
init|=
name|frameGeometry
argument_list|()
decl_stmt|;
name|QRect
name|newNormalPosition
init|=
name|normalGeometry
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|topData
argument_list|()
operator|->
name|wasMaximized
operator|&&
operator|!
operator|(
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowMaximized
operator|)
condition|)
block|{
comment|// Change the starting position
name|newFramePosition
operator|.
name|moveTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newNormalPosition
operator|.
name|moveTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QByteArray
name|array
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|array
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setVersion
argument_list|(
name|QDataStream
operator|::
name|Qt_4_0
argument_list|)
expr_stmt|;
specifier|const
name|quint32
name|magicNumber
init|=
literal|0x1D9D0CB
decl_stmt|;
name|quint16
name|majorVersion
init|=
literal|1
decl_stmt|;
name|quint16
name|minorVersion
init|=
literal|0
decl_stmt|;
name|stream
operator|<<
name|magicNumber
operator|<<
name|majorVersion
operator|<<
name|minorVersion
ifdef|#
directive|ifdef
name|Q_WS_MAC
operator|<<
name|newFramePosition
operator|<<
name|newNormalPosition
else|#
directive|else
operator|<<
name|frameGeometry
argument_list|()
operator|<<
name|normalGeometry
argument_list|()
endif|#
directive|endif
comment|// Q_WS_MAC
operator|<<
name|qint32
argument_list|(
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenNumber
argument_list|(
name|this
argument_list|)
argument_list|)
operator|<<
name|quint8
argument_list|(
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowMaximized
argument_list|)
operator|<<
name|quint8
argument_list|(
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowFullScreen
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
comment|/*!     \since 4.2      Restores the geometry and state top-level widgets stored in the     byte array \a geometry. Returns true on success; otherwise     returns false.      If the restored geometry is off-screen, it will be modified to be     inside the available screen geometry.      To restore geometry saved using QSettings, you can use code like     this:      \snippet code/src_gui_kernel_qwidget.cpp 12      See the \l{Window Geometry} documentation for an overview of geometry     issues with windows.      Use QMainWindow::restoreState() to restore the geometry and the     state of toolbars and dock widgets.      \sa saveGeometry(), QSettings, QMainWindow::saveState(), QMainWindow::restoreState() */
DECL|function|restoreGeometry
name|bool
name|QWidget
operator|::
name|restoreGeometry
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|geometry
parameter_list|)
block|{
if|if
condition|(
name|geometry
operator|.
name|size
argument_list|()
operator|<
literal|4
condition|)
return|return
literal|false
return|;
name|QDataStream
name|stream
argument_list|(
name|geometry
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setVersion
argument_list|(
name|QDataStream
operator|::
name|Qt_4_0
argument_list|)
expr_stmt|;
specifier|const
name|quint32
name|magicNumber
init|=
literal|0x1D9D0CB
decl_stmt|;
name|quint32
name|storedMagicNumber
decl_stmt|;
name|stream
operator|>>
name|storedMagicNumber
expr_stmt|;
if|if
condition|(
name|storedMagicNumber
operator|!=
name|magicNumber
condition|)
return|return
literal|false
return|;
specifier|const
name|quint16
name|currentMajorVersion
init|=
literal|1
decl_stmt|;
name|quint16
name|majorVersion
init|=
literal|0
decl_stmt|;
name|quint16
name|minorVersion
init|=
literal|0
decl_stmt|;
name|stream
operator|>>
name|majorVersion
operator|>>
name|minorVersion
expr_stmt|;
if|if
condition|(
name|majorVersion
operator|!=
name|currentMajorVersion
condition|)
return|return
literal|false
return|;
comment|// (Allow all minor versions.)
name|QRect
name|restoredFrameGeometry
decl_stmt|;
name|QRect
name|restoredNormalGeometry
decl_stmt|;
name|qint32
name|restoredScreenNumber
decl_stmt|;
name|quint8
name|maximized
decl_stmt|;
name|quint8
name|fullScreen
decl_stmt|;
name|stream
operator|>>
name|restoredFrameGeometry
operator|>>
name|restoredNormalGeometry
operator|>>
name|restoredScreenNumber
operator|>>
name|maximized
operator|>>
name|fullScreen
expr_stmt|;
specifier|const
name|int
name|frameHeight
init|=
literal|20
decl_stmt|;
if|if
condition|(
operator|!
name|restoredFrameGeometry
operator|.
name|isValid
argument_list|()
condition|)
name|restoredFrameGeometry
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sizeHint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restoredNormalGeometry
operator|.
name|isValid
argument_list|()
condition|)
name|restoredNormalGeometry
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
name|frameHeight
argument_list|)
argument_list|,
name|sizeHint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restoredNormalGeometry
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// use the widget's adjustedSize if the sizeHint() doesn't help
name|restoredNormalGeometry
operator|.
name|setSize
argument_list|(
name|restoredNormalGeometry
operator|.
name|size
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|d_func
argument_list|()
operator|->
name|adjustedSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QDesktopWidget
modifier|*
specifier|const
name|desktop
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
decl_stmt|;
if|if
condition|(
name|restoredScreenNumber
operator|>=
name|desktop
operator|->
name|numScreens
argument_list|()
condition|)
name|restoredScreenNumber
operator|=
name|desktop
operator|->
name|primaryScreen
argument_list|()
expr_stmt|;
specifier|const
name|QRect
name|availableGeometry
init|=
name|desktop
operator|->
name|availableGeometry
argument_list|(
name|restoredScreenNumber
argument_list|)
decl_stmt|;
comment|// Modify the restored geometry if we are about to restore to coordinates
comment|// that would make the window "lost". This happens if:
comment|// - The restored geometry is completely oustside the available geometry
comment|// - The title bar is outside the available geometry.
comment|// - (Mac only) The window is higher than the available geometry. It must
comment|//   be possible to bring the size grip on screen by moving the window.
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|restoredFrameGeometry
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|restoredFrameGeometry
operator|.
name|height
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restoredNormalGeometry
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|restoredNormalGeometry
operator|.
name|height
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|height
argument_list|()
operator|-
name|frameHeight
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|restoredFrameGeometry
operator|.
name|intersects
argument_list|(
name|availableGeometry
argument_list|)
condition|)
block|{
name|restoredFrameGeometry
operator|.
name|moveBottom
argument_list|(
name|qMin
argument_list|(
name|restoredFrameGeometry
operator|.
name|bottom
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restoredFrameGeometry
operator|.
name|moveLeft
argument_list|(
name|qMax
argument_list|(
name|restoredFrameGeometry
operator|.
name|left
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restoredFrameGeometry
operator|.
name|moveRight
argument_list|(
name|qMin
argument_list|(
name|restoredFrameGeometry
operator|.
name|right
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|right
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|restoredFrameGeometry
operator|.
name|moveTop
argument_list|(
name|qMax
argument_list|(
name|restoredFrameGeometry
operator|.
name|top
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|top
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restoredNormalGeometry
operator|.
name|intersects
argument_list|(
name|availableGeometry
argument_list|)
condition|)
block|{
name|restoredNormalGeometry
operator|.
name|moveBottom
argument_list|(
name|qMin
argument_list|(
name|restoredNormalGeometry
operator|.
name|bottom
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restoredNormalGeometry
operator|.
name|moveLeft
argument_list|(
name|qMax
argument_list|(
name|restoredNormalGeometry
operator|.
name|left
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|left
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restoredNormalGeometry
operator|.
name|moveRight
argument_list|(
name|qMin
argument_list|(
name|restoredNormalGeometry
operator|.
name|right
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|right
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|restoredNormalGeometry
operator|.
name|moveTop
argument_list|(
name|qMax
argument_list|(
name|restoredNormalGeometry
operator|.
name|top
argument_list|()
argument_list|,
name|availableGeometry
operator|.
name|top
argument_list|()
operator|+
name|frameHeight
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maximized
operator|||
name|fullScreen
condition|)
block|{
comment|// set geometry before setting the window state to make
comment|// sure the window is maximized to the right screen.
comment|// Skip on windows: the window is restored into a broken
comment|// half-maximized state.
ifndef|#
directive|ifndef
name|Q_OS_WIN
name|setGeometry
argument_list|(
name|restoredNormalGeometry
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Qt
operator|::
name|WindowStates
name|ws
init|=
name|windowState
argument_list|()
decl_stmt|;
if|if
condition|(
name|maximized
condition|)
name|ws
operator||=
name|Qt
operator|::
name|WindowMaximized
expr_stmt|;
if|if
condition|(
name|fullScreen
condition|)
name|ws
operator||=
name|Qt
operator|::
name|WindowFullScreen
expr_stmt|;
name|setWindowState
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
operator|->
name|normalGeometry
operator|=
name|restoredNormalGeometry
expr_stmt|;
block|}
else|else
block|{
name|QPoint
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_X11
if|if
condition|(
name|isFullScreen
argument_list|()
condition|)
name|offset
operator|=
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
operator|->
name|fullScreenOffset
expr_stmt|;
endif|#
directive|endif
name|setWindowState
argument_list|(
name|windowState
argument_list|()
operator|&
operator|~
operator|(
name|Qt
operator|::
name|WindowMaximized
operator||
name|Qt
operator|::
name|WindowFullScreen
operator|)
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|restoredFrameGeometry
operator|.
name|topLeft
argument_list|()
operator|+
name|offset
argument_list|)
expr_stmt|;
name|resize
argument_list|(
name|restoredNormalGeometry
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/*!\fn void QWidget::setGeometry(int x, int y, int w, int h)     \overload      This corresponds to setGeometry(QRect(\a x, \a y, \a w, \a h)). */
comment|/*!   Sets the margins around the contents of the widget to have the sizes   \a left, \a top, \a right, and \a bottom. The margins are used by   the layout system, and may be used by subclasses to specify the area   to draw in (e.g. excluding the frame).    Changing the margins will trigger a resizeEvent().    \sa contentsRect(), getContentsMargins() */
DECL|function|setContentsMargins
name|void
name|QWidget
operator|::
name|setContentsMargins
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|d
operator|->
name|leftmargin
operator|&&
name|top
operator|==
name|d
operator|->
name|topmargin
operator|&&
name|right
operator|==
name|d
operator|->
name|rightmargin
operator|&&
name|bottom
operator|==
name|d
operator|->
name|bottommargin
condition|)
return|return;
name|d
operator|->
name|leftmargin
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|topmargin
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|rightmargin
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|bottommargin
operator|=
name|bottom
expr_stmt|;
if|if
condition|(
name|QLayout
modifier|*
name|l
init|=
name|d
operator|->
name|layout
condition|)
name|l
operator|->
name|update
argument_list|()
expr_stmt|;
comment|//force activate; will do updateGeometry
else|else
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|update
argument_list|()
expr_stmt|;
name|QResizeEvent
name|e
argument_list|(
name|data
operator|->
name|crect
operator|.
name|size
argument_list|()
argument_list|,
name|data
operator|->
name|crect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ContentsRectChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!   \overload   \since 4.6    \brief The setContentsMargins function sets the margins around the   widget's contents.    Sets the margins around the contents of the widget to have the   sizes determined by \a margins. The margins are   used by the layout system, and may be used by subclasses to   specify the area to draw in (e.g. excluding the frame).    Changing the margins will trigger a resizeEvent().    \sa contentsRect(), getContentsMargins() */
DECL|function|setContentsMargins
name|void
name|QWidget
operator|::
name|setContentsMargins
parameter_list|(
specifier|const
name|QMargins
modifier|&
name|margins
parameter_list|)
block|{
name|setContentsMargins
argument_list|(
name|margins
operator|.
name|left
argument_list|()
argument_list|,
name|margins
operator|.
name|top
argument_list|()
argument_list|,
name|margins
operator|.
name|right
argument_list|()
argument_list|,
name|margins
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*!   Returns the widget's contents margins for \a left, \a top, \a   right, and \a bottom.    \sa setContentsMargins(), contentsRect()  */
DECL|function|getContentsMargins
name|void
name|QWidget
operator|::
name|getContentsMargins
parameter_list|(
name|int
modifier|*
name|left
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|right
parameter_list|,
name|int
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|d
operator|->
name|leftmargin
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|d
operator|->
name|topmargin
expr_stmt|;
if|if
condition|(
name|right
condition|)
operator|*
name|right
operator|=
name|d
operator|->
name|rightmargin
expr_stmt|;
if|if
condition|(
name|bottom
condition|)
operator|*
name|bottom
operator|=
name|d
operator|->
name|bottommargin
expr_stmt|;
block|}
comment|/*!   \since 4.6    \brief The contentsMargins function returns the widget's contents margins.    \sa getContentsMargins(), setContentsMargins(), contentsRect()  */
DECL|function|contentsMargins
name|QMargins
name|QWidget
operator|::
name|contentsMargins
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|QMargins
argument_list|(
name|d
operator|->
name|leftmargin
argument_list|,
name|d
operator|->
name|topmargin
argument_list|,
name|d
operator|->
name|rightmargin
argument_list|,
name|d
operator|->
name|bottommargin
argument_list|)
return|;
block|}
comment|/*!     Returns the area inside the widget's margins.      \sa setContentsMargins(), getContentsMargins() */
DECL|function|contentsRect
name|QRect
name|QWidget
operator|::
name|contentsRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|d
operator|->
name|leftmargin
argument_list|,
name|d
operator|->
name|topmargin
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|data
operator|->
name|crect
operator|.
name|width
argument_list|()
operator|-
literal|1
operator|-
name|d
operator|->
name|rightmargin
argument_list|,
name|data
operator|->
name|crect
operator|.
name|height
argument_list|()
operator|-
literal|1
operator|-
name|d
operator|->
name|bottommargin
argument_list|)
argument_list|)
return|;
block|}
comment|/*!   \fn void QWidget::customContextMenuRequested(const QPoint&pos)    This signal is emitted when the widget's \l contextMenuPolicy is   Qt::CustomContextMenu, and the user has requested a context menu on   the widget. The position \a pos is the position of the context menu   event that the widget receives. Normally this is in widget   coordinates. The exception to this rule is QAbstractScrollArea and   its subclasses that map the context menu event to coordinates of the   \l{QAbstractScrollArea::viewport()}{viewport()}.     \sa mapToGlobal(), QMenu, contextMenuPolicy */
comment|/*!     \property QWidget::contextMenuPolicy     \brief how the widget shows a context menu      The default value of this property is Qt::DefaultContextMenu,     which means the contextMenuEvent() handler is called. Other values     are Qt::NoContextMenu, Qt::PreventContextMenu,     Qt::ActionsContextMenu, and Qt::CustomContextMenu. With     Qt::CustomContextMenu, the signal customContextMenuRequested() is     emitted.      \sa contextMenuEvent(), customContextMenuRequested(), actions() */
DECL|function|contextMenuPolicy
name|Qt
operator|::
name|ContextMenuPolicy
name|QWidget
operator|::
name|contextMenuPolicy
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|Qt
operator|::
name|ContextMenuPolicy
operator|)
name|data
operator|->
name|context_menu_policy
return|;
block|}
DECL|function|setContextMenuPolicy
name|void
name|QWidget
operator|::
name|setContextMenuPolicy
parameter_list|(
name|Qt
operator|::
name|ContextMenuPolicy
name|policy
parameter_list|)
block|{
name|data
operator|->
name|context_menu_policy
operator|=
operator|(
name|uint
operator|)
name|policy
expr_stmt|;
block|}
comment|/*!     \property QWidget::focusPolicy     \brief the way the widget accepts keyboard focus      The policy is Qt::TabFocus if the widget accepts keyboard     focus by tabbing, Qt::ClickFocus if the widget accepts     focus by clicking, Qt::StrongFocus if it accepts both, and     Qt::NoFocus (the default) if it does not accept focus at     all.      You must enable keyboard focus for a widget if it processes     keyboard events. This is normally done from the widget's     constructor. For instance, the QLineEdit constructor calls     setFocusPolicy(Qt::StrongFocus).      If the widget has a focus proxy, then the focus policy will     be propagated to it.      \sa focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), enabled */
DECL|function|focusPolicy
name|Qt
operator|::
name|FocusPolicy
name|QWidget
operator|::
name|focusPolicy
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|Qt
operator|::
name|FocusPolicy
operator|)
name|data
operator|->
name|focus_policy
return|;
block|}
DECL|function|setFocusPolicy
name|void
name|QWidget
operator|::
name|setFocusPolicy
parameter_list|(
name|Qt
operator|::
name|FocusPolicy
name|policy
parameter_list|)
block|{
name|data
operator|->
name|focus_policy
operator|=
operator|(
name|uint
operator|)
name|policy
expr_stmt|;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
operator|&&
name|d
operator|->
name|extra
operator|->
name|focus_proxy
condition|)
name|d
operator|->
name|extra
operator|->
name|focus_proxy
operator|->
name|setFocusPolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::updatesEnabled     \brief whether updates are enabled      An updates enabled widget receives paint events and has a system     background; a disabled widget does not. This also implies that     calling update() and repaint() has no effect if updates are     disabled.      By default, this property is true.      setUpdatesEnabled() is normally used to disable updates for a     short period of time, for instance to avoid screen flicker during     large changes. In Qt, widgets normally do not generate screen     flicker, but on X11 the server might erase regions on the screen     when widgets get hidden before they can be replaced by other     widgets. Disabling updates solves this.      Example:     \snippet code/src_gui_kernel_qwidget.cpp 13      Disabling a widget implicitly disables all its children. Enabling a widget     enables all child widgets \e except top-level widgets or those that     have been explicitly disabled. Re-enabling updates implicitly calls     update() on the widget.      \sa paintEvent() */
DECL|function|setUpdatesEnabled
name|void
name|QWidget
operator|::
name|setUpdatesEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceUpdatesDisabled
argument_list|,
operator|!
name|enable
argument_list|)
expr_stmt|;
name|d
operator|->
name|setUpdatesEnabled_helper
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
comment|/*!     Shows the widget and its child widgets. This function is     equivalent to setVisible(true) in the normal case, and equivalent     to showFullScreen() if the QStyleHints::showIsFullScreen() hint     is true and the window is not a popup.      \sa raise(), showEvent(), hide(), setVisible(), showMinimized(), showMaximized(),     showNormal(), isVisible(), windowFlags() */
DECL|function|show
name|void
name|QWidget
operator|::
name|show
parameter_list|()
block|{
name|bool
name|isPopup
init|=
name|data
operator|->
name|window_flags
operator|&
name|Qt
operator|::
name|Popup
operator|&
operator|~
name|Qt
operator|::
name|Window
decl_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
name|isPopup
operator|&&
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|showIsFullScreen
argument_list|()
condition|)
name|showFullScreen
argument_list|()
expr_stmt|;
else|else
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*! \internal     Makes the widget visible in the isVisible() meaning of the word.    It is only called for toplevels or widgets with visible parents.  */
DECL|function|show_recursive
name|void
name|QWidgetPrivate
operator|::
name|show_recursive
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// polish if necessary
if|if
condition|(
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|createRecursively
argument_list|()
expr_stmt|;
name|q
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|&&
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|data
operator|->
name|in_show
condition|)
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
comment|// activate our layout before we and our children become visible
if|if
condition|(
name|layout
condition|)
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
name|show_helper
argument_list|()
expr_stmt|;
block|}
DECL|function|sendPendingMoveAndResizeEvents
name|void
name|QWidgetPrivate
operator|::
name|sendPendingMoveAndResizeEvents
parameter_list|(
name|bool
name|recursive
parameter_list|,
name|bool
name|disableUpdates
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|disableUpdates
operator|=
name|disableUpdates
operator|&&
name|q
operator|->
name|updatesEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|disableUpdates
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UpdatesDisabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingMoveEvent
argument_list|)
condition|)
block|{
name|QMoveEvent
name|e
argument_list|(
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|data
operator|.
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingMoveEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
condition|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|data
operator|.
name|crect
operator|.
name|size
argument_list|()
argument_list|,
name|QSize
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disableUpdates
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_UpdatesDisabled
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recursive
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|sendPendingMoveAndResizeEvents
argument_list|(
name|recursive
argument_list|,
name|disableUpdates
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|activateChildLayoutsRecursively
name|void
name|QWidgetPrivate
operator|::
name|activateChildLayoutsRecursively
parameter_list|()
block|{
name|sendPendingMoveAndResizeEvents
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|isHidden
argument_list|()
operator|||
name|child
operator|->
name|isWindow
argument_list|()
condition|)
continue|continue;
name|child
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
comment|// Activate child's layout
name|QWidgetPrivate
modifier|*
name|childPrivate
init|=
name|child
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|childPrivate
operator|->
name|layout
condition|)
name|childPrivate
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
comment|// Pretend we're visible.
specifier|const
name|bool
name|wasVisible
init|=
name|child
operator|->
name|isVisible
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasVisible
condition|)
name|child
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|)
expr_stmt|;
comment|// Do the same for all my children.
name|childPrivate
operator|->
name|activateChildLayoutsRecursively
argument_list|()
expr_stmt|;
comment|// We're not cheating anymore.
if|if
condition|(
operator|!
name|wasVisible
condition|)
name|child
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|show_helper
name|void
name|QWidgetPrivate
operator|::
name|show_helper
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|data
operator|.
name|in_show
operator|=
literal|true
expr_stmt|;
comment|// qws optimization
comment|// make sure we receive pending move and resize events
name|sendPendingMoveAndResizeEvents
argument_list|()
expr_stmt|;
comment|// become visible before showing all children
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|)
expr_stmt|;
comment|// finally show all children recursively
name|showChildren
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// popup handling: new popups and tools need to be raised, and
comment|// existing popups must be closed. Also propagate the current
comment|// windows's KeyboardFocusChange status.
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Tool
operator|)
operator|||
operator|(
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|||
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|ToolTip
condition|)
block|{
name|q
operator|->
name|raise
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|window
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|->
name|close
argument_list|()
condition|)
break|break;
block|}
block|}
block|}
comment|// Automatic embedding of child windows of widgets already embedded into
comment|// QGraphicsProxyWidget when they are shown the first time.
name|bool
name|isEmbedded
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|isEmbedded
operator|=
name|q
operator|->
name|graphicsProxyWidget
argument_list|()
condition|?
literal|true
else|:
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|isEmbedded
operator|&&
operator|!
name|bypassGraphicsProxyWidget
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|QGraphicsProxyWidget
modifier|*
name|ancestorProxy
init|=
name|nearestGraphicsProxyWidget
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ancestorProxy
condition|)
block|{
name|isEmbedded
operator|=
literal|true
expr_stmt|;
name|ancestorProxy
operator|->
name|d_func
argument_list|()
operator|->
name|embedSubWindow
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|isEmbedded
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// On Windows, show the popup now so that our own focus handling
comment|// stores the correct old focus widget even if it's stolen in the
comment|// showevent
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
operator|!
name|isEmbedded
operator|&&
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|openPopup
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// send the show event before showing the window
name|QShowEvent
name|showEvent
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|showEvent
argument_list|)
expr_stmt|;
name|show_sys
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isEmbedded
operator|&&
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|openPopup
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|q
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|ToolTip
condition|)
block|{
comment|// Tooltips are read aloud twice in MS narrator.
name|QAccessibleEvent
name|event
argument_list|(
name|q
argument_list|,
name|QAccessible
operator|::
name|ObjectShow
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
operator|==
name|q
condition|)
block|{
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
block|}
comment|// Process events when showing a Qt::SplashScreen widget before the event loop
comment|// is spinnning; otherwise it might not show up on particular platforms.
comment|// This makes QSplashScreen behave the same on all platforms.
if|if
condition|(
operator|!
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|&&
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|SplashScreen
condition|)
name|QApplication
operator|::
name|processEvents
argument_list|()
expr_stmt|;
name|data
operator|.
name|in_show
operator|=
literal|false
expr_stmt|;
comment|// reset qws optimization
block|}
comment|/*!     Hides the widget. This function is equivalent to     setVisible(false).       \note If you are working with QDialog or its subclasses and you invoke     the show() function after this function, the dialog will be displayed in     its original position.      \sa hideEvent(), isHidden(), show(), setVisible(), isVisible(), close() */
DECL|function|hide
name|void
name|QWidget
operator|::
name|hide
parameter_list|()
block|{
name|setVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/*!\internal  */
DECL|function|hide_helper
name|void
name|QWidgetPrivate
operator|::
name|hide_helper
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|bool
name|isEmbedded
init|=
literal|false
decl_stmt|;
if|#
directive|if
operator|!
name|defined
name|QT_NO_GRAPHICSVIEW
name|isEmbedded
operator|=
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|bypassGraphicsProxyWidget
argument_list|(
name|q
argument_list|)
operator|&&
name|nearestGraphicsProxyWidget
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|isEmbedded
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isEmbedded
operator|&&
operator|(
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|closePopup
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
operator|(
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|&&
name|q
operator|->
name|parentWidget
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|isHidden
argument_list|()
operator|&&
name|q
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|q
operator|->
name|parentWidget
argument_list|()
operator|->
name|activateWindow
argument_list|()
expr_stmt|;
comment|// Activate parent
endif|#
directive|endif
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Mapped
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hide_sys
argument_list|()
expr_stmt|;
name|bool
name|wasVisible
init|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasVisible
condition|)
block|{
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|QHideEvent
name|hideEvent
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|hideEvent
argument_list|)
expr_stmt|;
name|hideChildren
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// next bit tries to move the focus if the focus widget is now
comment|// hidden.
if|if
condition|(
name|wasVisible
condition|)
block|{
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|sendSyntheticEnterLeave
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|fw
operator|&&
operator|!
name|fw
operator|->
name|isWindow
argument_list|()
condition|)
block|{
if|if
condition|(
name|fw
operator|==
name|q
condition|)
block|{
name|q
operator|->
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|fw
operator|=
name|fw
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|maybeBackingStore
argument_list|()
condition|)
name|bs
operator|->
name|removeDirtyWidget
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|wasVisible
condition|)
block|{
name|QAccessibleEvent
name|event
argument_list|(
name|q
argument_list|,
name|QAccessible
operator|::
name|ObjectHide
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*!     \fn bool QWidget::isHidden() const      Returns true if the widget is hidden, otherwise returns false.      A hidden widget will only become visible when show() is called on     it. It will not be automatically shown when the parent is shown.      To check visibility, use !isVisible() instead (notice the exclamation mark).      isHidden() implies !isVisible(), but a widget can be not visible     and not hidden at the same time. This is the case for widgets that are children of     widgets that are not visible.       Widgets are hidden if:     \list         \li they were created as independent windows,         \li they were created as children of visible widgets,         \li hide() or setVisible(false) was called.     \endlist */
DECL|function|setVisible
name|void
name|QWidget
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
if|if
condition|(
name|visible
condition|)
block|{
comment|// show
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// Designer uses a trick to make grabWidget work without showing
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
name|parentWidget
argument_list|()
operator|&&
name|parentWidget
argument_list|()
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|parentWidget
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|parentWidget
argument_list|()
operator|->
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|createRecursively
argument_list|()
expr_stmt|;
comment|//we have to at least create toplevels before applyX11SpecificCommandLineArguments
comment|//but not children of non-visible parents
name|QWidget
modifier|*
name|pw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
operator|(
name|isWindow
argument_list|()
operator|||
name|pw
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|)
condition|)
block|{
name|create
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Window
condition|)
name|QApplicationPrivate
operator|::
name|applyX11SpecificCommandLineArguments
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|wasResized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|WindowStates
name|initialWindowState
init|=
name|windowState
argument_list|()
decl_stmt|;
comment|// polish if necessary
name|ensurePolished
argument_list|()
expr_stmt|;
comment|// remember that show was called explicitly
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
expr_stmt|;
comment|// whether we need to inform the parent widget immediately
name|bool
name|needUpdateGeometry
init|=
operator|!
name|isWindow
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
decl_stmt|;
comment|// we are no longer hidden
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|needUpdateGeometry
condition|)
name|d
operator|->
name|updateGeometry_helper
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// activate our layout before we and our children become visible
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|parent
init|=
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
name|parent
operator|->
name|isVisible
argument_list|()
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|&&
operator|!
name|parent
operator|->
name|data
operator|->
name|in_show
condition|)
block|{
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
name|parent
operator|=
name|parent
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parent
condition|)
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
block|}
comment|// adjust size if necessary
if|if
condition|(
operator|!
name|wasResized
operator|&&
operator|(
name|isWindow
argument_list|()
operator|||
operator|!
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|)
condition|)
block|{
if|if
condition|(
name|isWindow
argument_list|()
condition|)
block|{
name|adjustSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|windowState
argument_list|()
operator|!=
name|initialWindowState
condition|)
name|setWindowState
argument_list|(
name|initialWindowState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjustSize
argument_list|()
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|||
name|parentWidget
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|d
operator|->
name|show_helper
argument_list|()
expr_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|sendSyntheticEnterLeave
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|showToParentEvent
argument_list|(
name|QEvent
operator|::
name|ShowToParent
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|showToParentEvent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// hide
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
comment|// reset WS_DISABLED style in a Blocked window
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|QApplicationPrivate
operator|::
name|isBlockedByModal
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|LONG
name|dwStyle
init|=
name|GetWindowLong
argument_list|(
name|winId
argument_list|()
argument_list|,
name|GWL_STYLE
argument_list|)
decl_stmt|;
name|dwStyle
operator|&=
operator|~
name|WS_DISABLED
expr_stmt|;
name|SetWindowLong
argument_list|(
name|winId
argument_list|()
argument_list|,
name|GWL_STYLE
argument_list|,
name|dwStyle
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
operator|==
name|this
condition|)
name|QApplicationPrivate
operator|::
name|hidden_focus_widget
operator|=
literal|0
expr_stmt|;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// hw: The test on getOpaqueRegion() needs to be more intelligent
comment|// currently it doesn't work if the widget is hidden (the region will
comment|// be clipped). The real check should be testing the cached region
comment|// (and dirty flag) directly.
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
name|parentWidget
argument_list|()
condition|)
comment|//&& !d->getOpaqueRegion().isEmpty())
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|hide_helper
argument_list|()
expr_stmt|;
comment|// invalidate layout similar to updateGeometry()
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parentWidget
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
name|QApplication
operator|::
name|postEvent
argument_list|(
name|parentWidget
argument_list|()
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|hideToParentEvent
argument_list|(
name|QEvent
operator|::
name|HideToParent
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|hideToParentEvent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     Convenience function, equivalent to setVisible(!\a hidden). */
DECL|function|setHidden
name|void
name|QWidget
operator|::
name|setHidden
parameter_list|(
name|bool
name|hidden
parameter_list|)
block|{
name|setVisible
argument_list|(
operator|!
name|hidden
argument_list|)
expr_stmt|;
block|}
DECL|function|_q_showIfNotHidden
name|void
name|QWidgetPrivate
operator|::
name|_q_showIfNotHidden
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|->
name|isHidden
argument_list|()
operator|&&
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|)
condition|)
name|q
operator|->
name|setVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|function|showChildren
name|void
name|QWidgetPrivate
operator|::
name|showChildren
parameter_list|(
name|bool
name|spontaneous
parameter_list|)
block|{
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|childList
init|=
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widget
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
operator|||
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|spontaneous
condition|)
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Mapped
argument_list|)
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|showChildren
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QShowEvent
name|e
decl_stmt|;
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
condition|)
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|show_recursive
argument_list|()
expr_stmt|;
else|else
name|widget
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|function|hideChildren
name|void
name|QWidgetPrivate
operator|::
name|hideChildren
parameter_list|(
name|bool
name|spontaneous
parameter_list|)
block|{
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|childList
init|=
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widget
operator|||
name|widget
operator|->
name|isWindow
argument_list|()
operator|||
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// Before doing anything we need to make sure that we don't leave anything in a non-consistent state.
comment|// When hiding a widget we need to make sure that no mouse_down events are active, because
comment|// the mouse_up event will never be received by a hidden widget or one of its descendants.
comment|// The solution is simple, before going through with this we check if there are any mouse_down events in
comment|// progress, if so we check if it is related to this widget or not. If so, we just reset the mouse_down and
comment|// then we continue.
comment|// In X11 and Windows we send a mouse_release event, however we don't do that here because we were already
comment|// ignoring that from before. I.e. Carbon did not send the mouse release event, so we will not send the
comment|// mouse release event. There are two ways to interpret this:
comment|// 1. If we don't send the mouse release event, the widget might get into an inconsistent state, i.e. it
comment|// might be waiting for a release event that will never arrive.
comment|// 2. If we send the mouse release event, then the widget might decide to trigger an action that is not
comment|// supposed to trigger because it is not visible.
if|if
condition|(
name|widget
operator|==
name|qt_button_down
condition|)
name|qt_button_down
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// Q_WS_MAC
if|if
condition|(
name|spontaneous
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Mapped
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Visible
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|hideChildren
argument_list|(
name|spontaneous
argument_list|)
expr_stmt|;
name|QHideEvent
name|e
decl_stmt|;
if|if
condition|(
name|spontaneous
condition|)
block|{
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|widget
operator|->
name|internalWinId
argument_list|()
operator|&&
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
condition|)
block|{
comment|// hide_sys() on an ancestor won't have any affect on this
comment|// widget, so it needs an explicit hide_sys() of its own
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|hide_sys
argument_list|()
expr_stmt|;
block|}
block|}
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|sendSyntheticEnterLeave
argument_list|(
name|widget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
operator|!
name|spontaneous
condition|)
block|{
name|QAccessibleEvent
name|event
argument_list|(
name|widget
argument_list|,
name|QAccessible
operator|::
name|ObjectHide
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
DECL|function|close_helper
name|bool
name|QWidgetPrivate
operator|::
name|close_helper
parameter_list|(
name|CloseMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|is_closing
condition|)
return|return
literal|true
return|;
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|data
operator|.
name|is_closing
operator|=
literal|1
expr_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|that
init|=
name|q
decl_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|parentWidget
init|=
name|q
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
name|bool
name|quitOnClose
init|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_QuitOnClose
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|CloseNoEvent
condition|)
block|{
name|QCloseEvent
name|e
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CloseWithSpontaneousEvent
condition|)
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|that
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|e
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|data
operator|.
name|is_closing
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|that
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|isHidden
argument_list|()
condition|)
name|q
operator|->
name|hide
argument_list|()
expr_stmt|;
comment|// Attempt to close the application only if this has WA_QuitOnClose set and a non-visible parent
name|quitOnClose
operator|=
name|quitOnClose
operator|&&
operator|(
name|parentWidget
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|parentWidget
operator|->
name|isVisible
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|quitOnClose
condition|)
block|{
comment|/* if there is no non-withdrawn primary window left (except            the ones without QuitOnClose), we emit the lastWindowClosed            signal */
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
name|bool
name|lastWindowClosed
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|isVisible
argument_list|()
operator|||
name|w
operator|->
name|parentWidget
argument_list|()
operator|||
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_QuitOnClose
argument_list|)
condition|)
continue|continue;
name|lastWindowClosed
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lastWindowClosed
condition|)
block|{
name|QGuiApplicationPrivate
operator|::
name|emitLastWindowClosed
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
modifier|*
name|applicationPrivate
init|=
cast|static_cast
argument_list|<
name|QCoreApplicationPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|applicationPrivate
operator|->
name|maybeQuit
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|that
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|data
operator|.
name|is_closing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
condition|)
block|{
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/*!     Closes this widget. Returns true if the widget was closed;     otherwise returns false.      First it sends the widget a QCloseEvent. The widget is     \l{hide()}{hidden} if it \l{QCloseEvent::accept()}{accepts}     the close event. If it \l{QCloseEvent::ignore()}{ignores}     the event, nothing happens. The default     implementation of QWidget::closeEvent() accepts the close event.      If the widget has the Qt::WA_DeleteOnClose flag, the widget     is also deleted. A close events is delivered to the widget no     matter if the widget is visible or not.      The \l QApplication::lastWindowClosed() signal is emitted when the     last visible primary window (i.e. window with no parent) with the     Qt::WA_QuitOnClose attribute set is closed. By default this     attribute is set for all widgets except transient windows such as     splash screens, tool windows, and popup menus.  */
DECL|function|close
name|bool
name|QWidget
operator|::
name|close
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|close_helper
argument_list|(
name|QWidgetPrivate
operator|::
name|CloseWithEvent
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::visible     \brief whether the widget is visible      Calling setVisible(true) or show() sets the widget to visible     status if all its parent widgets up to the window are visible. If     an ancestor is not visible, the widget won't become visible until     all its ancestors are shown. If its size or position has changed,     Qt guarantees that a widget gets move and resize events just     before it is shown. If the widget has not been resized yet, Qt     will adjust the widget's size to a useful default using     adjustSize().      Calling setVisible(false) or hide() hides a widget explicitly. An     explicitly hidden widget will never become visible, even if all     its ancestors become visible, unless you show it.      A widget receives show and hide events when its visibility status     changes. Between a hide and a show event, there is no need to     waste CPU cycles preparing or displaying information to the user.     A video application, for example, might simply stop generating new     frames.      A widget that happens to be obscured by other windows on the     screen is considered to be visible. The same applies to iconified     windows and windows that exist on another virtual     desktop (on platforms that support this concept). A widget     receives spontaneous show and hide events when its mapping status     is changed by the window system, e.g. a spontaneous hide event     when the user minimizes the window, and a spontaneous show event     when the window is restored again.      You almost never have to reimplement the setVisible() function. If     you need to change some settings before a widget is shown, use     showEvent() instead. If you need to do some delayed initialization     use the Polish event delivered to the event() function.      \sa show(), hide(), isHidden(), isVisibleTo(), isMinimized(),     showEvent(), hideEvent() */
comment|/*!     Returns true if this widget would become visible if \a ancestor is     shown; otherwise returns false.      The true case occurs if neither the widget itself nor any parent     up to but excluding \a ancestor has been explicitly hidden.      This function will still return true if the widget is obscured by     other windows on the screen, but could be physically visible if it     or they were to be moved.      isVisibleTo(0) is identical to isVisible().      \sa show(), hide(), isVisible() */
DECL|function|isVisibleTo
name|bool
name|QWidget
operator|::
name|isVisibleTo
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|ancestor
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|ancestor
condition|)
return|return
name|isVisible
argument_list|()
return|;
specifier|const
name|QWidget
modifier|*
name|w
init|=
name|this
decl_stmt|;
while|while
condition|(
operator|!
name|w
operator|->
name|isHidden
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
operator|&&
name|w
operator|->
name|parentWidget
argument_list|()
operator|!=
name|ancestor
condition|)
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
return|return
operator|!
name|w
operator|->
name|isHidden
argument_list|()
return|;
block|}
comment|/*!     Returns the unobscured region where paint events can occur.      For visible widgets, this is an approximation of the area not     covered by other widgets; otherwise, this is an empty region.      The repaint() function calls this function if necessary, so in     general you do not need to call it.  */
DECL|function|visibleRegion
name|QRegion
name|QWidget
operator|::
name|visibleRegion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QRect
name|clipRect
init|=
name|d
operator|->
name|clipRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|QRegion
name|r
argument_list|(
name|clipRect
argument_list|)
decl_stmt|;
name|d
operator|->
name|subtractOpaqueChildren
argument_list|(
name|r
argument_list|,
name|clipRect
argument_list|)
expr_stmt|;
name|d
operator|->
name|subtractOpaqueSiblings
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
DECL|function|adjustedSize
name|QSize
name|QWidgetPrivate
operator|::
name|adjustedSize
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QSize
name|s
init|=
name|q
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|Qt
operator|::
name|Orientations
name|exp
decl_stmt|;
if|if
condition|(
name|layout
condition|)
block|{
if|if
condition|(
name|layout
operator|->
name|hasHeightForWidth
argument_list|()
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|layout
operator|->
name|totalHeightForWidth
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|layout
operator|->
name|expandingDirections
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|sizePolicy
argument_list|()
operator|.
name|hasHeightForWidth
argument_list|()
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|q
operator|->
name|heightForWidth
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|q
operator|->
name|sizePolicy
argument_list|()
operator|.
name|expandingDirections
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|&
name|Qt
operator|::
name|Horizontal
condition|)
name|s
operator|.
name|setWidth
argument_list|(
name|qMax
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
literal|200
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|&
name|Qt
operator|::
name|Vertical
condition|)
name|s
operator|.
name|setHeight
argument_list|(
name|qMax
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|QRect
name|screen
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
decl_stmt|;
else|#
directive|else
comment|// all others
name|QRect
name|screen
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|(
name|q
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|s
operator|.
name|setWidth
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|screen
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|screen
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|.
name|setWidth
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|screen
operator|.
name|width
argument_list|()
operator|*
literal|2
operator|/
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|screen
operator|.
name|height
argument_list|()
operator|*
literal|2
operator|/
literal|3
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QTLWExtra
modifier|*
name|extra
init|=
name|maybeTopData
argument_list|()
condition|)
name|extra
operator|->
name|sizeAdjusted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QRect
name|r
init|=
name|q
operator|->
name|childrenRect
argument_list|()
decl_stmt|;
comment|// get children rectangle
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|s
return|;
name|s
operator|=
name|r
operator|.
name|size
argument_list|()
operator|+
name|QSize
argument_list|(
literal|2
operator|*
name|r
operator|.
name|x
argument_list|()
argument_list|,
literal|2
operator|*
name|r
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/*!     Adjusts the size of the widget to fit its contents.      This function uses sizeHint() if it is valid, i.e., the size hint's width     and height are \>= 0. Otherwise, it sets the size to the children     rectangle that covers all child widgets (the union of all child widget     rectangles).      For windows, the screen size is also taken into account. If the sizeHint()     is less than (200, 100) and the size policy is \l{QSizePolicy::Expanding}     {expanding}, the window will be at least (200, 100). The maximum size of     a window is 2/3 of the screen's width and height.      \sa sizeHint(), childrenRect() */
DECL|function|adjustSize
name|void
name|QWidget
operator|::
name|adjustSize
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QSize
name|s
init|=
name|d
operator|->
name|adjustedSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|isValid
argument_list|()
condition|)
name|resize
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*!     \property QWidget::sizeHint     \brief the recommended size for the widget      If the value of this property is an invalid size, no size is     recommended.      The default implementation of sizeHint() returns an invalid size     if there is no layout for this widget, and returns the layout's     preferred size otherwise.      \sa QSize::isValid(), minimumSizeHint(), sizePolicy(),     setMinimumSize(), updateGeometry() */
DECL|function|sizeHint
name|QSize
name|QWidget
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
return|return
name|d
operator|->
name|layout
operator|->
name|totalSizeHint
argument_list|()
return|;
return|return
name|QSize
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/*!     \property QWidget::minimumSizeHint     \brief the recommended minimum size for the widget      If the value of this property is an invalid size, no minimum size     is recommended.      The default implementation of minimumSizeHint() returns an invalid     size if there is no layout for this widget, and returns the     layout's minimum size otherwise. Most built-in widgets reimplement     minimumSizeHint().      \l QLayout will never resize a widget to a size smaller than the     minimum size hint unless minimumSize() is set or the size policy is     set to QSizePolicy::Ignore. If minimumSize() is set, the minimum     size hint will be ignored.      \sa QSize::isValid(), resize(), setMinimumSize(), sizePolicy() */
DECL|function|minimumSizeHint
name|QSize
name|QWidget
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
return|return
name|d
operator|->
name|layout
operator|->
name|totalMinimumSize
argument_list|()
return|;
return|return
name|QSize
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/*!     \fn QWidget *QWidget::parentWidget() const      Returns the parent of this widget, or 0 if it does not have any     parent widget. */
comment|/*!     Returns true if this widget is a parent, (or grandparent and so on     to any level), of the given \a child, and both widgets are within     the same window; otherwise returns false. */
DECL|function|isAncestorOf
name|bool
name|QWidget
operator|::
name|isAncestorOf
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|child
parameter_list|)
specifier|const
block|{
while|while
condition|(
name|child
condition|)
block|{
if|if
condition|(
name|child
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|child
operator|->
name|isWindow
argument_list|()
condition|)
return|return
literal|false
return|;
name|child
operator|=
name|child
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
DECL|function|setDisabledStyle
specifier|inline
name|void
name|setDisabledStyle
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|,
name|bool
name|setStyle
parameter_list|)
block|{
comment|// set/reset WS_DISABLED style.
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
name|w
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|LONG
name|dwStyle
init|=
name|GetWindowLong
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|GWL_STYLE
argument_list|)
decl_stmt|;
name|LONG
name|newStyle
init|=
name|dwStyle
decl_stmt|;
if|if
condition|(
name|setStyle
condition|)
name|newStyle
operator||=
name|WS_DISABLED
expr_stmt|;
else|else
name|newStyle
operator|&=
operator|~
name|WS_DISABLED
expr_stmt|;
if|if
condition|(
name|newStyle
operator|!=
name|dwStyle
condition|)
block|{
name|SetWindowLong
argument_list|(
name|w
operator|->
name|winId
argument_list|()
argument_list|,
name|GWL_STYLE
argument_list|,
name|newStyle
argument_list|)
expr_stmt|;
comment|// we might need to repaint in some situations (eg. menu)
name|w
operator|->
name|repaint
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*****************************************************************************   QWidget event handling  *****************************************************************************/
comment|/*!     This is the main event handler; it handles event \a event. You can     reimplement this function in a subclass, but we recommend using     one of the specialized event handlers instead.      Key press and release events are treated differently from other     events. event() checks for Tab and Shift+Tab and tries to move the     focus appropriately. If there is no widget to move the focus to     (or the key press is not Tab or Shift+Tab), event() calls     keyPressEvent().      Mouse and tablet event handling is also slightly special: only     when the widget is \l enabled, event() will call the specialized     handlers such as mousePressEvent(); otherwise it will discard the     event.      This function returns true if the event was recognized, otherwise     it returns false.  If the recognized event was accepted (see \l     QEvent::accepted), any further processing such as event     propagation to the parent widget stops.      \sa closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(),     keyPressEvent(), keyReleaseEvent(), leaveEvent(),     mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(),     mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(),     QObject::event(), QObject::timerEvent() */
DECL|function|event
name|bool
name|QWidget
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// ignore mouse and key events when disabled
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
case|case
name|QEvent
operator|::
name|TouchCancel
case|:
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
endif|#
directive|endif
return|return
literal|false
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseMove
case|:
name|mouseMoveEvent
argument_list|(
operator|(
name|QMouseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
name|mousePressEvent
argument_list|(
operator|(
name|QMouseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
name|mouseReleaseEvent
argument_list|(
operator|(
name|QMouseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
name|mouseDoubleClickEvent
argument_list|(
operator|(
name|QMouseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
name|wheelEvent
argument_list|(
operator|(
name|QWheelEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
name|tabletEvent
argument_list|(
operator|(
name|QTabletEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|KeyPress
case|:
block|{
name|QKeyEvent
modifier|*
name|k
init|=
operator|(
name|QKeyEvent
operator|*
operator|)
name|event
decl_stmt|;
name|bool
name|res
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator|)
operator|)
condition|)
block|{
comment|//### Add MetaModifier?
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
operator|||
operator|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|&&
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|)
condition|)
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
condition|)
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
break|break;
block|}
name|keyPressEvent
argument_list|(
name|k
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|!
name|k
operator|->
name|isAccepted
argument_list|()
operator|&&
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator||
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
condition|)
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
condition|)
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadDirectional
condition|)
block|{
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
condition|)
name|res
operator|=
name|QWidgetPrivate
operator|::
name|navigateToDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionNorth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Right
condition|)
name|res
operator|=
name|QWidgetPrivate
operator|::
name|navigateToDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionEast
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
condition|)
name|res
operator|=
name|QWidgetPrivate
operator|::
name|navigateToDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionSouth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Left
condition|)
name|res
operator|=
name|QWidgetPrivate
operator|::
name|navigateToDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionWest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
block|{
name|k
operator|->
name|accept
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_WHATSTHIS
if|if
condition|(
operator|!
name|k
operator|->
name|isAccepted
argument_list|()
operator|&&
name|k
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
operator|&&
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_F1
operator|&&
name|d
operator|->
name|whatsThis
operator|.
name|size
argument_list|()
condition|)
block|{
name|QWhatsThis
operator|::
name|showText
argument_list|(
name|mapToGlobal
argument_list|(
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorRectangle
argument_list|)
operator|.
name|toRect
argument_list|()
operator|.
name|center
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|whatsThis
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|k
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|keyReleaseEvent
argument_list|(
operator|(
name|QKeyEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
comment|// fall through
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
break|break;
case|case
name|QEvent
operator|::
name|InputMethod
case|:
name|inputMethodEvent
argument_list|(
operator|(
name|QInputMethodEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|InputMethodQuery
case|:
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
block|{
name|QInputMethodQueryEvent
modifier|*
name|query
init|=
cast|static_cast
argument_list|<
name|QInputMethodQueryEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|InputMethodQueries
name|queries
init|=
name|query
operator|->
name|queries
argument_list|()
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|Qt
operator|::
name|InputMethodQuery
name|q
init|=
call|(
name|Qt
operator|::
name|InputMethodQuery
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|queries
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|QVariant
name|v
init|=
name|inputMethodQuery
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|Qt
operator|::
name|ImEnabled
operator|&&
operator|!
name|v
operator|.
name|isValid
argument_list|()
operator|&&
name|isEnabled
argument_list|()
condition|)
name|v
operator|=
name|QVariant
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// special case for Qt4 compatibility
name|query
operator|->
name|setValue
argument_list|(
name|q
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|PolishRequest
case|:
name|ensurePolished
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Polish
case|:
block|{
name|style
argument_list|()
operator|->
name|polish
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|font
argument_list|(
name|this
argument_list|)
operator|.
name|isCopyOf
argument_list|(
name|QApplication
operator|::
name|font
argument_list|()
argument_list|)
condition|)
name|d
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QApplication
operator|::
name|palette
argument_list|(
name|this
argument_list|)
operator|.
name|isCopyOf
argument_list|(
name|QApplication
operator|::
name|palette
argument_list|()
argument_list|)
condition|)
name|d
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|ApplicationWindowIconChange
case|:
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetWindowIcon
argument_list|)
condition|)
block|{
name|d
operator|->
name|setWindowIcon_sys
argument_list|()
expr_stmt|;
name|d
operator|->
name|setWindowIcon_helper
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|FocusIn
case|:
name|focusInEvent
argument_list|(
operator|(
name|QFocusEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateWidgetTransform
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusOut
case|:
name|focusOutEvent
argument_list|(
operator|(
name|QFocusEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Enter
case|:
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
if|if
condition|(
name|d
operator|->
name|statusTip
operator|.
name|size
argument_list|()
condition|)
block|{
name|QStatusTipEvent
name|tip
argument_list|(
name|d
operator|->
name|statusTip
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|enterEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Leave
case|:
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
if|if
condition|(
name|d
operator|->
name|statusTip
operator|.
name|size
argument_list|()
condition|)
block|{
name|QString
name|empty
decl_stmt|;
name|QStatusTipEvent
name|tip
argument_list|(
name|empty
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|leaveEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Paint
case|:
comment|// At this point the event has to be delivered, regardless
comment|// whether the widget isVisible() or not because it
comment|// already went through the filters
name|paintEvent
argument_list|(
operator|(
name|QPaintEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Move
case|:
name|moveEvent
argument_list|(
operator|(
name|QMoveEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateWidgetTransform
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Resize
case|:
name|resizeEvent
argument_list|(
operator|(
name|QResizeEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateWidgetTransform
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Close
case|:
name|closeEvent
argument_list|(
operator|(
name|QCloseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
switch|switch
condition|(
name|data
operator|->
name|context_menu_policy
condition|)
block|{
case|case
name|Qt
operator|::
name|PreventContextMenu
case|:
break|break;
case|case
name|Qt
operator|::
name|DefaultContextMenu
case|:
name|contextMenuEvent
argument_list|(
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|CustomContextMenu
case|:
emit|emit
name|customContextMenuRequested
argument_list|(
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|pos
argument_list|()
argument_list|)
emit|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_MENU
case|case
name|Qt
operator|::
name|ActionsContextMenu
case|:
if|if
condition|(
name|d
operator|->
name|actions
operator|.
name|count
argument_list|()
condition|)
block|{
name|QMenu
operator|::
name|exec
argument_list|(
name|d
operator|->
name|actions
argument_list|,
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|globalPos
argument_list|()
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// fall through
endif|#
directive|endif
default|default:
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|QEvent
operator|::
name|Drop
case|:
name|dropEvent
argument_list|(
operator|(
name|QDropEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|DragEnter
case|:
name|dragEnterEvent
argument_list|(
operator|(
name|QDragEnterEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|DragMove
case|:
name|dragMoveEvent
argument_list|(
operator|(
name|QDragMoveEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|DragLeave
case|:
name|dragLeaveEvent
argument_list|(
operator|(
name|QDragLeaveEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|Show
case|:
name|showEvent
argument_list|(
operator|(
name|QShowEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
name|hideEvent
argument_list|(
operator|(
name|QHideEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ShowWindowRequest
case|:
if|if
condition|(
operator|!
name|isHidden
argument_list|()
condition|)
name|d
operator|->
name|show_sys
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ApplicationFontChange
case|:
name|d
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ApplicationPaletteChange
case|:
if|if
condition|(
operator|!
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
name|d
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ToolBarChange
case|:
case|case
name|QEvent
operator|::
name|ActivationChange
case|:
case|case
name|QEvent
operator|::
name|EnabledChange
case|:
case|case
name|QEvent
operator|::
name|FontChange
case|:
case|case
name|QEvent
operator|::
name|StyleChange
case|:
case|case
name|QEvent
operator|::
name|PaletteChange
case|:
case|case
name|QEvent
operator|::
name|WindowTitleChange
case|:
case|case
name|QEvent
operator|::
name|IconTextChange
case|:
case|case
name|QEvent
operator|::
name|ModifiedChange
case|:
case|case
name|QEvent
operator|::
name|MouseTrackingChange
case|:
case|case
name|QEvent
operator|::
name|ParentChange
case|:
case|case
name|QEvent
operator|::
name|WindowStateChange
case|:
case|case
name|QEvent
operator|::
name|LocaleChange
case|:
case|case
name|QEvent
operator|::
name|MacSizeChange
case|:
case|case
name|QEvent
operator|::
name|ContentsRectChange
case|:
case|case
name|QEvent
operator|::
name|ThemeChange
case|:
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
block|{
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
operator|!
name|palette
argument_list|()
operator|.
name|isEqual
argument_list|(
name|QPalette
operator|::
name|Active
argument_list|,
name|QPalette
operator|::
name|Inactive
argument_list|)
condition|)
name|update
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|childList
init|=
name|d
operator|->
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|LanguageChange
case|:
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|{
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|childList
init|=
name|d
operator|->
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|o
init|=
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|o
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
block|}
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
case|:
name|d
operator|->
name|resolveLayoutDirection
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|UpdateRequest
case|:
name|d
operator|->
name|syncBackingStore
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|UpdateLater
case|:
name|update
argument_list|(
cast|static_cast
argument_list|<
name|QUpdateLaterEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|region
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleAnimationUpdate
case|:
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowBlocked
case|:
case|case
name|QEvent
operator|::
name|WindowUnblocked
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|modalWidget
init|=
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|o
init|=
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|!=
name|modalWidget
operator|&&
name|o
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// do not forward the event to child windows; QApplication does this for us
if|if
condition|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|setDisabledStyle
argument_list|(
name|this
argument_list|,
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|WindowBlocked
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifndef|#
directive|ifndef
name|QT_NO_TOOLTIP
case|case
name|QEvent
operator|::
name|ToolTip
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|toolTip
operator|.
name|isEmpty
argument_list|()
condition|)
name|QToolTip
operator|::
name|showText
argument_list|(
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|globalPos
argument_list|()
argument_list|,
name|d
operator|->
name|toolTip
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_WHATSTHIS
case|case
name|QEvent
operator|::
name|WhatsThis
case|:
if|if
condition|(
name|d
operator|->
name|whatsThis
operator|.
name|size
argument_list|()
condition|)
name|QWhatsThis
operator|::
name|showText
argument_list|(
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|globalPos
argument_list|()
argument_list|,
name|d
operator|->
name|whatsThis
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|QueryWhatsThis
case|:
if|if
condition|(
name|d
operator|->
name|whatsThis
operator|.
name|isEmpty
argument_list|()
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|EmbeddingControl
case|:
name|d
operator|->
name|topData
argument_list|()
operator|->
name|frameStrut
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|fstrut_dirty
operator|=
literal|false
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|embedded
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
ifndef|#
directive|ifndef
name|QT_NO_ACTION
case|case
name|QEvent
operator|::
name|ActionAdded
case|:
case|case
name|QEvent
operator|::
name|ActionRemoved
case|:
case|case
name|QEvent
operator|::
name|ActionChanged
case|:
name|actionEvent
argument_list|(
operator|(
name|QActionEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|KeyboardLayoutChange
case|:
block|{
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// inform children of the change
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|childList
init|=
name|d
operator|->
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
case|case
name|QEvent
operator|::
name|MacGLWindowChange
case|:
name|d
operator|->
name|needWindowChange
operator|=
literal|false
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
case|case
name|QEvent
operator|::
name|TouchCancel
case|:
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|Gesture
case|:
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
case|case
name|QEvent
operator|::
name|DynamicPropertyChange
case|:
block|{
specifier|const
name|QByteArray
modifier|&
name|propName
init|=
cast|static_cast
argument_list|<
name|QDynamicPropertyChangeEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|propertyName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qstrncmp
argument_list|(
name|propName
argument_list|,
literal|"_q_customDpi"
argument_list|,
literal|12
argument_list|)
operator|&&
name|propName
operator|.
name|length
argument_list|()
operator|==
literal|13
condition|)
block|{
name|uint
name|value
init|=
name|property
argument_list|(
name|propName
operator|.
name|constData
argument_list|()
argument_list|)
operator|.
name|toUInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
condition|)
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
specifier|const
name|char
name|axis
init|=
name|propName
operator|.
name|at
argument_list|(
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|axis
operator|==
literal|'X'
condition|)
name|d
operator|->
name|extra
operator|->
name|customDpiX
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|axis
operator|==
literal|'Y'
condition|)
name|d
operator|->
name|extra
operator|->
name|customDpiY
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|updateFont
argument_list|(
name|d
operator|->
name|data
operator|.
name|fnt
argument_list|)
expr_stmt|;
block|}
comment|// fall through
block|}
endif|#
directive|endif
default|default:
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/*!   This event handler can be reimplemented to handle state changes.    The state being changed in this event can be retrieved through the \a event   supplied.    Change events include: QEvent::ToolBarChange,   QEvent::ActivationChange, QEvent::EnabledChange, QEvent::FontChange,   QEvent::StyleChange, QEvent::PaletteChange,   QEvent::WindowTitleChange, QEvent::IconTextChange,   QEvent::ModifiedChange, QEvent::MouseTrackingChange,   QEvent::ParentChange, QEvent::WindowStateChange,   QEvent::LanguageChange, QEvent::LocaleChange,   QEvent::LayoutDirectionChange.  */
DECL|function|changeEvent
name|void
name|QWidget
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|EnabledChange
case|:
block|{
name|update
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|State
name|s
decl_stmt|;
name|s
operator|.
name|disabled
operator|=
literal|true
expr_stmt|;
name|QAccessibleStateChangeEvent
name|event
argument_list|(
name|this
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|QEvent
operator|::
name|FontChange
case|:
case|case
name|QEvent
operator|::
name|StyleChange
case|:
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|PaletteChange
case|:
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ThemeChange
case|:
if|if
condition|(
name|QApplication
operator|::
name|desktopSettingsAware
argument_list|()
operator|&&
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
name|qApp
operator|&&
operator|!
name|QApplication
operator|::
name|closingDown
argument_list|()
condition|)
block|{
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
name|QApplication
operator|::
name|style
argument_list|()
operator|->
name|unpolish
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Polished
argument_list|)
condition|)
name|QApplication
operator|::
name|style
argument_list|()
operator|->
name|polish
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QEvent
name|styleChangedEvent
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|styleChangedEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|Q_OS_MAC
case|case
name|QEvent
operator|::
name|MacSizeChange
case|:
name|updateGeometry
argument_list|()
expr_stmt|;
break|break;
elif|#
directive|elif
name|defined
name|Q_WS_MAC
case|case
name|QEvent
operator|::
name|ToolTipChange
case|:
case|case
name|QEvent
operator|::
name|MouseTrackingChange
case|:
name|qt_mac_update_mouseTracking
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive mouse move events for the widget.      If mouse tracking is switched off, mouse move events only occur if     a mouse button is pressed while the mouse is being moved. If mouse     tracking is switched on, mouse move events occur even if no mouse     button is pressed.      QMouseEvent::pos() reports the position of the mouse cursor,     relative to this widget. For press and release events, the     position is usually the same as the position of the last mouse     move event, but it might be different if the user's hand shakes.     This is a feature of the underlying window system, not Qt.      If you want to show a tooltip immediately, while the mouse is     moving (e.g., to get the mouse coordinates with QMouseEvent::pos()     and show them as a tooltip), you must first enable mouse tracking     as described above. Then, to ensure that the tooltip is updated     immediately, you must call QToolTip::showText() instead of     setToolTip() in your implementation of mouseMoveEvent().      \sa setMouseTracking(), mousePressEvent(), mouseReleaseEvent(),     mouseDoubleClickEvent(), event(), QMouseEvent, {Scribble Example} */
DECL|function|mouseMoveEvent
name|void
name|QWidget
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive mouse press events for the widget.      If you create new widgets in the mousePressEvent() the     mouseReleaseEvent() may not end up where you expect, depending on     the underlying window system (or X11 window manager), the widgets'     location and maybe more.      The default implementation implements the closing of popup widgets     when you click outside the window. For other widget types it does     nothing.      \sa mouseReleaseEvent(), mouseDoubleClickEvent(),     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example} */
DECL|function|mousePressEvent
name|void
name|QWidget
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|QWidget
modifier|*
name|w
decl_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|)
operator|&&
name|w
operator|!=
name|this
condition|)
block|{
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|==
name|w
condition|)
comment|// widget does not want to disappear
name|w
operator|->
name|hide
argument_list|()
expr_stmt|;
comment|// hide at least
block|}
if|if
condition|(
operator|!
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive mouse release events for the widget.      \sa mousePressEvent(), mouseDoubleClickEvent(),     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example} */
DECL|function|mouseReleaseEvent
name|void
name|QWidget
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive mouse double click events for the widget.      The default implementation generates a normal mouse press event.      \note The widget will also receive mouse press and mouse release     events in addition to the double click event. It is up to the     developer to ensure that the application interprets these events     correctly.      \sa mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(),     event(), QMouseEvent */
DECL|function|mouseDoubleClickEvent
name|void
name|QWidget
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive wheel events for the widget.      If you reimplement this handler, it is very important that you     \l{QWheelEvent}{ignore()} the event if you do not handle     it, so that the widget's parent can interpret it.      The default implementation ignores the event.      \sa QWheelEvent::ignore(), QWheelEvent::accept(), event(),     QWheelEvent */
DECL|function|wheelEvent
name|void
name|QWidget
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_WHEELEVENT
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive tablet events for the widget.      If you reimplement this handler, it is very important that you     \l{QTabletEvent}{ignore()} the event if you do not handle     it, so that the widget's parent can interpret it.      The default implementation ignores the event.      \sa QTabletEvent::ignore(), QTabletEvent::accept(), event(),     QTabletEvent */
DECL|function|tabletEvent
name|void
name|QWidget
operator|::
name|tabletEvent
parameter_list|(
name|QTabletEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive key press events for the widget.      A widget must call setFocusPolicy() to accept focus initially and     have focus in order to receive a key press event.      If you reimplement this handler, it is very important that you     call the base class implementation if you do not act upon the key.      The default implementation closes popup widgets if the user     presses Esc. Otherwise the event is ignored, so that the widget's     parent can interpret it.      Note that QKeyEvent starts with isAccepted() == true, so you do not     need to call QKeyEvent::accept() - just do not call the base class     implementation if you act upon the key.      \sa keyReleaseEvent(), setFocusPolicy(),     focusInEvent(), focusOutEvent(), event(), QKeyEvent, {Tetrix Example} */
DECL|function|keyPressEvent
name|void
name|QWidget
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|(
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
operator|)
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Escape
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive key release events for the widget.      A widget must \l{setFocusPolicy()}{accept focus}     initially and \l{hasFocus()}{have focus} in order to     receive a key release event.      If you reimplement this handler, it is very important that you     call the base class implementation if you do not act upon the key.      The default implementation ignores the event, so that the widget's     parent can interpret it.      Note that QKeyEvent starts with isAccepted() == true, so you do not     need to call QKeyEvent::accept() - just do not call the base class     implementation if you act upon the key.      \sa keyPressEvent(), QKeyEvent::ignore(), setFocusPolicy(),     focusInEvent(), focusOutEvent(), event(), QKeyEvent */
DECL|function|keyReleaseEvent
name|void
name|QWidget
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::focusInEvent(QFocusEvent *event)      This event handler can be reimplemented in a subclass to receive     keyboard focus events (focus received) for the widget. The event     is passed in the \a event parameter      A widget normally must setFocusPolicy() to something other than     Qt::NoFocus in order to receive focus events. (Note that the     application programmer can call setFocus() on any widget, even     those that do not normally accept focus.)      The default implementation updates the widget (except for windows     that do not specify a focusPolicy()).      \sa focusOutEvent(), setFocusPolicy(), keyPressEvent(),     keyReleaseEvent(), event(), QFocusEvent */
DECL|function|focusInEvent
name|void
name|QWidget
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
operator|||
operator|!
name|isWindow
argument_list|()
condition|)
block|{
name|update
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*!     \fn void QWidget::focusOutEvent(QFocusEvent *event)      This event handler can be reimplemented in a subclass to receive     keyboard focus events (focus lost) for the widget. The events is     passed in the \a event parameter.      A widget normally must setFocusPolicy() to something other than     Qt::NoFocus in order to receive focus events. (Note that the     application programmer can call setFocus() on any widget, even     those that do not normally accept focus.)      The default implementation updates the widget (except for windows     that do not specify a focusPolicy()).      \sa focusInEvent(), setFocusPolicy(), keyPressEvent(),     keyReleaseEvent(), event(), QFocusEvent */
DECL|function|focusOutEvent
name|void
name|QWidget
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
operator|||
operator|!
name|isWindow
argument_list|()
condition|)
name|update
argument_list|()
expr_stmt|;
comment|// automatically hide the SIP
if|if
condition|(
name|qApp
operator|->
name|autoSipEnabled
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::enterEvent(QEvent *event)      This event handler can be reimplemented in a subclass to receive     widget enter events which are passed in the \a event parameter.      An event is sent to the widget when the mouse cursor enters the     widget.      \sa leaveEvent(), mouseMoveEvent(), event() */
DECL|function|enterEvent
name|void
name|QWidget
operator|::
name|enterEvent
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
block|{ }
comment|// ### Qt 6: void QWidget::enterEvent(QEnterEvent *).
comment|/*!     \fn void QWidget::leaveEvent(QEvent *event)      This event handler can be reimplemented in a subclass to receive     widget leave events which are passed in the \a event parameter.      A leave event is sent to the widget when the mouse cursor leaves     the widget.      \sa enterEvent(), mouseMoveEvent(), event() */
DECL|function|leaveEvent
name|void
name|QWidget
operator|::
name|leaveEvent
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::paintEvent(QPaintEvent *event)      This event handler can be reimplemented in a subclass to receive paint     events passed in \a event.      A paint event is a request to repaint all or part of a widget. It can     happen for one of the following reasons:      \list         \li repaint() or update() was invoked,         \li the widget was obscured and has now been uncovered, or         \li many other reasons.     \endlist      Many widgets can simply repaint their entire surface when asked to, but     some slow widgets need to optimize by painting only the requested region:     QPaintEvent::region(). This speed optimization does not change the result,     as painting is clipped to that region during event processing. QListView     and QTableView do this, for example.      Qt also tries to speed up painting by merging multiple paint events into     one. When update() is called several times or the window system sends     several paint events, Qt merges these events into one event with a larger     region (see QRegion::united()). The repaint() function does not permit this     optimization, so we suggest using update() whenever possible.      When the paint event occurs, the update region has normally been erased, so     you are painting on the widget's background.      The background can be set using setBackgroundRole() and setPalette().      Since Qt 4.0, QWidget automatically double-buffers its painting, so there     is no need to write double-buffering code in paintEvent() to avoid flicker.      \b{Note for the X11 platform}: It is possible to toggle global double     buffering by calling \c qt_x11_set_global_double_buffer(). For example,      \snippet code/src_gui_kernel_qwidget.cpp 14      \note Generally, you should refrain from calling update() or repaint()     \b{inside} a paintEvent(). For example, calling update() or repaint() on     children inside a paintevent() results in undefined behavior; the child may     or may not get a paint event.      \warning If you are using a custom paint engine without Qt's backingstore,     Qt::WA_PaintOnScreen must be set. Otherwise, QWidget::paintEngine() will     never be called; the backingstore will be used instead.      \sa event(), repaint(), update(), QPainter, QPixmap, QPaintEvent,     {Analog Clock Example} */
DECL|function|paintEvent
name|void
name|QWidget
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::moveEvent(QMoveEvent *event)      This event handler can be reimplemented in a subclass to receive     widget move events which are passed in the \a event parameter.     When the widget receives this event, it is already at the new     position.      The old position is accessible through QMoveEvent::oldPos().      \sa resizeEvent(), event(), move(), QMoveEvent */
DECL|function|moveEvent
name|void
name|QWidget
operator|::
name|moveEvent
parameter_list|(
name|QMoveEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     This event handler can be reimplemented in a subclass to receive     widget resize events which are passed in the \a event parameter.     When resizeEvent() is called, the widget already has its new     geometry. The old size is accessible through     QResizeEvent::oldSize().      The widget will be erased and receive a paint event immediately     after processing the resize event. No drawing need be (or should     be) done inside this handler.       \sa moveEvent(), event(), resize(), QResizeEvent, paintEvent(),         {Scribble Example} */
DECL|function|resizeEvent
name|void
name|QWidget
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
comment|/* event */
parameter_list|)
block|{ }
ifndef|#
directive|ifndef
name|QT_NO_ACTION
comment|/*!     \fn void QWidget::actionEvent(QActionEvent *event)      This event handler is called with the given \a event whenever the     widget's actions are changed.      \sa addAction(), insertAction(), removeAction(), actions(), QActionEvent */
DECL|function|actionEvent
name|void
name|QWidget
operator|::
name|actionEvent
parameter_list|(
name|QActionEvent
modifier|*
parameter_list|)
block|{  }
endif|#
directive|endif
comment|/*!     This event handler is called with the given \a event when Qt receives a window     close request for a top-level widget from the window system.      By default, the event is accepted and the widget is closed. You can reimplement     this function to change the way the widget responds to window close requests.     For example, you can prevent the window from closing by calling \l{QEvent::}{ignore()}     on all events.      Main window applications typically use reimplementations of this function to check     whether the user's work has been saved and ask for permission before closing.     For example, the \l{Application Example} uses a helper function to determine whether     or not to close the window:      \snippet mainwindows/application/mainwindow.cpp 3     \snippet mainwindows/application/mainwindow.cpp 4      \sa event(), hide(), close(), QCloseEvent, {Application Example} */
DECL|function|closeEvent
name|void
name|QWidget
operator|::
name|closeEvent
parameter_list|(
name|QCloseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive widget context menu events.      The handler is called when the widget's \l contextMenuPolicy is     Qt::DefaultContextMenu.      The default implementation ignores the context event.     See the \l QContextMenuEvent documentation for more details.      \sa event(), QContextMenuEvent, customContextMenuRequested() */
DECL|function|contextMenuEvent
name|void
name|QWidget
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive Input Method composition events. This handler     is called when the state of the input method changes.      Note that when creating custom text editing widgets, the     Qt::WA_InputMethodEnabled window attribute must be set explicitly     (using the setAttribute() function) in order to receive input     method events.      The default implementation calls event->ignore(), which rejects the     Input Method event. See the \l QInputMethodEvent documentation for more     details.      \sa event(), QInputMethodEvent */
DECL|function|inputMethodEvent
name|void
name|QWidget
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
comment|/*!     This method is only relevant for input widgets. It is used by the     input method to query a set of properties of the widget to be     able to support complex input method operations as support for     surrounding text and reconversions.      \a query specifies which property is queried.      \sa inputMethodEvent(), QInputMethodEvent, QInputMethodQueryEvent, inputMethodHints */
DECL|function|inputMethodQuery
name|QVariant
name|QWidget
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|query
condition|)
block|{
case|case
name|Qt
operator|::
name|ImCursorRectangle
case|:
return|return
name|QRect
argument_list|(
name|width
argument_list|()
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|height
argument_list|()
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImFont
case|:
return|return
name|font
argument_list|()
return|;
case|case
name|Qt
operator|::
name|ImAnchorPosition
case|:
comment|// Fallback.
return|return
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImHints
case|:
return|return
operator|(
name|int
operator|)
name|inputMethodHints
argument_list|()
return|;
default|default:
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
comment|/*!     \property QWidget::inputMethodHints     \brief What input method specific hints the widget has.      This is only relevant for input widgets. It is used by     the input method to retrieve hints as to how the input method     should operate. For example, if the Qt::ImhFormattedNumbersOnly flag     is set, the input method may change its visual components to reflect     that only numbers can be entered.      \note The flags are only hints, so the particular input method           implementation is free to ignore them. If you want to be           sure that a certain type of characters are entered,           you should also set a QValidator on the widget.      The default value is Qt::ImhNone.      \since 4.6      \sa inputMethodQuery() */
DECL|function|inputMethodHints
name|Qt
operator|::
name|InputMethodHints
name|QWidget
operator|::
name|inputMethodHints
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_IM
specifier|const
name|QWidgetPrivate
modifier|*
name|priv
init|=
name|d_func
argument_list|()
decl_stmt|;
while|while
condition|(
name|priv
operator|->
name|inheritsInputMethodHints
condition|)
block|{
name|priv
operator|=
name|priv
operator|->
name|q_func
argument_list|()
operator|->
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
return|return
name|priv
operator|->
name|imHints
return|;
else|#
directive|else
comment|//QT_NO_IM
return|return
literal|0
return|;
endif|#
directive|endif
comment|//QT_NO_IM
block|}
DECL|function|setInputMethodHints
name|void
name|QWidget
operator|::
name|setInputMethodHints
parameter_list|(
name|Qt
operator|::
name|InputMethodHints
name|hints
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IM
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|imHints
operator|==
name|hints
condition|)
return|return;
name|d
operator|->
name|imHints
operator|=
name|hints
expr_stmt|;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImHints
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_IM
block|}
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
comment|/*!     \fn void QWidget::dragEnterEvent(QDragEnterEvent *event)      This event handler is called when a drag is in progress and the     mouse enters this widget. The event is passed in the \a event parameter.      If the event is ignored, the widget won't receive any \l{dragMoveEvent()}{drag     move events}.      See the \l{dnd.html}{Drag-and-drop documentation} for an     overview of how to provide drag-and-drop in your application.      \sa QDrag, QDragEnterEvent */
DECL|function|dragEnterEvent
name|void
name|QWidget
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::dragMoveEvent(QDragMoveEvent *event)      This event handler is called if a drag is in progress, and when     any of the following conditions occur: the cursor enters this widget,     the cursor moves within this widget, or a modifier key is pressed on     the keyboard while this widget has the focus. The event is passed     in the \a event parameter.      See the \l{dnd.html}{Drag-and-drop documentation} for an     overview of how to provide drag-and-drop in your application.      \sa QDrag, QDragMoveEvent */
DECL|function|dragMoveEvent
name|void
name|QWidget
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::dragLeaveEvent(QDragLeaveEvent *event)      This event handler is called when a drag is in progress and the     mouse leaves this widget. The event is passed in the \a event     parameter.      See the \l{dnd.html}{Drag-and-drop documentation} for an     overview of how to provide drag-and-drop in your application.      \sa QDrag, QDragLeaveEvent */
DECL|function|dragLeaveEvent
name|void
name|QWidget
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::dropEvent(QDropEvent *event)      This event handler is called when the drag is dropped on this     widget. The event is passed in the \a event parameter.      See the \l{dnd.html}{Drag-and-drop documentation} for an     overview of how to provide drag-and-drop in your application.      \sa QDrag, QDropEvent */
DECL|function|dropEvent
name|void
name|QWidget
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
parameter_list|)
block|{ }
endif|#
directive|endif
comment|// QT_NO_DRAGANDDROP
comment|/*!     \fn void QWidget::showEvent(QShowEvent *event)      This event handler can be reimplemented in a subclass to receive     widget show events which are passed in the \a event parameter.      Non-spontaneous show events are sent to widgets immediately     before they are shown. The spontaneous show events of windows are     delivered afterwards.      Note: A widget receives spontaneous show and hide events when its     mapping status is changed by the window system, e.g. a spontaneous     hide event when the user minimizes the window, and a spontaneous     show event when the window is restored again. After receiving a     spontaneous hide event, a widget is still considered visible in     the sense of isVisible().      \sa visible, event(), QShowEvent */
DECL|function|showEvent
name|void
name|QWidget
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     \fn void QWidget::hideEvent(QHideEvent *event)      This event handler can be reimplemented in a subclass to receive     widget hide events. The event is passed in the \a event parameter.      Hide events are sent to widgets immediately after they have been     hidden.      Note: A widget receives spontaneous show and hide events when its     mapping status is changed by the window system, e.g. a spontaneous     hide event when the user minimizes the window, and a spontaneous     show event when the window is restored again. After receiving a     spontaneous hide event, a widget is still considered visible in     the sense of isVisible().      \sa visible, event(), QHideEvent */
DECL|function|hideEvent
name|void
name|QWidget
operator|::
name|hideEvent
parameter_list|(
name|QHideEvent
modifier|*
parameter_list|)
block|{ }
comment|/*!     This special event handler can be reimplemented in a subclass to     receive native platform events identified by \a eventType     which are passed in the \a message parameter.      In your reimplementation of this function, if you want to stop the     event being handled by Qt, return true and set \a result.     If you return false, this native event is passed back to Qt,     which translates the event into a Qt event and sends it to the widget.      \note Events are only delivered to this event handler if the widget is     has a native Window handle.      \note This function superseedes the event filter functions     x11Event(), winEvent() and macEvent() of Qt 4.      \table     \header \li Platform \li Event Type Identifier \li Message Type \li Result Type     \row \li Windows \li "windows_generic_MSG" \li MSG * \li LRESULT     \endtable */
DECL|function|nativeEvent
name|bool
name|QWidget
operator|::
name|nativeEvent
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|eventType
parameter_list|,
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|eventType
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/*!     Ensures that the widget has been polished by QStyle (i.e., has a     proper font and palette).      QWidget calls this function after it has been fully constructed     but before it is shown the very first time. You can call this     function if you want to ensure that the widget is polished before     doing an operation, e.g., the correct font size might be needed in     the widget's sizeHint() reimplementation. Note that this function     \e is called from the default implementation of sizeHint().      Polishing is useful for final initialization that must happen after     all constructors (from base classes as well as from subclasses)     have been called.      If you need to change some settings when a widget is polished,     reimplement event() and handle the QEvent::Polish event type.      \b{Note:} The function is declared const so that it can be called from     other const functions (e.g., sizeHint()).      \sa event() */
DECL|function|ensurePolished
name|void
name|QWidget
operator|::
name|ensurePolished
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|metaObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|d
operator|->
name|polished
condition|)
return|return;
name|d
operator|->
name|polished
operator|=
name|m
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|Polish
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|// polish children after 'this'
name|QList
argument_list|<
name|QObject
modifier|*
argument_list|>
name|children
init|=
name|d
operator|->
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|o
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|isWidgetType
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
condition|)
name|w
operator|->
name|ensurePolished
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|parent
operator|&&
name|d
operator|->
name|sendChildEvents
condition|)
block|{
name|QChildEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ChildPolished
argument_list|,
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|parent
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     Returns the mask currently set on a widget. If no mask is set the     return value will be an empty region.      \sa setMask(), clearMask(), QRegion::isEmpty(), {Shaped Clock Example} */
DECL|function|mask
name|QRegion
name|QWidget
operator|::
name|mask
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|extra
condition|?
name|d
operator|->
name|extra
operator|->
name|mask
else|:
name|QRegion
argument_list|()
return|;
block|}
comment|/*!     Returns the layout manager that is installed on this widget, or 0     if no layout manager is installed.      The layout manager sets the geometry of the widget's children     that have been added to the layout.      \sa setLayout(), sizePolicy(), {Layout Management} */
DECL|function|layout
name|QLayout
modifier|*
name|QWidget
operator|::
name|layout
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
return|;
block|}
comment|/*!     \fn void QWidget::setLayout(QLayout *layout)      Sets the layout manager for this widget to \a layout.      If there already is a layout manager installed on this widget,     QWidget won't let you install another. You must first delete the     existing layout manager (returned by layout()) before you can     call setLayout() with the new layout.      If \a layout is the layout manager on a different widget, setLayout()     will reparent the layout and make it the layout manager for this widget.      Example:      \snippet layouts/layouts.cpp 24      An alternative to calling this function is to pass this widget to     the layout's constructor.      The QWidget will take ownership of \a layout.      \sa layout(), {Layout Management} */
DECL|function|setLayout
name|void
name|QWidget
operator|::
name|setLayout
parameter_list|(
name|QLayout
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
operator|!
name|l
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::setLayout: Cannot set layout to 0"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|layout
argument_list|()
condition|)
block|{
if|if
condition|(
name|layout
argument_list|()
operator|!=
name|l
condition|)
name|qWarning
argument_list|(
literal|"QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", which already has a"
literal|" layout"
argument_list|,
name|l
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|QObject
modifier|*
name|oldParent
init|=
name|l
operator|->
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldParent
operator|&&
name|oldParent
operator|!=
name|this
condition|)
block|{
if|if
condition|(
name|oldParent
operator|->
name|isWidgetType
argument_list|()
condition|)
block|{
comment|// Steal the layout off a widget parent. Takes effect when
comment|// morphing laid-out container widgets in Designer.
name|QWidget
modifier|*
name|oldParentWidget
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|oldParent
argument_list|)
decl_stmt|;
name|oldParentWidget
operator|->
name|takeLayout
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", when the QLayout already has a parent"
argument_list|,
name|l
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|l
operator|->
name|d_func
argument_list|()
operator|->
name|topLevel
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|layout
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|oldParent
operator|!=
name|this
condition|)
block|{
name|l
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|l
operator|->
name|d_func
argument_list|()
operator|->
name|reparentChildWidgets
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|l
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|d
operator|->
name|maybeTopData
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|sizeAdjusted
operator|=
literal|false
expr_stmt|;
block|}
comment|/*!     \fn QLayout *QWidget::takeLayout()      Remove the layout from the widget.     \since 4.5 */
DECL|function|takeLayout
name|QLayout
modifier|*
name|QWidget
operator|::
name|takeLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QLayout
modifier|*
name|l
init|=
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|layout
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
comment|/*!     \property QWidget::sizePolicy     \brief the default layout behavior of the widget      If there is a QLayout that manages this widget's children, the     size policy specified by that layout is used. If there is no such     QLayout, the result of this function is used.      The default policy is Preferred/Preferred, which means that the     widget can be freely resized, but prefers to be the size     sizeHint() returns. Button-like widgets set the size policy to     specify that they may stretch horizontally, but are fixed     vertically. The same applies to lineedit controls (such as     QLineEdit, QSpinBox or an editable QComboBox) and other     horizontally orientated widgets (such as QProgressBar).     QToolButton's are normally square, so they allow growth in both     directions. Widgets that support different directions (such as     QSlider, QScrollBar or QHeader) specify stretching in the     respective direction only. Widgets that can provide scroll bars     (usually subclasses of QScrollArea) tend to specify that they can     use additional space, and that they can make do with less than     sizeHint().      \sa sizeHint(), QLayout, QSizePolicy, updateGeometry() */
DECL|function|sizePolicy
name|QSizePolicy
name|QWidget
operator|::
name|sizePolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|size_policy
return|;
block|}
DECL|function|setSizePolicy
name|void
name|QWidget
operator|::
name|setSizePolicy
parameter_list|(
name|QSizePolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|==
name|d
operator|->
name|size_policy
condition|)
return|return;
name|d
operator|->
name|size_policy
operator|=
name|policy
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QWExtra
modifier|*
name|extra
init|=
name|d
operator|->
name|extra
condition|)
block|{
if|if
condition|(
name|extra
operator|->
name|proxyWidget
condition|)
name|extra
operator|->
name|proxyWidget
operator|->
name|setSizePolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|d
operator|->
name|maybeTopData
argument_list|()
condition|)
name|d
operator|->
name|topData
argument_list|()
operator|->
name|sizeAdjusted
operator|=
literal|false
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)     \overload      Sets the size policy of the widget to \a horizontal and \a     vertical, with standard stretch and no height-for-width.      \sa QSizePolicy::QSizePolicy() */
comment|/*!     Returns the preferred height for this widget, given the width \a w.      If this widget has a layout, the default implementation returns     the layout's preferred height.  if there is no layout, the default     implementation returns -1 indicating that the preferred height     does not depend on the width. */
DECL|function|heightForWidth
name|int
name|QWidget
operator|::
name|heightForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|layout
argument_list|()
operator|&&
name|layout
argument_list|()
operator|->
name|hasHeightForWidth
argument_list|()
condition|)
return|return
name|layout
argument_list|()
operator|->
name|totalHeightForWidth
argument_list|(
name|w
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*!     \since 5.0      Returns true if the widget's preferred height depends on its width; otherwise returns false. */
DECL|function|hasHeightForWidth
name|bool
name|QWidget
operator|::
name|hasHeightForWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layout
condition|?
name|d
operator|->
name|layout
operator|->
name|hasHeightForWidth
argument_list|()
else|:
name|d
operator|->
name|size_policy
operator|.
name|hasHeightForWidth
argument_list|()
return|;
block|}
comment|/*!     \fn QWidget *QWidget::childAt(int x, int y) const      Returns the visible child widget at the position (\a{x}, \a{y})     in the widget's coordinate system. If there is no visible child     widget at the specified position, the function returns 0. */
comment|/*!     \overload      Returns the visible child widget at point \a p in the widget's own     coordinate system. */
DECL|function|childAt
name|QWidget
modifier|*
name|QWidget
operator|::
name|childAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|childAt_helper
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|function|childAt_helper
name|QWidget
modifier|*
name|QWidgetPrivate
operator|::
name|childAt_helper
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|bool
name|ignoreChildrenInDestructor
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
comment|// Unified tool bars on the Mac require special handling since they live outside
comment|// QMainWindow's geometry(). See commit: 35667fd45ada49269a5987c235fdedfc43e92bb8
name|bool
name|includeFrame
init|=
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
name|qobject_cast
argument_list|<
specifier|const
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|&&
cast|static_cast
argument_list|<
specifier|const
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|->
name|unifiedTitleAndToolBarOnMac
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeFrame
condition|)
return|return
name|childAtRecursiveHelper
argument_list|(
name|p
argument_list|,
name|ignoreChildrenInDestructor
argument_list|,
name|includeFrame
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pointInsideRectAndMask
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|childAtRecursiveHelper
argument_list|(
name|p
argument_list|,
name|ignoreChildrenInDestructor
argument_list|)
return|;
block|}
DECL|function|childAtRecursiveHelper
name|QWidget
modifier|*
name|QWidgetPrivate
operator|::
name|childAtRecursiveHelper
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|,
name|bool
name|ignoreChildrenInDestructor
parameter_list|,
name|bool
name|includeFrame
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|Q_WS_MAC
name|Q_UNUSED
argument_list|(
name|includeFrame
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|isWindow
argument_list|()
operator|||
name|child
operator|->
name|isHidden
argument_list|()
operator|||
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TransparentForMouseEvents
argument_list|)
operator|||
operator|(
name|ignoreChildrenInDestructor
operator|&&
name|child
operator|->
name|data
operator|->
name|in_destructor
operator|)
condition|)
block|{
continue|continue;
block|}
comment|// Map the point 'p' from parent coordinates to child coordinates.
name|QPoint
name|childPoint
init|=
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// 'includeFrame' is true if the child's parent is a top-level QMainWindow with an unified tool bar.
comment|// An unified tool bar on the Mac lives outside QMainWindow's geometry(), so a normal
comment|// QWidget::mapFromParent won't do the trick.
if|if
condition|(
name|includeFrame
operator|&&
name|qobject_cast
argument_list|<
name|QToolBar
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
condition|)
name|childPoint
operator|=
name|qt_mac_nativeMapFromParent
argument_list|(
name|child
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|childPoint
operator|-=
name|child
operator|->
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
comment|// Check if the point hits the child.
if|if
condition|(
operator|!
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|pointInsideRectAndMask
argument_list|(
name|childPoint
argument_list|)
condition|)
continue|continue;
comment|// Do the same for the child's descendants.
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|childAtRecursiveHelper
argument_list|(
name|childPoint
argument_list|,
name|ignoreChildrenInDestructor
argument_list|)
condition|)
return|return
name|w
return|;
comment|// We have found our target; namely the child at position 'p'.
return|return
name|child
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|function|updateGeometry_helper
name|void
name|QWidgetPrivate
operator|::
name|updateGeometry_helper
parameter_list|(
name|bool
name|forceUpdate
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|widgetItem
condition|)
name|widgetItem
operator|->
name|invalidateSizeCache
argument_list|()
expr_stmt|;
name|QWidget
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|forceUpdate
operator|||
operator|!
name|extra
operator|||
name|extra
operator|->
name|minw
operator|!=
name|extra
operator|->
name|maxw
operator|||
name|extra
operator|->
name|minh
operator|!=
name|extra
operator|->
name|maxh
condition|)
block|{
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|isHidden
argument_list|()
operator|&&
operator|(
name|parent
operator|=
name|q
operator|->
name|parentWidget
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|layout
condition|)
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parent
operator|->
name|isVisible
argument_list|()
condition|)
name|QApplication
operator|::
name|postEvent
argument_list|(
name|parent
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*!     Notifies the layout system that this widget has changed and may     need to change geometry.      Call this function if the sizeHint() or sizePolicy() have changed.      For explicitly hidden widgets, updateGeometry() is a no-op. The     layout system will be notified as soon as the widget is shown. */
DECL|function|updateGeometry
name|void
name|QWidget
operator|::
name|updateGeometry
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateGeometry_helper
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/*! \property QWidget::windowFlags      Window flags are a combination of a type (e.g. Qt::Dialog) and     zero or more hints to the window system (e.g.     Qt::FramelessWindowHint).      If the widget had type Qt::Widget or Qt::SubWindow and becomes a     window (Qt::Window, Qt::Dialog, etc.), it is put at position (0,     0) on the desktop. If the widget is a window and becomes a     Qt::Widget or Qt::SubWindow, it is put at position (0, 0)     relative to its parent widget.      \note This function calls setParent() when changing the flags for     a window, causing the widget to be hidden. You must call show() to make     the widget visible again..      \sa windowType(), {Window Flags Example} */
DECL|function|setWindowFlags
name|void
name|QWidget
operator|::
name|setWindowFlags
parameter_list|(
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|window_flags
operator|==
name|flags
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|->
name|window_flags
operator||
name|flags
operator|)
operator|&
name|Qt
operator|::
name|Window
condition|)
block|{
comment|// the old type was a window and/or the new type is a window
name|QPoint
name|oldPos
init|=
name|pos
argument_list|()
decl_stmt|;
name|bool
name|visible
init|=
name|isVisible
argument_list|()
decl_stmt|;
name|setParent
argument_list|(
name|parentWidget
argument_list|()
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|// if both types are windows or neither of them are, we restore
comment|// the old position
if|if
condition|(
operator|!
operator|(
operator|(
name|data
operator|->
name|window_flags
operator|^
name|flags
operator|)
operator|&
name|Qt
operator|::
name|Window
operator|)
operator|&&
operator|(
name|visible
operator|||
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
operator|)
condition|)
block|{
name|move
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
block|}
comment|// for backward-compatibility we change Qt::WA_QuitOnClose attribute value only when the window was recreated.
name|d
operator|->
name|adjustQuitOnCloseAttribute
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|window_flags
operator|=
name|flags
expr_stmt|;
block|}
block|}
comment|/*!     Sets the window flags for the widget to \a flags,     \e without telling the window system.      \warning Do not call this function unless you really know what     you're doing.      \sa setWindowFlags() */
DECL|function|overrideWindowFlags
name|void
name|QWidget
operator|::
name|overrideWindowFlags
parameter_list|(
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
block|{
name|data
operator|->
name|window_flags
operator|=
name|flags
expr_stmt|;
block|}
comment|/*!     \fn Qt::WindowType QWidget::windowType() const      Returns the window type of this widget. This is identical to     windowFlags()& Qt::WindowType_Mask.      \sa windowFlags */
comment|/*!     Sets the parent of the widget to \a parent, and resets the window     flags. The widget is moved to position (0, 0) in its new parent.      If the new parent widget is in a different window, the     reparented widget and its children are appended to the end of the     \l{setFocusPolicy()}{tab chain} of the new parent     widget, in the same internal order as before. If one of the moved     widgets had keyboard focus, setParent() calls clearFocus() for that     widget.      If the new parent widget is in the same window as the     old parent, setting the parent doesn't change the tab order or     keyboard focus.      If the "new" parent widget is the old parent widget, this function     does nothing.      \note The widget becomes invisible as part of changing its parent,     even if it was previously visible. You must call show() to make the     widget visible again.      \warning It is very unlikely that you will ever need this     function. If you have a widget that changes its content     dynamically, it is far easier to use \l QStackedWidget.      \sa setWindowFlags() */
DECL|function|setParent
name|void
name|QWidget
operator|::
name|setParent
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|==
name|parentWidget
argument_list|()
condition|)
return|return;
name|setParent
argument_list|(
operator|(
name|QWidget
operator|*
operator|)
name|parent
argument_list|,
name|windowFlags
argument_list|()
operator|&
operator|~
name|Qt
operator|::
name|WindowType_Mask
argument_list|)
expr_stmt|;
block|}
comment|/*!     \overload      This function also takes widget flags, \a f as an argument. */
DECL|function|setParent
name|void
name|QWidget
operator|::
name|setParent
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|bool
name|resized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|bool
name|wasCreated
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|oldtlw
init|=
name|window
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|desktopWidget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
name|desktopWidget
operator|=
name|parent
expr_stmt|;
name|bool
name|newParent
init|=
operator|(
name|parent
operator|!=
name|parentWidget
argument_list|()
operator|)
operator|||
operator|!
name|wasCreated
operator|||
name|desktopWidget
decl_stmt|;
if|if
condition|(
name|newParent
operator|&&
name|parent
operator|&&
operator|!
name|desktopWidget
condition|)
block|{
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
operator|&&
operator|!
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontCreateNativeWidgetSiblings
argument_list|)
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// On Mac, toolbars inside the unified title bar will never overlap with
comment|// siblings in the content view. So we skip enforce native siblings in that case
operator|&&
operator|!
name|d
operator|->
name|isInUnifiedToolbar
operator|&&
name|parentWidget
argument_list|()
operator|&&
name|parentWidget
argument_list|()
operator|->
name|isWindow
argument_list|()
endif|#
directive|endif
comment|// Q_WS_MAC
condition|)
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|enforceNativeChildren
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|nativeChildrenForced
argument_list|()
operator|||
name|parent
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PaintOnScreen
argument_list|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wasCreated
condition|)
block|{
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|)
condition|)
block|{
name|hide
argument_list|()
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newParent
condition|)
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ParentAboutToChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newParent
operator|&&
name|isAncestorOf
argument_list|(
name|focusWidget
argument_list|()
argument_list|)
condition|)
name|focusWidget
argument_list|()
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
name|QTLWExtra
modifier|*
name|oldTopExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
name|QWidgetBackingStoreTracker
modifier|*
name|oldBsTracker
init|=
name|oldTopExtra
condition|?
operator|&
name|oldTopExtra
operator|->
name|backingStoreTracker
else|:
literal|0
decl_stmt|;
name|d
operator|->
name|setParent_sys
argument_list|(
name|parent
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|QTLWExtra
modifier|*
name|topExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
name|QWidgetBackingStoreTracker
modifier|*
name|bsTracker
init|=
name|topExtra
condition|?
operator|&
name|topExtra
operator|->
name|backingStoreTracker
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|oldBsTracker
operator|&&
name|oldBsTracker
operator|!=
name|bsTracker
condition|)
name|oldBsTracker
operator|->
name|unregisterWidgetSubtree
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|desktopWidget
condition|)
name|parent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|oldBs
init|=
name|oldtlw
operator|->
name|d_func
argument_list|()
operator|->
name|maybeBackingStore
argument_list|()
condition|)
block|{
if|if
condition|(
name|newParent
condition|)
name|oldBs
operator|->
name|removeDirtyWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Move the widget and all its static children from
comment|// the old backing store to the new one.
name|oldBs
operator|->
name|moveStaticWidgets
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_ImmediateWidgetCreation
argument_list|)
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|create
argument_list|()
expr_stmt|;
name|d
operator|->
name|reparentFocusWidgets
argument_list|(
name|oldtlw
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|resized
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
operator|&&
operator|(
operator|!
name|parent
operator|||
operator|!
name|parent
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StyleSheet
argument_list|)
operator|)
condition|)
block|{
name|d
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
name|d
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|resolveLayoutDirection
argument_list|()
expr_stmt|;
name|d
operator|->
name|resolveLocale
argument_list|()
expr_stmt|;
comment|// Note: GL widgets under WGL or EGL will always need a ParentChange
comment|// event to handle recreation/rebinding of the GL context, hence the
comment|// (f& Qt::MSWindowsOwnDC) clause (which is set on QGLWidgets on all
comment|// platforms).
if|if
condition|(
name|newParent
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_ES
argument_list|)
operator|||
operator|(
name|f
operator|&
name|Qt
operator|::
name|MSWindowsOwnDC
operator|)
endif|#
directive|endif
condition|)
block|{
comment|// propagate enabled updates enabled state to non-windows
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceDisabled
argument_list|)
condition|)
name|d
operator|->
name|setEnabled_helper
argument_list|(
name|parent
condition|?
name|parent
operator|->
name|isEnabled
argument_list|()
else|:
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_ForceUpdatesDisabled
argument_list|)
condition|)
name|d
operator|->
name|setUpdatesEnabled_helper
argument_list|(
name|parent
condition|?
name|parent
operator|->
name|updatesEnabled
argument_list|()
else|:
literal|true
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|inheritStyle
argument_list|()
expr_stmt|;
comment|// send and post remaining QObject events
if|if
condition|(
name|parent
operator|&&
name|d
operator|->
name|sendChildEvents
condition|)
block|{
name|QChildEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ChildAdded
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|//### already hidden above ---> must probably do something smart on the mac
comment|// #ifdef Q_WS_MAC
comment|//             extern bool qt_mac_is_macdrawer(const QWidget *); //qwidget_mac.cpp
comment|//             if(!qt_mac_is_macdrawer(q)) //special case
comment|//                 q->setAttribute(Qt::WA_WState_Hidden);
comment|// #else
comment|//             q->setAttribute(Qt::WA_WState_Hidden);
comment|//#endif
if|if
condition|(
name|parent
operator|&&
name|d
operator|->
name|sendChildEvents
operator|&&
name|d
operator|->
name|polished
condition|)
block|{
name|QChildEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ChildPolished
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ParentChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wasCreated
condition|)
block|{
if|if
condition|(
name|isWindow
argument_list|()
operator|||
name|parentWidget
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Hidden
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// Embed the widget into a proxy if the parent is embedded.
comment|// ### Doesn't handle reparenting out of an embedded widget.
if|if
condition|(
name|oldtlw
operator|->
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsProxyWidget
modifier|*
name|ancestorProxy
init|=
name|d
operator|->
name|nearestGraphicsProxyWidget
argument_list|(
name|oldtlw
argument_list|)
condition|)
name|ancestorProxy
operator|->
name|d_func
argument_list|()
operator|->
name|unembedSubWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isWindow
argument_list|()
operator|&&
name|parent
operator|&&
operator|!
name|graphicsProxyWidget
argument_list|()
operator|&&
operator|!
name|bypassGraphicsProxyWidget
argument_list|(
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
name|QGraphicsProxyWidget
modifier|*
name|ancestorProxy
init|=
name|d
operator|->
name|nearestGraphicsProxyWidget
argument_list|(
name|parent
argument_list|)
condition|)
name|ancestorProxy
operator|->
name|d_func
argument_list|()
operator|->
name|embedSubWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*!     Scrolls the widget including its children \a dx pixels to the     right and \a dy downward. Both \a dx and \a dy may be negative.      After scrolling, the widgets will receive paint events for     the areas that need to be repainted. For widgets that Qt knows to     be opaque, this is only the newly exposed parts.     For example, if an opaque widget is scrolled 8 pixels to the left,     only an 8-pixel wide stripe at the right edge needs updating.      Since widgets propagate the contents of their parents by default,     you need to set the \l autoFillBackground property, or use     setAttribute() to set the Qt::WA_OpaquePaintEvent attribute, to make     a widget opaque.      For widgets that use contents propagation, a scroll will cause an     update of the entire scroll area.      \sa {Transparency and Double Buffering} */
DECL|function|scroll
name|void
name|QWidget
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|updatesEnabled
argument_list|()
operator|&&
name|children
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|||
operator|!
name|isVisible
argument_list|()
condition|)
return|return;
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|QWidgetPrivate
operator|::
name|nearestGraphicsProxyWidget
argument_list|(
name|this
argument_list|)
condition|)
block|{
comment|// Graphics View maintains its own dirty region as a list of rects;
comment|// until we can connect item updates directly to the view, we must
comment|// separately add a translated dirty region.
if|if
condition|(
operator|!
name|d
operator|->
name|dirty
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
operator|(
name|d
operator|->
name|dirty
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
operator|)
operator|.
name|rects
argument_list|()
control|)
name|proxy
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|proxy
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|proxy
operator|->
name|subWidgetRect
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
name|d
operator|->
name|scroll_sys
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
comment|/*!     \overload      This version only scrolls \a r and does not move the children of     the widget.      If \a r is empty or invalid, the result is undefined.      \sa QScrollArea */
DECL|function|scroll
name|void
name|QWidget
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|updatesEnabled
argument_list|()
operator|&&
name|children
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|||
operator|!
name|isVisible
argument_list|()
condition|)
return|return;
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|QWidgetPrivate
operator|::
name|nearestGraphicsProxyWidget
argument_list|(
name|this
argument_list|)
condition|)
block|{
comment|// Graphics View maintains its own dirty region as a list of rects;
comment|// until we can connect item updates directly to the view, we must
comment|// separately add a translated dirty region.
if|if
condition|(
operator|!
name|d
operator|->
name|dirty
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
operator|(
name|d
operator|->
name|dirty
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
operator|&
name|r
operator|)
operator|.
name|rects
argument_list|()
control|)
name|proxy
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|proxy
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|r
operator|.
name|translated
argument_list|(
name|proxy
operator|->
name|subWidgetRect
argument_list|(
name|this
argument_list|)
operator|.
name|topLeft
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|d
operator|->
name|scroll_sys
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/*!     Repaints the widget directly by calling paintEvent() immediately,     unless updates are disabled or the widget is hidden.      We suggest only using repaint() if you need an immediate repaint,     for example during animation. In almost all circumstances update()     is better, as it permits Qt to optimize for speed and minimize     flicker.      \warning If you call repaint() in a function which may itself be     called from paintEvent(), you may get infinite recursion. The     update() function never causes recursion.      \sa update(), paintEvent(), setUpdatesEnabled() */
DECL|function|repaint
name|void
name|QWidget
operator|::
name|repaint
parameter_list|()
block|{
name|repaint
argument_list|(
name|rect
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*! \overload      This version repaints a rectangle (\a x, \a y, \a w, \a h) inside     the widget.      If \a w is negative, it is replaced with \c{width() - x}, and if     \a h is negative, it is replaced width \c{height() - y}. */
DECL|function|repaint
name|void
name|QWidget
operator|::
name|repaint
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
if|if
condition|(
name|x
operator|>
name|data
operator|->
name|crect
operator|.
name|width
argument_list|()
operator|||
name|y
operator|>
name|data
operator|->
name|crect
operator|.
name|height
argument_list|()
condition|)
return|return;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
name|data
operator|->
name|crect
operator|.
name|width
argument_list|()
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
name|data
operator|->
name|crect
operator|.
name|height
argument_list|()
operator|-
name|y
expr_stmt|;
name|repaint
argument_list|(
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*! \overload      This version repaints a rectangle \a rect inside the widget. */
DECL|function|repaint
name|void
name|QWidget
operator|::
name|repaint
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ConfigPending
argument_list|)
condition|)
block|{
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isVisible
argument_list|()
operator|||
operator|!
name|updatesEnabled
argument_list|()
operator|||
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|hasBackingStoreSupport
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|isInUnifiedToolbar
condition|)
block|{
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|unifiedSurface
operator|->
name|renderToolbar
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QTLWExtra
modifier|*
name|tlwExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlwExtra
operator|&&
operator|!
name|tlwExtra
operator|->
name|inTopLevelResize
operator|&&
name|tlwExtra
operator|->
name|backingStore
condition|)
block|{
name|tlwExtra
operator|->
name|inRepaint
operator|=
literal|true
expr_stmt|;
name|tlwExtra
operator|->
name|backingStoreTracker
operator|->
name|markDirty
argument_list|(
name|rect
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tlwExtra
operator|->
name|inRepaint
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|repaint_sys
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \overload      This version repaints a region \a rgn inside the widget. */
DECL|function|repaint
name|void
name|QWidget
operator|::
name|repaint
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ConfigPending
argument_list|)
condition|)
block|{
name|update
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isVisible
argument_list|()
operator|||
operator|!
name|updatesEnabled
argument_list|()
operator|||
name|rgn
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|hasBackingStoreSupport
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|isInUnifiedToolbar
condition|)
block|{
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|unifiedSurface
operator|->
name|renderToolbar
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QTLWExtra
modifier|*
name|tlwExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlwExtra
operator|&&
operator|!
name|tlwExtra
operator|->
name|inTopLevelResize
operator|&&
name|tlwExtra
operator|->
name|backingStore
condition|)
block|{
name|tlwExtra
operator|->
name|inRepaint
operator|=
literal|true
expr_stmt|;
name|tlwExtra
operator|->
name|backingStoreTracker
operator|->
name|markDirty
argument_list|(
name|rgn
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tlwExtra
operator|->
name|inRepaint
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|repaint_sys
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     Updates the widget unless updates are disabled or the widget is     hidden.      This function does not cause an immediate repaint; instead it     schedules a paint event for processing when Qt returns to the main     event loop. This permits Qt to optimize for more speed and less     flicker than a call to repaint() does.      Calling update() several times normally results in just one     paintEvent() call.      Qt normally erases the widget's area before the paintEvent() call.     If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is     responsible for painting all its pixels with an opaque color.      \sa repaint(), paintEvent(), setUpdatesEnabled(), {Analog Clock Example} */
DECL|function|update
name|void
name|QWidget
operator|::
name|update
parameter_list|()
block|{
name|update
argument_list|(
name|rect
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*! \fn void QWidget::update(int x, int y, int w, int h)     \overload      This version updates a rectangle (\a x, \a y, \a w, \a h) inside     the widget. */
comment|/*!     \overload      This version updates a rectangle \a rect inside the widget. */
DECL|function|update
name|void
name|QWidget
operator|::
name|update
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isVisible
argument_list|()
operator|||
operator|!
name|updatesEnabled
argument_list|()
operator|||
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|)
condition|)
block|{
name|QApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QUpdateLaterEvent
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hasBackingStoreSupport
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|isInUnifiedToolbar
condition|)
block|{
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|unifiedSurface
operator|->
name|renderToolbar
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QTLWExtra
modifier|*
name|tlwExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlwExtra
operator|&&
operator|!
name|tlwExtra
operator|->
name|inTopLevelResize
operator|&&
name|tlwExtra
operator|->
name|backingStore
condition|)
name|tlwExtra
operator|->
name|backingStoreTracker
operator|->
name|markDirty
argument_list|(
name|rect
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_func
argument_list|()
operator|->
name|repaint_sys
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \overload      This version repaints a region \a rgn inside the widget. */
DECL|function|update
name|void
name|QWidget
operator|::
name|update
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|rgn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isVisible
argument_list|()
operator|||
operator|!
name|updatesEnabled
argument_list|()
operator|||
name|rgn
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_InPaintEvent
argument_list|)
condition|)
block|{
name|QApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QUpdateLaterEvent
argument_list|(
name|rgn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hasBackingStoreSupport
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|isInUnifiedToolbar
condition|)
block|{
name|qt_widget_private
argument_list|(
name|this
argument_list|)
operator|->
name|unifiedSurface
operator|->
name|renderToolbar
argument_list|(
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QTLWExtra
modifier|*
name|tlwExtra
init|=
name|window
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|tlwExtra
operator|&&
operator|!
name|tlwExtra
operator|->
name|inTopLevelResize
operator|&&
name|tlwExtra
operator|->
name|backingStore
condition|)
name|tlwExtra
operator|->
name|backingStoreTracker
operator|->
name|markDirty
argument_list|(
name|rgn
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_func
argument_list|()
operator|->
name|repaint_sys
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!   \internal    This just sets the corresponding attribute bit to 1 or 0  */
DECL|function|setAttribute_internal
specifier|static
name|void
name|setAttribute_internal
parameter_list|(
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|,
name|QWidgetData
modifier|*
name|data
parameter_list|,
name|QWidgetPrivate
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|attribute
operator|<
name|int
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|on
condition|)
name|data
operator|->
name|widget_attributes
operator||=
operator|(
literal|1
operator|<<
name|attribute
operator|)
expr_stmt|;
else|else
name|data
operator|->
name|widget_attributes
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|attribute
operator|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|x
init|=
name|attribute
operator|-
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
specifier|const
name|int
name|int_off
init|=
name|x
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|on
condition|)
name|d
operator|->
name|high_attributes
index|[
name|int_off
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
operator|(
name|int_off
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
else|else
name|d
operator|->
name|high_attributes
index|[
name|int_off
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
operator|(
name|int_off
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|Q_OS_MAC
DECL|function|macUpdateSizeAttribute
name|void
name|QWidgetPrivate
operator|::
name|macUpdateSizeAttribute
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|MacSizeChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|(
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|||
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowPropagation
argument_list|)
operator|)
operator|&&
operator|!
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|)
comment|// no attribute set? inherit from parent
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|)
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacNormalSize
argument_list|)
condition|)
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|macUpdateSizeAttribute
argument_list|()
expr_stmt|;
block|}
name|resolveFont
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*!     Sets the attribute \a attribute on this widget if \a on is true;     otherwise clears the attribute.      \sa testAttribute() */
DECL|function|setAttribute
name|void
name|QWidget
operator|::
name|setAttribute
parameter_list|(
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|testAttribute
argument_list|(
name|attribute
argument_list|)
operator|==
name|on
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
sizeof|sizeof
argument_list|(
name|d
operator|->
name|high_attributes
argument_list|)
operator|*
literal|8
operator|>=
operator|(
name|Qt
operator|::
name|WA_AttributeCount
operator|-
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|*
literal|8
operator|)
argument_list|,
literal|"QWidget::setAttribute(WidgetAttribute, bool)"
argument_list|,
literal|"QWidgetPrivate::high_attributes[] too small to contain all attributes in WidgetAttribute"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// ### Don't use PaintOnScreen+paintEngine() to do native painting in some future release
if|if
condition|(
name|attribute
operator|==
name|Qt
operator|::
name|WA_PaintOnScreen
operator|&&
name|on
operator|&&
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
operator|&&
operator|!
name|inherits
argument_list|(
literal|"QGLWidget"
argument_list|)
condition|)
block|{
comment|// see qwidget_qpa.cpp, ::paintEngine for details
name|paintEngine
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|noPaintOnScreen
condition|)
return|return;
block|}
endif|#
directive|endif
name|setAttribute_internal
argument_list|(
name|attribute
argument_list|,
name|on
argument_list|,
name|data
argument_list|,
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|Qt
operator|::
name|WA_AcceptDrops
case|:
block|{
if|if
condition|(
name|on
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
operator|(
name|isWindow
argument_list|()
operator|||
operator|!
name|parentWidget
argument_list|()
operator|||
operator|!
name|parentWidget
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
operator|)
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|AcceptDropsChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|WA_DropSiteRegistered
case|:
block|{
name|d
operator|->
name|registerDropSite
argument_list|(
name|on
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptDrops
argument_list|)
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|)
operator|!=
name|on
condition|)
name|w
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DropSiteRegistered
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|Qt
operator|::
name|WA_NoChildEventsForParent
case|:
name|d
operator|->
name|sendChildEvents
operator|=
operator|!
name|on
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_NoChildEventsFromChildren
case|:
name|d
operator|->
name|receiveChildEvents
operator|=
operator|!
name|on
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_MacBrushedMetal
case|:
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|d
operator|->
name|setStyle_helper
argument_list|(
name|style
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Make sure things get unpolished/polished correctly.
comment|// fall through since changing the metal attribute affects the opaque size grip.
case|case
name|Qt
operator|::
name|WA_MacOpaqueSizeGrip
case|:
name|d
operator|->
name|macUpdateOpaqueSizeGrip
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_MacShowFocusRect
case|:
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
name|clearFocus
argument_list|()
expr_stmt|;
name|setFocus
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|WA_Hover
case|:
name|qt_mac_update_mouseTracking
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|WA_MacAlwaysShowToolWindow
case|:
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|d
operator|->
name|macUpdateHideOnSuspend
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|Qt
operator|::
name|WA_MacNormalSize
case|:
case|case
name|Qt
operator|::
name|WA_MacSmallSize
case|:
case|case
name|Qt
operator|::
name|WA_MacMiniSize
case|:
ifdef|#
directive|ifdef
name|Q_OS_MAC
block|{
comment|// We can only have one of these set at a time
specifier|const
name|Qt
operator|::
name|WidgetAttribute
name|MacSizes
index|[]
init|=
block|{
name|Qt
operator|::
name|WA_MacNormalSize
block|,
name|Qt
operator|::
name|WA_MacSmallSize
block|,
name|Qt
operator|::
name|WA_MacMiniSize
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|MacSizes
index|[
name|i
index|]
operator|!=
name|attribute
condition|)
name|setAttribute_internal
argument_list|(
name|MacSizes
index|[
name|i
index|]
argument_list|,
literal|false
argument_list|,
name|data
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|macUpdateSizeAttribute
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|Qt
operator|::
name|WA_ShowModal
case|:
if|if
condition|(
operator|!
name|on
condition|)
block|{
comment|// reset modality type to NonModal when clearing WA_ShowModal
name|data
operator|->
name|window_modality
operator|=
name|Qt
operator|::
name|NonModal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|window_modality
operator|==
name|Qt
operator|::
name|NonModal
condition|)
block|{
comment|// determine the modality type if it hasn't been set prior
comment|// to setting WA_ShowModal. set the default to WindowModal
comment|// if we are the child of a group leader; otherwise use
comment|// ApplicationModal.
name|QWidget
modifier|*
name|w
init|=
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
name|w
operator|=
name|w
operator|->
name|window
argument_list|()
expr_stmt|;
while|while
condition|(
name|w
operator|&&
operator|!
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
condition|)
block|{
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|w
operator|=
name|w
operator|->
name|window
argument_list|()
expr_stmt|;
block|}
name|data
operator|->
name|window_modality
operator|=
operator|(
name|w
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_GroupLeader
argument_list|)
operator|)
condition|?
name|Qt
operator|::
name|WindowModal
else|:
name|Qt
operator|::
name|ApplicationModal
expr_stmt|;
comment|// Some window managers do not allow us to enter modality after the
comment|// window is visible.The window must be hidden before changing the
comment|// windowModality property and then reshown.
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
block|{
comment|// don't call setModal_sys() before create_sys()
name|d
operator|->
name|setModal_sys
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|WA_MouseTracking
case|:
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|MouseTrackingChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Qt
operator|::
name|WA_NativeWindow
case|:
block|{
name|d
operator|->
name|createTLExtra
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_IM
name|QWidget
modifier|*
name|focusWidget
init|=
name|d
operator|->
name|effectiveFocusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|on
operator|&&
operator|!
name|internalWinId
argument_list|()
operator|&&
name|hasFocus
argument_list|()
operator|&&
name|focusWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontCreateNativeWidgetSiblings
argument_list|)
operator|&&
name|parentWidget
argument_list|()
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// On Mac, toolbars inside the unified title bar will never overlap with
comment|// siblings in the content view. So we skip enforce native siblings in that case
operator|&&
operator|!
name|d
operator|->
name|isInUnifiedToolbar
operator|&&
name|parentWidget
argument_list|()
operator|->
name|isWindow
argument_list|()
endif|#
directive|endif
comment|// Q_WS_MAC
condition|)
name|parentWidget
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|enforceNativeChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|!
name|internalWinId
argument_list|()
operator|&&
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|createWinId
argument_list|()
expr_stmt|;
if|if
condition|(
name|isEnabled
argument_list|()
operator|&&
name|focusWidget
operator|->
name|isEnabled
argument_list|()
operator|&&
name|focusWidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_IM
break|break;
block|}
case|case
name|Qt
operator|::
name|WA_PaintOnScreen
case|:
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
comment|// Recreate the widget if it's already created as an alien widget and
comment|// WA_PaintOnScreen is enabled. Paint on screen widgets must have win id.
comment|// So must their children.
if|if
condition|(
name|on
condition|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|enforceNativeChildren
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// fall through
case|case
name|Qt
operator|::
name|WA_OpaquePaintEvent
case|:
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_NoSystemBackground
case|:
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
comment|// fall through...
case|case
name|Qt
operator|::
name|WA_UpdatesDisabled
case|:
name|d
operator|->
name|updateSystemBackground
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_TransparentForMouseEvents
case|:
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|d
operator|->
name|macUpdateIgnoreMouseEvents
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|Qt
operator|::
name|WA_InputMethodEnabled
case|:
block|{
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|qApp
operator|->
name|focusObject
argument_list|()
operator|==
name|this
condition|)
block|{
if|if
condition|(
operator|!
name|on
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImEnabled
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_IM
break|break;
block|}
case|case
name|Qt
operator|::
name|WA_WindowPropagation
case|:
name|d
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
name|d
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
name|d
operator|->
name|resolveLocale
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|Q_WS_X11
case|case
name|Qt
operator|::
name|WA_NoX11EventCompression
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|extra
condition|)
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|compress_events
operator|=
name|on
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_X11OpenGLOverlay
case|:
name|d
operator|->
name|updateIsOpaque
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WA_X11DoNotAcceptFocus
case|:
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|updateX11AcceptFocus
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|WA_DontShowOnScreen
case|:
block|{
if|if
condition|(
name|on
operator|&&
name|isVisible
argument_list|()
condition|)
block|{
comment|// Make sure we keep the current state and only hide the widget
comment|// from the desktop. show_sys will only update platform specific
comment|// attributes at this point.
name|d
operator|->
name|hide_sys
argument_list|()
expr_stmt|;
name|d
operator|->
name|show_sys
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|Q_WS_X11
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeDesktop
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeDock
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeToolBar
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeMenu
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeUtility
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeSplash
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeDialog
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeDropDownMenu
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypePopupMenu
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeToolTip
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeNotification
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeCombo
case|:
case|case
name|Qt
operator|::
name|WA_X11NetWmWindowTypeDND
case|:
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|setNetWmWindowTypes
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|WA_StaticContents
case|:
if|if
condition|(
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|d
operator|->
name|maybeBackingStore
argument_list|()
condition|)
block|{
if|if
condition|(
name|on
condition|)
name|bs
operator|->
name|addStaticWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|bs
operator|->
name|removeStaticWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|WA_TranslucentBackground
case|:
if|if
condition|(
name|on
condition|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateIsTranslucent
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|WA_AcceptTouchEvents
case|:
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|on
condition|)
name|d
operator|->
name|registerTouchWindow
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
block|}
comment|/*! \fn bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const    Returns true if attribute \a attribute is set on this widget;   otherwise returns false.    \sa setAttribute()  */
DECL|function|testAttribute_helper
name|bool
name|QWidget
operator|::
name|testAttribute_helper
parameter_list|(
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
specifier|const
name|int
name|x
init|=
name|attribute
operator|-
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
specifier|const
name|int
name|int_off
init|=
name|x
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|d
operator|->
name|high_attributes
index|[
name|int_off
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|-
operator|(
name|int_off
operator|*
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
comment|/*!   \property QWidget::windowOpacity    \brief The level of opacity for the window.    The valid range of opacity is from 1.0 (completely opaque) to   0.0 (completely transparent).    By default the value of this property is 1.0.    This feature is available on Embedded Linux, Mac OS X, Windows,   and X11 platforms that support the Composite extension.    This feature is not available on Windows CE.    Note that under X11 you need to have a composite manager running,   and the X11 specific _NET_WM_WINDOW_OPACITY atom needs to be   supported by the window manager you are using.    \warning Changing this property from opaque to transparent might issue a   paint event that needs to be processed before the window is displayed   correctly. This affects mainly the use of QPixmap::grabWindow(). Also note   that semi-transparent windows update and resize significantly slower than   opaque windows.    \sa setMask() */
DECL|function|windowOpacity
name|qreal
name|QWidget
operator|::
name|windowOpacity
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
operator|(
name|isWindow
argument_list|()
operator|&&
name|d
operator|->
name|maybeTopData
argument_list|()
operator|)
condition|?
name|d
operator|->
name|maybeTopData
argument_list|()
operator|->
name|opacity
operator|/
literal|255.
else|:
literal|1.0
return|;
block|}
DECL|function|setWindowOpacity
name|void
name|QWidget
operator|::
name|setWindowOpacity
parameter_list|(
name|qreal
name|opacity
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
return|return;
name|opacity
operator|=
name|qBound
argument_list|(
name|qreal
argument_list|(
literal|0.0
argument_list|)
argument_list|,
name|opacity
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|QTLWExtra
modifier|*
name|extra
init|=
name|d
operator|->
name|topData
argument_list|()
decl_stmt|;
name|extra
operator|->
name|opacity
operator|=
name|uint
argument_list|(
name|opacity
operator|*
literal|255
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_WindowOpacitySet
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWindowOpacity_sys
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
if|if
condition|(
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|graphicsProxyWidget
argument_list|()
condition|)
block|{
comment|// Avoid invalidating the cache if set.
if|if
condition|(
name|proxy
operator|->
name|cacheMode
argument_list|()
operator|==
name|QGraphicsItem
operator|::
name|NoCache
condition|)
name|proxy
operator|->
name|update
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scene
init|=
name|proxy
operator|->
name|scene
argument_list|()
condition|)
name|scene
operator|->
name|update
argument_list|(
name|proxy
operator|->
name|sceneBoundingRect
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
comment|/*!     \property QWidget::windowModified     \brief whether the document shown in the window has unsaved changes      A modified window is a window whose content has changed but has     not been saved to disk. This flag will have different effects     varied by the platform. On Mac OS X the close button will have a     modified look; on other platforms, the window title will have an     '*' (asterisk).      The window title must contain a "[*]" placeholder, which     indicates where the '*' should appear. Normally, it should appear     right after the file name (e.g., "document1.txt[*] - Text     Editor"). If the window isn't modified, the placeholder is simply     removed.      Note that if a widget is set as modified, all its ancestors will     also be set as modified. However, if you call \c     {setWindowModified(false)} on a widget, this will not propagate to     its parent because other children of the parent might have been     modified.      \sa windowTitle, {Application Example}, {SDI Example}, {MDI Example} */
DECL|function|isWindowModified
name|bool
name|QWidget
operator|::
name|isWindowModified
parameter_list|()
specifier|const
block|{
return|return
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowModified
argument_list|)
return|;
block|}
DECL|function|setWindowModified
name|void
name|QWidget
operator|::
name|setWindowModified
parameter_list|(
name|bool
name|mod
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowModified
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|d
operator|->
name|setWindowModified_helper
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ModifiedChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
DECL|function|setWindowModified_helper
name|void
name|QWidgetPrivate
operator|::
name|setWindowModified_helper
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QWindow
modifier|*
name|window
init|=
name|q
operator|->
name|windowHandle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|QPlatformWindow
modifier|*
name|platformWindow
init|=
name|window
operator|->
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|platformWindow
condition|)
return|return;
name|bool
name|on
init|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WindowModified
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|platformWindow
operator|->
name|setWindowModified
argument_list|(
name|on
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|q
operator|->
name|windowTitle
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"[*]"
argument_list|)
argument_list|)
operator|&&
name|on
condition|)
name|qWarning
argument_list|(
literal|"QWidget::setWindowModified: The window title does not contain a '[*]' placeholder"
argument_list|)
expr_stmt|;
name|setWindowTitle_helper
argument_list|(
name|q
operator|->
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
name|setWindowIconText_helper
argument_list|(
name|q
operator|->
name|windowIconText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_TOOLTIP
comment|/*!   \property QWidget::toolTip    \brief the widget's tooltip    Note that by default tooltips are only shown for widgets that are   children of the active window. You can change this behavior by   setting the attribute Qt::WA_AlwaysShowToolTips on the \e window,   not on the widget with the tooltip.    If you want to control a tooltip's behavior, you can intercept the   event() function and catch the QEvent::ToolTip event (e.g., if you   want to customize the area for which the tooltip should be shown).    By default, this property contains an empty string.    \sa QToolTip, statusTip, whatsThis */
DECL|function|setToolTip
name|void
name|QWidget
operator|::
name|setToolTip
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|toolTip
operator|=
name|s
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|ToolTipChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
DECL|function|toolTip
name|QString
name|QWidget
operator|::
name|toolTip
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|toolTip
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_TOOLTIP
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
comment|/*!   \property QWidget::statusTip   \brief the widget's status tip    By default, this property contains an empty string.    \sa toolTip, whatsThis */
DECL|function|setStatusTip
name|void
name|QWidget
operator|::
name|setStatusTip
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|statusTip
operator|=
name|s
expr_stmt|;
block|}
DECL|function|statusTip
name|QString
name|QWidget
operator|::
name|statusTip
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|statusTip
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_STATUSTIP
ifndef|#
directive|ifndef
name|QT_NO_WHATSTHIS
comment|/*!   \property QWidget::whatsThis    \brief the widget's What's This help text.    By default, this property contains an empty string.    \sa QWhatsThis, QWidget::toolTip, QWidget::statusTip */
DECL|function|setWhatsThis
name|void
name|QWidget
operator|::
name|setWhatsThis
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|whatsThis
operator|=
name|s
expr_stmt|;
block|}
DECL|function|whatsThis
name|QString
name|QWidget
operator|::
name|whatsThis
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|whatsThis
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_WHATSTHIS
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
comment|/*!   \property QWidget::accessibleName    \brief the widget's name as seen by assistive technologies    This property is used by accessible clients to identify, find, or announce   the widget for accessible clients.    By default, this property contains an empty string.    \sa QAccessibleInterface::text() */
DECL|function|setAccessibleName
name|void
name|QWidget
operator|::
name|setAccessibleName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|accessibleName
operator|=
name|name
expr_stmt|;
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|NameChanged
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
DECL|function|accessibleName
name|QString
name|QWidget
operator|::
name|accessibleName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|accessibleName
return|;
block|}
comment|/*!   \property QWidget::accessibleDescription    \brief the widget's description as seen by assistive technologies    By default, this property contains an empty string.    \sa QAccessibleInterface::text() */
DECL|function|setAccessibleDescription
name|void
name|QWidget
operator|::
name|setAccessibleDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|accessibleDescription
operator|=
name|description
expr_stmt|;
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|DescriptionChanged
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
DECL|function|accessibleDescription
name|QString
name|QWidget
operator|::
name|accessibleDescription
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|accessibleDescription
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_ACCESSIBILITY
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
comment|/*!     Adds a shortcut to Qt's shortcut system that watches for the given     \a key sequence in the given \a context. If the \a context is     Qt::ApplicationShortcut, the shortcut applies to the application as a     whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut,     or to the window itself, Qt::WindowShortcut.      If the same \a key sequence has been grabbed by several widgets,     when the \a key sequence occurs a QEvent::Shortcut event is sent     to all the widgets to which it applies in a non-deterministic     order, but with the ``ambiguous'' flag set to true.      \warning You should not normally need to use this function;     instead create \l{QAction}s with the shortcut key sequences you     require (if you also want equivalent menu options and toolbar     buttons), or create \l{QShortcut}s if you just need key sequences.     Both QAction and QShortcut handle all the event filtering for you,     and provide signals which are triggered when the user triggers the     key sequence, so are much easier to use than this low-level     function.      \sa releaseShortcut(), setShortcutEnabled() */
DECL|function|grabShortcut
name|int
name|QWidget
operator|::
name|grabShortcut
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|,
name|Qt
operator|::
name|ShortcutContext
name|context
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_GrabbedShortcut
argument_list|)
expr_stmt|;
return|return
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|addShortcut
argument_list|(
name|this
argument_list|,
name|key
argument_list|,
name|context
argument_list|,
name|qWidgetShortcutContextMatcher
argument_list|)
return|;
block|}
comment|/*!     Removes the shortcut with the given \a id from Qt's shortcut     system. The widget will no longer receive QEvent::Shortcut events     for the shortcut's key sequence (unless it has other shortcuts     with the same key sequence).      \warning You should not normally need to use this function since     Qt's shortcut system removes shortcuts automatically when their     parent widget is destroyed. It is best to use QAction or     QShortcut to handle shortcuts, since they are easier to use than     this low-level function. Note also that this is an expensive     operation.      \sa grabShortcut(), setShortcutEnabled() */
DECL|function|releaseShortcut
name|void
name|QWidget
operator|::
name|releaseShortcut
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|removeShortcut
argument_list|(
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*!     If \a enable is true, the shortcut with the given \a id is     enabled; otherwise the shortcut is disabled.      \warning You should not normally need to use this function since     Qt's shortcut system enables/disables shortcuts automatically as     widgets become hidden/visible and gain or lose focus. It is best     to use QAction or QShortcut to handle shortcuts, since they are     easier to use than this low-level function.      \sa grabShortcut(), releaseShortcut() */
DECL|function|setShortcutEnabled
name|void
name|QWidget
operator|::
name|setShortcutEnabled
parameter_list|(
name|int
name|id
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|setShortcutEnabled
argument_list|(
name|enable
argument_list|,
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*!     \since 4.2      If \a enable is true, auto repeat of the shortcut with the     given \a id is enabled; otherwise it is disabled.      \sa grabShortcut(), releaseShortcut() */
DECL|function|setShortcutAutoRepeat
name|void
name|QWidget
operator|::
name|setShortcutAutoRepeat
parameter_list|(
name|int
name|id
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|setShortcutAutoRepeat
argument_list|(
name|enable
argument_list|,
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_SHORTCUT
comment|/*!     Updates the widget's micro focus. */
DECL|function|updateMicroFocus
name|void
name|QWidget
operator|::
name|updateMicroFocus
parameter_list|()
block|{
comment|// updating everything since this is currently called for any kind of state change
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImQueryAll
argument_list|)
expr_stmt|;
block|}
comment|/*!     Raises this widget to the top of the parent widget's stack.      After this call the widget will be visually in front of any     overlapping sibling widgets.      \note When using activateWindow(), you can call this function to     ensure that the window is stacked on top.      \sa lower(), stackUnder() */
DECL|function|raise
name|void
name|QWidget
operator|::
name|raise
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|p
init|=
name|parentWidget
argument_list|()
decl_stmt|;
specifier|const
name|int
name|parentChildCount
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentChildCount
operator|<
literal|2
condition|)
return|return;
specifier|const
name|int
name|from
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|from
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Do nothing if the widget is already in correct stacking order _and_ created.
if|if
condition|(
name|from
operator|!=
name|parentChildCount
operator|-
literal|1
condition|)
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|move
argument_list|(
name|from
argument_list|,
name|parentChildCount
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|p
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|create
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|parentChildCount
operator|-
literal|1
condition|)
return|return;
name|QRegion
name|region
argument_list|(
name|rect
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|subtractOpaqueSiblings
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|d
operator|->
name|invalidateBuffer
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|raise_sys
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ZOrderChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     Lowers the widget to the bottom of the parent widget's stack.      After this call the widget will be visually behind (and therefore     obscured by) any overlapping sibling widgets.      \sa raise(), stackUnder() */
DECL|function|lower
name|void
name|QWidget
operator|::
name|lower
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|p
init|=
name|parentWidget
argument_list|()
decl_stmt|;
specifier|const
name|int
name|parentChildCount
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentChildCount
operator|<
literal|2
condition|)
return|return;
specifier|const
name|int
name|from
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|from
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// Do nothing if the widget is already in correct stacking order _and_ created.
if|if
condition|(
name|from
operator|!=
literal|0
condition|)
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|move
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|p
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|create
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|lower_sys
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ZOrderChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     Places the widget under \a w in the parent widget's stack.      To make this work, the widget itself and \a w must be siblings.      \sa raise(), lower() */
DECL|function|stackUnder
name|void
name|QWidget
operator|::
name|stackUnder
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|p
init|=
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|||
name|isWindow
argument_list|()
operator|||
name|p
operator|!=
name|w
operator|->
name|parentWidget
argument_list|()
operator|||
name|this
operator|==
name|w
condition|)
return|return;
if|if
condition|(
name|p
condition|)
block|{
name|int
name|from
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|to
init|=
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|indexOf
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|from
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|to
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|to
condition|)
operator|--
name|to
expr_stmt|;
comment|// Do nothing if the widget is already in correct stacking order _and_ created.
if|if
condition|(
name|from
operator|!=
name|to
condition|)
name|p
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|move
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
operator|&&
name|p
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|create
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return;
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|d
operator|->
name|stackUnder_sys
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ZOrderChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|/*!     \fn bool QWidget::isTopLevel() const     \obsolete      Use isWindow() instead. */
comment|/*!     \fn bool QWidget::isRightToLeft() const     \internal */
comment|/*!     \fn bool QWidget::isLeftToRight() const     \internal */
comment|/*!      \macro QWIDGETSIZE_MAX      \relates QWidget       Defines the maximum size for a QWidget object.       The largest allowed size for a widget is QSize(QWIDGETSIZE_MAX,      QWIDGETSIZE_MAX), i.e. QSize (16777215,16777215).       \sa QWidget::setMaximumSize() */
comment|/*!     \fn QWidget::setupUi(QWidget *widget)      Sets up the user interface for the specified \a widget.      \note This function is available with widgets that derive from user     interface descriptions created using \l{uic}.      \sa {Using a Designer UI File in Your Application} */
DECL|function|frameStrut
name|QRect
name|QWidgetPrivate
operator|::
name|frameStrut
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|||
operator|(
name|q
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|||
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontShowOnScreen
argument_list|)
condition|)
block|{
comment|// x2 = x1 + w - 1, so w/h = 1
return|return
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|data
operator|.
name|fstrut_dirty
ifndef|#
directive|ifndef
name|Q_WS_WIN
comment|// ### Fix properly for 4.3
operator|&&
name|q
operator|->
name|isVisible
argument_list|()
endif|#
directive|endif
operator|&&
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
cast|const_cast
argument_list|<
name|QWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateFrameStrut
argument_list|()
expr_stmt|;
return|return
name|maybeTopData
argument_list|()
condition|?
name|maybeTopData
argument_list|()
operator|->
name|frameStrut
else|:
name|QRect
argument_list|()
return|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|/*!     \internal      Changes the focus  from the current focusWidget to a widget in     the \a direction.      Returns true, if there was a widget in that direction */
DECL|function|navigateToDirection
name|bool
name|QWidgetPrivate
operator|::
name|navigateToDirection
parameter_list|(
name|Direction
name|direction
parameter_list|)
block|{
name|QWidget
modifier|*
name|targetWidget
init|=
name|widgetInNavigationDirection
argument_list|(
name|direction
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetWidget
condition|)
name|targetWidget
operator|->
name|setFocus
argument_list|()
expr_stmt|;
return|return
operator|(
name|targetWidget
operator|!=
literal|0
operator|)
return|;
block|}
comment|/*!     \internal      Searches for a widget that is positioned in the \a direction, starting     from the current focusWidget.      Returns the pointer to a found widget or 0, if there was no widget in     that direction. */
DECL|function|widgetInNavigationDirection
name|QWidget
modifier|*
name|QWidgetPrivate
operator|::
name|widgetInNavigationDirection
parameter_list|(
name|Direction
name|direction
parameter_list|)
block|{
specifier|const
name|QWidget
modifier|*
name|sourceWidget
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceWidget
condition|)
return|return
literal|0
return|;
specifier|const
name|QRect
name|sourceRect
init|=
name|sourceWidget
operator|->
name|rect
argument_list|()
operator|.
name|translated
argument_list|(
name|sourceWidget
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|sourceX
init|=
operator|(
name|direction
operator|==
name|DirectionNorth
operator|||
name|direction
operator|==
name|DirectionSouth
operator|)
condition|?
operator|(
name|sourceRect
operator|.
name|left
argument_list|()
operator|+
operator|(
name|sourceRect
operator|.
name|right
argument_list|()
operator|-
name|sourceRect
operator|.
name|left
argument_list|()
operator|)
operator|/
literal|2
operator|)
else|:
operator|(
name|direction
operator|==
name|DirectionEast
condition|?
name|sourceRect
operator|.
name|right
argument_list|()
else|:
name|sourceRect
operator|.
name|left
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|int
name|sourceY
init|=
operator|(
name|direction
operator|==
name|DirectionEast
operator|||
name|direction
operator|==
name|DirectionWest
operator|)
condition|?
operator|(
name|sourceRect
operator|.
name|top
argument_list|()
operator|+
operator|(
name|sourceRect
operator|.
name|bottom
argument_list|()
operator|-
name|sourceRect
operator|.
name|top
argument_list|()
operator|)
operator|/
literal|2
operator|)
else|:
operator|(
name|direction
operator|==
name|DirectionSouth
condition|?
name|sourceRect
operator|.
name|bottom
argument_list|()
else|:
name|sourceRect
operator|.
name|top
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|QPoint
name|sourcePoint
argument_list|(
name|sourceX
argument_list|,
name|sourceY
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|sourceCenter
init|=
name|sourceRect
operator|.
name|center
argument_list|()
decl_stmt|;
specifier|const
name|QWidget
modifier|*
name|sourceWindow
init|=
name|sourceWidget
operator|->
name|window
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|targetWidget
init|=
literal|0
decl_stmt|;
name|int
name|shortestDistance
init|=
name|INT_MAX
decl_stmt|;
foreach|foreach
control|(
name|QWidget
modifier|*
name|targetCandidate
decl|,
name|QApplication
operator|::
name|allWidgets
argument_list|()
control|)
block|{
specifier|const
name|QRect
name|targetCandidateRect
init|=
name|targetCandidate
operator|->
name|rect
argument_list|()
operator|.
name|translated
argument_list|(
name|targetCandidate
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// For focus proxies, the child widget handling the focus can have keypad navigation focus,
comment|// but the owner of the proxy cannot.
comment|// Additionally, empty widgets should be ignored.
if|if
condition|(
name|targetCandidate
operator|->
name|focusProxy
argument_list|()
operator|||
name|targetCandidateRect
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|// Only navigate to a target widget that...
if|if
condition|(
name|targetCandidate
operator|!=
name|sourceWidget
comment|// ...takes the focus,
operator|&&
name|targetCandidate
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|TabFocus
comment|// ...is above if DirectionNorth,
operator|&&
operator|!
operator|(
name|direction
operator|==
name|DirectionNorth
operator|&&
name|targetCandidateRect
operator|.
name|bottom
argument_list|()
operator|>
name|sourceRect
operator|.
name|top
argument_list|()
operator|)
comment|// ...is on the right if DirectionEast,
operator|&&
operator|!
operator|(
name|direction
operator|==
name|DirectionEast
operator|&&
name|targetCandidateRect
operator|.
name|left
argument_list|()
operator|<
name|sourceRect
operator|.
name|right
argument_list|()
operator|)
comment|// ...is below if DirectionSouth,
operator|&&
operator|!
operator|(
name|direction
operator|==
name|DirectionSouth
operator|&&
name|targetCandidateRect
operator|.
name|top
argument_list|()
operator|<
name|sourceRect
operator|.
name|bottom
argument_list|()
operator|)
comment|// ...is on the left if DirectionWest,
operator|&&
operator|!
operator|(
name|direction
operator|==
name|DirectionWest
operator|&&
name|targetCandidateRect
operator|.
name|right
argument_list|()
operator|>
name|sourceRect
operator|.
name|left
argument_list|()
operator|)
comment|// ...is enabled,
operator|&&
name|targetCandidate
operator|->
name|isEnabled
argument_list|()
comment|// ...is visible,
operator|&&
name|targetCandidate
operator|->
name|isVisible
argument_list|()
comment|// ...is in the same window,
operator|&&
name|targetCandidate
operator|->
name|window
argument_list|()
operator|==
name|sourceWindow
condition|)
block|{
specifier|const
name|int
name|targetCandidateDistance
init|=
name|pointToRect
argument_list|(
name|sourcePoint
argument_list|,
name|targetCandidateRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetCandidateDistance
operator|<
name|shortestDistance
condition|)
block|{
name|shortestDistance
operator|=
name|targetCandidateDistance
expr_stmt|;
name|targetWidget
operator|=
name|targetCandidate
expr_stmt|;
block|}
block|}
block|}
return|return
name|targetWidget
return|;
block|}
comment|/*!     \internal      Tells us if it there is currently a reachable widget by keypad navigation in     a certain \a orientation.     If no navigation is possible, occurring key events in that \a orientation may     be used to interact with the value in the focused widget, even though it     currently has not the editFocus.      \sa QWidgetPrivate::widgetInNavigationDirection(), QWidget::hasEditFocus() */
DECL|function|canKeypadNavigate
name|bool
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
operator|(
name|QWidgetPrivate
operator|::
name|widgetInNavigationDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionEast
argument_list|)
operator|||
name|QWidgetPrivate
operator|::
name|widgetInNavigationDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionWest
argument_list|)
operator|)
else|:
operator|(
name|QWidgetPrivate
operator|::
name|widgetInNavigationDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionNorth
argument_list|)
operator|||
name|QWidgetPrivate
operator|::
name|widgetInNavigationDirection
argument_list|(
name|QWidgetPrivate
operator|::
name|DirectionSouth
argument_list|)
operator|)
return|;
block|}
comment|/*!     \internal      Checks, if the \a widget is inside a QTabWidget. If is is inside     one, left/right key events will be used to switch between tabs in keypad     navigation. If there is no QTabWidget, the horizontal key events can be used to     interact with the value in the focused widget, even though it currently has     not the editFocus.      \sa QWidget::hasEditFocus() */
DECL|function|inTabWidget
name|bool
name|QWidgetPrivate
operator|::
name|inTabWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
for|for
control|(
name|QWidget
modifier|*
name|tabWidget
init|=
name|widget
init|;
name|tabWidget
condition|;
name|tabWidget
operator|=
name|tabWidget
operator|->
name|parentWidget
argument_list|()
control|)
if|if
condition|(
name|qobject_cast
argument_list|<
specifier|const
name|QTabWidget
operator|*
argument_list|>
argument_list|(
name|tabWidget
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|/*!     \since 5.0     \internal      Sets the backing store to be the \a store specified.     The QWidget will take ownership of the \a store. */
DECL|function|setBackingStore
name|void
name|QWidget
operator|::
name|setBackingStore
parameter_list|(
name|QBackingStore
modifier|*
name|store
parameter_list|)
block|{
comment|// ### createWinId() ??
if|if
condition|(
operator|!
name|isTopLevel
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QTLWExtra
modifier|*
name|topData
init|=
name|d
operator|->
name|topData
argument_list|()
decl_stmt|;
if|if
condition|(
name|topData
operator|->
name|backingStore
operator|==
name|store
condition|)
return|return;
name|QBackingStore
modifier|*
name|oldStore
init|=
name|topData
operator|->
name|backingStore
decl_stmt|;
operator|delete
name|topData
operator|->
name|backingStore
expr_stmt|;
name|topData
operator|->
name|backingStore
operator|=
name|store
expr_stmt|;
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|d
operator|->
name|maybeBackingStore
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bs
condition|)
return|return;
if|if
condition|(
name|isTopLevel
argument_list|()
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|store
operator|!=
name|oldStore
operator|&&
name|bs
operator|->
name|store
operator|!=
name|store
condition|)
operator|delete
name|bs
operator|->
name|store
expr_stmt|;
name|bs
operator|->
name|store
operator|=
name|store
expr_stmt|;
block|}
block|}
comment|/*!     \since 5.0      Returns the QBackingStore this widget will be drawn into. */
DECL|function|backingStore
name|QBackingStore
modifier|*
name|QWidget
operator|::
name|backingStore
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
name|QTLWExtra
modifier|*
name|extra
init|=
name|d
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|extra
operator|&&
name|extra
operator|->
name|backingStore
condition|)
return|return
name|extra
operator|->
name|backingStore
return|;
name|QWidgetBackingStore
modifier|*
name|bs
init|=
name|d
operator|->
name|maybeBackingStore
argument_list|()
decl_stmt|;
return|return
name|bs
condition|?
name|bs
operator|->
name|store
else|:
literal|0
return|;
block|}
DECL|function|getLayoutItemMargins
name|void
name|QWidgetPrivate
operator|::
name|getLayoutItemMargins
parameter_list|(
name|int
modifier|*
name|left
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|right
parameter_list|,
name|int
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
operator|(
name|int
operator|)
name|leftLayoutItemMargin
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
operator|(
name|int
operator|)
name|topLayoutItemMargin
expr_stmt|;
if|if
condition|(
name|right
condition|)
operator|*
name|right
operator|=
operator|(
name|int
operator|)
name|rightLayoutItemMargin
expr_stmt|;
if|if
condition|(
name|bottom
condition|)
operator|*
name|bottom
operator|=
operator|(
name|int
operator|)
name|bottomLayoutItemMargin
expr_stmt|;
block|}
DECL|function|setLayoutItemMargins
name|void
name|QWidgetPrivate
operator|::
name|setLayoutItemMargins
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
if|if
condition|(
name|leftLayoutItemMargin
operator|==
name|left
operator|&&
name|topLayoutItemMargin
operator|==
name|top
operator|&&
name|rightLayoutItemMargin
operator|==
name|right
operator|&&
name|bottomLayoutItemMargin
operator|==
name|bottom
condition|)
return|return;
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|leftLayoutItemMargin
operator|=
operator|(
name|signed
name|char
operator|)
name|left
expr_stmt|;
name|topLayoutItemMargin
operator|=
operator|(
name|signed
name|char
operator|)
name|top
expr_stmt|;
name|rightLayoutItemMargin
operator|=
operator|(
name|signed
name|char
operator|)
name|right
expr_stmt|;
name|bottomLayoutItemMargin
operator|=
operator|(
name|signed
name|char
operator|)
name|bottom
expr_stmt|;
name|q
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
DECL|function|setLayoutItemMargins
name|void
name|QWidgetPrivate
operator|::
name|setLayoutItemMargins
parameter_list|(
name|QStyle
operator|::
name|SubElement
name|element
parameter_list|,
specifier|const
name|QStyleOption
modifier|*
name|opt
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|QStyleOption
name|myOpt
decl_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
block|{
name|myOpt
operator|.
name|initFrom
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|myOpt
operator|.
name|rect
operator|.
name|setRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|32768
argument_list|,
literal|32768
argument_list|)
expr_stmt|;
comment|// arbitrary
name|opt
operator|=
operator|&
name|myOpt
expr_stmt|;
block|}
name|QRect
name|liRect
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|subElementRect
argument_list|(
name|element
argument_list|,
name|opt
argument_list|,
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|liRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|leftLayoutItemMargin
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|opt
operator|->
name|rect
operator|.
name|left
argument_list|()
operator|-
name|liRect
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|topLayoutItemMargin
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|opt
operator|->
name|rect
operator|.
name|top
argument_list|()
operator|-
name|liRect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|rightLayoutItemMargin
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|liRect
operator|.
name|right
argument_list|()
operator|-
name|opt
operator|->
name|rect
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|bottomLayoutItemMargin
operator|=
call|(
name|signed
name|char
call|)
argument_list|(
name|liRect
operator|.
name|bottom
argument_list|()
operator|-
name|opt
operator|->
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftLayoutItemMargin
operator|=
literal|0
expr_stmt|;
name|topLayoutItemMargin
operator|=
literal|0
expr_stmt|;
name|rightLayoutItemMargin
operator|=
literal|0
expr_stmt|;
name|bottomLayoutItemMargin
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// resets the Qt::WA_QuitOnClose attribute to the default value for transient widgets.
DECL|function|adjustQuitOnCloseAttribute
name|void
name|QWidgetPrivate
operator|::
name|adjustQuitOnCloseAttribute
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
name|Qt
operator|::
name|WindowType
name|type
init|=
name|q
operator|->
name|windowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Qt
operator|::
name|Widget
operator|||
name|type
operator|==
name|Qt
operator|::
name|SubWindow
condition|)
name|type
operator|=
name|Qt
operator|::
name|Window
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|Qt
operator|::
name|Widget
operator|&&
name|type
operator|!=
name|Qt
operator|::
name|Window
operator|&&
name|type
operator|!=
name|Qt
operator|::
name|Dialog
condition|)
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_QuitOnClose
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|qt_qwidget_data
name|Q_WIDGETS_EXPORT
name|QWidgetData
modifier|*
name|qt_qwidget_data
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
return|return
name|widget
operator|->
name|data
return|;
block|}
DECL|function|qt_widget_private
name|Q_WIDGETS_EXPORT
name|QWidgetPrivate
modifier|*
name|qt_widget_private
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
return|return
name|widget
operator|->
name|d_func
argument_list|()
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|/*!    \since 4.5     Returns the proxy widget for the corresponding embedded widget in a graphics    view; otherwise returns 0.     \sa QGraphicsProxyWidget::createProxyForChildWidget(),        QGraphicsScene::addWidget()  */
DECL|function|graphicsProxyWidget
name|QGraphicsProxyWidget
modifier|*
name|QWidget
operator|::
name|graphicsProxyWidget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extra
condition|)
block|{
return|return
name|d
operator|->
name|extra
operator|->
name|proxyWidget
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
comment|/*!     Subscribes the widget to a given \a gesture with specific \a flags.      \sa ungrabGesture(), QGestureEvent     \since 4.6 */
DECL|function|grabGesture
name|void
name|QWidget
operator|::
name|grabGesture
parameter_list|(
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|,
name|Qt
operator|::
name|GestureFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|gestureContext
operator|.
name|insert
argument_list|(
name|gesture
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QGestureManager
operator|::
name|instance
argument_list|()
expr_stmt|;
comment|// create a gesture manager
block|}
comment|/*!     Unsubscribes the widget from a given \a gesture type      \sa grabGesture(), QGestureEvent     \since 4.6 */
DECL|function|ungrabGesture
name|void
name|QWidget
operator|::
name|ungrabGesture
parameter_list|(
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|gestureContext
operator|.
name|remove
argument_list|(
name|gesture
argument_list|)
condition|)
block|{
if|if
condition|(
name|QGestureManager
modifier|*
name|manager
init|=
name|QGestureManager
operator|::
name|instance
argument_list|()
condition|)
name|manager
operator|->
name|cleanupCachedGestures
argument_list|(
name|this
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
comment|/*!     \fn void QWidget::destroy(bool destroyWindow, bool destroySubWindows)      Frees up window system resources. Destroys the widget window if \a     destroyWindow is true.      destroy() calls itself recursively for all the child widgets,     passing \a destroySubWindows for the \a destroyWindow parameter.     To have more control over destruction of subwidgets, destroy     subwidgets selectively first.      This function is usually called from the QWidget destructor. */
comment|/*!     \fn QPaintEngine *QWidget::paintEngine() const      Returns the widget's paint engine.      Note that this function should not be called explicitly by the     user, since it's meant for reimplementation purposes only. The     function is called by Qt internally, and the default     implementation may not always return a valid pointer. */
comment|/*!     \fn QPoint QWidget::mapToGlobal(const QPoint&pos) const      Translates the widget coordinate \a pos to global screen     coordinates. For example, \c{mapToGlobal(QPoint(0,0))} would give     the global coordinates of the top-left pixel of the widget.      \sa mapFromGlobal(), mapTo(), mapToParent() */
comment|/*!     \fn QPoint QWidget::mapFromGlobal(const QPoint&pos) const      Translates the global screen coordinate \a pos to widget     coordinates.      \sa mapToGlobal(), mapFrom(), mapFromParent() */
comment|/*!     \fn void QWidget::grabMouse()      Grabs the mouse input.      This widget receives all mouse events until releaseMouse() is     called; other widgets get no mouse events at all. Keyboard     events are not affected. Use grabKeyboard() if you want to grab     that.      \warning Bugs in mouse-grabbing applications very often lock the     terminal. Use this function with extreme caution, and consider     using the \c -nograb command line option while debugging.      It is almost never necessary to grab the mouse when using Qt, as     Qt grabs and releases it sensibly. In particular, Qt grabs the     mouse when a mouse button is pressed and keeps it until the last     button is released.      \note Only visible widgets can grab mouse input. If isVisible()     returns false for a widget, that widget cannot call grabMouse().      \note \b{(Mac OS X developers)} For \e Cocoa, calling     grabMouse() on a widget only works when the mouse is inside the     frame of that widget.  For \e Carbon, it works outside the widget's     frame as well, like for Windows and X11.      \sa releaseMouse(), grabKeyboard(), releaseKeyboard() */
comment|/*!     \fn void QWidget::grabMouse(const QCursor&cursor)     \overload grabMouse()      Grabs the mouse input and changes the cursor shape.      The cursor will assume shape \a cursor (for as long as the mouse     focus is grabbed) and this widget will be the only one to receive     mouse events until releaseMouse() is called().      \warning Grabbing the mouse might lock the terminal.      \note \b{(Mac OS X developers)} See the note in QWidget::grabMouse().      \sa releaseMouse(), grabKeyboard(), releaseKeyboard(), setCursor() */
comment|/*!     \fn void QWidget::releaseMouse()      Releases the mouse grab.      \sa grabMouse(), grabKeyboard(), releaseKeyboard() */
comment|/*!     \fn void QWidget::grabKeyboard()      Grabs the keyboard input.      This widget receives all keyboard events until releaseKeyboard()     is called; other widgets get no keyboard events at all. Mouse     events are not affected. Use grabMouse() if you want to grab that.      The focus widget is not affected, except that it doesn't receive     any keyboard events. setFocus() moves the focus as usual, but the     new focus widget receives keyboard events only after     releaseKeyboard() is called.      If a different widget is currently grabbing keyboard input, that     widget's grab is released first.      \sa releaseKeyboard(), grabMouse(), releaseMouse(), focusWidget() */
comment|/*!     \fn void QWidget::releaseKeyboard()      Releases the keyboard grab.      \sa grabKeyboard(), grabMouse(), releaseMouse() */
comment|/*!     \fn QWidget *QWidget::mouseGrabber()      Returns the widget that is currently grabbing the mouse input.      If no widget in this application is currently grabbing the mouse,     0 is returned.      \sa grabMouse(), keyboardGrabber() */
comment|/*!     \fn QWidget *QWidget::keyboardGrabber()      Returns the widget that is currently grabbing the keyboard input.      If no widget in this application is currently grabbing the     keyboard, 0 is returned.      \sa grabMouse(), mouseGrabber() */
comment|/*!     \fn void QWidget::activateWindow()      Sets the top-level widget containing this widget to be the active     window.      An active window is a visible top-level window that has the     keyboard input focus.      This function performs the same operation as clicking the mouse on     the title bar of a top-level window. On X11, the result depends on     the Window Manager. If you want to ensure that the window is     stacked on top as well you should also call raise(). Note that the     window must be visible, otherwise activateWindow() has no effect.      On Windows, if you are calling this when the application is not     currently the active one then it will not make it the active     window.  It will change the color of the taskbar entry to indicate     that the window has changed in some way. This is because Microsoft     does not allow an application to interrupt what the user is currently     doing in another application.      \sa isActiveWindow(), window(), show() */
comment|/*!     \fn int QWidget::metric(PaintDeviceMetric m) const      Internal implementation of the virtual QPaintDevice::metric()     function.      \a m is the metric to get. */
comment|/*!     Initializes the \a painter pen, background and font to the same as     the given widget's. This function is called automatically when the     painter is opened on a QWidget. */
DECL|function|initPainter
name|void
name|QWidget
operator|::
name|initPainter
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|)
specifier|const
block|{
specifier|const
name|QPalette
modifier|&
name|pal
init|=
name|palette
argument_list|()
decl_stmt|;
name|painter
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|->
name|pen
operator|=
name|QPen
argument_list|(
name|pal
operator|.
name|brush
argument_list|(
name|foregroundRole
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|painter
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|->
name|bgBrush
operator|=
name|pal
operator|.
name|brush
argument_list|(
name|backgroundRole
argument_list|()
argument_list|)
expr_stmt|;
name|QFont
name|f
argument_list|(
name|font
argument_list|()
argument_list|,
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|painter
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|->
name|deviceFont
operator|=
name|f
expr_stmt|;
name|painter
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|->
name|font
operator|=
name|f
expr_stmt|;
block|}
DECL|function|redirected
name|QPaintDevice
modifier|*
name|QWidget
operator|::
name|redirected
parameter_list|(
name|QPoint
modifier|*
name|offset
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|redirected
argument_list|(
name|offset
argument_list|)
return|;
block|}
DECL|function|sharedPainter
name|QPainter
modifier|*
name|QWidget
operator|::
name|sharedPainter
parameter_list|()
specifier|const
block|{
comment|// Someone sent a paint event directly to the widget
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|redirectDev
condition|)
return|return
literal|0
return|;
name|QPainter
modifier|*
name|sp
init|=
name|d_func
argument_list|()
operator|->
name|sharedPainter
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sp
operator|||
operator|!
name|sp
operator|->
name|isActive
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sp
operator|->
name|paintEngine
argument_list|()
operator|->
name|paintDevice
argument_list|()
operator|!=
name|d_func
argument_list|()
operator|->
name|redirectDev
condition|)
return|return
literal|0
return|;
return|return
name|sp
return|;
block|}
comment|/*!     \fn void QWidget::setMask(const QRegion&region)     \overload      Causes only the parts of the widget which overlap \a region to be     visible. If the region includes pixels outside the rect() of the     widget, window system controls in that area may or may not be     visible, depending on the platform.      Note that this effect can be slow if the region is particularly     complex.      \sa windowOpacity */
DECL|function|setMask
name|void
name|QWidget
operator|::
name|setMask
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|newMask
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|createExtra
argument_list|()
expr_stmt|;
if|if
condition|(
name|newMask
operator|==
name|d
operator|->
name|extra
operator|->
name|mask
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_BACKINGSTORE
specifier|const
name|QRegion
name|oldMask
argument_list|(
name|d
operator|->
name|extra
operator|->
name|mask
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|d
operator|->
name|extra
operator|->
name|mask
operator|=
name|newMask
expr_stmt|;
name|d
operator|->
name|extra
operator|->
name|hasMask
operator|=
operator|!
name|newMask
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|d
operator|->
name|setMask_sys
argument_list|(
name|newMask
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BACKINGSTORE
if|if
condition|(
operator|!
name|isVisible
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|extra
operator|->
name|hasMask
condition|)
block|{
comment|// Mask was cleared; update newly exposed area.
name|QRegion
name|expose
argument_list|(
name|rect
argument_list|()
argument_list|)
decl_stmt|;
name|expose
operator|-=
name|oldMask
expr_stmt|;
if|if
condition|(
operator|!
name|expose
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|expose
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|isWindow
argument_list|()
condition|)
block|{
comment|// Update newly exposed area on the parent widget.
name|QRegion
name|parentExpose
argument_list|(
name|rect
argument_list|()
argument_list|)
decl_stmt|;
name|parentExpose
operator|-=
name|newMask
expr_stmt|;
if|if
condition|(
operator|!
name|parentExpose
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|setDirtyOpaqueRegion
argument_list|()
expr_stmt|;
name|parentExpose
operator|.
name|translate
argument_list|(
name|data
operator|->
name|crect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|parentWidget
argument_list|()
operator|->
name|update
argument_list|(
name|parentExpose
argument_list|)
expr_stmt|;
block|}
comment|// Update newly exposed area on this widget
if|if
condition|(
operator|!
name|oldMask
operator|.
name|isEmpty
argument_list|()
condition|)
name|update
argument_list|(
name|newMask
operator|-
name|oldMask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*!     \fn void QWidget::setMask(const QBitmap&bitmap)      Causes only the pixels of the widget for which \a bitmap has a     corresponding 1 bit to be visible. If the region includes pixels     outside the rect() of the widget, window system controls in that     area may or may not be visible, depending on the platform.      Note that this effect can be slow if the region is particularly     complex.      The following code shows how an image with an alpha channel can be     used to generate a mask for a widget:      \snippet widget-mask/main.cpp 0      The label shown by this code is masked using the image it contains,     giving the appearance that an irregularly-shaped image is being drawn     directly onto the screen.      Masked widgets receive mouse events only on their visible     portions.      \sa clearMask(), windowOpacity(), {Shaped Clock Example} */
DECL|function|setMask
name|void
name|QWidget
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bitmap
parameter_list|)
block|{
name|setMask
argument_list|(
name|QRegion
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*!     \fn void QWidget::clearMask()      Removes any mask set by setMask().      \sa setMask() */
DECL|function|clearMask
name|void
name|QWidget
operator|::
name|clearMask
parameter_list|()
block|{
name|setMask
argument_list|(
name|QRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
DECL|function|syncUnifiedMode
name|void
name|QWidgetPrivate
operator|::
name|syncUnifiedMode
parameter_list|()
block|{
comment|// The whole purpose of this method is to keep the unifiedToolbar in sync.
comment|// That means making sure we either exchange the drawing methods or we let
comment|// the toolbar know that it does not require to draw the baseline.
name|Q_Q
argument_list|(
name|QWidget
argument_list|)
expr_stmt|;
comment|// This function makes sense only if this is a top level
if|if
condition|(
operator|!
name|q
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
name|OSWindowRef
name|window
init|=
name|qt_mac_window_for
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|changeMethods
condition|)
block|{
comment|// Ok, we are in documentMode.
if|if
condition|(
name|originalDrawMethod
condition|)
name|qt_mac_replaceDrawRect
argument_list|(
name|window
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|originalDrawMethod
condition|)
name|qt_mac_replaceDrawRectOriginal
argument_list|(
name|window
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Q_WS_MAC
name|QT_END_NAMESPACE
end_function
begin_include
include|#
directive|include
file|"moc_qwidget.cpp"
end_include
end_unit
