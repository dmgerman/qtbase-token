begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindowcontainer_p.h"
end_include
begin_include
include|#
directive|include
file|"qwidget_p.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/qwindow.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QWindowContainerPrivate
class|class
name|QWindowContainerPrivate
super|:
specifier|public
name|QWidgetPrivate
block|{
public|public:
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QWindowContainer
argument_list|)
DECL|function|QWindowContainerPrivate
name|QWindowContainerPrivate
parameter_list|()
member_init_list|:
name|window
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|oldFocusWindow
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~QWindowContainerPrivate
name|~
name|QWindowContainerPrivate
parameter_list|()
block|{ }
DECL|member|window
name|QPointer
argument_list|<
name|QWindow
argument_list|>
name|window
decl_stmt|;
DECL|member|oldFocusWindow
name|QWindow
modifier|*
name|oldFocusWindow
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \fn QWidget *QWidget::createWindowContainer(QWindow *window, QWidget *parent, Qt::WindowFlags flags);      Creates a QWidget that makes it possible to embed \a window into     a QWidget-based application.      The window container is created as a child of \a parent and with     window flags \a flags.      Once the window has been embedded into the container, the     container will control the window's geometry and     visibility. Explicit calls to QWindow::setGeometry(),     QWindow::show() or QWindow::hide() on an embedded window is not     recommended.      The container takes over ownership of \a window. The window can     be removed from the window container with a call to     QWindow::setParent().      The window container has a number of known limitations:      \list      \li Stacking order; The embedded window will stack on top of the     widget hierarchy as an opaque box. The stacking order of multiple     overlapping window container instances is undefined.      \li Window Handles; The window container will explicitly invoke     winId() which will force the use of native window handles     inside the application. See \l {Native Widgets vs Alien Widgets}     {QWidget documentation} for more details.      \li Rendering Integration; The window container does not interoperate     with QGraphicsProxyWidget, QWidget::render() or similar functionality.      \li Focus Handling; It is possible to let the window container     instance have any focus policy and it will delegate focus to the     window via a call to QWindow::requestActivate(). However,     returning to the normal focus chain from the QWindow instance will     be up to the QWindow instance implementation itself. For instance,     when entering a Qt Quick based window with tab focus, it is quite     likely that further tab presses will only cycle inside the QML     application. Also, whether QWindow::requestActivate() actually     gives the window focus, is platform dependent.      \li Using many window container instances in a QWidget-based     application can greatly hurt the overall performance of the     application.      \endlist  */
end_comment
begin_function
DECL|function|createWindowContainer
name|QWidget
modifier|*
name|QWidget
operator|::
name|createWindowContainer
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
block|{
return|return
operator|new
name|QWindowContainer
argument_list|(
name|window
argument_list|,
name|parent
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QWindowContainer
name|QWindowContainer
operator|::
name|QWindowContainer
parameter_list|(
name|QWindow
modifier|*
name|embeddedWindow
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QWindowContainerPrivate
argument_list|,
name|parent
argument_list|,
name|flags
argument_list|)
block|{
name|Q_D
argument_list|(
name|QWindowContainer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|embeddedWindow
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWindowContainer: embedded window cannot be null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|window
operator|=
name|embeddedWindow
expr_stmt|;
comment|// We force this window to become a native window and reparent the
comment|// window directly to it. This is done so that the order in which
comment|// the QWindowContainer is added to a QWidget tree and when it
comment|// gets a window does not matter.
name|winId
argument_list|()
expr_stmt|;
name|d
operator|->
name|window
operator|->
name|setParent
argument_list|(
name|windowHandle
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|QGuiApplication
operator|::
name|instance
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|focusWindowChanged
argument_list|(
name|QWindow
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|focusWindowChanged
argument_list|(
name|QWindow
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal  */
end_comment
begin_destructor
DECL|function|~QWindowContainer
name|QWindowContainer
operator|::
name|~
name|QWindowContainer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QWindowContainer
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|window
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|focusWindowChanged
name|void
name|QWindowContainer
operator|::
name|focusWindowChanged
parameter_list|(
name|QWindow
modifier|*
name|focusWindow
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindowContainer
argument_list|)
expr_stmt|;
name|d
operator|->
name|oldFocusWindow
operator|=
name|focusWindow
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|event
name|bool
name|QWindowContainer
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QWindowContainer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|window
condition|)
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
name|QEvent
operator|::
name|Type
name|type
init|=
name|e
operator|->
name|type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
block|{
name|QChildEvent
modifier|*
name|ce
init|=
cast|static_cast
argument_list|<
name|QChildEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|child
argument_list|()
operator|==
name|d
operator|->
name|window
condition|)
name|d
operator|->
name|window
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|// The only thing we are interested in is making sure our sizes stay
comment|// in sync, so do a catch-all case.
case|case
name|QEvent
operator|::
name|Resize
case|:
case|case
name|QEvent
operator|::
name|Move
case|:
case|case
name|QEvent
operator|::
name|PolishRequest
case|:
name|d
operator|->
name|window
operator|->
name|setGeometry
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
name|d
operator|->
name|window
operator|->
name|show
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
name|d
operator|->
name|window
operator|->
name|hide
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusIn
case|:
if|if
condition|(
name|d
operator|->
name|oldFocusWindow
operator|!=
name|d
operator|->
name|window
condition|)
block|{
name|d
operator|->
name|window
operator|->
name|requestActivate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QWidget
modifier|*
name|next
init|=
name|nextInFocusChain
argument_list|()
decl_stmt|;
name|next
operator|->
name|setFocus
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
