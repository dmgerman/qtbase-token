begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtoolbar.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
end_ifndef
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qcombobox.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qlayout.h>
end_include
begin_include
include|#
directive|include
file|<qmainwindow.h>
end_include
begin_include
include|#
directive|include
file|<qmenu.h>
end_include
begin_include
include|#
directive|include
file|<qmenubar.h>
end_include
begin_include
include|#
directive|include
file|<qrubberband.h>
end_include
begin_include
include|#
directive|include
file|<qsignalmapper.h>
end_include
begin_include
include|#
directive|include
file|<qstylepainter.h>
end_include
begin_include
include|#
directive|include
file|<qtoolbutton.h>
end_include
begin_include
include|#
directive|include
file|<qwidgetaction.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidgetaction_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmainwindowlayout_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_OSX
end_ifdef
begin_include
include|#
directive|include
file|<qpa/qplatformnativeinterface.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qtoolbar_p.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbarseparator_p.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbarlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_define
DECL|macro|POPUP_TIMER_INTERVAL
define|#
directive|define
name|POPUP_TIMER_INTERVAL
value|500
end_define
begin_function_decl
name|QT_BEGIN_NAMESPACE
comment|// qmainwindow.cpp
specifier|extern
name|QMainWindowLayout
modifier|*
name|qt_mainwindow_layout
parameter_list|(
specifier|const
name|QMainWindow
modifier|*
name|window
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/****************************************************************************** ** QToolBarPrivate */
end_comment
begin_function
DECL|function|init
name|void
name|QToolBarPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Preferred
argument_list|,
name|QSizePolicy
operator|::
name|Fixed
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Button
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_X11NetWmWindowTypeToolBar
argument_list|)
expr_stmt|;
name|q
operator|->
name|setProperty
argument_list|(
literal|"_q_platform_MacUseNSWindow"
argument_list|,
name|QVariant
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|q
operator|->
name|style
argument_list|()
decl_stmt|;
name|int
name|e
init|=
name|style
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ToolBarIconSize
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|iconSize
operator|=
name|QSize
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|layout
operator|=
operator|new
name|QToolBarLayout
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|layout
operator|->
name|updateMarginAndSpacing
argument_list|()
expr_stmt|;
name|toggleViewAction
operator|=
operator|new
name|QAction
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|toggleViewAction
operator|->
name|setCheckable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|q
operator|->
name|setMovable
argument_list|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ToolBar_Movable
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|toggleViewAction
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_toggleView
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_toggleView
name|void
name|QToolBarPrivate
operator|::
name|_q_toggleView
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|q
operator|->
name|isHidden
argument_list|()
condition|)
block|{
if|if
condition|(
name|b
condition|)
name|q
operator|->
name|show
argument_list|()
expr_stmt|;
else|else
name|q
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_updateIconSize
name|void
name|QToolBarPrivate
operator|::
name|_q_updateIconSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|sz
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explicitIconSize
condition|)
block|{
comment|// iconSize not explicitly set
name|q
operator|->
name|setIconSize
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|explicitIconSize
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_updateToolButtonStyle
name|void
name|QToolBarPrivate
operator|::
name|_q_updateToolButtonStyle
parameter_list|(
name|Qt
operator|::
name|ToolButtonStyle
name|style
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explicitToolButtonStyle
condition|)
block|{
name|q
operator|->
name|setToolButtonStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|explicitToolButtonStyle
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateWindowFlags
name|void
name|QToolBarPrivate
operator|::
name|updateWindowFlags
parameter_list|(
name|bool
name|floating
parameter_list|,
name|bool
name|unplug
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|WindowFlags
name|flags
init|=
name|floating
condition|?
name|Qt
operator|::
name|Tool
else|:
name|Qt
operator|::
name|Widget
decl_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|FramelessWindowHint
expr_stmt|;
if|if
condition|(
name|unplug
condition|)
name|flags
operator||=
name|Qt
operator|::
name|X11BypassWindowManagerHint
expr_stmt|;
name|q
operator|->
name|setWindowFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setWindowState
name|void
name|QToolBarPrivate
operator|::
name|setWindowState
parameter_list|(
name|bool
name|floating
parameter_list|,
name|bool
name|unplug
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|bool
name|visible
init|=
operator|!
name|q
operator|->
name|isHidden
argument_list|()
decl_stmt|;
name|bool
name|wasFloating
init|=
name|q
operator|->
name|isFloating
argument_list|()
decl_stmt|;
comment|// ...is also currently using popup menus
name|q
operator|->
name|hide
argument_list|()
expr_stmt|;
name|updateWindowFlags
argument_list|(
name|floating
argument_list|,
name|unplug
argument_list|)
expr_stmt|;
if|if
condition|(
name|floating
operator|!=
name|wasFloating
condition|)
name|layout
operator|->
name|checkUsePopupMenu
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isNull
argument_list|()
condition|)
name|q
operator|->
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible
condition|)
name|q
operator|->
name|show
argument_list|()
expr_stmt|;
if|if
condition|(
name|floating
operator|!=
name|wasFloating
condition|)
emit|emit
name|q
operator|->
name|topLevelChanged
argument_list|(
name|floating
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|initDrag
name|void
name|QToolBarPrivate
operator|::
name|initDrag
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
return|return;
name|QMainWindow
modifier|*
name|win
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|win
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QMainWindowLayout
modifier|*
name|layout
init|=
name|qt_mainwindow_layout
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layout
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
operator|->
name|pluggingWidget
operator|!=
literal|0
condition|)
comment|// the main window is animating a docking operation
return|return;
name|state
operator|=
operator|new
name|DragState
expr_stmt|;
name|state
operator|->
name|pressPos
operator|=
name|pos
expr_stmt|;
name|state
operator|->
name|dragging
operator|=
literal|false
expr_stmt|;
name|state
operator|->
name|moving
operator|=
literal|false
expr_stmt|;
name|state
operator|->
name|widgetItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|state
operator|->
name|pressPos
operator|=
name|QPoint
argument_list|(
name|q
operator|->
name|width
argument_list|()
operator|-
name|state
operator|->
name|pressPos
operator|.
name|x
argument_list|()
argument_list|,
name|state
operator|->
name|pressPos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startDrag
name|void
name|QToolBarPrivate
operator|::
name|startDrag
parameter_list|(
name|bool
name|moving
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|moving
operator|&&
name|state
operator|->
name|moving
operator|)
operator|||
name|state
operator|->
name|dragging
condition|)
return|return;
name|QMainWindow
modifier|*
name|win
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|win
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QMainWindowLayout
modifier|*
name|layout
init|=
name|qt_mainwindow_layout
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layout
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|moving
condition|)
block|{
name|state
operator|->
name|widgetItem
operator|=
name|layout
operator|->
name|unplug
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|->
name|widgetItem
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|dragging
operator|=
operator|!
name|moving
expr_stmt|;
name|state
operator|->
name|moving
operator|=
name|moving
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endDrag
name|void
name|QToolBarPrivate
operator|::
name|endDrag
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|releaseMouse
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dragging
condition|)
block|{
name|QMainWindowLayout
modifier|*
name|layout
init|=
name|qt_mainwindow_layout
argument_list|(
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|parentWidget
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layout
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|layout
operator|->
name|plug
argument_list|(
name|state
operator|->
name|widgetItem
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|isFloatable
argument_list|()
condition|)
block|{
name|layout
operator|->
name|restore
argument_list|()
expr_stmt|;
name|setWindowState
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// gets rid of the X11BypassWindowManager window flag
comment|// and activates the resizer
name|q
operator|->
name|activateWindow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|layout
operator|->
name|revert
argument_list|(
name|state
operator|->
name|widgetItem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|delete
name|state
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mousePressEvent
name|bool
name|QToolBarPrivate
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|QStyleOptionToolBar
name|opt
decl_stmt|;
name|q
operator|->
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_ToolBarHandle
argument_list|,
operator|&
name|opt
argument_list|,
name|q
argument_list|)
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_OSX
comment|// When using the unified toolbar on OS X, the user can click and
comment|// drag between toolbar contents to move the window. Make this work by
comment|// implementing the standard mouse-dragging code and then call
comment|// window->move() in mouseMoveEvent below.
if|if
condition|(
name|QMainWindow
modifier|*
name|mainWindow
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
if|if
condition|(
name|mainWindow
operator|->
name|toolBarArea
argument_list|(
name|q
argument_list|)
operator|==
name|Qt
operator|::
name|TopToolBarArea
operator|&&
name|mainWindow
operator|->
name|unifiedTitleAndToolBarOnMac
argument_list|()
operator|&&
name|q
operator|->
name|childAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|macWindowDragging
operator|=
literal|true
expr_stmt|;
name|macWindowDragPressPosition
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|if
condition|(
name|event
operator|->
name|button
argument_list|()
operator|!=
name|Qt
operator|::
name|LeftButton
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|layout
operator|->
name|movable
argument_list|()
condition|)
return|return
literal|true
return|;
name|initDrag
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|mouseReleaseEvent
name|bool
name|QToolBarPrivate
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
block|{
name|endDrag
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Q_OS_OSX
if|if
condition|(
operator|!
name|macWindowDragging
condition|)
return|return
literal|false
return|;
name|macWindowDragging
operator|=
literal|false
expr_stmt|;
name|macWindowDragPressPosition
operator|=
name|QPoint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|mouseMoveEvent
name|bool
name|QToolBarPrivate
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_OSX
if|if
condition|(
operator|!
name|macWindowDragging
condition|)
return|return
literal|false
return|;
name|QWidget
modifier|*
name|w
init|=
name|q
operator|->
name|window
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|delta
init|=
name|event
operator|->
name|pos
argument_list|()
operator|-
name|macWindowDragPressPosition
decl_stmt|;
name|w
operator|->
name|move
argument_list|(
name|w
operator|->
name|pos
argument_list|()
operator|+
name|delta
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|QMainWindow
modifier|*
name|win
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
condition|)
return|return
literal|true
return|;
name|QMainWindowLayout
modifier|*
name|layout
init|=
name|qt_mainwindow_layout
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layout
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
operator|->
name|pluggingWidget
operator|==
literal|0
operator|&&
operator|(
name|event
operator|->
name|pos
argument_list|()
operator|-
name|state
operator|->
name|pressPos
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|>
name|QApplication
operator|::
name|startDragDistance
argument_list|()
condition|)
block|{
specifier|const
name|bool
name|wasDragging
init|=
name|state
operator|->
name|dragging
decl_stmt|;
specifier|const
name|bool
name|moving
init|=
operator|!
name|q
operator|->
name|isWindow
argument_list|()
operator|&&
operator|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|?
name|event
operator|->
name|x
argument_list|()
operator|>=
literal|0
operator|&&
name|event
operator|->
name|x
argument_list|()
operator|<
name|q
operator|->
name|width
argument_list|()
else|:
name|event
operator|->
name|y
argument_list|()
operator|>=
literal|0
operator|&&
name|event
operator|->
name|y
argument_list|()
operator|<
name|q
operator|->
name|height
argument_list|()
operator|)
decl_stmt|;
name|startDrag
argument_list|(
name|moving
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|moving
operator|&&
operator|!
name|wasDragging
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_DEAD_CODE_FROM_QT4_WIN
name|grabMouseWhileInWindow
argument_list|()
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|grabMouse
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|state
operator|->
name|dragging
condition|)
block|{
name|QPoint
name|pos
init|=
name|event
operator|->
name|globalPos
argument_list|()
decl_stmt|;
comment|// if we are right-to-left, we move so as to keep the right edge the same distance
comment|// from the mouse
if|if
condition|(
name|q
operator|->
name|isLeftToRight
argument_list|()
condition|)
name|pos
operator|-=
name|state
operator|->
name|pressPos
expr_stmt|;
else|else
name|pos
operator|+=
name|QPoint
argument_list|(
name|state
operator|->
name|pressPos
operator|.
name|x
argument_list|()
operator|-
name|q
operator|->
name|width
argument_list|()
argument_list|,
operator|-
name|state
operator|->
name|pressPos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|move
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|layout
operator|->
name|hover
argument_list|(
name|state
operator|->
name|widgetItem
argument_list|,
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|moving
condition|)
block|{
specifier|const
name|QPoint
name|rtl
argument_list|(
name|q
operator|->
name|width
argument_list|()
operator|-
name|state
operator|->
name|pressPos
operator|.
name|x
argument_list|()
argument_list|,
name|state
operator|->
name|pressPos
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
comment|//for RTL
specifier|const
name|QPoint
name|globalPressPos
init|=
name|q
operator|->
name|mapToGlobal
argument_list|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|?
name|rtl
else|:
name|state
operator|->
name|pressPos
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|QPoint
name|delta
init|=
name|event
operator|->
name|globalPos
argument_list|()
operator|-
name|globalPressPos
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
block|{
name|pos
operator|=
name|q
operator|->
name|y
argument_list|()
operator|+
name|delta
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
block|{
name|pos
operator|=
name|win
operator|->
name|width
argument_list|()
operator|-
name|q
operator|->
name|width
argument_list|()
operator|-
name|q
operator|->
name|x
argument_list|()
operator|-
name|delta
operator|.
name|x
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|q
operator|->
name|x
argument_list|()
operator|+
name|delta
operator|.
name|x
argument_list|()
expr_stmt|;
block|}
block|}
name|layout
operator|->
name|moveToolBar
argument_list|(
name|q
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unplug
name|void
name|QToolBarPrivate
operator|::
name|unplug
parameter_list|(
specifier|const
name|QRect
modifier|&
name|_r
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|_r
decl_stmt|;
name|r
operator|.
name|moveTopLeft
argument_list|(
name|q
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setWindowState
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|layout
operator|->
name|setExpanded
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|plug
name|void
name|QToolBarPrivate
operator|::
name|plug
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|setWindowState
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/****************************************************************************** ** QToolBar */
end_comment
begin_comment
comment|/*!     \class QToolBar      \brief The QToolBar class provides a movable panel that contains a     set of controls.      \ingroup mainwindow-classes     \inmodule QtWidgets      Toolbar buttons are added by adding \e actions, using addAction()     or insertAction(). Groups of buttons can be separated using     addSeparator() or insertSeparator(). If a toolbar button is not     appropriate, a widget can be inserted instead using addWidget() or     insertWidget(). Examples of suitable widgets are QSpinBox,     QDoubleSpinBox, and QComboBox. When a toolbar button is pressed, it     emits the actionTriggered() signal.      A toolbar can be fixed in place in a particular area (e.g., at the     top of the window), or it can be movable between toolbar areas;     see setMovable(), isMovable(), allowedAreas() and isAreaAllowed().      When a toolbar is resized in such a way that it is too small to     show all the items it contains, an extension button will appear as     the last item in the toolbar. Pressing the extension button will     pop up a menu containing the items that does not currently fit in     the toolbar.      When a QToolBar is not a child of a QMainWindow, it loses the ability     to populate the extension pop up with widgets added to the toolbar using     addWidget(). Please use widget actions created by inheriting QWidgetAction     and implementing QWidgetAction::createWidget() instead.      \sa QToolButton, QMenu, QAction, {Application Example} */
end_comment
begin_comment
comment|/*!     \fn bool QToolBar::isAreaAllowed(Qt::ToolBarArea area) const      Returns \c true if this toolbar is dockable in the given \a area;     otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::actionTriggered(QAction *action)      This signal is emitted when an action in this toolbar is triggered.     This happens when the action's tool button is pressed, or when the     action is triggered in some other way outside the toolbar. The parameter     holds the triggered \a action. */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::allowedAreasChanged(Qt::ToolBarAreas allowedAreas)      This signal is emitted when the collection of allowed areas for the     toolbar is changed. The new areas in which the toolbar can be positioned     are specified by \a allowedAreas.      \sa allowedAreas */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::iconSizeChanged(const QSize&iconSize)      This signal is emitted when the icon size is changed. The \a     iconSize parameter holds the toolbar's new icon size.      \sa iconSize, QMainWindow::iconSize */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::movableChanged(bool movable)      This signal is emitted when the toolbar becomes movable or fixed.     If the toolbar can be moved, \a movable is true; otherwise it is     false.      \sa movable */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::orientationChanged(Qt::Orientation orientation)      This signal is emitted when the orientation of the toolbar changes.     The \a orientation parameter holds the toolbar's new orientation.      \sa orientation */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle)      This signal is emitted when the tool button style is changed. The     \a toolButtonStyle parameter holds the toolbar's new tool button     style.      \sa toolButtonStyle, QMainWindow::toolButtonStyle */
end_comment
begin_comment
comment|/*!     \since 4.6      \fn void QToolBar::topLevelChanged(bool topLevel)      This signal is emitted when the \l floating property changes.     The \a topLevel parameter is true if the toolbar is now floating;     otherwise it is false.      \sa isWindow() */
end_comment
begin_comment
comment|/*!     \fn void QToolBar::visibilityChanged(bool visible)     \since 4.7      This signal is emitted when the toolbar becomes \a visible (or     invisible). This happens when the widget is hidden or shown. */
end_comment
begin_comment
comment|/*!     Constructs a QToolBar with the given \a parent. */
end_comment
begin_constructor
DECL|function|QToolBar
name|QToolBar
operator|::
name|QToolBar
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QToolBarPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QToolBar with the given \a parent.      The given window \a title identifies the toolbar and is shown in     the context menu provided by QMainWindow.      \sa setWindowTitle() */
end_comment
begin_constructor
DECL|function|QToolBar
name|QToolBar
operator|::
name|QToolBar
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QToolBarPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|setWindowTitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the toolbar. */
end_comment
begin_destructor
DECL|function|~QToolBar
name|QToolBar
operator|::
name|~
name|QToolBar
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \property QToolBar::movable     \brief whether the user can move the toolbar within the toolbar area,     or between toolbar areas.      By default, this property is \c true.      This property only makes sense if the toolbar is in a     QMainWindow.      \sa allowedAreas */
end_comment
begin_function
DECL|function|setMovable
name|void
name|QToolBar
operator|::
name|setMovable
parameter_list|(
name|bool
name|movable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|movable
operator|==
operator|!
name|d
operator|->
name|movable
condition|)
return|return;
name|d
operator|->
name|movable
operator|=
name|movable
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|movableChanged
argument_list|(
name|d
operator|->
name|movable
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|isMovable
name|bool
name|QToolBar
operator|::
name|isMovable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|movable
return|;
block|}
end_function
begin_comment
comment|/*!     \property QToolBar::floatable     \brief whether the toolbar can be dragged and dropped as an independent window.      The default is true. */
end_comment
begin_function
DECL|function|isFloatable
name|bool
name|QToolBar
operator|::
name|isFloatable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|floatable
return|;
block|}
end_function
begin_function
DECL|function|setFloatable
name|void
name|QToolBar
operator|::
name|setFloatable
parameter_list|(
name|bool
name|floatable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|d
operator|->
name|floatable
operator|=
name|floatable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QToolBar::floating     \brief whether the toolbar is an independent window.      By default, this property is \c true.      \sa QWidget::isWindow() */
end_comment
begin_function
DECL|function|isFloating
name|bool
name|QToolBar
operator|::
name|isFloating
parameter_list|()
specifier|const
block|{
return|return
name|isWindow
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QToolBar::allowedAreas     \brief areas where the toolbar may be placed      The default is Qt::AllToolBarAreas.      This property only makes sense if the toolbar is in a     QMainWindow.      \sa movable */
end_comment
begin_function
DECL|function|setAllowedAreas
name|void
name|QToolBar
operator|::
name|setAllowedAreas
parameter_list|(
name|Qt
operator|::
name|ToolBarAreas
name|areas
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|areas
operator|&=
name|Qt
operator|::
name|ToolBarArea_Mask
expr_stmt|;
if|if
condition|(
name|areas
operator|==
name|d
operator|->
name|allowedAreas
condition|)
return|return;
name|d
operator|->
name|allowedAreas
operator|=
name|areas
expr_stmt|;
emit|emit
name|allowedAreasChanged
argument_list|(
name|d
operator|->
name|allowedAreas
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|allowedAreas
name|Qt
operator|::
name|ToolBarAreas
name|QToolBar
operator|::
name|allowedAreas
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|allowedAreas
return|;
block|}
end_function
begin_comment
comment|/*! \property QToolBar::orientation     \brief orientation of the toolbar      The default is Qt::Horizontal.      This function should not be used when the toolbar is managed     by QMainWindow. You can use QMainWindow::addToolBar() or     QMainWindow::insertToolBar() if you wish to move a toolbar that     is already added to a main window to another Qt::ToolBarArea. */
end_comment
begin_function
DECL|function|setOrientation
name|void
name|QToolBar
operator|::
name|setOrientation
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|d
operator|->
name|orientation
condition|)
return|return;
name|d
operator|->
name|orientation
operator|=
name|orientation
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Fixed
argument_list|,
name|QSizePolicy
operator|::
name|Preferred
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Preferred
argument_list|,
name|QSizePolicy
operator|::
name|Fixed
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|activate
argument_list|()
expr_stmt|;
emit|emit
name|orientationChanged
argument_list|(
name|d
operator|->
name|orientation
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|orientation
name|Qt
operator|::
name|Orientation
name|QToolBar
operator|::
name|orientation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|orientation
return|;
block|}
end_function
begin_comment
comment|/*!     \property QToolBar::iconSize     \brief size of icons in the toolbar.      The default size is determined by the application's style and is     derived from the QStyle::PM_ToolBarIconSize pixel metric. It is     the maximum size an icon can have. Icons of smaller size will not     be scaled up. */
end_comment
begin_function
DECL|function|iconSize
name|QSize
name|QToolBar
operator|::
name|iconSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|iconSize
return|;
block|}
end_function
begin_function
DECL|function|setIconSize
name|void
name|QToolBar
operator|::
name|setIconSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|iconSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|QSize
name|sz
init|=
name|iconSize
decl_stmt|;
if|if
condition|(
operator|!
name|sz
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QMainWindow
modifier|*
name|mw
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parentWidget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mw
operator|&&
name|mw
operator|->
name|layout
argument_list|()
condition|)
block|{
name|QLayout
modifier|*
name|layout
init|=
name|mw
operator|->
name|layout
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QLayoutItem
modifier|*
name|item
init|=
literal|0
decl_stmt|;
do|do
block|{
name|item
operator|=
name|layout
operator|->
name|itemAt
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|&&
operator|(
name|item
operator|->
name|widget
argument_list|()
operator|==
name|this
operator|)
condition|)
name|sz
operator|=
name|mw
operator|->
name|iconSize
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|sz
operator|.
name|isValid
argument_list|()
operator|&&
name|item
operator|!=
literal|0
condition|)
do|;
block|}
block|}
if|if
condition|(
operator|!
name|sz
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|int
name|metric
init|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ToolBarIconSize
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|sz
operator|=
name|QSize
argument_list|(
name|metric
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|iconSize
operator|!=
name|sz
condition|)
block|{
name|d
operator|->
name|iconSize
operator|=
name|sz
expr_stmt|;
name|setMinimumSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
emit|emit
name|iconSizeChanged
argument_list|(
name|d
operator|->
name|iconSize
argument_list|)
emit|;
block|}
name|d
operator|->
name|explicitIconSize
operator|=
name|iconSize
operator|.
name|isValid
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QToolBar::toolButtonStyle     \brief the style of toolbar buttons      This property defines the style of all tool buttons that are added     as \l{QAction}s. Note that if you add a QToolButton with the     addWidget() method, it will not get this button style.      To have the style of toolbuttons follow the system settings, set this property to Qt::ToolButtonFollowStyle.     On Unix, the user settings from the desktop environment will be used.     On other platforms, Qt::ToolButtonFollowStyle means icon only.      The default is Qt::ToolButtonIconOnly. */
end_comment
begin_function
DECL|function|toolButtonStyle
name|Qt
operator|::
name|ToolButtonStyle
name|QToolBar
operator|::
name|toolButtonStyle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|toolButtonStyle
return|;
block|}
end_function
begin_function
DECL|function|setToolButtonStyle
name|void
name|QToolBar
operator|::
name|setToolButtonStyle
parameter_list|(
name|Qt
operator|::
name|ToolButtonStyle
name|toolButtonStyle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|d
operator|->
name|explicitToolButtonStyle
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|toolButtonStyle
operator|==
name|toolButtonStyle
condition|)
return|return;
name|d
operator|->
name|toolButtonStyle
operator|=
name|toolButtonStyle
expr_stmt|;
name|setMinimumSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
emit|emit
name|toolButtonStyleChanged
argument_list|(
name|d
operator|->
name|toolButtonStyle
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Removes all actions from the toolbar.      \sa removeAction() */
end_comment
begin_function
DECL|function|clear
name|void
name|QToolBar
operator|::
name|clear
parameter_list|()
block|{
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|actions
init|=
name|this
operator|->
name|actions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|actions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|removeAction
argument_list|(
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a new action with the given \a text. This action is added to     the end of the toolbar. */
end_comment
begin_function
DECL|function|addAction
name|QAction
modifier|*
name|QToolBar
operator|::
name|addAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|text
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a new action with the given \a icon and \a text. This     action is added to the end of the toolbar. */
end_comment
begin_function
DECL|function|addAction
name|QAction
modifier|*
name|QToolBar
operator|::
name|addAction
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|icon
argument_list|,
name|text
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a new action with the given \a text. This action is added to     the end of the toolbar. The action's \l{QAction::triggered()}{triggered()}     signal is connected to \a member in \a receiver. */
end_comment
begin_function
DECL|function|addAction
name|QAction
modifier|*
name|QToolBar
operator|::
name|addAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|text
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|receiver
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a new action with the given \a icon and \a text. This     action is added to the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to \a     member in \a receiver. */
end_comment
begin_function
DECL|function|addAction
name|QAction
modifier|*
name|QToolBar
operator|::
name|addAction
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|icon
argument_list|,
name|text
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|receiver
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QString&text, const QObject *receiver, PointerToMemberFunction method)      \since 5.6      \overload      Creates a new action with the given \a text. This action is added to     the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a method of the \a receiver. */
end_comment
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QString&text, Functor functor)      \since 5.6      \overload      Creates a new action with the given \a text. This action is added to     the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a functor. */
end_comment
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QString&text, const QObject *context, Functor functor)      \since 5.6      \overload      Creates a new action with the given \a text. This action is added to     the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a functor.      If \a context is destroyed, the functor will not be called. */
end_comment
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QIcon&icon, const QString&text, const QObject *receiver, PointerToMemberFunction method)      \since 5.6      \overload      Creates a new action with the given \a icon and \a text. This     action is added to the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a method of the \a receiver. */
end_comment
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QIcon&icon, const QString&text, Functor functor)      \since 5.6      \overload      Creates a new action with the given \a icon and \a text. This     action is added to the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a functor. */
end_comment
begin_comment
comment|/*!\fn QAction *QToolBar::addAction(const QIcon&icon, const QString&text, const QObject *context, Functor functor)      \since 5.6      \overload      Creates a new action with the given \a icon and \a text. This     action is added to the end of the toolbar. The action's     \l{QAction::triggered()}{triggered()} signal is connected to the     \a functor.      If \a context is destroyed, the functor will not be called. */
end_comment
begin_comment
comment|/*!      Adds a separator to the end of the toolbar.       \sa insertSeparator() */
end_comment
begin_function
DECL|function|addSeparator
name|QAction
modifier|*
name|QToolBar
operator|::
name|addSeparator
parameter_list|()
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|action
operator|->
name|setSeparator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts a separator into the toolbar in front of the toolbar     item associated with the \a before action.      \sa addSeparator() */
end_comment
begin_function
DECL|function|insertSeparator
name|QAction
modifier|*
name|QToolBar
operator|::
name|insertSeparator
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|)
block|{
name|QAction
modifier|*
name|action
init|=
operator|new
name|QAction
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|action
operator|->
name|setSeparator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|insertAction
argument_list|(
name|before
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the given \a widget to the toolbar as the toolbar's last     item.      The toolbar takes ownership of \a widget.      If you add a QToolButton with this method, the toolbar's     Qt::ToolButtonStyle will not be respected.      \note You should use QAction::setVisible() to change the     visibility of the widget. Using QWidget::setVisible(),     QWidget::show() and QWidget::hide() does not work.      \sa insertWidget() */
end_comment
begin_function
DECL|function|addWidget
name|QAction
modifier|*
name|QToolBar
operator|::
name|addWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QWidgetAction
modifier|*
name|action
init|=
operator|new
name|QWidgetAction
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|action
operator|->
name|setDefaultWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|action
operator|->
name|d_func
argument_list|()
operator|->
name|autoCreated
operator|=
literal|true
expr_stmt|;
name|addAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the given \a widget in front of the toolbar item     associated with the \a before action.      Note: You should use QAction::setVisible() to change the     visibility of the widget. Using QWidget::setVisible(),     QWidget::show() and QWidget::hide() does not work.      \sa addWidget() */
end_comment
begin_function
DECL|function|insertWidget
name|QAction
modifier|*
name|QToolBar
operator|::
name|insertWidget
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QWidgetAction
modifier|*
name|action
init|=
operator|new
name|QWidgetAction
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|action
operator|->
name|setDefaultWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|action
operator|->
name|d_func
argument_list|()
operator|->
name|autoCreated
operator|=
literal|true
expr_stmt|;
name|insertAction
argument_list|(
name|before
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
name|action
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the geometry of the toolbar item associated with the given     \a action, or an invalid QRect if no matching item is found. */
end_comment
begin_function
DECL|function|actionGeometry
name|QRect
name|QToolBar
operator|::
name|actionGeometry
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
return|return
name|QRect
argument_list|()
return|;
return|return
name|d
operator|->
name|layout
operator|->
name|itemAt
argument_list|(
name|index
argument_list|)
operator|->
name|widget
argument_list|()
operator|->
name|geometry
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the action at point \a p. This function returns zero if no     action was found.      \sa QWidget::childAt() */
end_comment
begin_function
DECL|function|actionAt
name|QAction
modifier|*
name|QToolBar
operator|::
name|actionAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|widget
init|=
name|childAt
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|QLayoutItem
modifier|*
name|item
init|=
name|d
operator|->
name|layout
operator|->
name|itemAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|QToolBarItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|action
return|;
block|}
end_function
begin_comment
comment|/*! \fn QAction *QToolBar::actionAt(int x, int y) const     \overload      Returns the action at the point \a x, \a y. This function returns     zero if no action was found. */
end_comment
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|actionEvent
name|void
name|QToolBar
operator|::
name|actionEvent
parameter_list|(
name|QActionEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|QAction
modifier|*
name|action
init|=
name|event
operator|->
name|action
argument_list|()
decl_stmt|;
name|QWidgetAction
modifier|*
name|widgetAction
init|=
name|qobject_cast
argument_list|<
name|QWidgetAction
operator|*
argument_list|>
argument_list|(
name|action
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ActionAdded
case|:
block|{
name|Q_ASSERT_X
argument_list|(
name|widgetAction
operator|==
literal|0
operator|||
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|widgetAction
argument_list|)
operator|==
operator|-
literal|1
argument_list|,
literal|"QToolBar"
argument_list|,
literal|"widgets cannot be inserted multiple times"
argument_list|)
expr_stmt|;
comment|// reparent the action to this toolbar if it has been created
comment|// using the addAction(text) etc. convenience functions, to
comment|// preserve Qt 4.1.x behavior. The widget is already
comment|// reparented to us due to the createWidget call inside
comment|// createItem()
if|if
condition|(
name|widgetAction
operator|!=
literal|0
operator|&&
name|widgetAction
operator|->
name|d_func
argument_list|()
operator|->
name|autoCreated
condition|)
name|widgetAction
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|layout
operator|->
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|before
argument_list|()
condition|)
block|{
name|index
operator|=
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|event
operator|->
name|before
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|index
operator|!=
operator|-
literal|1
argument_list|,
literal|"QToolBar::insertAction"
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|layout
operator|->
name|insertAction
argument_list|(
name|index
argument_list|,
name|action
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|ActionChanged
case|:
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ActionRemoved
case|:
block|{
name|int
name|index
init|=
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
operator|delete
name|d
operator|->
name|layout
operator|->
name|takeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QToolBar::actionEvent"
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QToolBar
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|WindowTitleChange
case|:
name|d
operator|->
name|toggleViewAction
operator|->
name|setText
argument_list|(
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleChange
case|:
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|explicitIconSize
condition|)
name|setIconSize
argument_list|(
name|QSize
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|updateMarginAndSpacing
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|QWidget
operator|::
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QToolBar
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|this
operator|->
name|style
argument_list|()
decl_stmt|;
name|QStyleOptionToolBar
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|expanded
operator|||
name|d
operator|->
name|layout
operator|->
name|animating
operator|||
name|isWindow
argument_list|()
condition|)
block|{
comment|//if the toolbar is expended, we need to fill the background with the window color
comment|//because some styles may expects that.
name|p
operator|.
name|fillRect
argument_list|(
name|opt
operator|.
name|rect
argument_list|,
name|palette
argument_list|()
operator|.
name|background
argument_list|()
argument_list|)
expr_stmt|;
name|style
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_ToolBar
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|style
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_FrameMenu
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|style
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_ToolBar
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|opt
operator|.
name|rect
operator|=
name|style
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_ToolBarHandle
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|.
name|rect
operator|.
name|isValid
argument_list|()
condition|)
name|style
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_IndicatorToolBarHandle
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Checks if an expanded toolbar has to wait for this popup to close before     the toolbar collapses. This is true if     1) the popup has the toolbar in its parent chain,     2) the popup is a menu whose menuAction is somewhere in the toolbar. */
end_comment
begin_function
DECL|function|waitForPopup
specifier|static
name|bool
name|waitForPopup
parameter_list|(
name|QToolBar
modifier|*
name|tb
parameter_list|,
name|QWidget
modifier|*
name|popup
parameter_list|)
block|{
if|if
condition|(
name|popup
operator|==
literal|0
operator|||
name|popup
operator|->
name|isHidden
argument_list|()
condition|)
return|return
literal|false
return|;
name|QWidget
modifier|*
name|w
init|=
name|popup
decl_stmt|;
while|while
condition|(
name|w
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|==
name|tb
condition|)
return|return
literal|true
return|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
name|QMenu
modifier|*
name|menu
init|=
name|qobject_cast
argument_list|<
name|QMenu
operator|*
argument_list|>
argument_list|(
name|popup
argument_list|)
decl_stmt|;
if|if
condition|(
name|menu
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|QAction
modifier|*
name|action
init|=
name|menu
operator|->
name|menuAction
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|widgets
init|=
name|action
operator|->
name|associatedWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|widgets
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|waitForPopup
argument_list|(
name|tb
argument_list|,
name|widgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_OSX
end_ifdef
begin_function
DECL|function|enableMacToolBar
specifier|static
name|void
name|enableMacToolBar
parameter_list|(
name|QToolBar
modifier|*
name|toolbar
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|QPlatformNativeInterface
modifier|*
name|nativeInterface
init|=
name|QApplication
operator|::
name|platformNativeInterface
argument_list|()
decl_stmt|;
name|QPlatformNativeInterface
operator|::
name|NativeResourceForIntegrationFunction
name|function
init|=
name|nativeInterface
operator|->
name|nativeResourceFunctionForIntegration
argument_list|(
literal|"setContentBorderAreaEnabled"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|function
condition|)
return|return;
comment|// Not Cocoa platform plugin.
typedef|typedef
name|void
function_decl|(
modifier|*
name|SetContentBorderAreaEnabledFunction
function_decl|)
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|identifier
parameter_list|,
name|bool
name|enabled
parameter_list|)
function_decl|;
operator|(
cast|reinterpret_cast
argument_list|<
name|SetContentBorderAreaEnabledFunction
argument_list|>
argument_list|(
name|function
argument_list|)
operator|)
operator|(
name|toolbar
operator|->
name|window
argument_list|()
operator|->
name|windowHandle
argument_list|()
operator|,
name|toolbar
operator|,
name|enable
operator|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QToolBar
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QToolBar
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Timer
case|:
if|if
condition|(
name|d
operator|->
name|waitForPopupTimer
operator|.
name|timerId
argument_list|()
operator|==
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|timerId
argument_list|()
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|waitForPopup
argument_list|(
name|this
argument_list|,
name|w
argument_list|)
condition|)
block|{
name|d
operator|->
name|waitForPopupTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|underMouse
argument_list|()
condition|)
name|d
operator|->
name|layout
operator|->
name|setExpanded
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
if|if
condition|(
operator|!
name|isHidden
argument_list|()
condition|)
break|break;
comment|// fallthrough intended
case|case
name|QEvent
operator|::
name|Show
case|:
name|d
operator|->
name|toggleViewAction
operator|->
name|setChecked
argument_list|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Show
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_OSX
name|enableMacToolBar
argument_list|(
name|this
argument_list|,
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Show
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|visibilityChanged
argument_list|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Show
argument_list|)
emit|;
break|break;
case|case
name|QEvent
operator|::
name|ParentChange
case|:
name|d
operator|->
name|layout
operator|->
name|checkUsePopupMenu
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
block|{
if|if
condition|(
name|d
operator|->
name|mousePressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
if|if
condition|(
name|d
operator|->
name|mouseReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
break|break;
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
comment|// there's nothing special to do here and we don't want to update the whole widget
return|return
literal|true
return|;
case|case
name|QEvent
operator|::
name|HoverMove
case|:
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QHoverEvent
modifier|*
name|e
init|=
cast|static_cast
argument_list|<
name|QHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QStyleOptionToolBar
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
argument_list|()
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_ToolBarHandle
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
operator|.
name|contains
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|setCursor
argument_list|(
name|Qt
operator|::
name|SizeAllCursor
argument_list|)
expr_stmt|;
else|else
name|unsetCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseMove
case|:
if|if
condition|(
name|d
operator|->
name|mouseMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
break|break;
ifdef|#
directive|ifdef
name|Q_OS_WINCE
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
block|{
name|QContextMenuEvent
modifier|*
name|contextMenuEvent
init|=
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|child
init|=
name|childAt
argument_list|(
name|contextMenuEvent
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QAbstractButton
modifier|*
name|button
init|=
name|qobject_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|button
condition|)
name|button
operator|->
name|setDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|Leave
case|:
if|if
condition|(
name|d
operator|->
name|state
operator|!=
literal|0
operator|&&
name|d
operator|->
name|state
operator|->
name|dragging
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// This is a workaround for loosing the mouse on Vista.
name|QPoint
name|pos
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
name|QMouseEvent
name|fake
argument_list|(
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|mapFromGlobal
argument_list|(
name|pos
argument_list|)
argument_list|,
name|pos
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|QApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|mouseMoveEvent
argument_list|(
operator|&
name|fake
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|layout
operator|->
name|expanded
condition|)
break|break;
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|waitForPopup
argument_list|(
name|this
argument_list|,
name|w
argument_list|)
condition|)
block|{
name|d
operator|->
name|waitForPopupTimer
operator|.
name|start
argument_list|(
name|POPUP_TIMER_INTERVAL
argument_list|,
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|waitForPopupTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|setExpanded
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a checkable action that can be used to show or hide this     toolbar.      The action's text is set to the toolbar's window title.      \sa QAction::text, QWidget::windowTitle */
end_comment
begin_function
DECL|function|toggleViewAction
name|QAction
modifier|*
name|QToolBar
operator|::
name|toggleViewAction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|toggleViewAction
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the widget associated with the specified \a action.      \sa addWidget() */
end_comment
begin_function
DECL|function|widgetForAction
name|QWidget
modifier|*
name|QToolBar
operator|::
name|widgetForAction
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|layout
operator|->
name|indexOf
argument_list|(
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|layout
operator|->
name|itemAt
argument_list|(
name|index
argument_list|)
operator|->
name|widget
argument_list|()
return|;
block|}
end_function
begin_function_decl
specifier|extern
name|QMainWindowLayout
modifier|*
name|qt_mainwindow_layout
parameter_list|(
specifier|const
name|QMainWindow
modifier|*
name|window
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|initStyleOption
name|void
name|QToolBar
operator|::
name|initStyleOption
parameter_list|(
name|QStyleOptionToolBar
modifier|*
name|option
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QToolBar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option
condition|)
return|return;
name|option
operator|->
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Horizontal
expr_stmt|;
name|option
operator|->
name|lineWidth
operator|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ToolBarFrameWidth
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|option
operator|->
name|features
operator|=
name|d
operator|->
name|layout
operator|->
name|movable
argument_list|()
condition|?
name|QStyleOptionToolBar
operator|::
name|Movable
else|:
name|QStyleOptionToolBar
operator|::
name|None
expr_stmt|;
comment|// if the tool bar is not in a QMainWindow, this will make the painting right
name|option
operator|->
name|toolBarArea
operator|=
name|Qt
operator|::
name|NoToolBarArea
expr_stmt|;
comment|// Add more styleoptions if the toolbar has been added to a mainwindow.
name|QMainWindow
modifier|*
name|mainWindow
init|=
name|qobject_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|parentWidget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mainWindow
condition|)
return|return;
name|QMainWindowLayout
modifier|*
name|layout
init|=
name|qt_mainwindow_layout
argument_list|(
name|mainWindow
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|layout
operator|!=
literal|0
argument_list|,
literal|"QToolBar::initStyleOption()"
argument_list|,
literal|"QMainWindow->layout() != QMainWindowLayout"
argument_list|)
expr_stmt|;
name|layout
operator|->
name|getStyleOptionInfo
argument_list|(
name|option
argument_list|,
cast|const_cast
argument_list|<
name|QToolBar
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qtoolbar.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TOOLBAR
end_comment
end_unit
