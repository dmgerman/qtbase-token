begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextedit_p.h"
end_include
begin_include
include|#
directive|include
file|"qlineedit.h"
end_include
begin_include
include|#
directive|include
file|"qtextbrowser.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTEDIT
end_ifndef
begin_include
include|#
directive|include
file|<qfont.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdrag.h>
end_include
begin_include
include|#
directive|include
file|<qclipboard.h>
end_include
begin_include
include|#
directive|include
file|<qmenu.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|<qaccessible.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qtextdocumentlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocument.h"
end_include
begin_include
include|#
directive|include
file|"private/qtextdocument_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextlist.h"
end_include
begin_include
include|#
directive|include
file|"private/qwidgettextcontrol_p.h"
end_include
begin_include
include|#
directive|include
file|<qtextformat.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qtexttable.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_TEXTEDIT
DECL|function|shouldEnableInputMethod
specifier|static
specifier|inline
name|bool
name|shouldEnableInputMethod
parameter_list|(
name|QTextEdit
modifier|*
name|textedit
parameter_list|)
block|{
return|return
operator|!
name|textedit
operator|->
name|isReadOnly
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QTextEditControl
class|class
name|QTextEditControl
super|:
specifier|public
name|QWidgetTextControl
block|{
public|public:
DECL|function|QTextEditControl
specifier|inline
name|QTextEditControl
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidgetTextControl
argument_list|(
name|parent
argument_list|)
block|{}
DECL|function|createMimeDataFromSelection
specifier|virtual
name|QMimeData
modifier|*
name|createMimeDataFromSelection
parameter_list|()
specifier|const
block|{
name|QTextEdit
modifier|*
name|ed
init|=
name|qobject_cast
argument_list|<
name|QTextEdit
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
return|return
name|QWidgetTextControl
operator|::
name|createMimeDataFromSelection
argument_list|()
return|;
return|return
name|ed
operator|->
name|createMimeDataFromSelection
argument_list|()
return|;
block|}
DECL|function|canInsertFromMimeData
specifier|virtual
name|bool
name|canInsertFromMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|source
parameter_list|)
specifier|const
block|{
name|QTextEdit
modifier|*
name|ed
init|=
name|qobject_cast
argument_list|<
name|QTextEdit
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
return|return
name|QWidgetTextControl
operator|::
name|canInsertFromMimeData
argument_list|(
name|source
argument_list|)
return|;
return|return
name|ed
operator|->
name|canInsertFromMimeData
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|function|insertFromMimeData
specifier|virtual
name|void
name|insertFromMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|source
parameter_list|)
block|{
name|QTextEdit
modifier|*
name|ed
init|=
name|qobject_cast
argument_list|<
name|QTextEdit
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ed
condition|)
name|QWidgetTextControl
operator|::
name|insertFromMimeData
argument_list|(
name|source
argument_list|)
expr_stmt|;
else|else
name|ed
operator|->
name|insertFromMimeData
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_constructor
DECL|function|QTextEditPrivate
name|QTextEditPrivate
operator|::
name|QTextEditPrivate
parameter_list|()
member_init_list|:
name|control
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|autoFormatting
argument_list|(
name|QTextEdit
operator|::
name|AutoNone
argument_list|)
member_init_list|,
name|tabChangesFocus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|lineWrap
argument_list|(
name|QTextEdit
operator|::
name|WidgetWidth
argument_list|)
member_init_list|,
name|lineWrapColumnOrWidth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|wordWrap
argument_list|(
name|QTextOption
operator|::
name|WrapAtWordBoundaryOrAnywhere
argument_list|)
member_init_list|,
name|clickCausedFocus
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|textFormat
argument_list|(
name|Qt
operator|::
name|AutoText
argument_list|)
block|{
name|ignoreAutomaticScrollbarAdjustment
operator|=
literal|false
expr_stmt|;
name|preferRichText
operator|=
literal|false
expr_stmt|;
name|showCursorOnInitialShow
operator|=
literal|true
expr_stmt|;
name|inDrag
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|createAutoBulletList
name|void
name|QTextEditPrivate
operator|::
name|createAutoBulletList
parameter_list|()
block|{
name|QTextCursor
name|cursor
init|=
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|cursor
operator|.
name|beginEditBlock
argument_list|()
expr_stmt|;
name|QTextBlockFormat
name|blockFmt
init|=
name|cursor
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
name|QTextListFormat
name|listFmt
decl_stmt|;
name|listFmt
operator|.
name|setStyle
argument_list|(
name|QTextListFormat
operator|::
name|ListDisc
argument_list|)
expr_stmt|;
name|listFmt
operator|.
name|setIndent
argument_list|(
name|blockFmt
operator|.
name|indent
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|blockFmt
operator|.
name|setIndent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|blockFmt
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|createList
argument_list|(
name|listFmt
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|endEditBlock
argument_list|()
expr_stmt|;
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QTextEditPrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QString
modifier|&
name|html
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|control
operator|=
operator|new
name|QTextEditControl
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|control
operator|->
name|setPalette
argument_list|(
name|q
operator|->
name|palette
argument_list|()
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|microFocusChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|updateMicroFocus
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|documentSizeChanged
argument_list|(
name|QSizeF
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_adjustScrollbars
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|updateRequest
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_repaintContents
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|visibilityRequest
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_ensureVisible
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|currentCharFormatChanged
argument_list|(
name|QTextCharFormat
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_currentCharFormatChanged
argument_list|(
name|QTextCharFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|textChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|textChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|undoAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|undoAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|redoAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|redoAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|copyAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|copyAvailable
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|cursorPositionChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_cursorPositionChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|textChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|updateMicroFocus
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
comment|// set a null page size initially to avoid any relayouting until the textedit
comment|// is shown. relayoutDocument() will take care of setting the page size to the
comment|// viewport dimensions later.
name|doc
operator|->
name|setPageSize
argument_list|(
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|->
name|documentLayout
argument_list|()
operator|->
name|setPaintDevice
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
name|doc
operator|->
name|setDefaultFont
argument_list|(
name|q
operator|->
name|font
argument_list|()
argument_list|)
expr_stmt|;
name|doc
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// flush undo buffer.
name|doc
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|html
operator|.
name|isEmpty
argument_list|()
condition|)
name|control
operator|->
name|setHtml
argument_list|(
name|html
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setSingleStep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setSingleStep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|WheelFocus
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyCompression
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|viewport
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|IBeamCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_WS_WIN
name|setSingleFingerPanEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_repaintContents
name|void
name|QTextEditPrivate
operator|::
name|_q_repaintContents
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|contentsRect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|contentsRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|int
name|xOffset
init|=
name|horizontalOffset
argument_list|()
decl_stmt|;
specifier|const
name|int
name|yOffset
init|=
name|verticalOffset
argument_list|()
decl_stmt|;
specifier|const
name|QRectF
name|visibleRect
argument_list|(
name|xOffset
argument_list|,
name|yOffset
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|r
init|=
name|contentsRect
operator|.
name|intersected
argument_list|(
name|visibleRect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|r
operator|.
name|translate
argument_list|(
operator|-
name|xOffset
argument_list|,
operator|-
name|yOffset
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|update
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_cursorPositionChanged
name|void
name|QTextEditPrivate
operator|::
name|_q_cursorPositionChanged
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|cursorPositionChanged
argument_list|()
emit|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextCursorEvent
name|event
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|textCursor
argument_list|()
operator|.
name|position
argument_list|()
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|pageUpDown
name|void
name|QTextEditPrivate
operator|::
name|pageUpDown
parameter_list|(
name|QTextCursor
operator|::
name|MoveOperation
name|op
parameter_list|,
name|QTextCursor
operator|::
name|MoveMode
name|moveMode
parameter_list|)
block|{
name|QTextCursor
name|cursor
init|=
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|bool
name|moved
init|=
literal|false
decl_stmt|;
name|qreal
name|lastY
init|=
name|control
operator|->
name|cursorRect
argument_list|(
name|cursor
argument_list|)
operator|.
name|top
argument_list|()
decl_stmt|;
name|qreal
name|distance
init|=
literal|0
decl_stmt|;
comment|// move using movePosition to keep the cursor's x
do|do
block|{
name|qreal
name|y
init|=
name|control
operator|->
name|cursorRect
argument_list|(
name|cursor
argument_list|)
operator|.
name|top
argument_list|()
decl_stmt|;
name|distance
operator|+=
name|qAbs
argument_list|(
name|y
operator|-
name|lastY
argument_list|)
expr_stmt|;
name|lastY
operator|=
name|y
expr_stmt|;
name|moved
operator|=
name|cursor
operator|.
name|movePosition
argument_list|(
name|op
argument_list|,
name|moveMode
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|moved
operator|&&
name|distance
operator|<
name|viewport
operator|->
name|height
argument_list|()
condition|)
do|;
if|if
condition|(
name|moved
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|Up
condition|)
block|{
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Down
argument_list|,
name|moveMode
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderPageStepSub
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Up
argument_list|,
name|moveMode
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderPageStepAdd
argument_list|)
expr_stmt|;
block|}
block|}
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SCROLLBAR
end_ifndef
begin_function
DECL|function|documentSize
specifier|static
name|QSize
name|documentSize
parameter_list|(
name|QWidgetTextControl
modifier|*
name|control
parameter_list|)
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QAbstractTextDocumentLayout
modifier|*
name|layout
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
decl_stmt|;
name|QSize
name|docSize
decl_stmt|;
if|if
condition|(
name|QTextDocumentLayout
modifier|*
name|tlayout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|layout
argument_list|)
condition|)
block|{
name|docSize
operator|=
name|tlayout
operator|->
name|dynamicDocumentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
name|int
name|percentageDone
init|=
name|tlayout
operator|->
name|layoutStatus
argument_list|()
decl_stmt|;
comment|// extrapolate height
if|if
condition|(
name|percentageDone
operator|>
literal|0
condition|)
name|docSize
operator|.
name|setHeight
argument_list|(
name|docSize
operator|.
name|height
argument_list|()
operator|*
literal|100
operator|/
name|percentageDone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|docSize
operator|=
name|layout
operator|->
name|documentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
block|}
return|return
name|docSize
return|;
block|}
end_function
begin_function
DECL|function|_q_adjustScrollbars
name|void
name|QTextEditPrivate
operator|::
name|_q_adjustScrollbars
parameter_list|()
block|{
if|if
condition|(
name|ignoreAutomaticScrollbarAdjustment
condition|)
return|return;
name|ignoreAutomaticScrollbarAdjustment
operator|=
literal|true
expr_stmt|;
comment|// avoid recursion, #106108
name|QSize
name|viewportSize
init|=
name|viewport
operator|->
name|size
argument_list|()
decl_stmt|;
name|QSize
name|docSize
init|=
name|documentSize
argument_list|(
name|control
argument_list|)
decl_stmt|;
comment|// due to the recursion guard we have to repeat this step a few times,
comment|// as adding/removing a scroll bar will cause the document or viewport
comment|// size to change
comment|// ideally we should loop until the viewport size and doc size stabilize,
comment|// but in corner cases they might fluctuate, so we need to limit the
comment|// number of iterations
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|hbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|docSize
operator|.
name|width
argument_list|()
operator|-
name|viewportSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setPageStep
argument_list|(
name|viewportSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|docSize
operator|.
name|height
argument_list|()
operator|-
name|viewportSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setPageStep
argument_list|(
name|viewportSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
comment|// if we are in left-to-right mode widening the document due to
comment|// lazy layouting does not require a repaint. If in right-to-left
comment|// the scroll bar has the value zero and it visually has the maximum
comment|// value (it is visually at the right), then widening the document
comment|// keeps it at value zero but visually adjusts it to the new maximum
comment|// on the right, hence we need an update.
if|if
condition|(
name|q_func
argument_list|()
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
name|_q_showOrHideScrollBars
argument_list|()
expr_stmt|;
specifier|const
name|QSize
name|oldViewportSize
init|=
name|viewportSize
decl_stmt|;
specifier|const
name|QSize
name|oldDocSize
init|=
name|docSize
decl_stmt|;
comment|// make sure the document is layouted if the viewport width changes
name|viewportSize
operator|=
name|viewport
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|viewportSize
operator|.
name|width
argument_list|()
operator|!=
name|oldViewportSize
operator|.
name|width
argument_list|()
condition|)
name|relayoutDocument
argument_list|()
expr_stmt|;
name|docSize
operator|=
name|documentSize
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewportSize
operator|==
name|oldViewportSize
operator|&&
name|docSize
operator|==
name|oldDocSize
condition|)
break|break;
block|}
name|ignoreAutomaticScrollbarAdjustment
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// rect is in content coordinates
end_comment
begin_function
DECL|function|_q_ensureVisible
name|void
name|QTextEditPrivate
operator|::
name|_q_ensureVisible
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|_rect
parameter_list|)
block|{
specifier|const
name|QRect
name|rect
init|=
name|_rect
operator|.
name|toRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|vbar
operator|->
name|isVisible
argument_list|()
operator|&&
name|vbar
operator|->
name|maximum
argument_list|()
operator|<
name|rect
operator|.
name|bottom
argument_list|()
operator|)
operator|||
operator|(
name|hbar
operator|->
name|isVisible
argument_list|()
operator|&&
name|hbar
operator|->
name|maximum
argument_list|()
operator|<
name|rect
operator|.
name|right
argument_list|()
operator|)
condition|)
name|_q_adjustScrollbars
argument_list|()
expr_stmt|;
specifier|const
name|int
name|visibleWidth
init|=
name|viewport
operator|->
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|visibleHeight
init|=
name|viewport
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|rtl
init|=
name|q_func
argument_list|()
operator|->
name|isRightToLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|x
argument_list|()
operator|<
name|horizontalOffset
argument_list|()
condition|)
block|{
if|if
condition|(
name|rtl
condition|)
name|hbar
operator|->
name|setValue
argument_list|(
name|hbar
operator|->
name|maximum
argument_list|()
operator|-
name|rect
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|hbar
operator|->
name|setValue
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
operator|>
name|horizontalOffset
argument_list|()
operator|+
name|visibleWidth
condition|)
block|{
if|if
condition|(
name|rtl
condition|)
name|hbar
operator|->
name|setValue
argument_list|(
name|hbar
operator|->
name|maximum
argument_list|()
operator|-
operator|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
operator|-
name|visibleWidth
operator|)
argument_list|)
expr_stmt|;
else|else
name|hbar
operator|->
name|setValue
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
operator|-
name|visibleWidth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rect
operator|.
name|y
argument_list|()
operator|<
name|verticalOffset
argument_list|()
condition|)
name|vbar
operator|->
name|setValue
argument_list|(
name|rect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
operator|>
name|verticalOffset
argument_list|()
operator|+
name|visibleHeight
condition|)
name|vbar
operator|->
name|setValue
argument_list|(
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
operator|-
name|visibleHeight
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTextEdit     \brief The QTextEdit class provides a widget that is used to edit and display     both plain and rich text.      \ingroup richtext-processing     \inmodule QtWidgets      \tableofcontents      \section1 Introduction and Concepts      QTextEdit is an advanced WYSIWYG viewer/editor supporting rich     text formatting using HTML-style tags. It is optimized to handle     large documents and to respond quickly to user input.      QTextEdit works on paragraphs and characters. A paragraph is a     formatted string which is word-wrapped to fit into the width of     the widget. By default when reading plain text, one newline     signifies a paragraph. A document consists of zero or more     paragraphs. The words in the paragraph are aligned in accordance     with the paragraph's alignment. Paragraphs are separated by hard     line breaks. Each character within a paragraph has its own     attributes, for example, font and color.      QTextEdit can display images, lists and tables. If the text is     too large to view within the text edit's viewport, scroll bars will     appear. The text edit can load both plain text and rich text files.     Rich text is described using a subset of HTML 4 markup, refer to the     \l {Supported HTML Subset} page for more information.      If you just need to display a small piece of rich text use QLabel.      The rich text support in Qt is designed to provide a fast, portable and     efficient way to add reasonable online help facilities to     applications, and to provide a basis for rich text editors. If     you find the HTML support insufficient for your needs you may consider     the use of Qt WebKit, which provides a full-featured web browser     widget.      The shape of the mouse cursor on a QTextEdit is Qt::IBeamCursor by default.     It can be changed through the viewport()'s cursor property.      \section1 Using QTextEdit as a Display Widget      QTextEdit can display a large HTML subset, including tables and     images.      The text is set or replaced using setHtml() which deletes any     existing text and replaces it with the text passed in the     setHtml() call. If you call setHtml() with legacy HTML, and then     call toHtml(), the text that is returned may have different markup,     but will render the same. The entire text can be deleted with clear().      Text itself can be inserted using the QTextCursor class or using the     convenience functions insertHtml(), insertPlainText(), append() or     paste(). QTextCursor is also able to insert complex objects like tables     or lists into the document, and it deals with creating selections     and applying changes to selected text.      By default the text edit wraps words at whitespace to fit within     the text edit widget. The setLineWrapMode() function is used to     specify the kind of line wrap you want, or \l NoWrap if you don't     want any wrapping. Call setLineWrapMode() to set a fixed pixel width     \l FixedPixelWidth, or character column (e.g. 80 column) \l     FixedColumnWidth with the pixels or columns specified with     setLineWrapColumnOrWidth(). If you use word wrap to the widget's width     \l WidgetWidth, you can specify whether to break on whitespace or     anywhere with setWordWrapMode().      The find() function can be used to find and select a given string     within the text.      If you want to limit the total number of paragraphs in a QTextEdit,     as for example it is often useful in a log viewer, then you can use     QTextDocument's maximumBlockCount property for that.      \section2 Read-only Key Bindings      When QTextEdit is used read-only the key bindings are limited to     navigation, and text may only be selected with the mouse:     \table     \header \li Keypresses \li Action     \row \li Up        \li Moves one line up.     \row \li Down        \li Moves one line down.     \row \li Left        \li Moves one character to the left.     \row \li Right        \li Moves one character to the right.     \row \li PageUp        \li Moves one (viewport) page up.     \row \li PageDown        \li Moves one (viewport) page down.     \row \li Home        \li Moves to the beginning of the text.     \row \li End                \li Moves to the end of the text.     \row \li Alt+Wheel          \li Scrolls the page horizontally (the Wheel is the mouse wheel).     \row \li Ctrl+Wheel        \li Zooms the text.     \row \li Ctrl+A            \li Selects all text.     \endtable      The text edit may be able to provide some meta-information. For     example, the documentTitle() function will return the text from     within HTML \c{<title>} tags.      \section1 Using QTextEdit as an Editor      All the information about using QTextEdit as a display widget also     applies here.      The current char format's attributes are set with setFontItalic(),     setFontWeight(), setFontUnderline(), setFontFamily(),     setFontPointSize(), setTextColor() and setCurrentFont(). The current     paragraph's alignment is set with setAlignment().      Selection of text is handled by the QTextCursor class, which provides     functionality for creating selections, retrieving the text contents or     deleting selections. You can retrieve the object that corresponds with     the user-visible cursor using the textCursor() method. If you want to set     a selection in QTextEdit just create one on a QTextCursor object and     then make that cursor the visible cursor using setTextCursor(). The selection     can be copied to the clipboard with copy(), or cut to the clipboard with     cut(). The entire text can be selected using selectAll().      When the cursor is moved and the underlying formatting attributes change,     the currentCharFormatChanged() signal is emitted to reflect the new attributes     at the new cursor position.      QTextEdit holds a QTextDocument object which can be retrieved using the     document() method. You can also set your own document object using setDocument().     QTextDocument emits a textChanged() signal if the text changes and it also     provides a isModified() function which will return true if the text has been     modified since it was either loaded or since the last call to setModified     with false as argument. In addition it provides methods for undo and redo.      \section2 Drag and Drop      QTextEdit also supports custom drag and drop behavior. By default,     QTextEdit will insert plain text, HTML and rich text when the user drops     data of these MIME types onto a document. Reimplement     canInsertFromMimeData() and insertFromMimeData() to add support for     additional MIME types.      For example, to allow the user to drag and drop an image onto a QTextEdit,     you could the implement these functions in the following way:      \snippet textdocument-imagedrop/textedit.cpp 0      We add support for image MIME types by returning true. For all other     MIME types, we use the default implementation.      \snippet textdocument-imagedrop/textedit.cpp 1      We unpack the image from the QVariant held by the MIME source and insert     it into the document as a resource.      \section2 Editing Key Bindings      The list of key bindings which are implemented for editing:     \table     \header \li Keypresses \li Action     \row \li Backspace \li Deletes the character to the left of the cursor.     \row \li Delete \li Deletes the character to the right of the cursor.     \row \li Ctrl+C \li Copy the selected text to the clipboard.     \row \li Ctrl+Insert \li Copy the selected text to the clipboard.     \row \li Ctrl+K \li Deletes to the end of the line.     \row \li Ctrl+V \li Pastes the clipboard text into text edit.     \row \li Shift+Insert \li Pastes the clipboard text into text edit.     \row \li Ctrl+X \li Deletes the selected text and copies it to the clipboard.     \row \li Shift+Delete \li Deletes the selected text and copies it to the clipboard.     \row \li Ctrl+Z \li Undoes the last operation.     \row \li Ctrl+Y \li Redoes the last operation.     \row \li Left \li Moves the cursor one character to the left.     \row \li Ctrl+Left \li Moves the cursor one word to the left.     \row \li Right \li Moves the cursor one character to the right.     \row \li Ctrl+Right \li Moves the cursor one word to the right.     \row \li Up \li Moves the cursor one line up.     \row \li Down \li Moves the cursor one line down.     \row \li PageUp \li Moves the cursor one page up.     \row \li PageDown \li Moves the cursor one page down.     \row \li Home \li Moves the cursor to the beginning of the line.     \row \li Ctrl+Home \li Moves the cursor to the beginning of the text.     \row \li End \li Moves the cursor to the end of the line.     \row \li Ctrl+End \li Moves the cursor to the end of the text.     \row \li Alt+Wheel \li Scrolls the page horizontally (the Wheel is the mouse wheel).     \endtable      To select (mark) text hold down the Shift key whilst pressing one     of the movement keystrokes, for example, \e{Shift+Right}     will select the character to the right, and \e{Shift+Ctrl+Right} will select the word to the right, etc.      \sa QTextDocument, QTextCursor, {Application Example},         {Syntax Highlighter Example}, {Rich Text Processing} */
end_comment
begin_comment
comment|/*!     \property QTextEdit::plainText     \since 4.3      This property gets and sets the text editor's contents as plain     text. Previous contents are removed and undo/redo history is reset     when the property is set.      If the text edit has another content type, it will not be replaced     by plain text if you call toPlainText(). The only exception to this     is the non-break space, \e{nbsp;}, that will be converted into     standard space.      By default, for an editor with no contents, this property contains     an empty string.      \sa html */
end_comment
begin_comment
comment|/*!     \property QTextEdit::undoRedoEnabled     \brief whether undo and redo are enabled      Users are only able to undo or redo actions if this property is     true, and if there is an action that can be undone (or redone). */
end_comment
begin_comment
comment|/*!     \enum QTextEdit::LineWrapMode      \value NoWrap     \value WidgetWidth     \value FixedPixelWidth     \value FixedColumnWidth */
end_comment
begin_comment
comment|/*!     \enum QTextEdit::AutoFormattingFlag      \value AutoNone Don't do any automatic formatting.     \value AutoBulletList Automatically create bullet lists (e.g. when     the user enters an asterisk ('*') in the left most column, or     presses Enter in an existing list item.     \value AutoAll Apply all automatic formatting. Currently only     automatic bullet lists are supported. */
end_comment
begin_comment
comment|/*!     Constructs an empty QTextEdit with parent \a     parent. */
end_comment
begin_constructor
DECL|function|QTextEdit
name|QTextEdit
operator|::
name|QTextEdit
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|new
name|QTextEditPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QTextEdit
name|QTextEdit
operator|::
name|QTextEdit
parameter_list|(
name|QTextEditPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextEdit with parent \a parent. The text edit will display     the text \a text. The text is interpreted as html. */
end_comment
begin_constructor
DECL|function|QTextEdit
name|QTextEdit
operator|::
name|QTextEdit
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|new
name|QTextEditPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QTextEdit
name|QTextEdit
operator|::
name|~
name|QTextEdit
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the point size of the font of the current format.      \sa setFontFamily(), setCurrentFont(), setFontPointSize() */
end_comment
begin_function
DECL|function|fontPointSize
name|qreal
name|QTextEdit
operator|::
name|fontPointSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|fontPointSize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the font family of the current format.      \sa setFontFamily(), setCurrentFont(), setFontPointSize() */
end_comment
begin_function
DECL|function|fontFamily
name|QString
name|QTextEdit
operator|::
name|fontFamily
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|fontFamily
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the font weight of the current format.      \sa setFontWeight(), setCurrentFont(), setFontPointSize(), QFont::Weight */
end_comment
begin_function
DECL|function|fontWeight
name|int
name|QTextEdit
operator|::
name|fontWeight
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|fontWeight
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the font of the current format is underlined; otherwise returns     false.      \sa setFontUnderline() */
end_comment
begin_function
DECL|function|fontUnderline
name|bool
name|QTextEdit
operator|::
name|fontUnderline
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|fontUnderline
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the font of the current format is italic; otherwise returns     false.      \sa setFontItalic() */
end_comment
begin_function
DECL|function|fontItalic
name|bool
name|QTextEdit
operator|::
name|fontItalic
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|fontItalic
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text color of the current format.      \sa setTextColor() */
end_comment
begin_function
DECL|function|textColor
name|QColor
name|QTextEdit
operator|::
name|textColor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|foreground
argument_list|()
operator|.
name|color
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the text background color of the current format.      \sa setTextBackgroundColor() */
end_comment
begin_function
DECL|function|textBackgroundColor
name|QColor
name|QTextEdit
operator|::
name|textBackgroundColor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|background
argument_list|()
operator|.
name|color
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the font of the current format.      \sa setCurrentFont(), setFontFamily(), setFontPointSize() */
end_comment
begin_function
DECL|function|currentFont
name|QFont
name|QTextEdit
operator|::
name|currentFont
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|charFormat
argument_list|()
operator|.
name|font
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the alignment of the current paragraph to \a a. Valid     alignments are Qt::AlignLeft, Qt::AlignRight,     Qt::AlignJustify and Qt::AlignCenter (which centers     horizontally). */
end_comment
begin_function
DECL|function|setAlignment
name|void
name|QTextEdit
operator|::
name|setAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|a
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|QTextBlockFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setAlignment
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|cursor
operator|.
name|mergeBlockFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the alignment of the current paragraph.      \sa setAlignment() */
end_comment
begin_function
DECL|function|alignment
name|Qt
operator|::
name|Alignment
name|QTextEdit
operator|::
name|alignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|blockFormat
argument_list|()
operator|.
name|alignment
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::document     \brief the underlying document of the text editor.      \note The editor \e{does not take ownership of the document} unless it     is the document's parent object. The parent object of the provided document     remains the owner of the object. The editor does not delete any previously     assigned document, even if it is a child of the editor. */
end_comment
begin_function
DECL|function|setDocument
name|void
name|QTextEdit
operator|::
name|setDocument
parameter_list|(
name|QTextDocument
modifier|*
name|document
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateDefaultTextOption
argument_list|()
expr_stmt|;
name|d
operator|->
name|relayoutDocument
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|document
name|QTextDocument
modifier|*
name|QTextEdit
operator|::
name|document
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the visible \a cursor. */
end_comment
begin_function
DECL|function|setTextCursor
name|void
name|QTextEdit
operator|::
name|setTextCursor
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|doSetTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal       This provides a hook for subclasses to intercept cursor changes. */
end_comment
begin_function
DECL|function|doSetTextCursor
name|void
name|QTextEdit
operator|::
name|doSetTextCursor
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the QTextCursor that represents the currently visible cursor.     Note that changes on the returned cursor do not affect QTextEdit's cursor; use     setTextCursor() to update the visible cursor.  */
end_comment
begin_function
DECL|function|textCursor
name|QTextCursor
name|QTextEdit
operator|::
name|textCursor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the font family of the current format to \a fontFamily.      \sa fontFamily(), setCurrentFont() */
end_comment
begin_function
DECL|function|setFontFamily
name|void
name|QTextEdit
operator|::
name|setFontFamily
parameter_list|(
specifier|const
name|QString
modifier|&
name|fontFamily
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontFamily
argument_list|(
name|fontFamily
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the point size of the current format to \a s.      Note that if \a s is zero or negative, the behavior of this     function is not defined.      \sa fontPointSize(), setCurrentFont(), setFontFamily() */
end_comment
begin_function
DECL|function|setFontPointSize
name|void
name|QTextEdit
operator|::
name|setFontPointSize
parameter_list|(
name|qreal
name|s
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontPointSize
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextEdit::setFontWeight(int weight)      Sets the font weight of the current format to the given \a weight,     where the value used is in the range defined by the QFont::Weight     enum.      \sa fontWeight(), setCurrentFont(), setFontFamily() */
end_comment
begin_function
DECL|function|setFontWeight
name|void
name|QTextEdit
operator|::
name|setFontWeight
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontWeight
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a underline is true, sets the current format to underline;     otherwise sets the current format to non-underline.      \sa fontUnderline() */
end_comment
begin_function
DECL|function|setFontUnderline
name|void
name|QTextEdit
operator|::
name|setFontUnderline
parameter_list|(
name|bool
name|underline
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontUnderline
argument_list|(
name|underline
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a italic is true, sets the current format to italic;     otherwise sets the current format to non-italic.      \sa fontItalic() */
end_comment
begin_function
DECL|function|setFontItalic
name|void
name|QTextEdit
operator|::
name|setFontItalic
parameter_list|(
name|bool
name|italic
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontItalic
argument_list|(
name|italic
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the text color of the current format to \a c.      \sa textColor() */
end_comment
begin_function
DECL|function|setTextColor
name|void
name|QTextEdit
operator|::
name|setTextColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setForeground
argument_list|(
name|QBrush
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the text background color of the current format to \a c.      \sa textBackgroundColor() */
end_comment
begin_function
DECL|function|setTextBackgroundColor
name|void
name|QTextEdit
operator|::
name|setTextBackgroundColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|c
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setBackground
argument_list|(
name|QBrush
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the font of the current format to \a f.      \sa currentFont(), setFontPointSize(), setFontFamily() */
end_comment
begin_function
DECL|function|setCurrentFont
name|void
name|QTextEdit
operator|::
name|setCurrentFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|f
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFont
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mergeCurrentCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Undoes the last operation.      If there is no operation to undo, i.e. there is no undo step in     the undo/redo history, nothing happens.      \sa redo() */
end_comment
begin_function
DECL|function|undo
name|void
name|QTextEdit
operator|::
name|undo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|undo
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|redo
name|void
name|QTextEdit
operator|::
name|redo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|redo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextEdit::redo()     \since 4.2      Redoes the last operation.      If there is no operation to redo, i.e. there is no redo step in     the undo/redo history, nothing happens.      \sa undo() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_comment
comment|/*!     Copies the selected text to the clipboard and deletes it from     the text edit.      If there is no selected text nothing happens.      \sa copy(), paste() */
end_comment
begin_function
DECL|function|cut
name|void
name|QTextEdit
operator|::
name|cut
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|cut
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Copies any selected text to the clipboard.      \sa copyAvailable() */
end_comment
begin_function
DECL|function|copy
name|void
name|QTextEdit
operator|::
name|copy
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|copy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Pastes the text from the clipboard into the text edit at the     current cursor position.      If there is no text in the clipboard nothing happens.      To change the behavior of this function, i.e. to modify what     QTextEdit can paste and how it is being pasted, reimplement the     virtual canInsertFromMimeData() and insertFromMimeData()     functions.      \sa cut(), copy() */
end_comment
begin_function
DECL|function|paste
name|void
name|QTextEdit
operator|::
name|paste
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|paste
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Deletes all the text in the text edit.      Note that the undo/redo history is cleared by this function.      \sa cut(), setPlainText(), setHtml() */
end_comment
begin_function
DECL|function|clear
name|void
name|QTextEdit
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
comment|// clears and sets empty content
name|d
operator|->
name|control
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Selects all text.      \sa copy(), cut(), textCursor()  */
end_comment
begin_function
DECL|function|selectAll
name|void
name|QTextEdit
operator|::
name|selectAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|selectAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|event
name|bool
name|QTextEdit
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ContextMenu
operator|&&
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
operator|->
name|reason
argument_list|()
operator|==
name|QContextMenuEvent
operator|::
name|Keyboard
condition|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|ensureCursorVisible
argument_list|()
expr_stmt|;
specifier|const
name|QPoint
name|cursorPos
init|=
name|cursorRect
argument_list|()
operator|.
name|center
argument_list|()
decl_stmt|;
name|QContextMenuEvent
name|ce
argument_list|(
name|QContextMenuEvent
operator|::
name|Keyboard
argument_list|,
name|cursorPos
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|mapToGlobal
argument_list|(
name|cursorPos
argument_list|)
argument_list|)
decl_stmt|;
name|ce
operator|.
name|setAccepted
argument_list|(
name|e
operator|->
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|result
init|=
name|QAbstractScrollArea
operator|::
name|event
argument_list|(
operator|&
name|ce
argument_list|)
decl_stmt|;
name|e
operator|->
name|setAccepted
argument_list|(
name|ce
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ShortcutOverride
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ToolTip
condition|)
block|{
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|EnterEditFocus
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LeaveEditFocus
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QAbstractScrollArea
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QTextEdit
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|autoScrollTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|QRect
name|visible
init|=
name|d
operator|->
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
name|QPoint
name|pos
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|inDrag
condition|)
block|{
name|pos
operator|=
name|d
operator|->
name|autoScrollDragPos
expr_stmt|;
name|visible
operator|.
name|adjust
argument_list|(
name|qMin
argument_list|(
name|visible
operator|.
name|width
argument_list|()
operator|/
literal|3
argument_list|,
literal|20
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|visible
operator|.
name|height
argument_list|()
operator|/
literal|3
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|-
name|qMin
argument_list|(
name|visible
operator|.
name|width
argument_list|()
operator|/
literal|3
argument_list|,
literal|20
argument_list|)
argument_list|,
operator|-
name|qMin
argument_list|(
name|visible
operator|.
name|height
argument_list|()
operator|/
literal|3
argument_list|,
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QPoint
name|globalPos
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
name|pos
operator|=
name|d
operator|->
name|viewport
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
expr_stmt|;
name|QMouseEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|pos
argument_list|,
name|mapTo
argument_list|(
name|topLevelWidget
argument_list|()
argument_list|,
name|pos
argument_list|)
argument_list|,
name|globalPos
argument_list|,
name|Qt
operator|::
name|LeftButton
argument_list|,
name|Qt
operator|::
name|LeftButton
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
name|mouseMoveEvent
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
name|int
name|deltaY
init|=
name|qMax
argument_list|(
name|pos
operator|.
name|y
argument_list|()
operator|-
name|visible
operator|.
name|top
argument_list|()
argument_list|,
name|visible
operator|.
name|bottom
argument_list|()
operator|-
name|pos
operator|.
name|y
argument_list|()
argument_list|)
operator|-
name|visible
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|deltaX
init|=
name|qMax
argument_list|(
name|pos
operator|.
name|x
argument_list|()
operator|-
name|visible
operator|.
name|left
argument_list|()
argument_list|,
name|visible
operator|.
name|right
argument_list|()
operator|-
name|pos
operator|.
name|x
argument_list|()
argument_list|)
operator|-
name|visible
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|delta
init|=
name|qMax
argument_list|(
name|deltaX
argument_list|,
name|deltaY
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|delta
operator|<
literal|7
condition|)
name|delta
operator|=
literal|7
expr_stmt|;
name|int
name|timeout
init|=
literal|4900
operator|/
operator|(
name|delta
operator|*
name|delta
operator|)
decl_stmt|;
name|d
operator|->
name|autoScrollTimer
operator|.
name|start
argument_list|(
name|timeout
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaY
operator|>
literal|0
condition|)
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|pos
operator|.
name|y
argument_list|()
operator|<
name|visible
operator|.
name|center
argument_list|()
operator|.
name|y
argument_list|()
condition|?
name|QAbstractSlider
operator|::
name|SliderSingleStepSub
else|:
name|QAbstractSlider
operator|::
name|SliderSingleStepAdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaX
operator|>
literal|0
condition|)
name|d
operator|->
name|hbar
operator|->
name|triggerAction
argument_list|(
name|pos
operator|.
name|x
argument_list|()
operator|<
name|visible
operator|.
name|center
argument_list|()
operator|.
name|x
argument_list|()
condition|?
name|QAbstractSlider
operator|::
name|SliderSingleStepSub
else|:
name|QAbstractSlider
operator|::
name|SliderSingleStepAdd
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
elseif|else
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|deleteAllTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|deleteAllTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Changes the text of the text edit to the string \a text.     Any previous text is removed.      \a text is interpreted as plain text.      Note that the undo/redo history is cleared by this function.      \sa toPlainText() */
end_comment
begin_function
DECL|function|setPlainText
name|void
name|QTextEdit
operator|::
name|setPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|d
operator|->
name|preferRichText
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     QString QTextEdit::toPlainText() const      Returns the text of the text edit as plain text.      \sa QTextEdit::setPlainText()  */
end_comment
begin_function
DECL|function|toPlainText
name|QString
name|QTextEdit
operator|::
name|toPlainText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|toPlainText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::html      This property provides an HTML interface to the text of the text edit.      toHtml() returns the text of the text edit as html.      setHtml() changes the text of the text edit.  Any previous text is     removed and the undo/redo history is cleared. The input text is     interpreted as rich text in html format.      \note It is the responsibility of the caller to make sure that the     text is correctly decoded when a QString containing HTML is created     and passed to setHtml().      By default, for a newly-created, empty document, this property contains     text to describe an HTML 4.0 document with no body text.      \sa {Supported HTML Subset}, plainText */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|setHtml
name|void
name|QTextEdit
operator|::
name|setHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setHtml
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|d
operator|->
name|preferRichText
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toHtml
name|QString
name|QTextEdit
operator|::
name|toHtml
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|toHtml
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QTextEdit
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
comment|// code assumes linksaccessible + editable isn't meaningful
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
condition|)
block|{
name|setEditFocus
argument_list|(
operator|!
name|hasEditFocus
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hasEditFocus
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
block|{
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|QTextCharFormat
name|charFmt
init|=
name|cursor
operator|.
name|charFormat
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|LinksAccessibleByKeyboard
operator|)
operator|||
operator|!
name|cursor
operator|.
name|hasSelection
argument_list|()
operator|||
name|charFmt
operator|.
name|anchorHref
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
case|case
name|Qt
operator|::
name|Key_No
case|:
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|||
operator|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
operator|)
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|!
operator|(
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|text
argument_list|()
index|[
literal|0
index|]
operator|.
name|isPrint
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
break|break;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|Qt
operator|::
name|TextInteractionFlags
name|tif
init|=
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
decl_stmt|;
if|if
condition|(
name|tif
operator|&
name|Qt
operator|::
name|TextSelectableByKeyboard
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|SelectPreviousPage
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|pageUpDown
argument_list|(
name|QTextCursor
operator|::
name|Up
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|SelectNextPage
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|pageUpDown
argument_list|(
name|QTextCursor
operator|::
name|Down
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|tif
operator|&
operator|(
name|Qt
operator|::
name|TextSelectableByKeyboard
operator||
name|Qt
operator|::
name|TextEditable
operator|)
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|MoveToPreviousPage
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|pageUpDown
argument_list|(
name|QTextCursor
operator|::
name|Up
argument_list|,
name|QTextCursor
operator|::
name|MoveAnchor
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|MoveToNextPage
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|pageUpDown
argument_list|(
name|QTextCursor
operator|::
name|Down
argument_list|,
name|QTextCursor
operator|::
name|MoveAnchor
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|tif
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Space
case|:
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
condition|)
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderPageStepSub
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderPageStepAdd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|isAccepted
argument_list|()
operator|&&
name|e
operator|->
name|modifiers
argument_list|()
operator|==
name|Qt
operator|::
name|NoModifier
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Home
condition|)
block|{
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderToMinimum
argument_list|)
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_End
condition|)
block|{
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderToMaximum
argument_list|)
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
name|QAbstractScrollArea
operator|::
name|keyPressEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
endif|#
directive|endif
comment|// QT_NO_SHORTCUT
block|{
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
specifier|const
name|QString
name|text
init|=
name|e
operator|->
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
name|cursor
operator|.
name|atBlockStart
argument_list|()
operator|&&
operator|(
name|d
operator|->
name|autoFormatting
operator|&
name|AutoBulletList
operator|)
operator|&&
operator|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|text
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|||
name|text
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|cursor
operator|.
name|currentList
argument_list|()
operator|)
condition|)
block|{
name|d
operator|->
name|createAutoBulletList
argument_list|()
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|!
name|e
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Up
case|:
case|case
name|Qt
operator|::
name|Key_Down
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
comment|// Cursor position didn't change, so we want to leave
comment|// these keys to change focus.
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|isAutoRepeat
argument_list|()
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|document
argument_list|()
operator|->
name|isEmpty
argument_list|()
operator|||
operator|!
operator|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
condition|)
block|{
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|deleteAllTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|deleteAllTimer
operator|.
name|start
argument_list|(
literal|750
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QTextEdit
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|isAutoRepeat
argument_list|()
operator|&&
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Back
operator|&&
name|d
operator|->
name|deleteAllTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|d
operator|->
name|deleteAllTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|QTextBlockFormat
name|blockFmt
init|=
name|cursor
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
name|QTextList
modifier|*
name|list
init|=
name|cursor
operator|.
name|currentList
argument_list|()
decl_stmt|;
if|if
condition|(
name|list
operator|&&
name|cursor
operator|.
name|atBlockStart
argument_list|()
condition|)
block|{
name|list
operator|->
name|remove
argument_list|(
name|cursor
operator|.
name|block
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor
operator|.
name|atBlockStart
argument_list|()
operator|&&
name|blockFmt
operator|.
name|indent
argument_list|()
operator|>
literal|0
condition|)
block|{
name|blockFmt
operator|.
name|setIndent
argument_list|(
name|blockFmt
operator|.
name|indent
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setBlockFormat
argument_list|(
name|blockFmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|.
name|deletePreviousChar
argument_list|()
expr_stmt|;
block|}
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Loads the resource specified by the given \a type and \a name.      This function is an extension of QTextDocument::loadResource().      \sa QTextDocument::loadResource() */
end_comment
begin_function
DECL|function|loadResource
name|QVariant
name|QTextEdit
operator|::
name|loadResource
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QTextEdit
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lineWrap
operator|==
name|NoWrap
condition|)
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QVariant
name|alignmentProperty
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
operator|->
name|property
argument_list|(
literal|"contentHasAlignment"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doc
operator|->
name|pageSize
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|alignmentProperty
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Bool
operator|&&
operator|!
name|alignmentProperty
operator|.
name|toBool
argument_list|()
condition|)
block|{
name|d
operator|->
name|_q_adjustScrollbars
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|lineWrap
operator|!=
name|FixedPixelWidth
operator|&&
name|e
operator|->
name|oldSize
argument_list|()
operator|.
name|width
argument_list|()
operator|!=
name|e
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
condition|)
name|d
operator|->
name|relayoutDocument
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|_q_adjustScrollbars
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|relayoutDocument
name|void
name|QTextEditPrivate
operator|::
name|relayoutDocument
parameter_list|()
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QAbstractTextDocumentLayout
modifier|*
name|layout
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
decl_stmt|;
if|if
condition|(
name|QTextDocumentLayout
modifier|*
name|tlayout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|layout
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineWrap
operator|==
name|QTextEdit
operator|::
name|FixedColumnWidth
condition|)
name|tlayout
operator|->
name|setFixedColumnWidth
argument_list|(
name|lineWrapColumnOrWidth
argument_list|)
expr_stmt|;
else|else
name|tlayout
operator|->
name|setFixedColumnWidth
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|QTextDocumentLayout
modifier|*
name|tlayout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|layout
argument_list|)
decl_stmt|;
name|QSize
name|lastUsedSize
decl_stmt|;
if|if
condition|(
name|tlayout
condition|)
name|lastUsedSize
operator|=
name|tlayout
operator|->
name|dynamicDocumentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
else|else
name|lastUsedSize
operator|=
name|layout
operator|->
name|documentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
comment|// ignore calls to _q_adjustScrollbars caused by an emission of the
comment|// usedSizeChanged() signal in the layout, as we're calling it
comment|// later on our own anyway (or deliberately not) .
specifier|const
name|bool
name|oldIgnoreScrollbarAdjustment
init|=
name|ignoreAutomaticScrollbarAdjustment
decl_stmt|;
name|ignoreAutomaticScrollbarAdjustment
operator|=
literal|true
expr_stmt|;
name|int
name|width
init|=
name|viewport
operator|->
name|width
argument_list|()
decl_stmt|;
if|if
condition|(
name|lineWrap
operator|==
name|QTextEdit
operator|::
name|FixedPixelWidth
condition|)
name|width
operator|=
name|lineWrapColumnOrWidth
expr_stmt|;
elseif|else
if|if
condition|(
name|lineWrap
operator|==
name|QTextEdit
operator|::
name|NoWrap
condition|)
block|{
name|QVariant
name|alignmentProperty
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
operator|->
name|property
argument_list|(
literal|"contentHasAlignment"
argument_list|)
decl_stmt|;
if|if
condition|(
name|alignmentProperty
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Bool
operator|&&
operator|!
name|alignmentProperty
operator|.
name|toBool
argument_list|()
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|doc
operator|->
name|setPageSize
argument_list|(
name|QSize
argument_list|(
name|width
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlayout
condition|)
name|tlayout
operator|->
name|ensureLayouted
argument_list|(
name|verticalOffset
argument_list|()
operator|+
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|ignoreAutomaticScrollbarAdjustment
operator|=
name|oldIgnoreScrollbarAdjustment
expr_stmt|;
name|QSize
name|usedSize
decl_stmt|;
if|if
condition|(
name|tlayout
condition|)
name|usedSize
operator|=
name|tlayout
operator|->
name|dynamicDocumentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
else|else
name|usedSize
operator|=
name|layout
operator|->
name|documentSize
argument_list|()
operator|.
name|toSize
argument_list|()
expr_stmt|;
comment|// this is an obscure situation in the layout that can happen:
comment|// if a character at the end of a line is the tallest one and therefore
comment|// influencing the total height of the line and the line right below it
comment|// is always taller though, then it can happen that if due to line breaking
comment|// that tall character wraps into the lower line the document not only shrinks
comment|// horizontally (causing the character to wrap in the first place) but also
comment|// vertically, because the original line is now smaller and the one below kept
comment|// its size. So a layout with less width _can_ take up less vertical space, too.
comment|// If the wider case causes a vertical scroll bar to appear and the narrower one
comment|// (narrower because the vertical scroll bar takes up horizontal space)) to disappear
comment|// again then we have an endless loop, as _q_adjustScrollBars sets new ranges on the
comment|// scroll bars, the QAbstractScrollArea will find out about it and try to show/hide
comment|// the scroll bars again. That's why we try to detect this case here and break out.
comment|//
comment|// (if you change this please also check the layoutingLoop() testcase in
comment|// QTextEdit's autotests)
if|if
condition|(
name|lastUsedSize
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|vbar
operator|->
name|isHidden
argument_list|()
operator|&&
name|viewport
operator|->
name|width
argument_list|()
operator|<
name|lastUsedSize
operator|.
name|width
argument_list|()
operator|&&
name|usedSize
operator|.
name|height
argument_list|()
operator|<
name|lastUsedSize
operator|.
name|height
argument_list|()
operator|&&
name|usedSize
operator|.
name|height
argument_list|()
operator|<=
name|viewport
operator|->
name|height
argument_list|()
condition|)
return|return;
name|_q_adjustScrollbars
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|paint
name|void
name|QTextEditPrivate
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|QPaintEvent
modifier|*
name|e
parameter_list|)
block|{
specifier|const
name|int
name|xOffset
init|=
name|horizontalOffset
argument_list|()
decl_stmt|;
specifier|const
name|int
name|yOffset
init|=
name|verticalOffset
argument_list|()
decl_stmt|;
name|QRect
name|r
init|=
name|e
operator|->
name|rect
argument_list|()
decl_stmt|;
name|p
operator|->
name|translate
argument_list|(
operator|-
name|xOffset
argument_list|,
operator|-
name|yOffset
argument_list|)
expr_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|xOffset
argument_list|,
name|yOffset
argument_list|)
expr_stmt|;
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QTextDocumentLayout
modifier|*
name|layout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|doc
operator|->
name|documentLayout
argument_list|()
argument_list|)
decl_stmt|;
comment|// the layout might need to expand the root frame to
comment|// the viewport if NoWrap is set
if|if
condition|(
name|layout
condition|)
name|layout
operator|->
name|setViewport
argument_list|(
name|viewport
operator|->
name|rect
argument_list|()
argument_list|)
expr_stmt|;
name|control
operator|->
name|drawContents
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
condition|)
name|layout
operator|->
name|setViewport
argument_list|(
name|QRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn void QTextEdit::paintEvent(QPaintEvent *event)  This event handler can be reimplemented in a subclass to receive paint events passed in \a event. It is usually unnecessary to reimplement this function in a subclass of QTextEdit.  \warning The underlying text document must not be modified from within a reimplementation of this function. */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QTextEdit
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
decl_stmt|;
name|d
operator|->
name|paint
argument_list|(
operator|&
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_currentCharFormatChanged
name|void
name|QTextEditPrivate
operator|::
name|_q_currentCharFormatChanged
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|fmt
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|currentCharFormatChanged
argument_list|(
name|fmt
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|updateDefaultTextOption
name|void
name|QTextEditPrivate
operator|::
name|updateDefaultTextOption
parameter_list|()
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QTextOption
name|opt
init|=
name|doc
operator|->
name|defaultTextOption
argument_list|()
decl_stmt|;
name|QTextOption
operator|::
name|WrapMode
name|oldWrapMode
init|=
name|opt
operator|.
name|wrapMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|lineWrap
operator|==
name|QTextEdit
operator|::
name|NoWrap
condition|)
name|opt
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|NoWrap
argument_list|)
expr_stmt|;
else|else
name|opt
operator|.
name|setWrapMode
argument_list|(
name|wordWrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|.
name|wrapMode
argument_list|()
operator|!=
name|oldWrapMode
condition|)
name|doc
operator|->
name|setDefaultTextOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QTextEdit
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QTextEdit
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|inDrag
operator|=
literal|false
expr_stmt|;
comment|// paranoia
specifier|const
name|QPoint
name|pos
init|=
name|e
operator|->
name|pos
argument_list|()
decl_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
condition|)
return|return;
name|QRect
name|visible
init|=
name|d
operator|->
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
if|if
condition|(
name|visible
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|autoScrollTimer
operator|.
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|autoScrollTimer
operator|.
name|start
argument_list|(
literal|100
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QTextEdit
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoScrollTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|ensureCursorVisible
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
operator|&&
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|d
operator|->
name|handleSoftwareInputPanel
argument_list|(
name|e
operator|->
name|button
argument_list|()
argument_list|,
name|d
operator|->
name|clickCausedFocus
argument_list|)
expr_stmt|;
name|d
operator|->
name|clickCausedFocus
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QTextEdit
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QTextEdit
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|tabChangesFocus
operator|&&
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
condition|)
return|return
literal|false
return|;
return|return
name|QAbstractScrollArea
operator|::
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!   \fn void QTextEdit::contextMenuEvent(QContextMenuEvent *event)    Shows the standard context menu created with createStandardContextMenu().    If you do not want the text edit to have a context menu, you can set   its \l contextMenuPolicy to Qt::NoContextMenu. If you want to   customize the context menu, reimplement this function. If you want   to extend the standard context menu, reimplement this function, call   createStandardContextMenu() and extend the menu returned.    Information about the event is passed in the \a event object.    \snippet code/src_gui_widgets_qtextedit.cpp 0 */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QTextEdit
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QTextEdit
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|inDrag
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QTextEdit
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|inDrag
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QTextEdit
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoScrollDragPos
operator|=
name|e
operator|->
name|pos
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|autoScrollTimer
operator|.
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|autoScrollTimer
operator|.
name|start
argument_list|(
literal|100
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QTextEdit
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|inDrag
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QTextEdit
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|&&
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ensureCursorVisible
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|scrollContentsBy
name|void
name|QTextEdit
operator|::
name|scrollContentsBy
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QTextEdit
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|property
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
name|QVariant
name|v
decl_stmt|;
switch|switch
condition|(
name|property
condition|)
block|{
case|case
name|Qt
operator|::
name|ImHints
case|:
name|v
operator|=
name|QWidget
operator|::
name|inputMethodQuery
argument_list|(
name|property
argument_list|)
expr_stmt|;
break|break;
default|default:
name|v
operator|=
name|d
operator|->
name|control
operator|->
name|inputMethodQuery
argument_list|(
name|property
argument_list|)
expr_stmt|;
specifier|const
name|QPoint
name|offset
argument_list|(
operator|-
name|d
operator|->
name|horizontalOffset
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalOffset
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|RectF
condition|)
name|v
operator|=
name|v
operator|.
name|toRectF
argument_list|()
operator|.
name|toRect
argument_list|()
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|PointF
condition|)
name|v
operator|=
name|v
operator|.
name|toPointF
argument_list|()
operator|.
name|toPoint
argument_list|()
operator|+
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Rect
condition|)
name|v
operator|=
name|v
operator|.
name|toRect
argument_list|()
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Point
condition|)
name|v
operator|=
name|v
operator|.
name|toPoint
argument_list|()
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QTextEdit
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|MouseFocusReason
condition|)
block|{
name|d
operator|->
name|clickCausedFocus
operator|=
literal|1
expr_stmt|;
block|}
name|QAbstractScrollArea
operator|::
name|focusInEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QTextEdit
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|focusOutEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QTextEdit
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|anchorToScrollToWhenVisible
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|scrollToAnchor
argument_list|(
name|d
operator|->
name|anchorToScrollToWhenVisible
argument_list|)
expr_stmt|;
name|d
operator|->
name|anchorToScrollToWhenVisible
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|showCursorOnInitialShow
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|showCursorOnInitialShow
condition|)
block|{
name|d
operator|->
name|showCursorOnInitialShow
operator|=
literal|false
expr_stmt|;
name|ensureCursorVisible
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QTextEdit
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|changeEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ApplicationFontChange
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FontChange
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|setDefaultFont
argument_list|(
name|font
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ActivationChange
condition|)
block|{
if|if
condition|(
operator|!
name|isActiveWindow
argument_list|()
condition|)
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|EnabledChange
condition|)
block|{
name|e
operator|->
name|setAccepted
argument_list|(
name|isEnabled
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setPalette
argument_list|(
name|palette
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|PaletteChange
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|setPalette
argument_list|(
name|palette
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LayoutDirectionChange
condition|)
block|{
name|d
operator|->
name|sendControlEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_function
DECL|function|wheelEvent
name|void
name|QTextEdit
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
block|{
specifier|const
name|int
name|delta
init|=
name|e
operator|->
name|delta
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|zoomOut
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|zoomIn
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|QAbstractScrollArea
operator|::
name|wheelEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|updateMicroFocus
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!  This function creates the standard context menu which is shown   when the user clicks on the text edit with the right mouse   button. It is called from the default contextMenuEvent() handler.   The popup menu's ownership is transferred to the caller.    We recommend that you use the createStandardContextMenu(QPoint) version instead   which will enable the actions that are sensitive to where the user clicked. */
end_comment
begin_function
DECL|function|createStandardContextMenu
name|QMenu
modifier|*
name|QTextEdit
operator|::
name|createStandardContextMenu
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|createStandardContextMenu
argument_list|(
name|QPointF
argument_list|()
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4   This function creates the standard context menu which is shown   when the user clicks on the text edit with the right mouse   button. It is called from the default contextMenuEvent() handler   and it takes the \a position of where the mouse click was.   This can enable actions that are sensitive to the position where the user clicked.   The popup menu's ownership is transferred to the caller. */
end_comment
begin_function
DECL|function|createStandardContextMenu
name|QMenu
modifier|*
name|QTextEdit
operator|::
name|createStandardContextMenu
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|position
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|createStandardContextMenu
argument_list|(
name|position
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_comment
comment|/*!   returns a QTextCursor at position \a pos (in viewport coordinates). */
end_comment
begin_function
DECL|function|cursorForPosition
name|QTextCursor
name|QTextEdit
operator|::
name|cursorForPosition
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|cursorForPosition
argument_list|(
name|d
operator|->
name|mapToContents
argument_list|(
name|pos
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   returns a rectangle (in viewport coordinates) that includes the   \a cursor.  */
end_comment
begin_function
DECL|function|cursorRect
name|QRect
name|QTextEdit
operator|::
name|cursorRect
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QRect
name|r
init|=
name|d
operator|->
name|control
operator|->
name|cursorRect
argument_list|(
name|cursor
argument_list|)
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|r
operator|.
name|translate
argument_list|(
operator|-
name|d
operator|->
name|horizontalOffset
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalOffset
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!   returns a rectangle (in viewport coordinates) that includes the   cursor of the text edit.  */
end_comment
begin_function
DECL|function|cursorRect
name|QRect
name|QTextEdit
operator|::
name|cursorRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|d
operator|->
name|control
operator|->
name|cursorRect
argument_list|()
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|r
operator|.
name|translate
argument_list|(
operator|-
name|d
operator|->
name|horizontalOffset
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalOffset
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the reference of the anchor at position \a pos, or an     empty string if no anchor exists at that point. */
end_comment
begin_function
DECL|function|anchorAt
name|QString
name|QTextEdit
operator|::
name|anchorAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|anchorAt
argument_list|(
name|d
operator|->
name|mapToContents
argument_list|(
name|pos
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    \property QTextEdit::overwriteMode    \since 4.1    \brief whether text entered by the user will overwrite existing text     As with many text editors, the text editor widget can be configured    to insert or overwrite existing text with new text entered by the user.     If this property is true, existing text is overwritten, character-for-character    by new text; otherwise, text is inserted at the cursor position, displacing    existing text.     By default, this property is false (new text does not overwrite existing text). */
end_comment
begin_function
DECL|function|overwriteMode
name|bool
name|QTextEdit
operator|::
name|overwriteMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|overwriteMode
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setOverwriteMode
name|void
name|QTextEdit
operator|::
name|setOverwriteMode
parameter_list|(
name|bool
name|overwrite
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setOverwriteMode
argument_list|(
name|overwrite
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::tabStopWidth     \brief the tab stop width in pixels     \since 4.1      By default, this property contains a value of 80 pixels. */
end_comment
begin_function
DECL|function|tabStopWidth
name|int
name|QTextEdit
operator|::
name|tabStopWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|defaultTextOption
argument_list|()
operator|.
name|tabStop
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setTabStopWidth
name|void
name|QTextEdit
operator|::
name|setTabStopWidth
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|QTextOption
name|opt
init|=
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|defaultTextOption
argument_list|()
decl_stmt|;
if|if
condition|(
name|opt
operator|.
name|tabStop
argument_list|()
operator|==
name|width
operator|||
name|width
operator|<
literal|0
condition|)
return|return;
name|opt
operator|.
name|setTabStop
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|setDefaultTextOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \property QTextEdit::cursorWidth      This property specifies the width of the cursor in pixels. The default value is 1. */
end_comment
begin_function
DECL|function|cursorWidth
name|int
name|QTextEdit
operator|::
name|cursorWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|cursorWidth
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setCursorWidth
name|void
name|QTextEdit
operator|::
name|setCursorWidth
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorWidth
argument_list|(
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::acceptRichText     \brief whether the text edit accepts rich text insertions by the user     \since 4.1      When this propery is set to false text edit will accept only     plain text input from the user. For example through clipboard or drag and drop.      This property's default is true. */
end_comment
begin_function
DECL|function|acceptRichText
name|bool
name|QTextEdit
operator|::
name|acceptRichText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|acceptRichText
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setAcceptRichText
name|void
name|QTextEdit
operator|::
name|setAcceptRichText
parameter_list|(
name|bool
name|accept
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setAcceptRichText
argument_list|(
name|accept
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTextEdit::ExtraSelection     \since 4.2     \inmodule QtWidgets      \brief The QTextEdit::ExtraSelection structure provides a way of specifying a            character format for a given selection in a document */
end_comment
begin_comment
comment|/*!     \variable QTextEdit::ExtraSelection::cursor     A cursor that contains a selection in a QTextDocument */
end_comment
begin_comment
comment|/*!     \variable QTextEdit::ExtraSelection::format     A format that is used to specify a foreground or background brush/color     for the selection. */
end_comment
begin_comment
comment|/*!     \since 4.2     This function allows temporarily marking certain regions in the document     with a given color, specified as \a selections. This can be useful for     example in a programming editor to mark a whole line of text with a given     background color to indicate the existence of a breakpoint.      \sa QTextEdit::ExtraSelection, extraSelections() */
end_comment
begin_function
DECL|function|setExtraSelections
name|void
name|QTextEdit
operator|::
name|setExtraSelections
parameter_list|(
specifier|const
name|QList
argument_list|<
name|ExtraSelection
argument_list|>
modifier|&
name|selections
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setExtraSelections
argument_list|(
name|selections
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns previously set extra selections.      \sa setExtraSelections() */
end_comment
begin_function
DECL|function|extraSelections
name|QList
argument_list|<
name|QTextEdit
operator|::
name|ExtraSelection
argument_list|>
name|QTextEdit
operator|::
name|extraSelections
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|extraSelections
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This function returns a new MIME data object to represent the contents     of the text edit's current selection. It is called when the selection needs     to be encapsulated into a new QMimeData object; for example, when a drag     and drop operation is started, or when data is copyied to the clipboard.      If you reimplement this function, note that the ownership of the returned     QMimeData object is passed to the caller. The selection can be retrieved     by using the textCursor() function. */
end_comment
begin_function
DECL|function|createMimeDataFromSelection
name|QMimeData
modifier|*
name|QTextEdit
operator|::
name|createMimeDataFromSelection
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|QWidgetTextControl
operator|::
name|createMimeDataFromSelection
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This function returns true if the contents of the MIME data object, specified     by \a source, can be decoded and inserted into the document. It is called     for example when during a drag operation the mouse enters this widget and it     is necessary to determine whether it is possible to accept the drag and drop     operation.      Reimplement this function to enable drag and drop support for additional MIME types.  */
end_comment
begin_function
DECL|function|canInsertFromMimeData
name|bool
name|QTextEdit
operator|::
name|canInsertFromMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|source
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|QWidgetTextControl
operator|::
name|canInsertFromMimeData
argument_list|(
name|source
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This function inserts the contents of the MIME data object, specified     by \a source, into the text edit at the current cursor position. It is     called whenever text is inserted as the result of a clipboard paste     operation, or when the text edit accepts data from a drag and drop     operation.      Reimplement this function to enable drag and drop support for additional MIME types.  */
end_comment
begin_function
DECL|function|insertFromMimeData
name|void
name|QTextEdit
operator|::
name|insertFromMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|source
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|QWidgetTextControl
operator|::
name|insertFromMimeData
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::readOnly     \brief whether the text edit is read-only      In a read-only text edit the user can only navigate through the     text and select text; modifying the text is not possible.      This property's default is false. */
end_comment
begin_function
DECL|function|isReadOnly
name|bool
name|QTextEdit
operator|::
name|isReadOnly
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
operator|!
operator|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setReadOnly
name|void
name|QTextEdit
operator|::
name|setReadOnly
parameter_list|(
name|bool
name|ro
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|TextInteractionFlags
name|flags
init|=
name|Qt
operator|::
name|NoTextInteraction
decl_stmt|;
if|if
condition|(
name|ro
condition|)
block|{
name|flags
operator|=
name|Qt
operator|::
name|TextSelectableByMouse
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTBROWSER
if|if
condition|(
name|qobject_cast
argument_list|<
name|QTextBrowser
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
name|flags
operator||=
name|Qt
operator|::
name|TextBrowserInteraction
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|flags
operator|=
name|Qt
operator|::
name|TextEditorInteraction
expr_stmt|;
block|}
name|d
operator|->
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
name|shouldEnableInputMethod
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::textInteractionFlags     \since 4.2      Specifies how the widget should interact with user input.      The default value depends on whether the QTextEdit is read-only     or editable, and whether it is a QTextBrowser or not. */
end_comment
begin_function
DECL|function|setTextInteractionFlags
name|void
name|QTextEdit
operator|::
name|setTextInteractionFlags
parameter_list|(
name|Qt
operator|::
name|TextInteractionFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textInteractionFlags
name|Qt
operator|::
name|TextInteractionFlags
name|QTextEdit
operator|::
name|textInteractionFlags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Merges the properties specified in \a modifier into the current character     format by calling QTextCursor::mergeCharFormat on the editor's cursor.     If the editor has a selection then the properties of \a modifier are     directly applied to the selection.      \sa QTextCursor::mergeCharFormat()  */
end_comment
begin_function
DECL|function|mergeCurrentCharFormat
name|void
name|QTextEdit
operator|::
name|mergeCurrentCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|modifier
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|mergeCurrentCharFormat
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the char format that is be used when inserting new text to \a     format by calling QTextCursor::setCharFormat() on the editor's     cursor.  If the editor has a selection then the char format is     directly applied to the selection.  */
end_comment
begin_function
DECL|function|setCurrentCharFormat
name|void
name|QTextEdit
operator|::
name|setCurrentCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCurrentCharFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the char format that is used when inserting new text.  */
end_comment
begin_function
DECL|function|currentCharFormat
name|QTextCharFormat
name|QTextEdit
operator|::
name|currentCharFormat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|currentCharFormat
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::autoFormatting     \brief the enabled set of auto formatting features      The value can be any combination of the values in the     AutoFormattingFlag enum.  The default is AutoNone. Choose     AutoAll to enable all automatic formatting.      Currently, the only automatic formatting feature provided is     AutoBulletList; future versions of Qt may offer more. */
end_comment
begin_function
DECL|function|autoFormatting
name|QTextEdit
operator|::
name|AutoFormatting
name|QTextEdit
operator|::
name|autoFormatting
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoFormatting
return|;
block|}
end_function
begin_function
DECL|function|setAutoFormatting
name|void
name|QTextEdit
operator|::
name|setAutoFormatting
parameter_list|(
name|AutoFormatting
name|features
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoFormatting
operator|=
name|features
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Convenience slot that inserts \a text at the current     cursor position.      It is equivalent to      \snippet code/src_gui_widgets_qtextedit.cpp 1  */
end_comment
begin_function
DECL|function|insertPlainText
name|void
name|QTextEdit
operator|::
name|insertPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|insertPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Convenience slot that inserts \a text which is assumed to be of     html formatting at the current cursor position.      It is equivalent to:      \snippet code/src_gui_widgets_qtextedit.cpp 2      \note When using this function with a style sheet, the style sheet will     only apply to the current block in the document. In order to apply a style     sheet throughout a document, use QTextDocument::setDefaultStyleSheet()     instead.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|insertHtml
name|void
name|QTextEdit
operator|::
name|insertHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|insertHtml
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     Scrolls the text edit so that the anchor with the given \a name is     visible; does nothing if the \a name is empty, or is already     visible, or isn't found. */
end_comment
begin_function
DECL|function|scrollToAnchor
name|void
name|QTextEdit
operator|::
name|scrollToAnchor
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isVisible
argument_list|()
condition|)
block|{
name|d
operator|->
name|anchorToScrollToWhenVisible
operator|=
name|name
expr_stmt|;
return|return;
block|}
name|QPointF
name|p
init|=
name|d
operator|->
name|control
operator|->
name|anchorPosition
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|int
name|newPosition
init|=
name|qRound
argument_list|(
name|p
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|vbar
operator|->
name|maximum
argument_list|()
operator|<
name|newPosition
condition|)
name|d
operator|->
name|_q_adjustScrollbars
argument_list|()
expr_stmt|;
name|d
operator|->
name|vbar
operator|->
name|setValue
argument_list|(
name|newPosition
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextEdit::zoomIn(int range)      Zooms in on the text by making the base font size \a range     points larger and recalculating all font sizes to be the new size.     This does not change the size of any images.      \sa zoomOut() */
end_comment
begin_function
DECL|function|zoomIn
name|void
name|QTextEdit
operator|::
name|zoomIn
parameter_list|(
name|int
name|range
parameter_list|)
block|{
name|QFont
name|f
init|=
name|font
argument_list|()
decl_stmt|;
specifier|const
name|int
name|newSize
init|=
name|f
operator|.
name|pointSize
argument_list|()
operator|+
name|range
decl_stmt|;
if|if
condition|(
name|newSize
operator|<=
literal|0
condition|)
return|return;
name|f
operator|.
name|setPointSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|setFont
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextEdit::zoomOut(int range)      \overload      Zooms out on the text by making the base font size \a range points     smaller and recalculating all font sizes to be the new size. This     does not change the size of any images.      \sa zoomIn() */
end_comment
begin_function
DECL|function|zoomOut
name|void
name|QTextEdit
operator|::
name|zoomOut
parameter_list|(
name|int
name|range
parameter_list|)
block|{
name|zoomIn
argument_list|(
operator|-
name|range
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Moves the cursor by performing the given \a operation.      If \a mode is QTextCursor::KeepAnchor, the cursor selects the text it moves over.     This is the same effect that the user achieves when they hold down the Shift key     and move the cursor with the cursor keys.      \sa QTextCursor::movePosition() */
end_comment
begin_function
DECL|function|moveCursor
name|void
name|QTextEdit
operator|::
name|moveCursor
parameter_list|(
name|QTextCursor
operator|::
name|MoveOperation
name|operation
parameter_list|,
name|QTextCursor
operator|::
name|MoveMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|operation
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns whether text can be pasted from the clipboard into the textedit. */
end_comment
begin_function
DECL|function|canPaste
name|bool
name|QTextEdit
operator|::
name|canPaste
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|canPaste
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3     Convenience function to print the text edit's document to the given \a printer. This     is equivalent to calling the print method on the document directly except that this     function also supports QPrinter::Selection as print range.      \sa QTextDocument::print() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PRINTER
end_ifndef
begin_function
DECL|function|print
name|void
name|QTextEdit
operator|::
name|print
parameter_list|(
name|QPagedPaintDevice
modifier|*
name|printer
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|print
argument_list|(
name|printer
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \property QTextEdit::tabChangesFocus   \brief whether \uicontrol Tab changes focus or is accepted as input    In some occasions text edits should not allow the user to input   tabulators or change indentation using the \uicontrol Tab key, as this breaks   the focus chain. The default is false.  */
end_comment
begin_function
DECL|function|tabChangesFocus
name|bool
name|QTextEdit
operator|::
name|tabChangesFocus
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabChangesFocus
return|;
block|}
end_function
begin_function
DECL|function|setTabChangesFocus
name|void
name|QTextEdit
operator|::
name|setTabChangesFocus
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|tabChangesFocus
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::documentTitle     \brief the title of the document parsed from the text.      By default, for a newly-created, empty document, this property contains     an empty string. */
end_comment
begin_comment
comment|/*!     \property QTextEdit::lineWrapMode     \brief the line wrap mode      The default mode is WidgetWidth which causes words to be     wrapped at the right edge of the text edit. Wrapping occurs at     whitespace, keeping whole words intact. If you want wrapping to     occur within words use setWordWrapMode(). If you set a wrap mode of     FixedPixelWidth or FixedColumnWidth you should also call     setLineWrapColumnOrWidth() with the width you want.      \sa lineWrapColumnOrWidth */
end_comment
begin_function
DECL|function|lineWrapMode
name|QTextEdit
operator|::
name|LineWrapMode
name|QTextEdit
operator|::
name|lineWrapMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|lineWrap
return|;
block|}
end_function
begin_function
DECL|function|setLineWrapMode
name|void
name|QTextEdit
operator|::
name|setLineWrapMode
parameter_list|(
name|LineWrapMode
name|wrap
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lineWrap
operator|==
name|wrap
condition|)
return|return;
name|d
operator|->
name|lineWrap
operator|=
name|wrap
expr_stmt|;
name|d
operator|->
name|updateDefaultTextOption
argument_list|()
expr_stmt|;
name|d
operator|->
name|relayoutDocument
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::lineWrapColumnOrWidth     \brief the position (in pixels or columns depending on the wrap mode) where text will be wrapped      If the wrap mode is FixedPixelWidth, the value is the number of     pixels from the left edge of the text edit at which text should be     wrapped. If the wrap mode is FixedColumnWidth, the value is the     column number (in character columns) from the left edge of the     text edit at which text should be wrapped.      By default, this property contains a value of 0.      \sa lineWrapMode */
end_comment
begin_function
DECL|function|lineWrapColumnOrWidth
name|int
name|QTextEdit
operator|::
name|lineWrapColumnOrWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|lineWrapColumnOrWidth
return|;
block|}
end_function
begin_function
DECL|function|setLineWrapColumnOrWidth
name|void
name|QTextEdit
operator|::
name|setLineWrapColumnOrWidth
parameter_list|(
name|int
name|w
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|lineWrapColumnOrWidth
operator|=
name|w
expr_stmt|;
name|d
operator|->
name|relayoutDocument
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextEdit::wordWrapMode     \brief the mode QTextEdit will use when wrapping text by words      By default, this property is set to QTextOption::WrapAtWordBoundaryOrAnywhere.      \sa QTextOption::WrapMode */
end_comment
begin_function
DECL|function|wordWrapMode
name|QTextOption
operator|::
name|WrapMode
name|QTextEdit
operator|::
name|wordWrapMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|wordWrap
return|;
block|}
end_function
begin_function
DECL|function|setWordWrapMode
name|void
name|QTextEdit
operator|::
name|setWordWrapMode
parameter_list|(
name|QTextOption
operator|::
name|WrapMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|d
operator|->
name|wordWrap
condition|)
return|return;
name|d
operator|->
name|wordWrap
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|updateDefaultTextOption
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Finds the next occurrence of the string, \a exp, using the given     \a options. Returns true if \a exp was found and changes the     cursor to select the match; otherwise returns false. */
end_comment
begin_function
DECL|function|find
name|bool
name|QTextEdit
operator|::
name|find
parameter_list|(
specifier|const
name|QString
modifier|&
name|exp
parameter_list|,
name|QTextDocument
operator|::
name|FindFlags
name|options
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|find
argument_list|(
name|exp
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextEdit::copyAvailable(bool yes)      This signal is emitted when text is selected or de-selected in the     text edit.      When text is selected this signal will be emitted with \a yes set     to true. If no text has been selected or if the selected text is     de-selected this signal is emitted with \a yes set to false.      If \a yes is true then copy() can be used to copy the selection to     the clipboard. If \a yes is false then copy() does nothing.      \sa selectionChanged() */
end_comment
begin_comment
comment|/*!     \fn void QTextEdit::currentCharFormatChanged(const QTextCharFormat&f)      This signal is emitted if the current character format has changed, for     example caused by a change of the cursor position.      The new format is \a f.      \sa setCurrentCharFormat() */
end_comment
begin_comment
comment|/*!     \fn void QTextEdit::selectionChanged()      This signal is emitted whenever the selection changes.      \sa copyAvailable() */
end_comment
begin_comment
comment|/*!     \fn void QTextEdit::cursorPositionChanged()      This signal is emitted whenever the position of the     cursor changed. */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the text edit's \a text. The text can be plain text or HTML     and the text edit will try to guess the right format.      Use setHtml() or setPlainText() directly to avoid text edit's guessing.      \sa toPlainText(), toHtml() */
end_comment
begin_function
DECL|function|setText
name|void
name|QTextEdit
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|TextFormat
name|format
init|=
name|d
operator|->
name|textFormat
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|textFormat
operator|==
name|Qt
operator|::
name|AutoText
condition|)
name|format
operator|=
name|Qt
operator|::
name|mightBeRichText
argument_list|(
name|text
argument_list|)
condition|?
name|Qt
operator|::
name|RichText
else|:
name|Qt
operator|::
name|PlainText
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|RichText
condition|)
name|setHtml
argument_list|(
name|text
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Appends a new paragraph with \a text to the end of the text edit.      \note The new paragraph appended will have the same character format and     block format as the current paragraph, determined by the position of the cursor.      \sa currentCharFormat(), QTextCursor::blockFormat() */
end_comment
begin_function
DECL|function|append
name|void
name|QTextEdit
operator|::
name|append
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|atBottom
init|=
name|isReadOnly
argument_list|()
condition|?
name|d
operator|->
name|verticalOffset
argument_list|()
operator|>=
name|d
operator|->
name|vbar
operator|->
name|maximum
argument_list|()
else|:
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|atEnd
argument_list|()
decl_stmt|;
name|d
operator|->
name|control
operator|->
name|append
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|atBottom
condition|)
name|d
operator|->
name|vbar
operator|->
name|setValue
argument_list|(
name|d
operator|->
name|vbar
operator|->
name|maximum
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ensures that the cursor is visible by scrolling the text edit if     necessary. */
end_comment
begin_function
DECL|function|ensureCursorVisible
name|void
name|QTextEdit
operator|::
name|ensureCursorVisible
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|ensureCursorVisible
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextEdit::textChanged()      This signal is emitted whenever the document's content changes; for     example, when text is inserted or deleted, or when formatting is applied. */
end_comment
begin_comment
comment|/*!     \fn void QTextEdit::undoAvailable(bool available)      This signal is emitted whenever undo operations become available     (\a available is true) or unavailable (\a available is false). */
end_comment
begin_comment
comment|/*!     \fn void QTextEdit::redoAvailable(bool available)      This signal is emitted whenever redo operations become available     (\a available is true) or unavailable (\a available is false). */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTEDIT
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qtextedit.cpp"
end_include
end_unit
