begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstractscrollarea.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SCROLLAREA
end_ifndef
begin_include
include|#
directive|include
file|"qscrollbar.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qboxlayout.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qmargins.h"
end_include
begin_include
include|#
directive|include
file|"qheaderview.h"
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|"qabstractscrollarea_p.h"
end_include
begin_include
include|#
directive|include
file|"qscrollbar_p.h"
end_include
begin_include
include|#
directive|include
file|<qwidget.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_cocoa_helpers_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qlibrary.h>
end_include
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QAbstractScrollArea     \brief The QAbstractScrollArea widget provides a scrolling area with     on-demand scroll bars.      \ingroup abstractwidgets     \inmodule QtWidgets      QAbstractScrollArea is a low-level abstraction of a scrolling     area. The area provides a central widget called the viewport, in     which the contents of the area is to be scrolled (i.e, the     visible parts of the contents are rendered in the viewport).      Next to the viewport is a vertical scroll bar, and below is a     horizontal scroll bar. When all of the area contents fits in the     viewport, each scroll bar can be either visible or hidden     depending on the scroll bar's Qt::ScrollBarPolicy. When a scroll     bar is hidden, the viewport expands in order to cover all     available space. When a scroll bar becomes visible again, the     viewport shrinks in order to make room for the scroll bar.      It is possible to reserve a margin area around the viewport, see     setViewportMargins(). The feature is mostly used to place a     QHeaderView widget above or beside the scrolling area. Subclasses     of QAbstractScrollArea should implement margins.      When inheriting QAbstractScrollArea, you need to do the     following:      \list         \li Control the scroll bars by setting their            range, value, page step, and tracking their            movements.         \li Draw the contents of the area in the viewport according            to the values of the scroll bars.         \li Handle events received by the viewport in            viewportEvent() - notably resize events.         \li Use \c{viewport->update()} to update the contents of the           viewport instead of \l{QWidget::update()}{update()}           as all painting operations take place on the viewport.     \endlist      With a scroll bar policy of Qt::ScrollBarAsNeeded (the default),     QAbstractScrollArea shows scroll bars when they provide a non-zero     scrolling range, and hides them otherwise.      The scroll bars and viewport should be updated whenever the viewport     receives a resize event or the size of the contents changes.     The viewport also needs to be updated when the scroll bars     values change. The initial values of the scroll bars are often     set when the area receives new contents.      We give a simple example, in which we have implemented a scroll area     that can scroll any QWidget. We make the widget a child of the     viewport; this way, we do not have to calculate which part of     the widget to draw but can simply move the widget with     QWidget::move(). When the area contents or the viewport size     changes, we do the following:      \snippet myscrollarea.cpp 1      When the scroll bars change value, we need to update the widget     position, i.e., find the part of the widget that is to be drawn in     the viewport:      \snippet myscrollarea.cpp 0      In order to track scroll bar movements, reimplement the virtual     function scrollContentsBy(). In order to fine-tune scrolling     behavior, connect to a scroll bar's     QAbstractSlider::actionTriggered() signal and adjust the \l     QAbstractSlider::sliderPosition as you wish.      For convenience, QAbstractScrollArea makes all viewport events     available in the virtual viewportEvent() handler. QWidget's     specialized handlers are remapped to viewport events in the cases     where this makes sense. The remapped specialized handlers are:     paintEvent(), mousePressEvent(), mouseReleaseEvent(),     mouseDoubleClickEvent(), mouseMoveEvent(), wheelEvent(),     dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(), dropEvent(),     contextMenuEvent(),  and resizeEvent().      QScrollArea, which inherits QAbstractScrollArea, provides smooth     scrolling for any QWidget (i.e., the widget is scrolled pixel by     pixel). You only need to subclass QAbstractScrollArea if you need     more specialized behavior. This is, for instance, true if the     entire contents of the area is not suitable for being drawn on a     QWidget or if you do not want smooth scrolling.      \sa QScrollArea */
end_comment
begin_constructor
DECL|function|QAbstractScrollAreaPrivate
name|QAbstractScrollAreaPrivate
operator|::
name|QAbstractScrollAreaPrivate
parameter_list|()
member_init_list|:
name|hbar
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vbar
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vbarpolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
member_init_list|,
name|hbarpolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
member_init_list|,
name|viewport
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cornerWidget
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|left
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|top
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|right
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bottom
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|xoffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|yoffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|viewportFilter
argument_list|(
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|Q_WS_WIN
member_init_list|,
name|singleFingerPanEnabled
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
block|{ }
end_constructor
begin_constructor
DECL|function|QAbstractScrollAreaScrollBarContainer
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|QAbstractScrollAreaScrollBarContainer
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|scrollBar
argument_list|(
operator|new
name|QScrollBar
argument_list|(
name|orientation
argument_list|,
name|this
argument_list|)
argument_list|)
member_init_list|,
name|layout
argument_list|(
operator|new
name|QBoxLayout
argument_list|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|QBoxLayout
operator|::
name|LeftToRight
else|:
name|QBoxLayout
operator|::
name|TopToBottom
argument_list|)
argument_list|)
member_init_list|,
name|orientation
argument_list|(
name|orientation
argument_list|)
block|{
name|setLayout
argument_list|(
name|layout
argument_list|)
expr_stmt|;
name|layout
operator|->
name|setMargin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|layout
operator|->
name|setSpacing
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|layout
operator|->
name|addWidget
argument_list|(
name|scrollBar
argument_list|)
expr_stmt|;
name|layout
operator|->
name|setSizeConstraint
argument_list|(
name|QLayout
operator|::
name|SetMaximumSize
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal     Adds a widget to the scroll bar container. */
end_comment
begin_function
DECL|function|addWidget
name|void
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|addWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|LogicalPosition
name|position
parameter_list|)
block|{
name|QSizePolicy
name|policy
init|=
name|widget
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|policy
operator|.
name|setHorizontalPolicy
argument_list|(
name|QSizePolicy
operator|::
name|Ignored
argument_list|)
expr_stmt|;
else|else
name|policy
operator|.
name|setVerticalPolicy
argument_list|(
name|QSizePolicy
operator|::
name|Ignored
argument_list|)
expr_stmt|;
name|widget
operator|->
name|setSizePolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|widget
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
specifier|const
name|int
name|insertIndex
init|=
operator|(
name|position
operator|&
name|LogicalLeft
operator|)
condition|?
literal|0
else|:
name|scrollBarLayoutIndex
argument_list|()
operator|+
literal|1
decl_stmt|;
name|layout
operator|->
name|insertWidget
argument_list|(
name|insertIndex
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Retuns a list of scroll bar widgets for the given position. The scroll bar     itself is not returned. */
end_comment
begin_function
DECL|function|widgets
name|QWidgetList
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|widgets
parameter_list|(
name|LogicalPosition
name|position
parameter_list|)
block|{
name|QWidgetList
name|list
decl_stmt|;
specifier|const
name|int
name|scrollBarIndex
init|=
name|scrollBarLayoutIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|position
operator|==
name|LogicalLeft
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scrollBarIndex
condition|;
operator|++
name|i
control|)
name|list
operator|.
name|append
argument_list|(
name|layout
operator|->
name|itemAt
argument_list|(
name|i
argument_list|)
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|LogicalRight
condition|)
block|{
specifier|const
name|int
name|layoutItemCount
init|=
name|layout
operator|->
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|scrollBarIndex
operator|+
literal|1
init|;
name|i
operator|<
name|layoutItemCount
condition|;
operator|++
name|i
control|)
name|list
operator|.
name|append
argument_list|(
name|layout
operator|->
name|itemAt
argument_list|(
name|i
argument_list|)
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the layout index for the scroll bar. This needs to be     recalculated by a linear search for each use, since items in     the layout can be removed at any time (i.e. when a widget is     deleted or re-parented). */
end_comment
begin_function
DECL|function|scrollBarLayoutIndex
name|int
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|scrollBarLayoutIndex
parameter_list|()
specifier|const
block|{
specifier|const
name|int
name|layoutItemCount
init|=
name|layout
operator|->
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|layoutItemCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qobject_cast
argument_list|<
name|QScrollBar
operator|*
argument_list|>
argument_list|(
name|layout
operator|->
name|itemAt
argument_list|(
name|i
argument_list|)
operator|->
name|widget
argument_list|()
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|replaceScrollBar
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|replaceScrollBar
parameter_list|(
name|QScrollBar
modifier|*
name|scrollBar
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QAbstractScrollAreaScrollBarContainer
modifier|*
name|container
init|=
name|scrollBarContainers
index|[
name|orientation
index|]
decl_stmt|;
name|bool
name|horizontal
init|=
operator|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|)
decl_stmt|;
name|QScrollBar
modifier|*
name|oldBar
init|=
name|horizontal
condition|?
name|hbar
else|:
name|vbar
decl_stmt|;
if|if
condition|(
name|horizontal
condition|)
name|hbar
operator|=
name|scrollBar
expr_stmt|;
else|else
name|vbar
operator|=
name|scrollBar
expr_stmt|;
name|scrollBar
operator|->
name|setParent
argument_list|(
name|container
argument_list|)
expr_stmt|;
name|container
operator|->
name|scrollBar
operator|=
name|scrollBar
expr_stmt|;
name|container
operator|->
name|layout
operator|->
name|removeWidget
argument_list|(
name|oldBar
argument_list|)
expr_stmt|;
name|container
operator|->
name|layout
operator|->
name|insertWidget
argument_list|(
literal|0
argument_list|,
name|scrollBar
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setVisible
argument_list|(
name|oldBar
operator|->
name|isVisibleTo
argument_list|(
name|container
argument_list|)
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setInvertedAppearance
argument_list|(
name|oldBar
operator|->
name|invertedAppearance
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setInvertedControls
argument_list|(
name|oldBar
operator|->
name|invertedControls
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setRange
argument_list|(
name|oldBar
operator|->
name|minimum
argument_list|()
argument_list|,
name|oldBar
operator|->
name|maximum
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setOrientation
argument_list|(
name|oldBar
operator|->
name|orientation
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setPageStep
argument_list|(
name|oldBar
operator|->
name|pageStep
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setSingleStep
argument_list|(
name|oldBar
operator|->
name|singleStep
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setSliderDown
argument_list|(
name|oldBar
operator|->
name|isSliderDown
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setSliderPosition
argument_list|(
name|oldBar
operator|->
name|sliderPosition
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setTracking
argument_list|(
name|oldBar
operator|->
name|hasTracking
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|setValue
argument_list|(
name|oldBar
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|scrollBar
operator|->
name|installEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|oldBar
operator|->
name|removeEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|delete
name|oldBar
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|scrollBar
argument_list|,
name|SIGNAL
argument_list|(
name|valueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|horizontal
condition|?
name|SLOT
argument_list|(
name|_q_hslide
argument_list|(
name|int
argument_list|)
argument_list|)
else|:
name|SLOT
argument_list|(
name|_q_vslide
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|scrollBar
argument_list|,
name|SIGNAL
argument_list|(
name|rangeChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_showOrHideScrollBars
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|viewport
operator|=
operator|new
name|QWidget
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_scrollarea_viewport"
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|=
operator|new
name|QAbstractScrollAreaScrollBarContainer
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_scrollarea_hcontainer"
argument_list|)
argument_list|)
expr_stmt|;
name|hbar
operator|=
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|scrollBar
expr_stmt|;
name|hbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|setVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|installEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|hbar
argument_list|,
name|SIGNAL
argument_list|(
name|valueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_hslide
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|hbar
argument_list|,
name|SIGNAL
argument_list|(
name|rangeChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_showOrHideScrollBars
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|=
operator|new
name|QAbstractScrollAreaScrollBarContainer
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_scrollarea_vcontainer"
argument_list|)
argument_list|)
expr_stmt|;
name|vbar
operator|=
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|scrollBar
expr_stmt|;
name|vbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|setVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|installEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|vbar
argument_list|,
name|SIGNAL
argument_list|(
name|valueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_vslide
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|vbar
argument_list|,
name|SIGNAL
argument_list|(
name|rangeChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_showOrHideScrollBars
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|viewportFilter
operator|.
name|reset
argument_list|(
operator|new
name|QAbstractScrollAreaFilter
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|installEventFilter
argument_list|(
name|viewportFilter
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setFocusProxy
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|WheelFocus
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFrameStyle
argument_list|(
name|QFrame
operator|::
name|StyledPanel
operator||
name|QFrame
operator|::
name|Sunken
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Expanding
argument_list|,
name|QSizePolicy
operator|::
name|Expanding
argument_list|)
expr_stmt|;
name|layoutChildren
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|viewport
operator|->
name|grabGesture
argument_list|(
name|Qt
operator|::
name|PanGesture
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_WIN
end_ifdef
begin_function
DECL|function|setSingleFingerPanEnabled
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|setSingleFingerPanEnabled
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|singleFingerPanEnabled
operator|=
name|on
expr_stmt|;
name|QWidgetPrivate
modifier|*
name|dd
init|=
cast|static_cast
argument_list|<
name|QWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|viewport
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dd
condition|)
name|dd
operator|->
name|winSetupGestures
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_WS_WIN
end_comment
begin_function
DECL|function|layoutChildren
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|layoutChildren
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|bool
name|needh
init|=
operator|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
operator|||
operator|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
operator|&&
name|hbar
operator|->
name|minimum
argument_list|()
operator|<
name|hbar
operator|->
name|maximum
argument_list|()
operator|&&
operator|!
name|hbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|)
decl_stmt|;
name|bool
name|needv
init|=
operator|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
operator|||
operator|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
operator|&&
name|vbar
operator|->
name|minimum
argument_list|()
operator|<
name|vbar
operator|->
name|maximum
argument_list|()
operator|&&
operator|!
name|vbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|)
decl_stmt|;
name|QStyleOption
name|opt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|opt
operator|.
name|init
argument_list|(
name|q
argument_list|)
expr_stmt|;
specifier|const
name|int
name|scrollOverlap
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ScrollView_ScrollBarOverlap
argument_list|,
operator|&
name|opt
argument_list|,
name|q
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|QWidget
modifier|*
specifier|const
name|window
init|=
name|q
operator|->
name|window
argument_list|()
decl_stmt|;
comment|// Use small scroll bars for tool windows, to match the native size grip.
name|bool
name|hbarIsSmall
init|=
name|hbar
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|)
decl_stmt|;
name|bool
name|vbarIsSmall
init|=
name|vbar
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|)
decl_stmt|;
specifier|const
name|Qt
operator|::
name|WindowType
name|windowType
init|=
name|window
operator|->
name|windowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowType
operator|==
name|Qt
operator|::
name|Tool
condition|)
block|{
if|if
condition|(
operator|!
name|hbarIsSmall
condition|)
block|{
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacNormalSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vbarIsSmall
condition|)
block|{
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacNormalSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hbarIsSmall
condition|)
block|{
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacNormalSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vbarIsSmall
condition|)
block|{
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacMiniSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacNormalSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacSmallSize
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
specifier|const
name|int
name|hsbExt
init|=
name|hbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|vsbExt
init|=
name|vbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|extPoint
argument_list|(
name|vsbExt
argument_list|,
name|hsbExt
argument_list|)
decl_stmt|;
specifier|const
name|QSize
name|extSize
argument_list|(
name|vsbExt
argument_list|,
name|hsbExt
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|widgetRect
init|=
name|q
operator|->
name|rect
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|hasCornerWidget
init|=
operator|(
name|cornerWidget
operator|!=
literal|0
operator|)
decl_stmt|;
comment|// If the scroll bars are at the very right and bottom of the window we
comment|// move their positions to be aligned with the size grip.
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// Check if a native sizegrip is present.
name|bool
name|hasMacReverseSizeGrip
init|=
literal|false
decl_stmt|;
name|bool
name|hasMacSizeGrip
init|=
literal|false
decl_stmt|;
name|bool
name|nativeGripPresent
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|nativeGripPresent
operator|=
name|qt_mac_checkForNativeSizeGrip
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeGripPresent
condition|)
block|{
comment|// Look for a native size grip at the visual window bottom right and at the
comment|// absolute window bottom right. In reverse mode, the native size grip does not
comment|// swich side, so we need to check if it is on the "wrong side".
specifier|const
name|QPoint
name|scrollAreaBottomRight
init|=
name|q
operator|->
name|mapTo
argument_list|(
name|window
argument_list|,
name|widgetRect
operator|.
name|bottomRight
argument_list|()
operator|-
name|QPoint
argument_list|(
name|frameWidth
argument_list|,
name|frameWidth
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|windowBottomRight
init|=
name|window
operator|->
name|rect
argument_list|()
operator|.
name|bottomRight
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|visualWindowBottomRight
init|=
name|QStyle
operator|::
name|visualPos
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|windowBottomRight
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|offset
init|=
name|windowBottomRight
operator|-
name|scrollAreaBottomRight
decl_stmt|;
specifier|const
name|QPoint
name|visualOffset
init|=
name|visualWindowBottomRight
operator|-
name|scrollAreaBottomRight
decl_stmt|;
name|hasMacSizeGrip
operator|=
operator|(
name|visualOffset
operator|.
name|manhattanLength
argument_list|()
operator|<
name|vsbExt
operator|)
expr_stmt|;
name|hasMacReverseSizeGrip
operator|=
operator|(
name|hasMacSizeGrip
operator|==
literal|false
operator|&&
operator|(
name|offset
operator|.
name|manhattanLength
argument_list|()
operator|<
name|hsbExt
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QPoint
name|cornerOffset
argument_list|(
operator|(
name|needv
operator|&&
name|scrollOverlap
operator|==
literal|0
operator|)
condition|?
name|vsbExt
else|:
literal|0
argument_list|,
operator|(
name|needh
operator|&&
name|scrollOverlap
operator|==
literal|0
operator|)
condition|?
name|hsbExt
else|:
literal|0
argument_list|)
decl_stmt|;
name|QRect
name|controlsRect
decl_stmt|;
name|QRect
name|viewportRect
decl_stmt|;
comment|// In FrameOnlyAroundContents mode the frame is drawn between the controls and
comment|// the viewport, else the frame rect is equal to the widget rect.
if|if
condition|(
operator|(
name|frameStyle
operator|!=
name|QFrame
operator|::
name|NoFrame
operator|)
operator|&&
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollView_FrameOnlyAroundContents
argument_list|,
operator|&
name|opt
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|controlsRect
operator|=
name|widgetRect
expr_stmt|;
specifier|const
name|int
name|extra
init|=
name|scrollOverlap
operator|+
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ScrollView_ScrollBarSpacing
argument_list|,
operator|&
name|opt
argument_list|,
name|q
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|cornerExtra
argument_list|(
name|needv
condition|?
name|extra
else|:
literal|0
argument_list|,
name|needh
condition|?
name|extra
else|:
literal|0
argument_list|)
decl_stmt|;
name|QRect
name|frameRect
init|=
name|widgetRect
decl_stmt|;
name|frameRect
operator|.
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
name|cornerOffset
operator|.
name|x
argument_list|()
operator|-
name|cornerExtra
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|cornerOffset
operator|.
name|y
argument_list|()
operator|-
name|cornerExtra
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFrameRect
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|frameRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// The frame rect needs to be in logical coords, however we need to flip
comment|// the contentsRect back before passing it on to the viewportRect
comment|// since the viewportRect has its logical coords calculated later.
name|viewportRect
operator|=
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|q
operator|->
name|contentsRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|setFrameRect
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|widgetRect
argument_list|)
argument_list|)
expr_stmt|;
name|controlsRect
operator|=
name|q
operator|->
name|contentsRect
argument_list|()
expr_stmt|;
name|viewportRect
operator|=
name|QRect
argument_list|(
name|controlsRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|controlsRect
operator|.
name|bottomRight
argument_list|()
operator|-
name|cornerOffset
argument_list|)
expr_stmt|;
block|}
name|cornerOffset
operator|=
name|QPoint
argument_list|(
name|needv
condition|?
name|vsbExt
else|:
literal|0
argument_list|,
name|needh
condition|?
name|hsbExt
else|:
literal|0
argument_list|)
expr_stmt|;
comment|// If we have a corner widget and are only showing one scroll bar, we need to move it
comment|// to make room for the corner widget.
if|if
condition|(
name|hasCornerWidget
operator|&&
operator|(
name|needv
operator|||
name|needh
operator|)
operator|&&
name|scrollOverlap
operator|==
literal|0
condition|)
name|cornerOffset
operator|=
name|extPoint
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// Also move the scroll bars if they are covered by the native Mac size grip.
if|if
condition|(
name|hasMacSizeGrip
condition|)
name|cornerOffset
operator|=
name|extPoint
expr_stmt|;
endif|#
directive|endif
comment|// The corner point is where the scroll bar rects, the corner widget rect and the
comment|// viewport rect meets.
specifier|const
name|QPoint
name|cornerPoint
argument_list|(
name|controlsRect
operator|.
name|bottomRight
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|-
name|cornerOffset
argument_list|)
decl_stmt|;
comment|// Some styles paints the corner if both scorllbars are showing and there is
comment|// no corner widget. Also, on the Mac we paint if there is a native
comment|// (transparent) sizegrip in the area where a corner widget would be.
if|if
condition|(
operator|(
name|needv
operator|&&
name|needh
operator|&&
name|hasCornerWidget
operator|==
literal|false
operator|&&
name|scrollOverlap
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|needv
operator|||
name|needh
operator|)
ifdef|#
directive|ifdef
name|Q_WS_MAC
operator|&&
name|hasMacSizeGrip
endif|#
directive|endif
operator|)
condition|)
block|{
name|cornerPaintingRect
operator|=
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|QRect
argument_list|(
name|cornerPoint
argument_list|,
name|extSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cornerPaintingRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|hasMacReverseSizeGrip
condition|)
name|reverseCornerPaintingRect
operator|=
name|QRect
argument_list|(
name|controlsRect
operator|.
name|bottomRight
argument_list|()
operator|+
name|QPoint
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|-
name|extPoint
argument_list|,
name|extSize
argument_list|)
expr_stmt|;
else|else
name|reverseCornerPaintingRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// move the scrollbars away from top/left headers
name|int
name|vHeaderRight
init|=
literal|0
decl_stmt|;
name|int
name|hHeaderBottom
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|scrollOverlap
operator|>
literal|0
operator|&&
operator|(
name|needv
operator|||
name|needh
operator|)
condition|)
block|{
specifier|const
name|QList
argument_list|<
name|QHeaderView
modifier|*
argument_list|>
name|headers
init|=
name|q
operator|->
name|findChildren
argument_list|<
name|QHeaderView
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|headers
operator|.
name|count
argument_list|()
operator|<=
literal|2
condition|)
block|{
name|Q_FOREACH
argument_list|(
argument|const QHeaderView *header
argument_list|,
argument|headers
argument_list|)
block|{
specifier|const
name|QRect
name|geo
init|=
name|header
operator|->
name|geometry
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Vertical
operator|&&
name|header
operator|->
name|isVisible
argument_list|()
operator|&&
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|geo
argument_list|)
operator|.
name|left
argument_list|()
operator|<=
name|opt
operator|.
name|rect
operator|.
name|width
argument_list|()
operator|/
literal|2
condition|)
name|vHeaderRight
operator|=
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|geo
argument_list|)
operator|.
name|right
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
operator|&&
name|header
operator|->
name|isVisible
argument_list|()
operator|&&
name|geo
operator|.
name|top
argument_list|()
operator|<=
name|q
operator|->
name|frameWidth
argument_list|()
condition|)
name|hHeaderBottom
operator|=
name|geo
operator|.
name|bottom
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|needh
condition|)
block|{
name|QRect
name|horizontalScrollBarRect
argument_list|(
name|QPoint
argument_list|(
name|controlsRect
operator|.
name|left
argument_list|()
operator|+
name|vHeaderRight
argument_list|,
name|cornerPoint
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|cornerPoint
operator|.
name|x
argument_list|()
operator|-
literal|1
argument_list|,
name|controlsRect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|hasMacReverseSizeGrip
condition|)
name|horizontalScrollBarRect
operator|.
name|adjust
argument_list|(
name|vsbExt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_MAC
if|if
condition|(
operator|!
name|hasCornerWidget
operator|&&
name|QSysInfo
operator|::
name|macVersion
argument_list|()
operator|>=
name|QSysInfo
operator|::
name|MV_10_8
operator|&&
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollBar_Transient
argument_list|,
literal|0
argument_list|,
name|hbar
argument_list|)
condition|)
name|horizontalScrollBarRect
operator|.
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|cornerOffset
operator|.
name|x
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|horizontalScrollBarRect
argument_list|)
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needv
condition|)
block|{
name|QRect
name|verticalScrollBarRect
argument_list|(
name|QPoint
argument_list|(
name|cornerPoint
operator|.
name|x
argument_list|()
argument_list|,
name|controlsRect
operator|.
name|top
argument_list|()
operator|+
name|hHeaderBottom
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|controlsRect
operator|.
name|right
argument_list|()
argument_list|,
name|cornerPoint
operator|.
name|y
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
if|if
condition|(
operator|!
name|hasCornerWidget
operator|&&
name|QSysInfo
operator|::
name|macVersion
argument_list|()
operator|>=
name|QSysInfo
operator|::
name|MV_10_8
operator|&&
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollBar_Transient
argument_list|,
literal|0
argument_list|,
name|vbar
argument_list|)
condition|)
name|verticalScrollBarRect
operator|.
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cornerOffset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|verticalScrollBarRect
argument_list|)
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cornerWidget
condition|)
block|{
specifier|const
name|QRect
name|cornerWidgetRect
argument_list|(
name|cornerPoint
argument_list|,
name|controlsRect
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|cornerWidget
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|cornerWidgetRect
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|setVisible
argument_list|(
name|needh
argument_list|)
expr_stmt|;
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|setVisible
argument_list|(
name|needv
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|viewportRect
operator|.
name|adjust
argument_list|(
name|right
argument_list|,
name|top
argument_list|,
operator|-
name|left
argument_list|,
operator|-
name|bottom
argument_list|)
expr_stmt|;
else|else
name|viewportRect
operator|.
name|adjust
argument_list|(
name|left
argument_list|,
name|top
argument_list|,
operator|-
name|right
argument_list|,
operator|-
name|bottom
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|opt
operator|.
name|direction
argument_list|,
name|opt
operator|.
name|rect
argument_list|,
name|viewportRect
argument_list|)
argument_list|)
expr_stmt|;
comment|// resize the viewport last
block|}
end_function
begin_comment
comment|/*!     \internal      Creates a new QAbstractScrollAreaPrivate, \a dd with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractScrollArea
name|QAbstractScrollArea
operator|::
name|QAbstractScrollArea
parameter_list|(
name|QAbstractScrollAreaPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|d
operator|->
name|viewportFilter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a viewport.      The \a parent argument is sent to the QWidget constructor. */
end_comment
begin_constructor
DECL|function|QAbstractScrollArea
name|QAbstractScrollArea
operator|::
name|QAbstractScrollArea
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QAbstractScrollAreaPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|d
operator|->
name|viewportFilter
operator|.
name|reset
argument_list|()
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Destroys the viewport.  */
end_comment
begin_destructor
DECL|function|~QAbstractScrollArea
name|QAbstractScrollArea
operator|::
name|~
name|QAbstractScrollArea
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
comment|// reset it here, otherwise we'll have a dangling pointer in ~QWidget
name|d
operator|->
name|viewportFilter
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \since 4.2   Sets the viewport to be the given \a widget.   The QAbstractScrollArea will take ownership of the given \a widget.    If \a widget is 0, QAbstractScrollArea will assign a new QWidget instance   for the viewport.    \sa viewport() */
end_comment
begin_function
DECL|function|setViewport
name|void
name|QAbstractScrollArea
operator|::
name|setViewport
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|widget
operator|!=
name|d
operator|->
name|viewport
condition|)
block|{
name|QWidget
modifier|*
name|oldViewport
init|=
name|d
operator|->
name|viewport
decl_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
name|widget
operator|=
operator|new
name|QWidget
expr_stmt|;
name|d
operator|->
name|viewport
operator|=
name|widget
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|setFocusProxy
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|installEventFilter
argument_list|(
name|d
operator|->
name|viewportFilter
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|d
operator|->
name|viewport
operator|->
name|grabGesture
argument_list|(
name|Qt
operator|::
name|PanGesture
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
name|d
operator|->
name|viewport
operator|->
name|show
argument_list|()
expr_stmt|;
name|setupViewport
argument_list|(
name|widget
argument_list|)
expr_stmt|;
operator|delete
name|oldViewport
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the viewport widget.      Use the QScrollArea::widget() function to retrieve the contents of     the viewport widget.      \sa QScrollArea::widget() */
end_comment
begin_function
DECL|function|viewport
name|QWidget
modifier|*
name|QAbstractScrollArea
operator|::
name|viewport
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|viewport
return|;
block|}
end_function
begin_comment
comment|/*! Returns the size of the viewport as if the scroll bars had no valid scrolling range. */
end_comment
begin_comment
comment|// ### still thinking about the name
end_comment
begin_function
DECL|function|maximumViewportSize
name|QSize
name|QAbstractScrollArea
operator|::
name|maximumViewportSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|int
name|hsbExt
init|=
name|d
operator|->
name|hbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|vsbExt
init|=
name|d
operator|->
name|vbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|f
init|=
literal|2
operator|*
name|d
operator|->
name|frameWidth
decl_stmt|;
name|QSize
name|max
init|=
name|size
argument_list|()
operator|-
name|QSize
argument_list|(
name|f
operator|+
name|d
operator|->
name|left
operator|+
name|d
operator|->
name|right
argument_list|,
name|f
operator|+
name|d
operator|->
name|top
operator|+
name|d
operator|->
name|bottom
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|max
operator|.
name|rwidth
argument_list|()
operator|-=
name|vsbExt
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|max
operator|.
name|rheight
argument_list|()
operator|-=
name|hsbExt
expr_stmt|;
return|return
name|max
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractScrollArea::verticalScrollBarPolicy     \brief the policy for the vertical scroll bar      The default policy is Qt::ScrollBarAsNeeded.      \sa horizontalScrollBarPolicy */
end_comment
begin_function
DECL|function|verticalScrollBarPolicy
name|Qt
operator|::
name|ScrollBarPolicy
name|QAbstractScrollArea
operator|::
name|verticalScrollBarPolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|vbarpolicy
return|;
block|}
end_function
begin_function
DECL|function|setVerticalScrollBarPolicy
name|void
name|QAbstractScrollArea
operator|::
name|setVerticalScrollBarPolicy
parameter_list|(
name|Qt
operator|::
name|ScrollBarPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
specifier|const
name|Qt
operator|::
name|ScrollBarPolicy
name|oldPolicy
init|=
name|d
operator|->
name|vbarpolicy
decl_stmt|;
name|d
operator|->
name|vbarpolicy
operator|=
name|policy
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldPolicy
operator|!=
name|d
operator|->
name|vbarpolicy
condition|)
name|d
operator|->
name|scrollBarPolicyChanged
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|d
operator|->
name|vbarpolicy
argument_list|)
expr_stmt|;
name|d
operator|->
name|setScrollBarTransient
argument_list|(
name|d
operator|->
name|vbar
argument_list|,
name|policy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the vertical scroll bar.    \sa verticalScrollBarPolicy, horizontalScrollBar()  */
end_comment
begin_function
DECL|function|verticalScrollBar
name|QScrollBar
modifier|*
name|QAbstractScrollArea
operator|::
name|verticalScrollBar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|vbar
return|;
block|}
end_function
begin_comment
comment|/*!    \since 4.2    Replaces the existing vertical scroll bar with \a scrollBar, and sets all    the former scroll bar's slider properties on the new scroll bar. The former    scroll bar is then deleted.     QAbstractScrollArea already provides vertical and horizontal scroll bars by    default. You can call this function to replace the default vertical    scroll bar with your own custom scroll bar.     \sa verticalScrollBar(), setHorizontalScrollBar() */
end_comment
begin_function
DECL|function|setVerticalScrollBar
name|void
name|QAbstractScrollArea
operator|::
name|setVerticalScrollBar
parameter_list|(
name|QScrollBar
modifier|*
name|scrollBar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scrollBar
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractScrollArea::setVerticalScrollBar: Cannot set a null scroll bar"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|replaceScrollBar
argument_list|(
name|scrollBar
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractScrollArea::horizontalScrollBarPolicy     \brief the policy for the horizontal scroll bar      The default policy is Qt::ScrollBarAsNeeded.      \sa verticalScrollBarPolicy */
end_comment
begin_function
DECL|function|horizontalScrollBarPolicy
name|Qt
operator|::
name|ScrollBarPolicy
name|QAbstractScrollArea
operator|::
name|horizontalScrollBarPolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hbarpolicy
return|;
block|}
end_function
begin_function
DECL|function|setHorizontalScrollBarPolicy
name|void
name|QAbstractScrollArea
operator|::
name|setHorizontalScrollBarPolicy
parameter_list|(
name|Qt
operator|::
name|ScrollBarPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
specifier|const
name|Qt
operator|::
name|ScrollBarPolicy
name|oldPolicy
init|=
name|d
operator|->
name|hbarpolicy
decl_stmt|;
name|d
operator|->
name|hbarpolicy
operator|=
name|policy
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldPolicy
operator|!=
name|d
operator|->
name|hbarpolicy
condition|)
name|d
operator|->
name|scrollBarPolicyChanged
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|,
name|d
operator|->
name|hbarpolicy
argument_list|)
expr_stmt|;
name|d
operator|->
name|setScrollBarTransient
argument_list|(
name|d
operator|->
name|hbar
argument_list|,
name|policy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the horizontal scroll bar.    \sa horizontalScrollBarPolicy, verticalScrollBar()  */
end_comment
begin_function
DECL|function|horizontalScrollBar
name|QScrollBar
modifier|*
name|QAbstractScrollArea
operator|::
name|horizontalScrollBar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hbar
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Replaces the existing horizontal scroll bar with \a scrollBar, and sets all     the former scroll bar's slider properties on the new scroll bar. The former     scroll bar is then deleted.      QAbstractScrollArea already provides horizontal and vertical scroll bars by     default. You can call this function to replace the default horizontal     scroll bar with your own custom scroll bar.      \sa horizontalScrollBar(), setVerticalScrollBar() */
end_comment
begin_function
DECL|function|setHorizontalScrollBar
name|void
name|QAbstractScrollArea
operator|::
name|setHorizontalScrollBar
parameter_list|(
name|QScrollBar
modifier|*
name|scrollBar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scrollBar
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractScrollArea::setHorizontalScrollBar: Cannot set a null scroll bar"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|replaceScrollBar
argument_list|(
name|scrollBar
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the widget in the corner between the two scroll bars.      By default, no corner widget is present. */
end_comment
begin_function
DECL|function|cornerWidget
name|QWidget
modifier|*
name|QAbstractScrollArea
operator|::
name|cornerWidget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cornerWidget
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the widget in the corner between the two scroll bars to be     \a widget.      You will probably also want to set at least one of the scroll bar     modes to \c AlwaysOn.      Passing 0 shows no widget in the corner.      Any previous corner widget is hidden.      You may call setCornerWidget() with the same widget at different     times.      All widgets set here will be deleted by the scroll area when it is     destroyed unless you separately reparent the widget after setting     some other corner widget (or 0).      Any \e newly set widget should have no current parent.      By default, no corner widget is present.      \sa horizontalScrollBarPolicy, horizontalScrollBarPolicy */
end_comment
begin_function
DECL|function|setCornerWidget
name|void
name|QAbstractScrollArea
operator|::
name|setCornerWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|oldWidget
init|=
name|d
operator|->
name|cornerWidget
decl_stmt|;
if|if
condition|(
name|oldWidget
operator|!=
name|widget
condition|)
block|{
if|if
condition|(
name|oldWidget
condition|)
name|oldWidget
operator|->
name|hide
argument_list|()
expr_stmt|;
name|d
operator|->
name|cornerWidget
operator|=
name|widget
expr_stmt|;
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|parentWidget
argument_list|()
operator|!=
name|this
condition|)
name|widget
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|widget
condition|)
name|widget
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|cornerWidget
operator|=
name|widget
expr_stmt|;
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Adds \a widget as a scroll bar widget in the location specified     by \a alignment.      Scroll bar widgets are shown next to the horizontal or vertical     scroll bar, and can be placed on either side of it. If you want     the scroll bar widgets to be always visible, set the     scrollBarPolicy for the corresponding scroll bar to \c AlwaysOn.      \a alignment must be one of Qt::Alignleft and Qt::AlignRight,     which maps to the horizontal scroll bar, or Qt::AlignTop and     Qt::AlignBottom, which maps to the vertical scroll bar.      A scroll bar widget can be removed by either re-parenting the     widget or deleting it. It's also possible to hide a widget with     QWidget::hide()      The scroll bar widget will be resized to fit the scroll bar     geometry for the current style. The following describes the case     for scroll bar widgets on the horizontal scroll bar:      The height of the widget will be set to match the height of the     scroll bar. To control the width of the widget, use     QWidget::setMinimumWidth and QWidget::setMaximumWidth, or     implement QWidget::sizeHint() and set a horizontal size policy.     If you want a square widget, call     QStyle::pixelMetric(QStyle::PM_ScrollBarExtent) and set the     width to this value.      \sa scrollBarWidgets() */
end_comment
begin_function
DECL|function|addScrollBarWidget
name|void
name|QAbstractScrollArea
operator|::
name|addScrollBarWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|widget
operator|==
literal|0
condition|)
return|return;
specifier|const
name|Qt
operator|::
name|Orientation
name|scrollBarOrientation
init|=
operator|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
operator|||
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
operator|)
condition|?
name|Qt
operator|::
name|Horizontal
else|:
name|Qt
operator|::
name|Vertical
decl_stmt|;
specifier|const
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalPosition
name|position
init|=
operator|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
operator|||
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignBottom
operator|)
operator|)
condition|?
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalRight
else|:
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalLeft
decl_stmt|;
name|d
operator|->
name|scrollBarContainers
index|[
name|scrollBarOrientation
index|]
operator|->
name|addWidget
argument_list|(
name|widget
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|isHidden
argument_list|()
operator|==
literal|false
condition|)
name|widget
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns a list of the currently set scroll bar widgets. \a alignment     can be any combination of the four location flags.      \sa addScrollBarWidget() */
end_comment
begin_function
DECL|function|scrollBarWidgets
name|QWidgetList
name|QAbstractScrollArea
operator|::
name|scrollBarWidgets
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QWidgetList
name|list
decl_stmt|;
if|if
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignLeft
condition|)
name|list
operator|+=
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|widgets
argument_list|(
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalLeft
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|list
operator|+=
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|widgets
argument_list|(
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignTop
condition|)
name|list
operator|+=
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|widgets
argument_list|(
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalLeft
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|list
operator|+=
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|widgets
argument_list|(
name|QAbstractScrollAreaScrollBarContainer
operator|::
name|LogicalRight
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the margins around the scrolling area to \a left, \a top, \a     right and \a bottom. This is useful for applications such as     spreadsheets with "locked" rows and columns. The marginal space is     is left blank; put widgets in the unused area.      Note that this function is frequently called by QTreeView and     QTableView, so margins must be implemented by QAbstractScrollArea     subclasses. Also, if the subclasses are to be used in item views,     they should not call this function.      By default all margins are zero.  */
end_comment
begin_function
DECL|function|setViewportMargins
name|void
name|QAbstractScrollArea
operator|::
name|setViewportMargins
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|d
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|top
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|right
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|bottom
operator|=
name|bottom
expr_stmt|;
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets \a margins around the scrolling area. This is useful for     applications such as spreadsheets with "locked" rows and columns.     The marginal space is is left blank; put widgets in the unused     area.      By default all margins are zero.  */
end_comment
begin_function
DECL|function|setViewportMargins
name|void
name|QAbstractScrollArea
operator|::
name|setViewportMargins
parameter_list|(
specifier|const
name|QMargins
modifier|&
name|margins
parameter_list|)
block|{
name|setViewportMargins
argument_list|(
name|margins
operator|.
name|left
argument_list|()
argument_list|,
name|margins
operator|.
name|top
argument_list|()
argument_list|,
name|margins
operator|.
name|right
argument_list|()
argument_list|,
name|margins
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QAbstractScrollArea
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|d
operator|->
name|hbar
operator|||
name|o
operator|==
name|d
operator|->
name|vbar
operator|)
operator|&&
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|HoverEnter
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|HoverLeave
operator|)
condition|)
block|{
name|Qt
operator|::
name|ScrollBarPolicy
name|policy
init|=
name|o
operator|==
name|d
operator|->
name|hbar
condition|?
name|d
operator|->
name|vbarpolicy
else|:
name|d
operator|->
name|hbarpolicy
decl_stmt|;
if|if
condition|(
name|policy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
condition|)
block|{
name|QScrollBar
modifier|*
name|sibling
init|=
name|o
operator|==
name|d
operator|->
name|hbar
condition|?
name|d
operator|->
name|vbar
else|:
name|d
operator|->
name|hbar
decl_stmt|;
name|d
operator|->
name|setScrollBarTransient
argument_list|(
name|sibling
argument_list|,
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|HoverLeave
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|QFrame
operator|::
name|eventFilter
argument_list|(
name|o
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAbstractScrollArea::event(QEvent *event)      \reimp      This is the main event handler for the QAbstractScrollArea widget (\e not     the scrolling area viewport()). The specified \a event is a general event     object that may need to be cast to the appropriate class depending on its     type.      \sa QEvent::type() */
end_comment
begin_function
DECL|function|event
name|bool
name|QAbstractScrollArea
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|AcceptDropsChange
case|:
comment|// There was a chance that with accessibility client we get an
comment|// event before the viewport was created.
comment|// Also, in some cases we might get here from QWidget::event() virtual function which is (indirectly) called
comment|// from the viewport constructor at the time when the d->viewport is not yet initialized even without any
comment|// accessibility client. See qabstractscrollarea autotest for a test case.
if|if
condition|(
name|d
operator|->
name|viewport
condition|)
name|d
operator|->
name|viewport
operator|->
name|setAcceptDrops
argument_list|(
name|acceptDrops
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseTrackingChange
case|:
name|d
operator|->
name|viewport
operator|->
name|setMouseTracking
argument_list|(
name|hasMouseTracking
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Resize
case|:
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Paint
case|:
block|{
name|QStyleOption
name|option
decl_stmt|;
name|option
operator|.
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cornerPaintingRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|option
operator|.
name|rect
operator|=
name|d
operator|->
name|cornerPaintingRect
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_PanelScrollAreaCorner
argument_list|,
operator|&
name|option
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|d
operator|->
name|reverseCornerPaintingRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|option
operator|.
name|rect
operator|=
name|d
operator|->
name|reverseCornerPaintingRect
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_PanelScrollAreaCorner
argument_list|,
operator|&
name|option
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|QFrame
operator|::
name|paintEvent
argument_list|(
operator|(
name|QPaintEvent
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|QContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
operator|->
name|reason
argument_list|()
operator|==
name|QContextMenuEvent
operator|::
name|Keyboard
condition|)
return|return
name|QFrame
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_CONTEXTMENU
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
case|case
name|QEvent
operator|::
name|Wheel
case|:
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragEnter
case|:
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
endif|#
directive|endif
comment|// ignore touch events in case they have been propagated from the viewport
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
return|return
literal|false
return|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|Gesture
case|:
block|{
name|QGestureEvent
modifier|*
name|ge
init|=
cast|static_cast
argument_list|<
name|QGestureEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QPanGesture
modifier|*
name|g
init|=
cast|static_cast
argument_list|<
name|QPanGesture
operator|*
argument_list|>
argument_list|(
name|ge
operator|->
name|gesture
argument_list|(
name|Qt
operator|::
name|PanGesture
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
condition|)
block|{
name|QScrollBar
modifier|*
name|hBar
init|=
name|horizontalScrollBar
argument_list|()
decl_stmt|;
name|QScrollBar
modifier|*
name|vBar
init|=
name|verticalScrollBar
argument_list|()
decl_stmt|;
name|QPointF
name|delta
init|=
name|g
operator|->
name|delta
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|delta
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|QApplication
operator|::
name|isRightToLeft
argument_list|()
condition|)
name|delta
operator|.
name|rx
argument_list|()
operator|*=
operator|-
literal|1
expr_stmt|;
name|int
name|newX
init|=
name|hBar
operator|->
name|value
argument_list|()
operator|-
name|delta
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|newY
init|=
name|vBar
operator|->
name|value
argument_list|()
operator|-
name|delta
operator|.
name|y
argument_list|()
decl_stmt|;
name|hBar
operator|->
name|setValue
argument_list|(
name|newX
argument_list|)
expr_stmt|;
name|vBar
operator|->
name|setValue
argument_list|(
name|newY
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|ScrollPrepare
case|:
block|{
name|QScrollPrepareEvent
modifier|*
name|se
init|=
cast|static_cast
argument_list|<
name|QScrollPrepareEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|canStartScrollingAt
argument_list|(
name|se
operator|->
name|startPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
condition|)
block|{
name|QScrollBar
modifier|*
name|hBar
init|=
name|horizontalScrollBar
argument_list|()
decl_stmt|;
name|QScrollBar
modifier|*
name|vBar
init|=
name|verticalScrollBar
argument_list|()
decl_stmt|;
name|se
operator|->
name|setViewportSize
argument_list|(
name|QSizeF
argument_list|(
name|viewport
argument_list|()
operator|->
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|setContentPosRange
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hBar
operator|->
name|maximum
argument_list|()
argument_list|,
name|vBar
operator|->
name|maximum
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|setContentPos
argument_list|(
name|QPointF
argument_list|(
name|hBar
operator|->
name|value
argument_list|()
argument_list|,
name|vBar
operator|->
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
case|case
name|QEvent
operator|::
name|Scroll
case|:
block|{
name|QScrollEvent
modifier|*
name|se
init|=
cast|static_cast
argument_list|<
name|QScrollEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QScrollBar
modifier|*
name|hBar
init|=
name|horizontalScrollBar
argument_list|()
decl_stmt|;
name|QScrollBar
modifier|*
name|vBar
init|=
name|verticalScrollBar
argument_list|()
decl_stmt|;
name|hBar
operator|->
name|setValue
argument_list|(
name|se
operator|->
name|contentPos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|vBar
operator|->
name|setValue
argument_list|(
name|se
operator|->
name|contentPos
argument_list|()
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_WIN
typedef|typedef
name|BOOL
function_decl|(
modifier|*
name|PtrBeginPanningFeedback
function_decl|)
parameter_list|(
name|HWND
parameter_list|)
function_decl|;
typedef|typedef
name|BOOL
function_decl|(
modifier|*
name|PtrUpdatePanningFeedback
function_decl|)
parameter_list|(
name|HWND
parameter_list|,
name|LONG
parameter_list|,
name|LONG
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
typedef|typedef
name|BOOL
function_decl|(
modifier|*
name|PtrEndPanningFeedback
function_decl|)
parameter_list|(
name|HWND
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
specifier|static
name|PtrBeginPanningFeedback
name|ptrBeginPanningFeedback
init|=
literal|0
decl_stmt|;
specifier|static
name|PtrUpdatePanningFeedback
name|ptrUpdatePanningFeedback
init|=
literal|0
decl_stmt|;
specifier|static
name|PtrEndPanningFeedback
name|ptrEndPanningFeedback
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ptrBeginPanningFeedback
condition|)
name|ptrBeginPanningFeedback
operator|=
operator|(
name|PtrBeginPanningFeedback
operator|)
name|QLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"UxTheme"
argument_list|)
argument_list|,
literal|"BeginPanningFeedback"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrUpdatePanningFeedback
condition|)
name|ptrUpdatePanningFeedback
operator|=
operator|(
name|PtrUpdatePanningFeedback
operator|)
name|QLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"UxTheme"
argument_list|)
argument_list|,
literal|"UpdatePanningFeedback"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrEndPanningFeedback
condition|)
name|ptrEndPanningFeedback
operator|=
operator|(
name|PtrEndPanningFeedback
operator|)
name|QLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"UxTheme"
argument_list|)
argument_list|,
literal|"EndPanningFeedback"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrBeginPanningFeedback
operator|&&
name|ptrUpdatePanningFeedback
operator|&&
name|ptrEndPanningFeedback
condition|)
block|{
name|WId
name|wid
init|=
name|window
argument_list|()
operator|->
name|winId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|overshoot
operator|.
name|isNull
argument_list|()
condition|)
name|ptrBeginPanningFeedback
argument_list|(
name|wid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|ptrUpdatePanningFeedback
argument_list|(
name|wid
argument_list|,
operator|-
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|y
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|overshoot
operator|.
name|isNull
argument_list|()
condition|)
name|ptrEndPanningFeedback
argument_list|(
name|wid
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|QPoint
name|delta
init|=
name|d
operator|->
name|overshoot
operator|-
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|toPoint
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|delta
operator|.
name|isNull
argument_list|()
condition|)
name|viewport
argument_list|()
operator|->
name|move
argument_list|(
name|viewport
argument_list|()
operator|->
name|pos
argument_list|()
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|overshoot
operator|=
name|se
operator|->
name|overshootDistance
argument_list|()
operator|.
name|toPoint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|QEvent
operator|::
name|StyleChange
case|:
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
case|case
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
case|:
case|case
name|QEvent
operator|::
name|LayoutRequest
case|:
name|d
operator|->
name|layoutChildren
argument_list|()
expr_stmt|;
comment|// fall through
default|default:
return|return
name|QFrame
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \fn bool QAbstractScrollArea::viewportEvent(QEvent *event)    The main event handler for the scrolling area (the viewport() widget).   It handles the \a event specified, and can be called by subclasses to   provide reasonable default behavior.    Returns true to indicate to the event system that the event has been   handled, and needs no further processing; otherwise returns false to   indicate that the event should be propagated further.    You can reimplement this function in a subclass, but we recommend   using one of the specialized event handlers instead.    Specialized handlers for viewport events are: paintEvent(),   mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(),   mouseMoveEvent(), wheelEvent(), dragEnterEvent(), dragMoveEvent(),   dragLeaveEvent(), dropEvent(), contextMenuEvent(), and   resizeEvent(). */
end_comment
begin_function
DECL|function|viewportEvent
name|bool
name|QAbstractScrollArea
operator|::
name|viewportEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Resize
case|:
case|case
name|QEvent
operator|::
name|Paint
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
case|case
name|QEvent
operator|::
name|Drop
case|:
case|case
name|QEvent
operator|::
name|DragEnter
case|:
case|case
name|QEvent
operator|::
name|DragMove
case|:
case|case
name|QEvent
operator|::
name|DragLeave
case|:
endif|#
directive|endif
return|return
name|QFrame
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
case|case
name|QEvent
operator|::
name|LayoutRequest
case|:
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|Gesture
case|:
case|case
name|QEvent
operator|::
name|GestureOverride
case|:
return|return
name|event
argument_list|(
name|e
argument_list|)
return|;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|ScrollPrepare
case|:
case|case
name|QEvent
operator|::
name|Scroll
case|:
return|return
name|event
argument_list|(
name|e
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
comment|// let the viewport widget handle the event
block|}
end_function
begin_comment
comment|/*!     \fn void QAbstractScrollArea::resizeEvent(QResizeEvent *event)      This event handler can be reimplemented in a subclass to receive     resize events (passed in \a event), for the viewport() widget.      When resizeEvent() is called, the viewport already has its new     geometry: Its new size is accessible through the     QResizeEvent::size() function, and the old size through     QResizeEvent::oldSize().      \sa QWidget::resizeEvent()  */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QAbstractScrollArea
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QAbstractScrollArea::paintEvent(QPaintEvent *event)      This event handler can be reimplemented in a subclass to receive     paint events (passed in \a event), for the viewport() widget.      \note If you open a painter, make sure to open it on the viewport().      \sa QWidget::paintEvent() */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QAbstractScrollArea
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     mouse press events for the viewport() widget. The event is passed     in \a e.      \sa QWidget::mousePressEvent() */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QAbstractScrollArea
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     mouse release events for the viewport() widget. The event is     passed in \a e.      \sa QWidget::mouseReleaseEvent() */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QAbstractScrollArea
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     mouse double click events for the viewport() widget. The event is     passed in \a e.      \sa QWidget::mouseDoubleClickEvent() */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QAbstractScrollArea
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     mouse move events for the viewport() widget. The event is passed     in \a e.      \sa QWidget::mouseMoveEvent() */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QAbstractScrollArea
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     wheel events for the viewport() widget. The event is passed in \a     e.      \sa QWidget::wheelEvent() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_function
DECL|function|wheelEvent
name|void
name|QAbstractScrollArea
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|QWheelEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
operator|->
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|hbar
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|vbar
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     context menu events for the viewport() widget. The event is passed     in \a e.      \sa QWidget::contextMenuEvent() */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QAbstractScrollArea
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_comment
comment|/*!     This function is called with key event \a e when key presses     occur. It handles PageUp, PageDown, Up, Down, Left, and Right, and     ignores all other key presses. */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QAbstractScrollArea
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|MoveToPreviousPage
condition|)
block|{
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QScrollBar
operator|::
name|SliderPageStepSub
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QKeySequence
operator|::
name|MoveToNextPage
condition|)
block|{
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QScrollBar
operator|::
name|SliderPageStepAdd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Up
case|:
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QScrollBar
operator|::
name|SliderSingleStepSub
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Down
case|:
name|d
operator|->
name|vbar
operator|->
name|triggerAction
argument_list|(
name|QScrollBar
operator|::
name|SliderSingleStepAdd
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Left
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|hasEditFocus
argument_list|()
operator|&&
operator|(
operator|!
name|d
operator|->
name|hbar
operator|->
name|isVisible
argument_list|()
operator|||
name|d
operator|->
name|hbar
operator|->
name|value
argument_list|()
operator|==
name|d
operator|->
name|hbar
operator|->
name|minimum
argument_list|()
operator|)
condition|)
block|{
comment|//if we aren't using the hbar or we are already at the leftmost point ignore
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|d
operator|->
name|hbar
operator|->
name|triggerAction
argument_list|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|QScrollBar
operator|::
name|SliderSingleStepSub
else|:
name|QScrollBar
operator|::
name|SliderSingleStepAdd
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Right
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|hasEditFocus
argument_list|()
operator|&&
operator|(
operator|!
name|d
operator|->
name|hbar
operator|->
name|isVisible
argument_list|()
operator|||
name|d
operator|->
name|hbar
operator|->
name|value
argument_list|()
operator|==
name|d
operator|->
name|hbar
operator|->
name|maximum
argument_list|()
operator|)
condition|)
block|{
comment|//if we aren't using the hbar or we are already at the rightmost point ignore
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|d
operator|->
name|hbar
operator|->
name|triggerAction
argument_list|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|QScrollBar
operator|::
name|SliderSingleStepAdd
else|:
name|QScrollBar
operator|::
name|SliderSingleStepSub
argument_list|)
expr_stmt|;
break|break;
default|default:
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     \fn void QAbstractScrollArea::dragEnterEvent(QDragEnterEvent *event)      This event handler can be reimplemented in a subclass to receive     drag enter events (passed in \a event), for the viewport() widget.      \sa QWidget::dragEnterEvent() */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QAbstractScrollArea
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QAbstractScrollArea::dragMoveEvent(QDragMoveEvent *event)      This event handler can be reimplemented in a subclass to receive     drag move events (passed in \a event), for the viewport() widget.      \sa QWidget::dragMoveEvent() */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QAbstractScrollArea
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QAbstractScrollArea::dragLeaveEvent(QDragLeaveEvent *event)      This event handler can be reimplemented in a subclass to receive     drag leave events (passed in \a event), for the viewport() widget.      \sa QWidget::dragLeaveEvent() */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QAbstractScrollArea
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QAbstractScrollArea::dropEvent(QDropEvent *event)      This event handler can be reimplemented in a subclass to receive     drop events (passed in \a event), for the viewport() widget.      \sa QWidget::dropEvent() */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QAbstractScrollArea
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     This virtual handler is called when the scroll bars are moved by     \a dx, \a dy, and consequently the viewport's contents should be     scrolled accordingly.      The default implementation simply calls update() on the entire     viewport(), subclasses can reimplement this handler for     optimization purposes, or - like QScrollArea - to move a contents     widget. The parameters \a dx and \a dy are there for convenience,     so that the class knows how much should be scrolled (useful     e.g. when doing pixel-shifts). You may just as well ignore these     values and scroll directly to the position the scroll bars     indicate.      Calling this function in order to scroll programmatically is an     error, use the scroll bars instead (e.g. by calling     QScrollBar::setValue() directly). */
end_comment
begin_function
DECL|function|scrollContentsBy
name|void
name|QAbstractScrollArea
operator|::
name|scrollContentsBy
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
block|{
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|canStartScrollingAt
name|bool
name|QAbstractScrollAreaPrivate
operator|::
name|canStartScrollingAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|startPos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
comment|// don't start scrolling when a drag mode has been set.
comment|// don't start scrolling on a movable item.
if|if
condition|(
name|QGraphicsView
modifier|*
name|view
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|view
operator|->
name|dragMode
argument_list|()
operator|!=
name|QGraphicsView
operator|::
name|NoDrag
condition|)
return|return
literal|false
return|;
name|QGraphicsItem
modifier|*
name|childItem
init|=
name|view
operator|->
name|itemAt
argument_list|(
name|startPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|childItem
operator|&&
operator|(
name|childItem
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsMovable
operator|)
condition|)
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|// don't start scrolling on a QAbstractSlider
if|if
condition|(
name|qobject_cast
argument_list|<
name|QAbstractSlider
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|viewport
argument_list|()
operator|->
name|childAt
argument_list|(
name|startPos
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|flashScrollBars
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|flashScrollBars
parameter_list|()
block|{
if|if
condition|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
condition|)
name|hbar
operator|->
name|d_func
argument_list|()
operator|->
name|flash
argument_list|()
expr_stmt|;
if|if
condition|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
condition|)
name|vbar
operator|->
name|d_func
argument_list|()
operator|->
name|flash
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setScrollBarTransient
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|setScrollBarTransient
parameter_list|(
name|QScrollBar
modifier|*
name|scrollBar
parameter_list|,
name|bool
name|transient
parameter_list|)
block|{
name|scrollBar
operator|->
name|d_func
argument_list|()
operator|->
name|setTransient
argument_list|(
name|transient
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_hslide
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|_q_hslide
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|int
name|dx
init|=
name|xoffset
operator|-
name|x
decl_stmt|;
name|xoffset
operator|=
name|x
expr_stmt|;
name|q
operator|->
name|scrollContentsBy
argument_list|(
name|dx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flashScrollBars
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_vslide
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|_q_vslide
parameter_list|(
name|int
name|y
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|int
name|dy
init|=
name|yoffset
operator|-
name|y
decl_stmt|;
name|yoffset
operator|=
name|y
expr_stmt|;
name|q
operator|->
name|scrollContentsBy
argument_list|(
literal|0
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|flashScrollBars
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_showOrHideScrollBars
name|void
name|QAbstractScrollAreaPrivate
operator|::
name|_q_showOrHideScrollBars
parameter_list|()
block|{
name|layoutChildren
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_WIN
comment|// Need to re-subscribe to gestures as the content changes to make sure we
comment|// enable/disable panning when needed.
name|QWidgetPrivate
modifier|*
name|dd
init|=
cast|static_cast
argument_list|<
name|QWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|viewport
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dd
condition|)
name|dd
operator|->
name|winSetupGestures
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Q_WS_WIN
block|}
end_function
begin_function
DECL|function|contentsOffset
name|QPoint
name|QAbstractScrollAreaPrivate
operator|::
name|contentsOffset
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|QPoint
name|offset
decl_stmt|;
if|if
condition|(
name|vbar
operator|->
name|isVisible
argument_list|()
condition|)
name|offset
operator|.
name|setY
argument_list|(
name|vbar
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbar
operator|->
name|isVisible
argument_list|()
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|offset
operator|.
name|setX
argument_list|(
name|hbar
operator|->
name|maximum
argument_list|()
operator|-
name|hbar
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|offset
operator|.
name|setX
argument_list|(
name|hbar
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp  */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QAbstractScrollArea
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractScrollArea
argument_list|)
expr_stmt|;
name|int
name|hsbExt
init|=
name|d
operator|->
name|hbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|vsbExt
init|=
name|d
operator|->
name|vbar
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|extra
init|=
literal|2
operator|*
name|d
operator|->
name|frameWidth
decl_stmt|;
name|QStyleOption
name|opt
decl_stmt|;
name|opt
operator|.
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|frameStyle
operator|!=
name|QFrame
operator|::
name|NoFrame
operator|)
operator|&&
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollView_FrameOnlyAroundContents
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
block|{
name|extra
operator|+=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ScrollView_ScrollBarSpacing
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|QSize
argument_list|(
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Horizontal
index|]
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
operator|+
name|vsbExt
operator|+
name|extra
argument_list|,
name|d
operator|->
name|scrollBarContainers
index|[
name|Qt
operator|::
name|Vertical
index|]
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
operator|+
name|hsbExt
operator|+
name|extra
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QAbstractScrollArea
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
literal|256
argument_list|,
literal|192
argument_list|)
return|;
if|#
directive|if
literal|0
block|Q_D(const QAbstractScrollArea);     int h = qMax(10, fontMetrics().height());     int f = 2 * d->frameWidth;     return QSize((6 * h) + f, (4 * h) + f);
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     This slot is called by QAbstractScrollArea after setViewport(\a     viewport) has been called. Reimplement this function in a     subclass of QAbstractScrollArea to initialize the new \a viewport     before it is used.      \sa setViewport() */
end_comment
begin_function
DECL|function|setupViewport
name|void
name|QAbstractScrollArea
operator|::
name|setupViewport
parameter_list|(
name|QWidget
modifier|*
name|viewport
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      This method is reserved for future use. */
end_comment
begin_function
DECL|function|viewportSizeHint
name|QSize
name|QAbstractScrollArea
operator|::
name|viewportSizeHint
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qabstractscrollarea.cpp"
end_include
begin_include
include|#
directive|include
file|"moc_qabstractscrollarea_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SCROLLAREA
end_comment
end_unit
