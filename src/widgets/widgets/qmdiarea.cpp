begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QMdiArea     \brief The QMdiArea widget provides an area in which MDI windows are displayed.     \since 4.3     \ingroup mainwindow-classes     \inmodule QtWidgets      QMdiArea functions, essentially, like a window manager for MDI     windows. For instance, it draws the windows it manages on itself     and arranges them in a cascading or tile pattern. QMdiArea is     commonly used as the center widget in a QMainWindow to create MDI     applications, but can also be placed in any layout. The following     code adds an area to a main window:      \snippet mdiareasnippets.cpp 0      Unlike the window managers for top-level windows, all window flags     (Qt::WindowFlags) are supported by QMdiArea as long as the flags     are supported by the current widget style. If a specific flag is     not supported by the style (e.g., the     \l{Qt::}{WindowShadeButtonHint}), you can still shade the window     with showShaded().      Subwindows in QMdiArea are instances of QMdiSubWindow. They     are added to an MDI area with addSubWindow(). It is common to pass     a QWidget, which is set as the internal widget, to this function,     but it is also possible to pass a QMdiSubWindow directly.The class     inherits QWidget, and you can use the same API as with a normal     top-level window when programming. QMdiSubWindow also has behavior     that is specific to MDI windows. See the QMdiSubWindow class     description for more details.      A subwindow becomes active when it gets the keyboard focus, or     when setFocus() is called. The user activates a window by moving     focus in the usual ways. The MDI area emits the     subWindowActivated() signal when the active window changes, and     the activeSubWindow() function returns the active subwindow.      The convenience function subWindowList() returns a list of all     subwindows. This information could be used in a popup menu     containing a list of windows, for example.      The subwindows are sorted by the current     \l{QMdiArea::}{WindowOrder}. This is used for the subWindowList()     and for activateNextSubWindow() and activatePreviousSubWindow().     Also, it is used when cascading or tiling the windows with     cascadeSubWindows() and tileSubWindows().      QMdiArea provides two built-in layout strategies for     subwindows: cascadeSubWindows() and tileSubWindows(). Both are     slots and are easily connected to menu entries.      \table     \row \li \inlineimage mdi-cascade.png          \li \inlineimage mdi-tile.png     \endtable      \note The default scroll bar property for QMdiArea is Qt::ScrollBarAlwaysOff.      \sa QMdiSubWindow */
end_comment
begin_comment
comment|/*!     \fn QMdiArea::subWindowActivated(QMdiSubWindow *window)      QMdiArea emits this signal after \a window has been activated. When \a     window is 0, QMdiArea has just deactivated its last active window, and     there are no active windows on the workspace.      \sa QMdiArea::activeSubWindow() */
end_comment
begin_comment
comment|/*!     \enum QMdiArea::AreaOption      This enum describes options that customize the behavior of the     QMdiArea.      \value DontMaximizeSubWindowOnActivation When the active subwindow     is maximized, the default behavior is to maximize the next     subwindow that is activated. Set this option if you do not want     this behavior. */
end_comment
begin_comment
comment|/*!     \enum QMdiArea::WindowOrder      Specifies the criteria to use for ordering the list of child windows     returned by subWindowList(). The functions cascadeSubWindows() and     tileSubWindows() follow this order when arranging the windows.      \value CreationOrder The windows are returned in the order of     their creation.      \value StackingOrder The windows are returned in the order in     which they are stacked, with the top-most window being last in     the list.      \value ActivationHistoryOrder The windows are returned in the order in     which they were activated.      \sa subWindowList() */
end_comment
begin_comment
comment|/*!     \enum QMdiArea::ViewMode     \since 4.4      This enum describes the view mode of the area; i.e. how sub-windows     will be displayed.      \value SubWindowView Display sub-windows with window frames (default).     \value TabbedView Display sub-windows with tabs in a tab bar.      \sa setViewMode() */
end_comment
begin_include
include|#
directive|include
file|"qmdiarea_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MDIAREA
end_ifndef
begin_include
include|#
directive|include
file|<QApplication>
end_include
begin_include
include|#
directive|include
file|<QStyle>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_STYLE_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qmacstyle_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QChildEvent>
end_include
begin_include
include|#
directive|include
file|<QResizeEvent>
end_include
begin_include
include|#
directive|include
file|<QScrollBar>
end_include
begin_include
include|#
directive|include
file|<QtAlgorithms>
end_include
begin_include
include|#
directive|include
file|<QMutableListIterator>
end_include
begin_include
include|#
directive|include
file|<QPainter>
end_include
begin_include
include|#
directive|include
file|<QFontMetrics>
end_include
begin_include
include|#
directive|include
file|<QStyleOption>
end_include
begin_include
include|#
directive|include
file|<QDesktopWidget>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qlayoutengine_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_using
using|using
namespace|namespace
name|QMdi
namespace|;
end_using
begin_comment
comment|// Asserts in debug mode, gives warning otherwise.
end_comment
begin_function
DECL|function|sanityCheck
specifier|static
name|bool
name|sanityCheck
parameter_list|(
specifier|const
name|QMdiSubWindow
modifier|*
specifier|const
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
if|if
condition|(
operator|!
name|child
condition|)
block|{
specifier|const
name|char
name|error
index|[]
init|=
literal|"null pointer"
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s:%s"
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|sanityCheck
specifier|static
name|bool
name|sanityCheck
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
modifier|&
name|widgets
parameter_list|,
specifier|const
name|int
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|widgets
operator|.
name|size
argument_list|()
condition|)
block|{
specifier|const
name|char
name|error
index|[]
init|=
literal|"index out of range"
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s:%s"
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|widgets
operator|.
name|at
argument_list|(
name|index
argument_list|)
condition|)
block|{
specifier|const
name|char
name|error
index|[]
init|=
literal|"null pointer"
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s:%s"
argument_list|,
name|where
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setIndex
specifier|static
name|void
name|setIndex
parameter_list|(
name|int
modifier|*
name|index
parameter_list|,
name|int
name|candidate
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|bool
name|isIncreasing
parameter_list|)
block|{
if|if
condition|(
operator|!
name|index
condition|)
return|return;
if|if
condition|(
name|isIncreasing
condition|)
block|{
if|if
condition|(
name|candidate
operator|>
name|max
condition|)
operator|*
name|index
operator|=
name|min
expr_stmt|;
else|else
operator|*
name|index
operator|=
name|qMax
argument_list|(
name|candidate
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|candidate
operator|<
name|min
condition|)
operator|*
name|index
operator|=
name|max
expr_stmt|;
else|else
operator|*
name|index
operator|=
name|qMin
argument_list|(
name|candidate
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|*
name|index
operator|>=
name|min
operator|&&
operator|*
name|index
operator|<=
name|max
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|useScrollBar
specifier|static
specifier|inline
name|bool
name|useScrollBar
parameter_list|(
specifier|const
name|QRect
modifier|&
name|childrenRect
parameter_list|,
specifier|const
name|QSize
modifier|&
name|maxViewportSize
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
return|return
name|childrenRect
operator|.
name|width
argument_list|()
operator|>
name|maxViewportSize
operator|.
name|width
argument_list|()
operator|||
name|childrenRect
operator|.
name|left
argument_list|()
operator|<
literal|0
operator|||
name|childrenRect
operator|.
name|right
argument_list|()
operator|>=
name|maxViewportSize
operator|.
name|width
argument_list|()
return|;
else|else
return|return
name|childrenRect
operator|.
name|height
argument_list|()
operator|>
name|maxViewportSize
operator|.
name|height
argument_list|()
operator|||
name|childrenRect
operator|.
name|top
argument_list|()
operator|<
literal|0
operator|||
name|childrenRect
operator|.
name|bottom
argument_list|()
operator|>=
name|maxViewportSize
operator|.
name|height
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Returns the closest mdi area containing the widget (if any).
end_comment
begin_function
DECL|function|mdiAreaParent
specifier|static
specifier|inline
name|QMdiArea
modifier|*
name|mdiAreaParent
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|widget
condition|)
return|return
literal|0
return|;
name|QWidget
modifier|*
name|parent
init|=
name|widget
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|QMdiArea
modifier|*
name|area
init|=
name|qobject_cast
argument_list|<
name|QMdiArea
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|area
return|;
name|parent
operator|=
name|parent
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
end_ifndef
begin_function
DECL|function|tabBarShapeFrom
specifier|static
specifier|inline
name|QTabBar
operator|::
name|Shape
name|tabBarShapeFrom
parameter_list|(
name|QTabWidget
operator|::
name|TabShape
name|shape
parameter_list|,
name|QTabWidget
operator|::
name|TabPosition
name|position
parameter_list|)
block|{
specifier|const
name|bool
name|rounded
init|=
operator|(
name|shape
operator|==
name|QTabWidget
operator|::
name|Rounded
operator|)
decl_stmt|;
if|if
condition|(
name|position
operator|==
name|QTabWidget
operator|::
name|North
condition|)
return|return
name|rounded
condition|?
name|QTabBar
operator|::
name|RoundedNorth
else|:
name|QTabBar
operator|::
name|TriangularNorth
return|;
if|if
condition|(
name|position
operator|==
name|QTabWidget
operator|::
name|South
condition|)
return|return
name|rounded
condition|?
name|QTabBar
operator|::
name|RoundedSouth
else|:
name|QTabBar
operator|::
name|TriangularSouth
return|;
if|if
condition|(
name|position
operator|==
name|QTabWidget
operator|::
name|East
condition|)
return|return
name|rounded
condition|?
name|QTabBar
operator|::
name|RoundedEast
else|:
name|QTabBar
operator|::
name|TriangularEast
return|;
if|if
condition|(
name|position
operator|==
name|QTabWidget
operator|::
name|West
condition|)
return|return
name|rounded
condition|?
name|QTabBar
operator|::
name|RoundedWest
else|:
name|QTabBar
operator|::
name|TriangularWest
return|;
return|return
name|QTabBar
operator|::
name|RoundedNorth
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABWIDGET
end_comment
begin_function
DECL|function|tabTextFor
specifier|static
specifier|inline
name|QString
name|tabTextFor
parameter_list|(
name|QMdiSubWindow
modifier|*
name|subWindow
parameter_list|)
block|{
if|if
condition|(
operator|!
name|subWindow
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|title
init|=
name|subWindow
operator|->
name|windowTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|subWindow
operator|->
name|isWindowModified
argument_list|()
condition|)
block|{
name|title
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"[*]"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|QString
name|qt_setWindowTitle_helperHelper
argument_list|(
specifier|const
name|QString
operator|&
argument_list|,
specifier|const
name|QWidget
operator|*
argument_list|)
decl_stmt|;
name|title
operator|=
name|qt_setWindowTitle_helperHelper
argument_list|(
name|title
argument_list|,
name|subWindow
argument_list|)
expr_stmt|;
block|}
return|return
name|title
operator|.
name|isEmpty
argument_list|()
condition|?
name|QMdiArea
operator|::
name|tr
argument_list|(
literal|"(Untitled)"
argument_list|)
else|:
name|title
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rearrange
name|void
name|RegularTiler
operator|::
name|rearrange
parameter_list|(
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
modifier|&
name|widgets
parameter_list|,
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|widgets
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|int
name|n
init|=
name|widgets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ncols
init|=
name|qMax
argument_list|(
name|qCeil
argument_list|(
name|qSqrt
argument_list|(
name|qreal
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|nrows
init|=
name|qMax
argument_list|(
operator|(
name|n
operator|%
name|ncols
operator|)
condition|?
operator|(
name|n
operator|/
name|ncols
operator|+
literal|1
operator|)
else|:
operator|(
name|n
operator|/
name|ncols
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|nspecial
init|=
operator|(
name|n
operator|%
name|ncols
operator|)
condition|?
operator|(
name|ncols
operator|-
name|n
operator|%
name|ncols
operator|)
else|:
literal|0
decl_stmt|;
specifier|const
name|int
name|dx
init|=
name|domain
operator|.
name|width
argument_list|()
operator|/
name|ncols
decl_stmt|;
specifier|const
name|int
name|dy
init|=
name|domain
operator|.
name|height
argument_list|()
operator|/
name|nrows
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
operator|++
name|row
control|)
block|{
specifier|const
name|int
name|y1
init|=
name|int
argument_list|(
name|row
operator|*
operator|(
name|dy
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
operator|++
name|col
control|)
block|{
if|if
condition|(
name|row
operator|==
literal|1
operator|&&
name|col
operator|<
name|nspecial
condition|)
continue|continue;
specifier|const
name|int
name|x1
init|=
name|int
argument_list|(
name|col
operator|*
operator|(
name|dx
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|int
name|x2
init|=
name|int
argument_list|(
name|x1
operator|+
name|dx
argument_list|)
decl_stmt|;
name|int
name|y2
init|=
name|int
argument_list|(
name|y1
operator|+
name|dy
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|==
literal|0
operator|&&
name|col
operator|<
name|nspecial
condition|)
block|{
name|y2
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|nrows
operator|!=
literal|2
condition|)
name|y2
operator|+=
literal|1
expr_stmt|;
else|else
name|y2
operator|=
name|domain
operator|.
name|bottom
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|==
name|ncols
operator|-
literal|1
operator|&&
name|x2
operator|!=
name|domain
operator|.
name|right
argument_list|()
condition|)
name|x2
operator|=
name|domain
operator|.
name|right
argument_list|()
expr_stmt|;
if|if
condition|(
name|row
operator|==
name|nrows
operator|-
literal|1
operator|&&
name|y2
operator|!=
name|domain
operator|.
name|bottom
argument_list|()
condition|)
name|y2
operator|=
name|domain
operator|.
name|bottom
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|widgets
argument_list|,
name|i
argument_list|,
literal|"RegularTiler"
argument_list|)
condition|)
continue|continue;
name|QWidget
modifier|*
name|widget
init|=
name|widgets
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|QRect
name|newGeometry
init|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
argument_list|)
decl_stmt|;
name|widget
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|widget
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|domain
argument_list|,
name|newGeometry
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rearrange
name|void
name|SimpleCascader
operator|::
name|rearrange
parameter_list|(
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
modifier|&
name|widgets
parameter_list|,
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|widgets
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Tunables:
specifier|const
name|int
name|topOffset
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|bottomOffset
init|=
literal|50
decl_stmt|;
specifier|const
name|int
name|leftOffset
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|rightOffset
init|=
literal|100
decl_stmt|;
specifier|const
name|int
name|dx
init|=
literal|10
decl_stmt|;
name|QStyleOptionTitleBar
name|options
decl_stmt|;
name|options
operator|.
name|initFrom
argument_list|(
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|titleBarHeight
init|=
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_TitleBarHeight
argument_list|,
operator|&
name|options
argument_list|,
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_STYLE_MAC
argument_list|)
comment|// ### Remove this after the mac style has been fixed
if|if
condition|(
name|qobject_cast
argument_list|<
name|QMacStyle
operator|*
argument_list|>
argument_list|(
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|style
argument_list|()
argument_list|)
condition|)
name|titleBarHeight
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QFontMetrics
name|fontMetrics
init|=
name|QFontMetrics
argument_list|(
name|QApplication
operator|::
name|font
argument_list|(
literal|"QMdiSubWindowTitleBar"
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|dy
init|=
name|qMax
argument_list|(
name|titleBarHeight
operator|-
operator|(
name|titleBarHeight
operator|-
name|fontMetrics
operator|.
name|height
argument_list|()
operator|)
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|n
init|=
name|widgets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|int
name|nrows
init|=
name|qMax
argument_list|(
operator|(
name|domain
operator|.
name|height
argument_list|()
operator|-
operator|(
name|topOffset
operator|+
name|bottomOffset
operator|)
operator|)
operator|/
name|dy
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|ncols
init|=
name|qMax
argument_list|(
name|n
operator|/
name|nrows
operator|+
operator|(
operator|(
name|n
operator|%
name|nrows
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|dcol
init|=
operator|(
name|domain
operator|.
name|width
argument_list|()
operator|-
operator|(
name|leftOffset
operator|+
name|rightOffset
operator|)
operator|)
operator|/
name|ncols
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
operator|++
name|col
control|)
block|{
specifier|const
name|int
name|x
init|=
name|leftOffset
operator|+
name|row
operator|*
name|dx
operator|+
name|col
operator|*
name|dcol
decl_stmt|;
specifier|const
name|int
name|y
init|=
name|topOffset
operator|+
name|row
operator|*
name|dy
decl_stmt|;
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|widgets
argument_list|,
name|i
argument_list|,
literal|"SimpleCascader"
argument_list|)
condition|)
continue|continue;
name|QWidget
modifier|*
name|widget
init|=
name|widgets
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|QRect
name|newGeometry
init|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|widget
operator|->
name|sizeHint
argument_list|()
argument_list|)
decl_stmt|;
name|widget
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|widget
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|domain
argument_list|,
name|newGeometry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
condition|)
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rearrange
name|void
name|IconTiler
operator|::
name|rearrange
parameter_list|(
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
modifier|&
name|widgets
parameter_list|,
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|widgets
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|sanityCheck
argument_list|(
name|widgets
argument_list|,
literal|0
argument_list|,
literal|"IconTiler"
argument_list|)
condition|)
return|return;
specifier|const
name|int
name|n
init|=
name|widgets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|widgets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|ncols
init|=
name|qMax
argument_list|(
name|domain
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|nrows
init|=
name|n
operator|/
name|ncols
operator|+
operator|(
operator|(
name|n
operator|%
name|ncols
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
operator|++
name|col
control|)
block|{
specifier|const
name|int
name|x
init|=
name|col
operator|*
name|width
decl_stmt|;
specifier|const
name|int
name|y
init|=
name|domain
operator|.
name|height
argument_list|()
operator|-
name|height
operator|-
name|row
operator|*
name|height
decl_stmt|;
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|widgets
argument_list|,
name|i
argument_list|,
literal|"IconTiler"
argument_list|)
condition|)
continue|continue;
name|QWidget
modifier|*
name|widget
init|=
name|widgets
operator|.
name|at
argument_list|(
name|i
operator|++
argument_list|)
decl_stmt|;
name|QPoint
name|newPos
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|QRect
name|newGeometry
init|=
name|QRect
argument_list|(
name|newPos
operator|.
name|x
argument_list|()
argument_list|,
name|newPos
operator|.
name|y
argument_list|()
argument_list|,
name|widget
operator|->
name|width
argument_list|()
argument_list|,
name|widget
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|widget
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|widget
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|domain
argument_list|,
name|newGeometry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
condition|)
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Calculates the accumulated overlap (intersection area) between 'source' and 'rects'. */
end_comment
begin_function
DECL|function|accumulatedOverlap
name|int
name|MinOverlapPlacer
operator|::
name|accumulatedOverlap
parameter_list|(
specifier|const
name|QRect
modifier|&
name|source
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
parameter_list|)
block|{
name|int
name|accOverlap
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|rects
control|)
block|{
name|QRect
name|intersection
init|=
name|source
operator|.
name|intersected
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|accOverlap
operator|+=
name|intersection
operator|.
name|width
argument_list|()
operator|*
name|intersection
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
return|return
name|accOverlap
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Finds among 'source' the rectangle with the minimum accumulated overlap with the     rectangles in 'rects'. */
end_comment
begin_function
DECL|function|findMinOverlapRect
name|QRect
name|MinOverlapPlacer
operator|::
name|findMinOverlapRect
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|source
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
parameter_list|)
block|{
name|int
name|minAccOverlap
init|=
operator|-
literal|1
decl_stmt|;
name|QRect
name|minAccOverlapRect
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|srcRect
decl|,
name|source
control|)
block|{
specifier|const
name|int
name|accOverlap
init|=
name|accumulatedOverlap
argument_list|(
name|srcRect
argument_list|,
name|rects
argument_list|)
decl_stmt|;
if|if
condition|(
name|accOverlap
operator|<
name|minAccOverlap
operator|||
name|minAccOverlap
operator|==
operator|-
literal|1
condition|)
block|{
name|minAccOverlap
operator|=
name|accOverlap
expr_stmt|;
name|minAccOverlapRect
operator|=
name|srcRect
expr_stmt|;
block|}
block|}
return|return
name|minAccOverlapRect
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Gets candidates for the final placement. */
end_comment
begin_function
DECL|function|getCandidatePlacements
name|void
name|MinOverlapPlacer
operator|::
name|getCandidatePlacements
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
parameter_list|,
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|,
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|candidates
parameter_list|)
block|{
name|QSet
argument_list|<
name|int
argument_list|>
name|xset
decl_stmt|;
name|QSet
argument_list|<
name|int
argument_list|>
name|yset
decl_stmt|;
name|xset
operator|<<
name|domain
operator|.
name|left
argument_list|()
operator|<<
name|domain
operator|.
name|right
argument_list|()
operator|-
name|size
operator|.
name|width
argument_list|()
operator|+
literal|1
expr_stmt|;
name|yset
operator|<<
name|domain
operator|.
name|top
argument_list|()
expr_stmt|;
if|if
condition|(
name|domain
operator|.
name|bottom
argument_list|()
operator|-
name|size
operator|.
name|height
argument_list|()
operator|+
literal|1
operator|>=
literal|0
condition|)
name|yset
operator|<<
name|domain
operator|.
name|bottom
argument_list|()
operator|-
name|size
operator|.
name|height
argument_list|()
operator|+
literal|1
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|rects
control|)
block|{
name|xset
operator|<<
name|rect
operator|.
name|right
argument_list|()
operator|+
literal|1
expr_stmt|;
name|yset
operator|<<
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
name|QList
argument_list|<
name|int
argument_list|>
name|xlist
init|=
name|xset
operator|.
name|values
argument_list|()
decl_stmt|;
name|qSort
argument_list|(
name|xlist
operator|.
name|begin
argument_list|()
argument_list|,
name|xlist
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|ylist
init|=
name|yset
operator|.
name|values
argument_list|()
decl_stmt|;
name|qSort
argument_list|(
name|ylist
operator|.
name|begin
argument_list|()
argument_list|,
name|ylist
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|int
name|y
decl|,
name|ylist
control|)
foreach|foreach
control|(
name|int
name|x
decl|,
name|xlist
control|)
name|candidates
operator|<<
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Finds all rectangles in 'source' not completely inside 'domain'. The result is stored     in 'result' and also removed from 'source'. */
end_comment
begin_function
DECL|function|findNonInsiders
name|void
name|MinOverlapPlacer
operator|::
name|findNonInsiders
parameter_list|(
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|,
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|source
parameter_list|,
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|result
parameter_list|)
block|{
name|QMutableListIterator
argument_list|<
name|QRect
argument_list|>
name|it
argument_list|(
name|source
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
specifier|const
name|QRect
name|srcRect
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|domain
operator|.
name|contains
argument_list|(
name|srcRect
argument_list|)
condition|)
block|{
name|result
operator|<<
name|srcRect
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!    \internal     Finds all rectangles in 'source' that overlaps 'domain' by the maximum overlap area     between 'domain' and any rectangle in 'source'. The result is stored in 'result'. */
end_comment
begin_function
DECL|function|findMaxOverlappers
name|void
name|MinOverlapPlacer
operator|::
name|findMaxOverlappers
parameter_list|(
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|source
parameter_list|,
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|result
parameter_list|)
block|{
name|int
name|maxOverlap
init|=
operator|-
literal|1
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|srcRect
decl|,
name|source
control|)
block|{
name|QRect
name|intersection
init|=
name|domain
operator|.
name|intersected
argument_list|(
name|srcRect
argument_list|)
decl_stmt|;
specifier|const
name|int
name|overlap
init|=
name|intersection
operator|.
name|width
argument_list|()
operator|*
name|intersection
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|overlap
operator|>=
name|maxOverlap
operator|||
name|maxOverlap
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|overlap
operator|>
name|maxOverlap
condition|)
block|{
name|maxOverlap
operator|=
name|overlap
expr_stmt|;
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|result
operator|<<
name|srcRect
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!    \internal     Finds among the rectangles in 'source' the best placement. Here, 'best' means the     placement that overlaps the rectangles in 'rects' as little as possible while at the     same time being as much as possible inside 'domain'. */
end_comment
begin_function
DECL|function|findBestPlacement
name|QPoint
name|MinOverlapPlacer
operator|::
name|findBestPlacement
parameter_list|(
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
parameter_list|,
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|source
parameter_list|)
block|{
name|QList
argument_list|<
name|QRect
argument_list|>
name|nonInsiders
decl_stmt|;
name|findNonInsiders
argument_list|(
name|domain
argument_list|,
name|source
argument_list|,
name|nonInsiders
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|empty
argument_list|()
condition|)
return|return
name|findMinOverlapRect
argument_list|(
name|source
argument_list|,
name|rects
argument_list|)
operator|.
name|topLeft
argument_list|()
return|;
name|QList
argument_list|<
name|QRect
argument_list|>
name|maxOverlappers
decl_stmt|;
name|findMaxOverlappers
argument_list|(
name|domain
argument_list|,
name|nonInsiders
argument_list|,
name|maxOverlappers
argument_list|)
expr_stmt|;
return|return
name|findMinOverlapRect
argument_list|(
name|maxOverlappers
argument_list|,
name|rects
argument_list|)
operator|.
name|topLeft
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Places the rectangle defined by 'size' relative to 'rects' and 'domain' so that it     overlaps 'rects' as little as possible and 'domain' as much as possible.     Returns the position of the resulting rectangle. */
end_comment
begin_function
DECL|function|place
name|QPoint
name|MinOverlapPlacer
operator|::
name|place
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
parameter_list|,
specifier|const
name|QRect
modifier|&
name|domain
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|size
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|domain
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QPoint
argument_list|()
return|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|rects
control|)
block|{
if|if
condition|(
operator|!
name|rect
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QPoint
argument_list|()
return|;
block|}
name|QList
argument_list|<
name|QRect
argument_list|>
name|candidates
decl_stmt|;
name|getCandidatePlacements
argument_list|(
name|size
argument_list|,
name|rects
argument_list|,
name|domain
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
return|return
name|findBestPlacement
argument_list|(
name|domain
argument_list|,
name|rects
argument_list|,
name|candidates
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
end_ifndef
begin_class
DECL|class|QMdiAreaTabBar
class|class
name|QMdiAreaTabBar
super|:
specifier|public
name|QTabBar
block|{
public|public:
DECL|function|QMdiAreaTabBar
name|QMdiAreaTabBar
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QTabBar
argument_list|(
name|parent
argument_list|)
block|{}
protected|protected:
name|void
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
name|void
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
function_decl|;
endif|#
directive|endif
private|private:
name|QMdiSubWindow
modifier|*
name|subWindowFromIndex
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QMdiAreaTabBar
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|button
argument_list|()
operator|!=
name|Qt
operator|::
name|MidButton
condition|)
block|{
name|QTabBar
operator|::
name|mousePressEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|QMdiSubWindow
modifier|*
name|subWindow
init|=
name|subWindowFromIndex
argument_list|(
name|tabAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subWindow
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|subWindow
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QMdiAreaTabBar
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|QPointer
argument_list|<
name|QMdiSubWindow
argument_list|>
name|subWindow
init|=
name|subWindowFromIndex
argument_list|(
name|tabAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subWindow
operator|||
name|subWindow
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_MENU
name|QMdiSubWindowPrivate
modifier|*
name|subWindowPrivate
init|=
name|subWindow
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|subWindowPrivate
operator|->
name|systemMenu
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|QMdiSubWindow
modifier|*
name|currentSubWindow
init|=
name|subWindowFromIndex
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|currentSubWindow
argument_list|)
expr_stmt|;
comment|// We don't want these actions to show up in the system menu when the
comment|// current sub-window is maximized, i.e. covers the entire viewport.
if|if
condition|(
name|currentSubWindow
operator|->
name|isMaximized
argument_list|()
condition|)
block|{
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|MoveAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|ResizeAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|MinimizeAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|MaximizeAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|RestoreAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|subWindowPrivate
operator|->
name|setVisible
argument_list|(
name|QMdiSubWindowPrivate
operator|::
name|StayOnTopAction
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Show system menu.
name|subWindowPrivate
operator|->
name|systemMenu
operator|->
name|exec
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subWindow
condition|)
return|return;
comment|// Restore action visibility.
name|subWindowPrivate
operator|->
name|updateActions
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_MENU
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|subWindowFromIndex
name|QMdiSubWindow
modifier|*
name|QMdiAreaTabBar
operator|::
name|subWindowFromIndex
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|count
argument_list|()
condition|)
return|return
literal|0
return|;
name|QMdiArea
modifier|*
name|mdiArea
init|=
name|qobject_cast
argument_list|<
name|QMdiArea
operator|*
argument_list|>
argument_list|(
name|parentWidget
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|mdiArea
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
name|subWindows
init|=
name|mdiArea
operator|->
name|subWindowList
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|subWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|subWindow
init|=
name|mdiArea
operator|->
name|subWindowList
argument_list|()
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|subWindow
argument_list|)
expr_stmt|;
return|return
name|subWindow
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABBAR
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QMdiAreaPrivate
name|QMdiAreaPrivate
operator|::
name|QMdiAreaPrivate
parameter_list|()
member_init_list|:
name|cascader
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|regularTiler
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iconTiler
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|placer
argument_list|(
literal|0
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
name|rubberBand
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
name|tabBar
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
name|activationOrder
argument_list|(
name|QMdiArea
operator|::
name|CreationOrder
argument_list|)
member_init_list|,
name|viewMode
argument_list|(
name|QMdiArea
operator|::
name|SubWindowView
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
name|documentMode
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|tabsClosable
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|tabsMovable
argument_list|(
literal|false
argument_list|)
member_init_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
name|tabShape
argument_list|(
name|QTabWidget
operator|::
name|Rounded
argument_list|)
member_init_list|,
name|tabPosition
argument_list|(
name|QTabWidget
operator|::
name|North
argument_list|)
member_init_list|,
endif|#
directive|endif
name|ignoreGeometryChange
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|ignoreWindowStateChange
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isActivated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isSubWindowsTiled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|showActiveWindowMaximized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|tileCalledFromResizeEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|updatesDisabledByUs
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inViewModeChange
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|indexToNextWindow
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|indexToPreviousWindow
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|indexToHighlighted
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|indexToLastActiveTab
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|resizeTimerId
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|tabToPreviousTimerId
argument_list|(
operator|-
literal|1
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_deactivateAllWindows
name|void
name|QMdiAreaPrivate
operator|::
name|_q_deactivateAllWindows
parameter_list|(
name|QMdiSubWindow
modifier|*
name|aboutToActivate
parameter_list|)
block|{
if|if
condition|(
name|ignoreWindowStateChange
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aboutToActivate
condition|)
name|aboutToBecomeActive
operator|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|aboutToBecomeActive
operator|=
name|aboutToActivate
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|aboutToBecomeActive
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::deactivateAllWindows"
argument_list|)
operator|||
name|aboutToBecomeActive
operator|==
name|child
condition|)
continue|continue;
comment|// We don't want to handle signals caused by child->showNormal().
name|ignoreWindowStateChange
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|QMdiArea
operator|::
name|DontMaximizeSubWindowOnActivation
operator|)
operator|&&
operator|!
name|showActiveWindowMaximized
condition|)
name|showActiveWindowMaximized
operator|=
name|child
operator|->
name|isMaximized
argument_list|()
operator|&&
name|child
operator|->
name|isVisible
argument_list|()
expr_stmt|;
if|if
condition|(
name|showActiveWindowMaximized
operator|&&
name|child
operator|->
name|isMaximized
argument_list|()
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|updatesEnabled
argument_list|()
condition|)
block|{
name|updatesDisabledByUs
operator|=
literal|true
expr_stmt|;
name|q
operator|->
name|setUpdatesEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|child
operator|->
name|showNormal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|->
name|isMinimized
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isShaded
argument_list|()
operator|&&
operator|!
name|windowStaysOnTop
argument_list|(
name|child
argument_list|)
condition|)
name|child
operator|->
name|lower
argument_list|()
expr_stmt|;
name|ignoreWindowStateChange
operator|=
literal|false
expr_stmt|;
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_processWindowStateChanged
name|void
name|QMdiAreaPrivate
operator|::
name|_q_processWindowStateChanged
parameter_list|(
name|Qt
operator|::
name|WindowStates
name|oldState
parameter_list|,
name|Qt
operator|::
name|WindowStates
name|newState
parameter_list|)
block|{
if|if
condition|(
name|ignoreWindowStateChange
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
condition|)
return|return;
comment|// windowActivated
if|if
condition|(
operator|!
operator|(
name|oldState
operator|&
name|Qt
operator|::
name|WindowActive
operator|)
operator|&&
operator|(
name|newState
operator|&
name|Qt
operator|::
name|WindowActive
operator|)
condition|)
name|emitWindowActivated
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// windowDeactivated
elseif|else
if|if
condition|(
operator|(
name|oldState
operator|&
name|Qt
operator|::
name|WindowActive
operator|)
operator|&&
operator|!
operator|(
name|newState
operator|&
name|Qt
operator|::
name|WindowActive
operator|)
condition|)
name|resetActiveWindow
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// windowMinimized
if|if
condition|(
operator|!
operator|(
name|oldState
operator|&
name|Qt
operator|::
name|WindowMinimized
operator|)
operator|&&
operator|(
name|newState
operator|&
name|Qt
operator|::
name|WindowMinimized
operator|)
condition|)
block|{
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
comment|// windowMaximized
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|oldState
operator|&
name|Qt
operator|::
name|WindowMaximized
operator|)
operator|&&
operator|(
name|newState
operator|&
name|Qt
operator|::
name|WindowMaximized
operator|)
condition|)
block|{
name|internalRaise
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// windowRestored
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|newState
operator|&
operator|(
name|Qt
operator|::
name|WindowMaximized
operator||
name|Qt
operator|::
name|WindowMinimized
operator|)
operator|)
condition|)
block|{
name|internalRaise
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldState
operator|&
name|Qt
operator|::
name|WindowMinimized
condition|)
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_currentTabChanged
name|void
name|QMdiAreaPrivate
operator|::
name|_q_currentTabChanged
parameter_list|(
name|int
name|index
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TABBAR
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|tabBar
operator|||
name|index
operator|<
literal|0
condition|)
return|return;
comment|// If the previous active sub-window was hidden, disable the tab.
if|if
condition|(
name|indexToLastActiveTab
operator|>=
literal|0
operator|&&
name|indexToLastActiveTab
operator|<
name|tabBar
operator|->
name|count
argument_list|()
operator|&&
name|indexToLastActiveTab
operator|<
name|childWindows
operator|.
name|count
argument_list|()
condition|)
block|{
name|QMdiSubWindow
modifier|*
name|lastActive
init|=
name|childWindows
operator|.
name|at
argument_list|(
name|indexToLastActiveTab
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastActive
operator|&&
name|lastActive
operator|->
name|isHidden
argument_list|()
condition|)
name|tabBar
operator|->
name|setTabEnabled
argument_list|(
name|indexToLastActiveTab
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|indexToLastActiveTab
operator|=
name|index
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|childWindows
operator|.
name|size
argument_list|()
operator|>
name|index
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|subWindow
init|=
name|childWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|subWindow
argument_list|)
expr_stmt|;
name|activateWindow
argument_list|(
name|subWindow
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TABBAR
block|}
end_function
begin_function
DECL|function|_q_closeTab
name|void
name|QMdiAreaPrivate
operator|::
name|_q_closeTab
parameter_list|(
name|int
name|index
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TABBAR
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|QMdiSubWindow
modifier|*
name|subWindow
init|=
name|childWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|subWindow
argument_list|)
expr_stmt|;
name|subWindow
operator|->
name|close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TABBAR
block|}
end_function
begin_function
DECL|function|_q_moveTab
name|void
name|QMdiAreaPrivate
operator|::
name|_q_moveTab
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TABBAR
name|Q_UNUSED
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
name|childWindows
operator|.
name|move
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TABBAR
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|appendChild
name|void
name|QMdiAreaPrivate
operator|::
name|appendChild
parameter_list|(
name|QMdiSubWindow
modifier|*
name|child
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|child
operator|&&
name|childWindows
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|parent
argument_list|()
operator|!=
name|viewport
condition|)
name|child
operator|->
name|setParent
argument_list|(
name|viewport
argument_list|,
name|child
operator|->
name|windowFlags
argument_list|()
argument_list|)
expr_stmt|;
name|childWindows
operator|.
name|append
argument_list|(
name|QPointer
argument_list|<
name|QMdiSubWindow
argument_list|>
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
operator|&&
name|q
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|QSize
name|newSize
argument_list|(
name|child
operator|->
name|sizeHint
argument_list|()
operator|.
name|boundedTo
argument_list|(
name|viewport
operator|->
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|child
operator|->
name|resize
argument_list|(
name|newSize
operator|.
name|expandedTo
argument_list|(
name|qSmartMinSize
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|placer
condition|)
name|placer
operator|=
operator|new
name|MinOverlapPlacer
expr_stmt|;
name|place
argument_list|(
name|placer
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
condition|)
name|child
operator|->
name|setOption
argument_list|(
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaHorizontally
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|setOption
argument_list|(
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaHorizontally
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
condition|)
name|child
operator|->
name|setOption
argument_list|(
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaVertically
argument_list|,
literal|true
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|setOption
argument_list|(
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaVertically
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|internalRaise
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|indicesToActivatedChildren
operator|.
name|prepend
argument_list|(
name|childWindows
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|indicesToActivatedChildren
operator|.
name|size
argument_list|()
operator|==
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
if|if
condition|(
name|tabBar
condition|)
block|{
name|tabBar
operator|->
name|addTab
argument_list|(
name|child
operator|->
name|windowIcon
argument_list|()
argument_list|,
name|tabTextFor
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|childWindows
operator|.
name|count
argument_list|()
operator|==
literal|1
operator|&&
operator|!
operator|(
name|options
operator|&
name|QMdiArea
operator|::
name|DontMaximizeSubWindowOnActivation
operator|)
condition|)
name|showActiveWindowMaximized
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|child
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|SubWindow
operator|)
condition|)
name|child
operator|->
name|setWindowFlags
argument_list|(
name|Qt
operator|::
name|SubWindow
argument_list|)
expr_stmt|;
name|child
operator|->
name|installEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|child
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToActivate
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_deactivateAllWindows
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|child
argument_list|,
name|SIGNAL
argument_list|(
name|windowStateChanged
argument_list|(
name|Qt
operator|::
name|WindowStates
argument_list|,
name|Qt
operator|::
name|WindowStates
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_processWindowStateChanged
argument_list|(
name|Qt
operator|::
name|WindowStates
argument_list|,
name|Qt
operator|::
name|WindowStates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|place
name|void
name|QMdiAreaPrivate
operator|::
name|place
parameter_list|(
name|Placer
modifier|*
name|placer
parameter_list|,
name|QMdiSubWindow
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
operator|!
name|placer
operator|||
operator|!
name|child
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isVisible
argument_list|()
condition|)
block|{
comment|// The window is only laid out when it's added to QMdiArea,
comment|// so there's no need to check that we don't have it in the
comment|// list already. appendChild() ensures that.
name|pendingPlacements
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return;
block|}
name|QList
argument_list|<
name|QRect
argument_list|>
name|rects
decl_stmt|;
name|QRect
name|parentRect
init|=
name|q
operator|->
name|rect
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|window
decl|,
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|window
argument_list|,
literal|"QMdiArea::place"
argument_list|)
operator|||
name|window
operator|==
name|child
operator|||
operator|!
name|window
operator|->
name|isVisibleTo
argument_list|(
name|q
argument_list|)
operator|||
operator|!
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|QRect
name|occupiedGeometry
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|isMaximized
argument_list|()
condition|)
block|{
name|occupiedGeometry
operator|=
name|QRect
argument_list|(
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|oldGeometry
operator|.
name|topLeft
argument_list|()
argument_list|,
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|restoreSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|occupiedGeometry
operator|=
name|window
operator|->
name|geometry
argument_list|()
expr_stmt|;
block|}
name|rects
operator|.
name|append
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|child
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|parentRect
argument_list|,
name|occupiedGeometry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QPoint
name|newPos
init|=
name|placer
operator|->
name|place
argument_list|(
name|child
operator|->
name|size
argument_list|()
argument_list|,
name|rects
argument_list|,
name|parentRect
argument_list|)
decl_stmt|;
name|QRect
name|newGeometry
init|=
name|QRect
argument_list|(
name|newPos
operator|.
name|x
argument_list|()
argument_list|,
name|newPos
operator|.
name|y
argument_list|()
argument_list|,
name|child
operator|->
name|width
argument_list|()
argument_list|,
name|child
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|child
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|child
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|parentRect
argument_list|,
name|newGeometry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rearrange
name|void
name|QMdiAreaPrivate
operator|::
name|rearrange
parameter_list|(
name|Rearranger
modifier|*
name|rearranger
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rearranger
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|isVisible
argument_list|()
condition|)
block|{
comment|// Compress if we already have the rearranger in the list.
name|int
name|index
init|=
name|pendingRearrangements
operator|.
name|indexOf
argument_list|(
name|rearranger
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|pendingRearrangements
operator|.
name|move
argument_list|(
name|index
argument_list|,
name|pendingRearrangements
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|pendingRearrangements
operator|.
name|append
argument_list|(
name|rearranger
argument_list|)
expr_stmt|;
return|return;
block|}
name|QList
argument_list|<
name|QWidget
modifier|*
argument_list|>
name|widgets
decl_stmt|;
specifier|const
name|bool
name|reverseList
init|=
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|RegularTiler
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
name|subWindows
init|=
name|subWindowList
argument_list|(
name|activationOrder
argument_list|,
name|reverseList
argument_list|)
decl_stmt|;
name|QSize
name|minSubWindowSize
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|subWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::rearrange"
argument_list|)
operator|||
operator|!
name|child
operator|->
name|isVisible
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|IconTiler
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|isMinimized
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isShaded
argument_list|()
operator|&&
operator|!
operator|(
name|child
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|FramelessWindowHint
operator|)
condition|)
name|widgets
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|child
operator|->
name|isMinimized
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isShaded
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|isMaximized
argument_list|()
operator|||
name|child
operator|->
name|isShaded
argument_list|()
condition|)
name|child
operator|->
name|showNormal
argument_list|()
expr_stmt|;
name|minSubWindowSize
operator|=
name|minSubWindowSize
operator|.
name|expandedTo
argument_list|(
name|child
operator|->
name|minimumSize
argument_list|()
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|internalMinimumSize
argument_list|)
expr_stmt|;
name|widgets
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|active
operator|&&
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|RegularTiler
condition|)
block|{
comment|// Move active window in front if necessary. That's the case if we
comment|// have any windows with staysOnTopHint set.
name|int
name|indexToActive
init|=
name|widgets
operator|.
name|indexOf
argument_list|(
operator|(
name|QWidget
operator|*
operator|)
name|active
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexToActive
operator|>
literal|0
condition|)
name|widgets
operator|.
name|move
argument_list|(
name|indexToActive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|QRect
name|domain
init|=
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
if|if
condition|(
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|RegularTiler
operator|&&
operator|!
name|widgets
operator|.
name|isEmpty
argument_list|()
condition|)
name|domain
operator|=
name|resizeToMinimumTileSize
argument_list|(
name|minSubWindowSize
argument_list|,
name|widgets
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|rearranger
operator|->
name|rearrange
argument_list|(
name|widgets
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|RegularTiler
operator|&&
operator|!
name|widgets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|isSubWindowsTiled
operator|=
literal|true
expr_stmt|;
name|updateScrollBars
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rearranger
operator|->
name|type
argument_list|()
operator|==
name|Rearranger
operator|::
name|SimpleCascader
condition|)
block|{
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Arranges all minimized windows at the bottom of the workspace. */
end_comment
begin_function
DECL|function|arrangeMinimizedSubWindows
name|void
name|QMdiAreaPrivate
operator|::
name|arrangeMinimizedSubWindows
parameter_list|()
block|{
if|if
condition|(
operator|!
name|iconTiler
condition|)
name|iconTiler
operator|=
operator|new
name|IconTiler
expr_stmt|;
name|rearrange
argument_list|(
name|iconTiler
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|activateWindow
name|void
name|QMdiAreaPrivate
operator|::
name|activateWindow
parameter_list|(
name|QMdiSubWindow
modifier|*
name|child
parameter_list|)
block|{
if|if
condition|(
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|child
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|active
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|child
condition|)
block|{
if|if
condition|(
name|active
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|active
operator|->
name|d_func
argument_list|()
operator|->
name|isActive
argument_list|)
expr_stmt|;
name|active
operator|->
name|d_func
argument_list|()
operator|->
name|setActive
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|resetActiveWindow
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|child
operator|->
name|isHidden
argument_list|()
operator|||
name|child
operator|==
name|active
condition|)
return|return;
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|activateCurrentWindow
name|void
name|QMdiAreaPrivate
operator|::
name|activateCurrentWindow
parameter_list|()
block|{
name|QMdiSubWindow
modifier|*
name|current
init|=
name|q_func
argument_list|()
operator|->
name|currentSubWindow
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|&&
operator|!
name|isExplicitlyDeactivated
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|activationEnabled
operator|=
literal|true
expr_stmt|;
name|current
operator|->
name|d_func
argument_list|()
operator|->
name|setActive
argument_list|(
literal|true
argument_list|,
comment|/*changeFocus=*/
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|activateHighlightedWindow
name|void
name|QMdiAreaPrivate
operator|::
name|activateHighlightedWindow
parameter_list|()
block|{
if|if
condition|(
name|indexToHighlighted
operator|<
literal|0
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|indexToHighlighted
operator|<
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabToPreviousTimerId
operator|!=
operator|-
literal|1
condition|)
name|activateWindow
argument_list|(
name|nextVisibleSubWindow
argument_list|(
operator|-
literal|1
argument_list|,
name|QMdiArea
operator|::
name|ActivationHistoryOrder
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|activateWindow
argument_list|(
name|childWindows
operator|.
name|at
argument_list|(
name|indexToHighlighted
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
name|hideRubberBand
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|emitWindowActivated
name|void
name|QMdiAreaPrivate
operator|::
name|emitWindowActivated
parameter_list|(
name|QMdiSubWindow
modifier|*
name|activeWindow
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|activeWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeWindow
operator|==
name|active
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|activeWindow
operator|->
name|d_func
argument_list|()
operator|->
name|isActive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aboutToBecomeActive
condition|)
name|_q_deactivateAllWindows
argument_list|(
name|activeWindow
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|aboutToBecomeActive
argument_list|)
expr_stmt|;
comment|// This is true only if 'DontMaximizeSubWindowOnActivation' is disabled
comment|// and the previous active window was maximized.
if|if
condition|(
name|showActiveWindowMaximized
condition|)
block|{
if|if
condition|(
operator|!
name|activeWindow
operator|->
name|isMaximized
argument_list|()
condition|)
name|activeWindow
operator|->
name|showMaximized
argument_list|()
expr_stmt|;
name|showActiveWindowMaximized
operator|=
literal|false
expr_stmt|;
block|}
comment|// Put in front to update activation order.
specifier|const
name|int
name|indexToActiveWindow
init|=
name|childWindows
operator|.
name|indexOf
argument_list|(
name|activeWindow
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|indexToActiveWindow
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|index
init|=
name|indicesToActivatedChildren
operator|.
name|indexOf
argument_list|(
name|indexToActiveWindow
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|indicesToActivatedChildren
operator|.
name|move
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|internalRaise
argument_list|(
name|activeWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|updatesDisabledByUs
condition|)
block|{
name|q
operator|->
name|setUpdatesEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|updatesDisabledByUs
operator|=
literal|false
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|aboutToBecomeActive
operator|==
name|activeWindow
argument_list|)
expr_stmt|;
name|active
operator|=
name|activeWindow
expr_stmt|;
name|aboutToBecomeActive
operator|=
literal|0
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|active
operator|->
name|d_func
argument_list|()
operator|->
name|isActive
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
if|if
condition|(
name|tabBar
operator|&&
name|tabBar
operator|->
name|currentIndex
argument_list|()
operator|!=
name|indexToActiveWindow
condition|)
name|tabBar
operator|->
name|setCurrentIndex
argument_list|(
name|indexToActiveWindow
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|active
operator|->
name|isMaximized
argument_list|()
operator|&&
name|scrollBarsEnabled
argument_list|()
condition|)
name|updateScrollBars
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|subWindowActivated
argument_list|(
name|active
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|resetActiveWindow
name|void
name|QMdiAreaPrivate
operator|::
name|resetActiveWindow
parameter_list|(
name|QMdiSubWindow
modifier|*
name|deactivatedWindow
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|deactivatedWindow
condition|)
block|{
if|if
condition|(
name|deactivatedWindow
operator|!=
name|active
condition|)
return|return;
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|aboutToBecomeActive
operator|||
name|isActivated
operator|||
name|lastWindowAboutToBeDestroyed
argument_list|()
operator|)
operator|&&
operator|!
name|isExplicitlyDeactivated
argument_list|(
name|deactivatedWindow
argument_list|)
operator|&&
operator|!
name|q
operator|->
name|window
argument_list|()
operator|->
name|isMinimized
argument_list|()
condition|)
block|{
return|return;
block|}
emit|emit
name|q
operator|->
name|subWindowActivated
argument_list|(
literal|0
argument_list|)
emit|;
return|return;
block|}
if|if
condition|(
name|aboutToBecomeActive
condition|)
return|return;
name|active
operator|=
literal|0
expr_stmt|;
emit|emit
name|q
operator|->
name|subWindowActivated
argument_list|(
literal|0
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateActiveWindow
name|void
name|QMdiAreaPrivate
operator|::
name|updateActiveWindow
parameter_list|(
name|int
name|removedIndex
parameter_list|,
name|bool
name|activeRemoved
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|indicesToActivatedChildren
operator|.
name|size
argument_list|()
operator|==
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
if|if
condition|(
name|tabBar
operator|&&
name|removedIndex
operator|>=
literal|0
condition|)
block|{
name|tabBar
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|removeTab
argument_list|(
name|removedIndex
argument_list|)
expr_stmt|;
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
name|tabBar
operator|->
name|blockSignals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|showActiveWindowMaximized
operator|=
literal|false
expr_stmt|;
name|resetActiveWindow
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|indexToHighlighted
operator|>=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
comment|// Hide rubber band if highlighted window is removed.
if|if
condition|(
name|indexToHighlighted
operator|==
name|removedIndex
condition|)
name|hideRubberBand
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|// or update index if necessary.
if|if
condition|(
name|indexToHighlighted
operator|>
name|removedIndex
condition|)
operator|--
name|indexToHighlighted
expr_stmt|;
block|}
comment|// Update indices list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indicesToActivatedChildren
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
modifier|*
name|index
init|=
operator|&
name|indicesToActivatedChildren
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|index
operator|>
name|removedIndex
condition|)
operator|--
operator|*
name|index
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|activeRemoved
condition|)
return|return;
comment|// Activate next window.
name|QMdiSubWindow
modifier|*
name|next
init|=
name|nextVisibleSubWindow
argument_list|(
literal|0
argument_list|,
name|activationOrder
argument_list|,
name|removedIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|activateWindow
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateScrollBars
name|void
name|QMdiAreaPrivate
operator|::
name|updateScrollBars
parameter_list|()
block|{
if|if
condition|(
name|ignoreGeometryChange
operator|||
operator|!
name|scrollBarsEnabled
argument_list|()
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|QSize
name|maxSize
init|=
name|q
operator|->
name|maximumViewportSize
argument_list|()
decl_stmt|;
name|QSize
name|hbarExtent
init|=
name|hbar
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
name|QSize
name|vbarExtent
init|=
name|vbar
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollView_FrameOnlyAroundContents
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
condition|)
block|{
specifier|const
name|int
name|doubleFrameWidth
init|=
name|frameWidth
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|maxSize
operator|.
name|rheight
argument_list|()
operator|-=
name|doubleFrameWidth
expr_stmt|;
if|if
condition|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|maxSize
operator|.
name|rwidth
argument_list|()
operator|-=
name|doubleFrameWidth
expr_stmt|;
name|hbarExtent
operator|.
name|rheight
argument_list|()
operator|+=
name|doubleFrameWidth
expr_stmt|;
name|vbarExtent
operator|.
name|rwidth
argument_list|()
operator|+=
name|doubleFrameWidth
expr_stmt|;
block|}
specifier|const
name|QRect
name|childrenRect
init|=
name|active
operator|&&
name|active
operator|->
name|isMaximized
argument_list|()
condition|?
name|active
operator|->
name|geometry
argument_list|()
else|:
name|viewport
operator|->
name|childrenRect
argument_list|()
decl_stmt|;
name|bool
name|useHorizontalScrollBar
init|=
name|useScrollBar
argument_list|(
name|childrenRect
argument_list|,
name|maxSize
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
decl_stmt|;
name|bool
name|useVerticalScrollBar
init|=
name|useScrollBar
argument_list|(
name|childrenRect
argument_list|,
name|maxSize
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
decl_stmt|;
if|if
condition|(
name|useHorizontalScrollBar
operator|&&
operator|!
name|useVerticalScrollBar
condition|)
block|{
specifier|const
name|QSize
name|max
init|=
name|maxSize
operator|-
name|QSize
argument_list|(
literal|0
argument_list|,
name|hbarExtent
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|useVerticalScrollBar
operator|=
name|useScrollBar
argument_list|(
name|childrenRect
argument_list|,
name|max
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useVerticalScrollBar
operator|&&
operator|!
name|useHorizontalScrollBar
condition|)
block|{
specifier|const
name|QSize
name|max
init|=
name|maxSize
operator|-
name|QSize
argument_list|(
name|vbarExtent
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|useHorizontalScrollBar
operator|=
name|useScrollBar
argument_list|(
name|childrenRect
argument_list|,
name|max
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useHorizontalScrollBar
operator|&&
name|hbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|maxSize
operator|.
name|rheight
argument_list|()
operator|-=
name|hbarExtent
operator|.
name|height
argument_list|()
expr_stmt|;
if|if
condition|(
name|useVerticalScrollBar
operator|&&
name|vbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|maxSize
operator|.
name|rwidth
argument_list|()
operator|-=
name|vbarExtent
operator|.
name|width
argument_list|()
expr_stmt|;
name|QRect
name|viewportRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
specifier|const
name|int
name|startX
init|=
name|q
operator|->
name|isLeftToRight
argument_list|()
condition|?
name|childrenRect
operator|.
name|left
argument_list|()
else|:
name|viewportRect
operator|.
name|right
argument_list|()
operator|-
name|childrenRect
operator|.
name|right
argument_list|()
decl_stmt|;
comment|// Horizontal scroll bar.
if|if
condition|(
name|isSubWindowsTiled
operator|&&
name|hbar
operator|->
name|value
argument_list|()
operator|!=
literal|0
condition|)
name|hbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|int
name|xOffset
init|=
name|startX
operator|+
name|hbar
operator|->
name|value
argument_list|()
decl_stmt|;
name|hbar
operator|->
name|setRange
argument_list|(
name|qMin
argument_list|(
literal|0
argument_list|,
name|xOffset
argument_list|)
argument_list|,
name|qMax
argument_list|(
literal|0
argument_list|,
name|xOffset
operator|+
name|childrenRect
operator|.
name|width
argument_list|()
operator|-
name|viewportRect
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setPageStep
argument_list|(
name|childrenRect
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setSingleStep
argument_list|(
name|childrenRect
operator|.
name|width
argument_list|()
operator|/
literal|20
argument_list|)
expr_stmt|;
comment|// Vertical scroll bar.
if|if
condition|(
name|isSubWindowsTiled
operator|&&
name|vbar
operator|->
name|value
argument_list|()
operator|!=
literal|0
condition|)
name|vbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|int
name|yOffset
init|=
name|childrenRect
operator|.
name|top
argument_list|()
operator|+
name|vbar
operator|->
name|value
argument_list|()
decl_stmt|;
name|vbar
operator|->
name|setRange
argument_list|(
name|qMin
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|)
argument_list|,
name|qMax
argument_list|(
literal|0
argument_list|,
name|yOffset
operator|+
name|childrenRect
operator|.
name|height
argument_list|()
operator|-
name|viewportRect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setPageStep
argument_list|(
name|childrenRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setSingleStep
argument_list|(
name|childrenRect
operator|.
name|height
argument_list|()
operator|/
literal|20
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|internalRaise
name|void
name|QMdiAreaPrivate
operator|::
name|internalRaise
parameter_list|(
name|QMdiSubWindow
modifier|*
name|mdiChild
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|mdiChild
argument_list|,
literal|"QMdiArea::internalRaise"
argument_list|)
operator|||
name|childWindows
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
return|return;
name|QMdiSubWindow
modifier|*
name|stackUnderChild
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|windowStaysOnTop
argument_list|(
name|mdiChild
argument_list|)
condition|)
block|{
foreach|foreach
control|(
name|QObject
modifier|*
name|object
decl|,
name|viewport
operator|->
name|children
argument_list|()
control|)
block|{
name|QMdiSubWindow
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
operator|!
name|childWindows
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|child
operator|->
name|isHidden
argument_list|()
operator|&&
name|windowStaysOnTop
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|stackUnderChild
condition|)
name|child
operator|->
name|stackUnder
argument_list|(
name|stackUnderChild
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|raise
argument_list|()
expr_stmt|;
name|stackUnderChild
operator|=
name|child
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stackUnderChild
condition|)
name|mdiChild
operator|->
name|stackUnder
argument_list|(
name|stackUnderChild
argument_list|)
expr_stmt|;
else|else
name|mdiChild
operator|->
name|raise
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resizeToMinimumTileSize
name|QRect
name|QMdiAreaPrivate
operator|::
name|resizeToMinimumTileSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|minSubWindowSize
parameter_list|,
name|int
name|subWindowCount
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minSubWindowSize
operator|.
name|isValid
argument_list|()
operator|||
name|subWindowCount
operator|<=
literal|0
condition|)
return|return
name|viewport
operator|->
name|rect
argument_list|()
return|;
comment|// Calculate minimum size.
specifier|const
name|int
name|columns
init|=
name|qMax
argument_list|(
name|qCeil
argument_list|(
name|qSqrt
argument_list|(
name|qreal
argument_list|(
name|subWindowCount
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|rows
init|=
name|qMax
argument_list|(
operator|(
name|subWindowCount
operator|%
name|columns
operator|)
condition|?
operator|(
name|subWindowCount
operator|/
name|columns
operator|+
literal|1
operator|)
else|:
operator|(
name|subWindowCount
operator|/
name|columns
operator|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|int
name|minWidth
init|=
name|minSubWindowSize
operator|.
name|width
argument_list|()
operator|*
name|columns
decl_stmt|;
specifier|const
name|int
name|minHeight
init|=
name|minSubWindowSize
operator|.
name|height
argument_list|()
operator|*
name|rows
decl_stmt|;
comment|// Increase area size if necessary. Scroll bars are provided if we're not able
comment|// to resize to the minimum size.
if|if
condition|(
operator|!
name|tileCalledFromResizeEvent
condition|)
block|{
name|QWidget
modifier|*
name|topLevel
init|=
name|q
decl_stmt|;
comment|// Find the topLevel for this area, either a real top-level or a sub-window.
while|while
condition|(
name|topLevel
operator|&&
operator|!
name|topLevel
operator|->
name|isWindow
argument_list|()
operator|&&
name|topLevel
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|SubWindow
condition|)
name|topLevel
operator|=
name|topLevel
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
comment|// We don't want sub-subwindows to be placed at the edge, thus add 2 pixels.
name|int
name|minAreaWidth
init|=
name|minWidth
operator|+
name|left
operator|+
name|right
operator|+
literal|2
decl_stmt|;
name|int
name|minAreaHeight
init|=
name|minHeight
operator|+
name|top
operator|+
name|bottom
operator|+
literal|2
decl_stmt|;
if|if
condition|(
name|hbar
operator|->
name|isVisible
argument_list|()
condition|)
name|minAreaHeight
operator|+=
name|hbar
operator|->
name|height
argument_list|()
expr_stmt|;
if|if
condition|(
name|vbar
operator|->
name|isVisible
argument_list|()
condition|)
name|minAreaWidth
operator|+=
name|vbar
operator|->
name|width
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollView_FrameOnlyAroundContents
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
condition|)
block|{
specifier|const
name|int
name|frame
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_DefaultFrameWidth
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|minAreaWidth
operator|+=
literal|2
operator|*
name|frame
expr_stmt|;
name|minAreaHeight
operator|+=
literal|2
operator|*
name|frame
expr_stmt|;
block|}
specifier|const
name|QSize
name|diff
init|=
name|QSize
argument_list|(
name|minAreaWidth
argument_list|,
name|minAreaHeight
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|q
operator|->
name|size
argument_list|()
argument_list|)
operator|-
name|q
operator|->
name|size
argument_list|()
decl_stmt|;
name|topLevel
operator|->
name|resize
argument_list|(
name|topLevel
operator|->
name|size
argument_list|()
operator|+
name|diff
argument_list|)
expr_stmt|;
block|}
name|QRect
name|domain
init|=
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
comment|// Adjust domain width and provide horizontal scroll bar.
if|if
condition|(
name|domain
operator|.
name|width
argument_list|()
operator|<
name|minWidth
condition|)
block|{
name|domain
operator|.
name|setWidth
argument_list|(
name|minWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOff
condition|)
name|q
operator|->
name|setHorizontalScrollBarPolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
expr_stmt|;
else|else
name|hbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Adjust domain height and provide vertical scroll bar.
if|if
condition|(
name|domain
operator|.
name|height
argument_list|()
operator|<
name|minHeight
condition|)
block|{
name|domain
operator|.
name|setHeight
argument_list|(
name|minHeight
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOff
condition|)
name|q
operator|->
name|setVerticalScrollBarPolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAsNeeded
argument_list|)
expr_stmt|;
else|else
name|vbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|domain
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|scrollBarsEnabled
name|bool
name|QMdiAreaPrivate
operator|::
name|scrollBarsEnabled
parameter_list|()
specifier|const
block|{
return|return
name|hbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
operator|||
name|vbarpolicy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|lastWindowAboutToBeDestroyed
name|bool
name|QMdiAreaPrivate
operator|::
name|lastWindowAboutToBeDestroyed
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|childWindows
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|QMdiSubWindow
modifier|*
name|last
init|=
name|childWindows
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|last
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|last
operator|->
name|d_func
argument_list|()
operator|->
name|data
operator|.
name|is_closing
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setChildActivationEnabled
name|void
name|QMdiAreaPrivate
operator|::
name|setChildActivationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|,
name|bool
name|onlyNextActivationEvent
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|subWindow
decl|,
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|subWindow
operator|||
operator|!
name|subWindow
operator|->
name|isVisible
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|onlyNextActivationEvent
condition|)
name|subWindow
operator|->
name|d_func
argument_list|()
operator|->
name|ignoreNextActivationEvent
operator|=
operator|!
name|enable
expr_stmt|;
else|else
name|subWindow
operator|->
name|d_func
argument_list|()
operator|->
name|activationEnabled
operator|=
name|enable
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     \reimp */
end_comment
begin_function
DECL|function|scrollBarPolicyChanged
name|void
name|QMdiAreaPrivate
operator|::
name|scrollBarPolicyChanged
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|Qt
operator|::
name|ScrollBarPolicy
name|policy
parameter_list|)
block|{
if|if
condition|(
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|QMdiSubWindow
operator|::
name|SubWindowOption
name|option
init|=
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaHorizontally
else|:
name|QMdiSubWindow
operator|::
name|AllowOutsideAreaVertically
decl_stmt|;
specifier|const
name|bool
name|enable
init|=
name|policy
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::scrollBarPolicyChanged"
argument_list|)
condition|)
continue|continue;
name|child
operator|->
name|setOption
argument_list|(
name|option
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
name|updateScrollBars
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
DECL|function|subWindowList
name|QMdiAreaPrivate
operator|::
name|subWindowList
parameter_list|(
name|QMdiArea
operator|::
name|WindowOrder
name|order
parameter_list|,
name|bool
name|reversed
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
name|list
decl_stmt|;
if|if
condition|(
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|list
return|;
if|if
condition|(
name|order
operator|==
name|QMdiArea
operator|::
name|CreationOrder
condition|)
block|{
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|child
condition|)
continue|continue;
if|if
condition|(
operator|!
name|reversed
condition|)
name|list
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
else|else
name|list
operator|.
name|prepend
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|order
operator|==
name|QMdiArea
operator|::
name|StackingOrder
condition|)
block|{
foreach|foreach
control|(
name|QObject
modifier|*
name|object
decl|,
name|viewport
operator|->
name|children
argument_list|()
control|)
block|{
name|QMdiSubWindow
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
operator|!
name|childWindows
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|reversed
condition|)
name|list
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
else|else
name|list
operator|.
name|prepend
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ActivationHistoryOrder
name|Q_ASSERT
argument_list|(
name|indicesToActivatedChildren
operator|.
name|size
argument_list|()
operator|==
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|indicesToActivatedChildren
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QMdiSubWindow
modifier|*
name|child
init|=
name|childWindows
operator|.
name|at
argument_list|(
name|indicesToActivatedChildren
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
condition|)
continue|continue;
if|if
condition|(
operator|!
name|reversed
condition|)
name|list
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
else|else
name|list
operator|.
name|prepend
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|disconnectSubWindow
name|void
name|QMdiAreaPrivate
operator|::
name|disconnectSubWindow
parameter_list|(
name|QObject
modifier|*
name|subWindow
parameter_list|)
block|{
if|if
condition|(
operator|!
name|subWindow
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|subWindow
argument_list|,
literal|0
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subWindow
operator|->
name|removeEventFilter
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|nextVisibleSubWindow
name|QMdiSubWindow
modifier|*
name|QMdiAreaPrivate
operator|::
name|nextVisibleSubWindow
parameter_list|(
name|int
name|increaseFactor
parameter_list|,
name|QMdiArea
operator|::
name|WindowOrder
name|order
parameter_list|,
name|int
name|removedIndex
parameter_list|,
name|int
name|fromIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_Q
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
specifier|const
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
name|subWindows
init|=
name|q
operator|->
name|subWindowList
argument_list|(
name|order
argument_list|)
decl_stmt|;
name|QMdiSubWindow
modifier|*
name|current
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|removedIndex
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fromIndex
operator|>=
literal|0
operator|&&
name|fromIndex
operator|<
name|subWindows
operator|.
name|size
argument_list|()
condition|)
name|current
operator|=
name|childWindows
operator|.
name|at
argument_list|(
name|fromIndex
argument_list|)
expr_stmt|;
else|else
name|current
operator|=
name|q
operator|->
name|currentSubWindow
argument_list|()
expr_stmt|;
block|}
comment|// There's no current sub-window (removed or deactivated),
comment|// so we have to pick the last active or the next in creation order.
if|if
condition|(
operator|!
name|current
condition|)
block|{
if|if
condition|(
name|removedIndex
operator|>=
literal|0
operator|&&
name|order
operator|==
name|QMdiArea
operator|::
name|CreationOrder
condition|)
block|{
name|int
name|candidateIndex
init|=
operator|-
literal|1
decl_stmt|;
name|setIndex
argument_list|(
operator|&
name|candidateIndex
argument_list|,
name|removedIndex
argument_list|,
literal|0
argument_list|,
name|subWindows
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|current
operator|=
name|childWindows
operator|.
name|at
argument_list|(
name|candidateIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|subWindows
operator|.
name|back
argument_list|()
expr_stmt|;
block|}
block|}
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|// Find the index for the current sub-window in the given activation order
specifier|const
name|int
name|indexToCurrent
init|=
name|subWindows
operator|.
name|indexOf
argument_list|(
name|current
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|increasing
init|=
name|increaseFactor
operator|>
literal|0
condition|?
literal|true
else|:
literal|false
decl_stmt|;
comment|// and use that index + increseFactor as a candidate.
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|setIndex
argument_list|(
operator|&
name|index
argument_list|,
name|indexToCurrent
operator|+
name|increaseFactor
argument_list|,
literal|0
argument_list|,
name|subWindows
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|increasing
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Try to find another window if the candidate is hidden.
while|while
condition|(
name|subWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|setIndex
argument_list|(
operator|&
name|index
argument_list|,
name|index
operator|+
name|increaseFactor
argument_list|,
literal|0
argument_list|,
name|subWindows
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|increasing
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|indexToCurrent
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|subWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|isHidden
argument_list|()
condition|)
return|return
name|subWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|highlightNextSubWindow
name|void
name|QMdiAreaPrivate
operator|::
name|highlightNextSubWindow
parameter_list|(
name|int
name|increaseFactor
parameter_list|)
block|{
if|if
condition|(
name|childWindows
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
comment|// There's no highlighted sub-window atm, use current.
if|if
condition|(
name|indexToHighlighted
operator|<
literal|0
condition|)
block|{
name|QMdiSubWindow
modifier|*
name|current
init|=
name|q
operator|->
name|currentSubWindow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
name|indexToHighlighted
operator|=
name|childWindows
operator|.
name|indexOf
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|indexToHighlighted
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|indexToHighlighted
operator|<
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|highlight
init|=
name|nextVisibleSubWindow
argument_list|(
name|increaseFactor
argument_list|,
name|activationOrder
argument_list|,
operator|-
literal|1
argument_list|,
name|indexToHighlighted
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|highlight
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
operator|!
name|rubberBand
condition|)
block|{
name|rubberBand
operator|=
operator|new
name|QRubberBand
argument_list|(
name|QRubberBand
operator|::
name|Rectangle
argument_list|,
name|viewport
argument_list|)
expr_stmt|;
comment|// For accessibility to identify this special widget.
name|rubberBand
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_rubberband"
argument_list|)
argument_list|)
expr_stmt|;
name|rubberBand
operator|->
name|setWindowFlags
argument_list|(
name|rubberBand
operator|->
name|windowFlags
argument_list|()
operator||
name|Qt
operator|::
name|WindowStaysOnTopHint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Only highlight if we're not switching back to the previously active window (Ctrl-Tab once).
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|tabToPreviousTimerId
operator|==
operator|-
literal|1
condition|)
name|showRubberBandFor
argument_list|(
name|highlight
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|indexToHighlighted
operator|=
name|childWindows
operator|.
name|indexOf
argument_list|(
name|highlight
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|indexToHighlighted
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.4 */
end_comment
begin_function
DECL|function|setViewMode
name|void
name|QMdiAreaPrivate
operator|::
name|setViewMode
parameter_list|(
name|QMdiArea
operator|::
name|ViewMode
name|mode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewMode
operator|==
name|mode
operator|||
name|inViewModeChange
condition|)
return|return;
comment|// Just a guard since we cannot set viewMode = mode here.
name|inViewModeChange
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
if|if
condition|(
name|mode
operator|==
name|QMdiArea
operator|::
name|TabbedView
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|tabBar
argument_list|)
expr_stmt|;
name|tabBar
operator|=
operator|new
name|QMdiAreaTabBar
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|setDocumentMode
argument_list|(
name|documentMode
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|setTabsClosable
argument_list|(
name|tabsClosable
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|setMovable
argument_list|(
name|tabsMovable
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
name|tabBar
operator|->
name|setShape
argument_list|(
name|tabBarShapeFrom
argument_list|(
name|tabShape
argument_list|,
name|tabPosition
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|subWindow
decl|,
name|childWindows
control|)
name|tabBar
operator|->
name|addTab
argument_list|(
name|subWindow
operator|->
name|windowIcon
argument_list|()
argument_list|,
name|tabTextFor
argument_list|(
name|subWindow
argument_list|)
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|current
init|=
name|q
operator|->
name|currentSubWindow
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
condition|)
block|{
name|tabBar
operator|->
name|setCurrentIndex
argument_list|(
name|childWindows
operator|.
name|indexOf
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
comment|// Restore sub-window (i.e. cleanup buttons in menu bar and window title).
if|if
condition|(
name|current
operator|->
name|isMaximized
argument_list|()
condition|)
name|current
operator|->
name|showNormal
argument_list|()
expr_stmt|;
name|viewMode
operator|=
name|mode
expr_stmt|;
comment|// Now, maximize it.
if|if
condition|(
operator|!
name|q
operator|->
name|testOption
argument_list|(
name|QMdiArea
operator|::
name|DontMaximizeSubWindowOnActivation
argument_list|)
condition|)
block|{
name|current
operator|->
name|showMaximized
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|viewMode
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|tabBar
operator|->
name|show
argument_list|()
expr_stmt|;
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|tabBar
argument_list|,
name|SIGNAL
argument_list|(
name|currentChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_currentTabChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|tabBar
argument_list|,
name|SIGNAL
argument_list|(
name|tabCloseRequested
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_closeTab
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|tabBar
argument_list|,
name|SIGNAL
argument_list|(
name|tabMoved
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_moveTab
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|// QT_NO_TABBAR
block|{
comment|// SubWindowView
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
operator|delete
name|tabBar
expr_stmt|;
name|tabBar
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TABBAR
name|viewMode
operator|=
name|mode
expr_stmt|;
name|q
operator|->
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indexToLastActiveTab
operator|=
operator|-
literal|1
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|current
init|=
name|q
operator|->
name|currentSubWindow
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|&&
name|current
operator|->
name|isMaximized
argument_list|()
condition|)
name|current
operator|->
name|showNormal
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|viewMode
operator|==
name|mode
argument_list|)
expr_stmt|;
name|inViewModeChange
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateTabBarGeometry
name|void
name|QMdiAreaPrivate
operator|::
name|updateTabBarGeometry
parameter_list|()
block|{
if|if
condition|(
operator|!
name|tabBar
condition|)
return|return;
name|Q_Q
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
name|Q_ASSERT
argument_list|(
name|tabBarShapeFrom
argument_list|(
name|tabShape
argument_list|,
name|tabPosition
argument_list|)
operator|==
name|tabBar
operator|->
name|shape
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QSize
name|tabBarSizeHint
init|=
name|tabBar
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
name|int
name|areaHeight
init|=
name|q
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|hbar
operator|&&
name|hbar
operator|->
name|isVisible
argument_list|()
condition|)
name|areaHeight
operator|-=
name|hbar
operator|->
name|height
argument_list|()
expr_stmt|;
name|int
name|areaWidth
init|=
name|q
operator|->
name|width
argument_list|()
decl_stmt|;
if|if
condition|(
name|vbar
operator|&&
name|vbar
operator|->
name|isVisible
argument_list|()
condition|)
name|areaWidth
operator|-=
name|vbar
operator|->
name|width
argument_list|()
expr_stmt|;
name|QRect
name|tabBarRect
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
switch|switch
condition|(
name|tabPosition
condition|)
block|{
case|case
name|QTabWidget
operator|::
name|North
case|:
name|q
operator|->
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tabBarRect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|areaWidth
argument_list|,
name|tabBarSizeHint
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabWidget
operator|::
name|South
case|:
name|q
operator|->
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|tabBarRect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
name|areaHeight
operator|-
name|tabBarSizeHint
operator|.
name|height
argument_list|()
argument_list|,
name|areaWidth
argument_list|,
name|tabBarSizeHint
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabWidget
operator|::
name|East
case|:
if|if
condition|(
name|q
operator|->
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|)
name|q
operator|->
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|setViewportMargins
argument_list|(
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tabBarRect
operator|=
name|QRect
argument_list|(
name|areaWidth
operator|-
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
name|areaHeight
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabWidget
operator|::
name|West
case|:
if|if
condition|(
name|q
operator|->
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|)
name|q
operator|->
name|setViewportMargins
argument_list|(
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tabBarRect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tabBarSizeHint
operator|.
name|width
argument_list|()
argument_list|,
name|areaHeight
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|// QT_NO_TABWIDGET
name|tabBar
operator|->
name|setGeometry
argument_list|(
name|QStyle
operator|::
name|visualRect
argument_list|(
name|q
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|q
operator|->
name|contentsRect
argument_list|()
argument_list|,
name|tabBarRect
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|refreshTabBar
name|void
name|QMdiAreaPrivate
operator|::
name|refreshTabBar
parameter_list|()
block|{
if|if
condition|(
operator|!
name|tabBar
condition|)
return|return;
name|tabBar
operator|->
name|setDocumentMode
argument_list|(
name|documentMode
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|setTabsClosable
argument_list|(
name|tabsClosable
argument_list|)
expr_stmt|;
name|tabBar
operator|->
name|setMovable
argument_list|(
name|tabsMovable
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
name|tabBar
operator|->
name|setShape
argument_list|(
name|tabBarShapeFrom
argument_list|(
name|tabShape
argument_list|,
name|tabPosition
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABBAR
end_comment
begin_comment
comment|/*!     Constructs an empty mdi area. \a parent is passed to QWidget's     constructor. */
end_comment
begin_constructor
DECL|function|QMdiArea
name|QMdiArea
operator|::
name|QMdiArea
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|new
name|QMdiAreaPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|setBackground
argument_list|(
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Dark
argument_list|)
argument_list|)
expr_stmt|;
name|setFrameStyle
argument_list|(
name|QFrame
operator|::
name|NoFrame
argument_list|)
expr_stmt|;
name|setHorizontalScrollBarPolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAlwaysOff
argument_list|)
expr_stmt|;
name|setVerticalScrollBarPolicy
argument_list|(
name|Qt
operator|::
name|ScrollBarAlwaysOff
argument_list|)
expr_stmt|;
name|setViewport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|NoFocus
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|instance
argument_list|()
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the MDI area. */
end_comment
begin_destructor
DECL|function|~QMdiArea
name|QMdiArea
operator|::
name|~
name|QMdiArea
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|cascader
expr_stmt|;
name|d
operator|->
name|cascader
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|regularTiler
expr_stmt|;
name|d
operator|->
name|regularTiler
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|iconTiler
expr_stmt|;
name|d
operator|->
name|iconTiler
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|placer
expr_stmt|;
name|d
operator|->
name|placer
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QMdiArea
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
comment|// Calculate a proper scale factor for QDesktopWidget::size().
comment|// This also takes into account that we can have nested workspaces.
name|int
name|nestedCount
init|=
literal|0
decl_stmt|;
name|QWidget
modifier|*
name|widget
init|=
name|this
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|widget
condition|)
block|{
if|if
condition|(
name|qobject_cast
argument_list|<
name|QMdiArea
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
operator|++
name|nestedCount
expr_stmt|;
name|widget
operator|=
name|widget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
specifier|const
name|int
name|scaleFactor
init|=
literal|3
operator|*
operator|(
name|nestedCount
operator|+
literal|1
operator|)
decl_stmt|;
name|QSize
name|desktopSize
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|size
argument_list|()
decl_stmt|;
name|QSize
name|size
argument_list|(
name|desktopSize
operator|.
name|width
argument_list|()
operator|*
literal|2
operator|/
name|scaleFactor
argument_list|,
name|desktopSize
operator|.
name|height
argument_list|()
operator|*
literal|2
operator|/
name|scaleFactor
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d_func
argument_list|()
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::sizeHint"
argument_list|)
condition|)
continue|continue;
name|size
operator|=
name|size
operator|.
name|expandedTo
argument_list|(
name|child
operator|->
name|sizeHint
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|size
operator|.
name|expandedTo
argument_list|(
name|QApplication
operator|::
name|globalStrut
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QMdiArea
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
name|QSize
name|size
argument_list|(
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_MdiSubWindowMinimizedWidth
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
argument_list|,
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_TitleBarHeight
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
name|size
operator|.
name|expandedTo
argument_list|(
name|QAbstractScrollArea
operator|::
name|minimumSizeHint
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scrollBarsEnabled
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::sizeHint"
argument_list|)
condition|)
continue|continue;
name|size
operator|=
name|size
operator|.
name|expandedTo
argument_list|(
name|child
operator|->
name|minimumSizeHint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|size
operator|.
name|expandedTo
argument_list|(
name|QApplication
operator|::
name|globalStrut
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the current subwindow, or 0 if there is     no current subwindow.      This function will return the same as activeSubWindow() if     the QApplication containing QMdiArea is active.      \sa activeSubWindow(), QApplication::activeWindow() */
end_comment
begin_function
DECL|function|currentSubWindow
name|QMdiSubWindow
modifier|*
name|QMdiArea
operator|::
name|currentSubWindow
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|->
name|active
condition|)
return|return
name|d
operator|->
name|active
return|;
if|if
condition|(
name|d
operator|->
name|isActivated
operator|&&
operator|!
name|window
argument_list|()
operator|->
name|isMinimized
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|indicesToActivatedChildren
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|indicesToActivatedChildren
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|d
operator|->
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QMdiSubWindow
modifier|*
name|current
init|=
name|d
operator|->
name|childWindows
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
name|current
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the current active subwindow. If no     window is currently active, 0 is returned.      Subwindows are treated as top-level windows with respect to     window state, i.e., if a widget outside the MDI area is the active     window, no subwindow will be active. Note that if a widget in the     window in which the MDI area lives gains focus, the window will be     activated.      \sa setActiveSubWindow(), Qt::WindowState */
end_comment
begin_function
DECL|function|activeSubWindow
name|QMdiSubWindow
modifier|*
name|QMdiArea
operator|::
name|activeSubWindow
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|active
return|;
block|}
end_function
begin_comment
comment|/*!     Activates the subwindow \a window. If \a window is 0, any     current active window is deactivated.      \sa activeSubWindow() */
end_comment
begin_function
DECL|function|setActiveSubWindow
name|void
name|QMdiArea
operator|::
name|setActiveSubWindow
parameter_list|(
name|QMdiSubWindow
modifier|*
name|window
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
block|{
name|d
operator|->
name|activateWindow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::setActiveSubWindow: workspace is empty"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|window
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::setActiveSubWindow: window is not inside workspace"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|activateWindow
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the active subwindow.      \sa closeAllSubWindows() */
end_comment
begin_function
DECL|function|closeActiveSubWindow
name|void
name|QMdiArea
operator|::
name|closeActiveSubWindow
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|active
condition|)
name|d
operator|->
name|active
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all subwindows in the MDI area. If \a order is     CreationOrder (the default), the windows are sorted in the order     in which they were inserted into the workspace. If \a order is     StackingOrder, the windows are listed in their stacking order,     with the topmost window as the last item in the list. If \a order     is ActivationHistoryOrder, the windows are listed according to     their recent activation history.      \sa WindowOrder */
end_comment
begin_function
DECL|function|subWindowList
name|QList
argument_list|<
name|QMdiSubWindow
modifier|*
argument_list|>
name|QMdiArea
operator|::
name|subWindowList
parameter_list|(
name|WindowOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|subWindowList
argument_list|(
name|order
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Closes all subwindows by sending a QCloseEvent to each window.     You may receive subWindowActivated() signals from subwindows     before they are closed (if the MDI area activates the subwindow     when another is closing).      Subwindows that ignore the close event will remain open.      \sa closeActiveSubWindow() */
end_comment
begin_function
DECL|function|closeAllSubWindows
name|void
name|QMdiArea
operator|::
name|closeAllSubWindows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::closeAllSubWindows"
argument_list|)
condition|)
continue|continue;
name|child
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|updateScrollBars
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Gives the keyboard focus to another window in the list of child     windows.  The window activated will be the next one determined     by the current \l{QMdiArea::WindowOrder} {activation order}.      \sa activatePreviousSubWindow(), QMdiArea::WindowOrder */
end_comment
begin_function
DECL|function|activateNextSubWindow
name|void
name|QMdiArea
operator|::
name|activateNextSubWindow
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMdiSubWindow
modifier|*
name|next
init|=
name|d
operator|->
name|nextVisibleSubWindow
argument_list|(
literal|1
argument_list|,
name|d
operator|->
name|activationOrder
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|d
operator|->
name|activateWindow
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Gives the keyboard focus to another window in the list of child     windows.  The window activated will be the previous one determined     by the current \l{QMdiArea::WindowOrder} {activation order}.      \sa activateNextSubWindow(), QMdiArea::WindowOrder */
end_comment
begin_function
DECL|function|activatePreviousSubWindow
name|void
name|QMdiArea
operator|::
name|activatePreviousSubWindow
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMdiSubWindow
modifier|*
name|previous
init|=
name|d
operator|->
name|nextVisibleSubWindow
argument_list|(
operator|-
literal|1
argument_list|,
name|d
operator|->
name|activationOrder
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
condition|)
name|d
operator|->
name|activateWindow
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds \a widget as a new subwindow to the MDI area.  If \a     windowFlags are non-zero, they will override the flags set on the     widget.      The \a widget can be either a QMdiSubWindow or another QWidget     (in which case the MDI area will create a subwindow and set the \a     widget as the internal widget).      \note Once the subwindow has been added, its parent will be the     \e{viewport widget} of the QMdiArea.      \snippet mdiareasnippets.cpp 1      When you create your own subwindow, you must set the     Qt::WA_DeleteOnClose widget attribute if you want the window to be     deleted when closed in the MDI area. If not, the window will be     hidden and the MDI area will not activate the next subwindow.      Returns the QMdiSubWindow that is added to the MDI area.      \sa removeSubWindow() */
end_comment
begin_function
DECL|function|addSubWindow
name|QMdiSubWindow
modifier|*
name|QMdiArea
operator|::
name|addSubWindow
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|windowFlags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::addSubWindow: null pointer to widget"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
comment|// QWidget::setParent clears focusWidget so store it
name|QWidget
modifier|*
name|childFocus
init|=
name|widget
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
name|QMdiSubWindow
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
decl_stmt|;
comment|// Widget is already a QMdiSubWindow
if|if
condition|(
name|child
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::addSubWindow: window is already added"
argument_list|)
expr_stmt|;
return|return
name|child
return|;
block|}
name|child
operator|->
name|setParent
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|windowFlags
condition|?
name|windowFlags
else|:
name|child
operator|->
name|windowFlags
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create a QMdiSubWindow
block|}
else|else
block|{
name|child
operator|=
operator|new
name|QMdiSubWindow
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|windowFlags
argument_list|)
expr_stmt|;
name|child
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
expr_stmt|;
name|child
operator|->
name|setWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childFocus
condition|)
name|childFocus
operator|->
name|setFocus
argument_list|()
expr_stmt|;
name|d
operator|->
name|appendChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
name|child
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a widget from the MDI area. The \a widget must be     either a QMdiSubWindow or a widget that is the internal widget of     a subwindow. Note \a widget is never actually deleted by QMdiArea.     If a QMdiSubWindow is passed in its parent is set to 0 and it is     removed, but if an internal widget is passed in the child widget     is set to 0 but the QMdiSubWindow is not removed.      \sa addSubWindow() */
end_comment
begin_function
DECL|function|removeSubWindow
name|void
name|QMdiArea
operator|::
name|removeSubWindow
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::removeSubWindow: null pointer to widget"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|QMdiSubWindow
modifier|*
name|child
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
block|{
name|int
name|index
init|=
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMdiArea::removeSubWindow: window is not inside workspace"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|disconnectSubWindow
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|d
operator|->
name|childWindows
operator|.
name|removeAll
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|d
operator|->
name|indicesToActivatedChildren
operator|.
name|removeAll
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateActiveWindow
argument_list|(
name|index
argument_list|,
name|d
operator|->
name|active
operator|==
name|child
argument_list|)
expr_stmt|;
name|child
operator|->
name|setParent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|found
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::removeSubWindow"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|widget
argument_list|()
operator|==
name|widget
condition|)
block|{
name|child
operator|->
name|setWidget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|child
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|qWarning
argument_list|(
literal|"QMdiArea::removeSubWindow: widget is not child of any window inside QMdiArea"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::background     \brief the background brush for the workspace      This property sets the background brush for the workspace area     itself. By default, it is a gray color, but can be any brush     (e.g., colors, gradients or pixmaps). */
end_comment
begin_function
DECL|function|background
name|QBrush
name|QMdiArea
operator|::
name|background
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|background
return|;
block|}
end_function
begin_function
DECL|function|setBackground
name|void
name|QMdiArea
operator|::
name|setBackground
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|background
operator|!=
name|brush
condition|)
block|{
name|d
operator|->
name|background
operator|=
name|brush
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_OpaquePaintEvent
argument_list|,
name|brush
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::activationOrder     \brief the ordering criteria for subwindow lists     \since 4.4      This property specifies the ordering criteria for the list of     subwindows returned by subWindowList(). By default, it is the window     creation order.      \sa subWindowList() */
end_comment
begin_function
DECL|function|activationOrder
name|QMdiArea
operator|::
name|WindowOrder
name|QMdiArea
operator|::
name|activationOrder
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|activationOrder
return|;
block|}
end_function
begin_function
DECL|function|setActivationOrder
name|void
name|QMdiArea
operator|::
name|setActivationOrder
parameter_list|(
name|WindowOrder
name|order
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|!=
name|d
operator|->
name|activationOrder
condition|)
name|d
operator|->
name|activationOrder
operator|=
name|order
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a on is true, \a option is enabled on the MDI area; otherwise     it is disabled. See AreaOption for the effect of each option.      \sa AreaOption, testOption() */
end_comment
begin_function
DECL|function|setOption
name|void
name|QMdiArea
operator|::
name|setOption
parameter_list|(
name|AreaOption
name|option
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|&&
operator|!
operator|(
name|d
operator|->
name|options
operator|&
name|option
operator|)
condition|)
name|d
operator|->
name|options
operator||=
name|option
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
operator|(
name|d
operator|->
name|options
operator|&
name|option
operator|)
condition|)
name|d
operator|->
name|options
operator|&=
operator|~
name|option
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a option is enabled; otherwise returns false.      \sa AreaOption, setOption() */
end_comment
begin_function
DECL|function|testOption
name|bool
name|QMdiArea
operator|::
name|testOption
parameter_list|(
name|AreaOption
name|option
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|options
operator|&
name|option
return|;
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::viewMode     \brief the way sub-windows are displayed in the QMdiArea.     \since 4.4      By default, the SubWindowView is used to display sub-windows.      \sa ViewMode, setTabShape(), setTabPosition() */
end_comment
begin_function
DECL|function|viewMode
name|QMdiArea
operator|::
name|ViewMode
name|QMdiArea
operator|::
name|viewMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|viewMode
return|;
block|}
end_function
begin_function
DECL|function|setViewMode
name|void
name|QMdiArea
operator|::
name|setViewMode
parameter_list|(
name|ViewMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|d
operator|->
name|setViewMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
end_ifndef
begin_comment
comment|/*!     \property QMdiArea::documentMode     \brief whether the tab bar is set to document mode in tabbed view mode.     \since 4.5      Document mode is disabled by default.      \sa QTabBar::documentMode, setViewMode() */
end_comment
begin_function
DECL|function|documentMode
name|bool
name|QMdiArea
operator|::
name|documentMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|documentMode
return|;
block|}
end_function
begin_function
DECL|function|setDocumentMode
name|void
name|QMdiArea
operator|::
name|setDocumentMode
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|documentMode
operator|==
name|enabled
condition|)
return|return;
name|d
operator|->
name|documentMode
operator|=
name|enabled
expr_stmt|;
name|d
operator|->
name|refreshTabBar
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::tabsClosable     \brief whether the tab bar should place close buttons on each tab in tabbed view mode.     \since 4.8      Tabs are not closable by default.      \sa QTabBar::tabsClosable, setViewMode() */
end_comment
begin_function
DECL|function|tabsClosable
name|bool
name|QMdiArea
operator|::
name|tabsClosable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabsClosable
return|;
block|}
end_function
begin_function
DECL|function|setTabsClosable
name|void
name|QMdiArea
operator|::
name|setTabsClosable
parameter_list|(
name|bool
name|closable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tabsClosable
operator|==
name|closable
condition|)
return|return;
name|d
operator|->
name|tabsClosable
operator|=
name|closable
expr_stmt|;
name|d
operator|->
name|refreshTabBar
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::tabsMovable     \brief whether the user can move the tabs within the tabbar area in tabbed view mode.     \since 4.8      Tabs are not movable by default.      \sa QTabBar::movable, setViewMode() */
end_comment
begin_function
DECL|function|tabsMovable
name|bool
name|QMdiArea
operator|::
name|tabsMovable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabsMovable
return|;
block|}
end_function
begin_function
DECL|function|setTabsMovable
name|void
name|QMdiArea
operator|::
name|setTabsMovable
parameter_list|(
name|bool
name|movable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tabsMovable
operator|==
name|movable
condition|)
return|return;
name|d
operator|->
name|tabsMovable
operator|=
name|movable
expr_stmt|;
name|d
operator|->
name|refreshTabBar
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABBAR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
end_ifndef
begin_comment
comment|/*!     \property QMdiArea::tabShape     \brief the shape of the tabs in tabbed view mode.     \since 4.4      Possible values for this property are QTabWidget::Rounded     (default) or QTabWidget::Triangular.      \sa QTabWidget::TabShape, setViewMode() */
end_comment
begin_function
DECL|function|tabShape
name|QTabWidget
operator|::
name|TabShape
name|QMdiArea
operator|::
name|tabShape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabShape
return|;
block|}
end_function
begin_function
DECL|function|setTabShape
name|void
name|QMdiArea
operator|::
name|setTabShape
parameter_list|(
name|QTabWidget
operator|::
name|TabShape
name|shape
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tabShape
operator|==
name|shape
condition|)
return|return;
name|d
operator|->
name|tabShape
operator|=
name|shape
expr_stmt|;
name|d
operator|->
name|refreshTabBar
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QMdiArea::tabPosition     \brief the position of the tabs in tabbed view mode.     \since 4.4      Possible values for this property are described by the     QTabWidget::TabPosition enum.      \sa QTabWidget::TabPosition, setViewMode() */
end_comment
begin_function
DECL|function|tabPosition
name|QTabWidget
operator|::
name|TabPosition
name|QMdiArea
operator|::
name|tabPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMdiArea
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabPosition
return|;
block|}
end_function
begin_function
DECL|function|setTabPosition
name|void
name|QMdiArea
operator|::
name|setTabPosition
parameter_list|(
name|QTabWidget
operator|::
name|TabPosition
name|position
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tabPosition
operator|==
name|position
condition|)
return|return;
name|d
operator|->
name|tabPosition
operator|=
name|position
expr_stmt|;
name|d
operator|->
name|refreshTabBar
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABWIDGET
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|childEvent
name|void
name|QMdiArea
operator|::
name|childEvent
parameter_list|(
name|QChildEvent
modifier|*
name|childEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|childEvent
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ChildPolished
condition|)
block|{
if|if
condition|(
name|QMdiSubWindow
modifier|*
name|mdiChild
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|childEvent
operator|->
name|child
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|mdiChild
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|d
operator|->
name|appendChild
argument_list|(
name|mdiChild
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QMdiArea
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|resizeEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resizeEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
name|d
operator|->
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Re-tile the views if we're in tiled mode. Re-tile means we will change
comment|// the geometry of the children, which in turn means 'isSubWindowsTiled'
comment|// is set to false, so we have to update the state at the end.
if|if
condition|(
name|d
operator|->
name|isSubWindowsTiled
condition|)
block|{
name|d
operator|->
name|tileCalledFromResizeEvent
operator|=
literal|true
expr_stmt|;
name|tileSubWindows
argument_list|()
expr_stmt|;
name|d
operator|->
name|tileCalledFromResizeEvent
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|startResizeTimer
argument_list|()
expr_stmt|;
comment|// We don't have scroll bars or any maximized views.
return|return;
block|}
comment|// Resize maximized views.
name|bool
name|hasMaximizedSubWindow
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::resizeEvent"
argument_list|)
operator|&&
name|child
operator|->
name|isMaximized
argument_list|()
operator|&&
name|child
operator|->
name|size
argument_list|()
operator|!=
name|resizeEvent
operator|->
name|size
argument_list|()
condition|)
block|{
name|child
operator|->
name|resize
argument_list|(
name|resizeEvent
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasMaximizedSubWindow
condition|)
name|hasMaximizedSubWindow
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|d
operator|->
name|updateScrollBars
argument_list|()
expr_stmt|;
comment|// Minimized views are stacked under maximized views so there's
comment|// no need to re-arrange minimized views on-demand. Start a timer
comment|// just to make things faster with subsequent resize events.
if|if
condition|(
name|hasMaximizedSubWindow
condition|)
name|d
operator|->
name|startResizeTimer
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QMdiArea
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|timerEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|timerEvent
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|resizeTimerId
condition|)
block|{
name|killTimer
argument_list|(
name|d
operator|->
name|resizeTimerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|resizeTimerId
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timerEvent
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|tabToPreviousTimerId
condition|)
block|{
name|killTimer
argument_list|(
name|d
operator|->
name|tabToPreviousTimerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|tabToPreviousTimerId
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|indexToHighlighted
operator|<
literal|0
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
comment|// We're not doing a "quick switch" ... show rubber band.
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|indexToHighlighted
operator|<
name|d
operator|->
name|childWindows
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|rubberBand
argument_list|)
expr_stmt|;
name|d
operator|->
name|showRubberBandFor
argument_list|(
name|d
operator|->
name|childWindows
operator|.
name|at
argument_list|(
name|d
operator|->
name|indexToHighlighted
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QMdiArea
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
name|showEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|pendingRearrangements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|skipPlacement
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|Rearranger
modifier|*
name|rearranger
decl|,
name|d
operator|->
name|pendingRearrangements
control|)
block|{
comment|// If this is the case, we don't have to lay out pending child windows
comment|// since the rearranger will find a placement for them.
if|if
condition|(
name|rearranger
operator|->
name|type
argument_list|()
operator|!=
name|Rearranger
operator|::
name|IconTiler
operator|&&
operator|!
name|skipPlacement
condition|)
name|skipPlacement
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|rearrange
argument_list|(
name|rearranger
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|pendingRearrangements
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipPlacement
operator|&&
operator|!
name|d
operator|->
name|pendingPlacements
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|pendingPlacements
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|pendingPlacements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|window
decl|,
name|d
operator|->
name|pendingPlacements
control|)
block|{
if|if
condition|(
operator|!
name|window
condition|)
continue|continue;
if|if
condition|(
operator|!
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
condition|)
block|{
name|QSize
name|newSize
argument_list|(
name|window
operator|->
name|sizeHint
argument_list|()
operator|.
name|boundedTo
argument_list|(
name|viewport
argument_list|()
operator|->
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|window
operator|->
name|resize
argument_list|(
name|newSize
operator|.
name|expandedTo
argument_list|(
name|qSmartMinSize
argument_list|(
name|window
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|window
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
operator|&&
operator|!
name|window
operator|->
name|isMinimized
argument_list|()
operator|&&
operator|!
name|window
operator|->
name|isMaximized
argument_list|()
condition|)
block|{
name|d
operator|->
name|place
argument_list|(
name|d
operator|->
name|placer
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|pendingPlacements
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|setChildActivationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|activateCurrentWindow
argument_list|()
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|showEvent
argument_list|(
name|showEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|viewportEvent
name|bool
name|QMdiArea
operator|::
name|viewportEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
block|{
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
name|QObject
modifier|*
name|removedChild
init|=
cast|static_cast
argument_list|<
name|QChildEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|child
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|childWindows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|child
init|=
name|d
operator|->
name|childWindows
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|==
name|removedChild
operator|||
operator|!
name|child
operator|->
name|parent
argument_list|()
operator|||
name|child
operator|->
name|parent
argument_list|()
operator|!=
name|viewport
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|testOption
argument_list|(
name|DontMaximizeSubWindowOnActivation
argument_list|)
condition|)
block|{
comment|// In this case we can only rely on the child being a QObject
comment|// (or 0), but let's try and see if we can get more information.
name|QWidget
modifier|*
name|mdiChild
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|removedChild
argument_list|)
decl_stmt|;
if|if
condition|(
name|mdiChild
operator|&&
name|mdiChild
operator|->
name|isMaximized
argument_list|()
condition|)
name|d
operator|->
name|showActiveWindowMaximized
operator|=
literal|true
expr_stmt|;
block|}
name|d
operator|->
name|disconnectSubWindow
argument_list|(
name|child
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|activeRemoved
init|=
name|i
operator|==
name|d
operator|->
name|indicesToActivatedChildren
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|d
operator|->
name|childWindows
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|->
name|indicesToActivatedChildren
operator|.
name|removeAll
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateActiveWindow
argument_list|(
name|i
argument_list|,
name|activeRemoved
argument_list|)
expr_stmt|;
name|d
operator|->
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|d
operator|->
name|updateScrollBars
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|Destroy
case|:
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|resetActiveWindow
argument_list|()
expr_stmt|;
name|d
operator|->
name|childWindows
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qWarning
argument_list|(
literal|"QMdiArea: Deleting the view port is undefined, use setViewport instead."
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|viewportEvent
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|scrollContentsBy
name|void
name|QMdiArea
operator|::
name|scrollContentsBy
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|wasSubWindowsTiled
init|=
name|d
operator|->
name|isSubWindowsTiled
decl_stmt|;
name|d
operator|->
name|ignoreGeometryChange
operator|=
literal|true
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|scroll
argument_list|(
name|isLeftToRight
argument_list|()
condition|?
name|dx
else|:
operator|-
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|d
operator|->
name|arrangeMinimizedSubWindows
argument_list|()
expr_stmt|;
name|d
operator|->
name|ignoreGeometryChange
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|wasSubWindowsTiled
condition|)
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Arranges all child windows in a tile pattern.      \sa cascadeSubWindows() */
end_comment
begin_function
DECL|function|tileSubWindows
name|void
name|QMdiArea
operator|::
name|tileSubWindows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|regularTiler
condition|)
name|d
operator|->
name|regularTiler
operator|=
operator|new
name|RegularTiler
expr_stmt|;
name|d
operator|->
name|rearrange
argument_list|(
name|d
operator|->
name|regularTiler
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Arranges all the child windows in a cascade pattern.      \sa tileSubWindows() */
end_comment
begin_function
DECL|function|cascadeSubWindows
name|void
name|QMdiArea
operator|::
name|cascadeSubWindows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cascader
condition|)
name|d
operator|->
name|cascader
operator|=
operator|new
name|SimpleCascader
expr_stmt|;
name|d
operator|->
name|rearrange
argument_list|(
name|d
operator|->
name|cascader
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QMdiArea
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_WIN
comment|// QWidgetPrivate::hide_helper activates another sub-window when closing a
comment|// modal dialog on Windows (see activateWindow() inside the ifdef).
case|case
name|QEvent
operator|::
name|WindowUnblocked
case|:
name|d
operator|->
name|activateCurrentWindow
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
block|{
name|d
operator|->
name|isActivated
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
name|d
operator|->
name|active
condition|)
name|d
operator|->
name|activateCurrentWindow
argument_list|()
expr_stmt|;
name|d
operator|->
name|setChildActivationEnabled
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
name|d
operator|->
name|isActivated
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|setChildActivationEnabled
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleChange
case|:
comment|// Re-tile the views if we're in tiled mode. Re-tile means we will change
comment|// the geometry of the children, which in turn means 'isSubWindowsTiled'
comment|// is set to false, so we have to update the state at the end.
if|if
condition|(
name|d
operator|->
name|isSubWindowsTiled
condition|)
block|{
name|tileSubWindows
argument_list|()
expr_stmt|;
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|WindowIconChange
case|:
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|window
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
name|sanityCheck
argument_list|(
name|window
argument_list|,
literal|"QMdiArea::WindowIconChange"
argument_list|)
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|window
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
name|d
operator|->
name|setActive
argument_list|(
name|d
operator|->
name|active
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|setChildActivationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
name|d
operator|->
name|updateTabBarGeometry
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QMdiArea
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|object
condition|)
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
comment|// Global key events with Ctrl modifier.
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyRelease
condition|)
block|{
name|QKeyEvent
modifier|*
name|keyEvent
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
comment|// Ingore key events without a Ctrl modifier (except for press/release on the modifier itself).
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
operator|!
operator|(
name|keyEvent
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|MetaModifier
operator|)
operator|&&
name|keyEvent
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Meta
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|keyEvent
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
operator|&&
name|keyEvent
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Control
condition|)
endif|#
directive|endif
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
comment|// Find closest mdi area (in case we have a nested workspace).
name|QMdiArea
modifier|*
name|area
init|=
name|mdiAreaParent
argument_list|(
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|area
condition|)
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
specifier|const
name|bool
name|keyPress
init|=
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
comment|// 1) Ctrl-Tab once -> activate the previously active window.
comment|// 2) Ctrl-Tab (Tab, Tab, ...) -> iterate through all windows (activateNextSubWindow()).
comment|// 3) Ctrl-Shift-Tab (Tab, Tab, ...) -> iterate through all windows in the opposite
comment|//    direction (activatePreviousSubWindow())
switch|switch
condition|(
name|keyEvent
operator|->
name|key
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
case|case
name|Qt
operator|::
name|Key_Meta
case|:
else|#
directive|else
case|case
name|Qt
operator|::
name|Key_Control
case|:
endif|#
directive|endif
if|if
condition|(
name|keyPress
condition|)
name|area
operator|->
name|d_func
argument_list|()
operator|->
name|startTabToPreviousTimer
argument_list|()
expr_stmt|;
else|else
name|area
operator|->
name|d_func
argument_list|()
operator|->
name|activateHighlightedWindow
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Tab
case|:
case|case
name|Qt
operator|::
name|Key_Backtab
case|:
if|if
condition|(
name|keyPress
condition|)
name|area
operator|->
name|d_func
argument_list|()
operator|->
name|highlightNextSubWindow
argument_list|(
name|keyEvent
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
case|case
name|Qt
operator|::
name|Key_Escape
case|:
name|area
operator|->
name|d_func
argument_list|()
operator|->
name|hideRubberBand
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
block|}
name|QMdiSubWindow
modifier|*
name|subWindow
init|=
name|qobject_cast
argument_list|<
name|QMdiSubWindow
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|subWindow
condition|)
block|{
comment|// QApplication events:
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ApplicationActivate
operator|&&
operator|!
name|d
operator|->
name|active
operator|&&
name|isVisible
argument_list|()
operator|&&
operator|!
name|window
argument_list|()
operator|->
name|isMinimized
argument_list|()
condition|)
block|{
name|d
operator|->
name|activateCurrentWindow
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ApplicationDeactivate
operator|&&
name|d
operator|->
name|active
condition|)
block|{
name|d
operator|->
name|setActive
argument_list|(
name|d
operator|->
name|active
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
block|}
comment|// QMdiSubWindow events:
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Move
case|:
case|case
name|QEvent
operator|::
name|Resize
case|:
if|if
condition|(
name|d
operator|->
name|tileCalledFromResizeEvent
condition|)
break|break;
name|d
operator|->
name|updateScrollBars
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|subWindow
operator|->
name|isMinimized
argument_list|()
condition|)
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
if|if
condition|(
name|d
operator|->
name|tabBar
condition|)
block|{
specifier|const
name|int
name|tabIndex
init|=
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|subWindow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|tabBar
operator|->
name|isTabEnabled
argument_list|(
name|tabIndex
argument_list|)
condition|)
name|d
operator|->
name|tabBar
operator|->
name|setTabEnabled
argument_list|(
name|tabIndex
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABBAR
comment|// fall through
case|case
name|QEvent
operator|::
name|Hide
case|:
name|d
operator|->
name|isSubWindowsTiled
operator|=
literal|false
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
case|case
name|QEvent
operator|::
name|Close
case|:
if|if
condition|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|subWindow
argument_list|)
operator|==
name|d
operator|->
name|indexToHighlighted
condition|)
name|d
operator|->
name|hideRubberBand
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
case|case
name|QEvent
operator|::
name|WindowTitleChange
case|:
case|case
name|QEvent
operator|::
name|ModifiedChange
case|:
if|if
condition|(
name|d
operator|->
name|tabBar
condition|)
name|d
operator|->
name|tabBar
operator|->
name|setTabText
argument_list|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|subWindow
argument_list|)
argument_list|,
name|tabTextFor
argument_list|(
name|subWindow
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowIconChange
case|:
if|if
condition|(
name|d
operator|->
name|tabBar
condition|)
name|d
operator|->
name|tabBar
operator|->
name|setTabIcon
argument_list|(
name|d
operator|->
name|childWindows
operator|.
name|indexOf
argument_list|(
name|subWindow
argument_list|)
argument_list|,
name|subWindow
operator|->
name|windowIcon
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_TABBAR
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|eventFilter
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QMdiArea
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|paintEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
name|QPainter
name|painter
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
modifier|&
name|exposedRects
init|=
name|paintEvent
operator|->
name|region
argument_list|()
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exposedRects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|painter
operator|.
name|fillRect
argument_list|(
name|exposedRects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|d
operator|->
name|background
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called by QAbstractScrollArea after setViewport() has been     called. Reimplement this function in a subclass of QMdiArea to     initialize the new \a viewport before it is used.      \sa setViewport() */
end_comment
begin_function
DECL|function|setupViewport
name|void
name|QMdiArea
operator|::
name|setupViewport
parameter_list|(
name|QWidget
modifier|*
name|viewport
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMdiArea
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewport
condition|)
name|viewport
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_OpaquePaintEvent
argument_list|,
name|d
operator|->
name|background
operator|.
name|isOpaque
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QMdiSubWindow
modifier|*
name|child
decl|,
name|d
operator|->
name|childWindows
control|)
block|{
if|if
condition|(
operator|!
name|sanityCheck
argument_list|(
name|child
argument_list|,
literal|"QMdiArea::setupViewport"
argument_list|)
condition|)
continue|continue;
name|child
operator|->
name|setParent
argument_list|(
name|viewport
argument_list|,
name|child
operator|->
name|windowFlags
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qmdiarea.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MDIAREA
end_comment
end_unit
