begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlcdnumber.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LCDNUMBER
end_ifndef
begin_include
include|#
directive|include
file|"qbitarray.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"private/qframe_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QLCDNumberPrivate
class|class
name|QLCDNumberPrivate
super|:
specifier|public
name|QFramePrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QLCDNumber
parameter_list|)
specifier|public
private|:
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|internalSetString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
function_decl|;
name|void
name|drawString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QPainter
modifier|&
parameter_list|,
name|QBitArray
modifier|*
init|=
literal|0
parameter_list|,
name|bool
init|=
literal|true
parameter_list|)
function_decl|;
comment|//void drawString(const QString&, QPainter&, QBitArray * = 0) const;
name|void
name|drawDigit
parameter_list|(
specifier|const
name|QPoint
modifier|&
parameter_list|,
name|QPainter
modifier|&
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|,
name|char
init|=
literal|' '
parameter_list|)
function_decl|;
name|void
name|drawSegment
parameter_list|(
specifier|const
name|QPoint
modifier|&
parameter_list|,
name|char
parameter_list|,
name|QPainter
modifier|&
parameter_list|,
name|int
parameter_list|,
name|bool
init|=
literal|false
parameter_list|)
function_decl|;
DECL|member|ndigits
name|int
name|ndigits
decl_stmt|;
DECL|member|val
name|double
name|val
decl_stmt|;
name|uint
name|base
range|:
literal|2
decl_stmt|;
name|uint
name|smallPoint
range|:
literal|1
decl_stmt|;
name|uint
name|fill
range|:
literal|1
decl_stmt|;
name|uint
name|shadow
range|:
literal|1
decl_stmt|;
DECL|member|digitStr
name|QString
name|digitStr
decl_stmt|;
DECL|member|points
name|QBitArray
name|points
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QLCDNumber      \brief The QLCDNumber widget displays a number with LCD-like digits.      \ingroup basicwidgets     \inmodule QtWidgets      It can display a number in just about any size. It can display     decimal, hexadecimal, octal or binary numbers. It is easy to     connect to data sources using the display() slot, which is     overloaded to take any of five argument types.      There are also slots to change the base with setMode() and the     decimal point with setSmallDecimalPoint().      QLCDNumber emits the overflow() signal when it is asked to display     something beyond its range. The range is set by setDigitCount(),     but setSmallDecimalPoint() also influences it. If the display is     set to hexadecimal, octal or binary, the integer equivalent of the     value is displayed.      These digits and other symbols can be shown: 0/O, 1, 2, 3, 4, 5/S,     6, 7, 8, 9/g, minus, decimal point, A, B, C, D, E, F, h, H, L, o,     P, r, u, U, Y, colon, degree sign (which is specified as single     quote in the string) and space. QLCDNumber substitutes spaces for     illegal characters.      It is not possible to retrieve the contents of a QLCDNumber     object, although you can retrieve the numeric value with value().     If you really need the text, we recommend that you connect the     signals that feed the display() slot to another slot as well and     store the value there.      Incidentally, QLCDNumber is the very oldest part of Qt, tracing     its roots back to a BASIC program on the \l{Sinclair Spectrum}{Sinclair Spectrum}.      \table     \row \li     \inlineimage windows-lcdnumber.png Screenshot of a Windows style LCD number widget     \inlineimage windowsvista-lcdnumber.png Screenshot of a Windows Vista style LCD number widget     \inlineimage macintosh-lcdnumber.png Screenshot of a Macintosh style LCD number widget     \inlineimage fusion-lcdnumber.png Screenshot of a Fusion style LCD number widget     \row \li LCD number widgets shown in various widget styles (from left to right):     \l{Windows Style Widget Gallery}{Windows}, \l{Windows Vista Style Widget Gallery}{Windows Vista},     \l{Macintosh Style Widget Gallery}{Macintosh}, \l{Fusion Style Widget Gallery}{Fusion}.     \endtable      \sa QLabel, QFrame, {Digital Clock Example}, {Tetrix Example} */
end_comment
begin_comment
comment|/*!     \enum QLCDNumber::Mode      This type determines how numbers are shown.      \value Hex  Hexadecimal     \value Dec  Decimal     \value Oct  Octal     \value Bin  Binary      If the display is set to hexadecimal, octal or binary, the integer     equivalent of the value is displayed. */
end_comment
begin_comment
comment|/*!     \enum QLCDNumber::SegmentStyle      This type determines the visual appearance of the QLCDNumber     widget.      \value Outline gives raised segments filled with the background color.     \value Filled gives raised segments filled with the windowText color.     \value Flat gives flat segments filled with the windowText color. */
end_comment
begin_comment
comment|/*!     \fn void QLCDNumber::overflow()      This signal is emitted whenever the QLCDNumber is asked to display     a too-large number or a too-long string.      It is never emitted by setDigitCount(). */
end_comment
begin_function
DECL|function|int2string
specifier|static
name|QString
name|int2string
parameter_list|(
name|int
name|num
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|bool
modifier|*
name|oflow
parameter_list|)
block|{
name|QString
name|s
decl_stmt|;
name|bool
name|negative
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|negative
operator|=
literal|true
expr_stmt|;
name|num
operator|=
operator|-
name|num
expr_stmt|;
block|}
else|else
block|{
name|negative
operator|=
literal|false
expr_stmt|;
block|}
switch|switch
condition|(
name|base
condition|)
block|{
case|case
name|QLCDNumber
operator|::
name|Hex
case|:
name|s
operator|.
name|sprintf
argument_list|(
literal|"%*x"
argument_list|,
name|ndigits
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|QLCDNumber
operator|::
name|Dec
case|:
name|s
operator|.
name|sprintf
argument_list|(
literal|"%*i"
argument_list|,
name|ndigits
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|QLCDNumber
operator|::
name|Oct
case|:
name|s
operator|.
name|sprintf
argument_list|(
literal|"%*o"
argument_list|,
name|ndigits
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|QLCDNumber
operator|::
name|Bin
case|:
block|{
name|char
name|buf
index|[
literal|42
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|&
name|buf
index|[
literal|41
index|]
decl_stmt|;
name|uint
name|n
init|=
name|num
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|n
operator|&
literal|1
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|n
operator|>>=
literal|1
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|!=
literal|0
condition|)
do|;
name|len
operator|=
name|ndigits
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|s
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|negative
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|s
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|s
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|oflow
condition|)
operator|*
name|oflow
operator|=
operator|(
name|int
operator|)
name|s
operator|.
name|length
argument_list|()
operator|>
name|ndigits
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|double2string
specifier|static
name|QString
name|double2string
parameter_list|(
name|double
name|num
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|bool
modifier|*
name|oflow
parameter_list|)
block|{
name|QString
name|s
decl_stmt|;
if|if
condition|(
name|base
operator|!=
name|QLCDNumber
operator|::
name|Dec
condition|)
block|{
name|bool
name|of
init|=
name|num
operator|>=
literal|2147483648.0
operator|||
name|num
operator|<
operator|-
literal|2147483648.0
decl_stmt|;
if|if
condition|(
name|of
condition|)
block|{
comment|// oops, integer overflow
if|if
condition|(
name|oflow
condition|)
operator|*
name|oflow
operator|=
literal|true
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|int2string
argument_list|(
operator|(
name|int
operator|)
name|num
argument_list|,
name|base
argument_list|,
name|ndigits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// decimal base
name|int
name|nd
init|=
name|ndigits
decl_stmt|;
do|do
block|{
name|s
operator|.
name|sprintf
argument_list|(
literal|"%*.*g"
argument_list|,
name|ndigits
argument_list|,
name|nd
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
condition|)
block|{
name|s
index|[
name|i
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nd
operator|--
operator|&&
operator|(
name|int
operator|)
name|s
operator|.
name|length
argument_list|()
operator|>
name|ndigits
condition|)
do|;
block|}
if|if
condition|(
name|oflow
condition|)
operator|*
name|oflow
operator|=
operator|(
name|int
operator|)
name|s
operator|.
name|length
argument_list|()
operator|>
name|ndigits
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|getSegments
specifier|static
specifier|const
name|char
modifier|*
name|getSegments
parameter_list|(
name|char
name|ch
parameter_list|)
comment|// gets list of segments for ch
block|{
specifier|static
specifier|const
name|char
name|segments
index|[
literal|30
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|}
block|,
comment|// 0    0 / O
block|{
literal|2
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 1    1
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 2    2
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 3    3
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 4    4
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 5    5 / S
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|}
block|,
comment|// 6    6
block|{
literal|0
block|,
literal|2
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 7    7
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|}
block|,
comment|// 8    8
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|}
block|,
comment|// 9    9 / g
block|{
literal|3
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 10   -
block|{
literal|7
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 11   .
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|}
block|,
comment|// 12   A
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 13   B
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 14   C
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 15   D
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 16   E
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 17   F
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 18   h
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 19   H
block|{
literal|1
block|,
literal|4
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 20   L
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 21   o
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 22   P
block|{
literal|3
block|,
literal|4
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 23   r
block|{
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 24   u
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 25   U
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 26   Y
block|{
literal|8
block|,
literal|9
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 27   :
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// 28   '
block|{
literal|99
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|// 29   empty
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|segments
index|[
name|ch
operator|-
literal|'0'
index|]
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|segments
index|[
name|ch
operator|-
literal|'A'
operator|+
literal|12
index|]
return|;
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|segments
index|[
name|ch
operator|-
literal|'a'
operator|+
literal|12
index|]
return|;
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|n
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|n
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|n
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|n
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|n
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|n
operator|=
literal|19
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|n
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|n
operator|=
literal|21
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|n
operator|=
literal|22
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|n
operator|=
literal|23
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|n
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|n
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|n
operator|=
literal|25
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
name|n
operator|=
literal|26
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|n
operator|=
literal|27
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|n
operator|=
literal|28
expr_stmt|;
break|break;
default|default:
name|n
operator|=
literal|29
expr_stmt|;
break|break;
block|}
return|return
name|segments
index|[
name|n
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an LCD number, sets the number of digits to 5, the base     to decimal, the decimal point mode to 'small' and the frame style     to a raised box. The segmentStyle() is set to \c Outline.      The \a parent argument is passed to the QFrame constructor.      \sa setDigitCount(), setSmallDecimalPoint() */
end_comment
begin_constructor
DECL|function|QLCDNumber
name|QLCDNumber
operator|::
name|QLCDNumber
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QLCDNumberPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|ndigits
operator|=
literal|5
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an LCD number, sets the number of digits to \a     numDigits, the base to decimal, the decimal point mode to 'small'     and the frame style to a raised box. The segmentStyle() is set to     \c Filled.      The \a parent argument is passed to the QFrame constructor.      \sa setDigitCount(), setSmallDecimalPoint() */
end_comment
begin_constructor
DECL|function|QLCDNumber
name|QLCDNumber
operator|::
name|QLCDNumber
parameter_list|(
name|uint
name|numDigits
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QLCDNumberPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|ndigits
operator|=
name|numDigits
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QLCDNumberPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFrameStyle
argument_list|(
name|QFrame
operator|::
name|Box
operator||
name|QFrame
operator|::
name|Raised
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|base
operator|=
name|QLCDNumber
operator|::
name|Dec
expr_stmt|;
name|smallPoint
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|setDigitCount
argument_list|(
name|ndigits
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSegmentStyle
argument_list|(
name|QLCDNumber
operator|::
name|Filled
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Minimum
argument_list|,
name|QSizePolicy
operator|::
name|Minimum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys the LCD number. */
end_comment
begin_destructor
DECL|function|~QLCDNumber
name|QLCDNumber
operator|::
name|~
name|QLCDNumber
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \since 4.6     \property QLCDNumber::digitCount     \brief the current number of digits displayed      Corresponds to the current number of digits. If \l     QLCDNumber::smallDecimalPoint is false, the decimal point occupies     one digit position.      By default, this property contains a value of 5.      \sa smallDecimalPoint */
end_comment
begin_comment
comment|/*!   Sets the current number of digits to \a numDigits. Must   be in the range 0..99.  */
end_comment
begin_function
DECL|function|setDigitCount
name|void
name|QLCDNumber
operator|::
name|setDigitCount
parameter_list|(
name|int
name|numDigits
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|numDigits
operator|>
literal|99
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLCDNumber::setNumDigits: (%s) Max 99 digits allowed"
argument_list|,
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|numDigits
operator|=
literal|99
expr_stmt|;
block|}
if|if
condition|(
name|numDigits
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLCDNumber::setNumDigits: (%s) Min 0 digits allowed"
argument_list|,
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|numDigits
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|digitStr
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// from constructor
name|d
operator|->
name|ndigits
operator|=
name|numDigits
expr_stmt|;
name|d
operator|->
name|digitStr
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|d
operator|->
name|ndigits
argument_list|)
expr_stmt|;
name|d
operator|->
name|points
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|ndigits
argument_list|)
expr_stmt|;
name|d
operator|->
name|digitStr
index|[
name|d
operator|->
name|ndigits
operator|-
literal|1
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
comment|// "0" is the default number
block|}
else|else
block|{
name|bool
name|doDisplay
init|=
name|d
operator|->
name|ndigits
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|numDigits
operator|==
name|d
operator|->
name|ndigits
condition|)
comment|// no change
return|return;
name|int
name|i
decl_stmt|;
name|int
name|dif
decl_stmt|;
if|if
condition|(
name|numDigits
operator|>
name|d
operator|->
name|ndigits
condition|)
block|{
comment|// expand
name|dif
operator|=
name|numDigits
operator|-
name|d
operator|->
name|ndigits
expr_stmt|;
name|QString
name|buf
decl_stmt|;
name|buf
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|dif
argument_list|)
expr_stmt|;
name|d
operator|->
name|digitStr
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|d
operator|->
name|points
operator|.
name|resize
argument_list|(
name|numDigits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|numDigits
operator|-
literal|1
init|;
name|i
operator|>=
name|dif
condition|;
name|i
operator|--
control|)
name|d
operator|->
name|points
operator|.
name|setBit
argument_list|(
name|i
argument_list|,
name|d
operator|->
name|points
operator|.
name|testBit
argument_list|(
name|i
operator|-
name|dif
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dif
condition|;
name|i
operator|++
control|)
name|d
operator|->
name|points
operator|.
name|clearBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// shrink
name|dif
operator|=
name|d
operator|->
name|ndigits
operator|-
name|numDigits
expr_stmt|;
name|d
operator|->
name|digitStr
operator|=
name|d
operator|->
name|digitStr
operator|.
name|right
argument_list|(
name|numDigits
argument_list|)
expr_stmt|;
name|QBitArray
name|tmpPoints
init|=
name|d
operator|->
name|points
decl_stmt|;
name|d
operator|->
name|points
operator|.
name|resize
argument_list|(
name|numDigits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|numDigits
condition|;
name|i
operator|++
control|)
name|d
operator|->
name|points
operator|.
name|setBit
argument_list|(
name|i
argument_list|,
name|tmpPoints
operator|.
name|testBit
argument_list|(
name|i
operator|+
name|dif
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|ndigits
operator|=
name|numDigits
expr_stmt|;
if|if
condition|(
name|doDisplay
condition|)
name|display
argument_list|(
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Returns the current number of digits.  */
end_comment
begin_function
DECL|function|digitCount
name|int
name|QLCDNumber
operator|::
name|digitCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|ndigits
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns \c true if \a num is too big to be displayed in its entirety;     otherwise returns \c false.      \sa display(), digitCount(), smallDecimalPoint() */
end_comment
begin_function
DECL|function|checkOverflow
name|bool
name|QLCDNumber
operator|::
name|checkOverflow
parameter_list|(
name|int
name|num
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
name|bool
name|of
decl_stmt|;
name|int2string
argument_list|(
name|num
argument_list|,
name|d
operator|->
name|base
argument_list|,
name|d
operator|->
name|ndigits
argument_list|,
operator|&
name|of
argument_list|)
expr_stmt|;
return|return
name|of
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if \a num is too big to be displayed in its entirety;     otherwise returns \c false.      \sa display(), digitCount(), smallDecimalPoint() */
end_comment
begin_function
DECL|function|checkOverflow
name|bool
name|QLCDNumber
operator|::
name|checkOverflow
parameter_list|(
name|double
name|num
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
name|bool
name|of
decl_stmt|;
name|double2string
argument_list|(
name|num
argument_list|,
name|d
operator|->
name|base
argument_list|,
name|d
operator|->
name|ndigits
argument_list|,
operator|&
name|of
argument_list|)
expr_stmt|;
return|return
name|of
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLCDNumber::mode     \brief the current display mode (number base)      Corresponds to the current display mode, which is one of \c Bin,     \c Oct, \c Dec (the default) and \c Hex. \c Dec mode can display     floating point values, the other modes display the integer     equivalent.      \sa smallDecimalPoint(), setHexMode(), setDecMode(), setOctMode(), setBinMode() */
end_comment
begin_function
DECL|function|mode
name|QLCDNumber
operator|::
name|Mode
name|QLCDNumber
operator|::
name|mode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|QLCDNumber
operator|::
name|Mode
operator|)
name|d
operator|->
name|base
return|;
block|}
end_function
begin_function
DECL|function|setMode
name|void
name|QLCDNumber
operator|::
name|setMode
parameter_list|(
name|Mode
name|m
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|base
operator|=
name|m
expr_stmt|;
name|display
argument_list|(
name|d
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLCDNumber::value     \brief the displayed value      This property corresponds to the current value displayed by the     LCDNumber.      If the displayed value is not a number, the property has a value     of 0.      By default, this property contains a value of 0. */
end_comment
begin_function
DECL|function|value
name|double
name|QLCDNumber
operator|::
name|value
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|val
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Displays the number \a num. */
end_comment
begin_function
DECL|function|display
name|void
name|QLCDNumber
operator|::
name|display
parameter_list|(
name|double
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|val
operator|=
name|num
expr_stmt|;
name|bool
name|of
decl_stmt|;
name|QString
name|s
init|=
name|double2string
argument_list|(
name|d
operator|->
name|val
argument_list|,
name|d
operator|->
name|base
argument_list|,
name|d
operator|->
name|ndigits
argument_list|,
operator|&
name|of
argument_list|)
decl_stmt|;
if|if
condition|(
name|of
condition|)
emit|emit
name|overflow
argument_list|()
emit|;
else|else
name|d
operator|->
name|internalSetString
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLCDNumber::intValue     \brief the displayed value rounded to the nearest integer      This property corresponds to the nearest integer to the current     value displayed by the LCDNumber. This is the value used for     hexadecimal, octal and binary modes.      If the displayed value is not a number, the property has a value     of 0.      By default, this property contains a value of 0. */
end_comment
begin_function
DECL|function|intValue
name|int
name|QLCDNumber
operator|::
name|intValue
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|d
operator|->
name|val
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Displays the number \a num. */
end_comment
begin_function
DECL|function|display
name|void
name|QLCDNumber
operator|::
name|display
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|val
operator|=
operator|(
name|double
operator|)
name|num
expr_stmt|;
name|bool
name|of
decl_stmt|;
name|QString
name|s
init|=
name|int2string
argument_list|(
name|num
argument_list|,
name|d
operator|->
name|base
argument_list|,
name|d
operator|->
name|ndigits
argument_list|,
operator|&
name|of
argument_list|)
decl_stmt|;
if|if
condition|(
name|of
condition|)
emit|emit
name|overflow
argument_list|()
emit|;
else|else
name|d
operator|->
name|internalSetString
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Displays the number represented by the string \a s.      This version of the function disregards mode() and     smallDecimalPoint().      These digits and other symbols can be shown: 0/O, 1, 2, 3, 4, 5/S,     6, 7, 8, 9/g, minus, decimal point, A, B, C, D, E, F, h, H, L, o,     P, r, u, U, Y, colon, degree sign (which is specified as single     quote in the string) and space. QLCDNumber substitutes spaces for     illegal characters. */
end_comment
begin_function
DECL|function|display
name|void
name|QLCDNumber
operator|::
name|display
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|double
name|v
init|=
name|s
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
name|d
operator|->
name|val
operator|=
name|v
expr_stmt|;
name|d
operator|->
name|internalSetString
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calls setMode(Hex). Provided for convenience (e.g. for     connecting buttons to it).      \sa setMode(), setDecMode(), setOctMode(), setBinMode(), mode() */
end_comment
begin_function
DECL|function|setHexMode
name|void
name|QLCDNumber
operator|::
name|setHexMode
parameter_list|()
block|{
name|setMode
argument_list|(
name|Hex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calls setMode(Dec). Provided for convenience (e.g. for     connecting buttons to it).      \sa setMode(), setHexMode(), setOctMode(), setBinMode(), mode() */
end_comment
begin_function
DECL|function|setDecMode
name|void
name|QLCDNumber
operator|::
name|setDecMode
parameter_list|()
block|{
name|setMode
argument_list|(
name|Dec
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calls setMode(Oct). Provided for convenience (e.g. for     connecting buttons to it).      \sa setMode(), setHexMode(), setDecMode(), setBinMode(), mode() */
end_comment
begin_function
DECL|function|setOctMode
name|void
name|QLCDNumber
operator|::
name|setOctMode
parameter_list|()
block|{
name|setMode
argument_list|(
name|Oct
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calls setMode(Bin). Provided for convenience (e.g. for     connecting buttons to it).      \sa setMode(), setHexMode(), setDecMode(), setOctMode(), mode() */
end_comment
begin_function
DECL|function|setBinMode
name|void
name|QLCDNumber
operator|::
name|setBinMode
parameter_list|()
block|{
name|setMode
argument_list|(
name|Bin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLCDNumber::smallDecimalPoint     \brief the style of the decimal point      If true the decimal point is drawn between two digit positions.     Otherwise it occupies a digit position of its own, i.e. is drawn     in a digit position. The default is false.      The inter-digit space is made slightly wider when the decimal     point is drawn between the digits.      \sa mode */
end_comment
begin_function
DECL|function|setSmallDecimalPoint
name|void
name|QLCDNumber
operator|::
name|setSmallDecimalPoint
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|smallPoint
operator|=
name|b
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|smallDecimalPoint
name|bool
name|QLCDNumber
operator|::
name|smallDecimalPoint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|smallPoint
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QLCDNumber
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|drawFrame
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shadow
condition|)
name|p
operator|.
name|translate
argument_list|(
literal|0.5
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|smallPoint
condition|)
name|d
operator|->
name|drawString
argument_list|(
name|d
operator|->
name|digitStr
argument_list|,
name|p
argument_list|,
operator|&
name|d
operator|->
name|points
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|drawString
argument_list|(
name|d
operator|->
name|digitStr
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|internalSetString
name|void
name|QLCDNumberPrivate
operator|::
name|internalSetString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|QString
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|QBitArray
name|newPoints
argument_list|(
name|ndigits
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|smallPoint
condition|)
block|{
if|if
condition|(
name|len
operator|==
name|ndigits
condition|)
name|buffer
operator|=
name|s
expr_stmt|;
else|else
name|buffer
operator|=
name|s
operator|.
name|right
argument_list|(
name|ndigits
argument_list|)
operator|.
name|rightJustified
argument_list|(
name|ndigits
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|lastWasPoint
init|=
literal|true
decl_stmt|;
name|newPoints
operator|.
name|clearBit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastWasPoint
condition|)
block|{
comment|// point already set for digit?
if|if
condition|(
name|index
operator|==
name|ndigits
operator|-
literal|1
condition|)
comment|// no more digits
break|break;
name|index
operator|++
expr_stmt|;
name|buffer
index|[
name|index
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|// 2 points in a row, add space
block|}
name|newPoints
operator|.
name|setBit
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// set decimal point
name|lastWasPoint
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|==
name|ndigits
operator|-
literal|1
condition|)
break|break;
name|index
operator|++
expr_stmt|;
name|buffer
index|[
name|index
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|newPoints
operator|.
name|clearBit
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// decimal point default off
name|lastWasPoint
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
operator|(
operator|(
name|int
operator|)
name|ndigits
operator|)
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|index
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buffer
index|[
name|ndigits
operator|-
literal|1
operator|-
name|index
operator|+
name|i
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|newPoints
operator|.
name|setBit
argument_list|(
name|ndigits
operator|-
literal|1
operator|-
name|index
operator|+
name|i
argument_list|,
name|newPoints
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndigits
operator|-
name|index
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|newPoints
operator|.
name|clearBit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|buffer
operator|==
name|digitStr
condition|)
return|return;
name|digitStr
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|smallPoint
condition|)
name|points
operator|=
name|newPoints
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|drawString
name|void
name|QLCDNumberPrivate
operator|::
name|drawString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QPainter
modifier|&
name|p
parameter_list|,
name|QBitArray
modifier|*
name|newPoints
parameter_list|,
name|bool
name|newString
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|QPoint
name|pos
decl_stmt|;
name|int
name|digitSpace
init|=
name|smallPoint
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|xSegLen
init|=
name|q
operator|->
name|width
argument_list|()
operator|*
literal|5
operator|/
operator|(
name|ndigits
operator|*
operator|(
literal|5
operator|+
name|digitSpace
operator|)
operator|+
name|digitSpace
operator|)
decl_stmt|;
name|int
name|ySegLen
init|=
name|q
operator|->
name|height
argument_list|()
operator|*
literal|5
operator|/
literal|12
decl_stmt|;
name|int
name|segLen
init|=
name|ySegLen
operator|>
name|xSegLen
condition|?
name|xSegLen
else|:
name|ySegLen
decl_stmt|;
name|int
name|xAdvance
init|=
name|segLen
operator|*
operator|(
literal|5
operator|+
name|digitSpace
operator|)
operator|/
literal|5
decl_stmt|;
name|int
name|xOffset
init|=
operator|(
name|q
operator|->
name|width
argument_list|()
operator|-
name|ndigits
operator|*
name|xAdvance
operator|+
name|segLen
operator|/
literal|5
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|yOffset
init|=
operator|(
name|q
operator|->
name|height
argument_list|()
operator|-
name|segLen
operator|*
literal|2
operator|)
operator|/
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ndigits
condition|;
name|i
operator|++
control|)
block|{
name|pos
operator|=
name|QPoint
argument_list|(
name|xOffset
operator|+
name|xAdvance
operator|*
name|i
argument_list|,
name|yOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|newString
condition|)
name|drawDigit
argument_list|(
name|pos
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|,
name|s
index|[
name|i
index|]
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|digitStr
index|[
name|i
index|]
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|drawDigit
argument_list|(
name|pos
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|,
name|s
index|[
name|i
index|]
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newPoints
condition|)
block|{
name|char
name|newPoint
init|=
name|newPoints
operator|->
name|testBit
argument_list|(
name|i
argument_list|)
condition|?
literal|'.'
else|:
literal|' '
decl_stmt|;
if|if
condition|(
name|newString
condition|)
block|{
name|char
name|oldPoint
init|=
name|points
operator|.
name|testBit
argument_list|(
name|i
argument_list|)
condition|?
literal|'.'
else|:
literal|' '
decl_stmt|;
name|drawDigit
argument_list|(
name|pos
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|,
name|newPoint
argument_list|,
name|oldPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawDigit
argument_list|(
name|pos
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|,
name|newPoint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|newString
condition|)
block|{
name|digitStr
operator|=
name|s
expr_stmt|;
name|digitStr
operator|.
name|truncate
argument_list|(
name|ndigits
argument_list|)
expr_stmt|;
if|if
condition|(
name|newPoints
condition|)
name|points
operator|=
operator|*
name|newPoints
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|drawDigit
name|void
name|QLCDNumberPrivate
operator|::
name|drawDigit
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
name|QPainter
modifier|&
name|p
parameter_list|,
name|int
name|segLen
parameter_list|,
name|char
name|newCh
parameter_list|,
name|char
name|oldCh
parameter_list|)
block|{
comment|// Draws and/or erases segments to change display of a single digit
comment|// from oldCh to newCh
name|char
name|updates
index|[
literal|18
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|// can hold 2 times number of segments, only
comment|// first 9 used if segment table is correct
name|int
name|nErases
decl_stmt|;
name|int
name|nUpdates
decl_stmt|;
specifier|const
name|char
modifier|*
name|segs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
name|erase
init|=
literal|0
decl_stmt|;
specifier|const
name|char
name|draw
init|=
literal|1
decl_stmt|;
specifier|const
name|char
name|leaveAlone
init|=
literal|2
decl_stmt|;
name|segs
operator|=
name|getSegments
argument_list|(
name|oldCh
argument_list|)
expr_stmt|;
for|for
control|(
name|nErases
operator|=
literal|0
init|;
name|segs
index|[
name|nErases
index|]
operator|!=
literal|99
condition|;
name|nErases
operator|++
control|)
block|{
name|updates
index|[
name|nErases
index|]
index|[
literal|0
index|]
operator|=
name|erase
expr_stmt|;
comment|// get segments to erase to
name|updates
index|[
name|nErases
index|]
index|[
literal|1
index|]
operator|=
name|segs
index|[
name|nErases
index|]
expr_stmt|;
comment|// remove old char
block|}
name|nUpdates
operator|=
name|nErases
expr_stmt|;
name|segs
operator|=
name|getSegments
argument_list|(
name|newCh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|segs
index|[
name|i
index|]
operator|!=
literal|99
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nErases
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|segs
index|[
name|i
index|]
operator|==
name|updates
index|[
name|j
index|]
index|[
literal|1
index|]
condition|)
block|{
comment|// same segment ?
name|updates
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|leaveAlone
expr_stmt|;
comment|// yes, already on screen
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|nErases
condition|)
block|{
comment|// if not already on screen
name|updates
index|[
name|nUpdates
index|]
index|[
literal|0
index|]
operator|=
name|draw
expr_stmt|;
name|updates
index|[
name|nUpdates
index|]
index|[
literal|1
index|]
operator|=
name|segs
index|[
name|i
index|]
expr_stmt|;
name|nUpdates
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUpdates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|updates
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|draw
condition|)
name|drawSegment
argument_list|(
name|pos
argument_list|,
name|updates
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|updates
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|erase
condition|)
name|drawSegment
argument_list|(
name|pos
argument_list|,
name|updates
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|p
argument_list|,
name|segLen
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addPoint
specifier|static
name|void
name|addPoint
parameter_list|(
name|QPolygon
modifier|&
name|a
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|uint
name|n
init|=
name|a
operator|.
name|size
argument_list|()
decl_stmt|;
name|a
operator|.
name|resize
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|.
name|setPoint
argument_list|(
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|drawSegment
name|void
name|QLCDNumberPrivate
operator|::
name|drawSegment
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
name|char
name|segmentNo
parameter_list|,
name|QPainter
modifier|&
name|p
parameter_list|,
name|int
name|segLen
parameter_list|,
name|bool
name|erase
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|QPoint
name|ppt
decl_stmt|;
name|QPoint
name|pt
init|=
name|pos
decl_stmt|;
name|int
name|width
init|=
name|segLen
operator|/
literal|5
decl_stmt|;
specifier|const
name|QPalette
modifier|&
name|pal
init|=
name|q
operator|->
name|palette
argument_list|()
decl_stmt|;
name|QColor
name|lightColor
decl_stmt|,
name|darkColor
decl_stmt|,
name|fgColor
decl_stmt|;
if|if
condition|(
name|erase
condition|)
block|{
name|lightColor
operator|=
name|pal
operator|.
name|color
argument_list|(
name|q
operator|->
name|backgroundRole
argument_list|()
argument_list|)
expr_stmt|;
name|darkColor
operator|=
name|lightColor
expr_stmt|;
name|fgColor
operator|=
name|lightColor
expr_stmt|;
block|}
else|else
block|{
name|lightColor
operator|=
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
name|darkColor
operator|=
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
name|fgColor
operator|=
name|pal
operator|.
name|color
argument_list|(
name|q
operator|->
name|foregroundRole
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|macro|LINETO
define|#
directive|define
name|LINETO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|addPoint(a, QPoint(pt.x() + (X),pt.y() + (Y)))
DECL|macro|LIGHT
define|#
directive|define
name|LIGHT
DECL|macro|DARK
define|#
directive|define
name|DARK
if|if
condition|(
name|fill
condition|)
block|{
name|QPolygon
name|a
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//The following is an exact copy of the switch below.
comment|//don't make any changes here
switch|switch
condition|(
name|segmentNo
condition|)
block|{
case|case
literal|0
case|:
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
operator|-
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
if|if
condition|(
name|width
operator|&
literal|1
condition|)
block|{
comment|// adjust for integer division error
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|3
argument_list|,
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
operator|+
literal|2
argument_list|,
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
name|segLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|smallPoint
condition|)
comment|// if smallpoint place'.' between other digits
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|+
name|width
operator|/
literal|2
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
operator|-
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|segLen
operator|/
literal|2
operator|+
name|width
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
operator|-
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|,
literal|3
operator|*
name|segLen
operator|/
literal|2
operator|+
name|width
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default :
name|qWarning
argument_list|(
literal|"QLCDNumber::drawSegment: (%s) Illegal segment id: %d\n"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|segmentNo
argument_list|)
expr_stmt|;
block|}
comment|// End exact copy
name|p
operator|.
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBrush
argument_list|(
name|fgColor
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawPolygon
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|.
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pos
expr_stmt|;
block|}
DECL|macro|LINETO
undef|#
directive|undef
name|LINETO
DECL|macro|LIGHT
undef|#
directive|undef
name|LIGHT
DECL|macro|DARK
undef|#
directive|undef
name|DARK
DECL|macro|LINETO
define|#
directive|define
name|LINETO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|p.drawLine(ppt.x(), ppt.y(), pt.x()+(X), pt.y()+(Y)); \                     ppt = QPoint(pt.x()+(X), pt.y()+(Y))
DECL|macro|LIGHT
define|#
directive|define
name|LIGHT
value|p.setPen(lightColor)
DECL|macro|DARK
define|#
directive|define
name|DARK
value|p.setPen(darkColor)
if|if
condition|(
name|shadow
condition|)
switch|switch
condition|(
name|segmentNo
condition|)
block|{
case|case
literal|0
case|:
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
operator|-
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
if|if
condition|(
name|width
operator|&
literal|1
condition|)
block|{
comment|// adjust for integer division error
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|3
argument_list|,
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
operator|+
literal|2
argument_list|,
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
name|segLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
name|segLen
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|segLen
operator|-
name|width
operator|-
literal|2
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
operator|-
name|width
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
literal|0
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
name|width
operator|-
literal|1
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|segLen
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|smallPoint
condition|)
comment|// if smallpoint place'.' between other digits
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|+
name|width
operator|/
literal|2
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
argument_list|,
name|segLen
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
operator|-
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|segLen
operator|/
literal|2
operator|+
name|width
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|pt
operator|+=
name|QPoint
argument_list|(
name|segLen
operator|/
literal|2
operator|-
name|width
operator|/
literal|2
operator|+
literal|1
argument_list|,
literal|3
operator|*
name|segLen
operator|/
literal|2
operator|+
name|width
argument_list|)
expr_stmt|;
name|ppt
operator|=
name|pt
expr_stmt|;
name|DARK
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
name|width
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LIGHT
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
operator|-
name|width
argument_list|)
expr_stmt|;
name|LINETO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default :
name|qWarning
argument_list|(
literal|"QLCDNumber::drawSegment: (%s) Illegal segment id: %d\n"
argument_list|,
name|q
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|segmentNo
argument_list|)
expr_stmt|;
block|}
DECL|macro|LINETO
undef|#
directive|undef
name|LINETO
DECL|macro|LIGHT
undef|#
directive|undef
name|LIGHT
DECL|macro|DARK
undef|#
directive|undef
name|DARK
block|}
end_function
begin_comment
comment|/*!     \property QLCDNumber::segmentStyle     \brief the style of the LCDNumber      \table     \header \li Style \li Result     \row \li \c Outline          \li Produces raised segments filled with the background color     \row \li \c Filled             (this is the default).          \li Produces raised segments filled with the foreground color.     \row \li \c Flat          \li Produces flat segments filled with the foreground color.     \endtable      \c Outline and \c Filled will additionally use     QPalette::light() and QPalette::dark() for shadow effects. */
end_comment
begin_function
DECL|function|setSegmentStyle
name|void
name|QLCDNumber
operator|::
name|setSegmentStyle
parameter_list|(
name|SegmentStyle
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLCDNumber
argument_list|)
expr_stmt|;
name|d
operator|->
name|fill
operator|=
operator|(
name|s
operator|==
name|Flat
operator|||
name|s
operator|==
name|Filled
operator|)
expr_stmt|;
name|d
operator|->
name|shadow
operator|=
operator|(
name|s
operator|==
name|Outline
operator|||
name|s
operator|==
name|Filled
operator|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|segmentStyle
name|QLCDNumber
operator|::
name|SegmentStyle
name|QLCDNumber
operator|::
name|segmentStyle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLCDNumber
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|fill
operator|||
name|d
operator|->
name|shadow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fill
operator|&&
name|d
operator|->
name|shadow
condition|)
return|return
name|Outline
return|;
if|if
condition|(
name|d
operator|->
name|fill
operator|&&
name|d
operator|->
name|shadow
condition|)
return|return
name|Filled
return|;
return|return
name|Flat
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QLCDNumber
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
return|return
name|QSize
argument_list|(
literal|10
operator|+
literal|9
operator|*
operator|(
name|digitCount
argument_list|()
operator|+
operator|(
name|smallDecimalPoint
argument_list|()
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|,
literal|23
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QLCDNumber
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
return|return
name|QFrame
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_LCDNUMBER
end_comment
end_unit
