begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|"qabstractslider.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qabstractslider_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QAbstractSlider     \brief The QAbstractSlider class provides an integer value within a range.      \ingroup abstractwidgets     \inmodule QtWidgets      The class is designed as a common super class for widgets like     QScrollBar, QSlider and QDial.      Here are the main properties of the class:      \list 1      \li \l value: The bounded integer that QAbstractSlider maintains.      \li \l minimum: The lowest possible value.      \li \l maximum: The highest possible value.      \li \l singleStep: The smaller of two natural steps that an     abstract sliders provides and typically corresponds to the user     pressing an arrow key.      \li \l pageStep: The larger of two natural steps that an abstract     slider provides and typically corresponds to the user pressing     PageUp or PageDown.      \li \l tracking: Whether slider tracking is enabled.      \li \l sliderPosition: The current position of the slider. If \l     tracking is enabled (the default), this is identical to \l value.      \endlist      Unity (1) may be viewed as a third step size. setValue() lets you     set the current value to any integer in the allowed range, not     just minimum() + \e n * singleStep() for integer values of \e n.     Some widgets may allow the user to set any value at all; others     may just provide multiples of singleStep() or pageStep().      QAbstractSlider emits a comprehensive set of signals:      \table     \header \li Signal \li Emitted when     \row \li \l valueChanged()          \li the value has changed. The \l tracking             determines whether this signal is emitted during user             interaction.     \row \li \l sliderPressed()          \li the user starts to drag the slider.     \row \li \l sliderMoved()          \li the user drags the slider.     \row \li \l sliderReleased()          \li the user releases the slider.     \row \li \l actionTriggered()          \li a slider action was triggerd.     \row \li \l rangeChanged()          \li a the range has changed.     \endtable      QAbstractSlider provides a virtual sliderChange() function that is     well suited for updating the on-screen representation of     sliders. By calling triggerAction(), subclasses trigger slider     actions. Two helper functions QStyle::sliderPositionFromValue() and     QStyle::sliderValueFromPosition() help subclasses and styles to map     screen coordinates to logical range values.      \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example} */
end_comment
begin_comment
comment|/*!     \enum QAbstractSlider::SliderAction      \value SliderNoAction     \value SliderSingleStepAdd     \value SliderSingleStepSub     \value SliderPageStepAdd     \value SliderPageStepSub     \value SliderToMinimum     \value SliderToMaximum     \value SliderMove  */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::valueChanged(int value)      This signal is emitted when the slider value has changed, with the     new slider \a value as argument. */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::sliderPressed()      This signal is emitted when the user presses the slider with the     mouse, or programmatically when setSliderDown(true) is called.      \sa sliderReleased(), sliderMoved(), isSliderDown() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::sliderMoved(int value)      This signal is emitted when sliderDown is true and the slider moves. This     usually happens when the user is dragging the slider. The \a value     is the new slider position.      This signal is emitted even when tracking is turned off.      \sa setTracking(), valueChanged(), isSliderDown(),     sliderPressed(), sliderReleased() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::sliderReleased()      This signal is emitted when the user releases the slider with the     mouse, or programmatically when setSliderDown(false) is called.      \sa sliderPressed(), sliderMoved(), sliderDown */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::rangeChanged(int min, int max)      This signal is emitted when the slider range has changed, with \a     min being the new minimum, and \a max being the new maximum.      \sa minimum, maximum */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSlider::actionTriggered(int action)      This signal is emitted when the slider action \a action is     triggered. Actions are \l SliderSingleStepAdd, \l     SliderSingleStepSub, \l SliderPageStepAdd, \l SliderPageStepSub,     \l SliderToMinimum, \l SliderToMaximum, and \l SliderMove.      When the signal is emitted, the \l sliderPosition has been     adjusted according to the action, but the \l value has not yet     been propagated (meaning the valueChanged() signal was not yet     emitted), and the visual display has not been updated. In slots     connected to this signal you can thus safely adjust any action by     calling setSliderPosition() yourself, based on both the action and     the slider's value.      \sa triggerAction() */
end_comment
begin_comment
comment|/*!     \enum QAbstractSlider::SliderChange      \value SliderRangeChange     \value SliderOrientationChange     \value SliderStepsChange     \value SliderValueChange */
end_comment
begin_constructor
DECL|function|QAbstractSliderPrivate
name|QAbstractSliderPrivate
operator|::
name|QAbstractSliderPrivate
parameter_list|()
member_init_list|:
name|minimum
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maximum
argument_list|(
literal|99
argument_list|)
member_init_list|,
name|pageStep
argument_list|(
literal|10
argument_list|)
member_init_list|,
name|value
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|position
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pressValue
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|singleStep
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|singleStepFromItemView
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|viewMayChangeSingleStep
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|offset_accumulated
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|tracking
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|blocktracking
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pressed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|invertedAppearance
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|invertedControls
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|orientation
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
member_init_list|,
name|repeatAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderNoAction
argument_list|)
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
member_init_list|,
name|isAutoRepeating
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|repeatMultiplier
argument_list|(
literal|1
argument_list|)
block|{
name|firstRepeat
operator|.
name|invalidate
argument_list|()
expr_stmt|;
else|#
directive|else
block|{
endif|#
directive|endif
block|}
DECL|function|~QAbstractSliderPrivate
name|QAbstractSliderPrivate
operator|::
name|~
name|QAbstractSliderPrivate
parameter_list|()
block|{ }
comment|/*!     Sets the slider's minimum to \a min and its maximum to \a max.      If \a max is smaller than \a min, \a min becomes the only legal     value.      \sa minimum, maximum */
DECL|function|setRange
name|void
name|QAbstractSlider
operator|::
name|setRange
parameter_list|(
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|int
name|oldMin
init|=
name|d
operator|->
name|minimum
decl_stmt|;
name|int
name|oldMax
init|=
name|d
operator|->
name|maximum
decl_stmt|;
name|d
operator|->
name|minimum
operator|=
name|min
expr_stmt|;
name|d
operator|->
name|maximum
operator|=
name|qMax
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldMin
operator|!=
name|d
operator|->
name|minimum
operator|||
name|oldMax
operator|!=
name|d
operator|->
name|maximum
condition|)
block|{
name|sliderChange
argument_list|(
name|SliderRangeChange
argument_list|)
expr_stmt|;
emit|emit
name|rangeChanged
argument_list|(
name|d
operator|->
name|minimum
argument_list|,
name|d
operator|->
name|maximum
argument_list|)
emit|;
name|setValue
argument_list|(
name|d
operator|->
name|value
argument_list|)
expr_stmt|;
comment|// re-bound
block|}
block|}
DECL|function|setSteps
name|void
name|QAbstractSliderPrivate
operator|::
name|setSteps
parameter_list|(
name|int
name|single
parameter_list|,
name|int
name|page
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|singleStep
operator|=
name|qAbs
argument_list|(
name|single
argument_list|)
expr_stmt|;
name|pageStep
operator|=
name|qAbs
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|q
operator|->
name|sliderChange
argument_list|(
name|QAbstractSlider
operator|::
name|SliderStepsChange
argument_list|)
expr_stmt|;
block|}
comment|/*!     Constructs an abstract slider.      The \a parent argument is sent to the QWidget constructor.      The \l minimum defaults to 0, the \l maximum to 99, with a \l     singleStep size of 1 and a \l pageStep size of 10, and an initial     \l value of 0. */
DECL|function|QAbstractSlider
name|QAbstractSlider
operator|::
name|QAbstractSlider
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QAbstractSliderPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{ }
comment|/*! \internal */
DECL|function|QAbstractSlider
name|QAbstractSlider
operator|::
name|QAbstractSlider
parameter_list|(
name|QAbstractSliderPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{ }
comment|/*!     Destroys the slider. */
DECL|function|~QAbstractSlider
name|QAbstractSlider
operator|::
name|~
name|QAbstractSlider
parameter_list|()
block|{ }
comment|/*!     \property QAbstractSlider::orientation     \brief the orientation of the slider      The orientation must be \l Qt::Vertical (the default) or \l     Qt::Horizontal. */
DECL|function|setOrientation
name|void
name|QAbstractSlider
operator|::
name|setOrientation
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|orientation
operator|==
name|orientation
condition|)
return|return;
name|d
operator|->
name|orientation
operator|=
name|orientation
expr_stmt|;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|)
condition|)
block|{
name|QSizePolicy
name|sp
init|=
name|sizePolicy
argument_list|()
decl_stmt|;
name|sp
operator|.
name|transpose
argument_list|()
expr_stmt|;
name|setSizePolicy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
DECL|function|orientation
name|Qt
operator|::
name|Orientation
name|QAbstractSlider
operator|::
name|orientation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|orientation
return|;
block|}
comment|/*!     \property QAbstractSlider::minimum     \brief the sliders's minimum value      When setting this property, the \l maximum is adjusted if     necessary to ensure that the range remains valid. Also the     slider's current value is adjusted to be within the new range.  */
DECL|function|setMinimum
name|void
name|QAbstractSlider
operator|::
name|setMinimum
parameter_list|(
name|int
name|min
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|setRange
argument_list|(
name|min
argument_list|,
name|qMax
argument_list|(
name|d
operator|->
name|maximum
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|minimum
name|int
name|QAbstractSlider
operator|::
name|minimum
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minimum
return|;
block|}
comment|/*!     \property QAbstractSlider::maximum     \brief the slider's maximum value      When setting this property, the \l minimum is adjusted if     necessary to ensure that the range remains valid.  Also the     slider's current value is adjusted to be within the new range.   */
DECL|function|setMaximum
name|void
name|QAbstractSlider
operator|::
name|setMaximum
parameter_list|(
name|int
name|max
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|setRange
argument_list|(
name|qMin
argument_list|(
name|d
operator|->
name|minimum
argument_list|,
name|max
argument_list|)
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
DECL|function|maximum
name|int
name|QAbstractSlider
operator|::
name|maximum
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maximum
return|;
block|}
comment|/*!     \property QAbstractSlider::singleStep     \brief the single step.      The smaller of two natural steps that an     abstract sliders provides and typically corresponds to the user     pressing an arrow key.      If the property is modified during an auto repeating key event, behavior     is undefined.      \sa pageStep */
DECL|function|setSingleStep
name|void
name|QAbstractSlider
operator|::
name|setSingleStep
parameter_list|(
name|int
name|step
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewMayChangeSingleStep
operator|=
operator|(
name|step
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|step
argument_list|<
literal|0
operator|&&
name|d
operator|->
name|singleStepFromItemView
argument_list|>
literal|0
condition|)
name|step
operator|=
name|d
operator|->
name|singleStepFromItemView
expr_stmt|;
if|if
condition|(
name|step
operator|!=
name|d
operator|->
name|singleStep
condition|)
name|d
operator|->
name|setSteps
argument_list|(
name|step
argument_list|,
name|d
operator|->
name|pageStep
argument_list|)
expr_stmt|;
block|}
DECL|function|singleStep
name|int
name|QAbstractSlider
operator|::
name|singleStep
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|singleStep
return|;
block|}
comment|/*!     \property QAbstractSlider::pageStep     \brief the page step.      The larger of two natural steps that an abstract slider provides     and typically corresponds to the user pressing PageUp or PageDown.      \sa singleStep */
DECL|function|setPageStep
name|void
name|QAbstractSlider
operator|::
name|setPageStep
parameter_list|(
name|int
name|step
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|!=
name|d
operator|->
name|pageStep
condition|)
name|d
operator|->
name|setSteps
argument_list|(
name|d
operator|->
name|singleStep
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
DECL|function|pageStep
name|int
name|QAbstractSlider
operator|::
name|pageStep
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pageStep
return|;
block|}
comment|/*!     \property QAbstractSlider::tracking     \brief whether slider tracking is enabled      If tracking is enabled (the default), the slider emits the     valueChanged() signal while the slider is being dragged. If     tracking is disabled, the slider emits the valueChanged() signal     only when the user releases the slider.      \sa sliderDown */
DECL|function|setTracking
name|void
name|QAbstractSlider
operator|::
name|setTracking
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|d
operator|->
name|tracking
operator|=
name|enable
expr_stmt|;
block|}
DECL|function|hasTracking
name|bool
name|QAbstractSlider
operator|::
name|hasTracking
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tracking
return|;
block|}
comment|/*!     \property QAbstractSlider::sliderDown     \brief whether the slider is pressed down.      The property is set by subclasses in order to let the abstract     slider know whether or not \l tracking has any effect.      Changing the slider down property emits the sliderPressed() and     sliderReleased() signals.  */
DECL|function|setSliderDown
name|void
name|QAbstractSlider
operator|::
name|setSliderDown
parameter_list|(
name|bool
name|down
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|bool
name|doEmit
init|=
name|d
operator|->
name|pressed
operator|!=
name|down
decl_stmt|;
name|d
operator|->
name|pressed
operator|=
name|down
expr_stmt|;
if|if
condition|(
name|doEmit
condition|)
block|{
if|if
condition|(
name|down
condition|)
emit|emit
name|sliderPressed
argument_list|()
emit|;
else|else
emit|emit
name|sliderReleased
argument_list|()
emit|;
block|}
if|if
condition|(
operator|!
name|down
operator|&&
name|d
operator|->
name|position
operator|!=
name|d
operator|->
name|value
condition|)
name|triggerAction
argument_list|(
name|SliderMove
argument_list|)
expr_stmt|;
block|}
DECL|function|isSliderDown
name|bool
name|QAbstractSlider
operator|::
name|isSliderDown
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pressed
return|;
block|}
comment|/*!     \property QAbstractSlider::sliderPosition     \brief the current slider position      If \l tracking is enabled (the default), this is identical to \l value. */
DECL|function|setSliderPosition
name|void
name|QAbstractSlider
operator|::
name|setSliderPosition
parameter_list|(
name|int
name|position
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|position
operator|=
name|d
operator|->
name|bound
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
name|d
operator|->
name|position
condition|)
return|return;
name|d
operator|->
name|position
operator|=
name|position
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|tracking
condition|)
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pressed
condition|)
emit|emit
name|sliderMoved
argument_list|(
name|position
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|tracking
operator|&&
operator|!
name|d
operator|->
name|blocktracking
condition|)
name|triggerAction
argument_list|(
name|SliderMove
argument_list|)
expr_stmt|;
block|}
DECL|function|sliderPosition
name|int
name|QAbstractSlider
operator|::
name|sliderPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|position
return|;
block|}
comment|/*!     \property QAbstractSlider::value     \brief the slider's current value      The slider forces the value to be within the legal range: \l     minimum<= \c value<= \l maximum.      Changing the value also changes the \l sliderPosition. */
DECL|function|value
name|int
name|QAbstractSlider
operator|::
name|value
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|value
return|;
block|}
DECL|function|setValue
name|void
name|QAbstractSlider
operator|::
name|setValue
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|value
operator|=
name|d
operator|->
name|bound
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|value
operator|==
name|value
operator|&&
name|d
operator|->
name|position
operator|==
name|value
condition|)
return|return;
name|d
operator|->
name|value
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|position
operator|!=
name|value
condition|)
block|{
name|d
operator|->
name|position
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pressed
condition|)
emit|emit
name|sliderMoved
argument_list|(
operator|(
name|d
operator|->
name|position
operator|=
name|value
operator|)
argument_list|)
emit|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleValueChangeEvent
name|event
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|value
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sliderChange
argument_list|(
name|SliderValueChange
argument_list|)
expr_stmt|;
emit|emit
name|valueChanged
argument_list|(
name|value
argument_list|)
emit|;
block|}
comment|/*!     \property QAbstractSlider::invertedAppearance     \brief whether or not a slider shows its values inverted.      If this property is \c false (the default), the minimum and maximum will     be shown in its classic position for the inherited widget. If the     value is true, the minimum and maximum appear at their opposite location.      Note: This property makes most sense for sliders and dials. For     scroll bars, the visual effect of the scroll bar subcontrols depends on     whether or not the styles understand inverted appearance; most styles     ignore this property for scroll bars. */
DECL|function|invertedAppearance
name|bool
name|QAbstractSlider
operator|::
name|invertedAppearance
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|invertedAppearance
return|;
block|}
DECL|function|setInvertedAppearance
name|void
name|QAbstractSlider
operator|::
name|setInvertedAppearance
parameter_list|(
name|bool
name|invert
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|d
operator|->
name|invertedAppearance
operator|=
name|invert
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
comment|/*!     \property QAbstractSlider::invertedControls     \brief whether or not the slider inverts its wheel and key events.      If this property is \c false, scrolling the mouse wheel "up" and using keys     like page up will increase the slider's value towards its maximum. Otherwise     pressing page up will move value towards the slider's minimum. */
DECL|function|invertedControls
name|bool
name|QAbstractSlider
operator|::
name|invertedControls
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|invertedControls
return|;
block|}
DECL|function|setInvertedControls
name|void
name|QAbstractSlider
operator|::
name|setInvertedControls
parameter_list|(
name|bool
name|invert
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|d
operator|->
name|invertedControls
operator|=
name|invert
expr_stmt|;
block|}
comment|/*!  Triggers a slider \a action.  Possible actions are \l   SliderSingleStepAdd, \l SliderSingleStepSub, \l SliderPageStepAdd,   \l SliderPageStepSub, \l SliderToMinimum, \l SliderToMaximum, and \l   SliderMove.    \sa actionTriggered()  */
DECL|function|triggerAction
name|void
name|QAbstractSlider
operator|::
name|triggerAction
parameter_list|(
name|SliderAction
name|action
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|d
operator|->
name|blocktracking
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SliderSingleStepAdd
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
name|d
operator|->
name|effectiveSingleStep
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderSingleStepSub
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
operator|-
name|d
operator|->
name|effectiveSingleStep
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderPageStepAdd
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
name|d
operator|->
name|pageStep
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderPageStepSub
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
operator|-
name|d
operator|->
name|pageStep
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderToMinimum
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|minimum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderToMaximum
case|:
name|setSliderPosition
argument_list|(
name|d
operator|->
name|maximum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SliderMove
case|:
case|case
name|SliderNoAction
case|:
break|break;
block|}
empty_stmt|;
emit|emit
name|actionTriggered
argument_list|(
name|action
argument_list|)
emit|;
name|d
operator|->
name|blocktracking
operator|=
literal|false
expr_stmt|;
name|setValue
argument_list|(
name|d
operator|->
name|position
argument_list|)
expr_stmt|;
block|}
comment|/*!  Sets action \a action to be triggered repetitively in intervals of \a repeatTime, after an initial delay of \a thresholdTime.  \sa triggerAction(), repeatAction()  */
DECL|function|setRepeatAction
name|void
name|QAbstractSlider
operator|::
name|setRepeatAction
parameter_list|(
name|SliderAction
name|action
parameter_list|,
name|int
name|thresholdTime
parameter_list|,
name|int
name|repeatTime
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|repeatAction
operator|=
name|action
operator|)
operator|==
name|SliderNoAction
condition|)
block|{
name|d
operator|->
name|repeatActionTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|repeatActionTime
operator|=
name|repeatTime
expr_stmt|;
name|d
operator|->
name|repeatActionTimer
operator|.
name|start
argument_list|(
name|thresholdTime
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!   Returns the current repeat action.   \sa setRepeatAction()  */
DECL|function|repeatAction
name|QAbstractSlider
operator|::
name|SliderAction
name|QAbstractSlider
operator|::
name|repeatAction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSlider
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|repeatAction
return|;
block|}
comment|/*!\reimp  */
DECL|function|timerEvent
name|void
name|QAbstractSlider
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|repeatActionTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|repeatActionTime
condition|)
block|{
comment|// was threshold time, use repeat time next time
name|d
operator|->
name|repeatActionTimer
operator|.
name|start
argument_list|(
name|d
operator|->
name|repeatActionTime
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|repeatActionTime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|repeatAction
operator|==
name|SliderPageStepAdd
condition|)
name|d
operator|->
name|setAdjustedSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
name|d
operator|->
name|pageStep
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|repeatAction
operator|==
name|SliderPageStepSub
condition|)
name|d
operator|->
name|setAdjustedSliderPosition
argument_list|(
name|d
operator|->
name|overflowSafeAdd
argument_list|(
operator|-
name|d
operator|->
name|pageStep
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|triggerAction
argument_list|(
name|d
operator|->
name|repeatAction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     Reimplement this virtual function to track slider changes such as     \l SliderRangeChange, \l SliderOrientationChange, \l     SliderStepsChange, or \l SliderValueChange. The default     implementation only updates the display and ignores the \a change     parameter.  */
DECL|function|sliderChange
name|void
name|QAbstractSlider
operator|::
name|sliderChange
parameter_list|(
name|SliderChange
parameter_list|)
block|{
name|update
argument_list|()
expr_stmt|;
block|}
DECL|function|scrollByDelta
name|bool
name|QAbstractSliderPrivate
operator|::
name|scrollByDelta
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|int
name|stepsToScroll
init|=
literal|0
decl_stmt|;
comment|// in Qt scrolling to the right gives negative values.
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|qreal
name|offset
init|=
name|qreal
argument_list|(
name|delta
argument_list|)
operator|/
literal|120
decl_stmt|;
if|if
condition|(
operator|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
operator|||
operator|(
name|modifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
operator|)
condition|)
block|{
comment|// Scroll one page regardless of delta:
name|stepsToScroll
operator|=
name|qBound
argument_list|(
operator|-
name|pageStep
argument_list|,
name|int
argument_list|(
name|offset
operator|*
name|pageStep
argument_list|)
argument_list|,
name|pageStep
argument_list|)
expr_stmt|;
name|offset_accumulated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// Calculate how many lines to scroll. Depending on what delta is (and
comment|// offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can
comment|// only scroll whole lines, so we keep the reminder until next event.
name|qreal
name|stepsToScrollF
init|=
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
name|QApplication
operator|::
name|wheelScrollLines
argument_list|()
operator|*
endif|#
directive|endif
name|offset
operator|*
name|effectiveSingleStep
argument_list|()
decl_stmt|;
comment|// Check if wheel changed direction since last event:
if|if
condition|(
name|offset_accumulated
operator|!=
literal|0
operator|&&
operator|(
name|offset
operator|/
name|offset_accumulated
operator|)
operator|<
literal|0
condition|)
name|offset_accumulated
operator|=
literal|0
expr_stmt|;
name|offset_accumulated
operator|+=
name|stepsToScrollF
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_DEAD_CODE_FROM_QT4_MAC
comment|// Don't scroll more than one page in any case:
name|stepsToScroll
operator|=
name|qBound
argument_list|(
operator|-
name|pageStep
argument_list|,
name|int
argument_list|(
name|offset_accumulated
argument_list|)
argument_list|,
name|pageStep
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Native UI-elements on Mac can scroll hundreds of lines at a time as
comment|// a result of acceleration. So keep the same behaviour in Qt, and
comment|// don't restrict stepsToScroll to certain maximum (pageStep):
name|stepsToScroll
operator|=
name|int
argument_list|(
name|offset_accumulated
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset_accumulated
operator|-=
name|int
argument_list|(
name|offset_accumulated
argument_list|)
expr_stmt|;
if|if
condition|(
name|stepsToScroll
operator|==
literal|0
condition|)
block|{
comment|// We moved less than a line, but might still have accumulated partial scroll,
comment|// unless we already are at one of the ends.
specifier|const
name|float
name|effective_offset
init|=
name|invertedControls
condition|?
operator|-
name|offset_accumulated
else|:
name|offset_accumulated
decl_stmt|;
if|if
condition|(
name|effective_offset
operator|>
literal|0.f
operator|&&
name|value
operator|<
name|maximum
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|effective_offset
argument_list|<
literal|0.f
operator|&&
name|value
argument_list|>
name|minimum
condition|)
return|return
literal|true
return|;
name|offset_accumulated
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|invertedControls
condition|)
name|stepsToScroll
operator|=
operator|-
name|stepsToScroll
expr_stmt|;
name|int
name|prevValue
init|=
name|value
decl_stmt|;
name|position
operator|=
name|bound
argument_list|(
name|overflowSafeAdd
argument_list|(
name|stepsToScroll
argument_list|)
argument_list|)
expr_stmt|;
comment|// value will be updated by triggerAction()
name|q
operator|->
name|triggerAction
argument_list|(
name|QAbstractSlider
operator|::
name|SliderMove
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevValue
operator|==
name|value
condition|)
block|{
name|offset_accumulated
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/*!     \reimp */
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
DECL|function|wheelEvent
name|void
name|QAbstractSlider
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|int
name|delta
init|=
name|e
operator|->
name|delta
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|inverted
argument_list|()
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scrollByDelta
argument_list|(
name|e
operator|->
name|orientation
argument_list|()
argument_list|,
name|e
operator|->
name|modifiers
argument_list|()
argument_list|,
name|delta
argument_list|)
condition|)
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*!     \reimp */
DECL|function|keyPressEvent
name|void
name|QAbstractSlider
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
name|SliderAction
name|action
init|=
name|SliderNoAction
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|ev
operator|->
name|isAutoRepeat
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|firstRepeat
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|firstRepeat
operator|.
name|start
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|d
operator|->
name|repeatMultiplier
condition|)
block|{
comment|// This is the interval in milli seconds which one key repetition
comment|// takes.
specifier|const
name|int
name|repeatMSecs
init|=
name|d
operator|->
name|firstRepeat
operator|.
name|elapsed
argument_list|()
decl_stmt|;
comment|/**              * The time it takes to currently navigate the whole slider.              */
specifier|const
name|qreal
name|currentTimeElapse
init|=
operator|(
name|qreal
argument_list|(
name|maximum
argument_list|()
argument_list|)
operator|/
name|singleStep
argument_list|()
operator|)
operator|*
name|repeatMSecs
decl_stmt|;
comment|/**              * This is an arbitrarily determined constant in msecs that              * specifies how long time it should take to navigate from the              * start to the end(excluding starting key auto repeat).              */
specifier|const
name|int
name|SliderRepeatElapse
init|=
literal|2500
decl_stmt|;
name|d
operator|->
name|repeatMultiplier
operator|=
name|currentTimeElapse
operator|/
name|SliderRepeatElapse
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|firstRepeat
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|d
operator|->
name|firstRepeat
operator|.
name|invalidate
argument_list|()
expr_stmt|;
name|d
operator|->
name|repeatMultiplier
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|ev
operator|->
name|key
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
name|setEditFocus
argument_list|(
operator|!
name|hasEditFocus
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setValue
argument_list|(
name|d
operator|->
name|origValue
argument_list|)
expr_stmt|;
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// It seems we need to use invertedAppearance for Left and right, otherwise, things look weird.
case|case
name|Qt
operator|::
name|Key_Left
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// In QApplication::KeypadNavigationDirectional, we want to change the slider
comment|// value if there is no left/right navigation possible and if this slider is not
comment|// inside a tab widget.
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|(
operator|!
name|hasEditFocus
argument_list|()
operator|&&
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
operator|||
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|(
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|||
name|QWidgetPrivate
operator|::
name|inTabWidget
argument_list|(
name|this
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderSingleStepSub
else|:
name|SliderSingleStepAdd
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
name|action
operator|=
name|d
operator|->
name|invertedAppearance
condition|?
name|SliderSingleStepSub
else|:
name|SliderSingleStepAdd
expr_stmt|;
else|else
name|action
operator|=
operator|!
name|d
operator|->
name|invertedAppearance
condition|?
name|SliderSingleStepSub
else|:
name|SliderSingleStepAdd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Right
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// Same logic as in Qt::Key_Left
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|(
operator|!
name|hasEditFocus
argument_list|()
operator|&&
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
operator|||
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|(
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|||
name|QWidgetPrivate
operator|::
name|inTabWidget
argument_list|(
name|this
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderSingleStepAdd
else|:
name|SliderSingleStepSub
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
name|action
operator|=
name|d
operator|->
name|invertedAppearance
condition|?
name|SliderSingleStepAdd
else|:
name|SliderSingleStepSub
expr_stmt|;
else|else
name|action
operator|=
operator|!
name|d
operator|->
name|invertedAppearance
condition|?
name|SliderSingleStepAdd
else|:
name|SliderSingleStepSub
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Up
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// In QApplication::KeypadNavigationDirectional, we want to change the slider
comment|// value if there is no up/down navigation possible.
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|(
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|||
operator|!
name|hasEditFocus
argument_list|()
operator|&&
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
operator|)
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderSingleStepSub
else|:
name|SliderSingleStepAdd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Down
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// Same logic as in Qt::Key_Up
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|(
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
operator|||
name|d
operator|->
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
operator|||
operator|!
name|hasEditFocus
argument_list|()
operator|&&
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
operator|)
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderSingleStepAdd
else|:
name|SliderSingleStepSub
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_PageUp
case|:
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderPageStepSub
else|:
name|SliderPageStepAdd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_PageDown
case|:
name|action
operator|=
name|d
operator|->
name|invertedControls
condition|?
name|SliderPageStepAdd
else|:
name|SliderPageStepSub
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Home
case|:
name|action
operator|=
name|SliderToMinimum
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_End
case|:
name|action
operator|=
name|SliderToMaximum
expr_stmt|;
break|break;
default|default:
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
condition|)
name|triggerAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
comment|/*!     \reimp */
DECL|function|changeEvent
name|void
name|QAbstractSlider
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|EnabledChange
case|:
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
block|{
name|d
operator|->
name|repeatActionTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|setSliderDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// fall through...
default|default:
name|QWidget
operator|::
name|changeEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*!     \reimp */
DECL|function|event
name|bool
name|QAbstractSlider
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|Q_D
argument_list|(
name|QAbstractSlider
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|FocusIn
case|:
name|d
operator|->
name|origValue
operator|=
name|d
operator|->
name|value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|// This function is called from itemviews when doing scroll per pixel (on updateGeometries())
comment|// It will not have any effect if there has been a call to setSingleStep with
comment|// a 'reasonable' value (since viewMayChangeSingleStep will be set to false).
comment|// (If setSingleStep is called with -1 it will however allow the views to change singleStep.)
DECL|function|itemviewChangeSingleStep
name|void
name|QAbstractSliderPrivate
operator|::
name|itemviewChangeSingleStep
parameter_list|(
name|int
name|step
parameter_list|)
block|{
name|singleStepFromItemView
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|viewMayChangeSingleStep
operator|&&
name|singleStep
operator|!=
name|step
condition|)
name|setSteps
argument_list|(
name|step
argument_list|,
name|pageStep
argument_list|)
expr_stmt|;
block|}
name|QT_END_NAMESPACE
end_constructor
begin_include
include|#
directive|include
file|"moc_qabstractslider.cpp"
end_include
end_unit
