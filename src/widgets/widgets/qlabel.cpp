begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qdrawutil.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qabstractbutton.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|"qaction.h"
end_include
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qurl.h>
end_include
begin_include
include|#
directive|include
file|"qlabel_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|<qaccessible.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QLabel     \brief The QLabel widget provides a text or image display.      \ingroup basicwidgets     \inmodule QtWidgets      QLabel is used for displaying text or an image. No user     interaction functionality is provided. The visual appearance of     the label can be configured in various ways, and it can be used     for specifying a focus mnemonic key for another widget.      A QLabel can contain any of the following content types:      \table     \header \li Content \li Setting     \row \li Plain text          \li Pass a QString to setText().     \row \li Rich text          \li Pass a QString that contains rich text to setText().     \row \li A pixmap          \li Pass a QPixmap to setPixmap().     \row \li A movie          \li Pass a QMovie to setMovie().     \row \li A number          \li Pass an \e int or a \e double to setNum(), which converts             the number to plain text.     \row \li Nothing          \li The same as an empty plain text. This is the default. Set             by clear().     \endtable      \warning When passing a QString to the constructor or calling setText(),     make sure to sanitize your input, as QLabel tries to guess whether it     displays the text as plain text or as rich text, a subset of HTML 4     markup. You may want to call     setTextFormat() explicitly, e.g. in case you expect the text to be in     plain format but cannot control the text source (for instance when     displaying data loaded from the Web).      When the content is changed using any of these functions, any     previous content is cleared.      By default, labels display \l{alignment}{left-aligned, vertically-centered}     text and images, where any tabs in the text to be displayed are     \l{Qt::TextExpandTabs}{automatically expanded}. However, the look     of a QLabel can be adjusted and fine-tuned in several ways.      The positioning of the content within the QLabel widget area can     be tuned with setAlignment() and setIndent(). Text content can     also wrap lines along word boundaries with setWordWrap(). For     example, this code sets up a sunken panel with a two-line text in     the bottom right corner (both lines being flush with the right     side of the label):      \snippet code/src_gui_widgets_qlabel.cpp 0      The properties and functions QLabel inherits from QFrame can also     be used to specify the widget frame to be used for any given label.      A QLabel is often used as a label for an interactive widget. For     this use QLabel provides a useful mechanism for adding an     mnemonic (see QKeySequence) that will set the keyboard focus to     the other widget (called the QLabel's "buddy"). For example:      \snippet code/src_gui_widgets_qlabel.cpp 1      In this example, keyboard focus is transferred to the label's     buddy (the QLineEdit) when the user presses Alt+P. If the buddy     was a button (inheriting from QAbstractButton), triggering the     mnemonic would emulate a button click.      \table 100%     \row     \li \inlineimage macintosh-label.png Screenshot of a Macintosh style label     \li A label shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.     \row     \li \inlineimage fusion-label.png Screenshot of a Fusion style label     \li A label shown in the \l{Fusion Style Widget Gallery}{Fusion widget style}.     \row     \li \inlineimage windowsxp-label.png Screenshot of a Windows XP style label     \li A label shown in the \l{Windows XP Style Widget Gallery}{Windows XP widget style}.     \endtable      \sa QLineEdit, QTextEdit, QPixmap, QMovie,         {fowler}{GUI Design Handbook: Label} */
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
comment|/*!     Returns the label's picture or 0 if the label doesn't have a     picture. */
DECL|function|picture
specifier|const
name|QPicture
modifier|*
name|QLabel
operator|::
name|picture
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|picture
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Constructs an empty label.      The \a parent and widget flag \a f, arguments are passed     to the QFrame constructor.      \sa setAlignment(), setFrameStyle(), setIndent() */
end_comment
begin_constructor
DECL|function|QLabel
name|QLabel
operator|::
name|QLabel
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QLabelPrivate
argument_list|()
argument_list|,
name|parent
argument_list|,
name|f
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a label that displays the text, \a text.      The \a parent and widget flag \a f, arguments are passed     to the QFrame constructor.      \sa setText(), setAlignment(), setFrameStyle(), setIndent() */
end_comment
begin_constructor
DECL|function|QLabel
name|QLabel
operator|::
name|QLabel
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|f
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QLabelPrivate
argument_list|()
argument_list|,
name|parent
argument_list|,
name|f
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the label. */
end_comment
begin_destructor
DECL|function|~QLabel
name|QLabel
operator|::
name|~
name|QLabel
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QLabelPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|valid_hints
operator|=
literal|false
expr_stmt|;
name|margin
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
name|movie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|shortcutId
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|pixmap
operator|=
literal|0
expr_stmt|;
name|scaledpixmap
operator|=
literal|0
expr_stmt|;
name|cachedimage
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
name|picture
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|align
operator|=
name|Qt
operator|::
name|AlignLeft
operator||
name|Qt
operator|::
name|AlignVCenter
operator||
name|Qt
operator|::
name|TextExpandTabs
expr_stmt|;
name|indent
operator|=
operator|-
literal|1
expr_stmt|;
name|scaledcontents
operator|=
literal|false
expr_stmt|;
name|textLayoutDirty
operator|=
literal|false
expr_stmt|;
name|textDirty
operator|=
literal|false
expr_stmt|;
name|textformat
operator|=
name|Qt
operator|::
name|AutoText
expr_stmt|;
name|control
operator|=
literal|0
expr_stmt|;
name|textInteractionFlags
operator|=
name|Qt
operator|::
name|LinksAccessibleByMouse
expr_stmt|;
name|isRichText
operator|=
literal|false
expr_stmt|;
name|isTextLabel
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Preferred
argument_list|,
name|QSizePolicy
operator|::
name|Preferred
argument_list|,
name|QSizePolicy
operator|::
name|Label
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|validCursor
operator|=
literal|false
expr_stmt|;
name|onAnchor
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|openExternalLinks
operator|=
literal|false
expr_stmt|;
name|setLayoutItemMargins
argument_list|(
name|QStyle
operator|::
name|SE_LabelLayoutItem
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::text     \brief the label's text      If no text has been set this will return an empty string. Setting     the text clears any previous content.      The text will be interpreted either as plain text or as rich     text, depending on the text format setting; see setTextFormat().     The default setting is Qt::AutoText; i.e. QLabel will try to     auto-detect the format of the text set.     See \l {Supported HTML Subset} for the definition of rich text.      If a buddy has been set, the buddy mnemonic key is updated     from the new text.      Note that QLabel is well-suited to display small rich text     documents, such as small documents that get their document     specific settings (font, text color, link color) from the label's     palette and font properties. For large documents, use QTextEdit     in read-only mode instead. QTextEdit can also provide a scroll bar     when necessary.      \note This function enables mouse tracking if \a text contains rich     text.      \sa setTextFormat(), setBuddy(), alignment */
end_comment
begin_function
DECL|function|setText
name|void
name|QLabel
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|==
name|text
condition|)
return|return;
name|QWidgetTextControl
modifier|*
name|oldControl
init|=
name|d
operator|->
name|control
decl_stmt|;
name|d
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|isTextLabel
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|textDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|isRichText
operator|=
name|d
operator|->
name|textformat
operator|==
name|Qt
operator|::
name|RichText
operator|||
operator|(
name|d
operator|->
name|textformat
operator|==
name|Qt
operator|::
name|AutoText
operator|&&
name|Qt
operator|::
name|mightBeRichText
argument_list|(
name|d
operator|->
name|text
argument_list|)
operator|)
expr_stmt|;
name|d
operator|->
name|control
operator|=
name|oldControl
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needTextControl
argument_list|()
condition|)
block|{
name|d
operator|->
name|ensureTextControl
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|d
operator|->
name|control
expr_stmt|;
name|d
operator|->
name|control
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|isRichText
condition|)
block|{
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note: mouse tracking not disabled intentionally
block|}
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|d
operator|->
name|buddy
condition|)
name|d
operator|->
name|updateShortcut
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|accessibleName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|NameChanged
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|text
name|QString
name|QLabel
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Clears any label contents. */
end_comment
begin_function
DECL|function|clear
name|void
name|QLabel
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::pixmap     \brief the label's pixmap      If no pixmap has been set this will return 0.      Setting the pixmap clears any previous content. The buddy     shortcut, if any, is disabled. */
end_comment
begin_function
DECL|function|setPixmap
name|void
name|QLabel
operator|::
name|setPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|pixmap
operator|||
name|d
operator|->
name|pixmap
operator|->
name|cacheKey
argument_list|()
operator|!=
name|pixmap
operator|.
name|cacheKey
argument_list|()
condition|)
block|{
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
name|d
operator|->
name|pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|pixmap
operator|->
name|depth
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|d
operator|->
name|pixmap
operator|->
name|mask
argument_list|()
condition|)
name|d
operator|->
name|pixmap
operator|->
name|setMask
argument_list|(
operator|*
operator|(
operator|(
name|QBitmap
operator|*
operator|)
name|d
operator|->
name|pixmap
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pixmap
specifier|const
name|QPixmap
modifier|*
name|QLabel
operator|::
name|pixmap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pixmap
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
end_ifndef
begin_comment
comment|/*!     Sets the label contents to \a picture. Any previous content is     cleared.      The buddy shortcut, if any, is disabled.      \sa picture(), setBuddy() */
end_comment
begin_function
DECL|function|setPicture
name|void
name|QLabel
operator|::
name|setPicture
parameter_list|(
specifier|const
name|QPicture
modifier|&
name|picture
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
name|d
operator|->
name|picture
operator|=
operator|new
name|QPicture
argument_list|(
name|picture
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PICTURE
end_comment
begin_comment
comment|/*!     Sets the label contents to plain text containing the textual     representation of integer \a num. Any previous content is cleared.     Does nothing if the integer's string representation is the same as     the current contents of the label.      The buddy shortcut, if any, is disabled.      \sa setText(), QString::setNum(), setBuddy() */
end_comment
begin_function
DECL|function|setNum
name|void
name|QLabel
operator|::
name|setNum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|setNum
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|setText
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the label contents to plain text containing the textual     representation of double \a num. Any previous content is cleared.     Does nothing if the double's string representation is the same as     the current contents of the label.      The buddy shortcut, if any, is disabled.      \sa setText(), QString::setNum(), setBuddy() */
end_comment
begin_function
DECL|function|setNum
name|void
name|QLabel
operator|::
name|setNum
parameter_list|(
name|double
name|num
parameter_list|)
block|{
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|setNum
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|setText
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::alignment     \brief the alignment of the label's contents      By default, the contents of the label are left-aligned and vertically-centered.      \sa text */
end_comment
begin_function
DECL|function|setAlignment
name|void
name|QLabel
operator|::
name|setAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|==
operator|(
name|d
operator|->
name|align
operator|&
operator|(
name|Qt
operator|::
name|AlignVertical_Mask
operator||
name|Qt
operator|::
name|AlignHorizontal_Mask
operator|)
operator|)
condition|)
return|return;
name|d
operator|->
name|align
operator|=
operator|(
name|d
operator|->
name|align
operator|&
operator|~
operator|(
name|Qt
operator|::
name|AlignVertical_Mask
operator||
name|Qt
operator|::
name|AlignHorizontal_Mask
operator|)
operator|)
operator||
operator|(
name|alignment
operator|&
operator|(
name|Qt
operator|::
name|AlignVertical_Mask
operator||
name|Qt
operator|::
name|AlignHorizontal_Mask
operator|)
operator|)
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|alignment
name|Qt
operator|::
name|Alignment
name|QLabel
operator|::
name|alignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|QFlag
argument_list|(
name|d
operator|->
name|align
operator|&
operator|(
name|Qt
operator|::
name|AlignVertical_Mask
operator||
name|Qt
operator|::
name|AlignHorizontal_Mask
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::wordWrap     \brief the label's word-wrapping policy      If this property is true then label text is wrapped where     necessary at word-breaks; otherwise it is not wrapped at all.      By default, word wrap is disabled.      \sa text */
end_comment
begin_function
DECL|function|setWordWrap
name|void
name|QLabel
operator|::
name|setWordWrap
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|d
operator|->
name|align
operator||=
name|Qt
operator|::
name|TextWordWrap
expr_stmt|;
else|else
name|d
operator|->
name|align
operator|&=
operator|~
name|Qt
operator|::
name|TextWordWrap
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wordWrap
name|bool
name|QLabel
operator|::
name|wordWrap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|align
operator|&
name|Qt
operator|::
name|TextWordWrap
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::indent     \brief the label's text indent in pixels      If a label displays text, the indent applies to the left edge if     alignment() is Qt::AlignLeft, to the right edge if alignment() is     Qt::AlignRight, to the top edge if alignment() is Qt::AlignTop, and     to the bottom edge if alignment() is Qt::AlignBottom.      If indent is negative, or if no indent has been set, the label     computes the effective indent as follows: If frameWidth() is 0,     the effective indent becomes 0. If frameWidth() is greater than 0,     the effective indent becomes half the width of the "x" character     of the widget's current font().      By default, the indent is -1, meaning that an effective indent is     calculating in the manner described above.      \sa alignment, margin, frameWidth(), font() */
end_comment
begin_function
DECL|function|setIndent
name|void
name|QLabel
operator|::
name|setIndent
parameter_list|(
name|int
name|indent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|indent
operator|=
name|indent
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|indent
name|int
name|QLabel
operator|::
name|indent
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|indent
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::margin     \brief the width of the margin      The margin is the distance between the innermost pixel of the     frame and the outermost pixel of contents.      The default margin is 0.      \sa indent */
end_comment
begin_function
DECL|function|margin
name|int
name|QLabel
operator|::
name|margin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|margin
return|;
block|}
end_function
begin_function
DECL|function|setMargin
name|void
name|QLabel
operator|::
name|setMargin
parameter_list|(
name|int
name|margin
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|margin
operator|==
name|margin
condition|)
return|return;
name|d
operator|->
name|margin
operator|=
name|margin
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the size that will be used if the width of the label is \a     w. If \a w is -1, the sizeHint() is returned. If \a w is 0 minimumSizeHint() is returned */
end_comment
begin_function
DECL|function|sizeForWidth
name|QSize
name|QLabelPrivate
operator|::
name|sizeForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|minimumWidth
argument_list|()
operator|>
literal|0
condition|)
name|w
operator|=
name|qMax
argument_list|(
name|w
argument_list|,
name|q
operator|->
name|minimumWidth
argument_list|()
argument_list|)
expr_stmt|;
name|QSize
name|contentsMargin
argument_list|(
name|leftmargin
operator|+
name|rightmargin
argument_list|,
name|topmargin
operator|+
name|bottommargin
argument_list|)
decl_stmt|;
name|QRect
name|br
decl_stmt|;
name|int
name|hextra
init|=
literal|2
operator|*
name|margin
decl_stmt|;
name|int
name|vextra
init|=
name|hextra
decl_stmt|;
name|QFontMetrics
name|fm
init|=
name|q
operator|->
name|fontMetrics
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixmap
operator|&&
operator|!
name|pixmap
operator|->
name|isNull
argument_list|()
condition|)
name|br
operator|=
name|pixmap
operator|->
name|rect
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
elseif|else
if|if
condition|(
name|picture
operator|&&
operator|!
name|picture
operator|->
name|isNull
argument_list|()
condition|)
name|br
operator|=
name|picture
operator|->
name|boundingRect
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
elseif|else
if|if
condition|(
name|movie
operator|&&
operator|!
name|movie
operator|->
name|currentPixmap
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|br
operator|=
name|movie
operator|->
name|currentPixmap
argument_list|()
operator|.
name|rect
argument_list|()
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|isTextLabel
condition|)
block|{
name|int
name|align
init|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|textDirection
argument_list|()
argument_list|,
name|QFlag
argument_list|(
name|this
operator|->
name|align
argument_list|)
argument_list|)
decl_stmt|;
comment|// Add indentation
name|int
name|m
init|=
name|indent
decl_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
operator|&&
name|q
operator|->
name|frameWidth
argument_list|()
condition|)
comment|// no indent, but we do have a frame
name|m
operator|=
name|fm
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
argument_list|)
operator|-
name|margin
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|align
operator|&
name|Qt
operator|::
name|AlignLeft
operator|)
operator|||
operator|(
name|align
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
condition|)
name|hextra
operator|+=
name|m
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|&
name|Qt
operator|::
name|AlignTop
operator|)
operator|||
operator|(
name|align
operator|&
name|Qt
operator|::
name|AlignBottom
operator|)
condition|)
name|vextra
operator|+=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|control
condition|)
block|{
name|ensureTextLayouted
argument_list|()
expr_stmt|;
specifier|const
name|qreal
name|oldTextWidth
init|=
name|control
operator|->
name|textWidth
argument_list|()
decl_stmt|;
comment|// Calculate the length of document if w is the width
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|TextWordWrap
condition|)
block|{
if|if
condition|(
name|w
operator|>=
literal|0
condition|)
block|{
name|w
operator|=
name|qMax
argument_list|(
name|w
operator|-
name|hextra
operator|-
name|contentsMargin
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// strip margin and indent
name|control
operator|->
name|setTextWidth
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|control
operator|->
name|adjustSize
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|control
operator|->
name|setTextWidth
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|QSizeF
name|controlSize
init|=
name|control
operator|->
name|size
argument_list|()
decl_stmt|;
name|br
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QSize
argument_list|(
name|qCeil
argument_list|(
name|controlSize
operator|.
name|width
argument_list|()
argument_list|)
argument_list|,
name|qCeil
argument_list|(
name|controlSize
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// restore state
name|control
operator|->
name|setTextWidth
argument_list|(
name|oldTextWidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Turn off center alignment in order to avoid rounding errors for centering,
comment|// since centering involves a division by 2. At the end, all we want is the size.
name|int
name|flags
init|=
name|align
operator|&
operator|~
operator|(
name|Qt
operator|::
name|AlignVCenter
operator||
name|Qt
operator|::
name|AlignHCenter
operator|)
decl_stmt|;
if|if
condition|(
name|hasShortcut
condition|)
block|{
name|flags
operator||=
name|Qt
operator|::
name|TextShowMnemonic
expr_stmt|;
name|QStyleOption
name|opt
decl_stmt|;
name|opt
operator|.
name|initFrom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_UnderlineShortcut
argument_list|,
operator|&
name|opt
argument_list|,
name|q
argument_list|)
condition|)
name|flags
operator||=
name|Qt
operator|::
name|TextHideMnemonic
expr_stmt|;
block|}
name|bool
name|tryWidth
init|=
operator|(
name|w
operator|<
literal|0
operator|)
operator|&&
operator|(
name|align
operator|&
name|Qt
operator|::
name|TextWordWrap
operator|)
decl_stmt|;
if|if
condition|(
name|tryWidth
condition|)
name|w
operator|=
name|qMin
argument_list|(
name|fm
operator|.
name|averageCharWidth
argument_list|()
operator|*
literal|80
argument_list|,
name|q
operator|->
name|maximumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
literal|2000
expr_stmt|;
name|w
operator|-=
operator|(
name|hextra
operator|+
name|contentsMargin
operator|.
name|width
argument_list|()
operator|)
expr_stmt|;
name|br
operator|=
name|fm
operator|.
name|boundingRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
literal|2000
argument_list|,
name|flags
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryWidth
operator|&&
name|br
operator|.
name|height
argument_list|()
operator|<
literal|4
operator|*
name|fm
operator|.
name|lineSpacing
argument_list|()
operator|&&
name|br
operator|.
name|width
argument_list|()
operator|>
name|w
operator|/
literal|2
condition|)
name|br
operator|=
name|fm
operator|.
name|boundingRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
operator|/
literal|2
argument_list|,
literal|2000
argument_list|,
name|flags
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryWidth
operator|&&
name|br
operator|.
name|height
argument_list|()
operator|<
literal|2
operator|*
name|fm
operator|.
name|lineSpacing
argument_list|()
operator|&&
name|br
operator|.
name|width
argument_list|()
operator|>
name|w
operator|/
literal|4
condition|)
name|br
operator|=
name|fm
operator|.
name|boundingRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
operator|/
literal|4
argument_list|,
literal|2000
argument_list|,
name|flags
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|br
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|QSize
argument_list|(
name|fm
operator|.
name|averageCharWidth
argument_list|()
argument_list|,
name|fm
operator|.
name|lineSpacing
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QSize
name|contentsSize
argument_list|(
name|br
operator|.
name|width
argument_list|()
operator|+
name|hextra
argument_list|,
name|br
operator|.
name|height
argument_list|()
operator|+
name|vextra
argument_list|)
decl_stmt|;
return|return
operator|(
name|contentsSize
operator|+
name|contentsMargin
operator|)
operator|.
name|expandedTo
argument_list|(
name|q
operator|->
name|minimumSize
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|heightForWidth
name|int
name|QLabel
operator|::
name|heightForWidth
parameter_list|(
name|int
name|w
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isTextLabel
condition|)
return|return
name|d
operator|->
name|sizeForWidth
argument_list|(
name|w
argument_list|)
operator|.
name|height
argument_list|()
return|;
return|return
name|QWidget
operator|::
name|heightForWidth
argument_list|(
name|w
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::openExternalLinks     \since 4.2      Specifies whether QLabel should automatically open links using     QDesktopServices::openUrl() instead of emitting the     linkActivated() signal.      \b{Note:} The textInteractionFlags set on the label need to include     either LinksAccessibleByMouse or LinksAccessibleByKeyboard.      The default value is false.      \sa textInteractionFlags() */
end_comment
begin_function
DECL|function|openExternalLinks
name|bool
name|QLabel
operator|::
name|openExternalLinks
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|openExternalLinks
return|;
block|}
end_function
begin_function
DECL|function|setOpenExternalLinks
name|void
name|QLabel
operator|::
name|setOpenExternalLinks
parameter_list|(
name|bool
name|open
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|openExternalLinks
operator|=
name|open
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
condition|)
name|d
operator|->
name|control
operator|->
name|setOpenExternalLinks
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::textInteractionFlags     \since 4.2      Specifies how the label should interact with user input if it displays text.      If the flags contain Qt::LinksAccessibleByKeyboard the focus policy is also     automatically set to Qt::StrongFocus. If Qt::TextSelectableByKeyboard is set     then the focus policy is set to Qt::ClickFocus.      The default value is Qt::LinksAccessibleByMouse. */
end_comment
begin_function
DECL|function|setTextInteractionFlags
name|void
name|QLabel
operator|::
name|setTextInteractionFlags
parameter_list|(
name|Qt
operator|::
name|TextInteractionFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|textInteractionFlags
operator|==
name|flags
condition|)
return|return;
name|d
operator|->
name|textInteractionFlags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|LinksAccessibleByKeyboard
condition|)
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|StrongFocus
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|Qt
operator|::
name|TextSelectableByKeyboard
operator||
name|Qt
operator|::
name|TextSelectableByMouse
operator|)
condition|)
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|ClickFocus
argument_list|)
expr_stmt|;
else|else
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|NoFocus
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needTextControl
argument_list|()
condition|)
block|{
name|d
operator|->
name|ensureTextControl
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|d
operator|->
name|control
expr_stmt|;
name|d
operator|->
name|control
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|control
condition|)
name|d
operator|->
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|d
operator|->
name|textInteractionFlags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textInteractionFlags
name|Qt
operator|::
name|TextInteractionFlags
name|QLabel
operator|::
name|textInteractionFlags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textInteractionFlags
return|;
block|}
end_function
begin_comment
comment|/*!     Selects text from position \a start and for \a length characters.      \sa selectedText()      \b{Note:} The textInteractionFlags set on the label need to include     either TextSelectableByMouse or TextSelectableByKeyboard.      \since 4.7 */
end_comment
begin_function
DECL|function|setSelection
name|void
name|QLabel
operator|::
name|setSelection
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
condition|)
block|{
name|d
operator|->
name|ensureTextPopulated
argument_list|()
expr_stmt|;
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|start
operator|+
name|length
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QLabel::hasSelectedText     \brief whether there is any text selected      hasSelectedText() returns true if some or all of the text has been     selected by the user; otherwise returns false.      By default, this property is false.      \sa selectedText()      \b{Note:} The textInteractionFlags set on the label need to include     either TextSelectableByMouse or TextSelectableByKeyboard.      \since 4.7 */
end_comment
begin_function
DECL|function|hasSelectedText
name|bool
name|QLabel
operator|::
name|hasSelectedText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
condition|)
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|hasSelection
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::selectedText     \brief the selected text      If there is no selected text this property's value is     an empty string.      By default, this property contains an empty string.      \sa hasSelectedText()      \b{Note:} The textInteractionFlags set on the label need to include     either TextSelectableByMouse or TextSelectableByKeyboard.      \since 4.7 */
end_comment
begin_function
DECL|function|selectedText
name|QString
name|QLabel
operator|::
name|selectedText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
condition|)
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|selectedText
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     selectionStart() returns the index of the first selected character in the     label or -1 if no text is selected.      \sa selectedText()      \b{Note:} The textInteractionFlags set on the label need to include     either TextSelectableByMouse or TextSelectableByKeyboard.      \since 4.7 */
end_comment
begin_function
DECL|function|selectionStart
name|int
name|QLabel
operator|::
name|selectionStart
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|&&
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|hasSelection
argument_list|()
condition|)
return|return
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|selectionStart
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QLabel
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|valid_hints
condition|)
operator|(
name|void
operator|)
name|QLabel
operator|::
name|minimumSizeHint
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|sh
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QLabel
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|valid_hints
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|sizePolicy
operator|==
name|sizePolicy
argument_list|()
condition|)
return|return
name|d
operator|->
name|msh
return|;
block|}
name|ensurePolished
argument_list|()
expr_stmt|;
name|d
operator|->
name|valid_hints
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|sh
operator|=
name|d
operator|->
name|sizeForWidth
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// wrap ? golden ratio : min doc size
name|QSize
name|msh
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isTextLabel
condition|)
block|{
name|msh
operator|=
name|d
operator|->
name|sh
expr_stmt|;
block|}
else|else
block|{
name|msh
operator|.
name|rheight
argument_list|()
operator|=
name|d
operator|->
name|sizeForWidth
argument_list|(
name|QWIDGETSIZE_MAX
argument_list|)
operator|.
name|height
argument_list|()
expr_stmt|;
comment|// height for one line
name|msh
operator|.
name|rwidth
argument_list|()
operator|=
name|d
operator|->
name|sizeForWidth
argument_list|(
literal|0
argument_list|)
operator|.
name|width
argument_list|()
expr_stmt|;
comment|// wrap ? size of biggest word : min doc size
if|if
condition|(
name|d
operator|->
name|sh
operator|.
name|height
argument_list|()
operator|<
name|msh
operator|.
name|height
argument_list|()
condition|)
name|msh
operator|.
name|rheight
argument_list|()
operator|=
name|d
operator|->
name|sh
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|msh
operator|=
name|msh
expr_stmt|;
name|d
operator|->
name|sizePolicy
operator|=
name|sizePolicy
argument_list|()
expr_stmt|;
return|return
name|msh
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QLabel
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QLabel
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QLabel
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QLabel
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|ev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_CONTEXTMENU
name|Q_UNUSED
argument_list|(
name|ev
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isTextLabel
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|QMenu
modifier|*
name|menu
init|=
name|d
operator|->
name|createStandardContextMenu
argument_list|(
name|ev
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
name|menu
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
expr_stmt|;
name|menu
operator|->
name|popup
argument_list|(
name|ev
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QLabel
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isTextLabel
condition|)
block|{
name|d
operator|->
name|ensureTextControl
argument_list|()
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
name|QFrame
operator|::
name|focusInEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QLabel
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
condition|)
block|{
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|FocusReason
name|reason
init|=
name|ev
operator|->
name|reason
argument_list|()
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|ActiveWindowFocusReason
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
operator|&&
name|cursor
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
name|cursor
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
name|QFrame
operator|::
name|focusOutEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QLabel
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|&&
name|d
operator|->
name|control
operator|->
name|setFocusToNextOrPreviousAnchor
argument_list|(
name|next
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
name|QFrame
operator|::
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QLabel
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendControlEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QLabel
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|QEvent
operator|::
name|Type
name|type
init|=
name|e
operator|->
name|type
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|Shortcut
condition|)
block|{
name|QShortcutEvent
modifier|*
name|se
init|=
cast|static_cast
argument_list|<
name|QShortcutEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|se
operator|->
name|shortcutId
argument_list|()
operator|==
name|d
operator|->
name|shortcutId
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|d
operator|->
name|buddy
decl_stmt|;
name|QAbstractButton
modifier|*
name|button
init|=
name|qobject_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|w
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ShortcutFocusReason
argument_list|)
expr_stmt|;
if|if
condition|(
name|button
operator|&&
operator|!
name|se
operator|->
name|isAmbiguous
argument_list|()
condition|)
name|button
operator|->
name|animateClick
argument_list|()
expr_stmt|;
else|else
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|Resize
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|control
condition|)
name|d
operator|->
name|textLayoutDirty
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|StyleChange
ifdef|#
directive|ifdef
name|Q_OS_MAC
operator|||
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MacSizeChange
endif|#
directive|endif
condition|)
block|{
name|d
operator|->
name|setLayoutItemMargins
argument_list|(
name|QStyle
operator|::
name|SE_LabelLayoutItem
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
return|return
name|QFrame
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QLabel
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|QWidget
operator|::
name|style
argument_list|()
decl_stmt|;
name|QPainter
name|painter
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|drawFrame
argument_list|(
operator|&
name|painter
argument_list|)
expr_stmt|;
name|QRect
name|cr
init|=
name|contentsRect
argument_list|()
decl_stmt|;
name|cr
operator|.
name|adjust
argument_list|(
name|d
operator|->
name|margin
argument_list|,
name|d
operator|->
name|margin
argument_list|,
operator|-
name|d
operator|->
name|margin
argument_list|,
operator|-
name|d
operator|->
name|margin
argument_list|)
expr_stmt|;
name|int
name|align
init|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|d
operator|->
name|isTextLabel
condition|?
name|d
operator|->
name|textDirection
argument_list|()
else|:
name|layoutDirection
argument_list|()
argument_list|,
name|QFlag
argument_list|(
name|d
operator|->
name|align
argument_list|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
if|if
condition|(
name|d
operator|->
name|movie
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|scaledcontents
condition|)
name|style
operator|->
name|drawItemPixmap
argument_list|(
operator|&
name|painter
argument_list|,
name|cr
argument_list|,
name|align
argument_list|,
name|d
operator|->
name|movie
operator|->
name|currentPixmap
argument_list|()
operator|.
name|scaled
argument_list|(
name|cr
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|style
operator|->
name|drawItemPixmap
argument_list|(
operator|&
name|painter
argument_list|,
name|cr
argument_list|,
name|align
argument_list|,
name|d
operator|->
name|movie
operator|->
name|currentPixmap
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|isTextLabel
condition|)
block|{
name|QRectF
name|lr
init|=
name|d
operator|->
name|layoutRect
argument_list|()
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|QStyleOption
name|opt
decl_stmt|;
name|opt
operator|.
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|cssStyle
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|style
argument_list|)
condition|)
block|{
name|cssStyle
operator|->
name|styleSheetPalette
argument_list|(
name|this
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|opt
operator|.
name|palette
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|control
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
specifier|const
name|bool
name|underline
init|=
operator|(
name|bool
operator|)
name|style
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_UnderlineShortcut
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcutId
operator|!=
literal|0
operator|&&
name|underline
operator|!=
name|d
operator|->
name|shortcutCursor
operator|.
name|charFormat
argument_list|()
operator|.
name|fontUnderline
argument_list|()
condition|)
block|{
name|QTextCharFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setFontUnderline
argument_list|(
name|underline
argument_list|)
expr_stmt|;
name|d
operator|->
name|shortcutCursor
operator|.
name|mergeCharFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|ensureTextLayouted
argument_list|()
expr_stmt|;
name|QAbstractTextDocumentLayout
operator|::
name|PaintContext
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|control
operator|&&
comment|// We cannot support etched for rich text controls because custom
comment|// colors and links will override the light palette
name|style
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_EtchDisabledText
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
block|{
name|context
operator|.
name|palette
operator|=
name|opt
operator|.
name|palette
expr_stmt|;
name|context
operator|.
name|palette
operator|.
name|setColor
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|,
name|context
operator|.
name|palette
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|.
name|save
argument_list|()
expr_stmt|;
name|painter
operator|.
name|translate
argument_list|(
name|lr
operator|.
name|x
argument_list|()
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|y
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setClipRect
argument_list|(
name|lr
operator|.
name|translated
argument_list|(
operator|-
name|lr
operator|.
name|x
argument_list|()
operator|-
literal|1
argument_list|,
operator|-
name|lr
operator|.
name|y
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|QAbstractTextDocumentLayout
modifier|*
name|layout
init|=
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|documentLayout
argument_list|()
decl_stmt|;
name|layout
operator|->
name|draw
argument_list|(
operator|&
name|painter
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|painter
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
comment|// Adjust the palette
name|context
operator|.
name|palette
operator|=
name|opt
operator|.
name|palette
expr_stmt|;
if|if
condition|(
name|foregroundRole
argument_list|()
operator|!=
name|QPalette
operator|::
name|Text
operator|&&
name|isEnabled
argument_list|()
condition|)
name|context
operator|.
name|palette
operator|.
name|setColor
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|,
name|context
operator|.
name|palette
operator|.
name|color
argument_list|(
name|foregroundRole
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|.
name|save
argument_list|()
expr_stmt|;
name|painter
operator|.
name|translate
argument_list|(
name|lr
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setClipRect
argument_list|(
name|lr
operator|.
name|translated
argument_list|(
operator|-
name|lr
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|lr
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setPalette
argument_list|(
name|context
operator|.
name|palette
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|drawContents
argument_list|(
operator|&
name|painter
argument_list|,
name|QRectF
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|painter
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|flags
init|=
name|align
operator||
operator|(
name|d
operator|->
name|textDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|Qt
operator|::
name|TextForceLeftToRight
else|:
name|Qt
operator|::
name|TextForceRightToLeft
operator|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasShortcut
condition|)
block|{
name|flags
operator||=
name|Qt
operator|::
name|TextShowMnemonic
expr_stmt|;
if|if
condition|(
operator|!
name|style
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_UnderlineShortcut
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
name|flags
operator||=
name|Qt
operator|::
name|TextHideMnemonic
expr_stmt|;
block|}
name|style
operator|->
name|drawItemText
argument_list|(
operator|&
name|painter
argument_list|,
name|lr
operator|.
name|toRect
argument_list|()
argument_list|,
name|flags
argument_list|,
name|opt
operator|.
name|palette
argument_list|,
name|isEnabled
argument_list|()
argument_list|,
name|d
operator|->
name|text
argument_list|,
name|foregroundRole
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
if|if
condition|(
name|d
operator|->
name|picture
condition|)
block|{
name|QRect
name|br
init|=
name|d
operator|->
name|picture
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|int
name|rw
init|=
name|br
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|rh
init|=
name|br
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|scaledcontents
condition|)
block|{
name|painter
operator|.
name|save
argument_list|()
expr_stmt|;
name|painter
operator|.
name|translate
argument_list|(
name|cr
operator|.
name|x
argument_list|()
argument_list|,
name|cr
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|.
name|scale
argument_list|(
operator|(
name|double
operator|)
name|cr
operator|.
name|width
argument_list|()
operator|/
name|rw
argument_list|,
operator|(
name|double
operator|)
name|cr
operator|.
name|height
argument_list|()
operator|/
name|rh
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawPicture
argument_list|(
operator|-
name|br
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|br
operator|.
name|y
argument_list|()
argument_list|,
operator|*
name|d
operator|->
name|picture
argument_list|)
expr_stmt|;
name|painter
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|xo
init|=
literal|0
decl_stmt|;
name|int
name|yo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignVCenter
condition|)
name|yo
operator|=
operator|(
name|cr
operator|.
name|height
argument_list|()
operator|-
name|rh
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|yo
operator|=
name|cr
operator|.
name|height
argument_list|()
operator|-
name|rh
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|xo
operator|=
name|cr
operator|.
name|width
argument_list|()
operator|-
name|rw
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignHCenter
condition|)
name|xo
operator|=
operator|(
name|cr
operator|.
name|width
argument_list|()
operator|-
name|rw
operator|)
operator|/
literal|2
expr_stmt|;
name|painter
operator|.
name|drawPicture
argument_list|(
name|cr
operator|.
name|x
argument_list|()
operator|+
name|xo
operator|-
name|br
operator|.
name|x
argument_list|()
argument_list|,
name|cr
operator|.
name|y
argument_list|()
operator|+
name|yo
operator|-
name|br
operator|.
name|y
argument_list|()
argument_list|,
operator|*
name|d
operator|->
name|picture
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|pixmap
operator|&&
operator|!
name|d
operator|->
name|pixmap
operator|->
name|isNull
argument_list|()
condition|)
block|{
name|QPixmap
name|pix
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|scaledcontents
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|scaledpixmap
operator|||
name|d
operator|->
name|scaledpixmap
operator|->
name|size
argument_list|()
operator|!=
name|cr
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|cachedimage
condition|)
name|d
operator|->
name|cachedimage
operator|=
operator|new
name|QImage
argument_list|(
name|d
operator|->
name|pixmap
operator|->
name|toImage
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|scaledpixmap
expr_stmt|;
name|d
operator|->
name|scaledpixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|d
operator|->
name|cachedimage
operator|->
name|scaled
argument_list|(
name|cr
operator|.
name|size
argument_list|()
argument_list|,
name|Qt
operator|::
name|IgnoreAspectRatio
argument_list|,
name|Qt
operator|::
name|SmoothTransformation
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pix
operator|=
operator|*
name|d
operator|->
name|scaledpixmap
expr_stmt|;
block|}
else|else
name|pix
operator|=
operator|*
name|d
operator|->
name|pixmap
expr_stmt|;
name|QStyleOption
name|opt
decl_stmt|;
name|opt
operator|.
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
name|pix
operator|=
name|style
operator|->
name|generatedIconPixmap
argument_list|(
name|QIcon
operator|::
name|Disabled
argument_list|,
name|pix
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|style
operator|->
name|drawItemPixmap
argument_list|(
operator|&
name|painter
argument_list|,
name|cr
argument_list|,
name|align
argument_list|,
name|pix
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Updates the label, but not the frame. */
end_comment
begin_function
DECL|function|updateLabel
name|void
name|QLabelPrivate
operator|::
name|updateLabel
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|valid_hints
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|isTextLabel
condition|)
block|{
name|QSizePolicy
name|policy
init|=
name|q
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|wrap
init|=
name|align
operator|&
name|Qt
operator|::
name|TextWordWrap
decl_stmt|;
name|policy
operator|.
name|setHeightForWidth
argument_list|(
name|wrap
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|!=
name|q
operator|->
name|sizePolicy
argument_list|()
condition|)
comment|// ### should be replaced by WA_WState_OwnSizePolicy idiom
name|q
operator|->
name|setSizePolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
name|textLayoutDirty
operator|=
literal|true
expr_stmt|;
block|}
name|q
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
name|q
operator|->
name|update
argument_list|(
name|q
operator|->
name|contentsRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_comment
comment|/*!     Sets this label's buddy to \a buddy.      When the user presses the shortcut key indicated by this label,     the keyboard focus is transferred to the label's buddy widget.      The buddy mechanism is only available for QLabels that contain     text in which one character is prefixed with an ampersand, '&'.     This character is set as the shortcut key. See the \l     QKeySequence::mnemonic() documentation for details (to display an     actual ampersand, use '&&').      In a dialog, you might create two data entry widgets and a label     for each, and set up the geometry layout so each label is just to     the left of its data entry widget (its "buddy"), for example:     \snippet code/src_gui_widgets_qlabel.cpp 2      With the code above, the focus jumps to the Name field when the     user presses Alt+N, and to the Phone field when the user presses     Alt+P.      To unset a previously set buddy, call this function with \a buddy     set to 0.      \sa buddy(), setText(), QShortcut, setAlignment() */
end_comment
begin_function
DECL|function|setBuddy
name|void
name|QLabel
operator|::
name|setBuddy
parameter_list|(
name|QWidget
modifier|*
name|buddy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|buddy
operator|=
name|buddy
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isTextLabel
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|shortcutId
condition|)
name|releaseShortcut
argument_list|(
name|d
operator|->
name|shortcutId
argument_list|)
expr_stmt|;
name|d
operator|->
name|shortcutId
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|textDirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|buddy
condition|)
name|d
operator|->
name|updateShortcut
argument_list|()
expr_stmt|;
comment|// grab new shortcut
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns this label's buddy, or 0 if no buddy is currently set.      \sa setBuddy() */
end_comment
begin_function
DECL|function|buddy
name|QWidget
modifier|*
name|QLabel
operator|::
name|buddy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|buddy
return|;
block|}
end_function
begin_function
DECL|function|updateShortcut
name|void
name|QLabelPrivate
operator|::
name|updateShortcut
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|shortcutId
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Introduce an extra boolean to indicate the presence of a shortcut in the
comment|// text. We cannot use the shortcutId itself because on the mac mnemonics are
comment|// off by default, so QKeySequence::mnemonic always returns an empty sequence.
comment|// But then we do want to hide the ampersands, so we can't use shortcutId.
name|hasShortcut
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|text
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
argument_list|)
condition|)
return|return;
name|hasShortcut
operator|=
literal|true
expr_stmt|;
name|shortcutId
operator|=
name|q
operator|->
name|grabShortcut
argument_list|(
name|QKeySequence
operator|::
name|mnemonic
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SHORTCUT
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
end_ifndef
begin_function
DECL|function|_q_movieUpdated
name|void
name|QLabelPrivate
operator|::
name|_q_movieUpdated
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|movie
operator|&&
name|movie
operator|->
name|isValid
argument_list|()
condition|)
block|{
name|QRect
name|r
decl_stmt|;
if|if
condition|(
name|scaledcontents
condition|)
block|{
name|QRect
name|cr
init|=
name|q
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
name|QRect
name|pixmapRect
argument_list|(
name|cr
operator|.
name|topLeft
argument_list|()
argument_list|,
name|movie
operator|->
name|currentPixmap
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixmapRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|r
operator|.
name|setRect
argument_list|(
name|cr
operator|.
name|left
argument_list|()
argument_list|,
name|cr
operator|.
name|top
argument_list|()
argument_list|,
operator|(
name|rect
operator|.
name|width
argument_list|()
operator|*
name|cr
operator|.
name|width
argument_list|()
operator|)
operator|/
name|pixmapRect
operator|.
name|width
argument_list|()
argument_list|,
operator|(
name|rect
operator|.
name|height
argument_list|()
operator|*
name|cr
operator|.
name|height
argument_list|()
operator|)
operator|/
name|pixmapRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|itemPixmapRect
argument_list|(
name|q
operator|->
name|contentsRect
argument_list|()
argument_list|,
name|align
argument_list|,
name|movie
operator|->
name|currentPixmap
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|setWidth
argument_list|(
name|qMin
argument_list|(
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|setHeight
argument_list|(
name|qMin
argument_list|(
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|update
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_movieResized
name|void
name|QLabelPrivate
operator|::
name|_q_movieResized
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
comment|//we need to refresh the whole background in case the new size is smaler
name|valid_hints
operator|=
literal|false
expr_stmt|;
name|_q_movieUpdated
argument_list|(
name|QRect
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the label contents to \a movie. Any previous content is     cleared. The label does NOT take ownership of the movie.      The buddy shortcut, if any, is disabled.      \sa movie(), setBuddy() */
end_comment
begin_function
DECL|function|setMovie
name|void
name|QLabel
operator|::
name|setMovie
parameter_list|(
name|QMovie
modifier|*
name|movie
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearContents
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|movie
condition|)
return|return;
name|d
operator|->
name|movie
operator|=
name|movie
expr_stmt|;
name|connect
argument_list|(
name|movie
argument_list|,
name|SIGNAL
argument_list|(
name|resized
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_movieResized
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|movie
argument_list|,
name|SIGNAL
argument_list|(
name|updated
argument_list|(
name|QRect
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_movieUpdated
argument_list|(
name|QRect
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Assume that if the movie is running,
comment|// resize/update signals will come soon enough
if|if
condition|(
name|movie
operator|->
name|state
argument_list|()
operator|!=
name|QMovie
operator|::
name|Running
condition|)
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MOVIE
end_comment
begin_comment
comment|/*!   \internal    Clears any contents, without updating/repainting the label. */
end_comment
begin_function
DECL|function|clearContents
name|void
name|QLabelPrivate
operator|::
name|clearContents
parameter_list|()
block|{
operator|delete
name|control
expr_stmt|;
name|control
operator|=
literal|0
expr_stmt|;
name|isTextLabel
operator|=
literal|false
expr_stmt|;
name|hasShortcut
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
operator|delete
name|picture
expr_stmt|;
name|picture
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|delete
name|scaledpixmap
expr_stmt|;
name|scaledpixmap
operator|=
literal|0
expr_stmt|;
operator|delete
name|cachedimage
expr_stmt|;
name|cachedimage
operator|=
literal|0
expr_stmt|;
operator|delete
name|pixmap
expr_stmt|;
name|pixmap
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|shortcutId
condition|)
name|q
operator|->
name|releaseShortcut
argument_list|(
name|shortcutId
argument_list|)
expr_stmt|;
name|shortcutId
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
if|if
condition|(
name|movie
condition|)
block|{
name|QObject
operator|::
name|disconnect
argument_list|(
name|movie
argument_list|,
name|SIGNAL
argument_list|(
name|resized
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_movieResized
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|movie
argument_list|,
name|SIGNAL
argument_list|(
name|updated
argument_list|(
name|QRect
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_movieUpdated
argument_list|(
name|QRect
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|movie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|onAnchor
condition|)
block|{
if|if
condition|(
name|validCursor
condition|)
name|q
operator|->
name|setCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|unsetCursor
argument_list|()
expr_stmt|;
block|}
name|validCursor
operator|=
literal|false
expr_stmt|;
name|onAnchor
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
end_ifndef
begin_comment
comment|/*!     Returns a pointer to the label's movie, or 0 if no movie has been     set.      \sa setMovie() */
end_comment
begin_function
DECL|function|movie
name|QMovie
modifier|*
name|QLabel
operator|::
name|movie
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|movie
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MOVIE
end_comment
begin_comment
comment|/*!     \property QLabel::textFormat     \brief the label's text format      See the Qt::TextFormat enum for an explanation of the possible     options.      The default format is Qt::AutoText.      \sa text() */
end_comment
begin_function
DECL|function|textFormat
name|Qt
operator|::
name|TextFormat
name|QLabel
operator|::
name|textFormat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|textformat
return|;
block|}
end_function
begin_function
DECL|function|setTextFormat
name|void
name|QLabel
operator|::
name|setTextFormat
parameter_list|(
name|Qt
operator|::
name|TextFormat
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|d
operator|->
name|textformat
condition|)
block|{
name|d
operator|->
name|textformat
operator|=
name|format
expr_stmt|;
name|QString
name|t
init|=
name|d
operator|->
name|text
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|->
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setText
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QLabel
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FontChange
operator|||
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ApplicationFontChange
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|isTextLabel
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|control
condition|)
name|d
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|setDefaultFont
argument_list|(
name|font
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|PaletteChange
operator|&&
name|d
operator|->
name|control
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|setPalette
argument_list|(
name|palette
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ContentsRectChange
condition|)
block|{
name|d
operator|->
name|updateLabel
argument_list|()
expr_stmt|;
block|}
name|QFrame
operator|::
name|changeEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLabel::scaledContents     \brief whether the label will scale its contents to fill all     available space.      When enabled and the label shows a pixmap, it will scale the     pixmap to fill the available space.      This property's default is false. */
end_comment
begin_function
DECL|function|hasScaledContents
name|bool
name|QLabel
operator|::
name|hasScaledContents
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|scaledcontents
return|;
block|}
end_function
begin_function
DECL|function|setScaledContents
name|void
name|QLabel
operator|::
name|setScaledContents
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bool
operator|)
name|d
operator|->
name|scaledcontents
operator|==
name|enable
condition|)
return|return;
name|d
operator|->
name|scaledcontents
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
operator|delete
name|d
operator|->
name|scaledpixmap
expr_stmt|;
name|d
operator|->
name|scaledpixmap
operator|=
literal|0
expr_stmt|;
operator|delete
name|d
operator|->
name|cachedimage
expr_stmt|;
name|d
operator|->
name|cachedimage
operator|=
literal|0
expr_stmt|;
block|}
name|update
argument_list|(
name|contentsRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textDirection
name|Qt
operator|::
name|LayoutDirection
name|QLabelPrivate
operator|::
name|textDirection
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|control
condition|)
block|{
name|QTextOption
name|opt
init|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|defaultTextOption
argument_list|()
decl_stmt|;
return|return
name|opt
operator|.
name|textDirection
argument_list|()
return|;
block|}
return|return
name|text
operator|.
name|isRightToLeft
argument_list|()
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
return|;
block|}
end_function
begin_comment
comment|// Returns the rect that is available for us to draw the document
end_comment
begin_function
DECL|function|documentRect
name|QRect
name|QLabelPrivate
operator|::
name|documentRect
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|isTextLabel
argument_list|,
literal|"documentRect"
argument_list|,
literal|"document rect called for label that is not a text label!"
argument_list|)
expr_stmt|;
name|QRect
name|cr
init|=
name|q
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
name|cr
operator|.
name|adjust
argument_list|(
name|margin
argument_list|,
name|margin
argument_list|,
operator|-
name|margin
argument_list|,
operator|-
name|margin
argument_list|)
expr_stmt|;
specifier|const
name|int
name|align
init|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|isTextLabel
condition|?
name|textDirection
argument_list|()
else|:
name|q
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|QFlag
argument_list|(
name|this
operator|->
name|align
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|indent
decl_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
operator|&&
name|q
operator|->
name|frameWidth
argument_list|()
condition|)
comment|// no indent, but we do have a frame
name|m
operator|=
name|q
operator|->
name|fontMetrics
argument_list|()
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
argument_list|)
operator|/
literal|2
operator|-
name|margin
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignLeft
condition|)
name|cr
operator|.
name|setLeft
argument_list|(
name|cr
operator|.
name|left
argument_list|()
operator|+
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|cr
operator|.
name|setRight
argument_list|(
name|cr
operator|.
name|right
argument_list|()
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignTop
condition|)
name|cr
operator|.
name|setTop
argument_list|(
name|cr
operator|.
name|top
argument_list|()
operator|+
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|cr
operator|.
name|setBottom
argument_list|(
name|cr
operator|.
name|bottom
argument_list|()
operator|-
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|cr
return|;
block|}
end_function
begin_function
DECL|function|ensureTextPopulated
name|void
name|QLabelPrivate
operator|::
name|ensureTextPopulated
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|textDirty
condition|)
return|return;
if|if
condition|(
name|control
condition|)
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
if|if
condition|(
name|textDirty
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
if|if
condition|(
name|isRichText
condition|)
name|doc
operator|->
name|setHtml
argument_list|(
name|text
argument_list|)
expr_stmt|;
else|else
name|doc
operator|->
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
else|#
directive|else
name|doc
operator|->
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|doc
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|hasShortcut
condition|)
block|{
comment|// Underline the first character that follows an ampersand (and remove the others ampersands)
name|int
name|from
init|=
literal|0
decl_stmt|;
name|bool
name|found
init|=
literal|false
decl_stmt|;
name|QTextCursor
name|cursor
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|cursor
operator|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|find
argument_list|(
operator|(
name|QLatin1String
argument_list|(
literal|"&"
argument_list|)
operator|)
argument_list|,
name|from
argument_list|)
operator|)
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|cursor
operator|.
name|deleteChar
argument_list|()
expr_stmt|;
comment|// remove the ampersand
name|cursor
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|NextCharacter
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|from
operator|=
name|cursor
operator|.
name|position
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|found
operator|&&
name|cursor
operator|.
name|selectedText
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"&"
argument_list|)
condition|)
block|{
comment|//not a second&
name|found
operator|=
literal|true
expr_stmt|;
name|shortcutCursor
operator|=
name|cursor
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
block|}
name|textDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ensureTextLayouted
name|void
name|QLabelPrivate
operator|::
name|ensureTextLayouted
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|textLayoutDirty
condition|)
return|return;
name|ensureTextPopulated
argument_list|()
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|QTextDocument
modifier|*
name|doc
init|=
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QTextOption
name|opt
init|=
name|doc
operator|->
name|defaultTextOption
argument_list|()
decl_stmt|;
name|opt
operator|.
name|setAlignment
argument_list|(
name|QFlag
argument_list|(
name|this
operator|->
name|align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|align
operator|&
name|Qt
operator|::
name|TextWordWrap
condition|)
name|opt
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|WordWrap
argument_list|)
expr_stmt|;
else|else
name|opt
operator|.
name|setWrapMode
argument_list|(
name|QTextOption
operator|::
name|ManualWrap
argument_list|)
expr_stmt|;
name|doc
operator|->
name|setDefaultTextOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|QTextFrameFormat
name|fmt
init|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|fmt
operator|.
name|setMargin
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|setFrameFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|doc
operator|->
name|setTextWidth
argument_list|(
name|documentRect
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|textLayoutDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ensureTextControl
name|void
name|QLabelPrivate
operator|::
name|ensureTextControl
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isTextLabel
condition|)
return|return;
if|if
condition|(
operator|!
name|control
condition|)
block|{
name|control
operator|=
operator|new
name|QWidgetTextControl
argument_list|(
cast|const_cast
argument_list|<
name|QLabel
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|->
name|document
argument_list|()
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|control
operator|->
name|document
argument_list|()
operator|->
name|setDefaultFont
argument_list|(
name|q
operator|->
name|font
argument_list|()
argument_list|)
expr_stmt|;
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|textInteractionFlags
argument_list|)
expr_stmt|;
name|control
operator|->
name|setOpenExternalLinks
argument_list|(
name|openExternalLinks
argument_list|)
expr_stmt|;
name|control
operator|->
name|setPalette
argument_list|(
name|q
operator|->
name|palette
argument_list|()
argument_list|)
expr_stmt|;
name|control
operator|->
name|setFocus
argument_list|(
name|q
operator|->
name|hasFocus
argument_list|()
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|updateRequest
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|update
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkHovered
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_linkHovered
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkActivated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|linkActivated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|textLayoutDirty
operator|=
literal|true
expr_stmt|;
name|textDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sendControlEvent
name|void
name|QLabelPrivate
operator|::
name|sendControlEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isTextLabel
operator|||
operator|!
name|control
operator|||
name|textInteractionFlags
operator|==
name|Qt
operator|::
name|NoTextInteraction
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|processEvent
argument_list|(
name|e
argument_list|,
operator|-
name|layoutRect
argument_list|()
operator|.
name|topLeft
argument_list|()
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_linkHovered
name|void
name|QLabelPrivate
operator|::
name|_q_linkHovered
parameter_list|(
specifier|const
name|QString
modifier|&
name|anchor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QLabel
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|anchor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// restore cursor
if|if
condition|(
name|validCursor
condition|)
name|q
operator|->
name|setCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|unsetCursor
argument_list|()
expr_stmt|;
name|onAnchor
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|onAnchor
condition|)
block|{
name|validCursor
operator|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|validCursor
condition|)
block|{
name|cursor
operator|=
name|q
operator|->
name|cursor
argument_list|()
expr_stmt|;
block|}
name|q
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|PointingHandCursor
argument_list|)
expr_stmt|;
name|onAnchor
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
emit|emit
name|q
operator|->
name|linkHovered
argument_list|(
name|anchor
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|// Return the layout rect - this is the rect that is given to the layout painting code
end_comment
begin_comment
comment|// This may be different from the document rect since vertical alignment is not
end_comment
begin_comment
comment|// done by the text layout code
end_comment
begin_function
DECL|function|layoutRect
name|QRectF
name|QLabelPrivate
operator|::
name|layoutRect
parameter_list|()
specifier|const
block|{
name|QRectF
name|cr
init|=
name|documentRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|control
condition|)
return|return
name|cr
return|;
name|ensureTextLayouted
argument_list|()
expr_stmt|;
comment|// Caculate y position manually
name|qreal
name|rh
init|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|documentLayout
argument_list|()
operator|->
name|documentSize
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|yo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignVCenter
condition|)
name|yo
operator|=
name|qMax
argument_list|(
operator|(
name|cr
operator|.
name|height
argument_list|()
operator|-
name|rh
operator|)
operator|/
literal|2
argument_list|,
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignBottom
condition|)
name|yo
operator|=
name|qMax
argument_list|(
name|cr
operator|.
name|height
argument_list|()
operator|-
name|rh
argument_list|,
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|(
name|cr
operator|.
name|x
argument_list|()
argument_list|,
name|yo
operator|+
name|cr
operator|.
name|y
argument_list|()
argument_list|,
name|cr
operator|.
name|width
argument_list|()
argument_list|,
name|cr
operator|.
name|height
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Returns the point in the document rect adjusted with p
end_comment
begin_function
DECL|function|layoutPoint
name|QPoint
name|QLabelPrivate
operator|::
name|layoutPoint
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|QRect
name|lr
init|=
name|layoutRect
argument_list|()
operator|.
name|toRect
argument_list|()
decl_stmt|;
return|return
name|p
operator|-
name|lr
operator|.
name|topLeft
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_function
DECL|function|createStandardContextMenu
name|QMenu
modifier|*
name|QLabelPrivate
operator|::
name|createStandardContextMenu
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|QString
name|linkToCopy
decl_stmt|;
name|QPoint
name|p
decl_stmt|;
if|if
condition|(
name|control
operator|&&
name|isRichText
condition|)
block|{
name|p
operator|=
name|layoutPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|linkToCopy
operator|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|documentLayout
argument_list|()
operator|->
name|anchorAt
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linkToCopy
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|control
condition|)
return|return
literal|0
return|;
return|return
name|control
operator|->
name|createStandardContextMenu
argument_list|(
name|p
argument_list|,
name|q_func
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QLabel::linkHovered(const QString&link)     \since 4.2      This signal is emitted when the user hovers over a link. The URL     referred to by the anchor is passed in \a link.      \sa linkActivated() */
end_comment
begin_comment
comment|/*!     \fn void QLabel::linkActivated(const QString&link)     \since 4.2      This signal is emitted when the user clicks a link. The URL     referred to by the anchor is passed in \a link.      \sa linkHovered() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qlabel.cpp"
end_include
end_unit
