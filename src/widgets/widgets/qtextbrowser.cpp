begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextbrowser.h"
end_include
begin_include
include|#
directive|include
file|"qtextedit_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTBROWSER
end_ifndef
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qabstracttextdocumentlayout.h>
end_include
begin_include
include|#
directive|include
file|"private/qtextdocumentlayout_p.h"
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qwhatsthis.h>
end_include
begin_include
include|#
directive|include
file|<qtextobject.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopservices.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QTextBrowserPrivate
class|class
name|QTextBrowserPrivate
super|:
specifier|public
name|QTextEditPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QTextBrowser
parameter_list|)
specifier|public
private|:
DECL|function|QTextBrowserPrivate
specifier|inline
name|QTextBrowserPrivate
parameter_list|()
member_init_list|:
name|textOrSourceChanged
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|forceLoadOnSourceChange
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|openExternalLinks
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|openLinks
argument_list|(
literal|true
argument_list|)
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
member_init_list|,
name|lastKeypadScrollValue
argument_list|(
operator|-
literal|1
argument_list|)
endif|#
directive|endif
block|{}
name|void
name|init
parameter_list|()
function_decl|;
DECL|struct|HistoryEntry
struct|struct
name|HistoryEntry
block|{
DECL|function|HistoryEntry
specifier|inline
name|HistoryEntry
parameter_list|()
member_init_list|:
name|hpos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|vpos
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|focusIndicatorPosition
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|focusIndicatorAnchor
argument_list|(
operator|-
literal|1
argument_list|)
block|{}
DECL|member|url
name|QUrl
name|url
decl_stmt|;
DECL|member|title
name|QString
name|title
decl_stmt|;
DECL|member|hpos
name|int
name|hpos
decl_stmt|;
DECL|member|vpos
name|int
name|vpos
decl_stmt|;
DECL|member|focusIndicatorPosition
DECL|member|focusIndicatorAnchor
name|int
name|focusIndicatorPosition
decl_stmt|,
name|focusIndicatorAnchor
decl_stmt|;
block|}
struct|;
DECL|function|history
name|HistoryEntry
name|history
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
if|if
condition|(
operator|-
name|i
operator|<
name|stack
operator|.
name|count
argument_list|()
condition|)
return|return
name|stack
index|[
name|stack
operator|.
name|count
argument_list|()
operator|+
name|i
operator|-
literal|1
index|]
return|;
else|else
return|return
name|HistoryEntry
argument_list|()
return|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|forwardStack
operator|.
name|count
argument_list|()
condition|)
return|return
name|forwardStack
index|[
name|forwardStack
operator|.
name|count
argument_list|()
operator|-
name|i
index|]
return|;
else|else
return|return
name|HistoryEntry
argument_list|()
return|;
block|}
name|HistoryEntry
name|createHistoryEntry
parameter_list|()
specifier|const
function_decl|;
name|void
name|restoreHistoryEntry
parameter_list|(
specifier|const
name|HistoryEntry
name|entry
parameter_list|)
function_decl|;
DECL|member|stack
name|QStack
argument_list|<
name|HistoryEntry
argument_list|>
name|stack
decl_stmt|;
DECL|member|forwardStack
name|QStack
argument_list|<
name|HistoryEntry
argument_list|>
name|forwardStack
decl_stmt|;
DECL|member|home
name|QUrl
name|home
decl_stmt|;
DECL|member|currentURL
name|QUrl
name|currentURL
decl_stmt|;
DECL|member|searchPaths
name|QStringList
name|searchPaths
decl_stmt|;
comment|/*flag necessary to give the linkClicked() signal some meaningful       semantics when somebody connected to it calls setText() or       setSource() */
DECL|member|textOrSourceChanged
name|bool
name|textOrSourceChanged
decl_stmt|;
DECL|member|forceLoadOnSourceChange
name|bool
name|forceLoadOnSourceChange
decl_stmt|;
DECL|member|openExternalLinks
name|bool
name|openExternalLinks
decl_stmt|;
DECL|member|openLinks
name|bool
name|openLinks
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
DECL|member|oldCursor
name|QCursor
name|oldCursor
decl_stmt|;
endif|#
directive|endif
name|QString
name|findFile
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
DECL|function|_q_documentModified
specifier|inline
name|void
name|_q_documentModified
parameter_list|()
block|{
name|textOrSourceChanged
operator|=
literal|true
expr_stmt|;
name|forceLoadOnSourceChange
operator|=
operator|!
name|currentURL
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
name|void
name|_q_activateAnchor
parameter_list|(
specifier|const
name|QString
modifier|&
name|href
parameter_list|)
function_decl|;
name|void
name|_q_highlightLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|href
parameter_list|)
function_decl|;
name|void
name|setSource
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
function_decl|;
comment|// re-imlemented from QTextEditPrivate
specifier|virtual
name|QUrl
name|resolveUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
function_decl|;
DECL|function|resolveUrl
specifier|inline
name|QUrl
name|resolveUrl
parameter_list|(
specifier|const
name|QString
modifier|&
name|url
parameter_list|)
specifier|const
block|{
return|return
name|resolveUrl
argument_list|(
name|QUrl
argument_list|(
name|url
argument_list|)
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|void
name|keypadMove
parameter_list|(
name|bool
name|next
parameter_list|)
function_decl|;
DECL|member|prevFocus
name|QTextCursor
name|prevFocus
decl_stmt|;
DECL|member|lastKeypadScrollValue
name|int
name|lastKeypadScrollValue
decl_stmt|;
endif|#
directive|endif
block|}
class|;
end_class
begin_function
DECL|function|findFile
name|QString
name|QTextBrowserPrivate
operator|::
name|findFile
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|QString
name|fileName
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"qrc"
argument_list|)
condition|)
block|{
name|fileName
operator|=
name|QLatin1String
argument_list|(
literal|":/"
argument_list|)
operator|+
name|name
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fileName
operator|=
name|name
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
if|if
condition|(
name|name
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"assets"
argument_list|)
condition|)
name|fileName
operator|=
name|QLatin1String
argument_list|(
literal|"assets:"
argument_list|)
operator|+
name|name
operator|.
name|path
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|fileName
operator|=
name|name
operator|.
name|toLocalFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|isAbsolute
argument_list|()
condition|)
return|return
name|fileName
return|;
foreach|foreach
control|(
name|QString
name|path
decl|,
name|searchPaths
control|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|path
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|.
name|append
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|isReadable
argument_list|()
condition|)
return|return
name|path
return|;
block|}
return|return
name|fileName
return|;
block|}
end_function
begin_function
DECL|function|resolveUrl
name|QUrl
name|QTextBrowserPrivate
operator|::
name|resolveUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|url
operator|.
name|isRelative
argument_list|()
condition|)
return|return
name|url
return|;
comment|// For the second case QUrl can merge "#someanchor" with "foo.html"
comment|// correctly to "foo.html#someanchor"
if|if
condition|(
operator|!
operator|(
name|currentURL
operator|.
name|isRelative
argument_list|()
operator|||
operator|(
name|currentURL
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
operator|&&
operator|!
name|QFileInfo
argument_list|(
name|currentURL
operator|.
name|toLocalFile
argument_list|()
argument_list|)
operator|.
name|isAbsolute
argument_list|()
operator|)
operator|)
operator|||
operator|(
name|url
operator|.
name|hasFragment
argument_list|()
operator|&&
name|url
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
name|currentURL
operator|.
name|resolved
argument_list|(
name|url
argument_list|)
return|;
block|}
comment|// this is our last resort when current url and new url are both relative
comment|// we try to resolve against the current working directory in the local
comment|// file system.
name|QFileInfo
name|fi
argument_list|(
name|currentURL
operator|.
name|toLocalFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|fi
operator|.
name|absolutePath
argument_list|()
operator|+
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
operator|.
name|resolved
argument_list|(
name|url
argument_list|)
return|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_function
DECL|function|_q_activateAnchor
name|void
name|QTextBrowserPrivate
operator|::
name|_q_activateAnchor
parameter_list|(
specifier|const
name|QString
modifier|&
name|href
parameter_list|)
block|{
if|if
condition|(
name|href
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|viewport
operator|->
name|setCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QUrl
name|url
init|=
name|resolveUrl
argument_list|(
name|href
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|openLinks
condition|)
block|{
emit|emit
name|q
operator|->
name|anchorClicked
argument_list|(
name|url
argument_list|)
emit|;
return|return;
block|}
name|textOrSourceChanged
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DESKTOPSERVICES
name|bool
name|isFileScheme
init|=
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|||
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"assets"
argument_list|)
endif|#
directive|endif
operator|||
name|url
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"qrc"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|openExternalLinks
operator|&&
operator|!
name|isFileScheme
operator|&&
operator|!
name|url
operator|.
name|isRelative
argument_list|()
operator|)
operator|||
operator|(
name|url
operator|.
name|isRelative
argument_list|()
operator|&&
operator|!
name|currentURL
operator|.
name|isRelative
argument_list|()
operator|&&
operator|!
name|isFileScheme
operator|)
condition|)
block|{
name|QDesktopServices
operator|::
name|openUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
emit|emit
name|q
operator|->
name|anchorClicked
argument_list|(
name|url
argument_list|)
emit|;
if|if
condition|(
name|textOrSourceChanged
condition|)
return|return;
name|q
operator|->
name|setSource
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_highlightLink
name|void
name|QTextBrowserPrivate
operator|::
name|_q_highlightLink
parameter_list|(
specifier|const
name|QString
modifier|&
name|anchor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|viewport
operator|->
name|cursor
argument_list|()
operator|.
name|shape
argument_list|()
operator|!=
name|Qt
operator|::
name|PointingHandCursor
condition|)
name|oldCursor
operator|=
name|viewport
operator|->
name|cursor
argument_list|()
expr_stmt|;
name|viewport
operator|->
name|setCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QUrl
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|viewport
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|PointingHandCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QUrl
name|url
init|=
name|resolveUrl
argument_list|(
name|anchor
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
argument_list|)
emit|;
comment|// convenience to ease connecting to QStatusBar::showMessage(const QString&)
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|setSource
name|void
name|QTextBrowserPrivate
operator|::
name|setSource
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|QApplication
operator|::
name|setOverrideCursor
argument_list|(
name|Qt
operator|::
name|WaitCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|textOrSourceChanged
operator|=
literal|true
expr_stmt|;
name|QString
name|txt
decl_stmt|;
name|bool
name|doSetText
init|=
literal|false
decl_stmt|;
name|QUrl
name|currentUrlWithoutFragment
init|=
name|currentURL
decl_stmt|;
name|currentUrlWithoutFragment
operator|.
name|setFragment
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|QUrl
name|newUrlWithoutFragment
init|=
name|currentURL
operator|.
name|resolved
argument_list|(
name|url
argument_list|)
decl_stmt|;
name|newUrlWithoutFragment
operator|.
name|setFragment
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|url
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|newUrlWithoutFragment
operator|!=
name|currentUrlWithoutFragment
operator|||
name|forceLoadOnSourceChange
operator|)
condition|)
block|{
name|QVariant
name|data
init|=
name|q
operator|->
name|loadResource
argument_list|(
name|QTextDocument
operator|::
name|HtmlResource
argument_list|,
name|resolveUrl
argument_list|(
name|url
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|String
condition|)
block|{
name|txt
operator|=
name|data
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|ByteArray
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|QByteArray
name|ba
init|=
name|data
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
init|=
name|Qt
operator|::
name|codecForHtml
argument_list|(
name|ba
argument_list|)
decl_stmt|;
name|txt
operator|=
name|codec
operator|->
name|toUnicode
argument_list|(
name|ba
argument_list|)
expr_stmt|;
else|#
directive|else
name|txt
operator|=
name|data
operator|.
name|toString
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|txt
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QTextBrowser: No document for %s"
argument_list|,
name|url
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|QString
name|firstTag
init|=
name|txt
operator|.
name|left
argument_list|(
name|txt
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstTag
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"<qt"
argument_list|)
argument_list|)
operator|&&
name|firstTag
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"type"
argument_list|)
argument_list|)
operator|&&
name|firstTag
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"detail"
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|QApplication
operator|::
name|restoreOverrideCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_WHATSTHIS
name|QWhatsThis
operator|::
name|showText
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|,
name|txt
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
name|currentURL
operator|=
name|resolveUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|doSetText
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|home
operator|.
name|isValid
argument_list|()
condition|)
name|home
operator|=
name|url
expr_stmt|;
if|if
condition|(
name|doSetText
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
name|q
operator|->
name|QTextEdit
operator|::
name|setHtml
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|q
operator|->
name|document
argument_list|()
operator|->
name|setMetaInformation
argument_list|(
name|QTextDocument
operator|::
name|DocumentUrl
argument_list|,
name|currentURL
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|QTextEdit
operator|::
name|setPlainText
argument_list|(
name|txt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|prevFocus
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Start
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|forceLoadOnSourceChange
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|fragment
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|q
operator|->
name|scrollToAnchor
argument_list|(
name|url
operator|.
name|fragment
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|lastKeypadScrollValue
operator|=
name|vbar
operator|->
name|value
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QUrl
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|QApplication
operator|::
name|restoreOverrideCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|sourceChanged
argument_list|(
name|url
argument_list|)
emit|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_function
DECL|function|keypadMove
name|void
name|QTextBrowserPrivate
operator|::
name|keypadMove
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
specifier|const
name|int
name|height
init|=
name|viewport
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|overlap
init|=
name|qBound
argument_list|(
literal|20
argument_list|,
name|height
operator|/
literal|5
argument_list|,
literal|40
argument_list|)
decl_stmt|;
comment|// XXX arbitrary, but a good balance
specifier|const
name|int
name|visibleLinkAmount
init|=
name|overlap
decl_stmt|;
comment|// consistent, but maybe not the best choice (?)
name|int
name|yOffset
init|=
name|vbar
operator|->
name|value
argument_list|()
decl_stmt|;
name|int
name|scrollYOffset
init|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|next
condition|?
name|yOffset
operator|+
name|height
operator|-
name|overlap
else|:
name|yOffset
operator|-
name|height
operator|+
name|overlap
argument_list|,
name|vbar
operator|->
name|maximum
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|foundNextAnchor
init|=
literal|false
decl_stmt|;
name|bool
name|focusIt
init|=
literal|false
decl_stmt|;
name|int
name|focusedPos
init|=
operator|-
literal|1
decl_stmt|;
name|QTextCursor
name|anchorToFocus
decl_stmt|;
name|QRectF
name|viewRect
init|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|QRectF
name|newViewRect
init|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|scrollYOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
decl_stmt|;
name|QRectF
name|bothViewRects
init|=
name|viewRect
operator|.
name|united
argument_list|(
name|newViewRect
argument_list|)
decl_stmt|;
comment|// If we don't have a previous anchor, pretend that we had the first/last character
comment|// on the screen selected.
if|if
condition|(
name|prevFocus
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|prevFocus
operator|=
name|control
operator|->
name|cursorForPosition
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prevFocus
operator|=
name|control
operator|->
name|cursorForPosition
argument_list|(
name|QPointF
argument_list|(
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|yOffset
operator|+
name|height
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// First, check to see if someone has moved the scroll bars independently
if|if
condition|(
name|lastKeypadScrollValue
operator|!=
name|yOffset
condition|)
block|{
comment|// Someone (user or programmatically) has moved us, so we might
comment|// need to start looking from the current position instead of prevFocus
name|bool
name|findOnScreen
init|=
literal|true
decl_stmt|;
comment|// If prevFocus is on screen at all, we just use it.
if|if
condition|(
name|prevFocus
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
name|QRectF
name|prevRect
init|=
name|control
operator|->
name|selectionRect
argument_list|(
name|prevFocus
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewRect
operator|.
name|intersects
argument_list|(
name|prevRect
argument_list|)
condition|)
name|findOnScreen
operator|=
literal|false
expr_stmt|;
block|}
comment|// Otherwise, we find a new anchor that's on screen.
comment|// Basically, create a cursor with the last/first character
comment|// on screen
if|if
condition|(
name|findOnScreen
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|prevFocus
operator|=
name|control
operator|->
name|cursorForPosition
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prevFocus
operator|=
name|control
operator|->
name|cursorForPosition
argument_list|(
name|QPointF
argument_list|(
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|yOffset
operator|+
name|height
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|foundNextAnchor
operator|=
name|control
operator|->
name|findNextPrevAnchor
argument_list|(
name|prevFocus
argument_list|,
name|next
argument_list|,
name|anchorToFocus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prevFocus
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
comment|// Check the pathological case that the current anchor is higher
comment|// than the screen, and just scroll through it in that case
name|QRectF
name|prevRect
init|=
name|control
operator|->
name|selectionRect
argument_list|(
name|prevFocus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|&&
name|prevRect
operator|.
name|bottom
argument_list|()
operator|>
operator|(
name|yOffset
operator|+
name|height
operator|)
operator|)
operator|||
operator|(
operator|!
name|next
operator|&&
name|prevRect
operator|.
name|top
argument_list|()
operator|<
name|yOffset
operator|)
condition|)
block|{
name|anchorToFocus
operator|=
name|prevFocus
expr_stmt|;
name|focusedPos
operator|=
name|scrollYOffset
expr_stmt|;
name|focusIt
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// This is the "normal" case - no scroll bar adjustments, no large anchors,
comment|// and no wrapping.
name|foundNextAnchor
operator|=
name|control
operator|->
name|findNextPrevAnchor
argument_list|(
name|prevFocus
argument_list|,
name|next
argument_list|,
name|anchorToFocus
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If not found yet, see if we need to wrap
if|if
condition|(
operator|!
name|focusIt
operator|&&
operator|!
name|foundNextAnchor
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|yOffset
operator|==
name|vbar
operator|->
name|maximum
argument_list|()
condition|)
block|{
name|prevFocus
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|Start
argument_list|)
expr_stmt|;
name|yOffset
operator|=
name|scrollYOffset
operator|=
literal|0
expr_stmt|;
comment|// Refresh the rectangles
name|viewRect
operator|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|newViewRect
operator|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|scrollYOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|bothViewRects
operator|=
name|viewRect
operator|.
name|united
argument_list|(
name|newViewRect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|yOffset
operator|==
literal|0
condition|)
block|{
name|prevFocus
operator|.
name|movePosition
argument_list|(
name|QTextCursor
operator|::
name|End
argument_list|)
expr_stmt|;
name|yOffset
operator|=
name|scrollYOffset
operator|=
name|vbar
operator|->
name|maximum
argument_list|()
expr_stmt|;
comment|// Refresh the rectangles
name|viewRect
operator|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|yOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|newViewRect
operator|=
name|QRectF
argument_list|(
literal|0
argument_list|,
name|scrollYOffset
argument_list|,
name|control
operator|->
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|bothViewRects
operator|=
name|viewRect
operator|.
name|united
argument_list|(
name|newViewRect
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Try looking now
name|foundNextAnchor
operator|=
name|control
operator|->
name|findNextPrevAnchor
argument_list|(
name|prevFocus
argument_list|,
name|next
argument_list|,
name|anchorToFocus
argument_list|)
expr_stmt|;
block|}
comment|// If we did actually find an anchor to use...
if|if
condition|(
name|foundNextAnchor
condition|)
block|{
name|QRectF
name|desiredRect
init|=
name|control
operator|->
name|selectionRect
argument_list|(
name|anchorToFocus
argument_list|)
decl_stmt|;
comment|// XXX This is an arbitrary heuristic
comment|// Decide to focus an anchor if it will be at least be
comment|// in the middle region of the screen after a scroll.
comment|// This can result in partial anchors with focus, but
comment|// insisting on links being completely visible before
comment|// selecting them causes disparities between links that
comment|// take up 90% of the screen height and those that take
comment|// up e.g. 110%
comment|// Obviously if a link is entirely visible, we still
comment|// focus it.
if|if
condition|(
name|bothViewRects
operator|.
name|contains
argument_list|(
name|desiredRect
argument_list|)
operator|||
name|bothViewRects
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
name|visibleLinkAmount
argument_list|,
literal|0
argument_list|,
operator|-
name|visibleLinkAmount
argument_list|)
operator|.
name|intersects
argument_list|(
name|desiredRect
argument_list|)
condition|)
block|{
name|focusIt
operator|=
literal|true
expr_stmt|;
comment|// We aim to put the new link in the middle of the screen,
comment|// unless the link is larger than the screen (we just move to
comment|// display the first page of the link)
if|if
condition|(
name|desiredRect
operator|.
name|height
argument_list|()
operator|>
name|height
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|focusedPos
operator|=
operator|(
name|int
operator|)
name|desiredRect
operator|.
name|top
argument_list|()
expr_stmt|;
else|else
name|focusedPos
operator|=
operator|(
name|int
operator|)
name|desiredRect
operator|.
name|bottom
argument_list|()
operator|-
name|height
expr_stmt|;
block|}
else|else
name|focusedPos
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|desiredRect
operator|.
name|top
argument_list|()
operator|+
name|desiredRect
operator|.
name|bottom
argument_list|()
operator|)
operator|/
literal|2
operator|-
operator|(
name|height
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|// and clamp it to make sure we don't skip content.
if|if
condition|(
name|next
condition|)
name|focusedPos
operator|=
name|qBound
argument_list|(
name|yOffset
argument_list|,
name|focusedPos
argument_list|,
name|scrollYOffset
argument_list|)
expr_stmt|;
else|else
name|focusedPos
operator|=
name|qBound
argument_list|(
name|scrollYOffset
argument_list|,
name|focusedPos
argument_list|,
name|yOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we didn't get a new anchor, check if the old one is still on screen when we scroll
comment|// Note that big (larger than screen height) anchors also have some handling at the
comment|// start of this function.
if|if
condition|(
operator|!
name|focusIt
operator|&&
name|prevFocus
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
name|QRectF
name|desiredRect
init|=
name|control
operator|->
name|selectionRect
argument_list|(
name|prevFocus
argument_list|)
decl_stmt|;
comment|// XXX this may be better off also using the visibleLinkAmount value
if|if
condition|(
name|newViewRect
operator|.
name|intersects
argument_list|(
name|desiredRect
argument_list|)
condition|)
block|{
name|focusedPos
operator|=
name|scrollYOffset
expr_stmt|;
name|focusIt
operator|=
literal|true
expr_stmt|;
name|anchorToFocus
operator|=
name|prevFocus
expr_stmt|;
block|}
block|}
comment|// setTextCursor ensures that the cursor is visible. save& restore
comment|// the scroll bar values therefore
specifier|const
name|int
name|savedXOffset
init|=
name|hbar
operator|->
name|value
argument_list|()
decl_stmt|;
comment|// Now actually process our decision
if|if
condition|(
name|focusIt
operator|&&
name|control
operator|->
name|setFocusToAnchor
argument_list|(
name|anchorToFocus
argument_list|)
condition|)
block|{
comment|// Save the focus for next time
name|prevFocus
operator|=
name|control
operator|->
name|textCursor
argument_list|()
expr_stmt|;
comment|// Scroll
name|vbar
operator|->
name|setValue
argument_list|(
name|focusedPos
argument_list|)
expr_stmt|;
name|lastKeypadScrollValue
operator|=
name|focusedPos
expr_stmt|;
name|hbar
operator|->
name|setValue
argument_list|(
name|savedXOffset
argument_list|)
expr_stmt|;
comment|// Ensure that the new selection is highlighted.
specifier|const
name|QString
name|href
init|=
name|control
operator|->
name|anchorAtCursor
argument_list|()
decl_stmt|;
name|QUrl
name|url
init|=
name|resolveUrl
argument_list|(
name|href
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
emit|;
block|}
else|else
block|{
comment|// Scroll
name|vbar
operator|->
name|setValue
argument_list|(
name|scrollYOffset
argument_list|)
expr_stmt|;
name|lastKeypadScrollValue
operator|=
name|scrollYOffset
expr_stmt|;
comment|// now make sure we don't have a focused anchor
name|QTextCursor
name|cursor
init|=
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|cursor
operator|.
name|clearSelection
argument_list|()
expr_stmt|;
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setValue
argument_list|(
name|savedXOffset
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setValue
argument_list|(
name|scrollYOffset
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QUrl
argument_list|()
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|createHistoryEntry
name|QTextBrowserPrivate
operator|::
name|HistoryEntry
name|QTextBrowserPrivate
operator|::
name|createHistoryEntry
parameter_list|()
specifier|const
block|{
name|HistoryEntry
name|entry
decl_stmt|;
name|entry
operator|.
name|url
operator|=
name|q_func
argument_list|()
operator|->
name|source
argument_list|()
expr_stmt|;
name|entry
operator|.
name|title
operator|=
name|q_func
argument_list|()
operator|->
name|documentTitle
argument_list|()
expr_stmt|;
name|entry
operator|.
name|hpos
operator|=
name|hbar
operator|->
name|value
argument_list|()
expr_stmt|;
name|entry
operator|.
name|vpos
operator|=
name|vbar
operator|->
name|value
argument_list|()
expr_stmt|;
specifier|const
name|QTextCursor
name|cursor
init|=
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
if|if
condition|(
name|control
operator|->
name|cursorIsFocusIndicator
argument_list|()
operator|&&
name|cursor
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
name|entry
operator|.
name|focusIndicatorPosition
operator|=
name|cursor
operator|.
name|position
argument_list|()
expr_stmt|;
name|entry
operator|.
name|focusIndicatorAnchor
operator|=
name|cursor
operator|.
name|anchor
argument_list|()
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function
begin_function
DECL|function|restoreHistoryEntry
name|void
name|QTextBrowserPrivate
operator|::
name|restoreHistoryEntry
parameter_list|(
specifier|const
name|HistoryEntry
name|entry
parameter_list|)
block|{
name|setSource
argument_list|(
name|entry
operator|.
name|url
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setValue
argument_list|(
name|entry
operator|.
name|hpos
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setValue
argument_list|(
name|entry
operator|.
name|vpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|focusIndicatorAnchor
operator|!=
operator|-
literal|1
operator|&&
name|entry
operator|.
name|focusIndicatorPosition
operator|!=
operator|-
literal|1
condition|)
block|{
name|QTextCursor
name|cursor
argument_list|(
name|control
operator|->
name|document
argument_list|()
argument_list|)
decl_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|entry
operator|.
name|focusIndicatorAnchor
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|entry
operator|.
name|focusIndicatorPosition
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
name|control
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|control
operator|->
name|setCursorIsFocusIndicator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|lastKeypadScrollValue
operator|=
name|vbar
operator|->
name|value
argument_list|()
expr_stmt|;
name|prevFocus
operator|=
name|control
operator|->
name|textCursor
argument_list|()
expr_stmt|;
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|href
init|=
name|prevFocus
operator|.
name|charFormat
argument_list|()
operator|.
name|anchorHref
argument_list|()
decl_stmt|;
name|QUrl
name|url
init|=
name|resolveUrl
argument_list|(
name|href
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|highlighted
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \class QTextBrowser     \brief The QTextBrowser class provides a rich text browser with hypertext navigation.      \ingroup richtext-processing     \inmodule QtWidgets      This class extends QTextEdit (in read-only mode), adding some navigation     functionality so that users can follow links in hypertext documents.      If you want to provide your users with an editable rich text editor,     use QTextEdit. If you want a text browser without hypertext navigation     use QTextEdit, and use QTextEdit::setReadOnly() to disable     editing. If you just need to display a small piece of rich text     use QLabel.      \section1 Document Source and Contents      The contents of QTextEdit are set with setHtml() or setPlainText(),     but QTextBrowser also implements the setSource() function, making it     possible to use a named document as the source text. The name is looked     up in a list of search paths and in the directory of the current document     factory.      If a document name ends with     an anchor (for example, "\c #anchor"), the text browser automatically     scrolls to that position (using scrollToAnchor()). When the user clicks     on a hyperlink, the browser will call setSource() itself with the link's     \c href value as argument. You can track the current source by connecting     to the sourceChanged() signal.      \section1 Navigation      QTextBrowser provides backward() and forward() slots which you can     use to implement Back and Forward buttons. The home() slot sets     the text to the very first document displayed. The anchorClicked()     signal is emitted when the user clicks an anchor. To override the     default navigation behavior of the browser, call the setSource()     function to supply new document text in a slot connected to this     signal.      If you want to load documents stored in the Qt resource system use     \c{qrc} as the scheme in the URL to load. For example, for the document     resource path \c{:/docs/index.html} use \c{qrc:/docs/index.html} as     the URL with setSource().      \sa QTextEdit, QTextDocument */
end_comment
begin_comment
comment|/*!     \property QTextBrowser::modified     \brief whether the contents of the text browser have been modified */
end_comment
begin_comment
comment|/*!     \property QTextBrowser::readOnly     \brief whether the text browser is read-only      By default, this property is \c true. */
end_comment
begin_comment
comment|/*!     \property QTextBrowser::undoRedoEnabled     \brief whether the text browser supports undo/redo operations      By default, this property is \c false. */
end_comment
begin_function
DECL|function|init
name|void
name|QTextBrowserPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|Qt
operator|::
name|TextBrowserInteraction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|viewport
operator|->
name|setCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|q
operator|->
name|document
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|contentsChanged
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_documentModified
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkActivated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_activateAnchor
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkHovered
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_highlightLink
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs an empty QTextBrowser with parent \a parent. */
end_comment
begin_constructor
DECL|function|QTextBrowser
name|QTextBrowser
operator|::
name|QTextBrowser
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QTextEdit
argument_list|(
operator|*
operator|new
name|QTextBrowserPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QTextBrowser
name|QTextBrowser
operator|::
name|~
name|QTextBrowser
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \property QTextBrowser::source     \brief the name of the displayed document.      This is a an invalid url if no document is displayed or if the     source is unknown.      When setting this property QTextBrowser tries to find a document     with the specified name in the paths of the searchPaths property     and directory of the current source, unless the value is an absolute     file path. It also checks for optional anchors and scrolls the document     accordingly      If the first tag in the document is \c{<qt type=detail>}, the     document is displayed as a popup rather than as new document in     the browser window itself. Otherwise, the document is displayed     normally in the text browser with the text set to the contents of     the named document with setHtml().      By default, this property contains an empty URL. */
end_comment
begin_function
DECL|function|source
name|QUrl
name|QTextBrowser
operator|::
name|source
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QUrl
argument_list|()
return|;
else|else
return|return
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
operator|.
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextBrowser::searchPaths     \brief the search paths used by the text browser to find supporting     content      QTextBrowser uses this list to locate images and documents.      By default, this property contains an empty string list. */
end_comment
begin_function
DECL|function|searchPaths
name|QStringList
name|QTextBrowser
operator|::
name|searchPaths
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|searchPaths
return|;
block|}
end_function
begin_function
DECL|function|setSearchPaths
name|void
name|QTextBrowser
operator|::
name|setSearchPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|searchPaths
operator|=
name|paths
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Reloads the current set source. */
end_comment
begin_function
DECL|function|reload
name|void
name|QTextBrowser
operator|::
name|reload
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|QUrl
name|s
init|=
name|d
operator|->
name|currentURL
decl_stmt|;
name|d
operator|->
name|currentURL
operator|=
name|QUrl
argument_list|()
expr_stmt|;
name|setSource
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSource
name|void
name|QTextBrowser
operator|::
name|setSource
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
specifier|const
name|QTextBrowserPrivate
operator|::
name|HistoryEntry
name|historyEntry
init|=
name|d
operator|->
name|createHistoryEntry
argument_list|()
decl_stmt|;
name|d
operator|->
name|setSource
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|isValid
argument_list|()
condition|)
return|return;
comment|// the same url you are already watching?
if|if
condition|(
operator|!
name|d
operator|->
name|stack
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
operator|.
name|url
operator|==
name|url
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
operator|=
name|historyEntry
expr_stmt|;
name|QTextBrowserPrivate
operator|::
name|HistoryEntry
name|entry
decl_stmt|;
name|entry
operator|.
name|url
operator|=
name|url
expr_stmt|;
name|entry
operator|.
name|title
operator|=
name|documentTitle
argument_list|()
expr_stmt|;
name|entry
operator|.
name|hpos
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|vpos
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|stack
operator|.
name|push
argument_list|(
name|entry
argument_list|)
expr_stmt|;
emit|emit
name|backwardAvailable
argument_list|(
name|d
operator|->
name|stack
operator|.
name|count
argument_list|()
operator|>
literal|1
argument_list|)
emit|;
if|if
condition|(
operator|!
name|d
operator|->
name|forwardStack
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|forwardStack
operator|.
name|top
argument_list|()
operator|.
name|url
operator|==
name|url
condition|)
block|{
name|d
operator|->
name|forwardStack
operator|.
name|pop
argument_list|()
expr_stmt|;
emit|emit
name|forwardAvailable
argument_list|(
name|d
operator|->
name|forwardStack
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
emit|;
block|}
else|else
block|{
name|d
operator|->
name|forwardStack
operator|.
name|clear
argument_list|()
expr_stmt|;
emit|emit
name|forwardAvailable
argument_list|(
literal|false
argument_list|)
emit|;
block|}
emit|emit
name|historyChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextBrowser::backwardAvailable(bool available)      This signal is emitted when the availability of backward()     changes. \a available is false when the user is at home();     otherwise it is true. */
end_comment
begin_comment
comment|/*!     \fn void QTextBrowser::forwardAvailable(bool available)      This signal is emitted when the availability of forward() changes.     \a available is true after the user navigates backward() and false     when the user navigates or goes forward(). */
end_comment
begin_comment
comment|/*!     \fn void QTextBrowser::historyChanged()     \since 4.4      This signal is emitted when the history changes.      \sa historyTitle(), historyUrl() */
end_comment
begin_comment
comment|/*!     \fn void QTextBrowser::sourceChanged(const QUrl&src)      This signal is emitted when the source has changed, \a src     being the new source.      Source changes happen both programmatically when calling     setSource(), forward(), backword() or home() or when the user     clicks on links or presses the equivalent key sequences. */
end_comment
begin_comment
comment|/*!  \fn void QTextBrowser::highlighted(const QUrl&link)      This signal is emitted when the user has selected but not     activated an anchor in the document. The URL referred to by the     anchor is passed in \a link. */
end_comment
begin_comment
comment|/*!  \fn void QTextBrowser::highlighted(const QString&link)      \overload       Convenience signal that allows connecting to a slot      that takes just a QString, like for example QStatusBar's      message(). */
end_comment
begin_comment
comment|/*!     \fn void QTextBrowser::anchorClicked(const QUrl&link)      This signal is emitted when the user clicks an anchor. The     URL referred to by the anchor is passed in \a link.      Note that the browser will automatically handle navigation to the     location specified by \a link unless the openLinks property     is set to false or you call setSource() in a slot connected.     This mechanism is used to override the default navigation features of the browser. */
end_comment
begin_comment
comment|/*!     Changes the document displayed to the previous document in the     list of documents built by navigating links. Does nothing if there     is no previous document.      \sa forward(), backwardAvailable() */
end_comment
begin_function
DECL|function|backward
name|void
name|QTextBrowser
operator|::
name|backward
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|stack
operator|.
name|count
argument_list|()
operator|<=
literal|1
condition|)
return|return;
comment|// Update the history entry
name|d
operator|->
name|forwardStack
operator|.
name|push
argument_list|(
name|d
operator|->
name|createHistoryEntry
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
comment|// throw away the old version of the current entry
name|d
operator|->
name|restoreHistoryEntry
argument_list|(
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
comment|// previous entry
emit|emit
name|backwardAvailable
argument_list|(
name|d
operator|->
name|stack
operator|.
name|count
argument_list|()
operator|>
literal|1
argument_list|)
emit|;
emit|emit
name|forwardAvailable
argument_list|(
literal|true
argument_list|)
emit|;
emit|emit
name|historyChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Changes the document displayed to the next document in the list of     documents built by navigating links. Does nothing if there is no     next document.      \sa backward(), forwardAvailable() */
end_comment
begin_function
DECL|function|forward
name|void
name|QTextBrowser
operator|::
name|forward
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|forwardStack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Update the history entry
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
operator|=
name|d
operator|->
name|createHistoryEntry
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|stack
operator|.
name|push
argument_list|(
name|d
operator|->
name|forwardStack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|restoreHistoryEntry
argument_list|(
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|backwardAvailable
argument_list|(
literal|true
argument_list|)
emit|;
emit|emit
name|forwardAvailable
argument_list|(
operator|!
name|d
operator|->
name|forwardStack
operator|.
name|isEmpty
argument_list|()
argument_list|)
emit|;
emit|emit
name|historyChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Changes the document displayed to be the first document from     the history. */
end_comment
begin_function
DECL|function|home
name|void
name|QTextBrowser
operator|::
name|home
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|home
operator|.
name|isValid
argument_list|()
condition|)
name|setSource
argument_list|(
name|d
operator|->
name|home
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     The event \a ev is used to provide the following keyboard shortcuts:     \table     \header \li Keypress            \li Action     \row \li Alt+Left Arrow  \li \l backward()     \row \li Alt+Right Arrow \li \l forward()     \row \li Alt+Up Arrow    \li \l home()     \endtable */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QTextBrowser
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|QTextCursor
name|cursor
init|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
decl_stmt|;
name|QTextCharFormat
name|charFmt
init|=
name|cursor
operator|.
name|charFormat
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cursor
operator|.
name|hasSelection
argument_list|()
operator|||
name|charFmt
operator|.
name|anchorHref
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|QTextEdit
operator|::
name|keyPressEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|ev
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ev
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|AltModifier
condition|)
block|{
switch|switch
condition|(
name|ev
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Right
case|:
name|forward
argument_list|()
expr_stmt|;
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
case|case
name|Qt
operator|::
name|Key_Left
case|:
name|backward
argument_list|()
expr_stmt|;
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
case|case
name|Qt
operator|::
name|Key_Up
case|:
name|home
argument_list|()
expr_stmt|;
name|ev
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
else|else
block|{
if|if
condition|(
name|ev
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
condition|)
block|{
name|d
operator|->
name|keypadMove
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
condition|)
block|{
name|d
operator|->
name|keypadMove
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|QTextEdit
operator|::
name|keyPressEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QTextBrowser
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|QTextEdit
operator|::
name|mouseMoveEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QTextBrowser
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|QTextEdit
operator|::
name|mousePressEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QTextBrowser
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|QTextEdit
operator|::
name|mouseReleaseEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QTextBrowser
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|ev
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|setCursor
argument_list|(
operator|(
operator|!
operator|(
name|d
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
operator|)
condition|?
name|d
operator|->
name|oldCursor
else|:
name|Qt
operator|::
name|IBeamCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QTextEdit
operator|::
name|focusOutEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QTextBrowser
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|setFocusToNextOrPreviousAnchor
argument_list|(
name|next
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// Might need to synthesize a highlight event.
if|if
condition|(
name|d
operator|->
name|prevFocus
operator|!=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
operator|.
name|hasSelection
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|href
init|=
name|d
operator|->
name|control
operator|->
name|anchorAtCursor
argument_list|()
decl_stmt|;
name|QUrl
name|url
init|=
name|d
operator|->
name|resolveUrl
argument_list|(
name|href
argument_list|)
decl_stmt|;
emit|emit
name|highlighted
argument_list|(
name|url
argument_list|)
emit|;
emit|emit
name|highlighted
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
emit|;
block|}
name|d
operator|->
name|prevFocus
operator|=
name|d
operator|->
name|control
operator|->
name|textCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// We assume we have no highlight now.
emit|emit
name|highlighted
argument_list|(
name|QUrl
argument_list|()
argument_list|)
emit|;
emit|emit
name|highlighted
argument_list|(
name|QString
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
block|}
return|return
name|QTextEdit
operator|::
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QTextBrowser
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
decl_stmt|;
name|d
operator|->
name|paint
argument_list|(
operator|&
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called when the document is loaded and for     each image in the document. The \a type indicates the type of resource     to be loaded. An invalid QVariant is returned if the resource cannot be     loaded.      The default implementation ignores \a type and tries to locate     the resources by interpreting \a name as a file name. If it is     not an absolute path it tries to find the file in the paths of     the \l searchPaths property and in the same directory as the     current source. On success, the result is a QVariant that stores     a QByteArray with the contents of the file.      If you reimplement this function, you can return other QVariant     types. The table below shows which variant types are supported     depending on the resource type:      \table     \header \li ResourceType  \li QVariant::Type     \row    \li QTextDocument::HtmlResource  \li QString or QByteArray     \row    \li QTextDocument::ImageResource \li QImage, QPixmap or QByteArray     \row    \li QTextDocument::StyleSheetResource \li QString or QByteArray     \endtable */
end_comment
begin_function
DECL|function|loadResource
name|QVariant
name|QTextBrowser
operator|::
name|loadResource
parameter_list|(
name|int
comment|/*type*/
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|QByteArray
name|data
decl_stmt|;
name|QString
name|fileName
init|=
name|d
operator|->
name|findFile
argument_list|(
name|d
operator|->
name|resolveUrl
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|QFile
name|f
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|data
operator|=
name|f
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns \c true if the text browser can go backward in the document history     using backward().      \sa backwardAvailable(), backward() */
end_comment
begin_function
DECL|function|isBackwardAvailable
name|bool
name|QTextBrowser
operator|::
name|isBackwardAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|stack
operator|.
name|count
argument_list|()
operator|>
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns \c true if the text browser can go forward in the document history     using forward().      \sa forwardAvailable(), forward() */
end_comment
begin_function
DECL|function|isForwardAvailable
name|bool
name|QTextBrowser
operator|::
name|isForwardAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
operator|!
name|d
operator|->
name|forwardStack
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Clears the history of visited documents and disables the forward and     backward navigation.      \sa backward(), forward() */
end_comment
begin_function
DECL|function|clearHistory
name|void
name|QTextBrowser
operator|::
name|clearHistory
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|forwardStack
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QTextBrowserPrivate
operator|::
name|HistoryEntry
name|historyEntry
init|=
name|d
operator|->
name|stack
operator|.
name|top
argument_list|()
decl_stmt|;
name|d
operator|->
name|stack
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|stack
operator|.
name|push
argument_list|(
name|historyEntry
argument_list|)
expr_stmt|;
name|d
operator|->
name|home
operator|=
name|historyEntry
operator|.
name|url
expr_stmt|;
block|}
emit|emit
name|forwardAvailable
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|backwardAvailable
argument_list|(
literal|false
argument_list|)
emit|;
emit|emit
name|historyChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!    Returns the url of the HistoryItem.      \table     \header \li Input            \li Return     \row \li \a{i}< 0  \li \l backward() history     \row \li\a{i} == 0 \li current, see QTextBrowser::source()     \row \li \a{i}> 0  \li \l forward() history     \endtable      \since 4.4 */
end_comment
begin_function
DECL|function|historyUrl
name|QUrl
name|QTextBrowser
operator|::
name|historyUrl
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|history
argument_list|(
name|i
argument_list|)
operator|.
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the documentTitle() of the HistoryItem.      \table     \header \li Input            \li Return     \row \li \a{i}< 0  \li \l backward() history     \row \li \a{i} == 0 \li current, see QTextBrowser::source()     \row \li \a{i}> 0  \li \l forward() history     \endtable      \snippet code/src_gui_widgets_qtextbrowser.cpp 0      \since 4.4 */
end_comment
begin_function
DECL|function|historyTitle
name|QString
name|QTextBrowser
operator|::
name|historyTitle
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|history
argument_list|(
name|i
argument_list|)
operator|.
name|title
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of locations forward in the history.      \since 4.4 */
end_comment
begin_function
DECL|function|forwardHistoryCount
name|int
name|QTextBrowser
operator|::
name|forwardHistoryCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|forwardStack
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of locations backward in the history.      \since 4.4 */
end_comment
begin_function
DECL|function|backwardHistoryCount
name|int
name|QTextBrowser
operator|::
name|backwardHistoryCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|stack
operator|.
name|count
argument_list|()
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextBrowser::openExternalLinks     \since 4.2      Specifies whether QTextBrowser should automatically open links to external     sources using QDesktopServices::openUrl() instead of emitting the     anchorClicked signal. Links are considered external if their scheme is     neither file or qrc.      The default value is false. */
end_comment
begin_function
DECL|function|openExternalLinks
name|bool
name|QTextBrowser
operator|::
name|openExternalLinks
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|openExternalLinks
return|;
block|}
end_function
begin_function
DECL|function|setOpenExternalLinks
name|void
name|QTextBrowser
operator|::
name|setOpenExternalLinks
parameter_list|(
name|bool
name|open
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|openExternalLinks
operator|=
name|open
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \property QTextBrowser::openLinks    \since 4.3     This property specifies whether QTextBrowser should automatically open links the user tries to    activate by mouse or keyboard.     Regardless of the value of this property the anchorClicked signal is always emitted.     The default value is true. */
end_comment
begin_function
DECL|function|openLinks
name|bool
name|QTextBrowser
operator|::
name|openLinks
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBrowser
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|openLinks
return|;
block|}
end_function
begin_function
DECL|function|setOpenLinks
name|void
name|QTextBrowser
operator|::
name|setOpenLinks
parameter_list|(
name|bool
name|open
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBrowser
argument_list|)
expr_stmt|;
name|d
operator|->
name|openLinks
operator|=
name|open
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QTextBrowser
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
return|return
name|QTextEdit
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qtextbrowser.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTBROWSER
end_comment
end_unit
