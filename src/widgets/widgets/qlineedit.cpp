begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlineedit.h"
end_include
begin_include
include|#
directive|include
file|"qlineedit_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LINEEDIT
end_ifndef
begin_include
include|#
directive|include
file|"qaction.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qdrag.h"
end_include
begin_include
include|#
directive|include
file|"qdrawutil.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qfontmetrics.h"
end_include
begin_include
include|#
directive|include
file|"qstylehints.h"
end_include
begin_include
include|#
directive|include
file|"qmenu.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qpointer.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|"qvalidator.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qwhatsthis.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qtextedit.h"
end_include
begin_include
include|#
directive|include
file|<private/qtextedit_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qabstractitemview.h"
end_include
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_include
include|#
directive|include
file|"private/qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qshortcutmap_p.h"
end_include
begin_include
include|#
directive|include
file|"qkeysequence.h"
end_include
begin_define
DECL|macro|ACCEL_KEY
define|#
directive|define
name|ACCEL_KEY
parameter_list|(
name|k
parameter_list|)
value|(!qApp->d_func()->shortcutMap.hasShortcutForKeySequence(k) ? \                       QLatin1Char('\t') + QKeySequence(k).toString(QKeySequence::NativeText) : QString())
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ACCEL_KEY
define|#
directive|define
name|ACCEL_KEY
parameter_list|(
name|k
parameter_list|)
value|QString()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|DrawText
end_ifdef
begin_undef
DECL|macro|DrawText
undef|#
directive|undef
name|DrawText
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|Q_WS_MAC
specifier|extern
name|void
name|qt_mac_secure_keyboard
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//qapplication_mac.cpp
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Initialize \a option with the values from this QLineEdit. This method     is useful for subclasses when they need a QStyleOptionFrame or QStyleOptionFrameV2, but don't want     to fill in all the information themselves. This function will check the version     of the QStyleOptionFrame and fill in the additional values for a     QStyleOptionFrameV2.      \sa QStyleOption::initFrom() */
end_comment
begin_function
DECL|function|initStyleOption
name|void
name|QLineEdit
operator|::
name|initStyleOption
parameter_list|(
name|QStyleOptionFrame
modifier|*
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|option
condition|)
return|return;
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
name|option
operator|->
name|initFrom
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|option
operator|->
name|rect
operator|=
name|contentsRect
argument_list|()
expr_stmt|;
name|option
operator|->
name|lineWidth
operator|=
name|d
operator|->
name|frame
condition|?
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_DefaultFrameWidth
argument_list|,
name|option
argument_list|,
name|this
argument_list|)
else|:
literal|0
expr_stmt|;
name|option
operator|->
name|midLineWidth
operator|=
literal|0
expr_stmt|;
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_ReadOnly
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|hasEditFocus
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_HasEditFocus
expr_stmt|;
endif|#
directive|endif
name|option
operator|->
name|features
operator|=
name|QStyleOptionFrame
operator|::
name|None
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QLineEdit     \brief The QLineEdit widget is a one-line text editor.      \ingroup basicwidgets     \inmodule QtWidgets      A line edit allows the user to enter and edit a single line of     plain text with a useful collection of editing functions,     including undo and redo, cut and paste, and drag and drop.      By changing the echoMode() of a line edit, it can also be used as     a "write-only" field, for inputs such as passwords.      The length of the text can be constrained to maxLength(). The text     can be arbitrarily constrained using a validator() or an     inputMask(), or both. When switching between a validator and an input mask     on the same line edit, it is best to clear the validator or input mask to     prevent undefined behavior.       A related class is QTextEdit which allows multi-line, rich text     editing.      You can change the text with setText() or insert(). The text is     retrieved with text(); the displayed text (which may be different,     see \l{EchoMode}) is retrieved with displayText(). Text can be     selected with setSelection() or selectAll(), and the selection can     be cut(), copy()ied and paste()d. The text can be aligned with     setAlignment().      When the text changes the textChanged() signal is emitted; when     the text changes other than by calling setText() the textEdited()     signal is emitted; when the cursor is moved the     cursorPositionChanged() signal is emitted; and when the Return or     Enter key is pressed the returnPressed() signal is emitted.      When editing is finished, either because the line edit lost focus     or Return/Enter is pressed the editingFinished() signal is     emitted.      Note that if there is a validator set on the line edit, the     returnPressed()/editingFinished() signals will only be emitted if     the validator returns QValidator::Acceptable.      By default, QLineEdits have a frame as specified by platform     style guides; you can turn it off by calling     setFrame(false).      The default key bindings are described below. The line edit also     provides a context menu (usually invoked by a right mouse click)     that presents some of these editing options.     \target desc     \table     \header \li Keypress \li Action     \row \li Left Arrow \li Moves the cursor one character to the left.     \row \li Shift+Left Arrow \li Moves and selects text one character to the left.     \row \li Right Arrow \li Moves the cursor one character to the right.     \row \li Shift+Right Arrow \li Moves and selects text one character to the right.     \row \li Home \li Moves the cursor to the beginning of the line.     \row \li End \li Moves the cursor to the end of the line.     \row \li Backspace \li Deletes the character to the left of the cursor.     \row \li Ctrl+Backspace \li Deletes the word to the left of the cursor.     \row \li Delete \li Deletes the character to the right of the cursor.     \row \li Ctrl+Delete \li Deletes the word to the right of the cursor.     \row \li Ctrl+A \li Select all.     \row \li Ctrl+C \li Copies the selected text to the clipboard.     \row \li Ctrl+Insert \li Copies the selected text to the clipboard.     \row \li Ctrl+K \li Deletes to the end of the line.     \row \li Ctrl+V \li Pastes the clipboard text into line edit.     \row \li Shift+Insert \li Pastes the clipboard text into line edit.     \row \li Ctrl+X \li Deletes the selected text and copies it to the clipboard.     \row \li Shift+Delete \li Deletes the selected text and copies it to the clipboard.     \row \li Ctrl+Z \li Undoes the last operation.     \row \li Ctrl+Y \li Redoes the last undone operation.     \endtable      Any other key sequence that represents a valid character, will     cause the character to be inserted into the line edit.      \table 100%     \row \li \inlineimage macintosh-lineedit.png Screenshot of a Macintosh style line edit          \li A line edit shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.     \row \li \inlineimage windowsvista-lineedit.png Screenshot of a Windows Vista style line edit          \li A line edit shown in the \l{Windows Vista Style Widget Gallery}{Windows Vista widget style}.     \row \li \inlineimage fusion-lineedit.png Screenshot of a Fusion style line edit          \li A line edit shown in the \l{Fusion Style Widget Gallery}{Fusion widget style}.     \endtable      \sa QTextEdit, QLabel, QComboBox, {fowler}{GUI Design Handbook: Field, Entry}, {Line Edits Example} */
end_comment
begin_comment
comment|/*!     \fn void QLineEdit::textChanged(const QString&text)      This signal is emitted whenever the text changes. The \a text     argument is the new text.      Unlike textEdited(), this signal is also emitted when the text is     changed programmatically, for example, by calling setText(). */
end_comment
begin_comment
comment|/*!     \fn void QLineEdit::textEdited(const QString&text)      This signal is emitted whenever the text is edited. The \a text     argument is the new text.      Unlike textChanged(), this signal is not emitted when the text is     changed programmatically, for example, by calling setText(). */
end_comment
begin_comment
comment|/*!     \fn void QLineEdit::cursorPositionChanged(int old, int new)      This signal is emitted whenever the cursor moves. The previous     position is given by \a old, and the new position by \a new.      \sa setCursorPosition(), cursorPosition() */
end_comment
begin_comment
comment|/*!     \fn void QLineEdit::selectionChanged()      This signal is emitted whenever the selection changes.      \sa hasSelectedText(), selectedText() */
end_comment
begin_comment
comment|/*!     Constructs a line edit with no text.      The maximum text length is set to 32767 characters.      The \a parent argument is sent to the QWidget constructor.      \sa setText(), setMaxLength() */
end_comment
begin_constructor
DECL|function|QLineEdit
name|QLineEdit
operator|::
name|QLineEdit
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QLineEditPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a line edit containing the text \a contents.      The cursor position is set to the end of the line and the maximum     text length to 32767 characters.      The \a parent and argument is sent to the QWidget     constructor.      \sa text(), setMaxLength() */
end_comment
begin_constructor
DECL|function|QLineEdit
name|QLineEdit
operator|::
name|QLineEdit
parameter_list|(
specifier|const
name|QString
modifier|&
name|contents
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QLineEditPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the line edit. */
end_comment
begin_destructor
DECL|function|~QLineEdit
name|QLineEdit
operator|::
name|~
name|QLineEdit
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \property QLineEdit::text     \brief the line edit's text      Setting this property clears the selection, clears the undo/redo     history, moves the cursor to the end of the line and resets the     \l modified property to false. The text is not validated when     inserted with setText().      The text is truncated to maxLength() length.      By default, this property contains an empty string.      \sa insert(), clear() */
end_comment
begin_function
DECL|function|text
name|QString
name|QLineEdit
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setText
name|void
name|QLineEdit
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      \property QLineEdit::placeholderText     \brief the line edit's placeholder text      Setting this property makes the line edit display a grayed-out     placeholder text as long as the text() is empty and the widget doesn't     have focus.      By default, this property contains an empty string.      \sa text() */
end_comment
begin_function
DECL|function|placeholderText
name|QString
name|QLineEdit
operator|::
name|placeholderText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|placeholderText
return|;
block|}
end_function
begin_function
DECL|function|setPlaceholderText
name|void
name|QLineEdit
operator|::
name|setPlaceholderText
parameter_list|(
specifier|const
name|QString
modifier|&
name|placeholderText
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|placeholderText
operator|!=
name|placeholderText
condition|)
block|{
name|d
operator|->
name|placeholderText
operator|=
name|placeholderText
expr_stmt|;
if|if
condition|(
operator|!
name|hasFocus
argument_list|()
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::displayText     \brief the displayed text      If \l echoMode is \l Normal this returns the same as text(); if     \l EchoMode is \l Password or \l PasswordEchoOnEdit it returns a string of asterisks     text().length() characters long, e.g. "******"; if \l EchoMode is     \l NoEcho returns an empty string, "".      By default, this property contains an empty string.      \sa setEchoMode(), text(), EchoMode */
end_comment
begin_function
DECL|function|displayText
name|QString
name|QLineEdit
operator|::
name|displayText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|displayText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::maxLength     \brief the maximum permitted length of the text      If the text is too long, it is truncated at the limit.      If truncation occurs any selected text will be unselected, the     cursor position is set to 0 and the first part of the string is     shown.      If the line edit has an input mask, the mask defines the maximum     string length.      By default, this property contains a value of 32767.      \sa inputMask */
end_comment
begin_function
DECL|function|maxLength
name|int
name|QLineEdit
operator|::
name|maxLength
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|maxLength
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setMaxLength
name|void
name|QLineEdit
operator|::
name|setMaxLength
parameter_list|(
name|int
name|maxLength
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setMaxLength
argument_list|(
name|maxLength
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::frame     \brief whether the line edit draws itself with a frame      If enabled (the default) the line edit draws itself inside a     frame, otherwise the line edit draws itself without any frame. */
end_comment
begin_function
DECL|function|hasFrame
name|bool
name|QLineEdit
operator|::
name|hasFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|frame
return|;
block|}
end_function
begin_function
DECL|function|setFrame
name|void
name|QLineEdit
operator|::
name|setFrame
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|frame
operator|=
name|enable
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QLineEdit::EchoMode      This enum type describes how a line edit should display its     contents.      \value Normal   Display characters as they are entered. This is the                     default.     \value NoEcho   Do not display anything. This may be appropriate                     for passwords where even the length of the                     password should be kept secret.     \value Password  Display asterisks instead of the characters                     actually entered.     \value PasswordEchoOnEdit Display characters as they are entered                     while editing otherwise display asterisks.      \sa setEchoMode(), echoMode() */
end_comment
begin_comment
comment|/*!     \property QLineEdit::echoMode     \brief the line edit's echo mode      The echo mode determines how the text entered in the line edit is     displayed (or echoed) to the user.      The most common setting is \l Normal, in which the text entered by the     user is displayed verbatim, but QLineEdit also supports modes that allow     the entered text to be suppressed or obscured: these include \l NoEcho,     \l Password and \l PasswordEchoOnEdit.      The widget's display and the ability to copy or drag the text is     affected by this setting.      By default, this property is set to \l Normal.      \sa EchoMode, displayText() */
end_comment
begin_function
DECL|function|echoMode
name|QLineEdit
operator|::
name|EchoMode
name|QLineEdit
operator|::
name|echoMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EchoMode
operator|)
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setEchoMode
name|void
name|QLineEdit
operator|::
name|setEchoMode
parameter_list|(
name|EchoMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|(
name|EchoMode
operator|)
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
condition|)
return|return;
name|Qt
operator|::
name|InputMethodHints
name|imHints
init|=
name|inputMethodHints
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Password
operator|||
name|mode
operator|==
name|NoEcho
condition|)
block|{
name|imHints
operator||=
name|Qt
operator|::
name|ImhHiddenText
expr_stmt|;
block|}
else|else
block|{
name|imHints
operator|&=
operator|~
name|Qt
operator|::
name|ImhHiddenText
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|Normal
condition|)
block|{
name|imHints
operator||=
operator|(
name|Qt
operator|::
name|ImhNoAutoUppercase
operator||
name|Qt
operator|::
name|ImhNoPredictiveText
operator||
name|Qt
operator|::
name|ImhSensitiveData
operator|)
expr_stmt|;
block|}
else|else
block|{
name|imHints
operator|&=
operator|~
operator|(
name|Qt
operator|::
name|ImhNoAutoUppercase
operator||
name|Qt
operator|::
name|ImhNoPredictiveText
operator||
name|Qt
operator|::
name|ImhSensitiveData
operator|)
expr_stmt|;
block|}
name|setInputMethodHints
argument_list|(
name|imHints
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setEchoMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
name|qt_mac_secure_keyboard
argument_list|(
name|mode
operator|==
name|Password
operator|||
name|mode
operator|==
name|NoEcho
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_VALIDATOR
end_ifndef
begin_comment
comment|/*!     Returns a pointer to the current input validator, or 0 if no     validator has been set.      \sa setValidator() */
end_comment
begin_function
DECL|function|validator
specifier|const
name|QValidator
modifier|*
name|QLineEdit
operator|::
name|validator
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|validator
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this line edit to only accept input that the validator, \a v,     will accept. This allows you to place any arbitrary constraints on     the text which may be entered.      If \a v == 0, setValidator() removes the current input validator.     The initial setting is to have no input validator (i.e. any input     is accepted up to maxLength()).      \sa validator(), QIntValidator, QDoubleValidator, QRegExpValidator */
end_comment
begin_function
DECL|function|setValidator
name|void
name|QLineEdit
operator|::
name|setValidator
parameter_list|(
specifier|const
name|QValidator
modifier|*
name|v
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setValidator
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_VALIDATOR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
end_ifndef
begin_comment
comment|/*!     \since 4.2      Sets this line edit to provide auto completions from the completer, \a c.     The completion mode is set using QCompleter::setCompletionMode().      To use a QCompleter with a QValidator or QLineEdit::inputMask, you need to     ensure that the model provided to QCompleter contains valid entries. You can     use the QSortFilterProxyModel to ensure that the QCompleter's model contains     only valid entries.      If \a c == 0, setCompleter() removes the current completer, effectively     disabling auto completion.      \sa QCompleter */
end_comment
begin_function
DECL|function|setCompleter
name|void
name|QLineEdit
operator|::
name|setCompleter
parameter_list|(
name|QCompleter
modifier|*
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|setWidget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|control
operator|->
name|setCompleter
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|widget
argument_list|()
operator|==
literal|0
condition|)
name|c
operator|->
name|setWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|setText
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|highlighted
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_completionHighlighted
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the current QCompleter that provides completions. */
end_comment
begin_function
DECL|function|completer
name|QCompleter
modifier|*
name|QLineEdit
operator|::
name|completer
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_COMPLETER
end_comment
begin_comment
comment|/*!     Returns a recommended size for the widget.      The width returned, in pixels, is usually enough for about 15 to     20 characters. */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QLineEdit
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QFontMetrics
name|fm
argument_list|(
name|font
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|h
init|=
name|qMax
argument_list|(
name|fm
operator|.
name|height
argument_list|()
argument_list|,
literal|14
argument_list|)
operator|+
literal|2
operator|*
name|d
operator|->
name|verticalMargin
operator|+
name|d
operator|->
name|topTextMargin
operator|+
name|d
operator|->
name|bottomTextMargin
operator|+
name|d
operator|->
name|topmargin
operator|+
name|d
operator|->
name|bottommargin
decl_stmt|;
name|int
name|w
init|=
name|fm
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
argument_list|)
operator|*
literal|17
operator|+
literal|2
operator|*
name|d
operator|->
name|horizontalMargin
operator|+
name|d
operator|->
name|leftTextMargin
operator|+
name|d
operator|->
name|rightTextMargin
operator|+
name|d
operator|->
name|leftmargin
operator|+
name|d
operator|->
name|rightmargin
decl_stmt|;
comment|// "some"
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|style
argument_list|()
operator|->
name|sizeFromContents
argument_list|(
name|QStyle
operator|::
name|CT_LineEdit
argument_list|,
operator|&
name|opt
argument_list|,
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|QApplication
operator|::
name|globalStrut
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a minimum size for the line edit.      The width returned is enough for at least one character. */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QLineEdit
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QFontMetrics
name|fm
init|=
name|fontMetrics
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|fm
operator|.
name|height
argument_list|()
operator|+
name|qMax
argument_list|(
literal|2
operator|*
name|d
operator|->
name|verticalMargin
argument_list|,
name|fm
operator|.
name|leading
argument_list|()
argument_list|)
operator|+
name|d
operator|->
name|topmargin
operator|+
name|d
operator|->
name|bottommargin
decl_stmt|;
name|int
name|w
init|=
name|fm
operator|.
name|maxWidth
argument_list|()
operator|+
name|d
operator|->
name|leftmargin
operator|+
name|d
operator|->
name|rightmargin
decl_stmt|;
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|style
argument_list|()
operator|->
name|sizeFromContents
argument_list|(
name|QStyle
operator|::
name|CT_LineEdit
argument_list|,
operator|&
name|opt
argument_list|,
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|QApplication
operator|::
name|globalStrut
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::cursorPosition     \brief the current cursor position for this line edit      Setting the cursor position causes a repaint when appropriate.      By default, this property contains a value of 0. */
end_comment
begin_function
DECL|function|cursorPosition
name|int
name|QLineEdit
operator|::
name|cursorPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|cursorPosition
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setCursorPosition
name|void
name|QLineEdit
operator|::
name|setCursorPosition
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the cursor position under the point \a pos. */
end_comment
begin_comment
comment|// ### What should this do if the point is outside of contentsRect? Currently returns 0.
end_comment
begin_function
DECL|function|cursorPositionAt
name|int
name|QLineEdit
operator|::
name|cursorPositionAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|xToPos
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::alignment     \brief the alignment of the line edit      Both horizontal and vertical alignment is allowed here, Qt::AlignJustify     will map to Qt::AlignLeft.      By default, this property contains a combination of Qt::AlignLeft and Qt::AlignVCenter.      \sa Qt::Alignment */
end_comment
begin_function
DECL|function|alignment
name|Qt
operator|::
name|Alignment
name|QLineEdit
operator|::
name|alignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|QFlag
argument_list|(
name|d
operator|->
name|alignment
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAlignment
name|void
name|QLineEdit
operator|::
name|setAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the cursor forward \a steps characters. If \a mark is true     each character moved over is added to the selection; if \a mark is     false the selection is cleared.      \sa cursorBackward() */
end_comment
begin_function
DECL|function|cursorForward
name|void
name|QLineEdit
operator|::
name|cursorForward
parameter_list|(
name|bool
name|mark
parameter_list|,
name|int
name|steps
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|cursorForward
argument_list|(
name|mark
argument_list|,
name|steps
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the cursor back \a steps characters. If \a mark is true each     character moved over is added to the selection; if \a mark is     false the selection is cleared.      \sa cursorForward() */
end_comment
begin_function
DECL|function|cursorBackward
name|void
name|QLineEdit
operator|::
name|cursorBackward
parameter_list|(
name|bool
name|mark
parameter_list|,
name|int
name|steps
parameter_list|)
block|{
name|cursorForward
argument_list|(
name|mark
argument_list|,
operator|-
name|steps
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the cursor one word forward. If \a mark is true, the word is     also selected.      \sa cursorWordBackward() */
end_comment
begin_function
DECL|function|cursorWordForward
name|void
name|QLineEdit
operator|::
name|cursorWordForward
parameter_list|(
name|bool
name|mark
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|cursorWordForward
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the cursor one word backward. If \a mark is true, the word     is also selected.      \sa cursorWordForward() */
end_comment
begin_function
DECL|function|cursorWordBackward
name|void
name|QLineEdit
operator|::
name|cursorWordBackward
parameter_list|(
name|bool
name|mark
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|cursorWordBackward
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If no text is selected, deletes the character to the left of the     text cursor and moves the cursor one position to the left. If any     text is selected, the cursor is moved to the beginning of the     selected text and the selected text is deleted.      \sa del() */
end_comment
begin_function
DECL|function|backspace
name|void
name|QLineEdit
operator|::
name|backspace
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|backspace
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If no text is selected, deletes the character to the right of the     text cursor. If any text is selected, the cursor is moved to the     beginning of the selected text and the selected text is deleted.      \sa backspace() */
end_comment
begin_function
DECL|function|del
name|void
name|QLineEdit
operator|::
name|del
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|del
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the text cursor to the beginning of the line unless it is     already there. If \a mark is true, text is selected towards the     first position; otherwise, any selected text is unselected if the     cursor is moved.      \sa end() */
end_comment
begin_function
DECL|function|home
name|void
name|QLineEdit
operator|::
name|home
parameter_list|(
name|bool
name|mark
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|home
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Moves the text cursor to the end of the line unless it is already     there. If \a mark is true, text is selected towards the last     position; otherwise, any selected text is unselected if the cursor     is moved.      \sa home() */
end_comment
begin_function
DECL|function|end
name|void
name|QLineEdit
operator|::
name|end
parameter_list|(
name|bool
name|mark
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|end
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::modified     \brief whether the line edit's contents has been modified by the user      The modified flag is never read by QLineEdit; it has a default value     of false and is changed to true whenever the user changes the line     edit's contents.      This is useful for things that need to provide a default value but     do not start out knowing what the default should be (perhaps it     depends on other fields on the form). Start the line edit without     the best default, and when the default is known, if modified()     returns false (the user hasn't entered any text), insert the     default value.      Calling setText() resets the modified flag to false. */
end_comment
begin_function
DECL|function|isModified
name|bool
name|QLineEdit
operator|::
name|isModified
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|isModified
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setModified
name|void
name|QLineEdit
operator|::
name|setModified
parameter_list|(
name|bool
name|modified
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setModified
argument_list|(
name|modified
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::hasSelectedText     \brief whether there is any text selected      hasSelectedText() returns true if some or all of the text has been     selected by the user; otherwise returns false.      By default, this property is false.      \sa selectedText() */
end_comment
begin_function
DECL|function|hasSelectedText
name|bool
name|QLineEdit
operator|::
name|hasSelectedText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::selectedText     \brief the selected text      If there is no selected text this property's value is     an empty string.      By default, this property contains an empty string.      \sa hasSelectedText() */
end_comment
begin_function
DECL|function|selectedText
name|QString
name|QLineEdit
operator|::
name|selectedText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|selectedText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     selectionStart() returns the index of the first selected character in the     line edit or -1 if no text is selected.      \sa selectedText() */
end_comment
begin_function
DECL|function|selectionStart
name|int
name|QLineEdit
operator|::
name|selectionStart
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|selectionStart
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Selects text from position \a start and for \a length characters.     Negative lengths are allowed.      \sa deselect(), selectAll(), selectedText() */
end_comment
begin_function
DECL|function|setSelection
name|void
name|QLineEdit
operator|::
name|setSelection
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|start
operator|>
operator|(
name|int
operator|)
name|d
operator|->
name|control
operator|->
name|end
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QLineEdit::setSelection: Invalid start position (%d)"
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|control
operator|->
name|setSelection
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
condition|)
block|{
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_BlinkCursorWhenTextSelected
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::undoAvailable     \brief whether undo is available      Undo becomes available once the user has modified the text in the line edit.      By default, this property is false. */
end_comment
begin_function
DECL|function|isUndoAvailable
name|bool
name|QLineEdit
operator|::
name|isUndoAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|isUndoAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::redoAvailable     \brief whether redo is available      Redo becomes available once the user has performed one or more undo operations     on text in the line edit.      By default, this property is false. */
end_comment
begin_function
DECL|function|isRedoAvailable
name|bool
name|QLineEdit
operator|::
name|isRedoAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|isRedoAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::dragEnabled     \brief whether the lineedit starts a drag if the user presses and     moves the mouse on some selected text      Dragging is disabled by default. */
end_comment
begin_function
DECL|function|dragEnabled
name|bool
name|QLineEdit
operator|::
name|dragEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dragEnabled
return|;
block|}
end_function
begin_function
DECL|function|setDragEnabled
name|void
name|QLineEdit
operator|::
name|setDragEnabled
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragEnabled
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \property QLineEdit::cursorMoveStyle   \brief the movement style of cursor in this line edit   \since 4.8    When this property is set to Qt::VisualMoveStyle, the line edit will use visual   movement style. Pressing the left arrow key will always cause the cursor to move   left, regardless of the text's writing direction. The same behavior applies to   right arrow key.    When the property is Qt::LogicalMoveStyle (the default), within a LTR text block,   increase cursor position when pressing left arrow key, decrease cursor position   when pressing the right arrow key. If the text block is right to left, the opposite   behavior applies. */
end_comment
begin_function
DECL|function|cursorMoveStyle
name|Qt
operator|::
name|CursorMoveStyle
name|QLineEdit
operator|::
name|cursorMoveStyle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|cursorMoveStyle
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setCursorMoveStyle
name|void
name|QLineEdit
operator|::
name|setCursorMoveStyle
parameter_list|(
name|Qt
operator|::
name|CursorMoveStyle
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorMoveStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::acceptableInput     \brief whether the input satisfies the inputMask and the     validator.      By default, this property is true.      \sa setInputMask(), setValidator() */
end_comment
begin_function
DECL|function|hasAcceptableInput
name|bool
name|QLineEdit
operator|::
name|hasAcceptableInput
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|hasAcceptableInput
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the margins around the text inside the frame to have the     sizes \a left, \a top, \a right, and \a bottom.     \since 4.5      See also getTextMargins(). */
end_comment
begin_function
DECL|function|setTextMargins
name|void
name|QLineEdit
operator|::
name|setTextMargins
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|leftTextMargin
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|topTextMargin
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|rightTextMargin
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|bottomTextMargin
operator|=
name|bottom
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets the \a margins around the text inside the frame.      See also textMargins(). */
end_comment
begin_function
DECL|function|setTextMargins
name|void
name|QLineEdit
operator|::
name|setTextMargins
parameter_list|(
specifier|const
name|QMargins
modifier|&
name|margins
parameter_list|)
block|{
name|setTextMargins
argument_list|(
name|margins
operator|.
name|left
argument_list|()
argument_list|,
name|margins
operator|.
name|top
argument_list|()
argument_list|,
name|margins
operator|.
name|right
argument_list|()
argument_list|,
name|margins
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget's text margins for \a left, \a top, \a right, and \a bottom.     \since 4.5      \sa setTextMargins() */
end_comment
begin_function
DECL|function|getTextMargins
name|void
name|QLineEdit
operator|::
name|getTextMargins
parameter_list|(
name|int
modifier|*
name|left
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|right
parameter_list|,
name|int
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|d
operator|->
name|leftTextMargin
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|d
operator|->
name|topTextMargin
expr_stmt|;
if|if
condition|(
name|right
condition|)
operator|*
name|right
operator|=
name|d
operator|->
name|rightTextMargin
expr_stmt|;
if|if
condition|(
name|bottom
condition|)
operator|*
name|bottom
operator|=
name|d
operator|->
name|bottomTextMargin
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the widget's text margins.      \sa setTextMargins() */
end_comment
begin_function
DECL|function|textMargins
name|QMargins
name|QLineEdit
operator|::
name|textMargins
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|QMargins
argument_list|(
name|d
operator|->
name|leftTextMargin
argument_list|,
name|d
operator|->
name|topTextMargin
argument_list|,
name|d
operator|->
name|rightTextMargin
argument_list|,
name|d
operator|->
name|bottomTextMargin
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::inputMask     \brief The validation input mask      If no mask is set, inputMask() returns an empty string.      Sets the QLineEdit's validation mask. Validators can be used     instead of, or in conjunction with masks; see setValidator().      Unset the mask and return to normal QLineEdit operation by passing     an empty string ("").      The table below shows the characters that can be used in an input mask.     A space character, the default character for a blank, is needed for cases     where a character is \e{permitted but not required}.      \table     \header \li Character \li Meaning     \row \li \c A \li ASCII alphabetic character required. A-Z, a-z.     \row \li \c a \li ASCII alphabetic character permitted but not required.     \row \li \c N \li ASCII alphanumeric character required. A-Z, a-z, 0-9.     \row \li \c n \li ASCII alphanumeric character permitted but not required.     \row \li \c X \li Any character required.     \row \li \c x \li Any character permitted but not required.     \row \li \c 9 \li ASCII digit required. 0-9.     \row \li \c 0 \li ASCII digit permitted but not required.     \row \li \c D \li ASCII digit required. 1-9.     \row \li \c d \li ASCII digit permitted but not required (1-9).     \row \li \c # \li ASCII digit or plus/minus sign permitted but not required.     \row \li \c H \li Hexadecimal character required. A-F, a-f, 0-9.     \row \li \c h \li Hexadecimal character permitted but not required.     \row \li \c B \li Binary character required. 0-1.     \row \li \c b \li Binary character permitted but not required.     \row \li \c> \li All following alphabetic characters are uppercased.     \row \li \c< \li All following alphabetic characters are lowercased.     \row \li \c ! \li Switch off case conversion.     \row \li \tt{\\} \li Use \tt{\\} to escape the special                            characters listed above to use them as                            separators.     \endtable      The mask consists of a string of mask characters and separators,     optionally followed by a semicolon and the character used for     blanks. The blank characters are always removed from the text     after editing.      Examples:     \table     \header \li Mask \li Notes     \row \li \c 000.000.000.000;_ \li IP address; blanks are \c{_}.     \row \li \c HH:HH:HH:HH:HH:HH;_ \li MAC address     \row \li \c 0000-00-00 \li ISO Date; blanks are \c space     \row \li \c>AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;# \li License number;     blanks are \c - and all (alphabetic) characters are converted to     uppercase.     \endtable      To get range control (e.g., for an IP address) use masks together     with \l{setValidator()}{validators}.      \sa maxLength */
end_comment
begin_function
DECL|function|inputMask
name|QString
name|QLineEdit
operator|::
name|inputMask
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|inputMask
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setInputMask
name|void
name|QLineEdit
operator|::
name|setInputMask
parameter_list|(
specifier|const
name|QString
modifier|&
name|inputMask
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setInputMask
argument_list|(
name|inputMask
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Selects all the text (i.e. highlights it) and moves the cursor to     the end. This is useful when a default value has been inserted     because if the user types before clicking on the widget, the     selected text will be deleted.      \sa setSelection(), deselect() */
end_comment
begin_function
DECL|function|selectAll
name|void
name|QLineEdit
operator|::
name|selectAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|selectAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Deselects any selected text.      \sa setSelection(), selectAll() */
end_comment
begin_function
DECL|function|deselect
name|void
name|QLineEdit
operator|::
name|deselect
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|deselect
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Deletes any selected text, inserts \a newText, and validates the     result. If it is valid, it sets it as the new contents of the line     edit.      \sa setText(), clear() */
end_comment
begin_function
DECL|function|insert
name|void
name|QLineEdit
operator|::
name|insert
parameter_list|(
specifier|const
name|QString
modifier|&
name|newText
parameter_list|)
block|{
comment|//     q->resetInputContext(); //#### FIX ME IN QT
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|insert
argument_list|(
name|newText
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the contents of the line edit.      \sa setText(), insert() */
end_comment
begin_function
DECL|function|clear
name|void
name|QLineEdit
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetInputMethod
argument_list|()
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Undoes the last operation if undo is \l{QLineEdit::undoAvailable}{available}. Deselects any current     selection, and updates the selection start to the current cursor     position. */
end_comment
begin_function
DECL|function|undo
name|void
name|QLineEdit
operator|::
name|undo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetInputMethod
argument_list|()
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|undo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Redoes the last operation if redo is \l{QLineEdit::redoAvailable}{available}. */
end_comment
begin_function
DECL|function|redo
name|void
name|QLineEdit
operator|::
name|redo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetInputMethod
argument_list|()
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|redo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QLineEdit::readOnly     \brief whether the line edit is read only.      In read-only mode, the user can still copy the text to the     clipboard, or drag and drop the text (if echoMode() is \l Normal),     but cannot edit it.      QLineEdit does not show a cursor in read-only mode.      By default, this property is false.      \sa setEnabled() */
end_comment
begin_function
DECL|function|isReadOnly
name|bool
name|QLineEdit
operator|::
name|isReadOnly
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setReadOnly
name|void
name|QLineEdit
operator|::
name|setReadOnly
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|!=
name|enable
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|setReadOnly
argument_list|(
name|enable
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacShowFocusRect
argument_list|,
operator|!
name|enable
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
name|d
operator|->
name|shouldEnableInputMethod
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|setCursor
argument_list|(
name|enable
condition|?
name|Qt
operator|::
name|ArrowCursor
else|:
name|Qt
operator|::
name|IBeamCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_comment
comment|/*!     Copies the selected text to the clipboard and deletes it, if there     is any, and if echoMode() is \l Normal.      If the current validator disallows deleting the selected text,     cut() will copy without deleting.      \sa copy(), paste(), setValidator() */
end_comment
begin_function
DECL|function|cut
name|void
name|QLineEdit
operator|::
name|cut
parameter_list|()
block|{
if|if
condition|(
name|hasSelectedText
argument_list|()
condition|)
block|{
name|copy
argument_list|()
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Copies the selected text to the clipboard, if there is any, and if     echoMode() is \l Normal.      \sa cut(), paste() */
end_comment
begin_function
DECL|function|copy
name|void
name|QLineEdit
operator|::
name|copy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|copy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts the clipboard's text at the cursor position, deleting any     selected text, providing the line edit is not \l{QLineEdit::readOnly}{read-only}.      If the end result would not be acceptable to the current     \l{setValidator()}{validator}, nothing happens.      \sa copy(), cut() */
end_comment
begin_function
DECL|function|paste
name|void
name|QLineEdit
operator|::
name|paste
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|paste
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_CLIPBOARD
end_comment
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QLineEdit
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
condition|)
block|{
comment|// should be timerEvent, is here for binary compatibility
name|int
name|timerId
init|=
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|e
operator|)
operator|->
name|timerId
argument_list|()
decl_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
block|}
elseif|else
if|if
condition|(
name|timerId
operator|==
name|d
operator|->
name|dndTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|drag
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|timerId
operator|==
name|d
operator|->
name|tripleClickTimer
operator|.
name|timerId
argument_list|()
condition|)
name|d
operator|->
name|tripleClickTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ContextMenu
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|composeMode
argument_list|()
condition|)
return|return
literal|true
return|;
endif|#
directive|endif
comment|//d->separate();
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|WindowActivate
condition|)
block|{
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|0
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_handleWindowActivate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ShortcutOverride
condition|)
block|{
name|QKeyEvent
modifier|*
name|ke
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|d
operator|->
name|control
operator|->
name|processShortcutOverrideEvent
argument_list|(
name|ke
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyRelease
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
name|QApplication
operator|::
name|cursorFlashTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Show
condition|)
block|{
comment|//In order to get the cursor blinking if QComboBox::setEditable is called when the combobox has focus
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
name|QApplication
operator|::
name|cursorFlashTime
argument_list|()
argument_list|)
expr_stmt|;
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|hasSelectedText
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|preeditAreaText
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_BlinkCursorWhenTextSelected
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|EnterEditFocus
condition|)
block|{
name|end
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
name|QApplication
operator|::
name|cursorFlashTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|LeaveEditFocus
condition|)
block|{
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|hasAcceptableInput
argument_list|()
operator|||
name|d
operator|->
name|control
operator|->
name|fixup
argument_list|()
condition|)
emit|emit
name|editingFinished
argument_list|()
emit|;
block|}
block|}
endif|#
directive|endif
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QLineEdit
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressPos
operator|=
name|e
operator|->
name|pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sendMouseEventToInputContext
argument_list|(
name|e
argument_list|)
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|RightButton
condition|)
return|return;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Get the completion list to pop up.
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
condition|)
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|complete
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|tripleClickTimer
operator|.
name|isActive
argument_list|()
operator|&&
operator|(
name|e
operator|->
name|pos
argument_list|()
operator|-
name|d
operator|->
name|tripleClick
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|<
name|QApplication
operator|::
name|startDragDistance
argument_list|()
condition|)
block|{
name|selectAll
argument_list|()
expr_stmt|;
return|return;
block|}
name|bool
name|mark
init|=
name|e
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
decl_stmt|;
name|int
name|cursor
init|=
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
operator|!
name|mark
operator|&&
name|d
operator|->
name|dragEnabled
operator|&&
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|Normal
operator|&&
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
operator|&&
name|d
operator|->
name|control
operator|->
name|inSelection
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|dndTimer
operator|.
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|dndTimer
operator|.
name|start
argument_list|(
name|QApplication
operator|::
name|startDragTime
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|cursor
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QLineEdit
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|d
operator|->
name|dndTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|mousePressPos
operator|-
name|e
operator|->
name|pos
argument_list|()
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|>
name|QApplication
operator|::
name|startDragDistance
argument_list|()
condition|)
name|d
operator|->
name|drag
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|composeMode
argument_list|()
condition|)
block|{
name|int
name|startPos
init|=
name|d
operator|->
name|xToPos
argument_list|(
name|d
operator|->
name|mousePressPos
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|currentPos
init|=
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|startPos
operator|!=
name|currentPos
condition|)
name|d
operator|->
name|control
operator|->
name|setSelection
argument_list|(
name|startPos
argument_list|,
name|currentPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|d
operator|->
name|sendMouseEventToInputContext
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QLineEdit
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sendMouseEventToInputContext
argument_list|(
name|e
argument_list|)
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|dndTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|d
operator|->
name|dndTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|deselect
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
if|if
condition|(
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|supportsSelection
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|copy
argument_list|(
name|QClipboard
operator|::
name|Selection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|MidButton
condition|)
block|{
name|deselect
argument_list|()
expr_stmt|;
name|insert
argument_list|(
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|text
argument_list|(
name|QClipboard
operator|::
name|Selection
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
operator|&&
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|d
operator|->
name|handleSoftwareInputPanel
argument_list|(
name|e
operator|->
name|button
argument_list|()
argument_list|,
name|d
operator|->
name|clickCausedFocus
argument_list|)
expr_stmt|;
name|d
operator|->
name|clickCausedFocus
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QLineEdit
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|int
name|position
init|=
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
comment|// exit composition mode
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|composeMode
argument_list|()
condition|)
block|{
name|int
name|preeditPos
init|=
name|d
operator|->
name|control
operator|->
name|cursor
argument_list|()
decl_stmt|;
name|int
name|posInPreedit
init|=
name|position
operator|-
name|d
operator|->
name|control
operator|->
name|cursor
argument_list|()
decl_stmt|;
name|int
name|preeditLength
init|=
name|d
operator|->
name|control
operator|->
name|preeditAreaText
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|bool
name|positionOnPreedit
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|posInPreedit
operator|>=
literal|0
operator|&&
name|posInPreedit
operator|<=
name|preeditLength
condition|)
name|positionOnPreedit
operator|=
literal|true
expr_stmt|;
name|int
name|textLength
init|=
name|d
operator|->
name|control
operator|->
name|end
argument_list|()
decl_stmt|;
name|d
operator|->
name|control
operator|->
name|commitPreedit
argument_list|()
expr_stmt|;
name|int
name|sizeChange
init|=
name|d
operator|->
name|control
operator|->
name|end
argument_list|()
operator|-
name|textLength
decl_stmt|;
if|if
condition|(
name|positionOnPreedit
condition|)
block|{
if|if
condition|(
name|sizeChange
operator|==
literal|0
condition|)
name|position
operator|=
operator|-
literal|1
expr_stmt|;
comment|// cancel selection, word disappeared
else|else
comment|// ensure not selecting after preedit if event happened there
name|position
operator|=
name|qBound
argument_list|(
name|preeditPos
argument_list|,
name|position
argument_list|,
name|preeditPos
operator|+
name|sizeChange
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|>
name|preeditPos
condition|)
block|{
comment|// adjust positions after former preedit by how much text changed
name|position
operator|+=
operator|(
name|sizeChange
operator|-
name|preeditLength
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|position
operator|>=
literal|0
condition|)
name|d
operator|->
name|control
operator|->
name|selectWordAtPos
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|d
operator|->
name|tripleClickTimer
operator|.
name|start
argument_list|(
name|QApplication
operator|::
name|doubleClickInterval
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|tripleClick
operator|=
name|e
operator|->
name|pos
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|sendMouseEventToInputContext
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void  QLineEdit::returnPressed()      This signal is emitted when the Return or Enter key is pressed.     Note that if there is a validator() or inputMask() set on the line     edit, the returnPressed() signal will only be emitted if the input     follows the inputMask() and the validator() returns     QValidator::Acceptable. */
end_comment
begin_comment
comment|/*!     \fn void  QLineEdit::editingFinished()      This signal is emitted when the Return or Enter key is pressed or     the line edit loses focus. Note that if there is a validator() or     inputMask() set on the line edit and enter/return is pressed, the     editingFinished() signal will only be emitted if the input follows     the inputMask() and the validator() returns QValidator::Acceptable. */
end_comment
begin_comment
comment|/*!     Converts the given key press \a event into a line edit action.      If Return or Enter is pressed and the current text is valid (or     can be \l{QValidator::fixup()}{made valid} by the     validator), the signal returnPressed() is emitted.      The default key bindings are listed in the class's detailed     description. */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QLineEdit
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|bool
name|select
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|popup
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|popup
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
name|select
operator|=
literal|true
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
case|case
name|Qt
operator|::
name|Key_No
case|:
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|||
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|!
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|event
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|event
operator|->
name|text
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isPrint
argument_list|()
operator|&&
operator|!
name|isReadOnly
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|select
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Select
condition|)
return|return;
comment|// Just start. No action.
block|}
endif|#
directive|endif
name|d
operator|->
name|control
operator|->
name|processKeyEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
if|if
condition|(
name|layoutDirection
argument_list|()
operator|!=
name|d
operator|->
name|control
operator|->
name|layoutDirection
argument_list|()
condition|)
name|setLayoutDirection
argument_list|(
name|d
operator|->
name|control
operator|->
name|layoutDirection
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Returns a rectangle that includes the lineedit cursor. */
end_comment
begin_function
DECL|function|cursorRect
name|QRect
name|QLineEdit
operator|::
name|cursorRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cursorRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp  */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QLineEdit
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|PasswordEchoOnEdit
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|passwordEchoEditing
argument_list|()
condition|)
block|{
comment|// Clear the edit and reset to normal echo mode while entering input
comment|// method data; the echo mode switches back when the edit loses focus.
comment|// ### changes a public property, resets current content.
name|d
operator|->
name|updatePasswordEchoEditing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// Focus in if currently in navigation focus on the widget
comment|// Only focus in on preedits, to allow input methods to
comment|// commit text as they focus out without interfering with focus
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|hasFocus
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|!
name|e
operator|->
name|preeditString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|control
operator|->
name|processInputMethodEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
if|if
condition|(
operator|!
name|e
operator|->
name|commitString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|control
operator|->
name|complete
argument_list|(
name|Qt
operator|::
name|Key_unknown
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QLineEdit
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|property
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QLineEdit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|property
condition|)
block|{
case|case
name|Qt
operator|::
name|ImCursorRectangle
case|:
return|return
name|d
operator|->
name|cursorRect
argument_list|()
return|;
case|case
name|Qt
operator|::
name|ImFont
case|:
return|return
name|font
argument_list|()
return|;
case|case
name|Qt
operator|::
name|ImCursorPosition
case|:
return|return
name|QVariant
argument_list|(
name|d
operator|->
name|control
operator|->
name|cursor
argument_list|()
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImSurroundingText
case|:
return|return
name|QVariant
argument_list|(
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImCurrentSelection
case|:
return|return
name|QVariant
argument_list|(
name|selectedText
argument_list|()
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImMaximumTextLength
case|:
return|return
name|QVariant
argument_list|(
name|maxLength
argument_list|()
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ImAnchorPosition
case|:
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|selectionStart
argument_list|()
operator|==
name|d
operator|->
name|control
operator|->
name|selectionEnd
argument_list|()
condition|)
return|return
name|QVariant
argument_list|(
name|d
operator|->
name|control
operator|->
name|cursor
argument_list|()
argument_list|)
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|selectionStart
argument_list|()
operator|==
name|d
operator|->
name|control
operator|->
name|cursor
argument_list|()
condition|)
return|return
name|QVariant
argument_list|(
name|d
operator|->
name|control
operator|->
name|selectionEnd
argument_list|()
argument_list|)
return|;
else|else
return|return
name|QVariant
argument_list|(
name|d
operator|->
name|control
operator|->
name|selectionStart
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|QWidget
operator|::
name|inputMethodQuery
argument_list|(
name|property
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QLineEdit
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|TabFocusReason
operator|||
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|BacktabFocusReason
operator|||
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|ShortcutFocusReason
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|control
operator|->
name|inputMask
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|d
operator|->
name|control
operator|->
name|nextMaskBlank
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
condition|)
name|selectAll
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|MouseFocusReason
condition|)
block|{
name|d
operator|->
name|clickCausedFocus
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|||
operator|(
name|hasEditFocus
argument_list|()
operator|&&
operator|(
name|e
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|PopupFocusReason
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
name|QApplication
operator|::
name|cursorFlashTime
argument_list|()
argument_list|)
expr_stmt|;
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|hasSelectedText
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|preeditAreaText
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_BlinkCursorWhenTextSelected
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
condition|)
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|Password
operator|||
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|NoEcho
condition|)
name|qt_mac_secure_keyboard
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|d
operator|->
name|control
operator|->
name|setCancelText
argument_list|(
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
condition|)
block|{
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
operator|->
name|setWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|setText
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|highlighted
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_completionHighlighted
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QLineEdit
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|passwordEchoEditing
argument_list|()
condition|)
block|{
comment|// Reset the echomode back to PasswordEchoOnEdit when the widget loses
comment|// focus.
name|d
operator|->
name|updatePasswordEchoEditing
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|Qt
operator|::
name|FocusReason
name|reason
init|=
name|e
operator|->
name|reason
argument_list|()
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|ActiveWindowFocusReason
operator|&&
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
condition|)
name|deselect
argument_list|()
expr_stmt|;
name|d
operator|->
name|setCursorVisible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorBlinkPeriod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// editingFinished() is already emitted on LeaveEditFocus
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
endif|#
directive|endif
if|if
condition|(
name|reason
operator|!=
name|Qt
operator|::
name|PopupFocusReason
operator|||
operator|!
operator|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|&&
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|->
name|parentWidget
argument_list|()
operator|==
name|this
operator|)
condition|)
block|{
if|if
condition|(
name|hasAcceptableInput
argument_list|()
operator|||
name|d
operator|->
name|control
operator|->
name|fixup
argument_list|()
condition|)
emit|emit
name|editingFinished
argument_list|()
emit|;
block|}
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|Password
operator|||
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|NoEcho
condition|)
name|qt_mac_secure_keyboard
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
name|d
operator|->
name|control
operator|->
name|setCancelText
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
condition|)
block|{
name|QObject
operator|::
name|disconnect
argument_list|(
name|d
operator|->
name|control
operator|->
name|completer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QWidget
operator|::
name|focusOutEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QLineEdit
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QRect
name|r
init|=
name|rect
argument_list|()
decl_stmt|;
name|QPalette
name|pal
init|=
name|palette
argument_list|()
decl_stmt|;
name|QStyleOptionFrameV2
name|panel
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|panel
argument_list|)
expr_stmt|;
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_PanelLineEdit
argument_list|,
operator|&
name|panel
argument_list|,
operator|&
name|p
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|r
operator|=
name|style
argument_list|()
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_LineEditContents
argument_list|,
operator|&
name|panel
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|r
operator|.
name|setX
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|leftTextMargin
argument_list|)
expr_stmt|;
name|r
operator|.
name|setY
argument_list|(
name|r
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|topTextMargin
argument_list|)
expr_stmt|;
name|r
operator|.
name|setRight
argument_list|(
name|r
operator|.
name|right
argument_list|()
operator|-
name|d
operator|->
name|rightTextMargin
argument_list|)
expr_stmt|;
name|r
operator|.
name|setBottom
argument_list|(
name|r
operator|.
name|bottom
argument_list|()
operator|-
name|d
operator|->
name|bottomTextMargin
argument_list|)
expr_stmt|;
name|p
operator|.
name|setClipRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|QFontMetrics
name|fm
init|=
name|fontMetrics
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|Alignment
name|va
init|=
name|QStyle
operator|::
name|visualAlignment
argument_list|(
name|d
operator|->
name|control
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|QFlag
argument_list|(
name|d
operator|->
name|alignment
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|va
operator|&
name|Qt
operator|::
name|AlignVertical_Mask
condition|)
block|{
case|case
name|Qt
operator|::
name|AlignBottom
case|:
name|d
operator|->
name|vscroll
operator|=
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
operator|-
name|fm
operator|.
name|height
argument_list|()
operator|-
name|d
operator|->
name|verticalMargin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignTop
case|:
name|d
operator|->
name|vscroll
operator|=
name|r
operator|.
name|y
argument_list|()
operator|+
name|d
operator|->
name|verticalMargin
expr_stmt|;
break|break;
default|default:
comment|//center
name|d
operator|->
name|vscroll
operator|=
name|r
operator|.
name|y
argument_list|()
operator|+
operator|(
name|r
operator|.
name|height
argument_list|()
operator|-
name|fm
operator|.
name|height
argument_list|()
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
block|}
name|QRect
name|lineRect
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|d
operator|->
name|horizontalMargin
argument_list|,
name|d
operator|->
name|vscroll
argument_list|,
name|r
operator|.
name|width
argument_list|()
operator|-
literal|2
operator|*
name|d
operator|->
name|horizontalMargin
argument_list|,
name|fm
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minLB
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
operator|-
name|fm
operator|.
name|minLeftBearing
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minRB
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
operator|-
name|fm
operator|.
name|minRightBearing
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|placeholderText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QColor
name|col
init|=
name|pal
operator|.
name|text
argument_list|()
operator|.
name|color
argument_list|()
decl_stmt|;
name|col
operator|.
name|setAlpha
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|QPen
name|oldpen
init|=
name|p
operator|.
name|pen
argument_list|()
decl_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|lineRect
operator|.
name|adjust
argument_list|(
name|minLB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QString
name|elidedText
init|=
name|fm
operator|.
name|elidedText
argument_list|(
name|d
operator|->
name|placeholderText
argument_list|,
name|Qt
operator|::
name|ElideRight
argument_list|,
name|lineRect
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawText
argument_list|(
name|lineRect
argument_list|,
name|va
argument_list|,
name|elidedText
argument_list|)
expr_stmt|;
name|p
operator|.
name|setPen
argument_list|(
name|oldpen
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|cix
init|=
name|qRound
argument_list|(
name|d
operator|->
name|control
operator|->
name|cursorToX
argument_list|()
argument_list|)
decl_stmt|;
comment|// horizontal scrolling. d->hscroll is the left indent from the beginning
comment|// of the text line to the left edge of lineRect. we update this value
comment|// depending on the delta from the last paint event; in effect this means
comment|// the below code handles all scrolling based on the textline (widthUsed,
comment|// minLB, minRB), the line edit rect (lineRect) and the cursor position
comment|// (cix).
name|int
name|widthUsed
init|=
name|qRound
argument_list|(
name|d
operator|->
name|control
operator|->
name|naturalTextWidth
argument_list|()
argument_list|)
operator|+
literal|1
operator|+
name|minRB
decl_stmt|;
if|if
condition|(
operator|(
name|minLB
operator|+
name|widthUsed
operator|)
operator|<=
name|lineRect
operator|.
name|width
argument_list|()
condition|)
block|{
comment|// text fits in lineRect; use hscroll for alignment
switch|switch
condition|(
name|va
operator|&
operator|~
operator|(
name|Qt
operator|::
name|AlignAbsolute
operator||
name|Qt
operator|::
name|AlignVertical_Mask
operator|)
condition|)
block|{
case|case
name|Qt
operator|::
name|AlignRight
case|:
name|d
operator|->
name|hscroll
operator|=
name|widthUsed
operator|-
name|lineRect
operator|.
name|width
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignHCenter
case|:
name|d
operator|->
name|hscroll
operator|=
operator|(
name|widthUsed
operator|-
name|lineRect
operator|.
name|width
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
default|default:
comment|// Left
name|d
operator|->
name|hscroll
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|hscroll
operator|-=
name|minLB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cix
operator|-
name|d
operator|->
name|hscroll
operator|>=
name|lineRect
operator|.
name|width
argument_list|()
condition|)
block|{
comment|// text doesn't fit, cursor is to the right of lineRect (scroll right)
name|d
operator|->
name|hscroll
operator|=
name|cix
operator|-
name|lineRect
operator|.
name|width
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cix
operator|-
name|d
operator|->
name|hscroll
operator|<
literal|0
operator|&&
name|d
operator|->
name|hscroll
operator|<
name|widthUsed
condition|)
block|{
comment|// text doesn't fit, cursor is to the left of lineRect (scroll left)
name|d
operator|->
name|hscroll
operator|=
name|cix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|widthUsed
operator|-
name|d
operator|->
name|hscroll
operator|<
name|lineRect
operator|.
name|width
argument_list|()
condition|)
block|{
comment|// text doesn't fit, text document is to the left of lineRect; align
comment|// right
name|d
operator|->
name|hscroll
operator|=
name|widthUsed
operator|-
name|lineRect
operator|.
name|width
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|//in case the text is bigger than the lineedit, the hscroll can never be negative
name|d
operator|->
name|hscroll
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|hscroll
argument_list|)
expr_stmt|;
block|}
comment|// the y offset is there to keep the baseline constant in case we have script changes in the text.
name|QPoint
name|topLeft
init|=
name|lineRect
operator|.
name|topLeft
argument_list|()
operator|-
name|QPoint
argument_list|(
name|d
operator|->
name|hscroll
argument_list|,
name|d
operator|->
name|control
operator|->
name|ascent
argument_list|()
operator|-
name|fm
operator|.
name|ascent
argument_list|()
argument_list|)
decl_stmt|;
comment|// draw text, selections and cursors
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
if|if
condition|(
name|QStyleSheetStyle
modifier|*
name|cssStyle
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|style
argument_list|()
argument_list|)
condition|)
block|{
name|cssStyle
operator|->
name|styleSheetPalette
argument_list|(
name|this
argument_list|,
operator|&
name|panel
argument_list|,
operator|&
name|pal
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p
operator|.
name|setPen
argument_list|(
name|pal
operator|.
name|text
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|flags
init|=
name|QWidgetLineControl
operator|::
name|DrawText
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|||
name|hasEditFocus
argument_list|()
condition|)
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
operator|||
operator|(
name|d
operator|->
name|cursorVisible
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|inputMask
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|)
condition|)
block|{
name|flags
operator||=
name|QWidgetLineControl
operator|::
name|DrawSelections
expr_stmt|;
comment|// Palette only used for selections/mask and may not be in sync
if|if
condition|(
name|d
operator|->
name|control
operator|->
name|palette
argument_list|()
operator|!=
name|pal
operator|||
name|d
operator|->
name|control
operator|->
name|palette
argument_list|()
operator|.
name|currentColorGroup
argument_list|()
operator|!=
name|pal
operator|.
name|currentColorGroup
argument_list|()
condition|)
name|d
operator|->
name|control
operator|->
name|setPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
block|}
comment|// Asian users see an IM selection text as cursor on candidate
comment|// selection phase of input method, so the ordinary cursor should be
comment|// invisible if we have a preedit string.
if|if
condition|(
name|d
operator|->
name|cursorVisible
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
condition|)
name|flags
operator||=
name|QWidgetLineControl
operator|::
name|DrawCursor
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setCursorWidth
argument_list|(
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_TextCursorWidth
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|draw
argument_list|(
operator|&
name|p
argument_list|,
name|topLeft
argument_list|,
name|r
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QLineEdit
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
name|e
operator|->
name|mimeData
argument_list|()
operator|->
name|hasFormat
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
condition|)
block|{
name|e
operator|->
name|acceptProposedAction
argument_list|()
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|cursorVisible
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QLineEdit
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
name|e
parameter_list|)
block|{
name|QLineEdit
operator|::
name|dragMoveEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QLineEdit
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cursorVisible
condition|)
block|{
name|d
operator|->
name|cursorVisible
operator|=
literal|false
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QLineEdit
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|QString
name|str
init|=
name|e
operator|->
name|mimeData
argument_list|()
operator|->
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|source
argument_list|()
operator|==
name|this
operator|&&
name|e
operator|->
name|dropAction
argument_list|()
operator|==
name|Qt
operator|::
name|CopyAction
condition|)
name|deselect
argument_list|()
expr_stmt|;
name|int
name|cursorPos
init|=
name|d
operator|->
name|xToPos
argument_list|(
name|e
operator|->
name|pos
argument_list|()
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|selStart
init|=
name|cursorPos
decl_stmt|;
name|int
name|oldSelStart
init|=
name|d
operator|->
name|control
operator|->
name|selectionStart
argument_list|()
decl_stmt|;
name|int
name|oldSelEnd
init|=
name|d
operator|->
name|control
operator|->
name|selectionEnd
argument_list|()
decl_stmt|;
name|d
operator|->
name|control
operator|->
name|moveCursor
argument_list|(
name|cursorPos
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|cursorVisible
operator|=
literal|false
expr_stmt|;
name|e
operator|->
name|acceptProposedAction
argument_list|()
expr_stmt|;
name|insert
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|source
argument_list|()
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dropAction
argument_list|()
operator|==
name|Qt
operator|::
name|MoveAction
condition|)
block|{
if|if
condition|(
name|selStart
operator|>
name|oldSelStart
operator|&&
name|selStart
operator|<=
name|oldSelEnd
condition|)
name|setSelection
argument_list|(
name|oldSelStart
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|selStart
operator|>
name|oldSelEnd
condition|)
name|setSelection
argument_list|(
name|selStart
operator|-
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|setSelection
argument_list|(
name|selStart
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setSelection
argument_list|(
name|selStart
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!     Shows the standard context menu created with     createStandardContextMenu().      If you do not want the line edit to have a context menu, you can set     its \l contextMenuPolicy to Qt::NoContextMenu. If you want to     customize the context menu, reimplement this function. If you want     to extend the standard context menu, reimplement this function, call     createStandardContextMenu() and extend the menu returned.      \snippet code/src_gui_widgets_qlineedit.cpp 0      The \a event parameter is used to obtain the position where     the mouse cursor was when the event was generated.      \sa setContextMenuPolicy() */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QLineEdit
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|QMenu
modifier|*
name|menu
init|=
name|createStandardContextMenu
argument_list|()
condition|)
block|{
name|menu
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
expr_stmt|;
name|menu
operator|->
name|popup
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!  This function creates the standard context menu which is shown         when the user clicks on the line edit with the right mouse         button. It is called from the default contextMenuEvent() handler.         The popup menu's ownership is transferred to the caller. */
end_comment
begin_function
DECL|function|createStandardContextMenu
name|QMenu
modifier|*
name|QLineEdit
operator|::
name|createStandardContextMenu
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
name|QMenu
modifier|*
name|popup
init|=
operator|new
name|QMenu
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|popup
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_edit_menu"
argument_list|)
argument_list|)
expr_stmt|;
name|QAction
modifier|*
name|action
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"&Undo"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|Undo
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
name|d
operator|->
name|control
operator|->
name|isUndoAvailable
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|undo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"&Redo"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|Redo
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
name|d
operator|->
name|control
operator|->
name|isRedoAvailable
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|redo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|popup
operator|->
name|addSeparator
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"Cu&t"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|Cut
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|cut
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"&Copy"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|Copy
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|copy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"&Paste"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|Paste
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
operator|!
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|paste
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"Delete"
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|control
operator|->
name|hasSelectedText
argument_list|()
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|control
argument_list|,
name|SLOT
argument_list|(
name|_q_deleteSelected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|popup
operator|->
name|isEmpty
argument_list|()
condition|)
name|popup
operator|->
name|addSeparator
argument_list|()
expr_stmt|;
name|action
operator|=
name|popup
operator|->
name|addAction
argument_list|(
name|QLineEdit
operator|::
name|tr
argument_list|(
literal|"Select All"
argument_list|)
operator|+
name|ACCEL_KEY
argument_list|(
name|QKeySequence
operator|::
name|SelectAll
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|setEnabled
argument_list|(
operator|!
name|d
operator|->
name|control
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|control
operator|->
name|allSelected
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectAllAction
operator|=
name|action
expr_stmt|;
name|connect
argument_list|(
name|action
argument_list|,
name|SIGNAL
argument_list|(
name|triggered
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|selectAll
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|control
operator|->
name|isReadOnly
argument_list|()
operator|&&
name|qApp
operator|->
name|styleHints
argument_list|()
operator|->
name|useRtlExtensions
argument_list|()
condition|)
block|{
name|popup
operator|->
name|addSeparator
argument_list|()
expr_stmt|;
name|QUnicodeControlCharacterMenu
modifier|*
name|ctrlCharacterMenu
init|=
operator|new
name|QUnicodeControlCharacterMenu
argument_list|(
name|this
argument_list|,
name|popup
argument_list|)
decl_stmt|;
name|popup
operator|->
name|addMenu
argument_list|(
name|ctrlCharacterMenu
argument_list|)
expr_stmt|;
block|}
return|return
name|popup
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QLineEdit
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QLineEdit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ActivationChange
case|:
if|if
condition|(
operator|!
name|palette
argument_list|()
operator|.
name|isEqual
argument_list|(
name|QPalette
operator|::
name|Active
argument_list|,
name|QPalette
operator|::
name|Inactive
argument_list|)
condition|)
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FontChange
case|:
name|d
operator|->
name|control
operator|->
name|setFont
argument_list|(
name|font
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleChange
case|:
block|{
name|QStyleOptionFrameV2
name|opt
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|d
operator|->
name|control
operator|->
name|setPasswordCharacter
argument_list|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_LineEdit_PasswordCharacter
argument_list|,
operator|&
name|opt
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|update
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|QWidget
operator|::
name|changeEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qlineedit.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_LINEEDIT
end_comment
end_unit
