begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwidgetlinecontrol_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LINEEDIT
end_ifndef
begin_include
include|#
directive|include
file|"qabstractitemview.h"
end_include
begin_include
include|#
directive|include
file|"qclipboard.h"
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformtheme.h>
end_include
begin_include
include|#
directive|include
file|<qstylehints.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!    \internal     Updates the internal text layout. Returns the ascent of the    created QTextLine. */
DECL|function|redoTextLayout
name|int
name|QWidgetLineControl
operator|::
name|redoTextLayout
parameter_list|()
specifier|const
block|{
name|m_textLayout
operator|.
name|clearLayout
argument_list|()
expr_stmt|;
name|m_textLayout
operator|.
name|beginLayout
argument_list|()
expr_stmt|;
name|QTextLine
name|l
init|=
name|m_textLayout
operator|.
name|createLine
argument_list|()
decl_stmt|;
name|m_textLayout
operator|.
name|endLayout
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|m_threadChecks
condition|)
name|m_textLayoutThread
operator|=
name|QThread
operator|::
name|currentThread
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|qRound
argument_list|(
name|l
operator|.
name|ascent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Updates the display text based of the current edit text     If the text has changed will emit displayTextChanged() */
end_comment
begin_function
DECL|function|updateDisplayText
name|void
name|QWidgetLineControl
operator|::
name|updateDisplayText
parameter_list|(
name|bool
name|forceUpdate
parameter_list|)
block|{
name|QString
name|orig
init|=
name|m_textLayout
operator|.
name|text
argument_list|()
decl_stmt|;
name|QString
name|str
decl_stmt|;
if|if
condition|(
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|NoEcho
condition|)
name|str
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|m_text
expr_stmt|;
if|if
condition|(
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|Password
condition|)
block|{
name|str
operator|.
name|fill
argument_list|(
name|m_passwordCharacter
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_passwordEchoTimer
operator|!=
literal|0
operator|&&
name|m_cursor
operator|>
literal|0
operator|&&
name|m_cursor
operator|<=
name|m_text
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|cursor
init|=
name|m_cursor
operator|-
literal|1
decl_stmt|;
name|QChar
name|uc
init|=
name|m_text
operator|.
name|at
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
name|str
index|[
name|cursor
index|]
operator|=
name|uc
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
literal|0
operator|&&
name|uc
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
comment|// second half of a surrogate, check if we have the first half as well,
comment|// if yes restore both at once
name|uc
operator|=
name|m_text
operator|.
name|at
argument_list|(
name|cursor
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|.
name|isHighSurrogate
argument_list|()
condition|)
name|str
index|[
name|cursor
operator|-
literal|1
index|]
operator|=
name|uc
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|PasswordEchoOnEdit
operator|&&
operator|!
name|m_passwordEchoEditing
condition|)
block|{
name|str
operator|.
name|fill
argument_list|(
name|m_passwordCharacter
argument_list|)
expr_stmt|;
block|}
comment|// replace certain non-printable characters with spaces (to avoid
comment|// drawing boxes when using fonts that don't have glyphs for such
comment|// characters)
name|QChar
modifier|*
name|uc
init|=
name|str
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|uc
index|[
name|i
index|]
operator|<
literal|0x20
operator|&&
name|uc
index|[
name|i
index|]
operator|!=
literal|0x09
operator|)
operator|||
name|uc
index|[
name|i
index|]
operator|==
name|QChar
operator|::
name|LineSeparator
operator|||
name|uc
index|[
name|i
index|]
operator|==
name|QChar
operator|::
name|ParagraphSeparator
operator|||
name|uc
index|[
name|i
index|]
operator|==
name|QChar
operator|::
name|ObjectReplacementCharacter
condition|)
name|uc
index|[
name|i
index|]
operator|=
name|QChar
argument_list|(
literal|0x0020
argument_list|)
expr_stmt|;
block|}
name|m_textLayout
operator|.
name|setText
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|QTextOption
name|option
init|=
name|m_textLayout
operator|.
name|textOption
argument_list|()
decl_stmt|;
name|option
operator|.
name|setTextDirection
argument_list|(
name|m_layoutDirection
argument_list|)
expr_stmt|;
name|option
operator|.
name|setFlags
argument_list|(
name|QTextOption
operator|::
name|IncludeTrailingSpaces
argument_list|)
expr_stmt|;
name|m_textLayout
operator|.
name|setTextOption
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|m_ascent
operator|=
name|redoTextLayout
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|orig
operator|||
name|forceUpdate
condition|)
emit|emit
name|displayTextChanged
argument_list|(
name|str
argument_list|)
emit|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_comment
comment|/*!     \internal      Copies the currently selected text into the clipboard using the given     \a mode.      \note If the echo mode is set to a mode other than Normal then copy     will not work.  This is to prevent using copy as a method of bypassing     password features of the line control. */
end_comment
begin_function
DECL|function|copy
name|void
name|QWidgetLineControl
operator|::
name|copy
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
name|QString
name|t
init|=
name|selectedText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|Normal
condition|)
block|{
name|disconnect
argument_list|(
name|QApplication
operator|::
name|clipboard
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|setText
argument_list|(
name|t
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|QApplication
operator|::
name|clipboard
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_clipboardChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Inserts the text stored in the application clipboard into the line     control.      \sa insert() */
end_comment
begin_function
DECL|function|paste
name|void
name|QWidgetLineControl
operator|::
name|paste
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|clipboardMode
parameter_list|)
block|{
name|QString
name|clip
init|=
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|text
argument_list|(
name|clipboardMode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|clip
operator|.
name|isEmpty
argument_list|()
operator|||
name|hasSelectedText
argument_list|()
condition|)
block|{
name|separate
argument_list|()
expr_stmt|;
comment|//make it a separate undo/redo command
name|insert
argument_list|(
name|clip
argument_list|)
expr_stmt|;
name|separate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_CLIPBOARD
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|commitPreedit
name|void
name|QWidgetLineControl
operator|::
name|commitPreedit
parameter_list|()
block|{
if|if
condition|(
operator|!
name|composeMode
argument_list|()
condition|)
return|return;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|composeMode
argument_list|()
condition|)
return|return;
name|m_preeditCursor
operator|=
literal|0
expr_stmt|;
name|setPreeditArea
argument_list|(
operator|-
literal|1
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|m_textLayout
operator|.
name|clearAdditionalFormats
argument_list|()
expr_stmt|;
name|updateDisplayText
argument_list|(
comment|/*force*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Handles the behavior for the backspace key or function.     Removes the current selection if there is a selection, otherwise     removes the character prior to the cursor position.      \sa del() */
end_comment
begin_function
DECL|function|backspace
name|void
name|QWidgetLineControl
operator|::
name|backspace
parameter_list|()
block|{
name|int
name|priorState
init|=
name|m_undoState
decl_stmt|;
if|if
condition|(
name|hasSelectedText
argument_list|()
condition|)
block|{
name|removeSelectedText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_cursor
condition|)
block|{
operator|--
name|m_cursor
expr_stmt|;
if|if
condition|(
name|m_maskData
condition|)
name|m_cursor
operator|=
name|prevMaskBlank
argument_list|(
name|m_cursor
argument_list|)
expr_stmt|;
name|QChar
name|uc
init|=
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_cursor
operator|>
literal|0
operator|&&
name|uc
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
comment|// second half of a surrogate, check if we have the first half as well,
comment|// if yes delete both at once
name|uc
operator|=
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|.
name|isHighSurrogate
argument_list|()
condition|)
block|{
name|internalDelete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
operator|--
name|m_cursor
expr_stmt|;
block|}
block|}
name|internalDelete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|finishChange
argument_list|(
name|priorState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Handles the behavior for the delete key or function.     Removes the current selection if there is a selection, otherwise     removes the character after the cursor position.      \sa del() */
end_comment
begin_function
DECL|function|del
name|void
name|QWidgetLineControl
operator|::
name|del
parameter_list|()
block|{
name|int
name|priorState
init|=
name|m_undoState
decl_stmt|;
if|if
condition|(
name|hasSelectedText
argument_list|()
condition|)
block|{
name|removeSelectedText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
init|=
name|textLayout
argument_list|()
operator|->
name|nextCursorPosition
argument_list|(
name|m_cursor
argument_list|)
operator|-
name|m_cursor
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
name|internalDelete
argument_list|()
expr_stmt|;
block|}
name|finishChange
argument_list|(
name|priorState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Inserts the given \a newText at the current cursor position.     If there is any selected text it is removed prior to insertion of     the new text. */
end_comment
begin_function
DECL|function|insert
name|void
name|QWidgetLineControl
operator|::
name|insert
parameter_list|(
specifier|const
name|QString
modifier|&
name|newText
parameter_list|)
block|{
name|int
name|priorState
init|=
name|m_undoState
decl_stmt|;
name|removeSelectedText
argument_list|()
expr_stmt|;
name|internalInsert
argument_list|(
name|newText
argument_list|)
expr_stmt|;
name|finishChange
argument_list|(
name|priorState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Clears the line control text. */
end_comment
begin_function
DECL|function|clear
name|void
name|QWidgetLineControl
operator|::
name|clear
parameter_list|()
block|{
name|int
name|priorState
init|=
name|m_undoState
decl_stmt|;
name|m_selstart
operator|=
literal|0
expr_stmt|;
name|m_selend
operator|=
name|m_text
operator|.
name|length
argument_list|()
expr_stmt|;
name|removeSelectedText
argument_list|()
expr_stmt|;
name|separate
argument_list|()
expr_stmt|;
name|finishChange
argument_list|(
name|priorState
argument_list|,
comment|/*update*/
literal|false
argument_list|,
comment|/*edited*/
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets \a length characters from the given \a start position as selected.     The given \a start position must be within the current text for     the line control.  If \a length characters cannot be selected, then     the selection will extend to the end of the current text. */
end_comment
begin_function
DECL|function|setSelection
name|void
name|QWidgetLineControl
operator|::
name|setSelection
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|commitPreedit
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|start
operator|>
operator|(
name|int
operator|)
name|m_text
operator|.
name|length
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidgetLineControl::setSelection: Invalid start position"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|start
operator|==
name|m_selstart
operator|&&
name|start
operator|+
name|length
operator|==
name|m_selend
operator|&&
name|m_cursor
operator|==
name|m_selend
condition|)
return|return;
name|m_selstart
operator|=
name|start
expr_stmt|;
name|m_selend
operator|=
name|qMin
argument_list|(
name|start
operator|+
name|length
argument_list|,
operator|(
name|int
operator|)
name|m_text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|m_cursor
operator|=
name|m_selend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|start
operator|==
name|m_selend
operator|&&
name|start
operator|+
name|length
operator|==
name|m_selstart
operator|&&
name|m_cursor
operator|==
name|m_selstart
condition|)
return|return;
name|m_selstart
operator|=
name|qMax
argument_list|(
name|start
operator|+
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_selend
operator|=
name|start
expr_stmt|;
name|m_cursor
operator|=
name|m_selstart
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_selstart
operator|!=
name|m_selend
condition|)
block|{
name|m_selstart
operator|=
literal|0
expr_stmt|;
name|m_selend
operator|=
literal|0
expr_stmt|;
name|m_cursor
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|m_cursor
operator|=
name|start
expr_stmt|;
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
return|return;
block|}
emit|emit
name|selectionChanged
argument_list|()
emit|;
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_clipboardChanged
name|void
name|QWidgetLineControl
operator|::
name|_q_clipboardChanged
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|_q_deleteSelected
name|void
name|QWidgetLineControl
operator|::
name|_q_deleteSelected
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasSelectedText
argument_list|()
condition|)
return|return;
name|int
name|priorState
init|=
name|m_undoState
decl_stmt|;
emit|emit
name|resetInputContext
argument_list|()
emit|;
name|removeSelectedText
argument_list|()
expr_stmt|;
name|separate
argument_list|()
expr_stmt|;
name|finishChange
argument_list|(
name|priorState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Initializes the line control with a starting text value of \a txt. */
end_comment
begin_function
DECL|function|init
name|void
name|QWidgetLineControl
operator|::
name|init
parameter_list|(
specifier|const
name|QString
modifier|&
name|txt
parameter_list|)
block|{
name|m_textLayout
operator|.
name|setCacheEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|m_text
operator|=
name|txt
expr_stmt|;
name|updateDisplayText
argument_list|()
expr_stmt|;
name|m_cursor
operator|=
name|m_text
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
specifier|const
name|QPlatformTheme
modifier|*
name|theme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
condition|)
name|m_keyboardScheme
operator|=
name|theme
operator|->
name|themeHint
argument_list|(
name|QPlatformTheme
operator|::
name|KeyboardScheme
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// Generalize for X11
if|if
condition|(
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|KdeKeyboardScheme
operator|||
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|GnomeKeyboardScheme
operator|||
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|CdeKeyboardScheme
condition|)
block|{
name|m_keyboardScheme
operator|=
name|QPlatformTheme
operator|::
name|X11KeyboardScheme
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the password echo editing to \a editing.  If password echo editing     is true, then the text of the password is displayed even if the echo     mode is set to QLineEdit::PasswordEchoOnEdit.  Password echoing editing     does not affect other echo modes. */
end_comment
begin_function
DECL|function|updatePasswordEchoEditing
name|void
name|QWidgetLineControl
operator|::
name|updatePasswordEchoEditing
parameter_list|(
name|bool
name|editing
parameter_list|)
block|{
name|cancelPasswordEchoTimer
argument_list|()
expr_stmt|;
name|m_passwordEchoEditing
operator|=
name|editing
expr_stmt|;
name|updateDisplayText
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the cursor position of the given \a x pixel value in relation     to the displayed text.  The given \a betweenOrOn specified what kind     of cursor position is requested. */
end_comment
begin_function
DECL|function|xToPos
name|int
name|QWidgetLineControl
operator|::
name|xToPos
parameter_list|(
name|int
name|x
parameter_list|,
name|QTextLine
operator|::
name|CursorPosition
name|betweenOrOn
parameter_list|)
specifier|const
block|{
return|return
name|textLayout
argument_list|()
operator|->
name|lineAt
argument_list|(
literal|0
argument_list|)
operator|.
name|xToCursor
argument_list|(
name|x
argument_list|,
name|betweenOrOn
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the bounds of the current cursor, as defined as a     between characters cursor. */
end_comment
begin_function
DECL|function|cursorRect
name|QRect
name|QWidgetLineControl
operator|::
name|cursorRect
parameter_list|()
specifier|const
block|{
name|QTextLine
name|l
init|=
name|textLayout
argument_list|()
operator|->
name|lineAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|m_cursor
decl_stmt|;
if|if
condition|(
name|m_preeditCursor
operator|!=
operator|-
literal|1
condition|)
name|c
operator|+=
name|m_preeditCursor
expr_stmt|;
name|int
name|cix
init|=
name|qRound
argument_list|(
name|l
operator|.
name|cursorToX
argument_list|(
name|c
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|m_cursorWidth
decl_stmt|;
name|int
name|ch
init|=
name|l
operator|.
name|height
argument_list|()
operator|+
literal|1
decl_stmt|;
return|return
name|QRect
argument_list|(
name|cix
operator|-
literal|5
argument_list|,
literal|0
argument_list|,
name|w
operator|+
literal|9
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Fixes the current text so that it is valid given any set validators.      Returns true if the text was changed.  Otherwise returns false. */
end_comment
begin_function
DECL|function|fixup
name|bool
name|QWidgetLineControl
operator|::
name|fixup
parameter_list|()
comment|// this function assumes that validate currently returns != Acceptable
block|{
ifndef|#
directive|ifndef
name|QT_NO_VALIDATOR
if|if
condition|(
name|m_validator
condition|)
block|{
name|QString
name|textCopy
init|=
name|m_text
decl_stmt|;
name|int
name|cursorCopy
init|=
name|m_cursor
decl_stmt|;
name|m_validator
operator|->
name|fixup
argument_list|(
name|textCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_validator
operator|->
name|validate
argument_list|(
name|textCopy
argument_list|,
name|cursorCopy
argument_list|)
operator|==
name|QValidator
operator|::
name|Acceptable
condition|)
block|{
if|if
condition|(
name|textCopy
operator|!=
name|m_text
operator|||
name|cursorCopy
operator|!=
name|m_cursor
condition|)
name|internalSetText
argument_list|(
name|textCopy
argument_list|,
name|cursorCopy
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Moves the cursor to the given position \a pos.   If \a mark is true will     adjust the currently selected text. */
end_comment
begin_function
DECL|function|moveCursor
name|void
name|QWidgetLineControl
operator|::
name|moveCursor
parameter_list|(
name|int
name|pos
parameter_list|,
name|bool
name|mark
parameter_list|)
block|{
name|commitPreedit
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|m_cursor
condition|)
block|{
name|separate
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_maskData
condition|)
name|pos
operator|=
name|pos
operator|>
name|m_cursor
condition|?
name|nextMaskBlank
argument_list|(
name|pos
argument_list|)
else|:
name|prevMaskBlank
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mark
condition|)
block|{
name|int
name|anchor
decl_stmt|;
if|if
condition|(
name|m_selend
operator|>
name|m_selstart
operator|&&
name|m_cursor
operator|==
name|m_selstart
condition|)
name|anchor
operator|=
name|m_selend
expr_stmt|;
elseif|else
if|if
condition|(
name|m_selend
operator|>
name|m_selstart
operator|&&
name|m_cursor
operator|==
name|m_selend
condition|)
name|anchor
operator|=
name|m_selstart
expr_stmt|;
else|else
name|anchor
operator|=
name|m_cursor
expr_stmt|;
name|m_selstart
operator|=
name|qMin
argument_list|(
name|anchor
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|m_selend
operator|=
name|qMax
argument_list|(
name|anchor
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|updateDisplayText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|internalDeselect
argument_list|()
expr_stmt|;
block|}
name|m_cursor
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|mark
operator|||
name|m_selDirty
condition|)
block|{
name|m_selDirty
operator|=
literal|false
expr_stmt|;
emit|emit
name|selectionChanged
argument_list|()
emit|;
block|}
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Applies the given input method event \a event to the text of the line     control */
end_comment
begin_function
DECL|function|processInputMethodEvent
name|void
name|QWidgetLineControl
operator|::
name|processInputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|int
name|priorState
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|isGettingInput
init|=
operator|!
name|event
operator|->
name|commitString
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|event
operator|->
name|preeditString
argument_list|()
operator|!=
name|preeditAreaText
argument_list|()
operator|||
name|event
operator|->
name|replacementLength
argument_list|()
operator|>
literal|0
decl_stmt|;
name|bool
name|cursorPositionChanged
init|=
literal|false
decl_stmt|;
name|bool
name|selectionChange
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|isGettingInput
condition|)
block|{
comment|// If any text is being input, remove selected text.
name|priorState
operator|=
name|m_undoState
expr_stmt|;
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|PasswordEchoOnEdit
operator|&&
operator|!
name|passwordEchoEditing
argument_list|()
condition|)
block|{
name|updatePasswordEchoEditing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|m_selstart
operator|=
literal|0
expr_stmt|;
name|m_selend
operator|=
name|m_text
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|removeSelectedText
argument_list|()
expr_stmt|;
block|}
name|int
name|c
init|=
name|m_cursor
decl_stmt|;
comment|// cursor position after insertion of commit string
if|if
condition|(
name|event
operator|->
name|replacementStart
argument_list|()
operator|<=
literal|0
condition|)
name|c
operator|+=
name|event
operator|->
name|commitString
argument_list|()
operator|.
name|length
argument_list|()
operator|-
name|qMin
argument_list|(
operator|-
name|event
operator|->
name|replacementStart
argument_list|()
argument_list|,
name|event
operator|->
name|replacementLength
argument_list|()
argument_list|)
expr_stmt|;
name|m_cursor
operator|+=
name|event
operator|->
name|replacementStart
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_cursor
operator|<
literal|0
condition|)
name|m_cursor
operator|=
literal|0
expr_stmt|;
comment|// insert commit string
if|if
condition|(
name|event
operator|->
name|replacementLength
argument_list|()
condition|)
block|{
name|m_selstart
operator|=
name|m_cursor
expr_stmt|;
name|m_selend
operator|=
name|m_selstart
operator|+
name|event
operator|->
name|replacementLength
argument_list|()
expr_stmt|;
name|removeSelectedText
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|event
operator|->
name|commitString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|internalInsert
argument_list|(
name|event
operator|->
name|commitString
argument_list|()
argument_list|)
expr_stmt|;
name|cursorPositionChanged
operator|=
literal|true
expr_stmt|;
block|}
name|m_cursor
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|c
argument_list|,
name|m_text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|event
operator|->
name|attributes
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QInputMethodEvent
operator|::
name|Attribute
modifier|&
name|a
init|=
name|event
operator|->
name|attributes
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|QInputMethodEvent
operator|::
name|Selection
condition|)
block|{
name|m_cursor
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|a
operator|.
name|start
operator|+
name|a
operator|.
name|length
argument_list|,
name|m_text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|length
condition|)
block|{
name|m_selstart
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|qMin
argument_list|(
name|a
operator|.
name|start
argument_list|,
name|m_text
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_selend
operator|=
name|m_cursor
expr_stmt|;
if|if
condition|(
name|m_selend
operator|<
name|m_selstart
condition|)
block|{
name|qSwap
argument_list|(
name|m_selstart
argument_list|,
name|m_selend
argument_list|)
expr_stmt|;
block|}
name|selectionChange
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|m_selstart
operator|!=
name|m_selend
condition|)
name|selectionChange
operator|=
literal|true
expr_stmt|;
name|m_selstart
operator|=
name|m_selend
operator|=
literal|0
expr_stmt|;
block|}
name|cursorPositionChanged
operator|=
literal|true
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_IM
name|setPreeditArea
argument_list|(
name|m_cursor
argument_list|,
name|event
operator|->
name|preeditString
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_IM
specifier|const
name|int
name|oldPreeditCursor
init|=
name|m_preeditCursor
decl_stmt|;
name|m_preeditCursor
operator|=
name|event
operator|->
name|preeditString
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
name|m_hideCursor
operator|=
literal|false
expr_stmt|;
name|QList
argument_list|<
name|QTextLayout
operator|::
name|FormatRange
argument_list|>
name|formats
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|event
operator|->
name|attributes
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QInputMethodEvent
operator|::
name|Attribute
modifier|&
name|a
init|=
name|event
operator|->
name|attributes
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|QInputMethodEvent
operator|::
name|Cursor
condition|)
block|{
name|m_preeditCursor
operator|=
name|a
operator|.
name|start
expr_stmt|;
name|m_hideCursor
operator|=
operator|!
name|a
operator|.
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|QInputMethodEvent
operator|::
name|TextFormat
condition|)
block|{
name|QTextCharFormat
name|f
init|=
name|qvariant_cast
argument_list|<
name|QTextFormat
argument_list|>
argument_list|(
name|a
operator|.
name|value
argument_list|)
operator|.
name|toCharFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QTextLayout
operator|::
name|FormatRange
name|o
decl_stmt|;
name|o
operator|.
name|start
operator|=
name|a
operator|.
name|start
operator|+
name|m_cursor
expr_stmt|;
name|o
operator|.
name|length
operator|=
name|a
operator|.
name|length
expr_stmt|;
name|o
operator|.
name|format
operator|=
name|f
expr_stmt|;
name|formats
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|m_textLayout
operator|.
name|setAdditionalFormats
argument_list|(
name|formats
argument_list|)
expr_stmt|;
name|updateDisplayText
argument_list|(
comment|/*force*/
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursorPositionChanged
condition|)
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|m_preeditCursor
operator|!=
name|oldPreeditCursor
condition|)
emit|emit
name|updateMicroFocus
argument_list|()
emit|;
if|if
condition|(
name|isGettingInput
condition|)
name|finishChange
argument_list|(
name|priorState
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectionChange
condition|)
emit|emit
name|selectionChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      Draws the display text for the line control using the given     \a painter, \a clip, and \a offset.  Which aspects of the display text     are drawn is specified by the given \a flags.      If the flags contain DrawSelections, then the selection or input mask     backgrounds and foregrounds will be applied before drawing the text.      If the flags contain DrawCursor a cursor of the current cursorWidth()     will be drawn after drawing the text.      The display text will only be drawn if the flags contain DrawText */
end_comment
begin_function
DECL|function|draw
name|void
name|QWidgetLineControl
operator|::
name|draw
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|,
specifier|const
name|QRect
modifier|&
name|clip
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|QVector
argument_list|<
name|QTextLayout
operator|::
name|FormatRange
argument_list|>
name|selections
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DrawSelections
condition|)
block|{
name|QTextLayout
operator|::
name|FormatRange
name|o
decl_stmt|;
if|if
condition|(
name|m_selstart
operator|<
name|m_selend
condition|)
block|{
name|o
operator|.
name|start
operator|=
name|m_selstart
expr_stmt|;
name|o
operator|.
name|length
operator|=
name|m_selend
operator|-
name|m_selstart
expr_stmt|;
name|o
operator|.
name|format
operator|.
name|setBackground
argument_list|(
name|m_palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Highlight
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|.
name|format
operator|.
name|setForeground
argument_list|(
name|m_palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|HighlightedText
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// mask selection
if|if
condition|(
operator|!
name|m_blinkPeriod
operator|||
name|m_blinkStatus
condition|)
block|{
name|o
operator|.
name|start
operator|=
name|m_cursor
expr_stmt|;
name|o
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|o
operator|.
name|format
operator|.
name|setBackground
argument_list|(
name|m_palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|.
name|format
operator|.
name|setForeground
argument_list|(
name|m_palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Window
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|selections
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DrawText
condition|)
name|textLayout
argument_list|()
operator|->
name|draw
argument_list|(
name|painter
argument_list|,
name|offset
argument_list|,
name|selections
argument_list|,
name|clip
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DrawCursor
condition|)
block|{
name|int
name|cursor
init|=
name|m_cursor
decl_stmt|;
if|if
condition|(
name|m_preeditCursor
operator|!=
operator|-
literal|1
condition|)
name|cursor
operator|+=
name|m_preeditCursor
expr_stmt|;
if|if
condition|(
operator|!
name|m_hideCursor
operator|&&
operator|(
operator|!
name|m_blinkPeriod
operator|||
name|m_blinkStatus
operator|)
condition|)
name|textLayout
argument_list|()
operator|->
name|drawCursor
argument_list|(
name|painter
argument_list|,
name|offset
argument_list|,
name|cursor
argument_list|,
name|m_cursorWidth
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the selection to cover the word at the given cursor position.     The word boundaries are defined by the behavior of QTextLayout::SkipWords     cursor mode. */
end_comment
begin_function
DECL|function|selectWordAtPos
name|void
name|QWidgetLineControl
operator|::
name|selectWordAtPos
parameter_list|(
name|int
name|cursor
parameter_list|)
block|{
name|int
name|next
init|=
name|cursor
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|next
operator|>
name|end
argument_list|()
condition|)
operator|--
name|next
expr_stmt|;
name|int
name|c
init|=
name|textLayout
argument_list|()
operator|->
name|previousCursorPosition
argument_list|(
name|next
argument_list|,
name|QTextLayout
operator|::
name|SkipWords
argument_list|)
decl_stmt|;
name|moveCursor
argument_list|(
name|c
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// ## text layout should support end of words.
name|int
name|end
init|=
name|textLayout
argument_list|()
operator|->
name|nextCursorPosition
argument_list|(
name|c
argument_list|,
name|QTextLayout
operator|::
name|SkipWords
argument_list|)
decl_stmt|;
while|while
condition|(
name|end
operator|>
name|cursor
operator|&&
name|m_text
index|[
name|end
operator|-
literal|1
index|]
operator|.
name|isSpace
argument_list|()
condition|)
operator|--
name|end
expr_stmt|;
name|moveCursor
argument_list|(
name|end
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Completes a change to the line control text.  If the change is not valid     will undo the line control state back to the given \a validateFromState.      If \a edited is true and the change is valid, will emit textEdited() in     addition to textChanged().  Otherwise only emits textChanged() on a valid     change.      The \a update value is currently unused. */
end_comment
begin_function
DECL|function|finishChange
name|bool
name|QWidgetLineControl
operator|::
name|finishChange
parameter_list|(
name|int
name|validateFromState
parameter_list|,
name|bool
name|update
parameter_list|,
name|bool
name|edited
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|update
argument_list|)
if|if
condition|(
name|m_textDirty
condition|)
block|{
comment|// do validation
name|bool
name|wasValidInput
init|=
name|m_validInput
decl_stmt|;
name|m_validInput
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_VALIDATOR
if|if
condition|(
name|m_validator
condition|)
block|{
name|QString
name|textCopy
init|=
name|m_text
decl_stmt|;
name|int
name|cursorCopy
init|=
name|m_cursor
decl_stmt|;
name|m_validInput
operator|=
operator|(
name|m_validator
operator|->
name|validate
argument_list|(
name|textCopy
argument_list|,
name|cursorCopy
argument_list|)
operator|!=
name|QValidator
operator|::
name|Invalid
operator|)
expr_stmt|;
if|if
condition|(
name|m_validInput
condition|)
block|{
if|if
condition|(
name|m_text
operator|!=
name|textCopy
condition|)
block|{
name|internalSetText
argument_list|(
name|textCopy
argument_list|,
name|cursorCopy
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|m_cursor
operator|=
name|cursorCopy
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|validateFromState
operator|>=
literal|0
operator|&&
name|wasValidInput
operator|&&
operator|!
name|m_validInput
condition|)
block|{
if|if
condition|(
name|m_transactions
operator|.
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
name|internalUndo
argument_list|(
name|validateFromState
argument_list|)
expr_stmt|;
name|m_history
operator|.
name|resize
argument_list|(
name|m_undoState
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_modifiedState
operator|>
name|m_undoState
condition|)
name|m_modifiedState
operator|=
operator|-
literal|1
expr_stmt|;
name|m_validInput
operator|=
literal|true
expr_stmt|;
name|m_textDirty
operator|=
literal|false
expr_stmt|;
block|}
name|updateDisplayText
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_textDirty
condition|)
block|{
name|m_textDirty
operator|=
literal|false
expr_stmt|;
name|QString
name|actualText
init|=
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
name|edited
condition|)
emit|emit
name|textEdited
argument_list|(
name|actualText
argument_list|)
emit|;
emit|emit
name|textChanged
argument_list|(
name|actualText
argument_list|)
emit|;
block|}
block|}
if|if
condition|(
name|m_selDirty
condition|)
block|{
name|m_selDirty
operator|=
literal|false
expr_stmt|;
emit|emit
name|selectionChanged
argument_list|()
emit|;
block|}
if|if
condition|(
name|m_cursor
operator|==
name|m_lastCursorPos
condition|)
name|updateMicroFocus
argument_list|()
expr_stmt|;
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      An internal function for setting the text of the line control. */
end_comment
begin_function
DECL|function|internalSetText
name|void
name|QWidgetLineControl
operator|::
name|internalSetText
parameter_list|(
specifier|const
name|QString
modifier|&
name|txt
parameter_list|,
name|int
name|pos
parameter_list|,
name|bool
name|edited
parameter_list|)
block|{
name|cancelPasswordEchoTimer
argument_list|()
expr_stmt|;
name|internalDeselect
argument_list|()
expr_stmt|;
emit|emit
name|resetInputContext
argument_list|()
emit|;
name|QString
name|oldText
init|=
name|m_text
decl_stmt|;
if|if
condition|(
name|m_maskData
condition|)
block|{
name|m_text
operator|=
name|maskString
argument_list|(
literal|0
argument_list|,
name|txt
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|m_text
operator|+=
name|clearString
argument_list|(
name|m_text
operator|.
name|length
argument_list|()
argument_list|,
name|m_maxLength
operator|-
name|m_text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_text
operator|=
name|txt
operator|.
name|isEmpty
argument_list|()
condition|?
name|txt
else|:
name|txt
operator|.
name|left
argument_list|(
name|m_maxLength
argument_list|)
expr_stmt|;
block|}
name|m_history
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_modifiedState
operator|=
name|m_undoState
operator|=
literal|0
expr_stmt|;
name|m_cursor
operator|=
operator|(
name|pos
argument_list|<
literal|0
operator|||
name|pos
argument_list|>
name|m_text
operator|.
name|length
argument_list|()
operator|)
condition|?
name|m_text
operator|.
name|length
argument_list|()
else|:
name|pos
expr_stmt|;
name|m_textDirty
operator|=
operator|(
name|oldText
operator|!=
name|m_text
operator|)
expr_stmt|;
specifier|const
name|bool
name|changed
init|=
name|finishChange
argument_list|(
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
name|edited
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|oldText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QAccessibleTextInsertEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|)
decl_stmt|;
name|event
operator|.
name|setCursorPosition
argument_list|(
name|m_cursor
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|txt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QAccessibleTextRemoveEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
literal|0
argument_list|,
name|oldText
argument_list|)
decl_stmt|;
name|event
operator|.
name|setCursorPosition
argument_list|(
name|m_cursor
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QAccessibleTextUpdateEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
literal|0
argument_list|,
name|oldText
argument_list|,
name|txt
argument_list|)
decl_stmt|;
name|event
operator|.
name|setCursorPosition
argument_list|(
name|m_cursor
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|changed
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      Adds the given \a command to the undo history     of the line control.  Does not apply the command. */
end_comment
begin_function
DECL|function|addCommand
name|void
name|QWidgetLineControl
operator|::
name|addCommand
parameter_list|(
specifier|const
name|Command
modifier|&
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|m_separator
operator|&&
name|m_undoState
operator|&&
name|m_history
index|[
name|m_undoState
operator|-
literal|1
index|]
operator|.
name|type
operator|!=
name|Separator
condition|)
block|{
name|m_history
operator|.
name|resize
argument_list|(
name|m_undoState
operator|+
literal|2
argument_list|)
expr_stmt|;
name|m_history
index|[
name|m_undoState
operator|++
index|]
operator|=
name|Command
argument_list|(
name|Separator
argument_list|,
name|m_cursor
argument_list|,
literal|0
argument_list|,
name|m_selstart
argument_list|,
name|m_selend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_history
operator|.
name|resize
argument_list|(
name|m_undoState
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|m_separator
operator|=
literal|false
expr_stmt|;
name|m_history
index|[
name|m_undoState
operator|++
index|]
operator|=
name|cmd
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Inserts the given string \a s into the line     control.      Also adds the appropriate commands into the undo history.     This function does not call finishChange(), and may leave the text     in an invalid state. */
end_comment
begin_function
DECL|function|internalInsert
name|void
name|QWidgetLineControl
operator|::
name|internalInsert
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|Password
condition|)
block|{
if|if
condition|(
name|m_passwordEchoTimer
operator|!=
literal|0
condition|)
name|killTimer
argument_list|(
name|m_passwordEchoTimer
argument_list|)
expr_stmt|;
name|int
name|delay
init|=
name|qGuiApp
operator|->
name|styleHints
argument_list|()
operator|->
name|passwordMaskDelay
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
if|if
condition|(
name|m_passwordMaskDelayOverride
operator|>=
literal|0
condition|)
name|delay
operator|=
name|m_passwordMaskDelayOverride
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|m_passwordEchoTimer
operator|=
name|startTimer
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasSelectedText
argument_list|()
condition|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|SetSelection
argument_list|,
name|m_cursor
argument_list|,
literal|0
argument_list|,
name|m_selstart
argument_list|,
name|m_selend
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_maskData
condition|)
block|{
name|QString
name|ms
init|=
name|maskString
argument_list|(
name|m_cursor
argument_list|,
name|s
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextInsertEvent
name|insertEvent
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_cursor
argument_list|,
name|ms
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|insertEvent
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ms
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|addCommand
argument_list|(
name|Command
argument_list|(
name|DeleteSelection
argument_list|,
name|m_cursor
operator|+
name|i
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
operator|+
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addCommand
argument_list|(
name|Command
argument_list|(
name|Insert
argument_list|,
name|m_cursor
operator|+
name|i
argument_list|,
name|ms
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m_text
operator|.
name|replace
argument_list|(
name|m_cursor
argument_list|,
name|ms
operator|.
name|length
argument_list|()
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|m_cursor
operator|+=
name|ms
operator|.
name|length
argument_list|()
expr_stmt|;
name|m_cursor
operator|=
name|nextMaskBlank
argument_list|(
name|m_cursor
argument_list|)
expr_stmt|;
name|m_textDirty
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextCursorEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_cursor
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|int
name|remaining
init|=
name|m_maxLength
operator|-
name|m_text
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextInsertEvent
name|insertEvent
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_cursor
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|insertEvent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_text
operator|.
name|insert
argument_list|(
name|m_cursor
argument_list|,
name|s
operator|.
name|left
argument_list|(
name|remaining
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|s
operator|.
name|left
argument_list|(
name|remaining
argument_list|)
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|Insert
argument_list|,
name|m_cursor
operator|++
argument_list|,
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|m_textDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      deletes a single character from the current text.  If \a wasBackspace,     the character prior to the cursor is removed.  Otherwise the character     after the cursor is removed.      Also adds the appropriate commands into the undo history.     This function does not call finishChange(), and may leave the text     in an invalid state. */
end_comment
begin_function
DECL|function|internalDelete
name|void
name|QWidgetLineControl
operator|::
name|internalDelete
parameter_list|(
name|bool
name|wasBackspace
parameter_list|)
block|{
if|if
condition|(
name|m_cursor
operator|<
operator|(
name|int
operator|)
name|m_text
operator|.
name|length
argument_list|()
condition|)
block|{
name|cancelPasswordEchoTimer
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasSelectedText
argument_list|()
condition|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|SetSelection
argument_list|,
name|m_cursor
argument_list|,
literal|0
argument_list|,
name|m_selstart
argument_list|,
name|m_selend
argument_list|)
argument_list|)
expr_stmt|;
name|addCommand
argument_list|(
name|Command
argument_list|(
call|(
name|CommandType
call|)
argument_list|(
operator|(
name|m_maskData
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|wasBackspace
condition|?
name|Remove
else|:
name|Delete
operator|)
argument_list|)
argument_list|,
name|m_cursor
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextRemoveEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_cursor
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
argument_list|)
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_maskData
condition|)
block|{
name|m_text
operator|.
name|replace
argument_list|(
name|m_cursor
argument_list|,
literal|1
argument_list|,
name|clearString
argument_list|(
name|m_cursor
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|addCommand
argument_list|(
name|Command
argument_list|(
name|Insert
argument_list|,
name|m_cursor
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|m_cursor
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_text
operator|.
name|remove
argument_list|(
name|m_cursor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|m_textDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      removes the currently selected text from the line control.      Also adds the appropriate commands into the undo history.     This function does not call finishChange(), and may leave the text     in an invalid state. */
end_comment
begin_function
DECL|function|removeSelectedText
name|void
name|QWidgetLineControl
operator|::
name|removeSelectedText
parameter_list|()
block|{
if|if
condition|(
name|m_selstart
operator|<
name|m_selend
operator|&&
name|m_selend
operator|<=
operator|(
name|int
operator|)
name|m_text
operator|.
name|length
argument_list|()
condition|)
block|{
name|cancelPasswordEchoTimer
argument_list|()
expr_stmt|;
name|separate
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
name|addCommand
argument_list|(
name|Command
argument_list|(
name|SetSelection
argument_list|,
name|m_cursor
argument_list|,
literal|0
argument_list|,
name|m_selstart
argument_list|,
name|m_selend
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_selstart
operator|<=
name|m_cursor
operator|&&
name|m_cursor
operator|<
name|m_selend
condition|)
block|{
comment|// cursor is within the selection. Split up the commands
comment|// to be able to restore the correct cursor position
for|for
control|(
name|i
operator|=
name|m_cursor
init|;
name|i
operator|>=
name|m_selstart
condition|;
operator|--
name|i
control|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|DeleteSelection
argument_list|,
name|i
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m_selend
operator|-
literal|1
init|;
name|i
operator|>
name|m_cursor
condition|;
operator|--
name|i
control|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|DeleteSelection
argument_list|,
name|i
operator|-
name|m_cursor
operator|+
name|m_selstart
operator|-
literal|1
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|m_selend
operator|-
literal|1
init|;
name|i
operator|>=
name|m_selstart
condition|;
operator|--
name|i
control|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|RemoveSelection
argument_list|,
name|i
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleTextRemoveEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_selstart
argument_list|,
name|m_text
operator|.
name|mid
argument_list|(
name|m_selstart
argument_list|,
name|m_selend
operator|-
name|m_selstart
argument_list|)
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_maskData
condition|)
block|{
name|m_text
operator|.
name|replace
argument_list|(
name|m_selstart
argument_list|,
name|m_selend
operator|-
name|m_selstart
argument_list|,
name|clearString
argument_list|(
name|m_selstart
argument_list|,
name|m_selend
operator|-
name|m_selstart
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_selend
operator|-
name|m_selstart
condition|;
operator|++
name|i
control|)
name|addCommand
argument_list|(
name|Command
argument_list|(
name|Insert
argument_list|,
name|m_selstart
operator|+
name|i
argument_list|,
name|m_text
operator|.
name|at
argument_list|(
name|m_selstart
operator|+
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_text
operator|.
name|remove
argument_list|(
name|m_selstart
argument_list|,
name|m_selend
operator|-
name|m_selstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_cursor
operator|>
name|m_selstart
condition|)
name|m_cursor
operator|-=
name|qMin
argument_list|(
name|m_cursor
argument_list|,
name|m_selend
argument_list|)
operator|-
name|m_selstart
expr_stmt|;
name|internalDeselect
argument_list|()
expr_stmt|;
name|m_textDirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Parses the input mask specified by \a maskFields to generate     the mask data used to handle input masks. */
end_comment
begin_function
DECL|function|parseInputMask
name|void
name|QWidgetLineControl
operator|::
name|parseInputMask
parameter_list|(
specifier|const
name|QString
modifier|&
name|maskFields
parameter_list|)
block|{
name|int
name|delimiter
init|=
name|maskFields
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maskFields
operator|.
name|isEmpty
argument_list|()
operator|||
name|delimiter
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m_maskData
condition|)
block|{
operator|delete
index|[]
name|m_maskData
expr_stmt|;
name|m_maskData
operator|=
literal|0
expr_stmt|;
name|m_maxLength
operator|=
literal|32767
expr_stmt|;
name|internalSetText
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|delimiter
operator|==
operator|-
literal|1
condition|)
block|{
name|m_blank
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|m_inputMask
operator|=
name|maskFields
expr_stmt|;
block|}
else|else
block|{
name|m_inputMask
operator|=
name|maskFields
operator|.
name|left
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
name|m_blank
operator|=
operator|(
name|delimiter
operator|+
literal|1
operator|<
name|maskFields
operator|.
name|length
argument_list|()
operator|)
condition|?
name|maskFields
index|[
name|delimiter
operator|+
literal|1
index|]
else|:
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|// calculate m_maxLength / m_maskData length
name|m_maxLength
operator|=
literal|0
expr_stmt|;
name|QChar
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_inputMask
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|m_inputMask
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|m_inputMask
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
name|m_maxLength
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
name|m_maxLength
operator|++
expr_stmt|;
block|}
operator|delete
index|[]
name|m_maskData
expr_stmt|;
name|m_maskData
operator|=
operator|new
name|MaskInputData
index|[
name|m_maxLength
index|]
expr_stmt|;
name|MaskInputData
operator|::
name|Casemode
name|m
init|=
name|MaskInputData
operator|::
name|NoCaseMode
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|bool
name|s
decl_stmt|;
name|bool
name|escape
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_inputMask
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|m_inputMask
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape
condition|)
block|{
name|s
operator|=
literal|true
expr_stmt|;
name|m_maskData
index|[
name|index
index|]
operator|.
name|maskChar
operator|=
name|c
expr_stmt|;
name|m_maskData
index|[
name|index
index|]
operator|.
name|separator
operator|=
name|s
expr_stmt|;
name|m_maskData
index|[
name|index
index|]
operator|.
name|caseMode
operator|=
name|m
expr_stmt|;
name|index
operator|++
expr_stmt|;
name|escape
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
name|m
operator|=
name|MaskInputData
operator|::
name|Lower
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|m
operator|=
name|MaskInputData
operator|::
name|Upper
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
condition|)
block|{
name|m
operator|=
name|MaskInputData
operator|::
name|NoCaseMode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|'['
argument_list|)
operator|&&
name|c
operator|!=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
case|case
literal|'N'
case|:
case|case
literal|'n'
case|:
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
case|case
literal|'9'
case|:
case|case
literal|'0'
case|:
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
case|case
literal|'#'
case|:
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|s
operator|=
literal|false
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|escape
operator|=
literal|true
expr_stmt|;
default|default:
name|s
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|escape
condition|)
block|{
name|m_maskData
index|[
name|index
index|]
operator|.
name|maskChar
operator|=
name|c
expr_stmt|;
name|m_maskData
index|[
name|index
index|]
operator|.
name|separator
operator|=
name|s
expr_stmt|;
name|m_maskData
index|[
name|index
index|]
operator|.
name|caseMode
operator|=
name|m
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
name|internalSetText
argument_list|(
name|m_text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      checks if the key is valid compared to the inputMask */
end_comment
begin_function
DECL|function|isValidInput
name|bool
name|QWidgetLineControl
operator|::
name|isValidInput
parameter_list|(
name|QChar
name|key
parameter_list|,
name|QChar
name|mask
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|mask
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
name|key
operator|.
name|isLetter
argument_list|()
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|key
operator|.
name|isLetter
argument_list|()
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|key
operator|.
name|isLetterOrNumber
argument_list|()
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|key
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|key
operator|.
name|isPrint
argument_list|()
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|key
operator|.
name|isPrint
argument_list|()
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'9'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
operator|&&
name|key
operator|.
name|digitValue
argument_list|()
operator|>
literal|0
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|(
name|key
operator|.
name|isNumber
argument_list|()
operator|&&
name|key
operator|.
name|digitValue
argument_list|()
operator|>
literal|0
operator|)
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
operator|||
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|||
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
operator|||
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'1'
argument_list|)
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
operator|||
name|key
operator|==
name|QLatin1Char
argument_list|(
literal|'1'
argument_list|)
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
operator|||
operator|(
name|key
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|key
operator|<=
name|QLatin1Char
argument_list|(
literal|'f'
argument_list|)
operator|)
operator|||
operator|(
name|key
operator|>=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
operator|&&
name|key
operator|<=
name|QLatin1Char
argument_list|(
literal|'F'
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|key
operator|.
name|isNumber
argument_list|()
operator|||
operator|(
name|key
operator|>=
name|QLatin1Char
argument_list|(
literal|'a'
argument_list|)
operator|&&
name|key
operator|<=
name|QLatin1Char
argument_list|(
literal|'f'
argument_list|)
operator|)
operator|||
operator|(
name|key
operator|>=
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
operator|&&
name|key
operator|<=
name|QLatin1Char
argument_list|(
literal|'F'
argument_list|)
operator|)
operator|||
name|key
operator|==
name|m_blank
condition|)
return|return
literal|true
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns true if the given text \a str is valid for any     validator or input mask set for the line control.      Otherwise returns false */
end_comment
begin_function
DECL|function|hasAcceptableInput
name|bool
name|QWidgetLineControl
operator|::
name|hasAcceptableInput
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_VALIDATOR
name|QString
name|textCopy
init|=
name|str
decl_stmt|;
name|int
name|cursorCopy
init|=
name|m_cursor
decl_stmt|;
if|if
condition|(
name|m_validator
operator|&&
name|m_validator
operator|->
name|validate
argument_list|(
name|textCopy
argument_list|,
name|cursorCopy
argument_list|)
operator|!=
name|QValidator
operator|::
name|Acceptable
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_maskData
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|!=
name|m_maxLength
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_maxLength
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isValidInput
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Applies the inputMask on \a str starting from position \a pos in the mask. \a clear     specifies from where characters should be gotten when a separator is met in \a str - true means     that blanks will be used, false that previous input is used.     Calling this when no inputMask is set is undefined. */
end_comment
begin_function
DECL|function|maskString
name|QString
name|QWidgetLineControl
operator|::
name|maskString
parameter_list|(
name|uint
name|pos
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|bool
name|clear
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|pos
operator|>=
operator|(
name|uint
operator|)
name|m_maxLength
condition|)
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|)
return|;
name|QString
name|fill
decl_stmt|;
name|fill
operator|=
name|clear
condition|?
name|clearString
argument_list|(
literal|0
argument_list|,
name|m_maxLength
argument_list|)
else|:
name|m_text
expr_stmt|;
name|int
name|strIndex
init|=
literal|0
decl_stmt|;
name|QString
name|s
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|m_maxLength
condition|)
block|{
if|if
condition|(
name|strIndex
operator|<
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
condition|)
block|{
name|s
operator|+=
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
expr_stmt|;
if|if
condition|(
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|==
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
condition|)
name|strIndex
operator|++
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isValidInput
argument_list|(
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
argument_list|,
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|caseMode
condition|)
block|{
case|case
name|MaskInputData
operator|::
name|Upper
case|:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
break|break;
case|case
name|MaskInputData
operator|::
name|Lower
case|:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
break|break;
default|default:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
comment|// search for separator first
name|int
name|n
init|=
name|findInMask
argument_list|(
name|i
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|!=
literal|1
operator|||
name|i
operator|==
literal|0
operator|||
operator|(
name|i
operator|>
literal|0
operator|&&
operator|(
operator|!
name|m_maskData
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|separator
operator|||
name|m_maskData
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|maskChar
operator|!=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|)
operator|)
condition|)
block|{
name|s
operator|+=
name|fill
operator|.
name|mid
argument_list|(
name|i
argument_list|,
name|n
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|n
operator|+
literal|1
expr_stmt|;
comment|// update i to find + 1
block|}
block|}
else|else
block|{
comment|// search for valid m_blank if not
name|n
operator|=
name|findInMask
argument_list|(
name|i
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|+=
name|fill
operator|.
name|mid
argument_list|(
name|i
argument_list|,
name|n
operator|-
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m_maskData
index|[
name|n
index|]
operator|.
name|caseMode
condition|)
block|{
case|case
name|MaskInputData
operator|::
name|Upper
case|:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
break|break;
case|case
name|MaskInputData
operator|::
name|Lower
case|:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
operator|.
name|toLower
argument_list|()
expr_stmt|;
break|break;
default|default:
name|s
operator|+=
name|str
index|[
operator|(
name|int
operator|)
name|strIndex
index|]
expr_stmt|;
block|}
name|i
operator|=
name|n
operator|+
literal|1
expr_stmt|;
comment|// updates i to find + 1
block|}
block|}
block|}
operator|++
name|strIndex
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns a "cleared" string with only separators and blank chars.     Calling this when no inputMask is set is undefined. */
end_comment
begin_function
DECL|function|clearString
name|QString
name|QWidgetLineControl
operator|::
name|clearString
parameter_list|(
name|uint
name|pos
parameter_list|,
name|uint
name|len
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|pos
operator|>=
operator|(
name|uint
operator|)
name|m_maxLength
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|s
decl_stmt|;
name|int
name|end
init|=
name|qMin
argument_list|(
operator|(
name|uint
operator|)
name|m_maxLength
argument_list|,
name|pos
operator|+
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pos
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
condition|)
name|s
operator|+=
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
expr_stmt|;
else|else
name|s
operator|+=
name|m_blank
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Strips blank parts of the input in a QWidgetLineControl when an inputMask is set,     separators are still included. Typically "127.0__.0__.1__" becomes "127.0.0.1". */
end_comment
begin_function
DECL|function|stripString
name|QString
name|QWidgetLineControl
operator|::
name|stripString
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|m_maskData
condition|)
return|return
name|str
return|;
name|QString
name|s
decl_stmt|;
name|int
name|end
init|=
name|qMin
argument_list|(
name|m_maxLength
argument_list|,
operator|(
name|int
operator|)
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
condition|)
name|s
operator|+=
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
expr_stmt|;
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|!=
name|m_blank
condition|)
name|s
operator|+=
name|str
index|[
name|i
index|]
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     searches forward/backward in m_maskData for either a separator or a m_blank */
end_comment
begin_function
DECL|function|findInMask
name|int
name|QWidgetLineControl
operator|::
name|findInMask
parameter_list|(
name|int
name|pos
parameter_list|,
name|bool
name|forward
parameter_list|,
name|bool
name|findSeparator
parameter_list|,
name|QChar
name|searchChar
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|pos
operator|>=
name|m_maxLength
operator|||
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|end
init|=
name|forward
condition|?
name|m_maxLength
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|step
init|=
name|forward
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
name|pos
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|findSeparator
condition|)
block|{
if|if
condition|(
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
operator|&&
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
operator|==
name|searchChar
condition|)
return|return
name|i
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|m_maskData
index|[
name|i
index|]
operator|.
name|separator
condition|)
block|{
if|if
condition|(
name|searchChar
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|i
return|;
elseif|else
if|if
condition|(
name|isValidInput
argument_list|(
name|searchChar
argument_list|,
name|m_maskData
index|[
name|i
index|]
operator|.
name|maskChar
argument_list|)
condition|)
return|return
name|i
return|;
block|}
block|}
name|i
operator|+=
name|step
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|internalUndo
name|void
name|QWidgetLineControl
operator|::
name|internalUndo
parameter_list|(
name|int
name|until
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isUndoAvailable
argument_list|()
condition|)
return|return;
name|cancelPasswordEchoTimer
argument_list|()
expr_stmt|;
name|internalDeselect
argument_list|()
expr_stmt|;
comment|// Undo works only for clearing the line when in any of password the modes
if|if
condition|(
name|m_echoMode
operator|!=
name|QLineEdit
operator|::
name|Normal
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|m_undoState
operator|&&
name|m_undoState
operator|>
name|until
condition|)
block|{
name|Command
modifier|&
name|cmd
init|=
name|m_history
index|[
operator|--
name|m_undoState
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|.
name|type
condition|)
block|{
case|case
name|Insert
case|:
name|m_text
operator|.
name|remove
argument_list|(
name|cmd
operator|.
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
case|case
name|SetSelection
case|:
name|m_selstart
operator|=
name|cmd
operator|.
name|selStart
expr_stmt|;
name|m_selend
operator|=
name|cmd
operator|.
name|selEnd
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
case|case
name|Remove
case|:
case|case
name|RemoveSelection
case|:
name|m_text
operator|.
name|insert
argument_list|(
name|cmd
operator|.
name|pos
argument_list|,
name|cmd
operator|.
name|uc
argument_list|)
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|Delete
case|:
case|case
name|DeleteSelection
case|:
name|m_text
operator|.
name|insert
argument_list|(
name|cmd
operator|.
name|pos
argument_list|,
name|cmd
operator|.
name|uc
argument_list|)
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
case|case
name|Separator
case|:
continue|continue;
block|}
if|if
condition|(
name|until
operator|<
literal|0
operator|&&
name|m_undoState
condition|)
block|{
name|Command
modifier|&
name|next
init|=
name|m_history
index|[
name|m_undoState
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|type
operator|!=
name|cmd
operator|.
name|type
operator|&&
name|next
operator|.
name|type
operator|<
name|RemoveSelection
operator|&&
operator|(
name|cmd
operator|.
name|type
operator|<
name|RemoveSelection
operator|||
name|next
operator|.
name|type
operator|==
name|Separator
operator|)
condition|)
break|break;
block|}
block|}
name|m_textDirty
operator|=
literal|true
expr_stmt|;
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|internalRedo
name|void
name|QWidgetLineControl
operator|::
name|internalRedo
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isRedoAvailable
argument_list|()
condition|)
return|return;
name|internalDeselect
argument_list|()
expr_stmt|;
while|while
condition|(
name|m_undoState
operator|<
operator|(
name|int
operator|)
name|m_history
operator|.
name|size
argument_list|()
condition|)
block|{
name|Command
modifier|&
name|cmd
init|=
name|m_history
index|[
name|m_undoState
operator|++
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|.
name|type
condition|)
block|{
case|case
name|Insert
case|:
name|m_text
operator|.
name|insert
argument_list|(
name|cmd
operator|.
name|pos
argument_list|,
name|cmd
operator|.
name|uc
argument_list|)
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|SetSelection
case|:
name|m_selstart
operator|=
name|cmd
operator|.
name|selStart
expr_stmt|;
name|m_selend
operator|=
name|cmd
operator|.
name|selEnd
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
case|case
name|Remove
case|:
case|case
name|Delete
case|:
case|case
name|RemoveSelection
case|:
case|case
name|DeleteSelection
case|:
name|m_text
operator|.
name|remove
argument_list|(
name|cmd
operator|.
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_selstart
operator|=
name|cmd
operator|.
name|selStart
expr_stmt|;
name|m_selend
operator|=
name|cmd
operator|.
name|selEnd
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
case|case
name|Separator
case|:
name|m_selstart
operator|=
name|cmd
operator|.
name|selStart
expr_stmt|;
name|m_selend
operator|=
name|cmd
operator|.
name|selEnd
expr_stmt|;
name|m_cursor
operator|=
name|cmd
operator|.
name|pos
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m_undoState
operator|<
operator|(
name|int
operator|)
name|m_history
operator|.
name|size
argument_list|()
condition|)
block|{
name|Command
modifier|&
name|next
init|=
name|m_history
index|[
name|m_undoState
index|]
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|type
operator|!=
name|cmd
operator|.
name|type
operator|&&
name|cmd
operator|.
name|type
operator|<
name|RemoveSelection
operator|&&
name|next
operator|.
name|type
operator|!=
name|Separator
operator|&&
operator|(
name|next
operator|.
name|type
operator|<
name|RemoveSelection
operator|||
name|cmd
operator|.
name|type
operator|==
name|Separator
operator|)
condition|)
break|break;
block|}
block|}
name|m_textDirty
operator|=
literal|true
expr_stmt|;
name|emitCursorPositionChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      If the current cursor position differs from the last emitted cursor     position, emits cursorPositionChanged(). */
end_comment
begin_function
DECL|function|emitCursorPositionChanged
name|void
name|QWidgetLineControl
operator|::
name|emitCursorPositionChanged
parameter_list|()
block|{
if|if
condition|(
name|m_cursor
operator|!=
name|m_lastCursorPos
condition|)
block|{
specifier|const
name|int
name|oldLast
init|=
name|m_lastCursorPos
decl_stmt|;
name|m_lastCursorPos
operator|=
name|m_cursor
expr_stmt|;
name|cursorPositionChanged
argument_list|(
name|oldLast
argument_list|,
name|m_cursor
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
comment|// otherwise we send a selection update which includes the cursor
if|if
condition|(
operator|!
name|hasSelectedText
argument_list|()
condition|)
block|{
name|QAccessibleTextCursorEvent
name|event
argument_list|(
name|parent
argument_list|()
argument_list|,
name|m_cursor
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
end_ifndef
begin_comment
comment|// iterating forward(dir=1)/backward(dir=-1) from the
end_comment
begin_comment
comment|// current row based. dir=0 indicates a new completion prefix was set.
end_comment
begin_function
DECL|function|advanceToEnabledItem
name|bool
name|QWidgetLineControl
operator|::
name|advanceToEnabledItem
parameter_list|(
name|int
name|dir
parameter_list|)
block|{
name|int
name|start
init|=
name|m_completer
operator|->
name|currentRow
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|int
name|i
init|=
name|start
operator|+
name|dir
decl_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|m_completer
operator|->
name|setCurrentRow
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|m_completer
operator|->
name|wrapAround
argument_list|()
condition|)
break|break;
name|i
operator|=
name|i
operator|>
literal|0
condition|?
literal|0
else|:
name|m_completer
operator|->
name|completionCount
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|QModelIndex
name|currentIndex
init|=
name|m_completer
operator|->
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|m_completer
operator|->
name|completionModel
argument_list|()
operator|->
name|flags
argument_list|(
name|currentIndex
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsEnabled
condition|)
return|return
literal|true
return|;
name|i
operator|+=
name|dir
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|start
condition|)
do|;
name|m_completer
operator|->
name|setCurrentRow
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|// restore
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|complete
name|void
name|QWidgetLineControl
operator|::
name|complete
parameter_list|(
name|int
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_completer
operator|||
name|isReadOnly
argument_list|()
operator|||
name|echoMode
argument_list|()
operator|!=
name|QLineEdit
operator|::
name|Normal
condition|)
return|return;
name|QString
name|text
init|=
name|this
operator|->
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
name|m_completer
operator|->
name|completionMode
argument_list|()
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|Qt
operator|::
name|Key_Backspace
condition|)
return|return;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|==
name|Qt
operator|::
name|Key_Down
condition|)
block|{
if|if
condition|(
name|textAfterSelection
argument_list|()
operator|.
name|length
argument_list|()
condition|)
return|return;
name|QString
name|prefix
init|=
name|hasSelectedText
argument_list|()
condition|?
name|textBeforeSelection
argument_list|()
else|:
name|text
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|compare
argument_list|(
name|m_completer
operator|->
name|currentCompletion
argument_list|()
argument_list|,
name|m_completer
operator|->
name|caseSensitivity
argument_list|()
argument_list|)
operator|!=
literal|0
operator|||
name|prefix
operator|.
name|compare
argument_list|(
name|m_completer
operator|->
name|completionPrefix
argument_list|()
argument_list|,
name|m_completer
operator|->
name|caseSensitivity
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_completer
operator|->
name|setCompletionPrefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
operator|(
name|key
operator|==
name|Qt
operator|::
name|Key_Up
operator|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|m_completer
operator|->
name|setCompletionPrefix
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|advanceToEnabledItem
argument_list|(
name|n
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_completer
operator|->
name|popup
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|m_completer
operator|->
name|setCompletionPrefix
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|m_completer
operator|->
name|complete
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setReadOnly
name|void
name|QWidgetLineControl
operator|::
name|setReadOnly
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|m_readOnly
operator|=
name|enable
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|setCursorBlinkPeriod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|setCursorBlinkPeriod
argument_list|(
name|QApplication
operator|::
name|cursorFlashTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setCursorBlinkPeriod
name|void
name|QWidgetLineControl
operator|::
name|setCursorBlinkPeriod
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
if|if
condition|(
name|msec
operator|==
name|m_blinkPeriod
condition|)
return|return;
if|if
condition|(
name|m_blinkTimer
condition|)
block|{
name|killTimer
argument_list|(
name|m_blinkTimer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msec
operator|&&
operator|!
name|m_readOnly
condition|)
block|{
name|m_blinkTimer
operator|=
name|startTimer
argument_list|(
name|msec
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m_blinkStatus
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m_blinkTimer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m_blinkStatus
operator|==
literal|1
condition|)
emit|emit
name|updateNeeded
argument_list|(
name|inputMask
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|cursorRect
argument_list|()
else|:
name|QRect
argument_list|()
argument_list|)
emit|;
block|}
name|m_blinkPeriod
operator|=
name|msec
expr_stmt|;
block|}
end_function
begin_comment
comment|// This is still used by QDeclarativeTextInput in the qtquick1 repo
end_comment
begin_function
DECL|function|resetCursorBlinkTimer
name|void
name|QWidgetLineControl
operator|::
name|resetCursorBlinkTimer
parameter_list|()
block|{
if|if
condition|(
name|m_blinkPeriod
operator|==
literal|0
operator|||
name|m_blinkTimer
operator|==
literal|0
condition|)
return|return;
name|killTimer
argument_list|(
name|m_blinkTimer
argument_list|)
expr_stmt|;
name|m_blinkTimer
operator|=
name|startTimer
argument_list|(
name|m_blinkPeriod
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m_blinkStatus
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|QWidgetLineControl
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|m_blinkTimer
condition|)
block|{
name|m_blinkStatus
operator|=
operator|!
name|m_blinkStatus
expr_stmt|;
emit|emit
name|updateNeeded
argument_list|(
name|inputMask
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|cursorRect
argument_list|()
else|:
name|QRect
argument_list|()
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|m_deleteAllTimer
condition|)
block|{
name|killTimer
argument_list|(
name|m_deleteAllTimer
argument_list|)
expr_stmt|;
name|m_deleteAllTimer
operator|=
literal|0
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|m_tripleClickTimer
condition|)
block|{
name|killTimer
argument_list|(
name|m_tripleClickTimer
argument_list|)
expr_stmt|;
name|m_tripleClickTimer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|m_passwordEchoTimer
condition|)
block|{
name|killTimer
argument_list|(
name|m_passwordEchoTimer
argument_list|)
expr_stmt|;
name|m_passwordEchoTimer
operator|=
literal|0
expr_stmt|;
name|updateDisplayText
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_function
DECL|function|processShortcutOverrideEvent
name|void
name|QWidgetLineControl
operator|::
name|processShortcutOverrideEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|ke
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
return|return;
if|if
condition|(
name|ke
operator|==
name|QKeySequence
operator|::
name|Copy
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|Paste
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|Cut
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|Redo
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|Undo
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|MoveToNextWord
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|MoveToPreviousWord
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|MoveToStartOfDocument
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|MoveToEndOfDocument
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectNextWord
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectPreviousWord
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectStartOfLine
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectEndOfLine
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectStartOfBlock
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectEndOfBlock
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectStartOfDocument
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectAll
operator|||
name|ke
operator|==
name|QKeySequence
operator|::
name|SelectEndOfDocument
condition|)
block|{
name|ke
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ke
operator|->
name|modifiers
argument_list|()
operator|==
name|Qt
operator|::
name|NoModifier
operator|||
name|ke
operator|->
name|modifiers
argument_list|()
operator|==
name|Qt
operator|::
name|ShiftModifier
operator|||
name|ke
operator|->
name|modifiers
argument_list|()
operator|==
name|Qt
operator|::
name|KeypadModifier
condition|)
block|{
if|if
condition|(
name|ke
operator|->
name|key
argument_list|()
operator|<
name|Qt
operator|::
name|Key_Escape
condition|)
block|{
name|ke
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ke
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Delete
case|:
case|case
name|Qt
operator|::
name|Key_Home
case|:
case|case
name|Qt
operator|::
name|Key_End
case|:
case|case
name|Qt
operator|::
name|Key_Backspace
case|:
case|case
name|Qt
operator|::
name|Key_Left
case|:
case|case
name|Qt
operator|::
name|Key_Right
case|:
name|ke
operator|->
name|accept
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|processKeyEvent
name|void
name|QWidgetLineControl
operator|::
name|processKeyEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|bool
name|inlineCompletionAccepted
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
if|if
condition|(
name|m_completer
condition|)
block|{
name|QCompleter
operator|::
name|CompletionMode
name|completionMode
init|=
name|m_completer
operator|->
name|completionMode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|completionMode
operator|==
name|QCompleter
operator|::
name|PopupCompletion
operator|||
name|completionMode
operator|==
name|QCompleter
operator|::
name|UnfilteredPopupCompletion
operator|)
operator|&&
name|m_completer
operator|->
name|popup
argument_list|()
operator|&&
name|m_completer
operator|->
name|popup
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
block|{
comment|// The following keys are forwarded by the completer to the widget
comment|// Ignoring the events lets the completer provide suitable default behavior
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Escape
case|:
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
case|case
name|Qt
operator|::
name|Key_F4
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
break|break;
endif|#
directive|endif
name|m_completer
operator|->
name|popup
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
comment|// just hide. will end up propagating to parent
default|default:
break|break;
comment|// normal key processing
block|}
block|}
elseif|else
if|if
condition|(
name|completionMode
operator|==
name|QCompleter
operator|::
name|InlineCompletion
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
case|case
name|Qt
operator|::
name|Key_F4
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m_completer
operator|->
name|currentCompletion
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|hasSelectedText
argument_list|()
operator|&&
name|textAfterSelection
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setText
argument_list|(
name|m_completer
operator|->
name|currentCompletion
argument_list|()
argument_list|)
expr_stmt|;
name|inlineCompletionAccepted
operator|=
literal|true
expr_stmt|;
block|}
default|default:
break|break;
comment|// normal key processing
block|}
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_COMPLETER
if|if
condition|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Enter
operator|||
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Return
condition|)
block|{
if|if
condition|(
name|hasAcceptableInput
argument_list|()
operator|||
name|fixup
argument_list|()
condition|)
block|{
emit|emit
name|accepted
argument_list|()
emit|;
emit|emit
name|editingFinished
argument_list|()
emit|;
block|}
if|if
condition|(
name|inlineCompletionAccepted
condition|)
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
else|else
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|PasswordEchoOnEdit
operator|&&
operator|!
name|passwordEchoEditing
argument_list|()
operator|&&
operator|!
name|isReadOnly
argument_list|()
operator|&&
operator|!
name|event
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Select
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Up
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Down
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Back
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
condition|)
block|{
comment|// Clear the edit and reset to normal echo mode while editing; the
comment|// echo mode switches back when the edit loses focus
comment|// ### resets current content.  dubious code; you can
comment|// navigate with keys up, down, back, and select(?), but if you press
comment|// "left" or "right" it clears?
name|updatePasswordEchoEditing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|unknown
init|=
literal|false
decl_stmt|;
name|bool
name|visual
init|=
name|cursorMoveStyle
argument_list|()
operator|==
name|Qt
operator|::
name|VisualMoveStyle
decl_stmt|;
if|if
condition|(
literal|false
condition|)
block|{     }
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Undo
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
name|undo
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Redo
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
name|redo
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectAll
condition|)
block|{
name|selectAll
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Copy
condition|)
block|{
name|copy
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Paste
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|QClipboard
operator|::
name|Mode
name|mode
init|=
name|QClipboard
operator|::
name|Clipboard
decl_stmt|;
if|if
condition|(
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|X11KeyboardScheme
operator|&&
name|event
operator|->
name|modifiers
argument_list|()
operator|==
operator|(
name|Qt
operator|::
name|CTRL
operator||
name|Qt
operator|::
name|SHIFT
operator|)
operator|&&
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Insert
condition|)
block|{
name|mode
operator|=
name|QClipboard
operator|::
name|Selection
expr_stmt|;
block|}
name|paste
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Cut
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|copy
argument_list|()
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|DeleteEndOfLine
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|setSelection
argument_list|(
name|cursor
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|copy
argument_list|()
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_CLIPBOARD
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToStartOfLine
operator|||
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToStartOfBlock
condition|)
block|{
name|home
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToEndOfLine
operator|||
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToEndOfBlock
condition|)
block|{
name|end
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectStartOfLine
operator|||
name|event
operator|==
name|QKeySequence
operator|::
name|SelectStartOfBlock
condition|)
block|{
name|home
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectEndOfLine
operator|||
name|event
operator|==
name|QKeySequence
operator|::
name|SelectEndOfBlock
condition|)
block|{
name|end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToNextChar
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_COMPLETER
argument_list|)
specifier|const
name|bool
name|inlineCompletion
init|=
literal|false
decl_stmt|;
else|#
directive|else
specifier|const
name|bool
name|inlineCompletion
init|=
name|m_completer
operator|&&
name|m_completer
operator|->
name|completionMode
argument_list|()
operator|==
name|QCompleter
operator|::
name|InlineCompletion
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hasSelectedText
argument_list|()
operator|&&
operator|(
name|m_keyboardScheme
operator|!=
name|QPlatformTheme
operator|::
name|WindowsKeyboardScheme
operator|||
name|inlineCompletion
operator|)
condition|)
block|{
name|moveCursor
argument_list|(
name|selectionEnd
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cursorForward
argument_list|(
literal|0
argument_list|,
name|visual
condition|?
literal|1
else|:
operator|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectNextChar
condition|)
block|{
name|cursorForward
argument_list|(
literal|1
argument_list|,
name|visual
condition|?
literal|1
else|:
operator|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToPreviousChar
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_COMPLETER
argument_list|)
specifier|const
name|bool
name|inlineCompletion
init|=
literal|false
decl_stmt|;
else|#
directive|else
specifier|const
name|bool
name|inlineCompletion
init|=
name|m_completer
operator|&&
name|m_completer
operator|->
name|completionMode
argument_list|()
operator|==
name|QCompleter
operator|::
name|InlineCompletion
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hasSelectedText
argument_list|()
operator|&&
operator|(
name|m_keyboardScheme
operator|!=
name|QPlatformTheme
operator|::
name|WindowsKeyboardScheme
operator|||
name|inlineCompletion
operator|)
condition|)
block|{
name|moveCursor
argument_list|(
name|selectionStart
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cursorForward
argument_list|(
literal|0
argument_list|,
name|visual
condition|?
operator|-
literal|1
else|:
operator|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectPreviousChar
condition|)
block|{
name|cursorForward
argument_list|(
literal|1
argument_list|,
name|visual
condition|?
operator|-
literal|1
else|:
operator|(
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToNextWord
condition|)
block|{
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
condition|)
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|cursorWordForward
argument_list|(
literal|0
argument_list|)
else|:
name|cursorWordBackward
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|end
argument_list|(
literal|0
argument_list|)
else|:
name|home
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|MoveToPreviousWord
condition|)
block|{
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
condition|)
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|cursorWordBackward
argument_list|(
literal|0
argument_list|)
else|:
name|cursorWordForward
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|home
argument_list|(
literal|0
argument_list|)
else|:
name|end
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectNextWord
condition|)
block|{
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
condition|)
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|cursorWordForward
argument_list|(
literal|1
argument_list|)
else|:
name|cursorWordBackward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|end
argument_list|(
literal|1
argument_list|)
else|:
name|home
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|SelectPreviousWord
condition|)
block|{
if|if
condition|(
name|echoMode
argument_list|()
operator|==
name|QLineEdit
operator|::
name|Normal
condition|)
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|cursorWordBackward
argument_list|(
literal|1
argument_list|)
else|:
name|cursorWordForward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|LeftToRight
condition|?
name|home
argument_list|(
literal|1
argument_list|)
else|:
name|end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Delete
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
name|del
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|DeleteEndOfWord
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|cursorWordForward
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|DeleteStartOfWord
condition|)
block|{
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|cursorWordBackward
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_SHORTCUT
else|else
block|{
name|bool
name|handled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|MacKeyboardScheme
operator|&&
operator|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
condition|)
block|{
name|Qt
operator|::
name|KeyboardModifiers
name|myModifiers
init|=
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
operator|~
name|Qt
operator|::
name|KeypadModifier
operator|)
decl_stmt|;
if|if
condition|(
name|myModifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
condition|)
block|{
if|if
condition|(
name|myModifiers
operator|==
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|||
name|myModifiers
operator|==
operator|(
name|Qt
operator|::
name|AltModifier
operator||
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|||
name|myModifiers
operator|==
name|Qt
operator|::
name|ShiftModifier
condition|)
block|{
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
condition|?
name|home
argument_list|(
literal|1
argument_list|)
else|:
name|end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|myModifiers
operator|==
name|Qt
operator|::
name|ControlModifier
operator|||
name|myModifiers
operator|==
name|Qt
operator|::
name|AltModifier
operator|||
name|myModifiers
operator|==
name|Qt
operator|::
name|NoModifier
operator|)
condition|)
block|{
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
condition|?
name|home
argument_list|(
literal|0
argument_list|)
else|:
name|end
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|handled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Backspace
case|:
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|cursorWordBackward
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|del
argument_list|()
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
case|case
name|Qt
operator|::
name|Key_Up
case|:
case|case
name|Qt
operator|::
name|Key_Down
case|:
name|complete
argument_list|(
name|event
operator|->
name|key
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|Key_E
case|:
if|if
condition|(
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|X11KeyboardScheme
condition|)
name|end
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_U
case|:
if|if
condition|(
name|m_keyboardScheme
operator|==
name|QPlatformTheme
operator|::
name|X11KeyboardScheme
operator|&&
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|setSelection
argument_list|(
literal|0
argument_list|,
name|text
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|copy
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|del
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|handled
condition|)
name|unknown
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ### check for *no* modifier
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Backspace
case|:
if|if
condition|(
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|backspace
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
name|complete
argument_list|(
name|Qt
operator|::
name|Key_Backspace
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Back
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|event
operator|->
name|isAutoRepeat
argument_list|()
operator|&&
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
if|if
condition|(
name|text
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setText
argument_list|(
name|m_cancelText
argument_list|)
expr_stmt|;
if|if
condition|(
name|passwordEchoEditing
argument_list|()
condition|)
name|updatePasswordEchoEditing
argument_list|(
literal|false
argument_list|)
expr_stmt|;
emit|emit
name|editFocusChange
argument_list|(
literal|false
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
operator|!
name|m_deleteAllTimer
condition|)
block|{
name|m_deleteAllTimer
operator|=
name|startTimer
argument_list|(
literal|750
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unknown
operator|=
literal|true
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
operator|!
name|handled
condition|)
name|unknown
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Direction_L
operator|||
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Direction_R
condition|)
block|{
name|setLayoutDirection
argument_list|(
operator|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Direction_L
operator|)
condition|?
name|Qt
operator|::
name|LeftToRight
else|:
name|Qt
operator|::
name|RightToLeft
argument_list|)
expr_stmt|;
name|unknown
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|unknown
operator|&&
operator|!
name|isReadOnly
argument_list|()
condition|)
block|{
name|QString
name|t
init|=
name|event
operator|->
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isEmpty
argument_list|()
operator|&&
name|t
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isPrint
argument_list|()
condition|)
block|{
name|insert
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPLETER
name|complete
argument_list|(
name|event
operator|->
name|key
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|unknown
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
else|else
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isUndoAvailable
name|bool
name|QWidgetLineControl
operator|::
name|isUndoAvailable
parameter_list|()
specifier|const
block|{
comment|// For security reasons undo is not available in any password mode (NoEcho included)
comment|// with the exception that the user can clear the password with undo.
return|return
operator|!
name|m_readOnly
operator|&&
name|m_undoState
operator|&&
operator|(
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|Normal
operator|||
name|m_history
index|[
name|m_undoState
operator|-
literal|1
index|]
operator|.
name|type
operator|==
name|QWidgetLineControl
operator|::
name|Insert
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isRedoAvailable
name|bool
name|QWidgetLineControl
operator|::
name|isRedoAvailable
parameter_list|()
specifier|const
block|{
comment|// Same as with undo. Disabled for password modes.
return|return
operator|!
name|m_readOnly
operator|&&
name|m_echoMode
operator|==
name|QLineEdit
operator|::
name|Normal
operator|&&
name|m_undoState
operator|<
name|m_history
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
end_unit
