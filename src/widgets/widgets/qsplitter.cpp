begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsplitter.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SPLITTER
end_ifndef
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcursor.h"
end_include
begin_include
include|#
directive|include
file|"qdrawutil.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qlayout.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qrubberband.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qstyleoption.h"
end_include
begin_include
include|#
directive|include
file|"qtextstream.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"private/qlayoutengine_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsplitter_p.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|//#define QSPLITTER_DEBUG
end_comment
begin_comment
comment|/*!     \class QSplitterHandle     \brief The QSplitterHandle class provides handle functionality of the splitter.      \ingroup organizers     \inmodule QtWidgets      QSplitterHandle is typically what people think about when they think about     a splitter. It is the handle that is used to resize the widgets.      A typical developer using QSplitter will never have to worry about     QSplitterHandle. It is provided for developers who want splitter handles     that provide extra features, such as popup menus.      The typical way one would create splitter handles is to subclass QSplitter then     reimplement QSplitter::createHandle() to instantiate the custom splitter     handle. For example, a minimum QSplitter subclass might look like this:      \snippet doc/src/snippets/splitterhandle/splitter.h 0      The \l{QSplitter::}{createHandle()} implementation simply constructs a     custom splitter handle, called \c Splitter in this example:      \snippet doc/src/snippets/splitterhandle/splitter.cpp 1      Information about a given handle can be obtained using functions like     orientation() and opaqueResize(), and is retrieved from its parent splitter.     Details like these can be used to give custom handles different appearances     depending on the splitter's orientation.      The complexity of a custom handle subclass depends on the tasks that it     needs to perform. A simple subclass might only provide a paintEvent()     implementation:      \snippet doc/src/snippets/splitterhandle/splitter.cpp 0      In this example, a predefined gradient is set up differently depending on     the orientation of the handle. QSplitterHandle provides a reasonable     size hint for the handle, so the subclass does not need to provide a     reimplementation of sizeHint() unless the handle has special size     requirements.      \sa QSplitter */
end_comment
begin_comment
comment|/*!     Creates a QSplitter handle with the given \a orientation and     QSplitter \a parent. */
end_comment
begin_constructor
DECL|function|QSplitterHandle
name|QSplitterHandle
operator|::
name|QSplitterHandle
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|QSplitter
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QSplitterHandlePrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
name|d
operator|->
name|s
operator|=
name|parent
expr_stmt|;
name|setOrientation
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Sets the orientation of the splitter handle to \a orientation.     This is usually propagated from the QSplitter.      \sa QSplitter::setOrientation() */
end_comment
begin_function
DECL|function|setOrientation
name|void
name|QSplitterHandle
operator|::
name|setOrientation
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
name|d
operator|->
name|orient
operator|=
name|orientation
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|setCursor
argument_list|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|Qt
operator|::
name|SplitHCursor
else|:
name|Qt
operator|::
name|SplitVCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!    Returns the handle's orientation. This is usually propagated from the QSplitter.     \sa QSplitter::orientation() */
end_comment
begin_function
DECL|function|orientation
name|Qt
operator|::
name|Orientation
name|QSplitterHandle
operator|::
name|orientation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitterHandle
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|orient
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if widgets are resized dynamically (opaquely), otherwise     returns false. This value is controlled by the QSplitter.      \sa QSplitter::opaqueResize()  */
end_comment
begin_function
DECL|function|opaqueResize
name|bool
name|QSplitterHandle
operator|::
name|opaqueResize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitterHandle
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|s
operator|->
name|opaqueResize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the splitter associated with this splitter handle.      \sa QSplitter::handle() */
end_comment
begin_function
DECL|function|splitter
name|QSplitter
modifier|*
name|QSplitterHandle
operator|::
name|splitter
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Tells the splitter to move this handle to position \a pos, which is     the distance from the left or top edge of the widget.      Note that \a pos is also measured from the left (or top) for     right-to-left languages. This function will map \a pos to the     appropriate position before calling QSplitter::moveSplitter().      \sa QSplitter::moveSplitter() closestLegalPosition() */
end_comment
begin_function
DECL|function|moveSplitter
name|void
name|QSplitterHandle
operator|::
name|moveSplitter
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|s
operator|->
name|isRightToLeft
argument_list|()
operator|&&
name|d
operator|->
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|pos
operator|=
name|d
operator|->
name|s
operator|->
name|contentsRect
argument_list|()
operator|.
name|width
argument_list|()
operator|-
name|pos
expr_stmt|;
name|d
operator|->
name|s
operator|->
name|moveSplitter
argument_list|(
name|pos
argument_list|,
name|d
operator|->
name|s
operator|->
name|indexOf
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    Returns the closest legal position to \a pos of the splitter    handle. The positions are measured from the left or top edge of    the splitter, even for right-to-left languages.     \sa QSplitter::closestLegalPosition(), moveSplitter() */
end_comment
begin_function
DECL|function|closestLegalPosition
name|int
name|QSplitterHandle
operator|::
name|closestLegalPosition
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
name|QSplitter
modifier|*
name|s
init|=
name|d
operator|->
name|s
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|isRightToLeft
argument_list|()
operator|&&
name|d
operator|->
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|int
name|w
init|=
name|s
operator|->
name|contentsRect
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
return|return
name|w
operator|-
name|s
operator|->
name|closestLegalPosition
argument_list|(
name|w
operator|-
name|pos
argument_list|,
name|s
operator|->
name|indexOf
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
return|return
name|s
operator|->
name|closestLegalPosition
argument_list|(
name|pos
argument_list|,
name|s
operator|->
name|indexOf
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QSplitterHandle
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitterHandle
argument_list|)
expr_stmt|;
name|int
name|hw
init|=
name|d
operator|->
name|s
operator|->
name|handleWidth
argument_list|()
decl_stmt|;
name|QStyleOption
name|opt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|opt
operator|.
name|init
argument_list|(
name|d
operator|->
name|s
argument_list|)
expr_stmt|;
name|opt
operator|.
name|state
operator|=
name|QStyle
operator|::
name|State_None
expr_stmt|;
return|return
name|parentWidget
argument_list|()
operator|->
name|style
argument_list|()
operator|->
name|sizeFromContents
argument_list|(
name|QStyle
operator|::
name|CT_Splitter
argument_list|,
operator|&
name|opt
argument_list|,
name|QSize
argument_list|(
name|hw
argument_list|,
name|hw
argument_list|)
argument_list|,
name|d
operator|->
name|s
argument_list|)
operator|.
name|expandedTo
argument_list|(
name|QApplication
operator|::
name|globalStrut
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QSplitterHandle
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitterHandle
argument_list|)
expr_stmt|;
comment|// When splitters are only 1 or 0 pixel large we increase the
comment|// actual grab area to five pixels
comment|// Note that QSplitter uses contentsRect for layouting
comment|// and ensures that handles are drawn on top of widgets
comment|// We simply use the contents margins for draggin and only
comment|// paint the mask area
name|bool
name|useTinyMode
init|=
operator|(
name|d
operator|->
name|s
operator|->
name|handleWidth
argument_list|()
operator|<=
literal|1
operator|)
decl_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_MouseNoMask
argument_list|,
name|useTinyMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|useTinyMode
condition|)
block|{
if|if
condition|(
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|setContentsMargins
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|setContentsMargins
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setMask
argument_list|(
name|QRegion
argument_list|(
name|contentsRect
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QWidget
operator|::
name|resizeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSplitterHandle
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
name|d
operator|->
name|hover
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
name|d
operator|->
name|hover
operator|=
literal|false
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QSplitterHandle
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
condition|)
return|return;
name|int
name|pos
init|=
name|d
operator|->
name|pick
argument_list|(
name|parentWidget
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|e
operator|->
name|globalPos
argument_list|()
argument_list|)
argument_list|)
operator|-
name|d
operator|->
name|mouseOffset
decl_stmt|;
if|if
condition|(
name|opaqueResize
argument_list|()
condition|)
block|{
name|moveSplitter
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|s
operator|->
name|setRubberBand
argument_list|(
name|closestLegalPosition
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!    \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QSplitterHandle
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|d
operator|->
name|mouseOffset
operator|=
name|d
operator|->
name|pick
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|pressed
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!    \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QSplitterHandle
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opaqueResize
argument_list|()
operator|&&
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|int
name|pos
init|=
name|d
operator|->
name|pick
argument_list|(
name|parentWidget
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|e
operator|->
name|globalPos
argument_list|()
argument_list|)
argument_list|)
operator|-
name|d
operator|->
name|mouseOffset
decl_stmt|;
name|d
operator|->
name|s
operator|->
name|setRubberBand
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|moveSplitter
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|d
operator|->
name|pressed
operator|=
literal|false
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!    \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QSplitterHandle
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitterHandle
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QStyleOption
name|opt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|opt
operator|.
name|rect
operator|=
name|contentsRect
argument_list|()
expr_stmt|;
name|opt
operator|.
name|palette
operator|=
name|palette
argument_list|()
expr_stmt|;
if|if
condition|(
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
name|opt
operator|.
name|state
operator|=
name|QStyle
operator|::
name|State_Horizontal
expr_stmt|;
else|else
name|opt
operator|.
name|state
operator|=
name|QStyle
operator|::
name|State_None
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hover
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pressed
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
if|if
condition|(
name|isEnabled
argument_list|()
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Enabled
expr_stmt|;
name|parentWidget
argument_list|()
operator|->
name|style
argument_list|()
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_Splitter
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|p
argument_list|,
name|d
operator|->
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getWidgetSize
name|int
name|QSplitterLayoutStruct
operator|::
name|getWidgetSize
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orient
parameter_list|)
block|{
if|if
condition|(
name|sizer
operator|==
operator|-
literal|1
condition|)
block|{
name|QSize
name|s
init|=
name|widget
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
specifier|const
name|int
name|presizer
init|=
name|pick
argument_list|(
name|s
argument_list|,
name|orient
argument_list|)
decl_stmt|;
specifier|const
name|int
name|realsize
init|=
name|pick
argument_list|(
name|widget
operator|->
name|size
argument_list|()
argument_list|,
name|orient
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isValid
argument_list|()
operator|||
operator|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
operator|&&
operator|(
name|realsize
operator|>
name|presizer
operator|)
operator|)
condition|)
block|{
name|sizer
operator|=
name|pick
argument_list|(
name|widget
operator|->
name|size
argument_list|()
argument_list|,
name|orient
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sizer
operator|=
name|presizer
expr_stmt|;
block|}
name|QSizePolicy
name|p
init|=
name|widget
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
name|int
name|sf
init|=
operator|(
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
operator|)
condition|?
name|p
operator|.
name|horizontalStretch
argument_list|()
else|:
name|p
operator|.
name|verticalStretch
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|>
literal|1
condition|)
name|sizer
operator|*=
name|sf
expr_stmt|;
block|}
return|return
name|sizer
return|;
block|}
end_function
begin_function
DECL|function|getHandleSize
name|int
name|QSplitterLayoutStruct
operator|::
name|getHandleSize
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orient
parameter_list|)
block|{
return|return
name|pick
argument_list|(
name|handle
operator|->
name|sizeHint
argument_list|()
argument_list|,
name|orient
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QSplitterPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QSizePolicy
name|sp
argument_list|(
name|QSizePolicy
operator|::
name|Expanding
argument_list|,
name|QSizePolicy
operator|::
name|Preferred
argument_list|)
decl_stmt|;
if|if
condition|(
name|orient
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|sp
operator|.
name|transpose
argument_list|()
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recalc
name|void
name|QSplitterPrivate
operator|::
name|recalc
parameter_list|(
name|bool
name|update
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|count
argument_list|()
decl_stmt|;
comment|/*       Splitter handles before the first visible widget or right       before a hidden widget must be hidden.     */
name|bool
name|first
init|=
literal|true
decl_stmt|;
name|bool
name|allInvisible
init|=
name|n
operator|!=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bool
name|widgetHidden
init|=
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
decl_stmt|;
if|if
condition|(
name|allInvisible
operator|&&
operator|!
name|widgetHidden
operator|&&
operator|!
name|s
operator|->
name|collapsed
condition|)
name|allInvisible
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|handle
operator|->
name|setHidden
argument_list|(
name|first
operator|||
name|widgetHidden
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widgetHidden
condition|)
name|first
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|allInvisible
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|s
operator|->
name|collapsed
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|int
name|fi
init|=
literal|2
operator|*
name|q
operator|->
name|frameWidth
argument_list|()
decl_stmt|;
name|int
name|maxl
init|=
name|fi
decl_stmt|;
name|int
name|minl
init|=
name|fi
decl_stmt|;
name|int
name|maxt
init|=
name|QWIDGETSIZE_MAX
decl_stmt|;
name|int
name|mint
init|=
name|fi
decl_stmt|;
comment|/*       calculate min/max sizes for the whole splitter     */
name|bool
name|empty
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|empty
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|minl
operator|+=
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
name|maxl
operator|+=
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
block|}
name|QSize
name|minS
init|=
name|qSmartMinSize
argument_list|(
name|s
operator|->
name|widget
argument_list|)
decl_stmt|;
name|minl
operator|+=
name|pick
argument_list|(
name|minS
argument_list|)
expr_stmt|;
name|maxl
operator|+=
name|pick
argument_list|(
name|s
operator|->
name|widget
operator|->
name|maximumSize
argument_list|()
argument_list|)
expr_stmt|;
name|mint
operator|=
name|qMax
argument_list|(
name|mint
argument_list|,
name|trans
argument_list|(
name|minS
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|tm
init|=
name|trans
argument_list|(
name|s
operator|->
name|widget
operator|->
name|maximumSize
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tm
operator|>
literal|0
condition|)
name|maxt
operator|=
name|qMin
argument_list|(
name|maxt
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|qobject_cast
argument_list|<
name|QSplitter
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
comment|// nested splitters; be nice
name|maxl
operator|=
name|maxt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// QSplitter with no children yet
name|maxl
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxl
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxl
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxt
operator|<
name|mint
condition|)
name|maxt
operator|=
name|mint
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
if|if
condition|(
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|q
operator|->
name|setMaximumSize
argument_list|(
name|maxl
argument_list|,
name|maxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
name|q
operator|->
name|setMinimumSize
argument_list|(
name|minl
argument_list|,
name|mint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|setMaximumSize
argument_list|(
name|maxt
argument_list|,
name|maxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isWindow
argument_list|()
condition|)
name|q
operator|->
name|setMinimumSize
argument_list|(
name|mint
argument_list|,
name|minl
argument_list|)
expr_stmt|;
block|}
name|doResize
argument_list|()
expr_stmt|;
name|q
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|firstShow
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|doResize
name|void
name|QSplitterPrivate
operator|::
name|doResize
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|q
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|count
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QLayoutStruct
argument_list|>
name|a
argument_list|(
name|n
operator|*
literal|2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|noStretchFactorsSet
init|=
literal|true
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QSizePolicy
name|p
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|widget
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
name|int
name|sf
init|=
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|p
operator|.
name|horizontalStretch
argument_list|()
else|:
name|p
operator|.
name|verticalStretch
argument_list|()
decl_stmt|;
if|if
condition|(
name|sf
operator|!=
literal|0
condition|)
block|{
name|noStretchFactorsSet
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSPLITTER_DEBUG
name|qDebug
argument_list|(
literal|"widget %d hidden: %d collapsed: %d handle hidden: %d"
argument_list|,
name|i
argument_list|,
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
argument_list|,
name|s
operator|->
name|collapsed
argument_list|,
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
index|[
name|j
index|]
operator|.
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|a
index|[
name|j
index|]
operator|.
name|maximumSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
name|j
index|]
operator|.
name|sizeHint
operator|=
name|a
index|[
name|j
index|]
operator|.
name|minimumSize
operator|=
name|a
index|[
name|j
index|]
operator|.
name|maximumSize
operator|=
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|empty
operator|=
literal|false
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
operator|||
name|s
operator|->
name|collapsed
condition|)
block|{
name|a
index|[
name|j
index|]
operator|.
name|maximumSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
name|j
index|]
operator|.
name|minimumSize
operator|=
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|s
operator|->
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|maximumSize
operator|=
name|pick
argument_list|(
name|s
operator|->
name|widget
operator|->
name|maximumSize
argument_list|()
argument_list|)
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|empty
operator|=
literal|false
expr_stmt|;
name|bool
name|stretch
init|=
name|noStretchFactorsSet
decl_stmt|;
if|if
condition|(
operator|!
name|stretch
condition|)
block|{
name|QSizePolicy
name|p
init|=
name|s
operator|->
name|widget
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
name|int
name|sf
init|=
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|p
operator|.
name|horizontalStretch
argument_list|()
else|:
name|p
operator|.
name|verticalStretch
argument_list|()
decl_stmt|;
name|stretch
operator|=
operator|(
name|sf
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stretch
condition|)
block|{
name|a
index|[
name|j
index|]
operator|.
name|stretch
operator|=
name|s
operator|->
name|getWidgetSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|sizeHint
operator|=
name|a
index|[
name|j
index|]
operator|.
name|minimumSize
expr_stmt|;
name|a
index|[
name|j
index|]
operator|.
name|expansive
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
name|j
index|]
operator|.
name|sizeHint
operator|=
name|qMax
argument_list|(
name|s
operator|->
name|getWidgetSize
argument_list|(
name|orient
argument_list|)
argument_list|,
name|a
index|[
name|j
index|]
operator|.
name|minimumSize
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|j
expr_stmt|;
block|}
name|qGeomCalc
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|n
operator|*
literal|2
argument_list|,
name|pick
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|)
argument_list|,
name|pick
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSPLITTER_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|qDebug
argument_list|(
literal|"%*s%d: stretch %d, sh %d, minS %d, maxS %d, exp %d, emp %d -> %d, %d"
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
name|i
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|stretch
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|sizeHint
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|minimumSize
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|maximumSize
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|expansive
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|empty
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|pos
argument_list|,
name|a
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|setGeo
argument_list|(
name|s
argument_list|,
name|a
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|.
name|pos
argument_list|,
name|a
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|.
name|size
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|storeSizes
name|void
name|QSplitterPrivate
operator|::
name|storeSizes
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|sls
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sls
operator|->
name|sizer
operator|=
name|pick
argument_list|(
name|sls
operator|->
name|rect
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addContribution
name|void
name|QSplitterPrivate
operator|::
name|addContribution
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|bool
name|mayCollapse
parameter_list|)
specifier|const
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|)
block|{
operator|*
name|min
operator|+=
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
operator|*
name|max
operator|+=
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mayCollapse
operator|||
operator|!
name|s
operator|->
name|collapsed
condition|)
operator|*
name|min
operator|+=
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|s
operator|->
name|widget
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|max
operator|+=
name|pick
argument_list|(
name|s
operator|->
name|widget
operator|->
name|maximumSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findWidgetJustBeforeOrJustAfter
name|int
name|QSplitterPrivate
operator|::
name|findWidgetJustBeforeOrJustAfter
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
modifier|&
name|collapsibleSize
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|index
operator|+=
name|delta
expr_stmt|;
do|do
block|{
name|QWidget
modifier|*
name|w
init|=
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|widget
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|isHidden
argument_list|()
condition|)
block|{
if|if
condition|(
name|collapsible
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|collapsibleSize
operator|=
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
name|index
operator|+=
name|delta
expr_stmt|;
block|}
do|while
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|list
operator|.
name|count
argument_list|()
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*   For the splitter handle with index \a index, \a min and \a max give the range without collapsing any widgets,   and \a farMin and farMax give the range with collapsing included. */
end_comment
begin_function
DECL|function|getRange
name|void
name|QSplitterPrivate
operator|::
name|getRange
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|farMin
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|int
modifier|*
name|farMax
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|list
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<=
literal|0
operator|||
name|index
operator|>=
name|n
condition|)
return|return;
name|int
name|collapsibleSizeBefore
init|=
literal|0
decl_stmt|;
name|int
name|idJustBefore
init|=
name|findWidgetJustBeforeOrJustAfter
argument_list|(
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|collapsibleSizeBefore
argument_list|)
decl_stmt|;
name|int
name|collapsibleSizeAfter
init|=
literal|0
decl_stmt|;
name|int
name|idJustAfter
init|=
name|findWidgetJustBeforeOrJustAfter
argument_list|(
name|index
argument_list|,
operator|+
literal|1
argument_list|,
name|collapsibleSizeAfter
argument_list|)
decl_stmt|;
name|int
name|minBefore
init|=
literal|0
decl_stmt|;
name|int
name|minAfter
init|=
literal|0
decl_stmt|;
name|int
name|maxBefore
init|=
literal|0
decl_stmt|;
name|int
name|maxAfter
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
operator|++
name|i
control|)
name|addContribution
argument_list|(
name|i
argument_list|,
operator|&
name|minBefore
argument_list|,
operator|&
name|maxBefore
argument_list|,
name|i
operator|==
name|idJustBefore
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|index
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|addContribution
argument_list|(
name|i
argument_list|,
operator|&
name|minAfter
argument_list|,
operator|&
name|maxAfter
argument_list|,
name|i
operator|==
name|idJustAfter
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|q
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
name|int
name|farMinVal
decl_stmt|;
name|int
name|minVal
decl_stmt|;
name|int
name|maxVal
decl_stmt|;
name|int
name|farMaxVal
decl_stmt|;
name|int
name|smartMinBefore
init|=
name|qMax
argument_list|(
name|minBefore
argument_list|,
name|pick
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
operator|-
name|maxAfter
argument_list|)
decl_stmt|;
name|int
name|smartMaxBefore
init|=
name|qMin
argument_list|(
name|maxBefore
argument_list|,
name|pick
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
operator|-
name|minAfter
argument_list|)
decl_stmt|;
name|minVal
operator|=
name|pick
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|+
name|smartMinBefore
expr_stmt|;
name|maxVal
operator|=
name|pick
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|+
name|smartMaxBefore
expr_stmt|;
name|farMinVal
operator|=
name|minVal
expr_stmt|;
if|if
condition|(
name|minBefore
operator|-
name|collapsibleSizeBefore
operator|>=
name|pick
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
operator|-
name|maxAfter
condition|)
name|farMinVal
operator|-=
name|collapsibleSizeBefore
expr_stmt|;
name|farMaxVal
operator|=
name|maxVal
expr_stmt|;
if|if
condition|(
name|pick
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
operator|-
operator|(
name|minAfter
operator|-
name|collapsibleSizeAfter
operator|)
operator|<=
name|maxBefore
condition|)
name|farMaxVal
operator|+=
name|collapsibleSizeAfter
expr_stmt|;
if|if
condition|(
name|farMin
condition|)
operator|*
name|farMin
operator|=
name|farMinVal
expr_stmt|;
if|if
condition|(
name|min
condition|)
operator|*
name|min
operator|=
name|minVal
expr_stmt|;
if|if
condition|(
name|max
condition|)
operator|*
name|max
operator|=
name|maxVal
expr_stmt|;
if|if
condition|(
name|farMax
condition|)
operator|*
name|farMax
operator|=
name|farMaxVal
expr_stmt|;
block|}
end_function
begin_function
DECL|function|adjustPos
name|int
name|QSplitterPrivate
operator|::
name|adjustPos
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|farMin
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|int
modifier|*
name|farMax
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|Threshold
init|=
literal|40
decl_stmt|;
name|getRange
argument_list|(
name|index
argument_list|,
name|farMin
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|farMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
operator|*
name|min
condition|)
block|{
if|if
condition|(
name|pos
operator|<=
operator|*
name|max
condition|)
block|{
return|return
name|pos
return|;
block|}
else|else
block|{
name|int
name|delta
init|=
name|pos
operator|-
operator|*
name|max
decl_stmt|;
name|int
name|width
init|=
operator|*
name|farMax
operator|-
operator|*
name|max
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|width
operator|/
literal|2
operator|&&
name|delta
operator|>=
name|qMin
argument_list|(
name|Threshold
argument_list|,
name|width
argument_list|)
condition|)
block|{
return|return
operator|*
name|farMax
return|;
block|}
else|else
block|{
return|return
operator|*
name|max
return|;
block|}
block|}
block|}
else|else
block|{
name|int
name|delta
init|=
operator|*
name|min
operator|-
name|pos
decl_stmt|;
name|int
name|width
init|=
operator|*
name|min
operator|-
operator|*
name|farMin
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|width
operator|/
literal|2
operator|&&
name|delta
operator|>=
name|qMin
argument_list|(
name|Threshold
argument_list|,
name|width
argument_list|)
condition|)
block|{
return|return
operator|*
name|farMin
return|;
block|}
else|else
block|{
return|return
operator|*
name|min
return|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|collapsible
name|bool
name|QSplitterPrivate
operator|::
name|collapsible
parameter_list|(
name|QSplitterLayoutStruct
modifier|*
name|s
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|s
operator|->
name|collapsible
operator|!=
name|Default
condition|)
block|{
return|return
operator|(
name|bool
operator|)
name|s
operator|->
name|collapsible
return|;
block|}
else|else
block|{
return|return
name|childrenCollapsible
return|;
block|}
block|}
end_function
begin_function
DECL|function|updateHandles
name|void
name|QSplitterPrivate
operator|::
name|updateHandles
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|recalc
argument_list|(
name|q
operator|->
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSizes_helper
name|void
name|QSplitterPrivate
operator|::
name|setSizes_helper
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|sizes
parameter_list|,
name|bool
name|clampNegativeSize
parameter_list|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|s
operator|->
name|collapsed
operator|=
literal|false
expr_stmt|;
name|s
operator|->
name|sizer
operator|=
name|sizes
operator|.
name|value
argument_list|(
name|j
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|clampNegativeSize
operator|&&
name|s
operator|->
name|sizer
operator|<
literal|0
condition|)
name|s
operator|->
name|sizer
operator|=
literal|0
expr_stmt|;
name|int
name|smartMinSize
init|=
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|s
operator|->
name|widget
argument_list|)
argument_list|)
decl_stmt|;
comment|// Make sure that we reset the collapsed state.
if|if
condition|(
name|s
operator|->
name|sizer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|collapsible
argument_list|(
name|s
argument_list|)
operator|&&
name|smartMinSize
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|collapsed
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|sizer
operator|=
name|smartMinSize
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|->
name|sizer
operator|<
name|smartMinSize
condition|)
name|s
operator|->
name|sizer
operator|=
name|smartMinSize
expr_stmt|;
block|}
block|}
name|doResize
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setGeo
name|void
name|QSplitterPrivate
operator|::
name|setGeo
parameter_list|(
name|QSplitterLayoutStruct
modifier|*
name|sls
parameter_list|,
name|int
name|p
parameter_list|,
name|int
name|s
parameter_list|,
name|bool
name|allowCollapse
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|sls
operator|->
name|widget
decl_stmt|;
name|QRect
name|r
decl_stmt|;
name|QRect
name|contents
init|=
name|q
operator|->
name|contentsRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
name|r
operator|.
name|setRect
argument_list|(
name|p
argument_list|,
name|contents
operator|.
name|y
argument_list|()
argument_list|,
name|s
argument_list|,
name|contents
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|.
name|setRect
argument_list|(
name|contents
operator|.
name|x
argument_list|()
argument_list|,
name|p
argument_list|,
name|contents
operator|.
name|width
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|sls
operator|->
name|rect
operator|=
name|r
expr_stmt|;
name|int
name|minSize
init|=
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|w
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
operator|&&
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|r
operator|.
name|moveRight
argument_list|(
name|contents
operator|.
name|width
argument_list|()
operator|-
name|r
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowCollapse
condition|)
name|sls
operator|->
name|collapsed
operator|=
name|s
operator|<=
literal|0
operator|&&
name|minSize
operator|>
literal|0
operator|&&
operator|!
name|w
operator|->
name|isHidden
argument_list|()
expr_stmt|;
comment|//   Hide the child widget, but without calling hide() so that
comment|//   the splitter handle is still shown.
if|if
condition|(
name|sls
operator|->
name|collapsed
condition|)
name|r
operator|.
name|moveTopLeft
argument_list|(
name|QPoint
argument_list|(
operator|-
name|r
operator|.
name|width
argument_list|()
operator|-
literal|1
argument_list|,
operator|-
name|r
operator|.
name|height
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|setGeometry
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sls
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|QSplitterHandle
modifier|*
name|h
init|=
name|sls
operator|->
name|handle
decl_stmt|;
name|QSize
name|hs
init|=
name|h
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
name|int
name|left
decl_stmt|,
name|top
decl_stmt|,
name|right
decl_stmt|,
name|bottom
decl_stmt|;
name|h
operator|->
name|getContentsMargins
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|right
argument_list|,
operator|&
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|p
operator|=
name|contents
operator|.
name|width
argument_list|()
operator|-
name|p
operator|+
name|hs
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|->
name|setGeometry
argument_list|(
name|p
operator|-
name|hs
operator|.
name|width
argument_list|()
operator|-
name|left
argument_list|,
name|contents
operator|.
name|y
argument_list|()
argument_list|,
name|hs
operator|.
name|width
argument_list|()
operator|+
name|left
operator|+
name|right
argument_list|,
name|contents
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|setGeometry
argument_list|(
name|contents
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|-
name|hs
operator|.
name|height
argument_list|()
operator|-
name|top
argument_list|,
name|contents
operator|.
name|width
argument_list|()
argument_list|,
name|hs
operator|.
name|height
argument_list|()
operator|+
name|top
operator|+
name|bottom
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|doMove
name|void
name|QSplitterPrivate
operator|::
name|doMove
parameter_list|(
name|bool
name|backwards
parameter_list|,
name|int
name|hPos
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|delta
parameter_list|,
name|bool
name|mayCollapse
parameter_list|,
name|int
modifier|*
name|positions
parameter_list|,
name|int
modifier|*
name|widths
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|count
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|QSPLITTER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSplitterPrivate::doMove"
operator|<<
name|backwards
operator|<<
name|hPos
operator|<<
name|index
operator|<<
name|delta
operator|<<
name|mayCollapse
expr_stmt|;
endif|#
directive|endif
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|s
operator|->
name|widget
decl_stmt|;
name|int
name|nextId
init|=
name|backwards
condition|?
name|index
operator|-
name|delta
else|:
name|index
operator|+
name|delta
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|doMove
argument_list|(
name|backwards
argument_list|,
name|hPos
argument_list|,
name|nextId
argument_list|,
name|delta
argument_list|,
name|collapsible
argument_list|(
name|nextId
argument_list|)
argument_list|,
name|positions
argument_list|,
name|widths
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|hs
init|=
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|?
literal|0
else|:
name|s
operator|->
name|getHandleSize
argument_list|(
name|orient
argument_list|)
decl_stmt|;
name|int
name|ws
init|=
name|backwards
condition|?
name|hPos
operator|-
name|pick
argument_list|(
name|s
operator|->
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
else|:
name|pick
argument_list|(
name|s
operator|->
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
operator|-
name|hPos
operator|-
name|hs
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|ws
operator|>
literal|0
operator|||
operator|(
operator|!
name|s
operator|->
name|collapsed
operator|&&
operator|!
name|mayCollapse
operator|)
condition|)
block|{
name|ws
operator|=
name|qMin
argument_list|(
name|ws
argument_list|,
name|pick
argument_list|(
name|w
operator|->
name|maximumSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ws
operator|=
name|qMax
argument_list|(
name|ws
argument_list|,
name|pick
argument_list|(
name|qSmartMinSize
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ws
operator|=
literal|0
expr_stmt|;
block|}
name|positions
index|[
name|index
index|]
operator|=
name|backwards
condition|?
name|hPos
operator|-
name|ws
else|:
name|hPos
operator|+
name|hs
expr_stmt|;
name|widths
index|[
name|index
index|]
operator|=
name|ws
expr_stmt|;
name|doMove
argument_list|(
name|backwards
argument_list|,
name|backwards
condition|?
name|hPos
operator|-
name|ws
operator|-
name|hs
else|:
name|hPos
operator|+
name|hs
operator|+
name|ws
argument_list|,
name|nextId
argument_list|,
name|delta
argument_list|,
name|collapsible
argument_list|(
name|nextId
argument_list|)
argument_list|,
name|positions
argument_list|,
name|widths
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findWidget
name|QSplitterLayoutStruct
modifier|*
name|QSplitterPrivate
operator|::
name|findWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|widget
operator|==
name|w
condition|)
return|return
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|insertWidget_helper
name|void
name|QSplitterPrivate
operator|::
name|insertWidget_helper
parameter_list|(
name|int
name|index
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|,
name|bool
name|show
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QBoolBlocker
name|b
argument_list|(
name|blockChildAdd
argument_list|)
decl_stmt|;
name|bool
name|needShow
init|=
name|show
operator|&&
name|q
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|widget
operator|->
name|isHidden
argument_list|()
operator|&&
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|parentWidget
argument_list|()
operator|!=
name|q
condition|)
name|widget
operator|->
name|setParent
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|needShow
condition|)
name|widget
operator|->
name|show
argument_list|()
expr_stmt|;
name|insertWidget
argument_list|(
name|index
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|recalc
argument_list|(
name|q
operator|->
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Inserts the widget \a w at position \a index in the splitter's list of widgets.      If \a w is already in the splitter, it will be moved to the new position. */
end_comment
begin_function
DECL|function|insertWidget
name|QSplitterLayoutStruct
modifier|*
name|QSplitterPrivate
operator|::
name|insertWidget
parameter_list|(
name|int
name|index
parameter_list|,
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QSplitterLayoutStruct
modifier|*
name|sls
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|last
init|=
name|list
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|widget
operator|==
name|w
condition|)
block|{
name|sls
operator|=
name|s
expr_stmt|;
operator|--
name|last
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|last
condition|)
name|index
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|sls
condition|)
block|{
name|list
operator|.
name|move
argument_list|(
name|i
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QSplitterHandle
modifier|*
name|newHandle
init|=
literal|0
decl_stmt|;
name|sls
operator|=
operator|new
name|QSplitterLayoutStruct
expr_stmt|;
name|QString
name|tmp
init|=
name|QLatin1String
argument_list|(
literal|"qt_splithandle_"
argument_list|)
decl_stmt|;
name|tmp
operator|+=
name|w
operator|->
name|objectName
argument_list|()
expr_stmt|;
name|newHandle
operator|=
name|q
operator|->
name|createHandle
argument_list|()
expr_stmt|;
name|newHandle
operator|->
name|setObjectName
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|sls
operator|->
name|handle
operator|=
name|newHandle
expr_stmt|;
name|sls
operator|->
name|widget
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|lower
argument_list|()
expr_stmt|;
name|list
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|sls
argument_list|)
expr_stmt|;
if|if
condition|(
name|newHandle
operator|&&
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|newHandle
operator|->
name|show
argument_list|()
expr_stmt|;
comment|// will trigger sending of post events
block|}
return|return
name|sls
return|;
block|}
end_function
begin_comment
comment|/*!     \class QSplitter     \brief The QSplitter class implements a splitter widget.      \ingroup organizers     \inmodule QtWidgets       A splitter lets the user control the size of child widgets by dragging the     boundary between the children. Any number of widgets may be controlled by a     single splitter. The typical use of a QSplitter is to create several     widgets and add them using insertWidget() or addWidget().      The following example will show a QListView, QTreeView, and     QTextEdit side by side, with two splitter handles:      \snippet doc/src/snippets/splitter/splitter.cpp 0      If a widget is already inside a QSplitter when insertWidget() or     addWidget() is called, it will move to the new position. This can be used     to reorder widgets in the splitter later. You can use indexOf(),     widget(), and count() to get access to the widgets inside the splitter.      A default QSplitter lays out its children horizontally (side by side); you     can use setOrientation(Qt::Vertical) to lay its     children out vertically.      By default, all widgets can be as large or as small as the user     wishes, between the \l minimumSizeHint() (or \l minimumSize())     and \l maximumSize() of the widgets.      QSplitter resizes its children dynamically by default. If you     would rather have QSplitter resize the children only at the end of     a resize operation, call setOpaqueResize(false).      The initial distribution of size between the widgets is determined by     multiplying the initial size with the stretch factor.     You can also use setSizes() to set the sizes     of all the widgets. The function sizes() returns the sizes set by the user.     Alternatively, you can save and restore the sizes of the widgets from a     QByteArray using saveState() and restoreState() respectively.      When you hide() a child its space will be distributed among the     other children. It will be reinstated when you show() it again.      \sa QSplitterHandle, QHBoxLayout, QVBoxLayout, QTabWidget */
end_comment
begin_comment
comment|/*!     Constructs a horizontal splitter with the \a parent     argument passed on to the QFrame constructor.      \sa setOrientation() */
end_comment
begin_constructor
DECL|function|QSplitter
name|QSplitter
operator|::
name|QSplitter
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QSplitterPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|orient
operator|=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a splitter with the given \a orientation and \a parent.      \sa setOrientation() */
end_comment
begin_constructor
DECL|function|QSplitter
name|QSplitter
operator|::
name|QSplitter
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QFrame
argument_list|(
operator|*
operator|new
name|QSplitterPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|orient
operator|=
name|orientation
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the splitter. All children are deleted. */
end_comment
begin_destructor
DECL|function|~QSplitter
name|QSplitter
operator|::
name|~
name|QSplitter
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|rubberBand
expr_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|d
operator|->
name|list
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Updates the splitter's state. You should not need to call this     function. */
end_comment
begin_function
DECL|function|refresh
name|void
name|QSplitter
operator|::
name|refresh
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|recalc
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QSplitter::orientation     \brief the orientation of the splitter      By default the orientation is horizontal (i.e., the widgets are     laid out side by side). The possible orientations are     Qt::Horizontal and Qt::Vertical.      \sa QSplitterHandle::orientation() */
end_comment
begin_function
DECL|function|setOrientation
name|void
name|QSplitter
operator|::
name|setOrientation
parameter_list|(
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|orient
operator|==
name|orientation
condition|)
return|return;
if|if
condition|(
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|)
condition|)
block|{
name|QSizePolicy
name|sp
init|=
name|sizePolicy
argument_list|()
decl_stmt|;
name|sp
operator|.
name|transpose
argument_list|()
expr_stmt|;
name|setSizePolicy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|orient
operator|=
name|orientation
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|s
operator|->
name|handle
operator|->
name|setOrientation
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|recalc
argument_list|(
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|orientation
name|Qt
operator|::
name|Orientation
name|QSplitter
operator|::
name|orientation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|orient
return|;
block|}
end_function
begin_comment
comment|/*!     \property QSplitter::childrenCollapsible     \brief whether child widgets can be resized down to size 0 by the user      By default, children are collapsible. It is possible to enable     and disable the collapsing of individual children using     setCollapsible().      \sa setCollapsible() */
end_comment
begin_function
DECL|function|setChildrenCollapsible
name|void
name|QSplitter
operator|::
name|setChildrenCollapsible
parameter_list|(
name|bool
name|collapse
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|childrenCollapsible
operator|=
name|collapse
expr_stmt|;
block|}
end_function
begin_function
DECL|function|childrenCollapsible
name|bool
name|QSplitter
operator|::
name|childrenCollapsible
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|childrenCollapsible
return|;
block|}
end_function
begin_comment
comment|/*!     Sets whether the child widget at index \a index is collapsible to \a collapse.      By default, children are collapsible, meaning that the user can     resize them down to size 0, even if they have a non-zero     minimumSize() or minimumSizeHint(). This behavior can be changed     on a per-widget basis by calling this function, or globally for     all the widgets in the splitter by setting the \l     childrenCollapsible property.      \sa childrenCollapsible */
end_comment
begin_function
DECL|function|setCollapsible
name|void
name|QSplitter
operator|::
name|setCollapsible
parameter_list|(
name|int
name|index
parameter_list|,
name|bool
name|collapse
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSplitter::setCollapsible: Index %d out of range"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|collapsible
operator|=
name|collapse
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the widget at \a index is collapsible, otherwise returns false */
end_comment
begin_function
DECL|function|isCollapsible
name|bool
name|QSplitter
operator|::
name|isCollapsible
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSplitter::isCollapsible: Index %d out of range"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|collapsible
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QSplitter
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|doResize
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the given \a widget to the splitter's layout after all the other     items.      If \a widget is already in the splitter, it will be moved to the new position.      \sa insertWidget() widget() indexOf() */
end_comment
begin_function
DECL|function|addWidget
name|void
name|QSplitter
operator|::
name|addWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|insertWidget
argument_list|(
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts the \a widget specified into the splitter's layout at the     given \a index.      If \a widget is already in the splitter, it will be moved to the new position.      if \a index is an invalid index, then the widget will be inserted at the end.      \sa addWidget() indexOf() widget() */
end_comment
begin_function
DECL|function|insertWidget
name|void
name|QSplitter
operator|::
name|insertWidget
parameter_list|(
name|int
name|index
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|insertWidget_helper
argument_list|(
name|index
argument_list|,
name|widget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn int QSplitter::indexOf(QWidget *widget) const      Returns the index in the splitter's layout of the specified \a widget. This     also works for handles.      Handles are numbered from 0. There are as many handles as there     are child widgets, but the handle at position 0 is always hidden.       \sa count(), widget() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QSplitter
operator|::
name|indexOf
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|widget
operator|==
name|w
operator|||
name|s
operator|->
name|handle
operator|==
name|w
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a new splitter handle as a child widget of this splitter.     This function can be reimplemented in subclasses to provide support     for custom handles.      \sa handle(), indexOf() */
end_comment
begin_function
DECL|function|createHandle
name|QSplitterHandle
modifier|*
name|QSplitter
operator|::
name|createHandle
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
return|return
operator|new
name|QSplitterHandle
argument_list|(
name|d
operator|->
name|orient
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the handle to the left (or above) for the item in the     splitter's layout at the given \a index. The handle at index 0 is     always hidden.      For right-to-left languages such as Arabic and Hebrew, the layout     of horizontal splitters is reversed. The handle will be to the     right of the widget at \a index.      \sa count(), widget(), indexOf(), createHandle(), setHandleWidth() */
end_comment
begin_function
DECL|function|handle
name|QSplitterHandle
modifier|*
name|QSplitter
operator|::
name|handle
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|handle
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget at the given \a index in the splitter's layout.      \sa count(), handle(), indexOf(), insertWidget() */
end_comment
begin_function
DECL|function|widget
name|QWidget
modifier|*
name|QSplitter
operator|::
name|widget
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|widget
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of widgets contained in the splitter's layout.      \sa widget(), handle() */
end_comment
begin_function
DECL|function|count
name|int
name|QSplitter
operator|::
name|count
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Tells the splitter that the child widget described by \a c has been     inserted or removed.      This method is also used to handle the situation where a widget is created     with the splitter as a parent but not explicitly added with insertWidget()     or addWidget(). This is for compatibility and not the recommended way of     putting widgets into a splitter in new code. Please use insertWidget() or     addWidget() in new code.      \sa addWidget() insertWidget() */
end_comment
begin_function
DECL|function|childEvent
name|void
name|QSplitter
operator|::
name|childEvent
parameter_list|(
name|QChildEvent
modifier|*
name|c
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|child
argument_list|()
operator|->
name|isWidgetType
argument_list|()
condition|)
return|return;
name|QWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|c
operator|->
name|child
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|added
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|blockChildAdd
operator|&&
operator|!
name|w
operator|->
name|isWindow
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|findWidget
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|d
operator|->
name|insertWidget_helper
argument_list|(
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
argument_list|,
name|w
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|polished
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|blockChildAdd
condition|)
block|{
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|w
operator|->
name|isHidden
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_ExplicitShowHide
argument_list|)
operator|)
condition|)
name|w
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ChildRemoved
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|widget
operator|==
name|w
condition|)
block|{
name|d
operator|->
name|list
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|delete
name|s
expr_stmt|;
name|d
operator|->
name|recalc
argument_list|(
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Displays a rubber band at position \a pos. If \a pos is negative, the     rubber band is removed. */
end_comment
begin_function
DECL|function|setRubberBand
name|void
name|QSplitter
operator|::
name|setRubberBand
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|rubberBand
condition|)
name|d
operator|->
name|rubberBand
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
return|return;
block|}
name|QRect
name|r
init|=
name|contentsRect
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rBord
init|=
literal|3
decl_stmt|;
comment|// customizable?
name|int
name|hw
init|=
name|handleWidth
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|rubberBand
condition|)
block|{
name|QBoolBlocker
name|b
argument_list|(
name|d
operator|->
name|blockChildAdd
argument_list|)
decl_stmt|;
name|d
operator|->
name|rubberBand
operator|=
operator|new
name|QRubberBand
argument_list|(
name|QRubberBand
operator|::
name|Line
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// For accessibility to identify this special widget.
name|d
operator|->
name|rubberBand
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"qt_rubberband"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QRect
name|newGeom
init|=
name|d
operator|->
name|orient
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|pos
operator|+
name|hw
operator|/
literal|2
operator|-
name|rBord
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|QSize
argument_list|(
literal|2
operator|*
name|rBord
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
else|:
name|QRect
argument_list|(
name|QPoint
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|+
name|hw
operator|/
literal|2
operator|-
name|rBord
argument_list|)
argument_list|,
name|QSize
argument_list|(
name|r
operator|.
name|width
argument_list|()
argument_list|,
literal|2
operator|*
name|rBord
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|rubberBand
operator|->
name|setGeometry
argument_list|(
name|newGeom
argument_list|)
expr_stmt|;
name|d
operator|->
name|rubberBand
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSplitter
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Hide
case|:
comment|// Reset firstShow to false here since things can be done to the splitter in between
if|if
condition|(
operator|!
name|d
operator|->
name|firstShow
condition|)
name|d
operator|->
name|firstShow
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|firstShow
condition|)
break|break;
name|d
operator|->
name|firstShow
operator|=
literal|false
expr_stmt|;
comment|// fall through
case|case
name|QEvent
operator|::
name|HideToParent
case|:
case|case
name|QEvent
operator|::
name|ShowToParent
case|:
case|case
name|QEvent
operator|::
name|LayoutRequest
case|:
name|d
operator|->
name|recalc
argument_list|(
name|isVisible
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSplitter::splitterMoved(int pos, int index)      This signal is emitted when the splitter handle at a particular \a     index has been moved to position \a pos.      For right-to-left languages such as Arabic and Hebrew, the layout     of horizontal splitters is reversed. \a pos is then the     distance from the right edge of the widget.      \sa moveSplitter() */
end_comment
begin_comment
comment|/*!     Moves the left or top edge of the splitter handle at \a index as     close as possible to position \a pos, which is the distance from the     left or top edge of the widget.      For right-to-left languages such as Arabic and Hebrew, the layout     of horizontal splitters is reversed. \a pos is then the distance     from the right edge of the widget.      \sa splitterMoved(), closestLegalPosition(), getRange() */
end_comment
begin_function
DECL|function|moveSplitter
name|void
name|QSplitter
operator|::
name|moveSplitter
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|farMin
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|farMax
decl_stmt|;
ifdef|#
directive|ifdef
name|QSPLITTER_DEBUG
name|int
name|debugp
init|=
name|pos
decl_stmt|;
endif|#
directive|endif
name|pos
operator|=
name|d
operator|->
name|adjustPos
argument_list|(
name|pos
argument_list|,
name|index
argument_list|,
operator|&
name|farMin
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|farMax
argument_list|)
expr_stmt|;
name|int
name|oldP
init|=
name|d
operator|->
name|pick
argument_list|(
name|s
operator|->
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSPLITTER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSplitter::moveSplitter"
operator|<<
name|debugp
operator|<<
name|index
operator|<<
literal|"adjusted"
operator|<<
name|pos
operator|<<
literal|"oldP"
operator|<<
name|oldP
expr_stmt|;
endif|#
directive|endif
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|32
argument_list|>
name|poss
argument_list|(
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
literal|32
argument_list|>
name|ws
argument_list|(
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|upLeft
decl_stmt|;
name|d
operator|->
name|doMove
argument_list|(
literal|false
argument_list|,
name|pos
argument_list|,
name|index
argument_list|,
operator|+
literal|1
argument_list|,
operator|(
name|d
operator|->
name|collapsible
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|pos
operator|>
name|max
operator|)
operator|)
argument_list|,
name|poss
operator|.
name|data
argument_list|()
argument_list|,
name|ws
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|doMove
argument_list|(
literal|true
argument_list|,
name|pos
argument_list|,
name|index
operator|-
literal|1
argument_list|,
operator|+
literal|1
argument_list|,
operator|(
name|d
operator|->
name|collapsible
argument_list|(
name|index
operator|-
literal|1
argument_list|)
operator|&&
operator|(
name|pos
operator|<
name|min
operator|)
operator|)
argument_list|,
name|poss
operator|.
name|data
argument_list|()
argument_list|,
name|ws
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|upLeft
operator|=
operator|(
name|pos
operator|<
name|oldP
operator|)
expr_stmt|;
name|int
name|wid
decl_stmt|,
name|delta
decl_stmt|,
name|count
init|=
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|upLeft
condition|)
block|{
name|wid
operator|=
literal|0
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wid
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|wid
operator|>=
literal|0
operator|&&
name|wid
operator|<
name|count
condition|;
name|wid
operator|+=
name|delta
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|sls
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|wid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sls
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
name|d
operator|->
name|setGeo
argument_list|(
name|sls
argument_list|,
name|poss
index|[
name|wid
index|]
argument_list|,
name|ws
index|[
name|wid
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|storeSizes
argument_list|()
expr_stmt|;
emit|emit
name|splitterMoved
argument_list|(
name|pos
argument_list|,
name|index
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Returns the valid range of the splitter with index \a index in     *\a{min} and *\a{max} if \a min and \a max are not 0. */
end_comment
begin_function
DECL|function|getRange
name|void
name|QSplitter
operator|::
name|getRange
parameter_list|(
name|int
name|index
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|getRange
argument_list|(
name|index
argument_list|,
name|min
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the closest legal position to \a pos of the widget with index     \a index.      For right-to-left languages such as Arabic and Hebrew, the layout     of horizontal splitters is reversed. Positions are then measured     from the right edge of the widget.      \sa getRange() */
end_comment
begin_function
DECL|function|closestLegalPosition
name|int
name|QSplitter
operator|::
name|closestLegalPosition
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|int
name|x
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|u
decl_stmt|;
return|return
name|d
operator|->
name|adjustPos
argument_list|(
name|pos
argument_list|,
name|index
argument_list|,
operator|&
name|u
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QSplitter::opaqueResize     \brief whether resizing is opaque      Opaque resizing is on by default. */
end_comment
begin_function
DECL|function|opaqueResize
name|bool
name|QSplitter
operator|::
name|opaqueResize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|opaque
return|;
block|}
end_function
begin_function
DECL|function|setOpaqueResize
name|void
name|QSplitter
operator|::
name|setOpaqueResize
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|opaque
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QSplitter
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|widget
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|isHidden
argument_list|()
condition|)
continue|continue;
name|QSize
name|s
init|=
name|w
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|l
operator|+=
name|d
operator|->
name|pick
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
name|qMax
argument_list|(
name|t
argument_list|,
name|d
operator|->
name|trans
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|QSize
argument_list|(
name|l
argument_list|,
name|t
argument_list|)
else|:
name|QSize
argument_list|(
name|t
argument_list|,
name|l
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QSplitter
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|s
operator|->
name|widget
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|widget
operator|->
name|isHidden
argument_list|()
condition|)
continue|continue;
name|QSize
name|widgetSize
init|=
name|qSmartMinSize
argument_list|(
name|s
operator|->
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|widgetSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|l
operator|+=
name|d
operator|->
name|pick
argument_list|(
name|widgetSize
argument_list|)
expr_stmt|;
name|t
operator|=
name|qMax
argument_list|(
name|t
argument_list|,
name|d
operator|->
name|trans
argument_list|(
name|widgetSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|handle
operator|||
name|s
operator|->
name|handle
operator|->
name|isHidden
argument_list|()
condition|)
continue|continue;
name|QSize
name|splitterSize
init|=
name|s
operator|->
name|handle
operator|->
name|sizeHint
argument_list|()
decl_stmt|;
if|if
condition|(
name|splitterSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|l
operator|+=
name|d
operator|->
name|pick
argument_list|(
name|splitterSize
argument_list|)
expr_stmt|;
name|t
operator|=
name|qMax
argument_list|(
name|t
argument_list|,
name|d
operator|->
name|trans
argument_list|(
name|splitterSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|QSize
argument_list|(
name|l
argument_list|,
name|t
argument_list|)
else|:
name|QSize
argument_list|(
name|t
argument_list|,
name|l
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the size parameters of all the widgets in this splitter.      If the splitter's orientation is horizontal, the list contains the     widgets width in pixels, from left to right; if the orientation is     vertical, the list contains the widgets height in pixels,     from top to bottom.      Giving the values to another splitter's setSizes() function will     produce a splitter with the same layout as this one.      Note that invisible widgets have a size of 0.      \sa setSizes() */
end_comment
begin_function
DECL|function|sizes
name|QList
argument_list|<
name|int
argument_list|>
name|QSplitter
operator|::
name|sizes
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|list
operator|.
name|append
argument_list|(
name|d
operator|->
name|pick
argument_list|(
name|s
operator|->
name|rect
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the child widgets respective sizes to the values given in the \a list.      If the splitter is horizontal, the values set the widths of each     widget in pixels, from left to right. If the splitter is vertical, the     heights of each widget is set, from top to bottom.      Extra values in the \a list are ignored. If \a list contains too few     values, the result is undefined but the program will still be well-behaved.      The overall size of the splitter widget is not affected.     Instead, any additional/missing space is distributed amongst the     widgets according to the relative weight of the sizes.      If you specify a size of 0, the widget will be invisible. The size policies     of the widgets are preserved. That is, a value smaller then the minimal size     hint of the respective widget will be replaced by the value of the hint.      \sa sizes() */
end_comment
begin_function
DECL|function|setSizes
name|void
name|QSplitter
operator|::
name|setSizes
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|list
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|setSizes_helper
argument_list|(
name|list
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QSplitter::handleWidth     \brief the width of the splitter handles      By default, this property contains a value that depends on the user's platform     and style preferences.      If you set handleWidth to 1 or 0, the actual grab area will grow to overlap a     few pixels of it's respective widgets. */
end_comment
begin_function
DECL|function|handleWidth
name|int
name|QSplitter
operator|::
name|handleWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|handleWidth
operator|>=
literal|0
condition|)
block|{
return|return
name|d
operator|->
name|handleWidth
return|;
block|}
else|else
block|{
return|return
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_SplitterWidth
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|setHandleWidth
name|void
name|QSplitter
operator|::
name|setHandleWidth
parameter_list|(
name|int
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|d
operator|->
name|handleWidth
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|updateHandles
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QSplitter
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|StyleChange
condition|)
name|d
operator|->
name|updateHandles
argument_list|()
expr_stmt|;
name|QFrame
operator|::
name|changeEvent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|SplitterMagic
specifier|static
specifier|const
name|qint32
name|SplitterMagic
init|=
literal|0xff
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Saves the state of the splitter's layout.      Typically this is used in conjunction with QSettings to remember the size     for a future session. A version number is stored as part of the data.     Here is an example:      \snippet doc/src/snippets/splitter/splitter.cpp 1      \sa restoreState() */
end_comment
begin_function
DECL|function|saveState
name|QByteArray
name|QSplitter
operator|::
name|saveState
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSplitter
argument_list|)
expr_stmt|;
name|int
name|version
init|=
literal|0
decl_stmt|;
name|QByteArray
name|data
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|data
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|stream
operator|<<
name|qint32
argument_list|(
name|SplitterMagic
argument_list|)
expr_stmt|;
name|stream
operator|<<
name|qint32
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSplitterLayoutStruct
modifier|*
name|s
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|list
operator|.
name|append
argument_list|(
name|s
operator|->
name|sizer
argument_list|)
expr_stmt|;
block|}
name|stream
operator|<<
name|list
expr_stmt|;
name|stream
operator|<<
name|childrenCollapsible
argument_list|()
expr_stmt|;
name|stream
operator|<<
name|qint32
argument_list|(
name|handleWidth
argument_list|()
argument_list|)
expr_stmt|;
name|stream
operator|<<
name|opaqueResize
argument_list|()
expr_stmt|;
name|stream
operator|<<
name|qint32
argument_list|(
name|orientation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Restores the splitter's layout to the \a state specified.     Returns true if the state is restored; otherwise returns false.      Typically this is used in conjunction with QSettings to restore the size     from a past session. Here is an example:      Restore the splitters's state:      \snippet doc/src/snippets/splitter/splitter.cpp 2      A failure to restore the splitter's layout may result from either     invalid or out-of-date data in the supplied byte array.      \sa saveState() */
end_comment
begin_function
DECL|function|restoreState
name|bool
name|QSplitter
operator|::
name|restoreState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|state
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
name|int
name|version
init|=
literal|0
decl_stmt|;
name|QByteArray
name|sd
init|=
name|state
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|sd
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|list
decl_stmt|;
name|bool
name|b
decl_stmt|;
name|qint32
name|i
decl_stmt|;
name|qint32
name|marker
decl_stmt|;
name|qint32
name|v
decl_stmt|;
name|stream
operator|>>
name|marker
expr_stmt|;
name|stream
operator|>>
name|v
expr_stmt|;
if|if
condition|(
name|marker
operator|!=
name|SplitterMagic
operator|||
name|v
operator|!=
name|version
condition|)
return|return
literal|false
return|;
name|stream
operator|>>
name|list
expr_stmt|;
name|d
operator|->
name|setSizes_helper
argument_list|(
name|list
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|stream
operator|>>
name|b
expr_stmt|;
name|setChildrenCollapsible
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|stream
operator|>>
name|i
expr_stmt|;
name|setHandleWidth
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|stream
operator|>>
name|b
expr_stmt|;
name|setOpaqueResize
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|stream
operator|>>
name|i
expr_stmt|;
name|setOrientation
argument_list|(
name|Qt
operator|::
name|Orientation
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|doResize
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Updates the size policy of the widget at position \a index to     have a stretch factor of \a stretch.      \a stretch is not the effective stretch factor; the effective     stretch factor is calculated by taking the initial size of the      widget and multiplying it with \a stretch.      This function is provided for convenience. It is equivalent to      \snippet doc/src/snippets/code/src_gui_widgets_qsplitter.cpp 0      \sa setSizes(), widget() */
end_comment
begin_function
DECL|function|setStretchFactor
name|void
name|QSplitter
operator|::
name|setStretchFactor
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|stretch
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSplitter
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<=
operator|-
literal|1
operator|||
name|index
operator|>=
name|d
operator|->
name|list
operator|.
name|count
argument_list|()
condition|)
return|return;
name|QWidget
modifier|*
name|widget
init|=
name|d
operator|->
name|list
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|widget
decl_stmt|;
name|QSizePolicy
name|sp
init|=
name|widget
operator|->
name|sizePolicy
argument_list|()
decl_stmt|;
name|sp
operator|.
name|setHorizontalStretch
argument_list|(
name|stretch
argument_list|)
expr_stmt|;
name|sp
operator|.
name|setVerticalStretch
argument_list|(
name|stretch
argument_list|)
expr_stmt|;
name|widget
operator|->
name|setSizePolicy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \relates QSplitter     \obsolete      Use \a ts<< \a{splitter}.saveState() instead. */
end_comment
begin_function
DECL|function|operator <<
name|QTextStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QTextStream
modifier|&
name|ts
parameter_list|,
specifier|const
name|QSplitter
modifier|&
name|splitter
parameter_list|)
block|{
name|ts
operator|<<
name|splitter
operator|.
name|saveState
argument_list|()
operator|<<
name|endl
expr_stmt|;
return|return
name|ts
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QSplitter     \obsolete      Use \a ts>> \a{splitter}.restoreState() instead. */
end_comment
begin_function
DECL|function|operator >>
name|QTextStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QTextStream
modifier|&
name|ts
parameter_list|,
name|QSplitter
modifier|&
name|splitter
parameter_list|)
block|{
name|QString
name|line
init|=
name|ts
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|line
operator|=
name|line
operator|.
name|simplified
argument_list|()
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|splitter
operator|.
name|restoreState
argument_list|(
name|line
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ts
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SPLITTER
end_comment
end_unit
