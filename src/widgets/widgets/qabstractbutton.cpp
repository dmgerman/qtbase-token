begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstractbutton.h"
end_include
begin_include
include|#
directive|include
file|"qabstractitemview.h"
end_include
begin_include
include|#
directive|include
file|"qbuttongroup.h"
end_include
begin_include
include|#
directive|include
file|"qabstractbutton_p.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qstyle.h"
end_include
begin_include
include|#
directive|include
file|"qaction.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
DECL|macro|AUTO_REPEAT_DELAY
define|#
directive|define
name|AUTO_REPEAT_DELAY
value|300
DECL|macro|AUTO_REPEAT_INTERVAL
define|#
directive|define
name|AUTO_REPEAT_INTERVAL
value|100
name|Q_WIDGETS_EXPORT
specifier|extern
name|bool
name|qt_tab_all_widgets
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|/*!     \class QAbstractButton      \brief The QAbstractButton class is the abstract base class of     button widgets, providing functionality common to buttons.      \ingroup abstractwidgets     \inmodule QtWidgets      This class implements an \e abstract button.     Subclasses of this class handle user actions, and specify how the button     is drawn.      QAbstractButton provides support for both push buttons and checkable     (toggle) buttons. Checkable buttons are implemented in the QRadioButton     and QCheckBox classes. Push buttons are implemented in the     QPushButton and QToolButton classes; these also provide toggle     behavior if required.      Any button can display a label containing text and an icon. setText()     sets the text; setIcon() sets the icon. If a button is disabled, its label     is changed to give the button a "disabled" appearance.      If the button is a text button with a string containing an     ampersand ('&'), QAbstractButton automatically creates a shortcut     key. For example:      \snippet code/src_gui_widgets_qabstractbutton.cpp 0      The \uicontrol Alt+C shortcut is assigned to the button, i.e., when the     user presses \uicontrol Alt+C the button will call animateClick(). See     the \l {QShortcut#mnemonic}{QShortcut} documentation for details. To     display an actual ampersand, use '&&'.      You can also set a custom shortcut key using the setShortcut()     function. This is useful mostly for buttons that do not have any     text, and therefore can't have any automatic shortcut.      \snippet code/src_gui_widgets_qabstractbutton.cpp 1      All the buttons provided by Qt (QPushButton, QToolButton,     QCheckBox, and QRadioButton) can display both \l text and \l{icon}{icons}.      A button can be made the default button in a dialog by means of     QPushButton::setDefault() and QPushButton::setAutoDefault().      QAbstractButton provides most of the states used for buttons:      \list      \li isDown() indicates whether the button is \e pressed down.      \li isChecked() indicates whether the button is \e checked.  Only     checkable buttons can be checked and unchecked (see below).      \li isEnabled() indicates whether the button can be pressed by the     user. \note As opposed to other widgets, buttons derived from     QAbstractButton accept mouse and context menu events     when disabled.      \li setAutoRepeat() sets whether the button will auto-repeat if the     user holds it down. \l autoRepeatDelay and \l autoRepeatInterval     define how auto-repetition is done.      \li setCheckable() sets whether the button is a toggle button or not.      \endlist      The difference between isDown() and isChecked() is as follows.     When the user clicks a toggle button to check it, the button is first     \e pressed then released into the \e checked state. When the user     clicks it again (to uncheck it), the button moves first to the     \e pressed state, then to the \e unchecked state (isChecked() and     isDown() are both false).      QAbstractButton provides four signals:      \list 1      \li pressed() is emitted when the left mouse button is pressed while     the mouse cursor is inside the button.      \li released() is emitted when the left mouse button is released.      \li clicked() is emitted when the button is first pressed and then     released, when the shortcut key is typed, or when click() or     animateClick() is called.      \li toggled() is emitted when the state of a toggle button changes.      \endlist      To subclass QAbstractButton, you must reimplement at least     paintEvent() to draw the button's outline and its text or pixmap. It     is generally advisable to reimplement sizeHint() as well, and     sometimes hitButton() (to determine whether a button press is within     the button). For buttons with more than two states (like tri-state     buttons), you will also have to reimplement checkStateSet() and     nextCheckState().      \sa QButtonGroup */
end_comment
begin_constructor
DECL|function|QAbstractButtonPrivate
name|QAbstractButtonPrivate
operator|::
name|QAbstractButtonPrivate
parameter_list|(
name|QSizePolicy
operator|::
name|ControlType
name|type
parameter_list|)
member_init_list|:
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|shortcutId
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
name|checkable
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|checked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autoRepeat
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autoExclusive
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|down
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|blockRefresh
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pressed
argument_list|(
literal|false
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
name|group
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
name|autoRepeatDelay
argument_list|(
name|AUTO_REPEAT_DELAY
argument_list|)
member_init_list|,
name|autoRepeatInterval
argument_list|(
name|AUTO_REPEAT_INTERVAL
argument_list|)
member_init_list|,
name|controlType
argument_list|(
name|type
argument_list|)
block|{}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
end_ifndef
begin_class
DECL|class|QButtonGroupPrivate
class|class
name|QButtonGroupPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QButtonGroup
parameter_list|)
specifier|public
private|:
DECL|function|QButtonGroupPrivate
name|QButtonGroupPrivate
parameter_list|()
member_init_list|:
name|exclusive
argument_list|(
literal|true
argument_list|)
block|{}
DECL|member|buttonList
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|buttonList
decl_stmt|;
DECL|member|checkedButton
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|checkedButton
decl_stmt|;
name|void
name|detectCheckedButton
parameter_list|()
function_decl|;
name|void
name|notifyChecked
parameter_list|(
name|QAbstractButton
modifier|*
name|button
parameter_list|)
function_decl|;
DECL|member|exclusive
name|bool
name|exclusive
decl_stmt|;
DECL|member|mapping
name|QHash
argument_list|<
name|QAbstractButton
modifier|*
argument_list|,
name|int
argument_list|>
name|mapping
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QButtonGroup
name|QButtonGroup
operator|::
name|QButtonGroup
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QButtonGroupPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QButtonGroup
name|QButtonGroup
operator|::
name|~
name|QButtonGroup
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QButtonGroup
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|buttonList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|group
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|exclusive
name|bool
name|QButtonGroup
operator|::
name|exclusive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exclusive
return|;
block|}
end_function
begin_function
DECL|function|setExclusive
name|void
name|QButtonGroup
operator|::
name|setExclusive
parameter_list|(
name|bool
name|exclusive
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QButtonGroup
argument_list|)
expr_stmt|;
name|d
operator|->
name|exclusive
operator|=
name|exclusive
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addButton
name|void
name|QButtonGroup
operator|::
name|addButton
parameter_list|(
name|QAbstractButton
modifier|*
name|button
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QButtonGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|QButtonGroup
modifier|*
name|previous
init|=
name|button
operator|->
name|d_func
argument_list|()
operator|->
name|group
condition|)
name|previous
operator|->
name|removeButton
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|button
operator|->
name|d_func
argument_list|()
operator|->
name|group
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|buttonList
operator|.
name|append
argument_list|(
name|button
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|QList
argument_list|<
name|int
argument_list|>
name|ids
init|=
name|d
operator|->
name|mapping
operator|.
name|values
argument_list|()
decl_stmt|;
if|if
condition|(
name|ids
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|mapping
index|[
name|button
index|]
operator|=
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|qSort
argument_list|(
name|ids
argument_list|)
expr_stmt|;
name|d
operator|->
name|mapping
index|[
name|button
index|]
operator|=
name|ids
operator|.
name|first
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|mapping
index|[
name|button
index|]
operator|=
name|id
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|exclusive
operator|&&
name|button
operator|->
name|isChecked
argument_list|()
condition|)
name|button
operator|->
name|d_func
argument_list|()
operator|->
name|notifyChecked
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeButton
name|void
name|QButtonGroup
operator|::
name|removeButton
parameter_list|(
name|QAbstractButton
modifier|*
name|button
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QButtonGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|checkedButton
operator|==
name|button
condition|)
block|{
name|d
operator|->
name|detectCheckedButton
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|button
operator|->
name|d_func
argument_list|()
operator|->
name|group
operator|==
name|this
condition|)
block|{
name|button
operator|->
name|d_func
argument_list|()
operator|->
name|group
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|buttonList
operator|.
name|removeAll
argument_list|(
name|button
argument_list|)
expr_stmt|;
name|d
operator|->
name|mapping
operator|.
name|remove
argument_list|(
name|button
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|buttons
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|QButtonGroup
operator|::
name|buttons
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|buttonList
return|;
block|}
end_function
begin_function
DECL|function|checkedButton
name|QAbstractButton
modifier|*
name|QButtonGroup
operator|::
name|checkedButton
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|checkedButton
return|;
block|}
end_function
begin_function
DECL|function|button
name|QAbstractButton
modifier|*
name|QButtonGroup
operator|::
name|button
parameter_list|(
name|int
name|id
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|mapping
operator|.
name|key
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setId
name|void
name|QButtonGroup
operator|::
name|setId
parameter_list|(
name|QAbstractButton
modifier|*
name|button
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QButtonGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|button
operator|&&
name|id
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|mapping
index|[
name|button
index|]
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_function
DECL|function|id
name|int
name|QButtonGroup
operator|::
name|id
parameter_list|(
name|QAbstractButton
modifier|*
name|button
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|mapping
operator|.
name|value
argument_list|(
name|button
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|checkedId
name|int
name|QButtonGroup
operator|::
name|checkedId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QButtonGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|mapping
operator|.
name|value
argument_list|(
name|d
operator|->
name|checkedButton
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// detect a checked button other than the current one
end_comment
begin_function
DECL|function|detectCheckedButton
name|void
name|QButtonGroupPrivate
operator|::
name|detectCheckedButton
parameter_list|()
block|{
name|QAbstractButton
modifier|*
name|previous
init|=
name|checkedButton
decl_stmt|;
name|checkedButton
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exclusive
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buttonList
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|previous
operator|&&
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|isChecked
argument_list|()
condition|)
block|{
name|checkedButton
operator|=
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BUTTONGROUP
end_comment
begin_function
DECL|function|queryButtonList
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|QAbstractButtonPrivate
operator|::
name|queryButtonList
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|group
condition|)
return|return
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|buttonList
return|;
endif|#
directive|endif
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|candidates
init|=
name|parent
operator|->
name|findChildren
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|autoExclusive
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|candidates
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QAbstractButton
modifier|*
name|candidate
init|=
name|candidates
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|candidate
operator|->
name|autoExclusive
argument_list|()
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
operator|||
name|candidate
operator|->
name|group
argument_list|()
endif|#
directive|endif
condition|)
name|candidates
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|candidates
return|;
block|}
end_function
begin_function
DECL|function|queryCheckedButton
name|QAbstractButton
modifier|*
name|QAbstractButtonPrivate
operator|::
name|queryCheckedButton
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|group
condition|)
return|return
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|checkedButton
return|;
endif|#
directive|endif
name|Q_Q
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|buttonList
init|=
name|queryButtonList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|autoExclusive
operator|||
name|buttonList
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
comment|// no group
return|return
literal|0
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buttonList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractButton
modifier|*
name|b
init|=
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|d_func
argument_list|()
operator|->
name|checked
operator|&&
name|b
operator|!=
name|q
condition|)
return|return
name|b
return|;
block|}
return|return
name|checked
condition|?
cast|const_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|notifyChecked
name|void
name|QAbstractButtonPrivate
operator|::
name|notifyChecked
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
condition|)
block|{
name|QAbstractButton
modifier|*
name|previous
init|=
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|checkedButton
decl_stmt|;
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|checkedButton
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|exclusive
operator|&&
name|previous
operator|&&
name|previous
operator|!=
name|q
condition|)
name|previous
operator|->
name|nextCheckState
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|autoExclusive
condition|)
block|{
if|if
condition|(
name|QAbstractButton
modifier|*
name|b
init|=
name|queryCheckedButton
argument_list|()
condition|)
name|b
operator|->
name|setChecked
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|moveFocus
name|void
name|QAbstractButtonPrivate
operator|::
name|moveFocus
parameter_list|(
name|int
name|key
parameter_list|)
block|{
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|buttonList
init|=
name|queryButtonList
argument_list|()
decl_stmt|;
empty_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
name|bool
name|exclusive
init|=
name|group
condition|?
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|exclusive
else|:
name|autoExclusive
decl_stmt|;
else|#
directive|else
name|bool
name|exclusive
init|=
name|autoExclusive
decl_stmt|;
endif|#
directive|endif
name|QWidget
modifier|*
name|f
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
name|QAbstractButton
modifier|*
name|fb
init|=
name|qobject_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fb
operator|||
operator|!
name|buttonList
operator|.
name|contains
argument_list|(
name|fb
argument_list|)
condition|)
return|return;
name|QAbstractButton
modifier|*
name|candidate
init|=
literal|0
decl_stmt|;
name|int
name|bestScore
init|=
operator|-
literal|1
decl_stmt|;
name|QRect
name|target
init|=
name|f
operator|->
name|rect
argument_list|()
operator|.
name|translated
argument_list|(
name|f
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QPoint
name|goal
init|=
name|target
operator|.
name|center
argument_list|()
decl_stmt|;
name|uint
name|focus_flag
init|=
name|qt_tab_all_widgets
argument_list|()
condition|?
name|Qt
operator|::
name|TabFocus
else|:
name|Qt
operator|::
name|StrongFocus
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buttonList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractButton
modifier|*
name|button
init|=
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|button
operator|!=
name|f
operator|&&
name|button
operator|->
name|window
argument_list|()
operator|==
name|f
operator|->
name|window
argument_list|()
operator|&&
name|button
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|!
name|button
operator|->
name|isHidden
argument_list|()
operator|&&
operator|(
name|autoExclusive
operator|||
operator|(
name|button
operator|->
name|focusPolicy
argument_list|()
operator|&
name|focus_flag
operator|)
operator|==
name|focus_flag
operator|)
condition|)
block|{
name|QRect
name|buttonRect
init|=
name|button
operator|->
name|rect
argument_list|()
operator|.
name|translated
argument_list|(
name|button
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QPoint
name|p
init|=
name|buttonRect
operator|.
name|center
argument_list|()
decl_stmt|;
comment|//Priority to widgets that overlap on the same coordinate.
comment|//In that case, the distance in the direction will be used as significant score,
comment|//take also in account orthogonal distance in case two widget are in the same distance.
name|int
name|score
decl_stmt|;
if|if
condition|(
operator|(
name|buttonRect
operator|.
name|x
argument_list|()
operator|<
name|target
operator|.
name|right
argument_list|()
operator|&&
name|target
operator|.
name|x
argument_list|()
operator|<
name|buttonRect
operator|.
name|right
argument_list|()
operator|)
operator|&&
operator|(
name|key
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
condition|)
block|{
comment|//one item's is at the vertical of the other
name|score
operator|=
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
operator|-
name|goal
operator|.
name|y
argument_list|()
argument_list|)
operator|<<
literal|16
operator|)
operator|+
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|-
name|goal
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|buttonRect
operator|.
name|y
argument_list|()
operator|<
name|target
operator|.
name|bottom
argument_list|()
operator|&&
name|target
operator|.
name|y
argument_list|()
operator|<
name|buttonRect
operator|.
name|bottom
argument_list|()
operator|)
operator|&&
operator|(
name|key
operator|==
name|Qt
operator|::
name|Key_Left
operator|||
name|key
operator|==
name|Qt
operator|::
name|Key_Right
operator|)
condition|)
block|{
comment|//one item's is at the horizontal of the other
name|score
operator|=
operator|(
name|qAbs
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|-
name|goal
operator|.
name|x
argument_list|()
argument_list|)
operator|<<
literal|16
operator|)
operator|+
name|qAbs
argument_list|(
name|p
operator|.
name|y
argument_list|()
operator|-
name|goal
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|score
operator|=
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|+
operator|(
name|p
operator|.
name|y
argument_list|()
operator|-
name|goal
operator|.
name|y
argument_list|()
operator|)
operator|*
operator|(
name|p
operator|.
name|y
argument_list|()
operator|-
name|goal
operator|.
name|y
argument_list|()
operator|)
operator|+
operator|(
name|p
operator|.
name|x
argument_list|()
operator|-
name|goal
operator|.
name|x
argument_list|()
operator|)
operator|*
operator|(
name|p
operator|.
name|x
argument_list|()
operator|-
name|goal
operator|.
name|x
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|>
name|bestScore
operator|&&
name|candidate
condition|)
continue|continue;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Up
case|:
if|if
condition|(
name|p
operator|.
name|y
argument_list|()
operator|<
name|goal
operator|.
name|y
argument_list|()
condition|)
block|{
name|candidate
operator|=
name|button
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Down
case|:
if|if
condition|(
name|p
operator|.
name|y
argument_list|()
operator|>
name|goal
operator|.
name|y
argument_list|()
condition|)
block|{
name|candidate
operator|=
name|button
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Left
case|:
if|if
condition|(
name|p
operator|.
name|x
argument_list|()
operator|<
name|goal
operator|.
name|x
argument_list|()
condition|)
block|{
name|candidate
operator|=
name|button
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Right
case|:
if|if
condition|(
name|p
operator|.
name|x
argument_list|()
operator|>
name|goal
operator|.
name|x
argument_list|()
condition|)
block|{
name|candidate
operator|=
name|button
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|exclusive
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
operator|&&
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
endif|#
directive|endif
operator|&&
name|candidate
operator|&&
name|fb
operator|->
name|d_func
argument_list|()
operator|->
name|checked
operator|&&
name|candidate
operator|->
name|d_func
argument_list|()
operator|->
name|checkable
condition|)
name|candidate
operator|->
name|click
argument_list|()
expr_stmt|;
if|if
condition|(
name|candidate
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|key
operator|==
name|Qt
operator|::
name|Key_Left
condition|)
name|candidate
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
else|else
name|candidate
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|TabFocusReason
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fixFocusPolicy
name|void
name|QAbstractButtonPrivate
operator|::
name|fixFocusPolicy
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
operator|!
name|group
operator|&&
operator|!
name|autoExclusive
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|autoExclusive
condition|)
endif|#
directive|endif
return|return;
name|QList
argument_list|<
name|QAbstractButton
modifier|*
argument_list|>
name|buttonList
init|=
name|queryButtonList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buttonList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QAbstractButton
modifier|*
name|b
init|=
name|buttonList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|isCheckable
argument_list|()
condition|)
continue|continue;
name|b
operator|->
name|setFocusPolicy
argument_list|(
call|(
name|Qt
operator|::
name|FocusPolicy
call|)
argument_list|(
operator|(
name|b
operator|==
name|q
operator|||
operator|!
name|q
operator|->
name|isCheckable
argument_list|()
operator|)
condition|?
operator|(
name|b
operator|->
name|focusPolicy
argument_list|()
operator||
name|Qt
operator|::
name|TabFocus
operator|)
else|:
operator|(
name|b
operator|->
name|focusPolicy
argument_list|()
operator|&
operator|~
name|Qt
operator|::
name|TabFocus
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|init
name|void
name|QAbstractButtonPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|q
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|FocusPolicy
argument_list|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Button_FocusPolicy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Minimum
argument_list|,
name|QSizePolicy
operator|::
name|Fixed
argument_list|,
name|controlType
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_OwnSizePolicy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|q
operator|->
name|setForegroundRole
argument_list|(
name|QPalette
operator|::
name|ButtonText
argument_list|)
expr_stmt|;
name|q
operator|->
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Button
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|refresh
name|void
name|QAbstractButtonPrivate
operator|::
name|refresh
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockRefresh
condition|)
return|return;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|click
name|void
name|QAbstractButtonPrivate
operator|::
name|click
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|down
operator|=
literal|false
expr_stmt|;
name|blockRefresh
operator|=
literal|true
expr_stmt|;
name|bool
name|changeState
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|checked
operator|&&
name|queryCheckedButton
argument_list|()
operator|==
name|q
condition|)
block|{
comment|// the checked button of an exclusive or autoexclusive group cannot be unchecked
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|group
condition|?
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|exclusive
else|:
name|autoExclusive
condition|)
else|#
directive|else
if|if
condition|(
name|autoExclusive
condition|)
endif|#
directive|endif
name|changeState
operator|=
literal|false
expr_stmt|;
block|}
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|changeState
condition|)
block|{
name|q
operator|->
name|nextCheckState
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|guard
condition|)
return|return;
block|}
name|blockRefresh
operator|=
literal|false
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|q
operator|->
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|emitReleased
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|emitClicked
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitClicked
name|void
name|QAbstractButtonPrivate
operator|::
name|emitClicked
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|q
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|clicked
argument_list|(
name|checked
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
block|{
emit|emit
name|group
operator|->
name|buttonClicked
argument_list|(
name|group
operator|->
name|id
argument_list|(
name|q
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
emit|emit
name|group
operator|->
name|buttonClicked
argument_list|(
name|q
argument_list|)
emit|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|emitPressed
name|void
name|QAbstractButtonPrivate
operator|::
name|emitPressed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|q
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|pressed
argument_list|()
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
block|{
emit|emit
name|group
operator|->
name|buttonPressed
argument_list|(
name|group
operator|->
name|id
argument_list|(
name|q
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
emit|emit
name|group
operator|->
name|buttonPressed
argument_list|(
name|q
argument_list|)
emit|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|emitReleased
name|void
name|QAbstractButtonPrivate
operator|::
name|emitReleased
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|q
argument_list|)
decl_stmt|;
emit|emit
name|q
operator|->
name|released
argument_list|()
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
block|{
emit|emit
name|group
operator|->
name|buttonReleased
argument_list|(
name|group
operator|->
name|id
argument_list|(
name|q
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|guard
operator|&&
name|group
condition|)
emit|emit
name|group
operator|->
name|buttonReleased
argument_list|(
name|q
argument_list|)
emit|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Constructs an abstract button with a \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractButton
name|QAbstractButton
operator|::
name|QAbstractButton
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QAbstractButtonPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the button.  */
end_comment
begin_destructor
DECL|function|~QAbstractButton
name|QAbstractButton
operator|::
name|~
name|QAbstractButton
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|removeButton
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QAbstractButton
name|QAbstractButton
operator|::
name|QAbstractButton
parameter_list|(
name|QAbstractButtonPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \property QAbstractButton::text \brief the text shown on the button  If the button has no text, the text() function will return an empty string.  If the text contains an ampersand character ('&'), a shortcut is automatically created for it. The character that follows the '&' will be used as the shortcut key. Any previous shortcut will be overwritten or cleared if no shortcut is defined by the text. See the \l {QShortcut#mnemonic}{QShortcut} documentation for details. To display an actual ampersand, use '&&'.  There is no default text. */
end_comment
begin_function
DECL|function|setText
name|void
name|QAbstractButton
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|==
name|text
condition|)
return|return;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
name|QKeySequence
name|newMnemonic
init|=
name|QKeySequence
operator|::
name|mnemonic
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|setShortcut
argument_list|(
name|newMnemonic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|sizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|NameChanged
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|text
name|QString
name|QAbstractButton
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!   \property QAbstractButton::icon   \brief the icon shown on the button    The icon's default size is defined by the GUI style, but can be   adjusted by setting the \l iconSize property. */
end_comment
begin_function
DECL|function|setIcon
name|void
name|QAbstractButton
operator|::
name|setIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|icon
operator|=
name|icon
expr_stmt|;
name|d
operator|->
name|sizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|icon
name|QIcon
name|QAbstractButton
operator|::
name|icon
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|icon
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_comment
comment|/*! \property QAbstractButton::shortcut \brief the mnemonic associated with the button */
end_comment
begin_function
DECL|function|setShortcut
name|void
name|QAbstractButton
operator|::
name|setShortcut
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcutId
operator|!=
literal|0
condition|)
name|releaseShortcut
argument_list|(
name|d
operator|->
name|shortcutId
argument_list|)
expr_stmt|;
name|d
operator|->
name|shortcut
operator|=
name|key
expr_stmt|;
name|d
operator|->
name|shortcutId
operator|=
name|grabShortcut
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|shortcut
name|QKeySequence
name|QAbstractButton
operator|::
name|shortcut
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|shortcut
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SHORTCUT
end_comment
begin_comment
comment|/*! \property QAbstractButton::checkable \brief whether the button is checkable  By default, the button is not checkable.  \sa checked */
end_comment
begin_function
DECL|function|setCheckable
name|void
name|QAbstractButton
operator|::
name|setCheckable
parameter_list|(
name|bool
name|checkable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|checkable
operator|==
name|checkable
condition|)
return|return;
name|d
operator|->
name|checkable
operator|=
name|checkable
expr_stmt|;
name|d
operator|->
name|checked
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isCheckable
name|bool
name|QAbstractButton
operator|::
name|isCheckable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|checkable
return|;
block|}
end_function
begin_comment
comment|/*! \property QAbstractButton::checked \brief whether the button is checked  Only checkable buttons can be checked. By default, the button is unchecked.  \sa checkable */
end_comment
begin_function
DECL|function|setChecked
name|void
name|QAbstractButton
operator|::
name|setChecked
parameter_list|(
name|bool
name|checked
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|checkable
operator|||
name|d
operator|->
name|checked
operator|==
name|checked
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|blockRefresh
condition|)
name|checkStateSet
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|checked
operator|&&
name|d
operator|->
name|queryCheckedButton
argument_list|()
operator|==
name|this
condition|)
block|{
comment|// the checked button of an exclusive or autoexclusive group cannot be  unchecked
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
if|if
condition|(
name|d
operator|->
name|group
condition|?
name|d
operator|->
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|exclusive
else|:
name|d
operator|->
name|autoExclusive
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|group
condition|)
name|d
operator|->
name|group
operator|->
name|d_func
argument_list|()
operator|->
name|detectCheckedButton
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|autoExclusive
condition|)
return|return;
endif|#
directive|endif
block|}
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|d
operator|->
name|checked
operator|=
name|checked
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|blockRefresh
condition|)
name|checkStateSet
argument_list|()
expr_stmt|;
name|d
operator|->
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
operator|&&
name|checked
condition|)
name|d
operator|->
name|notifyChecked
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
emit|emit
name|toggled
argument_list|(
name|checked
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|QAccessible
operator|::
name|State
name|s
decl_stmt|;
name|s
operator|.
name|checked
operator|=
literal|true
expr_stmt|;
name|QAccessibleStateChangeEvent
name|event
argument_list|(
name|this
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|isChecked
name|bool
name|QAbstractButton
operator|::
name|isChecked
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|checked
return|;
block|}
end_function
begin_comment
comment|/*!   \property QAbstractButton::down   \brief whether the button is pressed down    If this property is true, the button is pressed down. The signals   pressed() and clicked() are not emitted if you set this property   to true. The default is false. */
end_comment
begin_function
DECL|function|setDown
name|void
name|QAbstractButton
operator|::
name|setDown
parameter_list|(
name|bool
name|down
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|down
operator|==
name|down
condition|)
return|return;
name|d
operator|->
name|down
operator|=
name|down
expr_stmt|;
name|d
operator|->
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoRepeat
operator|&&
name|d
operator|->
name|down
condition|)
name|d
operator|->
name|repeatTimer
operator|.
name|start
argument_list|(
name|d
operator|->
name|autoRepeatDelay
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|repeatTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isDown
name|bool
name|QAbstractButton
operator|::
name|isDown
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|down
return|;
block|}
end_function
begin_comment
comment|/*! \property QAbstractButton::autoRepeat \brief whether autoRepeat is enabled  If autoRepeat is enabled, then the pressed(), released(), and clicked() signals are emitted at regular intervals when the button is down. autoRepeat is off by default. The initial delay and the repetition interval are defined in milliseconds by \l autoRepeatDelay and \l autoRepeatInterval.  Note: If a button is pressed down by a shortcut key, then auto-repeat is enabled and timed by the system and not by this class. The pressed(), released(), and clicked() signals will be emitted like in the normal case. */
end_comment
begin_function
DECL|function|setAutoRepeat
name|void
name|QAbstractButton
operator|::
name|setAutoRepeat
parameter_list|(
name|bool
name|autoRepeat
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoRepeat
operator|==
name|autoRepeat
condition|)
return|return;
name|d
operator|->
name|autoRepeat
operator|=
name|autoRepeat
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoRepeat
operator|&&
name|d
operator|->
name|down
condition|)
name|d
operator|->
name|repeatTimer
operator|.
name|start
argument_list|(
name|d
operator|->
name|autoRepeatDelay
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|repeatTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoRepeat
name|bool
name|QAbstractButton
operator|::
name|autoRepeat
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoRepeat
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractButton::autoRepeatDelay     \brief the initial delay of auto-repetition     \since 4.2      If \l autoRepeat is enabled, then autoRepeatDelay defines the initial     delay in milliseconds before auto-repetition kicks in.      \sa autoRepeat, autoRepeatInterval */
end_comment
begin_function
DECL|function|setAutoRepeatDelay
name|void
name|QAbstractButton
operator|::
name|setAutoRepeatDelay
parameter_list|(
name|int
name|autoRepeatDelay
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoRepeatDelay
operator|=
name|autoRepeatDelay
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoRepeatDelay
name|int
name|QAbstractButton
operator|::
name|autoRepeatDelay
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoRepeatDelay
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractButton::autoRepeatInterval     \brief the interval of auto-repetition     \since 4.2      If \l autoRepeat is enabled, then autoRepeatInterval defines the     length of the auto-repetition interval in millisecons.      \sa autoRepeat, autoRepeatDelay */
end_comment
begin_function
DECL|function|setAutoRepeatInterval
name|void
name|QAbstractButton
operator|::
name|setAutoRepeatInterval
parameter_list|(
name|int
name|autoRepeatInterval
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoRepeatInterval
operator|=
name|autoRepeatInterval
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoRepeatInterval
name|int
name|QAbstractButton
operator|::
name|autoRepeatInterval
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoRepeatInterval
return|;
block|}
end_function
begin_comment
comment|/*! \property QAbstractButton::autoExclusive \brief whether auto-exclusivity is enabled  If auto-exclusivity is enabled, checkable buttons that belong to the same parent widget behave as if they were part of the same exclusive button group. In an exclusive button group, only one button can be checked at any time; checking another button automatically unchecks the previously checked one.  The property has no effect on buttons that belong to a button group.  autoExclusive is off by default, except for radio buttons.  \sa QRadioButton */
end_comment
begin_function
DECL|function|setAutoExclusive
name|void
name|QAbstractButton
operator|::
name|setAutoExclusive
parameter_list|(
name|bool
name|autoExclusive
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoExclusive
operator|=
name|autoExclusive
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoExclusive
name|bool
name|QAbstractButton
operator|::
name|autoExclusive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoExclusive
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
end_ifndef
begin_comment
comment|/*!   Returns the group that this button belongs to.    If the button is not a member of any QButtonGroup, this function   returns 0.    \sa QButtonGroup */
end_comment
begin_function
DECL|function|group
name|QButtonGroup
modifier|*
name|QAbstractButton
operator|::
name|group
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|group
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BUTTONGROUP
end_comment
begin_comment
comment|/*! Performs an animated click: the button is pressed immediately, and released \a msec milliseconds later (the default is 100 ms).  Calling this function again before the button is released resets the release timer.  All signals associated with a click are emitted as appropriate.  This function does nothing if the button is \l{setEnabled()}{disabled.}  \sa click() */
end_comment
begin_function
DECL|function|animateClick
name|void
name|QAbstractButton
operator|::
name|animateClick
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|checkable
operator|&&
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|ClickFocus
condition|)
name|setFocus
argument_list|()
expr_stmt|;
name|setDown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|animateTimer
operator|.
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
name|d
operator|->
name|animateTimer
operator|.
name|start
argument_list|(
name|msec
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Performs a click.  All the usual signals associated with a click are emitted as appropriate. If the button is checkable, the state of the button is toggled.  This function does nothing if the button is \l{setEnabled()}{disabled.}  \sa animateClick()  */
end_comment
begin_function
DECL|function|click
name|void
name|QAbstractButton
operator|::
name|click
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|d
operator|->
name|down
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
block|{
name|d
operator|->
name|down
operator|=
literal|false
expr_stmt|;
name|nextCheckState
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|d
operator|->
name|emitReleased
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|d
operator|->
name|emitClicked
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \fn void QAbstractButton::toggle()      Toggles the state of a checkable button.       \sa checked */
end_comment
begin_function
DECL|function|toggle
name|void
name|QAbstractButton
operator|::
name|toggle
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|setChecked
argument_list|(
operator|!
name|d
operator|->
name|checked
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! This virtual handler is called when setChecked() is used, unless it is called from within nextCheckState(). It allows subclasses to reset their intermediate button states.  \sa nextCheckState()  */
end_comment
begin_function
DECL|function|checkStateSet
name|void
name|QAbstractButton
operator|::
name|checkStateSet
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! This virtual handler is called when a button is clicked. The default implementation calls setChecked(!isChecked()) if the button isCheckable(). It allows subclasses to implement intermediate button states.  \sa checkStateSet() */
end_comment
begin_function
DECL|function|nextCheckState
name|void
name|QAbstractButton
operator|::
name|nextCheckState
parameter_list|()
block|{
if|if
condition|(
name|isCheckable
argument_list|()
condition|)
name|setChecked
argument_list|(
operator|!
name|isChecked
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Returns true if \a pos is inside the clickable button rectangle; otherwise returns false.  By default, the clickable area is the entire widget. Subclasses may reimplement this function to provide support for clickable areas of different shapes and sizes. */
end_comment
begin_function
DECL|function|hitButton
name|bool
name|QAbstractButton
operator|::
name|hitButton
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
return|return
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QAbstractButton
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
comment|// as opposed to other widgets, disabled buttons accept mouse
comment|// events. This avoids surprising click-through scenarios
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|TabletPress
case|:
case|case
name|QEvent
operator|::
name|TabletRelease
case|:
case|case
name|QEvent
operator|::
name|TabletMove
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
case|case
name|QEvent
operator|::
name|HoverMove
case|:
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
case|case
name|QEvent
operator|::
name|Wheel
case|:
endif|#
directive|endif
return|return
literal|true
return|;
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Shortcut
condition|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|QShortcutEvent
modifier|*
name|se
init|=
cast|static_cast
argument_list|<
name|QShortcutEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|shortcutId
operator|!=
name|se
operator|->
name|shortcutId
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|se
operator|->
name|isAmbiguous
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|animateTimer
operator|.
name|isActive
argument_list|()
condition|)
name|animateClick
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|setFocus
argument_list|(
name|Qt
operator|::
name|ShortcutFocusReason
argument_list|)
expr_stmt|;
name|window
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_KeyboardFocusChange
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
endif|#
directive|endif
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QAbstractButton
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|!=
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hitButton
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|setDown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|pressed
operator|=
literal|true
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QAbstractButton
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|d
operator|->
name|pressed
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|!=
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|down
condition|)
block|{
comment|// refresh is required by QMacStyle to resume the default button animation
name|d
operator|->
name|refresh
argument_list|()
expr_stmt|;
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hitButton
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|repeatTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|click
argument_list|()
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QAbstractButton
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
operator|||
operator|!
name|d
operator|->
name|pressed
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hitButton
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
operator|!=
name|d
operator|->
name|down
condition|)
block|{
name|setDown
argument_list|(
operator|!
name|d
operator|->
name|down
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|down
condition|)
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|emitReleased
argument_list|()
expr_stmt|;
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hitButton
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QAbstractButton
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
name|bool
name|next
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Select
case|:
case|case
name|Qt
operator|::
name|Key_Space
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|isAutoRepeat
argument_list|()
condition|)
block|{
name|setDown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Up
case|:
name|next
operator|=
literal|false
expr_stmt|;
comment|// fall through
case|case
name|Qt
operator|::
name|Key_Left
case|:
case|case
name|Qt
operator|::
name|Key_Right
case|:
case|case
name|Qt
operator|::
name|Key_Down
case|:
block|{
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Left
operator|||
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Right
operator|)
operator|)
operator|||
operator|(
operator|!
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadDirectional
operator|||
operator|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Up
operator|||
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Down
operator|)
operator|)
condition|)
block|{
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|QWidget
modifier|*
name|pw
init|=
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|autoExclusive
ifndef|#
directive|ifndef
name|QT_NO_BUTTONGROUP
operator|||
name|d
operator|->
name|group
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_ITEMVIEWS
operator|||
operator|(
name|pw
operator|&&
name|qobject_cast
argument_list|<
name|QAbstractItemView
operator|*
argument_list|>
argument_list|(
name|pw
operator|->
name|parentWidget
argument_list|()
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|// ### Using qobject_cast to check if the parent is a viewport of
comment|// QAbstractItemView is a crude hack, and should be revisited and
comment|// cleaned up when fixing task 194373. It's here to ensure that we
comment|// keep compatibility outside QAbstractItemView.
name|d
operator|->
name|moveFocus
argument_list|(
name|e
operator|->
name|key
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
comment|// nothing happend, propagate
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Prefer parent widget, use this if parent is absent
name|QWidget
modifier|*
name|w
init|=
name|pw
condition|?
name|pw
else|:
name|this
decl_stmt|;
name|bool
name|reverse
init|=
operator|(
name|w
operator|->
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|RightToLeft
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Left
operator|&&
operator|!
name|reverse
operator|)
operator|||
operator|(
name|e
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Right
operator|&&
name|reverse
operator|)
condition|)
block|{
name|next
operator|=
literal|false
expr_stmt|;
block|}
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Qt
operator|::
name|Key_Escape
case|:
if|if
condition|(
name|d
operator|->
name|down
condition|)
block|{
name|setDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|//flush paint event before invoking potentially expensive operation
name|QApplication
operator|::
name|flush
argument_list|()
expr_stmt|;
name|d
operator|->
name|emitReleased
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// fall through
default|default:
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QAbstractButton
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|isAutoRepeat
argument_list|()
condition|)
name|d
operator|->
name|repeatTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Select
case|:
case|case
name|Qt
operator|::
name|Key_Space
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|isAutoRepeat
argument_list|()
operator|&&
name|d
operator|->
name|down
condition|)
name|d
operator|->
name|click
argument_list|()
expr_stmt|;
break|break;
default|default:
name|e
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QAbstractButton
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|repeatTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|repeatTimer
operator|.
name|start
argument_list|(
name|d
operator|->
name|autoRepeatInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|down
condition|)
block|{
name|QPointer
argument_list|<
name|QAbstractButton
argument_list|>
name|guard
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|nextCheckState
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|d
operator|->
name|emitReleased
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|d
operator|->
name|emitClicked
argument_list|()
expr_stmt|;
if|if
condition|(
name|guard
condition|)
name|d
operator|->
name|emitPressed
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|animateTimer
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|animateTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|click
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QAbstractButton
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
operator|!
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
endif|#
directive|endif
name|d
operator|->
name|fixFocusPolicy
argument_list|()
expr_stmt|;
name|QWidget
operator|::
name|focusInEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QAbstractButton
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|reason
argument_list|()
operator|!=
name|Qt
operator|::
name|PopupFocusReason
condition|)
name|d
operator|->
name|down
operator|=
literal|false
expr_stmt|;
name|QWidget
operator|::
name|focusOutEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QAbstractButton
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|EnabledChange
case|:
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
name|setDown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|sizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
break|break;
block|}
name|QWidget
operator|::
name|changeEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAbstractButton::paintEvent(QPaintEvent *e)     \reimp */
end_comment
begin_comment
comment|/*!     \fn void QAbstractButton::pressed()      This signal is emitted when the button is pressed down.      \sa released(), clicked() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractButton::released()      This signal is emitted when the button is released.      \sa pressed(), clicked(), toggled() */
end_comment
begin_comment
comment|/*! \fn void QAbstractButton::clicked(bool checked)  This signal is emitted when the button is activated (i.e., pressed down then released while the mouse cursor is inside the button), when the shortcut key is typed, or when click() or animateClick() is called. Notably, this signal is \e not emitted if you call setDown(), setChecked() or toggle().  If the button is checkable, \a checked is true if the button is checked, or false if the button is unchecked.  \sa pressed(), released(), toggled() */
end_comment
begin_comment
comment|/*! \fn void QAbstractButton::toggled(bool checked)  This signal is emitted whenever a checkable button changes its state. \a checked is true if the button is checked, or false if the button is unchecked.  This may be the result of a user action, click() slot activation, or because setChecked() is called.  The states of buttons in exclusive button groups are updated before this signal is emitted. This means that slots can act on either the "off" signal or the "on" signal emitted by the buttons in the group whose states have changed.  For example, a slot that reacts to signals emitted by newly checked buttons but which ignores signals from buttons that have been unchecked can be implemented using the following pattern:  \snippet code/src_gui_widgets_qabstractbutton.cpp 2  Button groups can be created using the QButtonGroup class, and updates to the button states monitored with the \l{QButtonGroup::buttonClicked()} signal.  \sa checked, clicked() */
end_comment
begin_comment
comment|/*!     \property QAbstractButton::iconSize     \brief the icon size used for this button.      The default size is defined by the GUI style. This is a maximum     size for the icons. Smaller icons will not be scaled up. */
end_comment
begin_function
DECL|function|iconSize
name|QSize
name|QAbstractButton
operator|::
name|iconSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconSize
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|d
operator|->
name|iconSize
return|;
name|int
name|e
init|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ButtonIconSize
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|QSize
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setIconSize
name|void
name|QAbstractButton
operator|::
name|setIconSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractButton
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|iconSize
operator|==
name|size
condition|)
return|return;
name|d
operator|->
name|iconSize
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|sizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
