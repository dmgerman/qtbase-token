begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QT_EXPERIMENTAL_CLIENT_DECORATIONS
end_comment
begin_include
include|#
directive|include
file|"qmainwindow.h"
end_include
begin_include
include|#
directive|include
file|"qmainwindowlayout_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MAINWINDOW
end_ifndef
begin_include
include|#
directive|include
file|"qdockwidget.h"
end_include
begin_include
include|#
directive|include
file|"qtoolbar.h"
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qmenubar.h>
end_include
begin_include
include|#
directive|include
file|<qstatusbar.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|"qtoolbar_p.h"
end_include
begin_include
include|#
directive|include
file|"qwidgetanimator_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_cocoa_helpers_mac_p.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
specifier|extern
name|OSWindowRef
name|qt_mac_window_for
parameter_list|(
specifier|const
name|QWidget
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// qwidget_mac.cpp
end_comment
begin_expr_stmt
name|QT_END_NAMESPACE
endif|#
directive|endif
name|QT_BEGIN_NAMESPACE
DECL|class|QMainWindowPrivate
name|class
name|QMainWindowPrivate
operator|:
specifier|public
name|QWidgetPrivate
block|{
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QMainWindow
argument_list|)
specifier|public
operator|:
DECL|function|QMainWindowPrivate
specifier|inline
name|QMainWindowPrivate
argument_list|()
operator|:
name|layout
argument_list|(
literal|0
argument_list|)
block|,
name|explicitIconSize
argument_list|(
literal|false
argument_list|)
block|,
name|toolButtonStyle
argument_list|(
name|Qt
operator|::
name|ToolButtonIconOnly
argument_list|)
ifdef|#
directive|ifdef
name|Q_WS_MAC
block|,
name|useHIToolBar
argument_list|(
literal|false
argument_list|)
block|,
name|activateUnifiedToolbarAfterFullScreen
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DOCKWIDGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
block|,
name|hasOldCursor
argument_list|(
literal|false
argument_list|)
block|,
name|cursorAdjusted
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
block|{ }
DECL|member|layout
name|QMainWindowLayout
operator|*
name|layout
block|;
DECL|member|iconSize
name|QSize
name|iconSize
block|;
DECL|member|explicitIconSize
name|bool
name|explicitIconSize
block|;
DECL|member|toolButtonStyle
name|Qt
operator|::
name|ToolButtonStyle
name|toolButtonStyle
block|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
DECL|member|useHIToolBar
name|bool
name|useHIToolBar
block|;
DECL|member|activateUnifiedToolbarAfterFullScreen
name|bool
name|activateUnifiedToolbarAfterFullScreen
block|;
endif|#
directive|endif
name|void
name|init
argument_list|()
block|;
DECL|member|hoverSeparator
name|QList
argument_list|<
name|int
argument_list|>
name|hoverSeparator
block|;
DECL|member|hoverPos
name|QPoint
name|hoverPos
block|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DOCKWIDGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
name|QCursor
name|separatorCursor
argument_list|(
argument|const QList<int>&path
argument_list|)
specifier|const
block|;
name|void
name|adjustCursor
argument_list|(
specifier|const
name|QPoint
operator|&
name|pos
argument_list|)
block|;
DECL|member|oldCursor
name|QCursor
name|oldCursor
block|;
DECL|member|adjustedCursor
name|QCursor
name|adjustedCursor
block|;
name|uint
name|hasOldCursor
operator|:
literal|1
block|;
name|uint
name|cursorAdjusted
operator|:
literal|1
block|;
endif|#
directive|endif
DECL|function|mainWindowLayout
specifier|static
specifier|inline
name|QMainWindowLayout
operator|*
name|mainWindowLayout
argument_list|(
argument|const QMainWindow *mainWindow
argument_list|)
block|{
return|return
name|mainWindow
operator|?
name|mainWindow
operator|->
name|d_func
argument_list|()
operator|->
name|layout
operator|:
cast|static_cast
argument_list|<
name|QMainWindowLayout
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_expr_stmt
begin_function
unit|};
DECL|function|qt_mainwindow_layout
name|QMainWindowLayout
modifier|*
name|qt_mainwindow_layout
parameter_list|(
specifier|const
name|QMainWindow
modifier|*
name|mainWindow
parameter_list|)
block|{
return|return
name|QMainWindowPrivate
operator|::
name|mainWindowLayout
argument_list|(
name|mainWindow
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_EXPERIMENTAL_CLIENT_DECORATIONS
end_ifdef
begin_function
DECL|function|qt_setMainWindowTitleWidget
name|Q_WIDGETS_EXPORT
name|void
name|qt_setMainWindowTitleWidget
parameter_list|(
name|QMainWindow
modifier|*
name|mainWindow
parameter_list|,
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QGridLayout
modifier|*
name|topLayout
init|=
name|qobject_cast
argument_list|<
name|QGridLayout
operator|*
argument_list|>
argument_list|(
name|mainWindow
operator|->
name|layout
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|topLayout
argument_list|)
expr_stmt|;
name|int
name|row
init|=
literal|0
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|Qt
operator|::
name|LeftDockWidgetArea
case|:
name|row
operator|=
literal|1
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TopDockWidgetArea
case|:
name|row
operator|=
literal|0
expr_stmt|;
name|column
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|BottomDockWidgetArea
case|:
name|row
operator|=
literal|2
expr_stmt|;
name|column
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RightDockWidgetArea
case|:
name|row
operator|=
literal|1
expr_stmt|;
name|column
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"qt_setMainWindowTitleWidget"
argument_list|,
literal|"Unknown area"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QLayoutItem
modifier|*
name|oldItem
init|=
name|topLayout
operator|->
name|itemAtPosition
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
condition|)
operator|delete
name|oldItem
operator|->
name|widget
argument_list|()
expr_stmt|;
name|topLayout
operator|->
name|addWidget
argument_list|(
name|widget
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|init
name|void
name|QMainWindowPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_EXPERIMENTAL_CLIENT_DECORATIONS
name|QGridLayout
modifier|*
name|topLayout
init|=
operator|new
name|QGridLayout
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|topLayout
operator|->
name|setContentsMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|layout
operator|=
operator|new
name|QMainWindowLayout
argument_list|(
name|q
argument_list|,
name|topLayout
argument_list|)
expr_stmt|;
name|topLayout
operator|->
name|addItem
argument_list|(
name|layout
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|layout
operator|=
operator|new
name|QMainWindowLayout
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|int
name|metric
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ToolBarIconSize
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|iconSize
operator|=
name|QSize
argument_list|(
name|metric
argument_list|,
name|metric
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     The Main Window:      +----------------------------------------------------------+     | Menu Bar                                                 |     +----------------------------------------------------------+     | Tool Bar Area                                            |     |   +--------------------------------------------------+   |     |   | Dock Window Area                                 |   |     |   |   +------------------------------------------+   |   |     |   |   |                                          |   |   |     |   |   | Central Widget                           |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   |                                          |   |   |     |   |   +------------------------------------------+   |   |     |   |                                                  |   |     |   +--------------------------------------------------+   |     |                                                          |     +----------------------------------------------------------+     | Status Bar                                               |     +----------------------------------------------------------+  */
end_comment
begin_comment
comment|/*!     \class QMainWindow     \brief The QMainWindow class provides a main application            window.     \ingroup mainwindow-classes     \inmodule QtWidgets      \tableofcontents      \section1 Qt Main Window Framework      A main window provides a framework for building an     application's user interface. Qt has QMainWindow and its \l{Main     Window and Related Classes}{related classes} for main window     management. QMainWindow has its own layout to which you can add     \l{QToolBar}s, \l{QDockWidget}s, a     QMenuBar, and a QStatusBar. The layout has a center area that can     be occupied by any kind of widget. You can see an image of the     layout below.      \image mainwindowlayout.png      \note Creating a main window without a central widget is not supported.     You must have a central widget even if it is just a placeholder.      \section1 Creating Main Window Components      A central widget will typically be a standard Qt widget such     as a QTextEdit or a QGraphicsView. Custom widgets can also be     used for advanced applications. You set the central widget with \c     setCentralWidget().      Main windows have either a single (SDI) or multiple (MDI)     document interface. You create MDI applications in Qt by using a     QMdiArea as the central widget.      We will now examine each of the other widgets that can be     added to a main window. We give examples on how to create and add     them.      \section2 Creating Menus      Qt implements menus in QMenu and QMainWindow keeps them in a     QMenuBar. \l{QAction}{QAction}s are added to the menus, which     display them as menu items.      You can add new menus to the main window's menu bar by calling     \c menuBar(), which returns the QMenuBar for the window, and then     add a menu with QMenuBar::addMenu().      QMainWindow comes with a default menu bar, but you can also     set one yourself with \c setMenuBar(). If you wish to implement a     custom menu bar (i.e., not use the QMenuBar widget), you can set it     with \c setMenuWidget().      An example of how to create menus follows:      \snippet mainwindows/application/mainwindow.cpp 26      The \c createPopupMenu() function creates popup menus when the     main window receives context menu events.  The default     implementation generates a menu with the checkable actions from     the dock widgets and toolbars. You can reimplement \c     createPopupMenu() for a custom menu.      \section2 Creating Toolbars      Toolbars are implemented in the QToolBar class.  You add a     toolbar to a main window with \c addToolBar().      You control the initial position of toolbars by assigning them     to a specific Qt::ToolBarArea. You can split an area by inserting     a toolbar break - think of this as a line break in text editing -     with \c addToolBarBreak() or \c insertToolBarBreak(). You can also     restrict placement by the user with QToolBar::setAllowedAreas()     and QToolBar::setMovable().      The size of toolbar icons can be retrieved with \c iconSize().     The sizes are platform dependent; you can set a fixed size with \c     setIconSize(). You can alter the appearance of all tool buttons in     the toolbars with \c setToolButtonStyle().      An example of toolbar creation follows:      \snippet mainwindows/application/mainwindow.cpp 29      \section2 Creating Dock Widgets      Dock widgets are implemented in the QDockWidget class. A dock     widget is a window that can be docked into the main window.  You     add dock widgets to a main window with \c addDockWidget().      There are four dock widget areas as given by the     Qt::DockWidgetArea enum: left, right, top, and bottom. You can     specify which dock widget area that should occupy the corners     where the areas overlap with \c setCorner(). By default     each area can only contain one row (vertical or horizontal) of     dock widgets, but if you enable nesting with \c     setDockNestingEnabled(), dock widgets can be added in either     direction.      Two dock widgets may also be stacked on top of each other. A     QTabBar is then used to select which of the widgets that should be     displayed.      We give an example of how to create and add dock widgets to a     main window:      \snippet mainwindowsnippet.cpp 0      \section2 The Status Bar      You can set a status bar with \c setStatusBar(), but one is     created the first time \c statusBar() (which returns the main     window's status bar) is called. See QStatusBar for information on     how to use it.      \section1 Storing State      QMainWindow can store the state of its layout with \c     saveState(); it can later be retrieved with \c restoreState(). It     is the position and size (relative to the size of the main window)     of the toolbars and dock widgets that are stored.      \sa QMenuBar, QToolBar, QStatusBar, QDockWidget, {Application     Example}, {Dock Widgets Example}, {MDI Example}, {SDI Example},     {Menus Example} */
end_comment
begin_comment
comment|/*!     \fn void QMainWindow::iconSizeChanged(const QSize&iconSize)      This signal is emitted when the size of the icons used in the     window is changed. The new icon size is passed in \a iconSize.      You can connect this signal to other components to help maintain     a consistent appearance for your application.      \sa setIconSize() */
end_comment
begin_comment
comment|/*!     \fn void QMainWindow::toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle)      This signal is emitted when the style used for tool buttons in the     window is changed. The new style is passed in \a toolButtonStyle.      You can connect this signal to other components to help maintain     a consistent appearance for your application.      \sa setToolButtonStyle() */
end_comment
begin_comment
comment|/*!     Constructs a QMainWindow with the given \a parent and the specified     widget \a flags.      QMainWindow sets the Qt::Window flag itself, and will hence     always be created as a top-level widget.  */
end_comment
begin_constructor
DECL|function|QMainWindow
name|QMainWindow
operator|::
name|QMainWindow
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|flags
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|(
operator|new
name|QMainWindowPrivate
argument_list|()
operator|)
argument_list|,
name|parent
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|Window
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the main window.  */
end_comment
begin_destructor
DECL|function|~QMainWindow
name|QMainWindow
operator|::
name|~
name|QMainWindow
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \property QMainWindow::iconSize     \brief size of toolbar icons in this mainwindow.      The default is the default tool bar icon size of the GUI style.     Note that the icons used must be at least of this size as the     icons are only scaled down. */
end_comment
begin_comment
comment|/*!     \property QMainWindow::dockOptions     \brief the docking behavior of QMainWindow     \since 4.3      The default value is AnimatedDocks | AllowTabbedDocks. */
end_comment
begin_comment
comment|/*!     \enum QMainWindow::DockOption     \since 4.3      This enum contains flags that specify the docking behavior of QMainWindow.      \value AnimatedDocks    Identical to the \l animated property.      \value AllowNestedDocks Identical to the \l dockNestingEnabled property.      \value AllowTabbedDocks The user can drop one dock widget "on top" of                             another. The two widgets are stacked and a tab                             bar appears for selecting which one is visible.      \value ForceTabbedDocks Each dock area contains a single stack of tabbed                             dock widgets. In other words, dock widgets cannot                             be placed next to each other in a dock area. If                             this option is set, AllowNestedDocks has no effect.      \value VerticalTabs     The two vertical dock areas on the sides of the                             main window show their tabs vertically. If this                             option is not set, all dock areas show their tabs                             at the bottom. Implies AllowTabbedDocks. See also                             \l setTabPosition().      These options only control how dock widgets may be dropped in a QMainWindow.     They do not re-arrange the dock widgets to conform with the specified     options. For this reason they should be set before any dock widgets     are added to the main window. Exceptions to this are the AnimatedDocks and     VerticalTabs options, which may be set at any time. */
end_comment
begin_function
DECL|function|setDockOptions
name|void
name|QMainWindow
operator|::
name|setDockOptions
parameter_list|(
name|DockOptions
name|opt
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|setDockOptions
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dockOptions
name|QMainWindow
operator|::
name|DockOptions
name|QMainWindow
operator|::
name|dockOptions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMainWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layout
operator|->
name|dockOptions
return|;
block|}
end_function
begin_function
DECL|function|iconSize
name|QSize
name|QMainWindow
operator|::
name|iconSize
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|iconSize
return|;
block|}
end_function
begin_function
DECL|function|setIconSize
name|void
name|QMainWindow
operator|::
name|setIconSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|iconSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|QSize
name|sz
init|=
name|iconSize
decl_stmt|;
if|if
condition|(
operator|!
name|sz
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|int
name|metric
init|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ToolBarIconSize
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|sz
operator|=
name|QSize
argument_list|(
name|metric
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|iconSize
operator|!=
name|sz
condition|)
block|{
name|d
operator|->
name|iconSize
operator|=
name|sz
expr_stmt|;
emit|emit
name|iconSizeChanged
argument_list|(
name|d
operator|->
name|iconSize
argument_list|)
emit|;
block|}
name|d
operator|->
name|explicitIconSize
operator|=
name|iconSize
operator|.
name|isValid
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \property QMainWindow::toolButtonStyle     \brief style of toolbar buttons in this mainwindow.      The default is Qt::ToolButtonIconOnly. */
end_comment
begin_function
DECL|function|toolButtonStyle
name|Qt
operator|::
name|ToolButtonStyle
name|QMainWindow
operator|::
name|toolButtonStyle
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|toolButtonStyle
return|;
block|}
end_function
begin_function
DECL|function|setToolButtonStyle
name|void
name|QMainWindow
operator|::
name|setToolButtonStyle
parameter_list|(
name|Qt
operator|::
name|ToolButtonStyle
name|toolButtonStyle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|toolButtonStyle
operator|==
name|toolButtonStyle
condition|)
return|return;
name|d
operator|->
name|toolButtonStyle
operator|=
name|toolButtonStyle
expr_stmt|;
emit|emit
name|toolButtonStyleChanged
argument_list|(
name|d
operator|->
name|toolButtonStyle
argument_list|)
emit|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
end_ifndef
begin_comment
comment|/*!     Returns the menu bar for the main window. This function creates     and returns an empty menu bar if the menu bar does not exist.      If you want all windows in a Mac application to share one menu     bar, don't use this function to create it, because the menu bar     created here will have this QMainWindow as its parent.  Instead,     you must create a menu bar that does not have a parent, which you     can then share among all the Mac windows. Create a parent-less     menu bar this way:      \snippet code/src_gui_widgets_qmenubar.cpp 1      \sa setMenuBar() */
end_comment
begin_function
DECL|function|menuBar
name|QMenuBar
modifier|*
name|QMainWindow
operator|::
name|menuBar
parameter_list|()
specifier|const
block|{
name|QMenuBar
modifier|*
name|menuBar
init|=
name|qobject_cast
argument_list|<
name|QMenuBar
operator|*
argument_list|>
argument_list|(
name|layout
argument_list|()
operator|->
name|menuBar
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|menuBar
condition|)
block|{
name|QMainWindow
modifier|*
name|self
init|=
cast|const_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|menuBar
operator|=
operator|new
name|QMenuBar
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|self
operator|->
name|setMenuBar
argument_list|(
name|menuBar
argument_list|)
expr_stmt|;
block|}
return|return
name|menuBar
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the menu bar for the main window to \a menuBar.      Note: QMainWindow takes ownership of the \a menuBar pointer and     deletes it at the appropriate time.      \sa menuBar() */
end_comment
begin_function
DECL|function|setMenuBar
name|void
name|QMainWindow
operator|::
name|setMenuBar
parameter_list|(
name|QMenuBar
modifier|*
name|menuBar
parameter_list|)
block|{
name|QLayout
modifier|*
name|topLayout
init|=
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
name|topLayout
operator|->
name|menuBar
argument_list|()
operator|&&
name|topLayout
operator|->
name|menuBar
argument_list|()
operator|!=
name|menuBar
condition|)
block|{
comment|// Reparent corner widgets before we delete the old menu bar.
name|QMenuBar
modifier|*
name|oldMenuBar
init|=
name|qobject_cast
argument_list|<
name|QMenuBar
operator|*
argument_list|>
argument_list|(
name|topLayout
operator|->
name|menuBar
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|menuBar
condition|)
block|{
comment|// TopLeftCorner widget.
name|QWidget
modifier|*
name|cornerWidget
init|=
name|oldMenuBar
operator|->
name|cornerWidget
argument_list|(
name|Qt
operator|::
name|TopLeftCorner
argument_list|)
decl_stmt|;
if|if
condition|(
name|cornerWidget
condition|)
name|menuBar
operator|->
name|setCornerWidget
argument_list|(
name|cornerWidget
argument_list|,
name|Qt
operator|::
name|TopLeftCorner
argument_list|)
expr_stmt|;
comment|// TopRightCorner widget.
name|cornerWidget
operator|=
name|oldMenuBar
operator|->
name|cornerWidget
argument_list|(
name|Qt
operator|::
name|TopRightCorner
argument_list|)
expr_stmt|;
if|if
condition|(
name|cornerWidget
condition|)
name|menuBar
operator|->
name|setCornerWidget
argument_list|(
name|cornerWidget
argument_list|,
name|Qt
operator|::
name|TopRightCorner
argument_list|)
expr_stmt|;
block|}
name|oldMenuBar
operator|->
name|hide
argument_list|()
expr_stmt|;
name|oldMenuBar
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|topLayout
operator|->
name|setMenuBar
argument_list|(
name|menuBar
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the menu bar for the main window. This function returns     null if a menu bar hasn't been constructed yet. */
end_comment
begin_function
DECL|function|menuWidget
name|QWidget
modifier|*
name|QMainWindow
operator|::
name|menuWidget
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|menuBar
init|=
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|menuBar
argument_list|()
decl_stmt|;
return|return
name|menuBar
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the menu bar for the main window to \a menuBar.      QMainWindow takes ownership of the \a menuBar pointer and     deletes it at the appropriate time. */
end_comment
begin_function
DECL|function|setMenuWidget
name|void
name|QMainWindow
operator|::
name|setMenuWidget
parameter_list|(
name|QWidget
modifier|*
name|menuBar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|menuBar
argument_list|()
operator|&&
name|d
operator|->
name|layout
operator|->
name|menuBar
argument_list|()
operator|!=
name|menuBar
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|menuBar
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|menuBar
argument_list|()
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|layout
operator|->
name|setMenuBar
argument_list|(
name|menuBar
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MENUBAR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STATUSBAR
end_ifndef
begin_comment
comment|/*!     Returns the status bar for the main window. This function creates     and returns an empty status bar if the status bar does not exist.      \sa setStatusBar() */
end_comment
begin_function
DECL|function|statusBar
name|QStatusBar
modifier|*
name|QMainWindow
operator|::
name|statusBar
parameter_list|()
specifier|const
block|{
name|QStatusBar
modifier|*
name|statusbar
init|=
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|statusbar
condition|)
block|{
name|QMainWindow
modifier|*
name|self
init|=
cast|const_cast
argument_list|<
name|QMainWindow
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|statusbar
operator|=
operator|new
name|QStatusBar
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|statusbar
operator|->
name|setSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Ignored
argument_list|,
name|QSizePolicy
operator|::
name|Fixed
argument_list|)
expr_stmt|;
name|self
operator|->
name|setStatusBar
argument_list|(
name|statusbar
argument_list|)
expr_stmt|;
block|}
return|return
name|statusbar
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the status bar for the main window to \a statusbar.      Setting the status bar to 0 will remove it from the main window.     Note that QMainWindow takes ownership of the \a statusbar pointer     and deletes it at the appropriate time.      \sa statusBar() */
end_comment
begin_function
DECL|function|setStatusBar
name|void
name|QMainWindow
operator|::
name|setStatusBar
parameter_list|(
name|QStatusBar
modifier|*
name|statusbar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
operator|&&
name|d
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
operator|!=
name|statusbar
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|layout
operator|->
name|setStatusBar
argument_list|(
name|statusbar
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_STATUSBAR
end_comment
begin_comment
comment|/*!     Returns the central widget for the main window. This function     returns zero if the central widget has not been set.      \sa setCentralWidget() */
end_comment
begin_function
DECL|function|centralWidget
name|QWidget
modifier|*
name|QMainWindow
operator|::
name|centralWidget
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|centralWidget
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the given \a widget to be the main window's central widget.      Note: QMainWindow takes ownership of the \a widget pointer and     deletes it at the appropriate time.      \sa centralWidget() */
end_comment
begin_function
DECL|function|setCentralWidget
name|void
name|QMainWindow
operator|::
name|setCentralWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|centralWidget
argument_list|()
operator|&&
name|d
operator|->
name|layout
operator|->
name|centralWidget
argument_list|()
operator|!=
name|widget
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|centralWidget
argument_list|()
operator|->
name|hide
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|centralWidget
argument_list|()
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|layout
operator|->
name|setCentralWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
end_ifndef
begin_comment
comment|/*!     Sets the given dock widget \a area to occupy the specified \a     corner.      \sa corner() */
end_comment
begin_function
DECL|function|setCorner
name|void
name|QMainWindow
operator|::
name|setCorner
parameter_list|(
name|Qt
operator|::
name|Corner
name|corner
parameter_list|,
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|)
block|{
name|bool
name|valid
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|corner
condition|)
block|{
case|case
name|Qt
operator|::
name|TopLeftCorner
case|:
name|valid
operator|=
operator|(
name|area
operator|==
name|Qt
operator|::
name|TopDockWidgetArea
operator|||
name|area
operator|==
name|Qt
operator|::
name|LeftDockWidgetArea
operator|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TopRightCorner
case|:
name|valid
operator|=
operator|(
name|area
operator|==
name|Qt
operator|::
name|TopDockWidgetArea
operator|||
name|area
operator|==
name|Qt
operator|::
name|RightDockWidgetArea
operator|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|BottomLeftCorner
case|:
name|valid
operator|=
operator|(
name|area
operator|==
name|Qt
operator|::
name|BottomDockWidgetArea
operator|||
name|area
operator|==
name|Qt
operator|::
name|LeftDockWidgetArea
operator|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|BottomRightCorner
case|:
name|valid
operator|=
operator|(
name|area
operator|==
name|Qt
operator|::
name|BottomDockWidgetArea
operator|||
name|area
operator|==
name|Qt
operator|::
name|RightDockWidgetArea
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|valid
condition|)
name|qWarning
argument_list|(
literal|"QMainWindow::setCorner(): 'area' is not valid for 'corner'"
argument_list|)
expr_stmt|;
else|else
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|setCorner
argument_list|(
name|corner
argument_list|,
name|area
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the dock widget area that occupies the specified \a     corner.      \sa setCorner() */
end_comment
begin_function
DECL|function|corner
name|Qt
operator|::
name|DockWidgetArea
name|QMainWindow
operator|::
name|corner
parameter_list|(
name|Qt
operator|::
name|Corner
name|corner
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|corner
argument_list|(
name|corner
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
end_ifndef
begin_function
DECL|function|checkToolBarArea
specifier|static
name|bool
name|checkToolBarArea
parameter_list|(
name|Qt
operator|::
name|ToolBarArea
name|area
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|Qt
operator|::
name|LeftToolBarArea
case|:
case|case
name|Qt
operator|::
name|RightToolBarArea
case|:
case|case
name|Qt
operator|::
name|TopToolBarArea
case|:
case|case
name|Qt
operator|::
name|BottomToolBarArea
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"%s: invalid 'area' argument"
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Adds a toolbar break to the given \a area after all the other     objects that are present. */
end_comment
begin_function
DECL|function|addToolBarBreak
name|void
name|QMainWindow
operator|::
name|addToolBarBreak
parameter_list|(
name|Qt
operator|::
name|ToolBarArea
name|area
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkToolBarArea
argument_list|(
name|area
argument_list|,
literal|"QMainWindow::addToolBarBreak"
argument_list|)
condition|)
return|return;
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|addToolBarBreak
argument_list|(
name|area
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts a toolbar break before the toolbar specified by \a before. */
end_comment
begin_function
DECL|function|insertToolBarBreak
name|void
name|QMainWindow
operator|::
name|insertToolBarBreak
parameter_list|(
name|QToolBar
modifier|*
name|before
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|insertToolBarBreak
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes a toolbar break previously inserted before the toolbar specified by \a before. */
end_comment
begin_function
DECL|function|removeToolBarBreak
name|void
name|QMainWindow
operator|::
name|removeToolBarBreak
parameter_list|(
name|QToolBar
modifier|*
name|before
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|removeToolBarBreak
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the \a toolbar into the specified \a area in this main     window. The \a toolbar is placed at the end of the current tool     bar block (i.e. line). If the main window already manages \a toolbar     then it will only move the toolbar to \a area.      \sa insertToolBar(), addToolBarBreak(), insertToolBarBreak() */
end_comment
begin_function
DECL|function|addToolBar
name|void
name|QMainWindow
operator|::
name|addToolBar
parameter_list|(
name|Qt
operator|::
name|ToolBarArea
name|area
parameter_list|,
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkToolBarArea
argument_list|(
name|area
argument_list|,
literal|"QMainWindow::addToolBar"
argument_list|)
condition|)
return|return;
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|iconSizeChanged
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateIconSize
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|toolButtonStyleChanged
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateToolButtonStyle
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|&&
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|->
name|dragging
condition|)
block|{
comment|//removing a toolbar which is dragging will cause crash
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
name|bool
name|animated
init|=
name|isAnimated
argument_list|()
decl_stmt|;
name|setAnimated
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|endDrag
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
name|setAnimated
argument_list|(
name|animated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|layout
operator|->
name|usesHIToolBar
argument_list|(
name|toolbar
argument_list|)
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|removeWidget
argument_list|(
name|toolbar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|layout
operator|->
name|removeToolBar
argument_list|(
name|toolbar
argument_list|)
expr_stmt|;
block|}
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|_q_updateIconSize
argument_list|(
name|d
operator|->
name|iconSize
argument_list|)
expr_stmt|;
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|_q_updateToolButtonStyle
argument_list|(
name|d
operator|->
name|toolButtonStyle
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|iconSizeChanged
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateIconSize
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|toolButtonStyleChanged
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateToolButtonStyle
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|addToolBar
argument_list|(
name|area
argument_list|,
name|toolbar
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \overload     Equivalent of calling addToolBar(Qt::TopToolBarArea, \a toolbar) */
end_comment
begin_function
DECL|function|addToolBar
name|void
name|QMainWindow
operator|::
name|addToolBar
parameter_list|(
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
block|{
name|addToolBar
argument_list|(
name|Qt
operator|::
name|TopToolBarArea
argument_list|,
name|toolbar
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates a QToolBar object, setting its window title to \a title,     and inserts it into the top toolbar area.      \sa setWindowTitle() */
end_comment
begin_function
DECL|function|addToolBar
name|QToolBar
modifier|*
name|QMainWindow
operator|::
name|addToolBar
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|QToolBar
modifier|*
name|toolBar
init|=
operator|new
name|QToolBar
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|toolBar
operator|->
name|setWindowTitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|addToolBar
argument_list|(
name|toolBar
argument_list|)
expr_stmt|;
return|return
name|toolBar
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the \a toolbar into the area occupied by the \a before toolbar     so that it appears before it. For example, in normal left-to-right     layout operation, this means that \a toolbar will appear to the left     of the toolbar specified by \a before in a horizontal toolbar area.      \sa insertToolBarBreak(), addToolBar(), addToolBarBreak() */
end_comment
begin_function
DECL|function|insertToolBar
name|void
name|QMainWindow
operator|::
name|insertToolBar
parameter_list|(
name|QToolBar
modifier|*
name|before
parameter_list|,
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|removeToolBar
argument_list|(
name|toolbar
argument_list|)
expr_stmt|;
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|_q_updateIconSize
argument_list|(
name|d
operator|->
name|iconSize
argument_list|)
expr_stmt|;
name|toolbar
operator|->
name|d_func
argument_list|()
operator|->
name|_q_updateToolButtonStyle
argument_list|(
name|d
operator|->
name|toolButtonStyle
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|iconSizeChanged
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateIconSize
argument_list|(
name|QSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|toolButtonStyleChanged
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|,
name|toolbar
argument_list|,
name|SLOT
argument_list|(
name|_q_updateToolButtonStyle
argument_list|(
name|Qt
operator|::
name|ToolButtonStyle
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|insertToolBar
argument_list|(
name|before
argument_list|,
name|toolbar
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the \a toolbar from the main window layout and hides     it. Note that the \a toolbar is \e not deleted. */
end_comment
begin_function
DECL|function|removeToolBar
name|void
name|QMainWindow
operator|::
name|removeToolBar
parameter_list|(
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
block|{
if|if
condition|(
name|toolbar
condition|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|removeToolBar
argument_list|(
name|toolbar
argument_list|)
expr_stmt|;
name|toolbar
operator|->
name|hide
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the Qt::ToolBarArea for \a toolbar. If \a toolbar has not     been added to the main window, this function returns \c     Qt::NoToolBarArea.      \sa addToolBar(), addToolBarBreak(), Qt::ToolBarArea */
end_comment
begin_function
DECL|function|toolBarArea
name|Qt
operator|::
name|ToolBarArea
name|QMainWindow
operator|::
name|toolBarArea
parameter_list|(
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|toolBarArea
argument_list|(
name|toolbar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      Returns whether there is a toolbar     break before the \a toolbar.      \sa addToolBarBreak(), insertToolBarBreak() */
end_comment
begin_function
DECL|function|toolBarBreak
name|bool
name|QMainWindow
operator|::
name|toolBarBreak
parameter_list|(
name|QToolBar
modifier|*
name|toolbar
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|toolBarBreak
argument_list|(
name|toolbar
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TOOLBAR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
end_ifndef
begin_comment
comment|/*! \property QMainWindow::animated     \brief whether manipulating dock widgets and tool bars is animated     \since 4.2      When a dock widget or tool bar is dragged over the     main window, the main window adjusts its contents     to indicate where the dock widget or tool bar will     be docked if it is dropped. Setting this property     causes QMainWindow to move its contents in a smooth     animation. Clearing this property causes the contents     to snap into their new positions.      By default, this property is set. It may be cleared if     the main window contains widgets which are slow at resizing     or repainting themselves.      Setting this property is identical to setting the AnimatedDocks     option using setDockOptions(). */
end_comment
begin_function
DECL|function|isAnimated
name|bool
name|QMainWindow
operator|::
name|isAnimated
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMainWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layout
operator|->
name|dockOptions
operator|&
name|AnimatedDocks
return|;
block|}
end_function
begin_function
DECL|function|setAnimated
name|void
name|QMainWindow
operator|::
name|setAnimated
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|DockOptions
name|opts
init|=
name|d
operator|->
name|layout
operator|->
name|dockOptions
decl_stmt|;
if|if
condition|(
name|enabled
condition|)
name|opts
operator||=
name|AnimatedDocks
expr_stmt|;
else|else
name|opts
operator|&=
operator|~
name|AnimatedDocks
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|setDockOptions
argument_list|(
name|opts
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \property QMainWindow::dockNestingEnabled     \brief whether docks can be nested     \since 4.2      If this property is false, dock areas can only contain a single row     (horizontal or vertical) of dock widgets. If this property is true,     the area occupied by a dock widget can be split in either direction to contain     more dock widgets.      Dock nesting is only necessary in applications that contain a lot of     dock widgets. It gives the user greater freedom in organizing their     main window. However, dock nesting leads to more complex     (and less intuitive) behavior when a dock widget is dragged over the     main window, since there are more ways in which a dropped dock widget     may be placed in the dock area.      Setting this property is identical to setting the AllowNestedDocks option     using setDockOptions(). */
end_comment
begin_function
DECL|function|isDockNestingEnabled
name|bool
name|QMainWindow
operator|::
name|isDockNestingEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMainWindow
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layout
operator|->
name|dockOptions
operator|&
name|AllowNestedDocks
return|;
block|}
end_function
begin_function
DECL|function|setDockNestingEnabled
name|void
name|QMainWindow
operator|::
name|setDockNestingEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|DockOptions
name|opts
init|=
name|d
operator|->
name|layout
operator|->
name|dockOptions
decl_stmt|;
if|if
condition|(
name|enabled
condition|)
name|opts
operator||=
name|AllowNestedDocks
expr_stmt|;
else|else
name|opts
operator|&=
operator|~
name|AllowNestedDocks
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|setDockOptions
argument_list|(
name|opts
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*! \property QMainWindow::verticalTabsEnabled     \brief whether left and right dock areas use vertical tabs     \since 4.2      If this property is set to false, dock areas containing tabbed dock widgets     display horizontal tabs, simmilar to Visual Studio.      If this property is set to true, then the right and left dock areas display vertical     tabs, simmilar to KDevelop.      This property should be set before any dock widgets are added to the main window. */
end_comment
begin_endif
unit|bool QMainWindow::verticalTabsEnabled() const {     return d_func()->layout->verticalTabsEnabled(); }  void QMainWindow::setVerticalTabsEnabled(bool enabled) {     d_func()->layout->setVerticalTabsEnabled(enabled); }
endif|#
directive|endif
end_endif
begin_function
DECL|function|checkDockWidgetArea
specifier|static
name|bool
name|checkDockWidgetArea
parameter_list|(
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|Qt
operator|::
name|LeftDockWidgetArea
case|:
case|case
name|Qt
operator|::
name|RightDockWidgetArea
case|:
case|case
name|Qt
operator|::
name|TopDockWidgetArea
case|:
case|case
name|Qt
operator|::
name|BottomDockWidgetArea
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"%s: invalid 'area' argument"
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
end_ifndef
begin_comment
comment|/*!     \property QMainWindow::documentMode     \brief whether the tab bar for tabbed dockwidgets is set to document mode.     \since 4.5      The default is false.      \sa QTabBar::documentMode */
end_comment
begin_function
DECL|function|documentMode
name|bool
name|QMainWindow
operator|::
name|documentMode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|documentMode
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setDocumentMode
name|void
name|QMainWindow
operator|::
name|setDocumentMode
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|setDocumentMode
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABBAR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABWIDGET
end_ifndef
begin_comment
comment|/*!     \property QMainWindow::tabShape     \brief the tab shape used for tabbed dock widgets.     \since 4.5      The default is \l QTabWidget::Rounded.      \sa setTabPosition() */
end_comment
begin_function
DECL|function|tabShape
name|QTabWidget
operator|::
name|TabShape
name|QMainWindow
operator|::
name|tabShape
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|tabShape
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setTabShape
name|void
name|QMainWindow
operator|::
name|setTabShape
parameter_list|(
name|QTabWidget
operator|::
name|TabShape
name|tabShape
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|setTabShape
argument_list|(
name|tabShape
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the tab position for \a area.      \note The \l VerticalTabs dock option overrides the tab positions returned     by this function.      \sa setTabPosition(), tabShape() */
end_comment
begin_function
DECL|function|tabPosition
name|QTabWidget
operator|::
name|TabPosition
name|QMainWindow
operator|::
name|tabPosition
parameter_list|(
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|checkDockWidgetArea
argument_list|(
name|area
argument_list|,
literal|"QMainWindow::tabPosition"
argument_list|)
condition|)
return|return
name|QTabWidget
operator|::
name|South
return|;
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|tabPosition
argument_list|(
name|area
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the tab position for the given dock widget \a areas to the specified     \a tabPosition. By default, all dock areas show their tabs at the bottom.      \note The \l VerticalTabs dock option overrides the tab positions set by     this method.      \sa tabPosition(), setTabShape() */
end_comment
begin_function
DECL|function|setTabPosition
name|void
name|QMainWindow
operator|::
name|setTabPosition
parameter_list|(
name|Qt
operator|::
name|DockWidgetAreas
name|areas
parameter_list|,
name|QTabWidget
operator|::
name|TabPosition
name|tabPosition
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|setTabPosition
argument_list|(
name|areas
argument_list|,
name|tabPosition
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABWIDGET
end_comment
begin_comment
comment|/*!     Adds the given \a dockwidget to the specified \a area. */
end_comment
begin_function
DECL|function|addDockWidget
name|void
name|QMainWindow
operator|::
name|addDockWidget
parameter_list|(
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|,
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkDockWidgetArea
argument_list|(
name|area
argument_list|,
literal|"QMainWindow::addDockWidget"
argument_list|)
condition|)
return|return;
name|Qt
operator|::
name|Orientation
name|orientation
init|=
name|Qt
operator|::
name|Vertical
decl_stmt|;
switch|switch
condition|(
name|area
condition|)
block|{
case|case
name|Qt
operator|::
name|TopDockWidgetArea
case|:
case|case
name|Qt
operator|::
name|BottomDockWidgetArea
case|:
name|orientation
operator|=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|removeWidget
argument_list|(
name|dockwidget
argument_list|)
expr_stmt|;
comment|// in case it was already in here
name|addDockWidget
argument_list|(
name|area
argument_list|,
name|dockwidget
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|//drawer support
name|QMacCocoaAutoReleasePool
name|pool
decl_stmt|;
specifier|extern
name|bool
name|qt_mac_is_macdrawer
argument_list|(
specifier|const
name|QWidget
operator|*
argument_list|)
decl_stmt|;
comment|//qwidget_mac.cpp
if|if
condition|(
name|qt_mac_is_macdrawer
argument_list|(
name|dockwidget
argument_list|)
condition|)
block|{
specifier|extern
name|bool
name|qt_mac_set_drawer_preferred_edge
argument_list|(
name|QWidget
operator|*
argument_list|,
name|Qt
operator|::
name|DockWidgetArea
argument_list|)
decl_stmt|;
comment|//qwidget_mac.cpp
name|window
argument_list|()
operator|->
name|createWinId
argument_list|()
expr_stmt|;
name|dockwidget
operator|->
name|window
argument_list|()
operator|->
name|createWinId
argument_list|()
expr_stmt|;
name|qt_mac_set_drawer_preferred_edge
argument_list|(
name|dockwidget
argument_list|,
name|area
argument_list|)
expr_stmt|;
if|if
condition|(
name|dockwidget
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|dockwidget
operator|->
name|hide
argument_list|()
expr_stmt|;
name|dockwidget
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Restores the state of \a dockwidget if it is created after the call     to restoreState(). Returns true if the state was restored; otherwise     returns false.      \sa restoreState(), saveState() */
end_comment
begin_function
DECL|function|restoreDockWidget
name|bool
name|QMainWindow
operator|::
name|restoreDockWidget
parameter_list|(
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|restoreDockWidget
argument_list|(
name|dockwidget
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds \a dockwidget into the given \a area in the direction     specified by the \a orientation. */
end_comment
begin_function
DECL|function|addDockWidget
name|void
name|QMainWindow
operator|::
name|addDockWidget
parameter_list|(
name|Qt
operator|::
name|DockWidgetArea
name|area
parameter_list|,
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkDockWidgetArea
argument_list|(
name|area
argument_list|,
literal|"QMainWindow::addDockWidget"
argument_list|)
condition|)
return|return;
comment|// add a window to an area, placing done relative to the previous
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|addDockWidget
argument_list|(
name|area
argument_list|,
name|dockwidget
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMainWindow::splitDockWidget(QDockWidget *first, QDockWidget *second, Qt::Orientation orientation)      Splits the space covered by the \a first dock widget into two parts,     moves the \a first dock widget into the first part, and moves the     \a second dock widget into the second part.      The \a orientation specifies how the space is divided: A Qt::Horizontal     split places the second dock widget to the right of the first; a     Qt::Vertical split places the second dock widget below the first.      \e Note: if \a first is currently in a tabbed docked area, \a second will     be added as a new tab, not as a neighbor of \a first. This is because a     single tab can contain only one dock widget.      \e Note: The Qt::LayoutDirection influences the order of the dock widgets     in the two parts of the divided area. When right-to-left layout direction     is enabled, the placing of the dock widgets will be reversed.      \sa tabifyDockWidget(), addDockWidget(), removeDockWidget() */
end_comment
begin_function
DECL|function|splitDockWidget
name|void
name|QMainWindow
operator|::
name|splitDockWidget
parameter_list|(
name|QDockWidget
modifier|*
name|after
parameter_list|,
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|splitDockWidget
argument_list|(
name|after
argument_list|,
name|dockwidget
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMainWindow::tabifyDockWidget(QDockWidget *first, QDockWidget *second)      Moves \a second dock widget on top of \a first dock widget, creating a tabbed     docked area in the main window.      \sa tabifiedDockWidgets() */
end_comment
begin_function
DECL|function|tabifyDockWidget
name|void
name|QMainWindow
operator|::
name|tabifyDockWidget
parameter_list|(
name|QDockWidget
modifier|*
name|first
parameter_list|,
name|QDockWidget
modifier|*
name|second
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|tabifyDockWidget
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QDockWidget*> QMainWindow::tabifiedDockWidgets(QDockWidget *dockwidget) const      Returns the dock widgets that are tabified together with \a dockwidget.      \since 4.5     \sa tabifyDockWidget() */
end_comment
begin_function
DECL|function|tabifiedDockWidgets
name|QList
argument_list|<
name|QDockWidget
modifier|*
argument_list|>
name|QMainWindow
operator|::
name|tabifiedDockWidgets
parameter_list|(
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QDockWidget
modifier|*
argument_list|>
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_TABBAR
argument_list|)
name|Q_UNUSED
argument_list|(
name|dockwidget
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QDockAreaLayoutInfo
modifier|*
name|info
init|=
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|info
argument_list|(
name|dockwidget
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|tabbed
operator|&&
name|info
operator|->
name|tabBar
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|item_list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QDockAreaLayoutItem
modifier|&
name|item
init|=
name|info
operator|->
name|item_list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|.
name|widgetItem
condition|)
block|{
if|if
condition|(
name|QDockWidget
modifier|*
name|dock
init|=
name|qobject_cast
argument_list|<
name|QDockWidget
operator|*
argument_list|>
argument_list|(
name|item
operator|.
name|widgetItem
operator|->
name|widget
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|dock
operator|!=
name|dockwidget
condition|)
block|{
name|ret
operator|+=
name|dock
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the \a dockwidget from the main window layout and hides     it. Note that the \a dockwidget is \e not deleted. */
end_comment
begin_function
DECL|function|removeDockWidget
name|void
name|QMainWindow
operator|::
name|removeDockWidget
parameter_list|(
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|)
block|{
if|if
condition|(
name|dockwidget
condition|)
block|{
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|removeWidget
argument_list|(
name|dockwidget
argument_list|)
expr_stmt|;
name|dockwidget
operator|->
name|hide
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the Qt::DockWidgetArea for \a dockwidget. If \a dockwidget     has not been added to the main window, this function returns \c     Qt::NoDockWidgetArea.      \sa addDockWidget(), splitDockWidget(), Qt::DockWidgetArea */
end_comment
begin_function
DECL|function|dockWidgetArea
name|Qt
operator|::
name|DockWidgetArea
name|QMainWindow
operator|::
name|dockWidgetArea
parameter_list|(
name|QDockWidget
modifier|*
name|dockwidget
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|dockWidgetArea
argument_list|(
name|dockwidget
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DOCKWIDGET
end_comment
begin_comment
comment|/*!     Saves the current state of this mainwindow's toolbars and     dockwidgets. The \a version number is stored as part of the data.      The \l{QObject::objectName}{objectName} property is used     to identify each QToolBar and QDockWidget.  You should make sure     that this property is unique for each QToolBar and QDockWidget you     add to the QMainWindow      To restore the saved state, pass the return value and \a version     number to restoreState().      To save the geometry when the window closes, you can     implement a close event like this:      \snippet code/src_gui_widgets_qmainwindow.cpp 0      \sa restoreState(), QWidget::saveGeometry(), QWidget::restoreGeometry() */
end_comment
begin_function
DECL|function|saveState
name|QByteArray
name|QMainWindow
operator|::
name|saveState
parameter_list|(
name|int
name|version
parameter_list|)
specifier|const
block|{
name|QByteArray
name|data
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|data
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|stream
operator|<<
name|QMainWindowLayout
operator|::
name|VersionMarker
expr_stmt|;
name|stream
operator|<<
name|version
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|saveState
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Restores the \a state of this mainwindow's toolbars and     dockwidgets. The \a version number is compared with that stored     in \a state. If they do not match, the mainwindow's state is left     unchanged, and this function returns \c false; otherwise, the state     is restored, and this function returns \c true.      To restore geometry saved using QSettings, you can use code like     this:      \snippet code/src_gui_widgets_qmainwindow.cpp 1      \sa saveState(), QWidget::saveGeometry(),     QWidget::restoreGeometry(), restoreDockWidget() */
end_comment
begin_function
DECL|function|restoreState
name|bool
name|QMainWindow
operator|::
name|restoreState
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|state
parameter_list|,
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QByteArray
name|sd
init|=
name|state
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|sd
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
name|int
name|marker
decl_stmt|,
name|v
decl_stmt|;
name|stream
operator|>>
name|marker
expr_stmt|;
name|stream
operator|>>
name|v
expr_stmt|;
if|if
condition|(
name|stream
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
operator|||
name|marker
operator|!=
name|QMainWindowLayout
operator|::
name|VersionMarker
operator|||
name|v
operator|!=
name|version
condition|)
return|return
literal|false
return|;
name|bool
name|restored
init|=
name|d_func
argument_list|()
operator|->
name|layout
operator|->
name|restoreState
argument_list|(
name|stream
argument_list|)
decl_stmt|;
return|return
name|restored
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DOCKWIDGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
end_if
begin_function
DECL|function|separatorCursor
name|QCursor
name|QMainWindowPrivate
operator|::
name|separatorCursor
parameter_list|(
specifier|const
name|QList
argument_list|<
name|int
argument_list|>
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|QDockAreaLayoutInfo
modifier|*
name|info
init|=
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|info
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|info
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// is this the "top-level" separator which separates a dock area
comment|// from the central widget?
switch|switch
condition|(
name|path
operator|.
name|first
argument_list|()
condition|)
block|{
case|case
name|QInternal
operator|::
name|LeftDock
case|:
case|case
name|QInternal
operator|::
name|RightDock
case|:
return|return
name|Qt
operator|::
name|SplitHCursor
return|;
case|case
name|QInternal
operator|::
name|TopDock
case|:
case|case
name|QInternal
operator|::
name|BottomDock
case|:
return|return
name|Qt
operator|::
name|SplitVCursor
return|;
default|default:
break|break;
block|}
block|}
comment|// no, it's a splitter inside a dock area, separating two dock widgets
return|return
name|info
operator|->
name|o
operator|==
name|Qt
operator|::
name|Horizontal
condition|?
name|Qt
operator|::
name|SplitHCursor
else|:
name|Qt
operator|::
name|SplitVCursor
return|;
block|}
end_function
begin_function
DECL|function|adjustCursor
name|void
name|QMainWindowPrivate
operator|::
name|adjustCursor
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|hoverPos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hoverSeparator
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|update
argument_list|(
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|separatorRect
argument_list|(
name|hoverSeparator
argument_list|)
argument_list|)
expr_stmt|;
name|hoverSeparator
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursorAdjusted
condition|)
block|{
name|cursorAdjusted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|hasOldCursor
condition|)
name|q
operator|->
name|setCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|unsetCursor
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|layout
operator|->
name|movingSeparator
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Don't change cursor when moving separator
name|QList
argument_list|<
name|int
argument_list|>
name|pathToSeparator
init|=
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|findSeparator
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathToSeparator
operator|!=
name|hoverSeparator
condition|)
block|{
if|if
condition|(
operator|!
name|hoverSeparator
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|update
argument_list|(
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|separatorRect
argument_list|(
name|hoverSeparator
argument_list|)
argument_list|)
expr_stmt|;
name|hoverSeparator
operator|=
name|pathToSeparator
expr_stmt|;
if|if
condition|(
name|hoverSeparator
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|cursorAdjusted
condition|)
block|{
name|cursorAdjusted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|hasOldCursor
condition|)
name|q
operator|->
name|setCursor
argument_list|(
name|oldCursor
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|unsetCursor
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|q
operator|->
name|update
argument_list|(
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|separatorRect
argument_list|(
name|hoverSeparator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cursorAdjusted
condition|)
block|{
name|oldCursor
operator|=
name|q
operator|->
name|cursor
argument_list|()
expr_stmt|;
name|hasOldCursor
operator|=
name|q
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
expr_stmt|;
block|}
name|adjustedCursor
operator|=
name|separatorCursor
argument_list|(
name|hoverSeparator
argument_list|)
expr_stmt|;
name|q
operator|->
name|setCursor
argument_list|(
name|adjustedCursor
argument_list|)
expr_stmt|;
name|cursorAdjusted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QMainWindow
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
case|case
name|QEvent
operator|::
name|Paint
case|:
block|{
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QRegion
name|r
init|=
cast|static_cast
argument_list|<
name|QPaintEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|region
argument_list|()
decl_stmt|;
name|d
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|paintSeparators
argument_list|(
operator|&
name|p
argument_list|,
name|this
argument_list|,
name|r
argument_list|,
name|d
operator|->
name|hoverPos
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
case|case
name|QEvent
operator|::
name|HoverMove
case|:
block|{
name|d
operator|->
name|adjustCursor
argument_list|(
cast|static_cast
argument_list|<
name|QHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// We don't want QWidget to call update() on the entire QMainWindow
comment|// on HoverEnter and HoverLeave, hence accept the event (return true).
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
return|return
literal|true
return|;
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
name|d
operator|->
name|adjustCursor
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
comment|// when a menu pops up
name|d
operator|->
name|adjustCursor
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_CURSOR
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
block|{
name|QMouseEvent
modifier|*
name|e
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
operator|&&
name|d
operator|->
name|layout
operator|->
name|startSeparatorMove
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
comment|// The click was on a separator, eat this event
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseMove
case|:
block|{
name|QMouseEvent
modifier|*
name|e
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|d
operator|->
name|adjustCursor
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|e
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|separatorMove
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
comment|// We're moving a separator, eat this event
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
block|{
name|QMouseEvent
modifier|*
name|e
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|endSeparatorMove
argument_list|(
name|e
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
comment|// We've released a separator, eat this event
name|e
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
case|case
name|QEvent
operator|::
name|ToolBarChange
case|:
block|{
name|d
operator|->
name|layout
operator|->
name|toggleToolBarsVisible
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
case|case
name|QEvent
operator|::
name|StatusTip
case|:
ifndef|#
directive|ifndef
name|QT_NO_STATUSBAR
if|if
condition|(
name|QStatusBar
modifier|*
name|sb
init|=
name|d
operator|->
name|layout
operator|->
name|statusBar
argument_list|()
condition|)
name|sb
operator|->
name|showMessage
argument_list|(
cast|static_cast
argument_list|<
name|QStatusTipEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|tip
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
cast|static_cast
argument_list|<
name|QStatusTipEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
endif|#
directive|endif
comment|// QT_NO_STATUSTIP
case|case
name|QEvent
operator|::
name|StyleChange
case|:
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
name|d
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|styleChangedEvent
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|explicitIconSize
condition|)
name|setIconSize
argument_list|(
name|QSize
argument_list|()
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|Q_WS_MAC
case|case
name|QEvent
operator|::
name|Show
case|:
if|if
condition|(
name|unifiedTitleAndToolBarOnMac
argument_list|()
condition|)
name|d
operator|->
name|layout
operator|->
name|syncUnifiedToolbarVisibility
argument_list|()
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|blockVisiblityCheck
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowStateChange
case|:
block|{
if|if
condition|(
name|isHidden
argument_list|()
condition|)
block|{
comment|// We are coming out of a minimize, leave things as is.
name|d
operator|->
name|layout
operator|->
name|blockVisiblityCheck
operator|=
literal|true
expr_stmt|;
block|}
comment|// We need to update the HIToolbar status when we go out of or into fullscreen.
name|QWindowStateChangeEvent
modifier|*
name|wce
init|=
cast|static_cast
argument_list|<
name|QWindowStateChangeEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowFullScreen
operator|)
operator|||
operator|(
name|wce
operator|->
name|oldState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowFullScreen
operator|)
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|updateHIToolBarStatus
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|// Q_WS_MAC
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DOCKWIDGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
case|case
name|QEvent
operator|::
name|CursorChange
case|:
comment|// CursorChange events are triggered as mouse moves to new widgets even
comment|// if the cursor doesn't actually change, so do not change oldCursor if
comment|// the "changed" cursor has same shape as adjusted cursor.
if|if
condition|(
name|d
operator|->
name|cursorAdjusted
operator|&&
name|d
operator|->
name|adjustedCursor
operator|.
name|shape
argument_list|()
operator|!=
name|cursor
argument_list|()
operator|.
name|shape
argument_list|()
condition|)
block|{
name|d
operator|->
name|oldCursor
operator|=
name|cursor
argument_list|()
expr_stmt|;
name|d
operator|->
name|hasOldCursor
operator|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
expr_stmt|;
comment|// Ensure our adjusted cursor stays visible
name|setCursor
argument_list|(
name|d
operator|->
name|adjustedCursor
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
end_ifndef
begin_comment
comment|/*!     \property QMainWindow::unifiedTitleAndToolBarOnMac     \brief whether the window uses the unified title and toolbar look on Mac OS X     \since 4.3     \obsolete      This property is not implemented in Qt 5. Setting it has no effect. */
end_comment
begin_function
DECL|function|setUnifiedTitleAndToolBarOnMac
name|void
name|QMainWindow
operator|::
name|setUnifiedTitleAndToolBarOnMac
parameter_list|(
name|bool
name|set
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|||
name|d
operator|->
name|useHIToolBar
operator|==
name|set
operator|||
name|QSysInfo
operator|::
name|MacintoshVersion
operator|<
name|QSysInfo
operator|::
name|MV_10_3
condition|)
return|return;
name|d
operator|->
name|useHIToolBar
operator|=
name|set
expr_stmt|;
name|createWinId
argument_list|()
expr_stmt|;
comment|// We need the hiview for down below.
comment|// Activate the unified toolbar with the raster engine.
if|if
condition|(
name|windowSurface
argument_list|()
operator|&&
name|set
condition|)
block|{
name|d
operator|->
name|layout
operator|->
name|unifiedSurface
operator|=
operator|new
name|QUnifiedToolbarSurface
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|layout
operator|->
name|updateHIToolBarStatus
argument_list|()
expr_stmt|;
comment|// Deactivate the unified toolbar with the raster engine.
if|if
condition|(
name|windowSurface
argument_list|()
operator|&&
operator|!
name|set
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|layout
operator|->
name|unifiedSurface
condition|)
block|{
operator|delete
name|d
operator|->
name|layout
operator|->
name|unifiedSurface
expr_stmt|;
name|d
operator|->
name|layout
operator|->
name|unifiedSurface
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Enabling the unified toolbar clears the opaque size grip setting, update it.
name|d
operator|->
name|macUpdateOpaqueSizeGrip
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|set
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unifiedTitleAndToolBarOnMac
name|bool
name|QMainWindow
operator|::
name|unifiedTitleAndToolBarOnMac
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
return|return
name|d_func
argument_list|()
operator|->
name|useHIToolBar
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_MacBrushedMetal
argument_list|)
operator|&&
operator|!
operator|(
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|FramelessWindowHint
operator|)
return|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TOOLBAR
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isSeparator
name|bool
name|QMainWindow
operator|::
name|isSeparator
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
name|Q_D
argument_list|(
specifier|const
name|QMainWindow
argument_list|)
expr_stmt|;
return|return
operator|!
name|d
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|findSeparator
argument_list|(
name|pos
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QMainWindow
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
comment|// only show the context menu for direct QDockWidget and QToolBar
comment|// children and for the menu bar as well
name|QWidget
modifier|*
name|child
init|=
name|childAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|child
operator|&&
name|child
operator|!=
name|this
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_MENUBAR
if|if
condition|(
name|QMenuBar
modifier|*
name|mb
init|=
name|qobject_cast
argument_list|<
name|QMenuBar
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|mb
operator|->
name|parentWidget
argument_list|()
operator|!=
name|this
condition|)
return|return;
break|break;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
if|if
condition|(
name|QDockWidget
modifier|*
name|dw
init|=
name|qobject_cast
argument_list|<
name|QDockWidget
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|dw
operator|->
name|parentWidget
argument_list|()
operator|!=
name|this
condition|)
return|return;
if|if
condition|(
name|dw
operator|->
name|widget
argument_list|()
operator|&&
name|dw
operator|->
name|widget
argument_list|()
operator|->
name|geometry
argument_list|()
operator|.
name|contains
argument_list|(
name|child
operator|->
name|mapFrom
argument_list|(
name|this
argument_list|,
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// ignore the event if the mouse is over the QDockWidget contents
return|return;
block|}
break|break;
block|}
endif|#
directive|endif
comment|// QT_NO_DOCKWIDGET
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
if|if
condition|(
name|QToolBar
modifier|*
name|tb
init|=
name|qobject_cast
argument_list|<
name|QToolBar
operator|*
argument_list|>
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|tb
operator|->
name|parentWidget
argument_list|()
operator|!=
name|this
condition|)
return|return;
break|break;
block|}
endif|#
directive|endif
name|child
operator|=
name|child
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|==
name|this
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_MENU
name|QMenu
modifier|*
name|popup
init|=
name|createPopupMenu
argument_list|()
decl_stmt|;
if|if
condition|(
name|popup
condition|)
block|{
if|if
condition|(
operator|!
name|popup
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|popup
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
expr_stmt|;
name|popup
operator|->
name|popup
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|popup
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MENU
end_ifndef
begin_comment
comment|/*!     Returns a popup menu containing checkable entries for the toolbars and     dock widgets present in the main window. If  there are no toolbars and     dock widgets present, this function returns a null pointer.      By default, this function is called by the main window when the user     activates a context menu, typically by right-clicking on a toolbar or a dock     widget.      If you want to create a custom popup menu, reimplement this function and     return a newly-created popup menu. Ownership of the popup menu is transferred     to the caller.      \sa addDockWidget(), addToolBar(), menuBar() */
end_comment
begin_function
DECL|function|createPopupMenu
name|QMenu
modifier|*
name|QMainWindow
operator|::
name|createPopupMenu
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMainWindow
argument_list|)
expr_stmt|;
name|QMenu
modifier|*
name|menu
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DOCKWIDGET
name|QList
argument_list|<
name|QDockWidget
modifier|*
argument_list|>
name|dockwidgets
init|=
name|findChildren
argument_list|<
name|QDockWidget
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|dockwidgets
operator|.
name|size
argument_list|()
condition|)
block|{
name|menu
operator|=
operator|new
name|QMenu
argument_list|(
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dockwidgets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QDockWidget
modifier|*
name|dockWidget
init|=
name|dockwidgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dockWidget
operator|->
name|parentWidget
argument_list|()
operator|==
name|this
operator|&&
operator|!
name|d
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|dockAreaLayout
operator|.
name|indexOf
argument_list|(
name|dockWidget
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|menu
operator|->
name|addAction
argument_list|(
name|dockwidgets
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|toggleViewAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|menu
operator|->
name|addSeparator
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_DOCKWIDGET
ifndef|#
directive|ifndef
name|QT_NO_TOOLBAR
name|QList
argument_list|<
name|QToolBar
modifier|*
argument_list|>
name|toolbars
init|=
name|findChildren
argument_list|<
name|QToolBar
operator|*
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|toolbars
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|menu
condition|)
name|menu
operator|=
operator|new
name|QMenu
argument_list|(
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toolbars
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QToolBar
modifier|*
name|toolBar
init|=
name|toolbars
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toolBar
operator|->
name|parentWidget
argument_list|()
operator|==
name|this
operator|&&
operator|(
operator|!
name|d
operator|->
name|layout
operator|->
name|layoutState
operator|.
name|toolBarAreaLayout
operator|.
name|indexOf
argument_list|(
name|toolBar
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|unifiedTitleAndToolBarOnMac
argument_list|()
operator|&&
name|toolBarArea
argument_list|(
name|toolBar
argument_list|)
operator|==
name|Qt
operator|::
name|TopToolBarArea
operator|)
operator|)
condition|)
block|{
name|menu
operator|->
name|addAction
argument_list|(
name|toolbars
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|toggleViewAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|menu
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MENU
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MAINWINDOW
end_comment
end_unit
