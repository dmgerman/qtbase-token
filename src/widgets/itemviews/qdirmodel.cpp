begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdirmodel.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DIRMODEL
end_ifndef
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfilesystemmodel.h>
end_include
begin_include
include|#
directive|include
file|<qurl.h>
end_include
begin_include
include|#
directive|include
file|<qmimedata.h>
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qobject.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qlocale.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<private/qabstractitemmodel_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_comment
comment|/*!     \enum QDirModel::Roles     \value FileIconRole     \value FilePathRole     \value FileNameRole */
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QDirModelPrivate
class|class
name|QDirModelPrivate
super|:
specifier|public
name|QAbstractItemModelPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QDirModel
parameter_list|)
specifier|public
private|:
DECL|struct|QDirNode
struct|struct
name|QDirNode
block|{
DECL|function|QDirNode
name|QDirNode
parameter_list|()
member_init_list|:
name|parent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|populated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|stat
argument_list|(
literal|false
argument_list|)
block|{}
DECL|function|~QDirNode
name|~
name|QDirNode
parameter_list|()
block|{
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|member|parent
name|QDirNode
modifier|*
name|parent
decl_stmt|;
DECL|member|info
name|QFileInfo
name|info
decl_stmt|;
DECL|member|icon
name|QIcon
name|icon
decl_stmt|;
comment|// cache the icon
DECL|member|children
specifier|mutable
name|QVector
argument_list|<
name|QDirNode
argument_list|>
name|children
decl_stmt|;
DECL|member|populated
specifier|mutable
name|bool
name|populated
decl_stmt|;
comment|// have we read the children
DECL|member|stat
specifier|mutable
name|bool
name|stat
decl_stmt|;
block|}
struct|;
DECL|function|QDirModelPrivate
name|QDirModelPrivate
parameter_list|()
member_init_list|:
name|resolveSymlinks
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|readOnly
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|lazyChildCount
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|allowAppendChild
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|iconProvider
argument_list|(
operator|&
name|defaultProvider
argument_list|)
member_init_list|,
name|shouldStat
argument_list|(
literal|true
argument_list|)
comment|// ### This is set to false by QFileDialog
block|{ }
name|void
name|init
parameter_list|()
function_decl|;
name|QDirNode
modifier|*
name|node
parameter_list|(
name|int
name|row
parameter_list|,
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|QDirNode
argument_list|>
name|children
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|,
name|bool
name|stat
parameter_list|)
specifier|const
function_decl|;
name|void
name|_q_refresh
parameter_list|()
function_decl|;
name|void
name|savePersistentIndexes
parameter_list|()
function_decl|;
name|void
name|restorePersistentIndexes
parameter_list|()
function_decl|;
name|QFileInfoList
name|entryInfoList
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
function_decl|;
name|QStringList
name|entryList
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
function_decl|;
name|QString
name|name
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
function_decl|;
name|QString
name|size
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
function_decl|;
name|QString
name|type
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
function_decl|;
name|QString
name|time
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
function_decl|;
name|void
name|appendChild
parameter_list|(
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
function_decl|;
specifier|static
name|QFileInfo
name|resolvedInfo
parameter_list|(
name|QFileInfo
name|info
parameter_list|)
function_decl|;
specifier|inline
name|QDirNode
modifier|*
name|node
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|void
name|populate
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|void
name|clear
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
function_decl|;
name|void
name|invalidate
parameter_list|()
function_decl|;
DECL|member|root
specifier|mutable
name|QDirNode
name|root
decl_stmt|;
DECL|member|resolveSymlinks
name|bool
name|resolveSymlinks
decl_stmt|;
DECL|member|readOnly
name|bool
name|readOnly
decl_stmt|;
DECL|member|lazyChildCount
name|bool
name|lazyChildCount
decl_stmt|;
DECL|member|allowAppendChild
name|bool
name|allowAppendChild
decl_stmt|;
DECL|member|filters
name|QDir
operator|::
name|Filters
name|filters
decl_stmt|;
DECL|member|sort
name|QDir
operator|::
name|SortFlags
name|sort
decl_stmt|;
DECL|member|nameFilters
name|QStringList
name|nameFilters
decl_stmt|;
DECL|member|iconProvider
name|QFileIconProvider
modifier|*
name|iconProvider
decl_stmt|;
DECL|member|defaultProvider
name|QFileIconProvider
name|defaultProvider
decl_stmt|;
DECL|struct|SavedPersistent
struct|struct
name|SavedPersistent
block|{
DECL|member|path
name|QString
name|path
decl_stmt|;
DECL|member|column
name|int
name|column
decl_stmt|;
DECL|member|data
name|QPersistentModelIndexData
modifier|*
name|data
decl_stmt|;
DECL|member|index
name|QPersistentModelIndex
name|index
decl_stmt|;
block|}
struct|;
DECL|member|savedPersistent
name|QList
argument_list|<
name|SavedPersistent
argument_list|>
name|savedPersistent
decl_stmt|;
DECL|member|toBeRefreshed
name|QPersistentModelIndex
name|toBeRefreshed
decl_stmt|;
DECL|member|shouldStat
name|bool
name|shouldStat
decl_stmt|;
comment|// use the "carefull not to stat directories" mode
block|}
class|;
end_class
begin_function
DECL|function|qt_setDirModelShouldNotStat
name|void
name|qt_setDirModelShouldNotStat
parameter_list|(
name|QDirModelPrivate
modifier|*
name|modelPrivate
parameter_list|)
block|{
name|modelPrivate
operator|->
name|shouldStat
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|node
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|QDirModelPrivate
operator|::
name|node
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|n
init|=
cast|static_cast
argument_list|<
name|QDirModelPrivate
operator|::
name|QDirNode
operator|*
argument_list|>
argument_list|(
name|index
operator|.
name|internalPointer
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|populate
name|void
name|QDirModelPrivate
operator|::
name|populate
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|children
operator|=
name|children
argument_list|(
name|parent
argument_list|,
name|parent
operator|->
name|stat
argument_list|)
expr_stmt|;
name|parent
operator|->
name|populated
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QDirModelPrivate
operator|::
name|clear
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parent
operator|->
name|populated
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invalidate
name|void
name|QDirModelPrivate
operator|::
name|invalidate
parameter_list|()
block|{
name|QStack
argument_list|<
specifier|const
name|QDirNode
modifier|*
argument_list|>
name|nodes
decl_stmt|;
name|nodes
operator|.
name|push
argument_list|(
operator|&
name|root
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nodes
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|const
name|QDirNode
modifier|*
name|current
init|=
name|nodes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|current
operator|->
name|stat
operator|=
literal|false
expr_stmt|;
specifier|const
name|QVector
argument_list|<
name|QDirNode
argument_list|>
name|children
init|=
name|current
operator|->
name|children
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|nodes
operator|.
name|push
argument_list|(
operator|&
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QDirModel     \obsolete     \brief The QDirModel class provides a data model for the local filesystem.      \ingroup model-view     \inmodule QtWidgets      The usage of QDirModel is not recommended anymore. The     QFileSystemModel class is a more performant alternative.      This class provides access to the local filesystem, providing functions     for renaming and removing files and directories, and for creating new     directories. In the simplest case, it can be used with a suitable display     widget as part of a browser or filer.      QDirModel keeps a cache with file information. The cache needs to be     updated with refresh().      QDirModel can be accessed using the standard interface provided by     QAbstractItemModel, but it also provides some convenience functions     that are specific to a directory model. The fileInfo() and isDir()     functions provide information about the underlying files and directories     related to items in the model.      Directories can be created and removed using mkdir(), rmdir(), and the     model will be automatically updated to take the changes into account.      \note QDirModel requires an instance of a GUI application.      \sa nameFilters(), setFilter(), filter(), QListView, QTreeView, QFileSystemModel,     {Dir View Example}, {Model Classes} */
end_comment
begin_comment
comment|/*!     Constructs a new directory model with the given \a parent.     Only those files matching the \a nameFilters and the     \a filters are included in the model. The sort order is given by the     \a sort flags. */
end_comment
begin_constructor
DECL|function|QDirModel
name|QDirModel
operator|::
name|QDirModel
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|nameFilters
parameter_list|,
name|QDir
operator|::
name|Filters
name|filters
parameter_list|,
name|QDir
operator|::
name|SortFlags
name|sort
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
operator|*
operator|new
name|QDirModelPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
comment|// we always start with QDir::drives()
name|d
operator|->
name|nameFilters
operator|=
name|nameFilters
operator|.
name|isEmpty
argument_list|()
condition|?
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
argument_list|)
else|:
name|nameFilters
expr_stmt|;
name|d
operator|->
name|filters
operator|=
name|filters
expr_stmt|;
name|d
operator|->
name|sort
operator|=
name|sort
expr_stmt|;
name|d
operator|->
name|root
operator|.
name|parent
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|root
operator|.
name|info
operator|=
name|QFileInfo
argument_list|()
expr_stmt|;
name|d
operator|->
name|clear
argument_list|(
operator|&
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructs a directory model with the given \a parent. */
end_comment
begin_constructor
DECL|function|QDirModel
name|QDirModel
operator|::
name|QDirModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
operator|*
operator|new
name|QDirModelPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QDirModel
name|QDirModel
operator|::
name|QDirModel
parameter_list|(
name|QDirModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys this directory model. */
end_comment
begin_destructor
DECL|function|~QDirModel
name|QDirModel
operator|::
name|~
name|QDirModel
parameter_list|()
block|{  }
end_destructor
begin_comment
comment|/*!   Returns the model item index for the item in the \a parent with the   given \a row and \a column.  */
end_comment
begin_function
DECL|function|index
name|QModelIndex
name|QDirModel
operator|::
name|index
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
comment|// note that rowCount does lazy population
if|if
condition|(
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|||
name|row
argument_list|<
literal|0
operator|||
name|parent
operator|.
name|column
operator|(
operator|)
argument_list|>
literal|0
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
comment|// make sure the list of children is up to date
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
operator|(
name|d
operator|->
name|indexValid
argument_list|(
name|parent
argument_list|)
condition|?
name|d
operator|->
name|node
argument_list|(
name|parent
argument_list|)
else|:
operator|&
name|d
operator|->
name|root
operator|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|populated
condition|)
name|d
operator|->
name|populate
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// populate without stat'ing
if|if
condition|(
name|row
operator|>=
name|p
operator|->
name|children
operator|.
name|count
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
comment|// now get the internal pointer for the index
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|n
init|=
name|d
operator|->
name|node
argument_list|(
name|row
argument_list|,
name|d
operator|->
name|indexValid
argument_list|(
name|parent
argument_list|)
condition|?
name|p
else|:
literal|0
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|createIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Return the parent of the given \a child model item. */
end_comment
begin_function
DECL|function|parent
name|QModelIndex
name|QDirModel
operator|::
name|parent
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|child
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|child
argument_list|)
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|par
init|=
operator|(
name|node
condition|?
name|node
operator|->
name|parent
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|par
operator|==
literal|0
condition|)
comment|// parent is the root node
return|return
name|QModelIndex
argument_list|()
return|;
comment|// get the parent's row
specifier|const
name|QVector
argument_list|<
name|QDirModelPrivate
operator|::
name|QDirNode
argument_list|>
name|children
init|=
name|par
operator|->
name|parent
condition|?
name|par
operator|->
name|parent
operator|->
name|children
else|:
name|d
operator|->
name|root
operator|.
name|children
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|children
operator|.
name|count
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|int
name|row
init|=
operator|(
name|par
operator|-
operator|&
operator|(
name|children
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|)
operator|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|row
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|par
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the number of rows in the \a parent model item.  */
end_comment
begin_function
DECL|function|rowCount
name|int
name|QDirModel
operator|::
name|rowCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|column
argument_list|()
operator|>
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|root
operator|.
name|populated
condition|)
comment|// lazy population
name|d
operator|->
name|populate
argument_list|(
operator|&
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|root
operator|.
name|children
operator|.
name|count
argument_list|()
return|;
block|}
if|if
condition|(
name|parent
operator|.
name|model
argument_list|()
operator|!=
name|this
condition|)
return|return
literal|0
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
name|d
operator|->
name|node
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|info
operator|.
name|isDir
argument_list|()
operator|&&
operator|!
name|p
operator|->
name|populated
condition|)
comment|// lazy population
name|d
operator|->
name|populate
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|->
name|children
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the number of columns in the \a parent model item.  */
end_comment
begin_function
DECL|function|columnCount
name|int
name|QDirModel
operator|::
name|columnCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|parent
operator|.
name|column
argument_list|()
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|4
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the data for the model item \a index with the given \a role. */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QDirModel
operator|::
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|QVariant
argument_list|()
return|;
if|if
condition|(
name|role
operator|==
name|Qt
operator|::
name|DisplayRole
operator|||
name|role
operator|==
name|Qt
operator|::
name|EditRole
condition|)
block|{
switch|switch
condition|(
name|index
operator|.
name|column
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|d
operator|->
name|name
argument_list|(
name|index
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|d
operator|->
name|size
argument_list|(
name|index
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|d
operator|->
name|type
argument_list|(
name|index
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|d
operator|->
name|time
argument_list|(
name|index
argument_list|)
return|;
default|default:
name|qWarning
argument_list|(
literal|"data: invalid display value column %d"
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|index
operator|.
name|column
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|role
operator|==
name|FileIconRole
condition|)
return|return
name|fileIcon
argument_list|(
name|index
argument_list|)
return|;
if|if
condition|(
name|role
operator|==
name|FilePathRole
condition|)
return|return
name|filePath
argument_list|(
name|index
argument_list|)
return|;
if|if
condition|(
name|role
operator|==
name|FileNameRole
condition|)
return|return
name|fileName
argument_list|(
name|index
argument_list|)
return|;
block|}
if|if
condition|(
name|index
operator|.
name|column
argument_list|()
operator|==
literal|1
operator|&&
name|Qt
operator|::
name|TextAlignmentRole
operator|==
name|role
condition|)
block|{
return|return
name|Qt
operator|::
name|AlignRight
return|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the data for the model item \a index with the given \a role to   the data referenced by the \a value. Returns \c true if successful;   otherwise returns \c false.    \sa Qt::ItemDataRole */
end_comment
begin_function
DECL|function|setData
name|bool
name|QDirModel
operator|::
name|setData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
operator|||
name|index
operator|.
name|column
argument_list|()
operator|!=
literal|0
operator|||
operator|(
name|flags
argument_list|(
name|index
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsEditable
operator|)
operator|==
literal|0
operator|||
name|role
operator|!=
name|Qt
operator|::
name|EditRole
condition|)
return|return
literal|false
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QDir
name|dir
init|=
name|node
operator|->
name|info
operator|.
name|dir
argument_list|()
decl_stmt|;
name|QString
name|name
init|=
name|value
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|.
name|rename
argument_list|(
name|node
operator|->
name|info
operator|.
name|fileName
argument_list|()
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|node
operator|->
name|info
operator|=
name|QFileInfo
argument_list|(
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|QModelIndex
name|sibling
init|=
name|index
operator|.
name|sibling
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
literal|3
argument_list|)
decl_stmt|;
emit|emit
name|dataChanged
argument_list|(
name|index
argument_list|,
name|sibling
argument_list|)
emit|;
name|d
operator|->
name|toBeRefreshed
operator|=
name|index
operator|.
name|parent
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_refresh"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the data stored under the given \a role for the specified \a section   of the header with the given \a orientation. */
end_comment
begin_function
DECL|function|headerData
name|QVariant
name|QDirModel
operator|::
name|headerData
parameter_list|(
name|int
name|section
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
name|role
operator|!=
name|Qt
operator|::
name|DisplayRole
condition|)
return|return
name|QVariant
argument_list|()
return|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
literal|0
case|:
return|return
name|tr
argument_list|(
literal|"Name"
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|tr
argument_list|(
literal|"Size"
argument_list|)
return|;
case|case
literal|2
case|:
return|return
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|tr
argument_list|(
literal|"Kind"
argument_list|,
literal|"Match OS X Finder"
argument_list|)
return|;
else|#
directive|else
name|tr
argument_list|(
literal|"Type"
argument_list|,
literal|"All other platforms"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Windows   - Type
comment|// OS X      - Kind
comment|// Konqueror - File Type
comment|// Nautilus  - Type
case|case
literal|3
case|:
return|return
name|tr
argument_list|(
literal|"Date Modified"
argument_list|)
return|;
default|default:
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
return|return
name|QAbstractItemModel
operator|::
name|headerData
argument_list|(
name|section
argument_list|,
name|orientation
argument_list|,
name|role
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the \a parent model item has children; otherwise   returns \c false. */
end_comment
begin_function
DECL|function|hasChildren
name|bool
name|QDirModel
operator|::
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|column
argument_list|()
operator|>
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isValid
argument_list|()
condition|)
comment|// the invalid index is the "My Computer" item
return|return
literal|true
return|;
comment|// the drives
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
name|d
operator|->
name|node
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lazyChildCount
condition|)
comment|// optimization that only checks for children if the node has been populated
return|return
name|p
operator|->
name|info
operator|.
name|isDir
argument_list|()
return|;
return|return
name|p
operator|->
name|info
operator|.
name|isDir
argument_list|()
operator|&&
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the item flags for the given \a index in the model.    \sa Qt::ItemFlags */
end_comment
begin_function
DECL|function|flags
name|Qt
operator|::
name|ItemFlags
name|QDirModel
operator|::
name|flags
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|QAbstractItemModel
operator|::
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|flags
return|;
name|flags
operator||=
name|Qt
operator|::
name|ItemIsDragEnabled
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readOnly
condition|)
return|return
name|flags
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|.
name|column
argument_list|()
operator|==
literal|0
operator|)
operator|&&
name|node
operator|->
name|info
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|flags
operator||=
name|Qt
operator|::
name|ItemIsEditable
expr_stmt|;
if|if
condition|(
name|fileInfo
argument_list|(
name|index
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
comment|// is directory and is editable
name|flags
operator||=
name|Qt
operator|::
name|ItemIsDropEnabled
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function
begin_comment
comment|/*!   Sort the model items in the \a column using the \a order given.   The order is a value defined in \l Qt::SortOrder. */
end_comment
begin_function
DECL|function|sort
name|void
name|QDirModel
operator|::
name|sort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|QDir
operator|::
name|SortFlags
name|sort
init|=
name|QDir
operator|::
name|DirsFirst
operator||
name|QDir
operator|::
name|IgnoreCase
decl_stmt|;
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
condition|)
name|sort
operator||=
name|QDir
operator|::
name|Reversed
expr_stmt|;
switch|switch
condition|(
name|column
condition|)
block|{
case|case
literal|0
case|:
name|sort
operator||=
name|QDir
operator|::
name|Name
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sort
operator||=
name|QDir
operator|::
name|Size
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sort
operator||=
name|QDir
operator|::
name|Type
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sort
operator||=
name|QDir
operator|::
name|Time
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|setSorting
argument_list|(
name|sort
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of MIME types that can be used to describe a list of items     in the model. */
end_comment
begin_function
DECL|function|mimeTypes
name|QStringList
name|QDirModel
operator|::
name|mimeTypes
parameter_list|()
specifier|const
block|{
return|return
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"text/uri-list"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an object that contains a serialized description of the specified     \a indexes. The format used to describe the items corresponding to the     indexes is obtained from the mimeTypes() function.      If the list of indexes is empty, 0 is returned rather than a serialized     empty list. */
end_comment
begin_function
DECL|function|mimeData
name|QMimeData
modifier|*
name|QDirModel
operator|::
name|mimeData
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|indexes
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
decl_stmt|;
name|QList
argument_list|<
name|QModelIndex
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|indexes
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|indexes
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|column
argument_list|()
operator|==
literal|0
condition|)
name|urls
operator|<<
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|filePath
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|QMimeData
modifier|*
name|data
init|=
operator|new
name|QMimeData
argument_list|()
decl_stmt|;
name|data
operator|->
name|setUrls
argument_list|(
name|urls
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Handles the \a data supplied by a drag and drop operation that ended with     the given \a action over the row in the model specified by the \a row and     \a column and by the \a parent index.      Returns \c true if the drop was successful, and false otherwise.      \sa supportedDropActions() */
end_comment
begin_function
DECL|function|dropMimeData
name|bool
name|QDirModel
operator|::
name|dropMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|DropAction
name|action
parameter_list|,
name|int
comment|/* row */
parameter_list|,
name|int
comment|/* column */
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|parent
argument_list|)
operator|||
name|isReadOnly
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|success
init|=
literal|true
decl_stmt|;
name|QString
name|to
init|=
name|filePath
argument_list|(
name|parent
argument_list|)
operator|+
name|QDir
operator|::
name|separator
argument_list|()
decl_stmt|;
name|QModelIndex
name|_parent
init|=
name|parent
decl_stmt|;
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
init|=
name|data
operator|->
name|urls
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QUrl
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|urls
operator|.
name|constBegin
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|Qt
operator|::
name|CopyAction
case|:
for|for
control|(
init|;
name|it
operator|!=
name|urls
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|path
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|toLocalFile
argument_list|()
decl_stmt|;
name|success
operator|=
name|QFile
operator|::
name|copy
argument_list|(
name|path
argument_list|,
name|to
operator|+
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|fileName
argument_list|()
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|LinkAction
case|:
for|for
control|(
init|;
name|it
operator|!=
name|urls
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|path
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|toLocalFile
argument_list|()
decl_stmt|;
name|success
operator|=
name|QFile
operator|::
name|link
argument_list|(
name|path
argument_list|,
name|to
operator|+
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|fileName
argument_list|()
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|MoveAction
case|:
for|for
control|(
init|;
name|it
operator|!=
name|urls
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|path
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|toLocalFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|copy
argument_list|(
name|path
argument_list|,
name|to
operator|+
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|fileName
argument_list|()
argument_list|)
operator|&&
name|QFile
operator|::
name|remove
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|QModelIndex
name|idx
init|=
name|index
argument_list|(
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|refresh
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|//the previous call to refresh may invalidate the _parent. so recreate a new QModelIndex
name|_parent
operator|=
name|index
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
literal|false
expr_stmt|;
block|}
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
if|if
condition|(
name|success
condition|)
name|refresh
argument_list|(
name|_parent
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the drop actions supported by this model.    \sa Qt::DropActions */
end_comment
begin_function
DECL|function|supportedDropActions
name|Qt
operator|::
name|DropActions
name|QDirModel
operator|::
name|supportedDropActions
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|CopyAction
operator||
name|Qt
operator|::
name|MoveAction
return|;
comment|// FIXME: LinkAction is not supported yet
block|}
end_function
begin_comment
comment|/*!   Sets the \a provider of file icons for the directory model.  */
end_comment
begin_function
DECL|function|setIconProvider
name|void
name|QDirModel
operator|::
name|setIconProvider
parameter_list|(
name|QFileIconProvider
modifier|*
name|provider
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|iconProvider
operator|=
name|provider
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the file icon provider for this directory model. */
end_comment
begin_function
DECL|function|iconProvider
name|QFileIconProvider
modifier|*
name|QDirModel
operator|::
name|iconProvider
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|iconProvider
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the name \a filters for the directory model. */
end_comment
begin_function
DECL|function|setNameFilters
name|void
name|QDirModel
operator|::
name|setNameFilters
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|filters
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|nameFilters
operator|=
name|filters
expr_stmt|;
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|shouldStat
condition|)
name|refresh
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!   Returns a list of filters applied to the names in the model. */
end_comment
begin_function
DECL|function|nameFilters
name|QStringList
name|QDirModel
operator|::
name|nameFilters
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nameFilters
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the directory model's filter to that specified by \a filters.    Note that the filter you set should always include the QDir::AllDirs enum value,   otherwise QDirModel won't be able to read the directory structure.    \sa QDir::Filters */
end_comment
begin_function
DECL|function|setFilter
name|void
name|QDirModel
operator|::
name|setFilter
parameter_list|(
name|QDir
operator|::
name|Filters
name|filters
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|filters
operator|=
name|filters
expr_stmt|;
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|shouldStat
condition|)
name|refresh
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!   Returns the filter specification for the directory model.    \sa QDir::Filters */
end_comment
begin_function
DECL|function|filter
name|QDir
operator|::
name|Filters
name|QDirModel
operator|::
name|filter
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|filters
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the directory model's sorting order to that specified by \a sort.    \sa QDir::SortFlags */
end_comment
begin_function
DECL|function|setSorting
name|void
name|QDirModel
operator|::
name|setSorting
parameter_list|(
name|QDir
operator|::
name|SortFlags
name|sort
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|sort
operator|=
name|sort
expr_stmt|;
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
if|if
condition|(
name|d
operator|->
name|shouldStat
condition|)
name|refresh
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!   Returns the sorting method used for the directory model.    \sa QDir::SortFlags */
end_comment
begin_function
DECL|function|sorting
name|QDir
operator|::
name|SortFlags
name|QDirModel
operator|::
name|sorting
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sort
return|;
block|}
end_function
begin_comment
comment|/*!     \property QDirModel::resolveSymlinks     \brief Whether the directory model should resolve symbolic links      This is only relevant on operating systems that support symbolic     links. */
end_comment
begin_function
DECL|function|setResolveSymlinks
name|void
name|QDirModel
operator|::
name|setResolveSymlinks
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|resolveSymlinks
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveSymlinks
name|bool
name|QDirModel
operator|::
name|resolveSymlinks
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|resolveSymlinks
return|;
block|}
end_function
begin_comment
comment|/*!   \property QDirModel::readOnly   \brief Whether the directory model allows writing to the file system    If this property is set to false, the directory model will allow renaming, copying   and deleting of files and directories.    This property is \c true by default */
end_comment
begin_function
DECL|function|setReadOnly
name|void
name|QDirModel
operator|::
name|setReadOnly
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|readOnly
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isReadOnly
name|bool
name|QDirModel
operator|::
name|isReadOnly
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|readOnly
return|;
block|}
end_function
begin_comment
comment|/*!   \property QDirModel::lazyChildCount   \brief Whether the directory model optimizes the hasChildren function   to only check if the item is a directory.    If this property is set to false, the directory model will make sure that a directory   actually containes any files before reporting that it has children.   Otherwise the directory model will report that an item has children if the item   is a directory.    This property is \c false by default */
end_comment
begin_function
DECL|function|setLazyChildCount
name|void
name|QDirModel
operator|::
name|setLazyChildCount
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|lazyChildCount
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lazyChildCount
name|bool
name|QDirModel
operator|::
name|lazyChildCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|lazyChildCount
return|;
block|}
end_function
begin_comment
comment|/*!   QDirModel caches file information. This function updates the   cache. The \a parent parameter is the directory from which the   model is updated; the default value will update the model from   root directory of the file system (the entire model). */
end_comment
begin_function
DECL|function|refresh
name|void
name|QDirModel
operator|::
name|refresh
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|n
init|=
name|d
operator|->
name|indexValid
argument_list|(
name|parent
argument_list|)
condition|?
name|d
operator|->
name|node
argument_list|(
name|parent
argument_list|)
else|:
operator|&
operator|(
name|d
operator|->
name|root
operator|)
decl_stmt|;
name|int
name|rows
init|=
name|n
operator|->
name|children
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|rows
operator|==
literal|0
condition|)
block|{
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
name|n
operator|->
name|stat
operator|=
literal|true
expr_stmt|;
comment|// make sure that next time we read all the info
name|n
operator|->
name|populated
operator|=
literal|false
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
return|return;
block|}
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
name|d
operator|->
name|savePersistentIndexes
argument_list|()
expr_stmt|;
name|d
operator|->
name|rowsAboutToBeRemoved
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|rows
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|->
name|stat
operator|=
literal|true
expr_stmt|;
comment|// make sure that next time we read all the info
name|d
operator|->
name|clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|d
operator|->
name|rowsRemoved
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|rows
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|restorePersistentIndexes
argument_list|()
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the model item index for the given \a path. */
end_comment
begin_function
DECL|function|index
name|QModelIndex
name|QDirModel
operator|::
name|index
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
operator|||
name|path
operator|==
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QFileDialog"
argument_list|,
literal|"My Computer"
argument_list|)
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QString
name|absolutePath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|absolutePath
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|absolutePath
operator|=
name|absolutePath
operator|.
name|toLower
argument_list|()
expr_stmt|;
comment|// On Windows, "filename......." and "filename" are equivalent
if|if
condition|(
name|absolutePath
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|absolutePath
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|absolutePath
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
break|break;
block|}
name|absolutePath
operator|=
name|absolutePath
operator|.
name|left
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QStringList
name|pathElements
init|=
name|absolutePath
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pathElements
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|QFileInfo
argument_list|(
name|path
argument_list|)
operator|.
name|exists
argument_list|()
operator|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
name|path
operator|!=
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
endif|#
directive|endif
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QModelIndex
name|idx
decl_stmt|;
comment|// start with "My Computer"
if|if
condition|(
operator|!
name|d
operator|->
name|root
operator|.
name|populated
condition|)
comment|// make sure the root is populated
name|d
operator|->
name|populate
argument_list|(
operator|&
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|absolutePath
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
argument_list|)
condition|)
block|{
comment|// UNC path
name|QString
name|host
init|=
name|pathElements
operator|.
name|first
argument_list|()
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|d
operator|->
name|root
operator|.
name|children
operator|.
name|count
argument_list|()
condition|;
operator|++
name|r
control|)
if|if
condition|(
name|d
operator|->
name|root
operator|.
name|children
operator|.
name|at
argument_list|(
name|r
argument_list|)
operator|.
name|info
operator|.
name|fileName
argument_list|()
operator|==
name|host
condition|)
break|break;
name|bool
name|childAppended
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|r
operator|>=
name|d
operator|->
name|root
operator|.
name|children
operator|.
name|count
argument_list|()
operator|&&
name|d
operator|->
name|allowAppendChild
condition|)
block|{
name|d
operator|->
name|appendChild
argument_list|(
operator|&
name|d
operator|->
name|root
argument_list|,
name|QLatin1String
argument_list|(
literal|"//"
argument_list|)
operator|+
name|host
argument_list|)
expr_stmt|;
name|childAppended
operator|=
literal|true
expr_stmt|;
block|}
name|idx
operator|=
name|index
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
name|pathElements
operator|.
name|pop_front
argument_list|()
expr_stmt|;
if|if
condition|(
name|childAppended
condition|)
emit|emit
cast|const_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|layoutChanged
argument_list|()
emit|;
block|}
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|pathElements
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|pathElements
index|[
literal|0
index|]
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|// add the "/" item, since it is a valid path element on unix
name|pathElements
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pathElements
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|pathElements
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|element
init|=
name|pathElements
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|parent
init|=
operator|(
name|idx
operator|.
name|isValid
argument_list|()
condition|?
name|d
operator|->
name|node
argument_list|(
name|idx
argument_list|)
else|:
operator|&
name|d
operator|->
name|root
operator|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|populated
condition|)
name|d
operator|->
name|populate
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// search for the element in the child nodes first
name|int
name|row
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|parent
operator|->
name|children
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
specifier|const
name|QFileInfo
modifier|&
name|fi
init|=
name|parent
operator|->
name|children
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|info
decl_stmt|;
name|QString
name|childFileName
decl_stmt|;
name|childFileName
operator|=
name|idx
operator|.
name|isValid
argument_list|()
condition|?
name|fi
operator|.
name|fileName
argument_list|()
else|:
name|fi
operator|.
name|absoluteFilePath
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|childFileName
operator|=
name|childFileName
operator|.
name|toLower
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|childFileName
operator|==
name|element
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|pathElements
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|)
name|parent
operator|->
name|children
index|[
name|j
index|]
operator|.
name|stat
operator|=
literal|true
expr_stmt|;
name|row
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
comment|// we couldn't find the path element, we create a new node since we _know_ that the path is valid
if|if
condition|(
name|row
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|newPath
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|info
operator|.
name|isRoot
argument_list|()
condition|)
name|newPath
operator|=
name|parent
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
operator|+
name|element
expr_stmt|;
else|else
name|newPath
operator|=
name|parent
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|element
expr_stmt|;
else|#
directive|else
name|QString
name|newPath
init|=
name|parent
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|element
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|allowAppendChild
operator|||
operator|!
name|QFileInfo
argument_list|(
name|newPath
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|d
operator|->
name|appendChild
argument_list|(
name|parent
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
name|row
operator|=
name|parent
operator|->
name|children
operator|.
name|count
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pathElements
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|)
comment|// always stat children of  the last element
name|parent
operator|->
name|children
index|[
name|row
index|]
operator|.
name|stat
operator|=
literal|true
expr_stmt|;
emit|emit
cast|const_cast
argument_list|<
name|QDirModel
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|layoutChanged
argument_list|()
emit|;
block|}
name|Q_ASSERT
argument_list|(
name|row
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|idx
operator|=
name|createIndex
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|parent
operator|->
name|children
index|[
name|row
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|idx
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|!=
literal|0
condition|)
return|return
name|idx
operator|.
name|sibling
argument_list|(
name|idx
operator|.
name|row
argument_list|()
argument_list|,
name|column
argument_list|)
return|;
return|return
name|idx
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the model item \a index represents a directory;   otherwise returns \c false. */
end_comment
begin_function
DECL|function|isDir
name|bool
name|QDirModel
operator|::
name|isDir
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|node
operator|->
name|info
operator|.
name|isDir
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Create a directory with the \a name in the \a parent model item. */
end_comment
begin_function
DECL|function|mkdir
name|QModelIndex
name|QDirModel
operator|::
name|mkdir
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|parent
argument_list|)
operator|||
name|isReadOnly
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
name|d
operator|->
name|node
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|QString
name|path
init|=
name|p
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
comment|// For the indexOf() method to work, the new directory has to be a direct child of
comment|// the parent directory.
name|QDir
name|newDir
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|QDir
name|dir
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|newDir
operator|.
name|isRelative
argument_list|()
condition|)
name|newDir
operator|=
name|QDir
argument_list|(
name|path
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|name
argument_list|)
expr_stmt|;
name|QString
name|childName
init|=
name|newDir
operator|.
name|dirName
argument_list|()
decl_stmt|;
comment|// Get the singular name of the directory
name|newDir
operator|.
name|cdUp
argument_list|()
expr_stmt|;
if|if
condition|(
name|newDir
operator|.
name|absolutePath
argument_list|()
operator|!=
name|dir
operator|.
name|absolutePath
argument_list|()
operator|||
operator|!
name|dir
operator|.
name|mkdir
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
comment|// nothing happened
name|refresh
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|QStringList
name|entryList
init|=
name|d
operator|->
name|entryList
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|entryList
operator|.
name|indexOf
argument_list|(
name|childName
argument_list|)
decl_stmt|;
name|QModelIndex
name|i
init|=
name|index
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|parent
argument_list|)
decl_stmt|;
comment|// return an invalid index
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!   Removes the directory corresponding to the model item \a index in the   directory model and \b{deletes the corresponding directory from the   file system}, returning true if successful. If the directory cannot be   removed, false is returned.    \warning This function deletes directories from the file system; it does   \b{not} move them to a location where they can be recovered.    \sa remove() */
end_comment
begin_function
DECL|function|rmdir
name|bool
name|QDirModel
operator|::
name|rmdir
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
operator|||
name|isReadOnly
argument_list|()
condition|)
return|return
literal|false
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|n
init|=
name|d_func
argument_list|()
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|info
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"rmdir: the node is not a directory"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QModelIndex
name|par
init|=
name|parent
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
name|d_func
argument_list|()
operator|->
name|node
argument_list|(
name|par
argument_list|)
decl_stmt|;
name|QDir
name|dir
init|=
name|p
operator|->
name|info
operator|.
name|dir
argument_list|()
decl_stmt|;
comment|// parent dir
name|QString
name|path
init|=
name|n
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|rmdir
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|false
return|;
name|refresh
argument_list|(
name|par
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Removes the model item \a index from the directory model and \b{deletes the   corresponding file from the file system}, returning true if successful. If the   item cannot be removed, false is returned.    \warning This function deletes files from the file system; it does \b{not}   move them to a location where they can be recovered.    \sa rmdir() */
end_comment
begin_function
DECL|function|remove
name|bool
name|QDirModel
operator|::
name|remove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
operator|||
name|isReadOnly
argument_list|()
condition|)
return|return
literal|false
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|n
init|=
name|d_func
argument_list|()
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|info
operator|.
name|isDir
argument_list|()
condition|)
return|return
literal|false
return|;
name|QModelIndex
name|par
init|=
name|parent
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|p
init|=
name|d_func
argument_list|()
operator|->
name|node
argument_list|(
name|par
argument_list|)
decl_stmt|;
name|QDir
name|dir
init|=
name|p
operator|->
name|info
operator|.
name|dir
argument_list|()
decl_stmt|;
comment|// parent dir
name|QString
name|path
init|=
name|n
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|.
name|remove
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|false
return|;
name|refresh
argument_list|(
name|par
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the path of the item stored in the model under the   \a index given.  */
end_comment
begin_function
DECL|function|filePath
name|QString
name|QDirModel
operator|::
name|filePath
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|QFileInfo
name|fi
init|=
name|fileInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|resolveSymlinks
operator|&&
name|fi
operator|.
name|isSymLink
argument_list|()
condition|)
name|fi
operator|=
name|d
operator|->
name|resolvedInfo
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
name|QDir
operator|::
name|cleanPath
argument_list|(
name|fi
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
comment|// root path
block|}
end_function
begin_comment
comment|/*!   Returns the name of the item stored in the model under the   \a index given.  */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QDirModel
operator|::
name|fileName
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|QFileInfo
name|info
init|=
name|fileInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|isRoot
argument_list|()
condition|)
return|return
name|info
operator|.
name|absoluteFilePath
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|resolveSymlinks
operator|&&
name|info
operator|.
name|isSymLink
argument_list|()
condition|)
name|info
operator|=
name|d
operator|->
name|resolvedInfo
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|info
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the icons for the item stored in the model under the given   \a index. */
end_comment
begin_function
DECL|function|fileIcon
name|QIcon
name|QDirModel
operator|::
name|fileIcon
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|d
operator|->
name|iconProvider
operator|->
name|icon
argument_list|(
name|QFileIconProvider
operator|::
name|Computer
argument_list|)
return|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|icon
operator|.
name|isNull
argument_list|()
condition|)
name|node
operator|->
name|icon
operator|=
name|d
operator|->
name|iconProvider
operator|->
name|icon
argument_list|(
name|node
operator|->
name|info
argument_list|)
expr_stmt|;
return|return
name|node
operator|->
name|icon
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the file information for the specified model \a index.    \b{Note:} If the model index represents a symbolic link in the   underlying filing system, the file information returned will contain   information about the symbolic link itself, regardless of whether   resolveSymlinks is enabled or not.    \sa QFileInfo::symLinkTarget() */
end_comment
begin_function
DECL|function|fileInfo
name|QFileInfo
name|QDirModel
operator|::
name|fileInfo
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QDirModel
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|node
init|=
name|d
operator|->
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|node
operator|->
name|info
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QObject *QDirModel::parent() const   \internal */
end_comment
begin_comment
comment|/*   The root node is never seen outside the model. */
end_comment
begin_function
DECL|function|init
name|void
name|QDirModelPrivate
operator|::
name|init
parameter_list|()
block|{
name|filters
operator|=
name|QDir
operator|::
name|AllEntries
operator||
name|QDir
operator|::
name|NoDotAndDotDot
expr_stmt|;
name|sort
operator|=
name|QDir
operator|::
name|Name
expr_stmt|;
name|nameFilters
operator|<<
name|QLatin1String
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|root
operator|.
name|parent
operator|=
literal|0
expr_stmt|;
name|root
operator|.
name|info
operator|=
name|QFileInfo
argument_list|()
expr_stmt|;
name|clear
argument_list|(
operator|&
name|root
argument_list|)
expr_stmt|;
name|roleNames
operator|.
name|insertMulti
argument_list|(
name|QDirModel
operator|::
name|FileIconRole
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"fileIcon"
argument_list|)
argument_list|)
expr_stmt|;
comment|// == Qt::decoration
name|roleNames
operator|.
name|insert
argument_list|(
name|QDirModel
operator|::
name|FilePathRole
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"filePath"
argument_list|)
argument_list|)
expr_stmt|;
name|roleNames
operator|.
name|insert
argument_list|(
name|QDirModel
operator|::
name|FileNameRole
argument_list|,
name|QByteArrayLiteral
argument_list|(
literal|"fileName"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|node
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|QDirModelPrivate
operator|::
name|node
parameter_list|(
name|int
name|row
parameter_list|,
name|QDirNode
modifier|*
name|parent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|row
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|bool
name|isDir
init|=
operator|!
name|parent
operator|||
name|parent
operator|->
name|info
operator|.
name|isDir
argument_list|()
decl_stmt|;
name|QDirNode
modifier|*
name|p
init|=
operator|(
name|parent
condition|?
name|parent
else|:
operator|&
name|root
operator|)
decl_stmt|;
if|if
condition|(
name|isDir
operator|&&
operator|!
name|p
operator|->
name|populated
condition|)
name|populate
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// will also resolve symlinks
if|if
condition|(
name|row
operator|>=
name|p
operator|->
name|children
operator|.
name|count
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"node: the row does not exist"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
cast|const_cast
argument_list|<
name|QDirNode
operator|*
argument_list|>
argument_list|(
operator|&
name|p
operator|->
name|children
operator|.
name|at
argument_list|(
name|row
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|children
name|QVector
argument_list|<
name|QDirModelPrivate
operator|::
name|QDirNode
argument_list|>
name|QDirModelPrivate
operator|::
name|children
parameter_list|(
name|QDirNode
modifier|*
name|parent
parameter_list|,
name|bool
name|stat
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|QFileInfoList
name|infoList
decl_stmt|;
if|if
condition|(
name|parent
operator|==
operator|&
name|root
condition|)
block|{
name|parent
operator|=
literal|0
expr_stmt|;
name|infoList
operator|=
name|QDir
operator|::
name|drives
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|info
operator|.
name|isDir
argument_list|()
condition|)
block|{
comment|//resolve directory links only if requested.
if|if
condition|(
name|parent
operator|->
name|info
operator|.
name|isSymLink
argument_list|()
operator|&&
name|resolveSymlinks
condition|)
block|{
name|QString
name|link
init|=
name|parent
operator|->
name|info
operator|.
name|symLinkTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|link
operator|.
name|at
argument_list|(
name|link
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|QDir
operator|::
name|separator
argument_list|()
condition|)
name|link
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
condition|)
name|infoList
operator|=
name|entryInfoList
argument_list|(
name|link
argument_list|)
expr_stmt|;
else|else
name|infoList
operator|=
name|QDir
argument_list|(
name|link
argument_list|)
operator|.
name|entryInfoList
argument_list|(
name|nameFilters
argument_list|,
name|QDir
operator|::
name|AllEntries
operator||
name|QDir
operator|::
name|System
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stat
condition|)
name|infoList
operator|=
name|entryInfoList
argument_list|(
name|parent
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|infoList
operator|=
name|QDir
argument_list|(
name|parent
operator|->
name|info
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
operator|.
name|entryInfoList
argument_list|(
name|nameFilters
argument_list|,
name|QDir
operator|::
name|AllEntries
operator||
name|QDir
operator|::
name|System
argument_list|)
expr_stmt|;
block|}
block|}
name|QVector
argument_list|<
name|QDirNode
argument_list|>
name|nodes
argument_list|(
name|infoList
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infoList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QDirNode
modifier|&
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|node
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|node
operator|.
name|info
operator|=
name|infoList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|node
operator|.
name|populated
operator|=
literal|false
expr_stmt|;
name|node
operator|.
name|stat
operator|=
name|shouldStat
expr_stmt|;
block|}
return|return
name|nodes
return|;
block|}
end_function
begin_function
DECL|function|_q_refresh
name|void
name|QDirModelPrivate
operator|::
name|_q_refresh
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|q
operator|->
name|refresh
argument_list|(
name|toBeRefreshed
argument_list|)
expr_stmt|;
name|toBeRefreshed
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|savePersistentIndexes
name|void
name|QDirModelPrivate
operator|::
name|savePersistentIndexes
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|savedPersistent
operator|.
name|clear
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|QPersistentModelIndexData
modifier|*
name|data
decl|,
name|persistent
operator|.
name|indexes
control|)
block|{
name|SavedPersistent
name|saved
decl_stmt|;
name|QModelIndex
name|index
init|=
name|data
operator|->
name|index
decl_stmt|;
name|saved
operator|.
name|path
operator|=
name|q
operator|->
name|filePath
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|saved
operator|.
name|column
operator|=
name|index
operator|.
name|column
argument_list|()
expr_stmt|;
name|saved
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|saved
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|savedPersistent
operator|.
name|append
argument_list|(
name|saved
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|restorePersistentIndexes
name|void
name|QDirModelPrivate
operator|::
name|restorePersistentIndexes
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QDirModel
argument_list|)
expr_stmt|;
name|bool
name|allow
init|=
name|allowAppendChild
decl_stmt|;
name|allowAppendChild
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|savedPersistent
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
name|savedPersistent
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|data
decl_stmt|;
name|QString
name|path
init|=
name|savedPersistent
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|path
decl_stmt|;
name|int
name|column
init|=
name|savedPersistent
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|column
decl_stmt|;
name|QModelIndex
name|idx
init|=
name|q
operator|->
name|index
argument_list|(
name|path
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
name|data
operator|->
name|index
operator|||
name|data
operator|->
name|model
operator|==
literal|0
condition|)
block|{
comment|//data->model may be equal to 0 if the model is getting destroyed
name|persistent
operator|.
name|indexes
operator|.
name|remove
argument_list|(
name|data
operator|->
name|index
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|idx
expr_stmt|;
name|data
operator|->
name|model
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|idx
operator|.
name|isValid
argument_list|()
condition|)
name|persistent
operator|.
name|indexes
operator|.
name|insert
argument_list|(
name|idx
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|savedPersistent
operator|.
name|clear
argument_list|()
expr_stmt|;
name|allowAppendChild
operator|=
name|allow
expr_stmt|;
block|}
end_function
begin_function
DECL|function|entryInfoList
name|QFileInfoList
name|QDirModelPrivate
operator|::
name|entryInfoList
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
specifier|const
name|QDir
name|dir
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|dir
operator|.
name|entryInfoList
argument_list|(
name|nameFilters
argument_list|,
name|filters
argument_list|,
name|sort
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|entryList
name|QStringList
name|QDirModelPrivate
operator|::
name|entryList
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
specifier|const
name|QDir
name|dir
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|dir
operator|.
name|entryList
argument_list|(
name|nameFilters
argument_list|,
name|filters
argument_list|,
name|sort
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|name
name|QString
name|QDirModelPrivate
operator|::
name|name
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirNode
modifier|*
name|n
init|=
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|const
name|QFileInfo
name|info
init|=
name|n
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|isRoot
argument_list|()
condition|)
block|{
name|QString
name|name
init|=
name|info
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
comment|// UNC host
return|return
name|info
operator|.
name|fileName
argument_list|()
return|;
if|if
condition|(
name|name
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|name
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|name
return|;
block|}
return|return
name|info
operator|.
name|fileName
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|size
name|QString
name|QDirModelPrivate
operator|::
name|size
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|QDirNode
modifier|*
name|n
init|=
name|node
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|info
operator|.
name|isDir
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_MAC
return|return
name|QLatin1String
argument_list|(
literal|"--"
argument_list|)
return|;
else|#
directive|else
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
endif|#
directive|endif
comment|// Windows   - ""
comment|// OS X      - "--"
comment|// Konqueror - "4 KB"
comment|// Nautilus  - "9 items" (the number of children)
block|}
comment|// According to the Si standard KB is 1000 bytes, KiB is 1024
comment|// but on windows sizes are calulated by dividing by 1024 so we do what they do.
specifier|const
name|quint64
name|kb
init|=
literal|1024
decl_stmt|;
specifier|const
name|quint64
name|mb
init|=
literal|1024
operator|*
name|kb
decl_stmt|;
specifier|const
name|quint64
name|gb
init|=
literal|1024
operator|*
name|mb
decl_stmt|;
specifier|const
name|quint64
name|tb
init|=
literal|1024
operator|*
name|gb
decl_stmt|;
name|quint64
name|bytes
init|=
name|n
operator|->
name|info
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytes
operator|>=
name|tb
condition|)
return|return
name|QFileSystemModel
operator|::
name|tr
argument_list|(
literal|"%1 TB"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
name|qreal
argument_list|(
name|bytes
argument_list|)
operator|/
name|tb
argument_list|,
literal|'f'
argument_list|,
literal|3
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|bytes
operator|>=
name|gb
condition|)
return|return
name|QFileSystemModel
operator|::
name|tr
argument_list|(
literal|"%1 GB"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
name|qreal
argument_list|(
name|bytes
argument_list|)
operator|/
name|gb
argument_list|,
literal|'f'
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|bytes
operator|>=
name|mb
condition|)
return|return
name|QFileSystemModel
operator|::
name|tr
argument_list|(
literal|"%1 MB"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
name|qreal
argument_list|(
name|bytes
argument_list|)
operator|/
name|mb
argument_list|,
literal|'f'
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|bytes
operator|>=
name|kb
condition|)
return|return
name|QFileSystemModel
operator|::
name|tr
argument_list|(
literal|"%1 KB"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
name|bytes
operator|/
name|kb
argument_list|)
argument_list|)
return|;
return|return
name|QFileSystemModel
operator|::
name|tr
argument_list|(
literal|"%1 byte(s)"
argument_list|)
operator|.
name|arg
argument_list|(
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|type
name|QString
name|QDirModelPrivate
operator|::
name|type
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|iconProvider
operator|->
name|type
argument_list|(
name|node
argument_list|(
name|index
argument_list|)
operator|->
name|info
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|time
name|QString
name|QDirModelPrivate
operator|::
name|time
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
return|return
name|node
argument_list|(
name|index
argument_list|)
operator|->
name|info
operator|.
name|lastModified
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|LocalDate
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|appendChild
name|void
name|QDirModelPrivate
operator|::
name|appendChild
parameter_list|(
name|QDirModelPrivate
operator|::
name|QDirNode
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|QDirModelPrivate
operator|::
name|QDirNode
name|node
decl_stmt|;
name|node
operator|.
name|populated
operator|=
literal|false
expr_stmt|;
name|node
operator|.
name|stat
operator|=
name|shouldStat
expr_stmt|;
name|node
operator|.
name|parent
operator|=
operator|(
name|parent
operator|==
operator|&
name|root
condition|?
literal|0
else|:
name|parent
operator|)
expr_stmt|;
name|node
operator|.
name|info
operator|=
name|QFileInfo
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|node
operator|.
name|info
operator|.
name|setCaching
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// The following append(node) may reallocate the vector, thus
comment|// we need to update the pointers to the childnodes parent.
name|QDirModelPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QDirModelPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|savePersistentIndexes
argument_list|()
expr_stmt|;
name|parent
operator|->
name|children
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parent
operator|->
name|children
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QDirNode
modifier|*
name|childNode
init|=
operator|&
name|parent
operator|->
name|children
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childNode
operator|->
name|children
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
name|childNode
operator|->
name|children
index|[
name|j
index|]
operator|.
name|parent
operator|=
name|childNode
expr_stmt|;
block|}
name|that
operator|->
name|restorePersistentIndexes
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolvedInfo
name|QFileInfo
name|QDirModelPrivate
operator|::
name|resolvedInfo
parameter_list|(
name|QFileInfo
name|info
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// On windows, we cannot create a shortcut to a shortcut.
return|return
name|QFileInfo
argument_list|(
name|info
operator|.
name|symLinkTarget
argument_list|()
argument_list|)
return|;
else|#
directive|else
name|QStringList
name|paths
decl_stmt|;
do|do
block|{
name|QFileInfo
name|link
argument_list|(
name|info
operator|.
name|symLinkTarget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|isRelative
argument_list|()
condition|)
name|info
operator|.
name|setFile
argument_list|(
name|info
operator|.
name|absolutePath
argument_list|()
argument_list|,
name|link
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|info
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|paths
operator|.
name|contains
argument_list|(
name|info
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
condition|)
return|return
name|QFileInfo
argument_list|()
return|;
name|paths
operator|.
name|append
argument_list|(
name|info
operator|.
name|absoluteFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|info
operator|.
name|isSymLink
argument_list|()
condition|)
do|;
return|return
name|info
return|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qdirmodel.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DIRMODEL
end_comment
end_unit
