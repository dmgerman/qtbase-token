begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qstyleditemdelegate.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ITEMVIEWS
end_ifndef
begin_include
include|#
directive|include
file|<qabstractitemmodel.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qbrush.h>
end_include
begin_include
include|#
directive|include
file|<qlineedit.h>
end_include
begin_include
include|#
directive|include
file|<qtextedit.h>
end_include
begin_include
include|#
directive|include
file|<qplaintextedit.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qpalette.h>
end_include
begin_include
include|#
directive|include
file|<qpoint.h>
end_include
begin_include
include|#
directive|include
file|<qrect.h>
end_include
begin_include
include|#
directive|include
file|<qsize.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qpixmap.h>
end_include
begin_include
include|#
directive|include
file|<qbitmap.h>
end_include
begin_include
include|#
directive|include
file|<qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<qitemeditorfactory.h>
end_include
begin_include
include|#
directive|include
file|<private/qitemeditorfactory_p.h>
end_include
begin_include
include|#
directive|include
file|<qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<qtextlayout.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qdnd_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qlayoutengine_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qlocale.h>
end_include
begin_include
include|#
directive|include
file|<qdialog.h>
end_include
begin_include
include|#
directive|include
file|<qtableview.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QStyledItemDelegatePrivate
class|class
name|QStyledItemDelegatePrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QStyledItemDelegate
parameter_list|)
specifier|public
private|:
DECL|function|QStyledItemDelegatePrivate
name|QStyledItemDelegatePrivate
parameter_list|()
member_init_list|:
name|factory
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|widget
specifier|static
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|(
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|)
block|{
if|if
condition|(
specifier|const
name|QStyleOptionViewItemV3
modifier|*
name|v3
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionViewItemV3
operator|*
argument_list|>
argument_list|(
operator|&
name|option
argument_list|)
condition|)
return|return
name|v3
operator|->
name|widget
return|;
return|return
literal|0
return|;
block|}
DECL|function|editorFactory
specifier|const
name|QItemEditorFactory
modifier|*
name|editorFactory
parameter_list|()
specifier|const
block|{
return|return
name|factory
condition|?
name|factory
else|:
name|QItemEditorFactory
operator|::
name|defaultFactory
argument_list|()
return|;
block|}
DECL|function|_q_commitDataAndCloseEditor
name|void
name|_q_commitDataAndCloseEditor
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|commitData
argument_list|(
name|editor
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|SubmitModelCache
argument_list|)
emit|;
block|}
DECL|member|factory
name|QItemEditorFactory
modifier|*
name|factory
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QStyledItemDelegate      \brief The QStyledItemDelegate class provides display and editing facilities for     data items from a model.      \ingroup model-view     \inmodule QtWidgets      \since 4.4      When displaying data from models in Qt item views, e.g., a     QTableView, the individual items are drawn by a delegate. Also,     when an item is edited, it provides an editor widget, which is     placed on top of the item view while editing takes place.     QStyledItemDelegate is the default delegate for all Qt item     views, and is installed upon them when they are created.      The QStyledItemDelegate class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view     framework}. The delegate allows the display and editing of items     to be developed independently from the model and view.      The data of items in models are assigned an     \l{Qt::}{ItemDataRole}; each item can store a QVariant for each     role. QStyledItemDelegate implements display and editing for the     most common datatypes expected by users, including booleans,     integers, and strings.      The data will be drawn differently depending on which role they     have in the model. The following table describes the roles and the     data types the delegate can handle for each of them. It is often     sufficient to ensure that the model returns appropriate data for     each of the roles to determine the appearance of items in views.      \table     \header \o Role \o Accepted Types     \omit     \row    \o \l Qt::AccessibleDescriptionRole \o QString     \row    \o \l Qt::AccessibleTextRole \o QString     \endomit     \row    \o \l Qt::BackgroundRole \o QBrush     \row    \o \l Qt::BackgroundColorRole \o QColor (obsolete; use Qt::BackgroundRole instead)     \row    \o \l Qt::CheckStateRole \o Qt::CheckState     \row    \o \l Qt::DecorationRole \o QIcon, QPixmap, QImage and QColor     \row    \o \l Qt::DisplayRole \o QString and types with a string representation     \row    \o \l Qt::EditRole \o See QItemEditorFactory for details     \row    \o \l Qt::FontRole \o QFont     \row    \o \l Qt::SizeHintRole \o QSize     \omit     \row    \o \l Qt::StatusTipRole \o     \endomit     \row    \o \l Qt::TextAlignmentRole \o Qt::Alignment     \row    \o \l Qt::ForegroundRole \o QBrush     \row    \o \l Qt::TextColorRole \o QColor (obsolete; use Qt::ForegroundRole instead)     \omit     \row    \o \l Qt::ToolTipRole     \row    \o \l Qt::WhatsThisRole     \endomit     \endtable      Editors are created with a QItemEditorFactory; a default static     instance provided by QItemEditorFactory is installed on all item     delegates. You can set a custom factory using     setItemEditorFactory() or set a new default factory with     QItemEditorFactory::setDefaultFactory(). It is the data stored in     the item model with the \l{Qt::}{EditRole} that is edited. See the     QItemEditorFactory class for a more high-level introduction to     item editor factories. The \l{Color Editor Factory Example}{Color     Editor Factory} example shows how to create custom editors with a     factory.      \section1 Subclassing QStyledItemDelegate      If the delegate does not support painting of the data types you     need or you want to customize the drawing of items, you need to     subclass QStyledItemDelegate, and reimplement paint() and possibly     sizeHint(). The paint() function is called individually for each     item, and with sizeHint(), you can specify the hint for each     of them.      When reimplementing paint(), one would typically handle the     datatypes one would like to draw and use the superclass     implementation for other types.      The painting of check box indicators are performed by the current     style. The style also specifies the size and the bounding     rectangles in which to draw the data for the different data roles.     The bounding rectangle of the item itself is also calculated by     the style. When drawing already supported datatypes, it is     therefore a good idea to ask the style for these bounding     rectangles. The QStyle class description describes this in     more detail.      If you wish to change any of the bounding rectangles calculated by     the style or the painting of check box indicators, you can     subclass QStyle. Note, however, that the size of the items can     also be affected by reimplementing sizeHint().      It is possible for a custom delegate to provide editors     without the use of an editor item factory. In this case, the     following virtual functions must be reimplemented:      \list         \o createEditor() returns the widget used to change data from the model            and can be reimplemented to customize editing behavior.         \o setEditorData() provides the widget with data to manipulate.         \o updateEditorGeometry() ensures that the editor is displayed correctly            with respect to the item view.         \o setModelData() returns updated data to the model.     \endlist      The \l{Star Delegate Example}{Star Delegate} example creates     editors by reimplementing these methods.      \section1 QStyledItemDelegate vs. QItemDelegate      Since Qt 4.4, there are two delegate classes: QItemDelegate and     QStyledItemDelegate. However, the default delegate is QStyledItemDelegate.     These two classes are independent alternatives to painting and providing     editors for items in views. The difference between them is that     QStyledItemDelegate uses the current style to paint its items. We therefore     recommend using QStyledItemDelegate as the base class when implementing     custom delegates or when working with Qt style sheets. The code required     for either class should be equal unless the custom delegate needs to use     the style for drawing.      If you wish to customize the painting of item views, you should     implement a custom style. Please see the QStyle class     documentation for details.      \sa {Delegate Classes}, QItemDelegate, QAbstractItemDelegate, QStyle,         {Spin Box Delegate Example}, {Star Delegate Example}, {Color          Editor Factory Example} */
end_comment
begin_comment
comment|/*!     Constructs an item delegate with the given \a parent. */
end_comment
begin_constructor
DECL|function|QStyledItemDelegate
name|QStyledItemDelegate
operator|::
name|QStyledItemDelegate
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemDelegate
argument_list|(
operator|*
operator|new
name|QStyledItemDelegatePrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the item delegate. */
end_comment
begin_destructor
DECL|function|~QStyledItemDelegate
name|QStyledItemDelegate
operator|::
name|~
name|QStyledItemDelegate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     This function returns the string that the delegate will use to display the     Qt::DisplayRole of the model in \a locale. \a value is the value of the Qt::DisplayRole     provided by the model.      The default implementation uses the QLocale::toString to convert \a value into     a QString.      This function is not called for empty model indices, i.e., indices for which     the model returns an invalid QVariant.      \sa QAbstractItemModel::data() */
end_comment
begin_function
DECL|function|displayText
name|QString
name|QStyledItemDelegate
operator|::
name|displayText
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|QString
name|text
decl_stmt|;
switch|switch
condition|(
name|value
operator|.
name|userType
argument_list|()
condition|)
block|{
case|case
name|QMetaType
operator|::
name|Float
case|:
case|case
name|QVariant
operator|::
name|Double
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toReal
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toLongLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toULongLong
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Date
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toDate
argument_list|()
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Time
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toTime
argument_list|()
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|DateTime
case|:
name|text
operator|=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toDateTime
argument_list|()
operator|.
name|date
argument_list|()
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
name|text
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|text
operator|+=
name|locale
operator|.
name|toString
argument_list|(
name|value
operator|.
name|toDateTime
argument_list|()
operator|.
name|time
argument_list|()
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// convert new lines into line separators
name|text
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|text
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
name|text
index|[
name|i
index|]
operator|=
name|QChar
operator|::
name|LineSeparator
expr_stmt|;
block|}
break|break;
block|}
return|return
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Initialize \a option with the values using the index \a index. This method     is useful for subclasses when they need a QStyleOptionViewItem, but don't want     to fill in all the information themselves. This function will check the version     of the QStyleOptionViewItem and fill in the additional values for a     QStyleOptionViewItemV2, QStyleOptionViewItemV3 and QStyleOptionViewItemV4.      \sa QStyleOption::initFrom() */
end_comment
begin_function
DECL|function|initStyleOption
name|void
name|QStyledItemDelegate
operator|::
name|initStyleOption
parameter_list|(
name|QStyleOptionViewItem
modifier|*
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|QVariant
name|value
init|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|FontRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|option
operator|->
name|font
operator|=
name|qvariant_cast
argument_list|<
name|QFont
argument_list|>
argument_list|(
name|value
argument_list|)
operator|.
name|resolve
argument_list|(
name|option
operator|->
name|font
argument_list|)
expr_stmt|;
name|option
operator|->
name|fontMetrics
operator|=
name|QFontMetrics
argument_list|(
name|option
operator|->
name|font
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|TextAlignmentRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|isNull
argument_list|()
condition|)
name|option
operator|->
name|displayAlignment
operator|=
name|Qt
operator|::
name|Alignment
argument_list|(
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|ForegroundRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|canConvert
argument_list|<
name|QBrush
argument_list|>
argument_list|()
condition|)
name|option
operator|->
name|palette
operator|.
name|setBrush
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|,
name|qvariant_cast
argument_list|<
name|QBrush
argument_list|>
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QStyleOptionViewItemV4
modifier|*
name|v4
init|=
name|qstyleoption_cast
argument_list|<
name|QStyleOptionViewItemV4
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|v4
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|QVariant
name|value
init|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|CheckStateRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|v4
operator|->
name|features
operator||=
name|QStyleOptionViewItemV2
operator|::
name|HasCheckIndicator
expr_stmt|;
name|v4
operator|->
name|checkState
operator|=
cast|static_cast
argument_list|<
name|Qt
operator|::
name|CheckState
argument_list|>
argument_list|(
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|DecorationRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|v4
operator|->
name|features
operator||=
name|QStyleOptionViewItemV2
operator|::
name|HasDecoration
expr_stmt|;
switch|switch
condition|(
name|value
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|Icon
case|:
block|{
name|v4
operator|->
name|icon
operator|=
name|qvariant_cast
argument_list|<
name|QIcon
argument_list|>
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|QIcon
operator|::
name|Mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Enabled
operator|)
condition|)
name|mode
operator|=
name|QIcon
operator|::
name|Disabled
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|mode
operator|=
name|QIcon
operator|::
name|Selected
expr_stmt|;
else|else
name|mode
operator|=
name|QIcon
operator|::
name|Normal
expr_stmt|;
name|QIcon
operator|::
name|State
name|state
init|=
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Open
condition|?
name|QIcon
operator|::
name|On
else|:
name|QIcon
operator|::
name|Off
decl_stmt|;
name|v4
operator|->
name|decorationSize
operator|=
name|v4
operator|->
name|icon
operator|.
name|actualSize
argument_list|(
name|option
operator|->
name|decorationSize
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Color
case|:
block|{
name|QPixmap
name|pixmap
argument_list|(
name|option
operator|->
name|decorationSize
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|qvariant_cast
argument_list|<
name|QColor
argument_list|>
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|v4
operator|->
name|icon
operator|=
name|QIcon
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Image
case|:
block|{
name|QImage
name|image
init|=
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|v4
operator|->
name|icon
operator|=
name|QIcon
argument_list|(
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|v4
operator|->
name|decorationSize
operator|=
name|image
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QVariant
operator|::
name|Pixmap
case|:
block|{
name|QPixmap
name|pixmap
init|=
name|qvariant_cast
argument_list|<
name|QPixmap
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|v4
operator|->
name|icon
operator|=
name|QIcon
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
name|v4
operator|->
name|decorationSize
operator|=
name|pixmap
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
name|value
operator|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|DisplayRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|v4
operator|->
name|features
operator||=
name|QStyleOptionViewItemV2
operator|::
name|HasDisplay
expr_stmt|;
name|v4
operator|->
name|text
operator|=
name|displayText
argument_list|(
name|value
argument_list|,
name|v4
operator|->
name|locale
argument_list|)
expr_stmt|;
block|}
name|v4
operator|->
name|backgroundBrush
operator|=
name|qvariant_cast
argument_list|<
name|QBrush
argument_list|>
argument_list|(
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|BackgroundRole
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Renders the delegate using the given \a painter and style \a option for     the item specified by \a index.      This function paints the item using the view's QStyle.      When reimplementing paint in a subclass. Use the initStyleOption()     to set up the \a option in the same way as the     QStyledItemDelegate; the option will always be an instance of     QStyleOptionViewItemV4. Please see its class description for     information on its contents.      Whenever possible, use the \a option while painting.     Especially its \l{QStyleOption::}{rect} variable to decide     where to draw and its \l{QStyleOption::}{state} to determine     if it is enabled or selected.      After painting, you should ensure that the painter is returned to     its the state it was supplied in when this function was called.     For example, it may be useful to call QPainter::save() before     painting and QPainter::restore() afterwards.      \sa QItemDelegate::paint(), QStyle::drawControl(), QStyle::CE_ItemViewItem */
end_comment
begin_function
DECL|function|paint
name|void
name|QStyledItemDelegate
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QStyleOptionViewItemV4
name|opt
init|=
name|option
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|widget
init|=
name|QStyledItemDelegatePrivate
operator|::
name|widget
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|widget
condition|?
name|widget
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
decl_stmt|;
name|style
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_ItemViewItem
argument_list|,
operator|&
name|opt
argument_list|,
name|painter
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the size needed by the delegate to display the item     specified by \a index, taking into account the style information     provided by \a option.      This function uses the view's QStyle to determine the size of the     item.      \sa QStyle::sizeFromContents(), QStyle::CT_ItemViewItem */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QStyledItemDelegate
operator|::
name|sizeHint
parameter_list|(
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|QVariant
name|value
init|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|SizeHintRole
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|qvariant_cast
argument_list|<
name|QSize
argument_list|>
argument_list|(
name|value
argument_list|)
return|;
name|QStyleOptionViewItemV4
name|opt
init|=
name|option
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|widget
init|=
name|QStyledItemDelegatePrivate
operator|::
name|widget
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|widget
condition|?
name|widget
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
decl_stmt|;
return|return
name|style
operator|->
name|sizeFromContents
argument_list|(
name|QStyle
operator|::
name|CT_ItemViewItem
argument_list|,
operator|&
name|opt
argument_list|,
name|QSize
argument_list|()
argument_list|,
name|widget
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget used to edit the item specified by \a index     for editing. The \a parent widget and style \a option are used to     control how the editor widget appears.      \sa QAbstractItemDelegate::createEditor() */
end_comment
begin_function
DECL|function|createEditor
name|QWidget
modifier|*
name|QStyledItemDelegate
operator|::
name|createEditor
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QVariant
operator|::
name|Type
name|t
init|=
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|EditRole
argument_list|)
operator|.
name|userType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|editorFactory
argument_list|()
operator|->
name|createEditor
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data to be displayed and edited by the \a editor from the     data model item specified by the model \a index.      The default implementation stores the data in the \a editor     widget's \l {Qt's Property System} {user property}.      \sa QMetaProperty::isUser() */
end_comment
begin_function
DECL|function|setEditorData
name|void
name|QStyledItemDelegate
operator|::
name|setEditorData
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROPERTIES
name|Q_UNUSED
argument_list|(
name|editor
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
specifier|const
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
name|QVariant
name|v
init|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|EditRole
argument_list|)
decl_stmt|;
name|QByteArray
name|n
init|=
name|editor
operator|->
name|metaObject
argument_list|()
operator|->
name|userProperty
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
comment|// ### Qt 5: remove
comment|// A work-around for missing "USER true" in qdatetimeedit.h for
comment|// QTimeEdit's time property and QDateEdit's date property.
comment|// It only triggers if the default user property "dateTime" is
comment|// reported for QTimeEdit and QDateEdit.
if|if
condition|(
name|n
operator|==
literal|"dateTime"
condition|)
block|{
if|if
condition|(
name|editor
operator|->
name|inherits
argument_list|(
literal|"QTimeEdit"
argument_list|)
condition|)
name|n
operator|=
literal|"time"
expr_stmt|;
elseif|else
if|if
condition|(
name|editor
operator|->
name|inherits
argument_list|(
literal|"QDateEdit"
argument_list|)
condition|)
name|n
operator|=
literal|"date"
expr_stmt|;
block|}
comment|// ### Qt 5: give QComboBox a USER property
if|if
condition|(
name|n
operator|.
name|isEmpty
argument_list|()
operator|&&
name|editor
operator|->
name|inherits
argument_list|(
literal|"QComboBox"
argument_list|)
condition|)
name|n
operator|=
name|d
operator|->
name|editorFactory
argument_list|()
operator|->
name|valuePropertyName
argument_list|(
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|v
operator|.
name|userType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|v
operator|.
name|isValid
argument_list|()
condition|)
name|v
operator|=
name|QVariant
argument_list|(
name|editor
operator|->
name|property
argument_list|(
name|n
argument_list|)
operator|.
name|userType
argument_list|()
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|editor
operator|->
name|setProperty
argument_list|(
name|n
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Gets data from the \a editor widget and stores it in the specified     \a model at the item \a index.      The default implementation gets the value to be stored in the data     model from the \a editor widget's \l {Qt's Property System} {user     property}.      \sa QMetaProperty::isUser() */
end_comment
begin_function
DECL|function|setModelData
name|void
name|QStyledItemDelegate
operator|::
name|setModelData
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|,
name|QAbstractItemModel
modifier|*
name|model
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_NO_PROPERTIES
name|Q_UNUSED
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|editor
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
specifier|const
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|editor
argument_list|)
expr_stmt|;
name|QByteArray
name|n
init|=
name|editor
operator|->
name|metaObject
argument_list|()
operator|->
name|userProperty
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|isEmpty
argument_list|()
condition|)
name|n
operator|=
name|d
operator|->
name|editorFactory
argument_list|()
operator|->
name|valuePropertyName
argument_list|(
cast|static_cast
argument_list|<
name|QVariant
operator|::
name|Type
argument_list|>
argument_list|(
name|model
operator|->
name|data
argument_list|(
name|index
argument_list|,
name|Qt
operator|::
name|EditRole
argument_list|)
operator|.
name|userType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isEmpty
argument_list|()
condition|)
name|model
operator|->
name|setData
argument_list|(
name|index
argument_list|,
name|editor
operator|->
name|property
argument_list|(
name|n
argument_list|)
argument_list|,
name|Qt
operator|::
name|EditRole
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Updates the \a editor for the item specified by \a index     according to the style \a option given. */
end_comment
begin_function
DECL|function|updateEditorGeometry
name|void
name|QStyledItemDelegate
operator|::
name|updateEditorGeometry
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|editor
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QWidget
modifier|*
name|widget
init|=
name|QStyledItemDelegatePrivate
operator|::
name|widget
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|QStyleOptionViewItemV4
name|opt
init|=
name|option
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|opt
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// let the editor take up all available space
comment|//if the editor is not a QLineEdit
comment|//or it is in a QTableView
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TABLEVIEW
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_LINEEDIT
argument_list|)
if|if
condition|(
name|qobject_cast
argument_list|<
name|QExpandingLineEdit
operator|*
argument_list|>
argument_list|(
name|editor
argument_list|)
operator|&&
operator|!
name|qobject_cast
argument_list|<
specifier|const
name|QTableView
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
name|opt
operator|.
name|showDecorationSelected
operator|=
name|editor
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ItemView_ShowDecorationSelected
argument_list|,
literal|0
argument_list|,
name|editor
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|opt
operator|.
name|showDecorationSelected
operator|=
literal|true
expr_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|widget
condition|?
name|widget
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
decl_stmt|;
name|QRect
name|geom
init|=
name|style
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_ItemViewItemText
argument_list|,
operator|&
name|opt
argument_list|,
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|editor
operator|->
name|layoutDirection
argument_list|()
operator|==
name|Qt
operator|::
name|RightToLeft
condition|)
block|{
specifier|const
name|int
name|delta
init|=
name|qSmartMinSize
argument_list|(
name|editor
argument_list|)
operator|.
name|width
argument_list|()
operator|-
name|geom
operator|.
name|width
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|//we need to widen the geometry
name|geom
operator|.
name|adjust
argument_list|(
operator|-
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|editor
operator|->
name|setGeometry
argument_list|(
name|geom
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the editor factory used by the item delegate.   If no editor factory is set, the function will return null.    \sa setItemEditorFactory() */
end_comment
begin_function
DECL|function|itemEditorFactory
name|QItemEditorFactory
modifier|*
name|QStyledItemDelegate
operator|::
name|itemEditorFactory
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|factory
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the editor factory to be used by the item delegate to be the \a factory   specified. If no editor factory is set, the item delegate will use the   default editor factory.    \sa itemEditorFactory() */
end_comment
begin_function
DECL|function|setItemEditorFactory
name|void
name|QStyledItemDelegate
operator|::
name|setItemEditorFactory
parameter_list|(
name|QItemEditorFactory
modifier|*
name|factory
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QStyledItemDelegate
argument_list|)
expr_stmt|;
name|d
operator|->
name|factory
operator|=
name|factory
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QStyledItemDelegate::eventFilter(QObject *editor, QEvent *event)      Returns true if the given \a editor is a valid QWidget and the     given \a event is handled; otherwise returns false. The following     key press events are handled by default:      \list         \o \gui Tab         \o \gui Backtab         \o \gui Enter         \o \gui Return         \o \gui Esc     \endlist      In the case of \gui Tab, \gui Backtab, \gui Enter and \gui Return     key press events, the \a editor's data is comitted to the model     and the editor is closed. If the \a event is a \gui Tab key press     the view will open an editor on the next item in the     view. Likewise, if the \a event is a \gui Backtab key press the     view will open an editor on the \e previous item in the view.      If the event is a \gui Esc key press event, the \a editor is     closed \e without committing its data.      \sa commitData(), closeEditor() */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QStyledItemDelegate
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|QWidget
modifier|*
name|editor
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|editor
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
switch|switch
condition|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Tab
case|:
emit|emit
name|commitData
argument_list|(
name|editor
argument_list|)
emit|;
emit|emit
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EditNextItem
argument_list|)
emit|;
return|return
literal|true
return|;
case|case
name|Qt
operator|::
name|Key_Backtab
case|:
emit|emit
name|commitData
argument_list|(
name|editor
argument_list|)
emit|;
emit|emit
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EditPreviousItem
argument_list|)
emit|;
return|return
literal|true
return|;
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
ifndef|#
directive|ifndef
name|QT_NO_TEXTEDIT
if|if
condition|(
name|qobject_cast
argument_list|<
name|QTextEdit
operator|*
argument_list|>
argument_list|(
name|editor
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QPlainTextEdit
operator|*
argument_list|>
argument_list|(
name|editor
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// don't filter enter key events for QTextEdit
comment|// We want the editor to be able to process the key press
comment|// before committing the data (e.g. so it can do
comment|// validation/fixup of the input).
endif|#
directive|endif
comment|// QT_NO_TEXTEDIT
ifndef|#
directive|ifndef
name|QT_NO_LINEEDIT
if|if
condition|(
name|QLineEdit
modifier|*
name|e
init|=
name|qobject_cast
argument_list|<
name|QLineEdit
operator|*
argument_list|>
argument_list|(
name|editor
argument_list|)
condition|)
if|if
condition|(
operator|!
name|e
operator|->
name|hasAcceptableInput
argument_list|()
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
comment|// QT_NO_LINEEDIT
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_commitDataAndCloseEditor"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QWidget
operator|*
argument_list|,
name|editor
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
case|case
name|Qt
operator|::
name|Key_Escape
case|:
comment|// don't commit data
emit|emit
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|RevertModelCache
argument_list|)
emit|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
if|if
condition|(
name|editor
operator|->
name|parentWidget
argument_list|()
condition|)
name|editor
operator|->
name|parentWidget
argument_list|()
operator|->
name|setFocus
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FocusOut
operator|||
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Hide
operator|&&
name|editor
operator|->
name|isWindow
argument_list|()
operator|)
condition|)
block|{
comment|//the Hide event will take care of he editors that are in fact complete dialogs
if|if
condition|(
operator|!
name|editor
operator|->
name|isActiveWindow
argument_list|()
operator|||
operator|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|!=
name|editor
operator|)
condition|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
while|while
condition|(
name|w
condition|)
block|{
comment|// don't worry about focus changes internally in the editor
if|if
condition|(
name|w
operator|==
name|editor
condition|)
return|return
literal|false
return|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
comment|// The window may lose focus during an drag operation.
comment|// i.e when dragging involves the taskbar on Windows.
if|if
condition|(
name|QDragManager
operator|::
name|self
argument_list|()
operator|&&
name|QDragManager
operator|::
name|self
argument_list|()
operator|->
name|object
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
emit|emit
name|commitData
argument_list|(
name|editor
argument_list|)
emit|;
emit|emit
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|NoHint
argument_list|)
emit|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ShortcutOverride
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Escape
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|editorEvent
name|bool
name|QStyledItemDelegate
operator|::
name|editorEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QAbstractItemModel
modifier|*
name|model
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|model
argument_list|)
expr_stmt|;
comment|// make sure that the item is checkable
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|model
operator|->
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsUserCheckable
operator|)
operator|||
operator|!
operator|(
name|option
operator|.
name|state
operator|&
name|QStyle
operator|::
name|State_Enabled
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
condition|)
return|return
literal|false
return|;
comment|// make sure that we have a check state
name|QVariant
name|value
init|=
name|index
operator|.
name|data
argument_list|(
name|Qt
operator|::
name|CheckStateRole
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QWidget
modifier|*
name|widget
init|=
name|QStyledItemDelegatePrivate
operator|::
name|widget
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|widget
condition|?
name|widget
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
decl_stmt|;
comment|// make sure that we have the right event type
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|)
operator|||
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonDblClick
operator|)
operator|||
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|)
condition|)
block|{
name|QStyleOptionViewItemV4
name|viewOpt
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|viewOpt
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|QRect
name|checkRect
init|=
name|style
operator|->
name|subElementRect
argument_list|(
name|QStyle
operator|::
name|SE_ItemViewItemCheckIndicator
argument_list|,
operator|&
name|viewOpt
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|QMouseEvent
modifier|*
name|me
init|=
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|me
operator|->
name|button
argument_list|()
operator|!=
name|Qt
operator|::
name|LeftButton
operator|||
operator|!
name|checkRect
operator|.
name|contains
argument_list|(
name|me
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|)
operator|||
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonDblClick
operator|)
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
condition|)
block|{
if|if
condition|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Space
operator|&&
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
operator|!=
name|Qt
operator|::
name|Key_Select
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
name|Qt
operator|::
name|CheckState
name|state
init|=
operator|(
cast|static_cast
argument_list|<
name|Qt
operator|::
name|CheckState
argument_list|>
argument_list|(
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|Qt
operator|::
name|Checked
condition|?
name|Qt
operator|::
name|Unchecked
else|:
name|Qt
operator|::
name|Checked
operator|)
decl_stmt|;
return|return
name|model
operator|->
name|setData
argument_list|(
name|index
argument_list|,
name|state
argument_list|,
name|Qt
operator|::
name|CheckStateRole
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qstyleditemdelegate.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ITEMVIEWS
end_comment
end_unit
