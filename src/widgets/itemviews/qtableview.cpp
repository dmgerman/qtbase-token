begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtableview.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_include
include|#
directive|include
file|<qheaderview.h>
end_include
begin_include
include|#
directive|include
file|<qitemdelegate.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qsize.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<qscrollbar.h>
end_include
begin_include
include|#
directive|include
file|<qabstractbutton.h>
end_include
begin_include
include|#
directive|include
file|<private/qtableview_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qheaderview_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|<qaccessible.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
comment|/** \internal   Add a span to the collection. the collection takes the ownership.   */
DECL|function|addSpan
name|void
name|QSpanCollection
operator|::
name|addSpan
parameter_list|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
parameter_list|)
block|{
name|spans
operator|.
name|append
argument_list|(
name|span
argument_list|)
expr_stmt|;
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|lowerBound
argument_list|(
operator|-
name|span
operator|->
name|top
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|end
argument_list|()
operator|||
name|it_y
operator|.
name|key
argument_list|()
operator|!=
operator|-
name|span
operator|->
name|top
argument_list|()
condition|)
block|{
comment|//there is no spans that starts with the row in the index, so create a sublist for it.
name|SubIndex
name|sub_index
decl_stmt|;
if|if
condition|(
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
condition|)
block|{
comment|//the previouslist is the list of spans that sarts _before_ the row of the span.
comment|// and which may intersect this row.
specifier|const
name|SubIndex
name|previousList
init|=
name|it_y
operator|.
name|value
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|Span
modifier|*
name|s
decl|,
name|previousList
control|)
block|{
comment|//If a subspans intersect the row, we need to split it into subspans
if|if
condition|(
name|s
operator|->
name|bottom
argument_list|()
operator|>=
name|span
operator|->
name|top
argument_list|()
condition|)
name|sub_index
operator|.
name|insert
argument_list|(
operator|-
name|s
operator|->
name|left
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|it_y
operator|=
name|index
operator|.
name|insert
argument_list|(
operator|-
name|span
operator|->
name|top
argument_list|()
argument_list|,
name|sub_index
argument_list|)
expr_stmt|;
comment|//we will insert span to *it_y in the later loop
block|}
comment|//insert the span as supspan in all the lists that intesects the span
while|while
condition|(
operator|-
name|it_y
operator|.
name|key
argument_list|()
operator|<=
name|span
operator|->
name|bottom
argument_list|()
condition|)
block|{
operator|(
operator|*
name|it_y
operator|)
operator|.
name|insert
argument_list|(
operator|-
name|span
operator|->
name|left
argument_list|()
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|begin
argument_list|()
condition|)
break|break;
operator|--
name|it_y
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/** \internal * Has to be called after the height and width of a span is changed. * * old_height is the height before the change * * if the size of the span is now 0x0 the span will be deleted. */
end_comment
begin_function
DECL|function|updateSpan
name|void
name|QSpanCollection
operator|::
name|updateSpan
parameter_list|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
parameter_list|,
name|int
name|old_height
parameter_list|)
block|{
if|if
condition|(
name|old_height
operator|<
name|span
operator|->
name|height
argument_list|()
condition|)
block|{
comment|//add the span as subspan in all the lists that intersect the new covered columns
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|lowerBound
argument_list|(
operator|-
operator|(
name|span
operator|->
name|top
argument_list|()
operator|+
name|old_height
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|//it_y must exist since the span is in the list
while|while
condition|(
operator|-
name|it_y
operator|.
name|key
argument_list|()
operator|<=
name|span
operator|->
name|bottom
argument_list|()
condition|)
block|{
operator|(
operator|*
name|it_y
operator|)
operator|.
name|insert
argument_list|(
operator|-
name|span
operator|->
name|left
argument_list|()
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|begin
argument_list|()
condition|)
break|break;
operator|--
name|it_y
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|old_height
operator|>
name|span
operator|->
name|height
argument_list|()
condition|)
block|{
comment|//remove the span from all the subspans lists that intersect the columns not covered anymore
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|lowerBound
argument_list|(
operator|-
name|qMax
argument_list|(
name|span
operator|->
name|bottom
argument_list|()
argument_list|,
name|span
operator|->
name|top
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|//qMax useful if height is 0
name|Q_ASSERT
argument_list|(
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|//it_y must exist since the span is in the list
while|while
condition|(
operator|-
name|it_y
operator|.
name|key
argument_list|()
operator|<=
name|span
operator|->
name|top
argument_list|()
operator|+
name|old_height
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|-
name|it_y
operator|.
name|key
argument_list|()
operator|>
name|span
operator|->
name|bottom
argument_list|()
condition|)
block|{
name|int
name|removed
init|=
operator|(
operator|*
name|it_y
operator|)
operator|.
name|remove
argument_list|(
operator|-
name|span
operator|->
name|left
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|removed
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|it_y
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|begin
argument_list|()
condition|)
break|break;
operator|--
name|it_y
expr_stmt|;
block|}
block|}
if|if
condition|(
name|span
operator|->
name|width
argument_list|()
operator|==
literal|0
operator|&&
name|span
operator|->
name|height
argument_list|()
operator|==
literal|0
condition|)
block|{
name|spans
operator|.
name|removeOne
argument_list|(
name|span
argument_list|)
expr_stmt|;
operator|delete
name|span
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/** \internal  * \return a spans that spans over cell x,y  (column,row)  or 0 if there is none.  */
end_comment
begin_function
DECL|function|spanAt
name|QSpanCollection
operator|::
name|Span
modifier|*
name|QSpanCollection
operator|::
name|spanAt
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
name|Index
operator|::
name|const_iterator
name|it_y
init|=
name|index
operator|.
name|lowerBound
argument_list|(
operator|-
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
name|SubIndex
operator|::
name|const_iterator
name|it_x
init|=
operator|(
operator|*
name|it_y
operator|)
operator|.
name|lowerBound
argument_list|(
operator|-
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_x
operator|==
operator|(
operator|*
name|it_y
operator|)
operator|.
name|end
argument_list|()
condition|)
return|return
literal|0
return|;
name|Span
modifier|*
name|span
init|=
operator|*
name|it_x
decl_stmt|;
if|if
condition|(
name|span
operator|->
name|right
argument_list|()
operator|>=
name|x
operator|&&
name|span
operator|->
name|bottom
argument_list|()
operator|>=
name|y
condition|)
return|return
name|span
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/** \internal * remove and deletes all spans inside the collection */
end_comment
begin_function
DECL|function|clear
name|void
name|QSpanCollection
operator|::
name|clear
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|spans
argument_list|)
expr_stmt|;
name|index
operator|.
name|clear
argument_list|()
expr_stmt|;
name|spans
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/** \internal  * return a list to all the spans that spans over cells in the given rectangle  */
end_comment
begin_function
DECL|function|spansInRect
name|QList
argument_list|<
name|QSpanCollection
operator|::
name|Span
operator|*
argument_list|>
name|QSpanCollection
operator|::
name|spansInRect
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
specifier|const
block|{
name|QSet
argument_list|<
name|Span
modifier|*
argument_list|>
name|list
decl_stmt|;
name|Index
operator|::
name|const_iterator
name|it_y
init|=
name|index
operator|.
name|lowerBound
argument_list|(
operator|-
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|end
argument_list|()
condition|)
operator|--
name|it_y
expr_stmt|;
while|while
condition|(
operator|-
name|it_y
operator|.
name|key
argument_list|()
operator|<=
name|y
operator|+
name|h
condition|)
block|{
name|SubIndex
operator|::
name|const_iterator
name|it_x
init|=
operator|(
operator|*
name|it_y
operator|)
operator|.
name|lowerBound
argument_list|(
operator|-
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_x
operator|==
operator|(
operator|*
name|it_y
operator|)
operator|.
name|end
argument_list|()
condition|)
operator|--
name|it_x
expr_stmt|;
while|while
condition|(
operator|-
name|it_x
operator|.
name|key
argument_list|()
operator|<=
name|x
operator|+
name|w
condition|)
block|{
name|Span
modifier|*
name|s
init|=
operator|*
name|it_x
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|bottom
argument_list|()
operator|>=
name|y
operator|&&
name|s
operator|->
name|right
argument_list|()
operator|>=
name|x
condition|)
name|list
operator|<<
name|s
expr_stmt|;
if|if
condition|(
name|it_x
operator|==
operator|(
operator|*
name|it_y
operator|)
operator|.
name|begin
argument_list|()
condition|)
break|break;
operator|--
name|it_x
expr_stmt|;
block|}
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|begin
argument_list|()
condition|)
break|break;
operator|--
name|it_y
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toList
argument_list|()
return|;
block|}
end_function
begin_undef
DECL|macro|DEBUG_SPAN_UPDATE
undef|#
directive|undef
name|DEBUG_SPAN_UPDATE
end_undef
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
end_ifdef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|str
parameter_list|,
specifier|const
name|QSpanCollection
operator|::
name|Span
modifier|&
name|span
parameter_list|)
block|{
name|str
operator|<<
literal|"("
operator|<<
name|span
operator|.
name|top
argument_list|()
operator|<<
literal|","
operator|<<
name|span
operator|.
name|left
argument_list|()
operator|<<
literal|","
operator|<<
name|span
operator|.
name|bottom
argument_list|()
operator|<<
literal|","
operator|<<
name|span
operator|.
name|right
argument_list|()
operator|<<
literal|")"
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/** \internal * Updates the span collection after row insertion. */
end_comment
begin_function
DECL|function|updateInsertedRows
name|void
name|QSpanCollection
operator|::
name|updateInsertedRows
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|start
operator|<<
name|end
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|delta
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"Before"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|SpanList
operator|::
name|iterator
name|it
init|=
name|spans
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|spans
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|Span
modifier|*
name|span
init|=
operator|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|span
operator|->
name|m_bottom
operator|<
name|start
condition|)
continue|continue;
if|if
condition|(
name|span
operator|->
name|m_top
operator|>=
name|start
condition|)
name|span
operator|->
name|m_top
operator|+=
name|delta
expr_stmt|;
name|span
operator|->
name|m_bottom
operator|+=
name|delta
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"After"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|spans
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|begin
argument_list|()
init|;
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|int
name|y
init|=
operator|-
name|it_y
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|start
condition|)
block|{
operator|++
name|it_y
expr_stmt|;
continue|continue;
block|}
name|index
operator|.
name|insert
argument_list|(
operator|-
name|y
operator|-
name|delta
argument_list|,
name|it_y
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/** \internal * Updates the span collection after column insertion. */
end_comment
begin_function
DECL|function|updateInsertedColumns
name|void
name|QSpanCollection
operator|::
name|updateInsertedColumns
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|start
operator|<<
name|end
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|delta
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"Before"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|SpanList
operator|::
name|iterator
name|it
init|=
name|spans
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|spans
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|Span
modifier|*
name|span
init|=
operator|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|span
operator|->
name|m_right
operator|<
name|start
condition|)
continue|continue;
if|if
condition|(
name|span
operator|->
name|m_left
operator|>=
name|start
condition|)
name|span
operator|->
name|m_left
operator|+=
name|delta
expr_stmt|;
name|span
operator|->
name|m_right
operator|+=
name|delta
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"After"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|spans
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|begin
argument_list|()
init|;
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it_y
control|)
block|{
name|SubIndex
modifier|&
name|subindex
init|=
name|it_y
operator|.
name|value
argument_list|()
decl_stmt|;
for|for
control|(
name|SubIndex
operator|::
name|iterator
name|it
init|=
name|subindex
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|subindex
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|int
name|x
init|=
operator|-
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|<
name|start
condition|)
block|{
operator|++
name|it
expr_stmt|;
continue|continue;
block|}
name|subindex
operator|.
name|insert
argument_list|(
operator|-
name|x
operator|-
name|delta
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|subindex
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/** \internal * Cleans a subindex from to be deleted spans. The update argument is used * to move the spans inside the subindex, in case their anchor changed. * \return true if no span in this subindex starts at y, and should thus be deleted. */
end_comment
begin_function
DECL|function|cleanSpanSubIndex
name|bool
name|QSpanCollection
operator|::
name|cleanSpanSubIndex
parameter_list|(
name|QSpanCollection
operator|::
name|SubIndex
modifier|&
name|subindex
parameter_list|,
name|int
name|y
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
if|if
condition|(
name|subindex
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
name|bool
name|should_be_deleted
init|=
literal|true
decl_stmt|;
name|SubIndex
operator|::
name|iterator
name|it
init|=
name|subindex
operator|.
name|end
argument_list|()
decl_stmt|;
do|do
block|{
operator|--
name|it
expr_stmt|;
name|int
name|x
init|=
operator|-
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|Span
modifier|*
name|span
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|->
name|will_be_deleted
condition|)
block|{
name|it
operator|=
name|subindex
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|update
operator|&&
name|span
operator|->
name|m_left
operator|!=
name|x
condition|)
block|{
name|subindex
operator|.
name|insert
argument_list|(
operator|-
name|span
operator|->
name|m_left
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|it
operator|=
name|subindex
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|should_be_deleted
operator|&&
name|span
operator|->
name|m_top
operator|==
name|y
condition|)
name|should_be_deleted
operator|=
literal|false
expr_stmt|;
block|}
do|while
condition|(
name|it
operator|!=
name|subindex
operator|.
name|begin
argument_list|()
condition|)
do|;
return|return
name|should_be_deleted
return|;
block|}
end_function
begin_comment
comment|/** \internal * Updates the span collection after row removal. */
end_comment
begin_function
DECL|function|updateRemovedRows
name|void
name|QSpanCollection
operator|::
name|updateRemovedRows
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|start
operator|<<
name|end
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|SpanList
name|spansToBeDeleted
decl_stmt|;
name|int
name|delta
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"Before"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|SpanList
operator|::
name|iterator
name|it
init|=
name|spans
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|spans
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|Span
modifier|*
name|span
init|=
operator|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|span
operator|->
name|m_bottom
operator|<
name|start
condition|)
block|{
operator|++
name|it
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|span
operator|->
name|m_top
operator|<
name|start
condition|)
block|{
if|if
condition|(
name|span
operator|->
name|m_bottom
operator|<=
name|end
condition|)
name|span
operator|->
name|m_bottom
operator|=
name|start
operator|-
literal|1
expr_stmt|;
else|else
name|span
operator|->
name|m_bottom
operator|-=
name|delta
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|span
operator|->
name|m_bottom
operator|>
name|end
condition|)
block|{
if|if
condition|(
name|span
operator|->
name|m_top
operator|<=
name|end
condition|)
name|span
operator|->
name|m_top
operator|=
name|start
expr_stmt|;
else|else
name|span
operator|->
name|m_top
operator|-=
name|delta
expr_stmt|;
name|span
operator|->
name|m_bottom
operator|-=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|span
operator|->
name|will_be_deleted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|span
operator|->
name|m_top
operator|==
name|span
operator|->
name|m_bottom
operator|&&
name|span
operator|->
name|m_left
operator|==
name|span
operator|->
name|m_right
condition|)
name|span
operator|->
name|will_be_deleted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|span
operator|->
name|will_be_deleted
condition|)
block|{
name|spansToBeDeleted
operator|.
name|append
argument_list|(
name|span
argument_list|)
expr_stmt|;
name|it
operator|=
name|spans
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"After"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|spans
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qDeleteAll
argument_list|(
name|spansToBeDeleted
argument_list|)
expr_stmt|;
name|index
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|end
argument_list|()
decl_stmt|;
do|do
block|{
operator|--
name|it_y
expr_stmt|;
name|int
name|y
init|=
operator|-
name|it_y
operator|.
name|key
argument_list|()
decl_stmt|;
name|SubIndex
modifier|&
name|subindex
init|=
name|it_y
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|start
condition|)
block|{
if|if
condition|(
name|cleanSpanSubIndex
argument_list|(
name|subindex
argument_list|,
name|y
argument_list|)
condition|)
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>=
name|start
operator|&&
name|y
operator|<=
name|end
condition|)
block|{
name|bool
name|span_at_start
init|=
literal|false
decl_stmt|;
name|SubIndex
name|spansToBeMoved
decl_stmt|;
for|for
control|(
name|SubIndex
operator|::
name|iterator
name|it
init|=
name|subindex
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|subindex
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|Span
modifier|*
name|span
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|->
name|will_be_deleted
condition|)
continue|continue;
if|if
condition|(
operator|!
name|span_at_start
operator|&&
name|span
operator|->
name|m_top
operator|==
name|start
condition|)
name|span_at_start
operator|=
literal|true
expr_stmt|;
name|spansToBeMoved
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|==
name|start
operator|&&
name|span_at_start
condition|)
name|subindex
operator|.
name|clear
argument_list|()
expr_stmt|;
else|else
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|span_at_start
condition|)
block|{
name|Index
operator|::
name|iterator
name|it_start
decl_stmt|;
if|if
condition|(
name|y
operator|==
name|start
condition|)
name|it_start
operator|=
name|it_y
expr_stmt|;
else|else
block|{
name|it_start
operator|=
name|index
operator|.
name|find
argument_list|(
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|it_start
operator|==
name|index
operator|.
name|end
argument_list|()
condition|)
name|it_start
operator|=
name|index
operator|.
name|insert
argument_list|(
operator|-
name|start
argument_list|,
name|SubIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SubIndex
modifier|&
name|start_subindex
init|=
name|it_start
operator|.
name|value
argument_list|()
decl_stmt|;
for|for
control|(
name|SubIndex
operator|::
name|iterator
name|it
init|=
name|spansToBeMoved
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|spansToBeMoved
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|start_subindex
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|y
operator|==
name|end
operator|+
literal|1
condition|)
block|{
name|Index
operator|::
name|iterator
name|it_top
init|=
name|index
operator|.
name|find
argument_list|(
operator|-
name|y
operator|+
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_top
operator|==
name|index
operator|.
name|end
argument_list|()
condition|)
name|it_top
operator|=
name|index
operator|.
name|insert
argument_list|(
operator|-
name|y
operator|+
name|delta
argument_list|,
name|SubIndex
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SubIndex
operator|::
name|iterator
name|it
init|=
name|subindex
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|subindex
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|Span
modifier|*
name|span
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|span
operator|->
name|will_be_deleted
condition|)
name|it_top
operator|.
name|value
argument_list|()
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|span
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
else|else
block|{
name|index
operator|.
name|insert
argument_list|(
operator|-
name|y
operator|+
name|delta
argument_list|,
name|subindex
argument_list|)
expr_stmt|;
block|}
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|it_y
operator|!=
name|index
operator|.
name|begin
argument_list|()
condition|)
do|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
name|qDebug
argument_list|(
literal|"Deleted"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|spansToBeDeleted
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
name|qDeleteAll
argument_list|(
name|spansToBeDeleted
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/** \internal * Updates the span collection after column removal. */
end_comment
begin_function
DECL|function|updateRemovedColumns
name|void
name|QSpanCollection
operator|::
name|updateRemovedColumns
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|start
operator|<<
name|end
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|SpanList
name|toBeDeleted
decl_stmt|;
name|int
name|delta
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"Before"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|SpanList
operator|::
name|iterator
name|it
init|=
name|spans
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|spans
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|Span
modifier|*
name|span
init|=
operator|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|span
operator|->
name|m_right
operator|<
name|start
condition|)
block|{
operator|++
name|it
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|span
operator|->
name|m_left
operator|<
name|start
condition|)
block|{
if|if
condition|(
name|span
operator|->
name|m_right
operator|<=
name|end
condition|)
name|span
operator|->
name|m_right
operator|=
name|start
operator|-
literal|1
expr_stmt|;
else|else
name|span
operator|->
name|m_right
operator|-=
name|delta
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|span
operator|->
name|m_right
operator|>
name|end
condition|)
block|{
if|if
condition|(
name|span
operator|->
name|m_left
operator|<=
name|end
condition|)
name|span
operator|->
name|m_left
operator|=
name|start
expr_stmt|;
else|else
name|span
operator|->
name|m_left
operator|-=
name|delta
expr_stmt|;
name|span
operator|->
name|m_right
operator|-=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|span
operator|->
name|will_be_deleted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|span
operator|->
name|m_top
operator|==
name|span
operator|->
name|m_bottom
operator|&&
name|span
operator|->
name|m_left
operator|==
name|span
operator|->
name|m_right
condition|)
name|span
operator|->
name|will_be_deleted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|span
operator|->
name|will_be_deleted
condition|)
block|{
name|toBeDeleted
operator|.
name|append
argument_list|(
name|span
argument_list|)
expr_stmt|;
name|it
operator|=
name|spans
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|(
literal|"After"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|spans
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|spans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qDeleteAll
argument_list|(
name|toBeDeleted
argument_list|)
expr_stmt|;
name|index
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|Index
operator|::
name|iterator
name|it_y
init|=
name|index
operator|.
name|begin
argument_list|()
init|;
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
name|int
name|y
init|=
operator|-
name|it_y
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|cleanSpanSubIndex
argument_list|(
name|it_y
operator|.
name|value
argument_list|()
argument_list|,
name|y
argument_list|,
literal|true
argument_list|)
condition|)
name|it_y
operator|=
name|index
operator|.
name|erase
argument_list|(
name|it_y
argument_list|)
expr_stmt|;
else|else
operator|++
name|it_y
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SPAN_UPDATE
name|qDebug
argument_list|()
operator|<<
name|index
expr_stmt|;
name|qDebug
argument_list|(
literal|"Deleted"
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|toBeDeleted
control|)
name|qDebug
argument_list|()
operator|<<
name|span
operator|<<
operator|*
name|span
expr_stmt|;
endif|#
directive|endif
name|qDeleteAll
argument_list|(
name|toBeDeleted
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
end_ifdef
begin_comment
comment|/*!   \internal   Checks whether the span index structure is self-consistent, and consistent with the spans list. */
end_comment
begin_function
DECL|function|checkConsistency
name|bool
name|QSpanCollection
operator|::
name|checkConsistency
parameter_list|()
specifier|const
block|{
for|for
control|(
name|Index
operator|::
name|const_iterator
name|it_y
init|=
name|index
operator|.
name|begin
argument_list|()
init|;
name|it_y
operator|!=
name|index
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it_y
control|)
block|{
name|int
name|y
init|=
operator|-
name|it_y
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|SubIndex
modifier|&
name|subIndex
init|=
name|it_y
operator|.
name|value
argument_list|()
decl_stmt|;
for|for
control|(
name|SubIndex
operator|::
name|const_iterator
name|it
init|=
name|subIndex
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|subIndex
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|int
name|x
init|=
operator|-
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|Span
modifier|*
name|span
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|spans
operator|.
name|contains
argument_list|(
name|span
argument_list|)
operator|||
name|span
operator|->
name|left
argument_list|()
operator|!=
name|x
operator|||
name|y
argument_list|<
name|span
operator|->
name|top
operator|(
operator|)
operator|||
name|y
argument_list|>
name|span
operator|->
name|bottom
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
block|}
foreach|foreach
control|(
specifier|const
name|Span
modifier|*
name|span
decl|,
name|spans
control|)
block|{
if|if
condition|(
name|span
operator|->
name|width
argument_list|()
operator|<
literal|1
operator|||
name|span
operator|->
name|height
argument_list|()
operator|<
literal|1
operator|||
operator|(
name|span
operator|->
name|width
argument_list|()
operator|==
literal|1
operator|&&
name|span
operator|->
name|height
argument_list|()
operator|==
literal|1
operator|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|y
init|=
name|span
operator|->
name|top
argument_list|()
init|;
name|y
operator|<=
name|span
operator|->
name|bottom
argument_list|()
condition|;
operator|++
name|y
control|)
block|{
name|Index
operator|::
name|const_iterator
name|it_y
init|=
name|index
operator|.
name|find
argument_list|(
operator|-
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|it_y
operator|==
name|index
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|y
operator|==
name|span
operator|->
name|top
argument_list|()
condition|)
return|return
literal|false
return|;
else|else
continue|continue;
block|}
specifier|const
name|SubIndex
modifier|&
name|subIndex
init|=
name|it_y
operator|.
name|value
argument_list|()
decl_stmt|;
name|SubIndex
operator|::
name|const_iterator
name|it
init|=
name|subIndex
operator|.
name|find
argument_list|(
operator|-
name|span
operator|->
name|left
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|subIndex
operator|.
name|end
argument_list|()
operator|||
name|it
operator|.
name|value
argument_list|()
operator|!=
name|span
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QTableCornerButton
class|class
name|QTableCornerButton
super|:
specifier|public
name|QAbstractButton
block|{
name|Q_OBJECT
public|public:
DECL|function|QTableCornerButton
name|QTableCornerButton
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractButton
argument_list|(
name|parent
argument_list|)
block|{}
DECL|function|paintEvent
name|void
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{
name|QStyleOptionHeader
name|opt
decl_stmt|;
name|opt
operator|.
name|init
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QStyle
operator|::
name|State
name|state
init|=
name|QStyle
operator|::
name|State_None
decl_stmt|;
if|if
condition|(
name|isEnabled
argument_list|()
condition|)
name|state
operator||=
name|QStyle
operator|::
name|State_Enabled
expr_stmt|;
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
name|state
operator||=
name|QStyle
operator|::
name|State_Active
expr_stmt|;
if|if
condition|(
name|isDown
argument_list|()
condition|)
name|state
operator||=
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
name|opt
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|opt
operator|.
name|rect
operator|=
name|rect
argument_list|()
expr_stmt|;
name|opt
operator|.
name|position
operator|=
name|QStyleOptionHeader
operator|::
name|OnlyOneSection
expr_stmt|;
name|QPainter
name|painter
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|style
argument_list|()
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_Header
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|painter
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|init
name|void
name|QTableViewPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|q
operator|->
name|setEditTriggers
argument_list|(
name|editTriggers
operator||
name|QAbstractItemView
operator|::
name|AnyKeyPressed
argument_list|)
expr_stmt|;
name|QHeaderView
modifier|*
name|vertical
init|=
operator|new
name|QHeaderView
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|vertical
operator|->
name|setSectionsClickable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|vertical
operator|->
name|setHighlightSections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|q
operator|->
name|setVerticalHeader
argument_list|(
name|vertical
argument_list|)
expr_stmt|;
name|QHeaderView
modifier|*
name|horizontal
init|=
operator|new
name|QHeaderView
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|horizontal
operator|->
name|setSectionsClickable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|horizontal
operator|->
name|setHighlightSections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|q
operator|->
name|setHorizontalHeader
argument_list|(
name|horizontal
argument_list|)
expr_stmt|;
name|tabKeyNavigation
operator|=
literal|true
expr_stmt|;
name|cornerWidget
operator|=
operator|new
name|QTableCornerButton
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cornerWidget
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|NoFocus
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|cornerWidget
argument_list|,
name|SIGNAL
argument_list|(
name|clicked
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|selectAll
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Trims away indices that are hidden in the treeview due to hidden horizontal or vertical sections. */
end_comment
begin_function
DECL|function|trimHiddenSelections
name|void
name|QTableViewPrivate
operator|::
name|trimHiddenSelections
parameter_list|(
name|QItemSelectionRange
modifier|*
name|range
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|range
operator|&&
name|range
operator|->
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|top
init|=
name|range
operator|->
name|top
argument_list|()
decl_stmt|;
name|int
name|left
init|=
name|range
operator|->
name|left
argument_list|()
decl_stmt|;
name|int
name|bottom
init|=
name|range
operator|->
name|bottom
argument_list|()
decl_stmt|;
name|int
name|right
init|=
name|range
operator|->
name|right
argument_list|()
decl_stmt|;
while|while
condition|(
name|bottom
operator|>=
name|top
operator|&&
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|bottom
argument_list|)
condition|)
operator|--
name|bottom
expr_stmt|;
while|while
condition|(
name|right
operator|>=
name|left
operator|&&
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|right
argument_list|)
condition|)
operator|--
name|right
expr_stmt|;
if|if
condition|(
name|top
operator|>
name|bottom
operator|||
name|left
operator|>
name|right
condition|)
block|{
comment|// everything is hidden
operator|*
name|range
operator|=
name|QItemSelectionRange
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|top
argument_list|)
operator|&&
name|top
operator|<=
name|bottom
condition|)
operator|++
name|top
expr_stmt|;
while|while
condition|(
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|left
argument_list|)
operator|&&
name|left
operator|<=
name|right
condition|)
operator|++
name|left
expr_stmt|;
if|if
condition|(
name|top
operator|>
name|bottom
operator|||
name|left
operator|>
name|right
condition|)
block|{
comment|// everything is hidden
operator|*
name|range
operator|=
name|QItemSelectionRange
argument_list|()
expr_stmt|;
return|return;
block|}
name|QModelIndex
name|bottomRight
init|=
name|model
operator|->
name|index
argument_list|(
name|bottom
argument_list|,
name|right
argument_list|,
name|range
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
name|QModelIndex
name|topLeft
init|=
name|model
operator|->
name|index
argument_list|(
name|top
argument_list|,
name|left
argument_list|,
name|range
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
operator|*
name|range
operator|=
name|QItemSelectionRange
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Sets the span for the cell at (\a row, \a column). */
end_comment
begin_function
DECL|function|setSpan
name|void
name|QTableViewPrivate
operator|::
name|setSpan
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|rowSpan
parameter_list|,
name|int
name|columnSpan
parameter_list|)
block|{
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|column
operator|<
literal|0
operator|||
name|rowSpan
operator|<=
literal|0
operator|||
name|columnSpan
operator|<=
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTableView::setSpan: invalid span given: ("
operator|<<
name|row
operator|<<
literal|','
operator|<<
name|column
operator|<<
literal|','
operator|<<
name|rowSpan
operator|<<
literal|','
operator|<<
name|columnSpan
operator|<<
literal|')'
expr_stmt|;
return|return;
block|}
name|QSpanCollection
operator|::
name|Span
modifier|*
name|sp
init|=
name|spans
operator|.
name|spanAt
argument_list|(
name|column
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|top
argument_list|()
operator|!=
name|row
operator|||
name|sp
operator|->
name|left
argument_list|()
operator|!=
name|column
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTableView::setSpan: span cannot overlap"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rowSpan
operator|==
literal|1
operator|&&
name|columnSpan
operator|==
literal|1
condition|)
block|{
name|rowSpan
operator|=
name|columnSpan
operator|=
literal|0
expr_stmt|;
block|}
specifier|const
name|int
name|old_height
init|=
name|sp
operator|->
name|height
argument_list|()
decl_stmt|;
name|sp
operator|->
name|m_bottom
operator|=
name|row
operator|+
name|rowSpan
operator|-
literal|1
expr_stmt|;
name|sp
operator|->
name|m_right
operator|=
name|column
operator|+
name|columnSpan
operator|-
literal|1
expr_stmt|;
name|spans
operator|.
name|updateSpan
argument_list|(
name|sp
argument_list|,
name|old_height
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rowSpan
operator|==
literal|1
operator|&&
name|columnSpan
operator|==
literal|1
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QTableView::setSpan: single cell span won't be added"
expr_stmt|;
return|return;
block|}
name|sp
operator|=
operator|new
name|QSpanCollection
operator|::
name|Span
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|rowSpan
argument_list|,
name|columnSpan
argument_list|)
expr_stmt|;
name|spans
operator|.
name|addSpan
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Gets the span information for the cell at (\a row, \a column). */
end_comment
begin_function
DECL|function|span
name|QSpanCollection
operator|::
name|Span
name|QTableViewPrivate
operator|::
name|span
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
name|QSpanCollection
operator|::
name|Span
modifier|*
name|sp
init|=
name|spans
operator|.
name|spanAt
argument_list|(
name|column
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
condition|)
return|return
operator|*
name|sp
return|;
return|return
name|QSpanCollection
operator|::
name|Span
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns the logical index of the last section that's part of the span. */
end_comment
begin_function
DECL|function|sectionSpanEndLogical
name|int
name|QTableViewPrivate
operator|::
name|sectionSpanEndLogical
parameter_list|(
specifier|const
name|QHeaderView
modifier|*
name|header
parameter_list|,
name|int
name|logical
parameter_list|,
name|int
name|span
parameter_list|)
specifier|const
block|{
name|int
name|visual
init|=
name|header
operator|->
name|visualIndex
argument_list|(
name|logical
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|span
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|visual
operator|>=
name|header
operator|->
name|count
argument_list|()
condition|)
break|break;
name|logical
operator|=
name|header
operator|->
name|logicalIndex
argument_list|(
name|visual
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|logical
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns the size of the span starting at logical index \a logical   and spanning \a span sections. */
end_comment
begin_function
DECL|function|sectionSpanSize
name|int
name|QTableViewPrivate
operator|::
name|sectionSpanSize
parameter_list|(
specifier|const
name|QHeaderView
modifier|*
name|header
parameter_list|,
name|int
name|logical
parameter_list|,
name|int
name|span
parameter_list|)
specifier|const
block|{
name|int
name|endLogical
init|=
name|sectionSpanEndLogical
argument_list|(
name|header
argument_list|,
name|logical
argument_list|,
name|span
argument_list|)
decl_stmt|;
return|return
name|header
operator|->
name|sectionPosition
argument_list|(
name|endLogical
argument_list|)
operator|-
name|header
operator|->
name|sectionPosition
argument_list|(
name|logical
argument_list|)
operator|+
name|header
operator|->
name|sectionSize
argument_list|(
name|endLogical
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns true if the section at logical index \a logical is part of the span   starting at logical index \a spanLogical and spanning \a span sections;   otherwise, returns false. */
end_comment
begin_function
DECL|function|spanContainsSection
name|bool
name|QTableViewPrivate
operator|::
name|spanContainsSection
parameter_list|(
specifier|const
name|QHeaderView
modifier|*
name|header
parameter_list|,
name|int
name|logical
parameter_list|,
name|int
name|spanLogical
parameter_list|,
name|int
name|span
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|logical
operator|==
name|spanLogical
condition|)
return|return
literal|true
return|;
comment|// it's the start of the span
name|int
name|visual
init|=
name|header
operator|->
name|visualIndex
argument_list|(
name|spanLogical
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|span
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|visual
operator|>=
name|header
operator|->
name|count
argument_list|()
condition|)
break|break;
name|spanLogical
operator|=
name|header
operator|->
name|logicalIndex
argument_list|(
name|visual
argument_list|)
expr_stmt|;
if|if
condition|(
name|logical
operator|==
name|spanLogical
condition|)
return|return
literal|true
return|;
operator|++
name|i
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns the visual rect for the given \a span. */
end_comment
begin_function
DECL|function|visualSpanRect
name|QRect
name|QTableViewPrivate
operator|::
name|visualSpanRect
parameter_list|(
specifier|const
name|QSpanCollection
operator|::
name|Span
modifier|&
name|span
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
comment|// vertical
name|int
name|row
init|=
name|span
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|rowp
init|=
name|verticalHeader
operator|->
name|sectionViewportPosition
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|int
name|rowh
init|=
name|rowSpanHeight
argument_list|(
name|row
argument_list|,
name|span
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
comment|// horizontal
name|int
name|column
init|=
name|span
operator|.
name|left
argument_list|()
decl_stmt|;
name|int
name|colw
init|=
name|columnSpanWidth
argument_list|(
name|column
argument_list|,
name|span
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
name|column
operator|=
name|span
operator|.
name|right
argument_list|()
expr_stmt|;
name|int
name|colp
init|=
name|horizontalHeader
operator|->
name|sectionViewportPosition
argument_list|(
name|column
argument_list|)
decl_stmt|;
specifier|const
name|int
name|i
init|=
name|showGrid
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
return|return
name|QRect
argument_list|(
name|colp
operator|+
name|i
argument_list|,
name|rowp
argument_list|,
name|colw
operator|-
name|i
argument_list|,
name|rowh
operator|-
name|i
argument_list|)
return|;
return|return
name|QRect
argument_list|(
name|colp
argument_list|,
name|rowp
argument_list|,
name|colw
operator|-
name|i
argument_list|,
name|rowh
operator|-
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Draws the spanning cells within rect \a area, and clips them off as   preparation for the main drawing loop.   \a drawn is a QBitArray of visualRowCountxvisualCoulumnCount which say if particular cell has been drawn */
end_comment
begin_function
DECL|function|drawAndClipSpans
name|void
name|QTableViewPrivate
operator|::
name|drawAndClipSpans
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|area
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
name|QBitArray
modifier|*
name|drawn
parameter_list|,
name|int
name|firstVisualRow
parameter_list|,
name|int
name|lastVisualRow
parameter_list|,
name|int
name|firstVisualColumn
parameter_list|,
name|int
name|lastVisualColumn
parameter_list|)
block|{
name|bool
name|alternateBase
init|=
literal|false
decl_stmt|;
name|QRegion
name|region
init|=
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QSpanCollection
operator|::
name|Span
operator|*
argument_list|>
name|visibleSpans
decl_stmt|;
name|bool
name|sectionMoved
init|=
name|verticalHeader
operator|->
name|sectionsMoved
argument_list|()
operator|||
name|horizontalHeader
operator|->
name|sectionsMoved
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sectionMoved
condition|)
block|{
name|visibleSpans
operator|=
name|spans
operator|.
name|spansInRect
argument_list|(
name|logicalColumn
argument_list|(
name|firstVisualColumn
argument_list|)
argument_list|,
name|logicalRow
argument_list|(
name|firstVisualRow
argument_list|)
argument_list|,
name|lastVisualColumn
operator|-
name|firstVisualColumn
operator|+
literal|1
argument_list|,
name|lastVisualRow
operator|-
name|firstVisualRow
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QSet
argument_list|<
name|QSpanCollection
operator|::
name|Span
operator|*
argument_list|>
name|set
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
name|firstVisualColumn
init|;
name|x
operator|<=
name|lastVisualColumn
condition|;
name|x
operator|++
control|)
for|for
control|(
name|int
name|y
init|=
name|firstVisualRow
init|;
name|y
operator|<=
name|lastVisualRow
condition|;
name|y
operator|++
control|)
name|set
operator|.
name|insert
argument_list|(
name|spans
operator|.
name|spanAt
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|visibleSpans
operator|=
name|set
operator|.
name|toList
argument_list|()
expr_stmt|;
block|}
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|span
decl|,
name|visibleSpans
control|)
block|{
name|int
name|row
init|=
name|span
operator|->
name|top
argument_list|()
decl_stmt|;
name|int
name|col
init|=
name|span
operator|->
name|left
argument_list|()
decl_stmt|;
name|QModelIndex
name|index
init|=
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
name|QRect
name|rect
init|=
name|visualSpanRect
argument_list|(
operator|*
name|span
argument_list|)
decl_stmt|;
name|rect
operator|.
name|translate
argument_list|(
name|scrollDelayOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|area
operator|.
name|intersects
argument_list|(
name|rect
argument_list|)
condition|)
continue|continue;
name|QStyleOptionViewItem
name|opt
init|=
name|option
decl_stmt|;
name|opt
operator|.
name|rect
operator|=
name|rect
expr_stmt|;
name|alternateBase
operator|=
name|alternatingColors
operator|&&
operator|(
name|span
operator|->
name|top
argument_list|()
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|alternateBase
condition|)
name|opt
operator|.
name|features
operator||=
name|QStyleOptionViewItem
operator|::
name|Alternate
expr_stmt|;
else|else
name|opt
operator|.
name|features
operator|&=
operator|~
name|QStyleOptionViewItem
operator|::
name|Alternate
expr_stmt|;
name|drawCell
argument_list|(
name|painter
argument_list|,
name|opt
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|region
operator|-=
name|rect
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|span
operator|->
name|top
argument_list|()
init|;
name|r
operator|<=
name|span
operator|->
name|bottom
argument_list|()
condition|;
operator|++
name|r
control|)
block|{
specifier|const
name|int
name|vr
init|=
name|visualRow
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|vr
argument_list|<
name|firstVisualRow
operator|||
name|vr
argument_list|>
name|lastVisualRow
condition|)
continue|continue;
for|for
control|(
name|int
name|c
init|=
name|span
operator|->
name|left
argument_list|()
init|;
name|c
operator|<=
name|span
operator|->
name|right
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|int
name|vc
init|=
name|visualColumn
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|vc
argument_list|<
name|firstVisualColumn
operator|||
name|vc
argument_list|>
name|lastVisualColumn
condition|)
continue|continue;
name|drawn
operator|->
name|setBit
argument_list|(
operator|(
name|vr
operator|-
name|firstVisualRow
operator|)
operator|*
operator|(
name|lastVisualColumn
operator|-
name|firstVisualColumn
operator|+
literal|1
operator|)
operator|+
name|vc
operator|-
name|firstVisualColumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|painter
operator|->
name|setClipRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Updates spans after row insertion. */
end_comment
begin_function
DECL|function|_q_updateSpanInsertedRows
name|void
name|QTableViewPrivate
operator|::
name|_q_updateSpanInsertedRows
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|parent
argument_list|)
name|spans
operator|.
name|updateInsertedRows
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Updates spans after column insertion. */
end_comment
begin_function
DECL|function|_q_updateSpanInsertedColumns
name|void
name|QTableViewPrivate
operator|::
name|_q_updateSpanInsertedColumns
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|parent
argument_list|)
name|spans
operator|.
name|updateInsertedColumns
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Updates spans after row removal. */
end_comment
begin_function
DECL|function|_q_updateSpanRemovedRows
name|void
name|QTableViewPrivate
operator|::
name|_q_updateSpanRemovedRows
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|parent
argument_list|)
name|spans
operator|.
name|updateRemovedRows
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Updates spans after column removal. */
end_comment
begin_function
DECL|function|_q_updateSpanRemovedColumns
name|void
name|QTableViewPrivate
operator|::
name|_q_updateSpanRemovedColumns
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|parent
argument_list|)
name|spans
operator|.
name|updateRemovedColumns
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Draws a table cell. */
end_comment
begin_function
DECL|function|drawCell
name|void
name|QTableViewPrivate
operator|::
name|drawCell
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|option
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|QStyleOptionViewItem
name|opt
init|=
name|option
decl_stmt|;
if|if
condition|(
name|selectionModel
operator|&&
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Selected
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|hover
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
if|if
condition|(
name|option
operator|.
name|state
operator|&
name|QStyle
operator|::
name|State_Enabled
condition|)
block|{
name|QPalette
operator|::
name|ColorGroup
name|cg
decl_stmt|;
if|if
condition|(
operator|(
name|model
operator|->
name|flags
argument_list|(
name|index
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
operator|==
literal|0
condition|)
block|{
name|opt
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_Enabled
expr_stmt|;
name|cg
operator|=
name|QPalette
operator|::
name|Disabled
expr_stmt|;
block|}
else|else
block|{
name|cg
operator|=
name|QPalette
operator|::
name|Normal
expr_stmt|;
block|}
name|opt
operator|.
name|palette
operator|.
name|setCurrentColorGroup
argument_list|(
name|cg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
name|q
operator|->
name|currentIndex
argument_list|()
condition|)
block|{
specifier|const
name|bool
name|focus
init|=
operator|(
name|q
operator|->
name|hasFocus
argument_list|()
operator|||
name|viewport
operator|->
name|hasFocus
argument_list|()
operator|)
operator|&&
name|q
operator|->
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
decl_stmt|;
if|if
condition|(
name|focus
condition|)
name|opt
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
block|}
name|q
operator|->
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_PanelItemViewRow
argument_list|,
operator|&
name|opt
argument_list|,
name|painter
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|itemDelegate
argument_list|(
name|index
argument_list|)
operator|->
name|paint
argument_list|(
name|painter
argument_list|,
name|opt
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTableView      \brief The QTableView class provides a default model/view     implementation of a table view.      \ingroup model-view     \ingroup advanced     \inmodule QtWidgets      A QTableView implements a table view that displays items from a     model. This class is used to provide standard tables that were     previously provided by the QTable class, but using the more     flexible approach provided by Qt's model/view architecture.      The QTableView class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      QTableView implements the interfaces defined by the     QAbstractItemView class to allow it to display data provided by     models derived from the QAbstractItemModel class.      \section1 Navigation      You can navigate the cells in the table by clicking on a cell with the     mouse, or by using the arrow keys. Because QTableView enables     \l{QAbstractItemView::tabKeyNavigation}{tabKeyNavigation} by default, you     can also hit Tab and Backtab to move from cell to cell.      \section1 Visual Appearance      The table has a vertical header that can be obtained using the     verticalHeader() function, and a horizontal header that is available     through the horizontalHeader() function. The height of each row in the     table can be found by using rowHeight(); similarly, the width of     columns can be found using columnWidth().  Since both of these are plain     widgets, you can hide either of them using their hide() functions.      Rows and columns can be hidden and shown with hideRow(), hideColumn(),     showRow(), and showColumn(). They can be selected with selectRow()     and selectColumn(). The table will show a grid depending on the     \l showGrid property.      The items shown in a table view, like those in the other item views, are     rendered and edited using standard \l{QItemDelegate}{delegates}. However,     for some tasks it is sometimes useful to be able to insert widgets in a     table instead. Widgets are set for particular indexes with the     \l{QAbstractItemView::}{setIndexWidget()} function, and     later retrieved with \l{QAbstractItemView::}{indexWidget()}.      \table     \row \li \inlineimage qtableview-resized.png     \li By default, the cells in a table do not expand to fill the available space.      You can make the cells fill the available space by stretching the last     header section. Access the relevant header using horizontalHeader()     or verticalHeader() and set the header's \l{QHeaderView::}{stretchLastSection}     property.      To distribute the available space according to the space requirement of     each column or row, call the view's resizeColumnsToContents() or     resizeRowsToContents() functions.     \endtable      \section1 Coordinate Systems      For some specialized forms of tables it is useful to be able to     convert between row and column indexes and widget coordinates.     The rowAt() function provides the y-coordinate within the view of the     specified row; the row index can be used to obtain a corresponding     y-coordinate with rowViewportPosition(). The columnAt() and     columnViewportPosition() functions provide the equivalent conversion     operations between x-coordinates and column indexes.      \section1 Styles      QTableView is styled appropriately for each platform. The following images show     how it looks on three different platforms. Go to the \l{Qt Widget Gallery} to see     its appearance in other styles.      \table 100%     \row \li \inlineimage windowsvista-tableview.png Screenshot of a Windows Vista style table view          \li \inlineimage macintosh-tableview.png Screenshot of a Macintosh style table view          \li \inlineimage fusion-tableview.png Screenshot of a Fusion style table view     \row \li A \l{Windows Vista Style Widget Gallery}{Windows Vista style} table view.          \li A \l{Macintosh Style Widget Gallery}{Macintosh style} table view.          \li A \l{Fusion Style Widget Gallery}{Fusion style} table view.     \endtable      \sa QTableWidget, {View Classes}, QAbstractItemModel, QAbstractItemView,         {Chart Example}, {Pixelator Example}, {Table Model Example} */
end_comment
begin_comment
comment|/*!     Constructs a table view with a \a parent to represent the data.      \sa QAbstractItemModel */
end_comment
begin_constructor
DECL|function|QTableView
name|QTableView
operator|::
name|QTableView
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemView
argument_list|(
operator|*
operator|new
name|QTableViewPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QTableView
name|QTableView
operator|::
name|QTableView
parameter_list|(
name|QTableViewPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemView
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destroys the table view. */
end_comment
begin_destructor
DECL|function|~QTableView
name|QTableView
operator|::
name|~
name|QTableView
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|viewportSizeHint
name|QSize
name|QTableView
operator|::
name|viewportSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|QSize
name|result
argument_list|(
operator|(
name|d
operator|->
name|verticalHeader
operator|->
name|isHidden
argument_list|()
condition|?
literal|0
else|:
name|d
operator|->
name|verticalHeader
operator|->
name|width
argument_list|()
operator|)
operator|+
name|d
operator|->
name|horizontalHeader
operator|->
name|length
argument_list|()
argument_list|,
operator|(
name|d
operator|->
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
condition|?
literal|0
else|:
name|d
operator|->
name|horizontalHeader
operator|->
name|height
argument_list|()
operator|)
operator|+
name|d
operator|->
name|verticalHeader
operator|->
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QSize
argument_list|(
name|verticalScrollBar
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|?
name|verticalScrollBar
argument_list|()
operator|->
name|width
argument_list|()
else|:
literal|0
argument_list|,
name|horizontalScrollBar
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|?
name|horizontalScrollBar
argument_list|()
operator|->
name|height
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|setModel
name|void
name|QTableView
operator|::
name|setModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
name|d
operator|->
name|model
condition|)
return|return;
comment|//let's disconnect from the old model
if|if
condition|(
name|d
operator|->
name|model
operator|&&
name|d
operator|->
name|model
operator|!=
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanInsertedRows
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanInsertedColumns
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanRemovedRows
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanRemovedColumns
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
comment|// support row editing
name|disconnect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|currentRowChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|d
operator|->
name|model
argument_list|,
name|SLOT
argument_list|(
name|submit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|model
condition|)
block|{
comment|//and connect to the new one
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanInsertedRows
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanInsertedColumns
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanRemovedRows
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_updateSpanRemovedColumns
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|verticalHeader
operator|->
name|setModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|QAbstractItemView
operator|::
name|setModel
argument_list|(
name|model
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|setRootIndex
name|void
name|QTableView
operator|::
name|setRootIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|d
operator|->
name|root
condition|)
block|{
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|verticalHeader
operator|->
name|setRootIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setRootIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|QAbstractItemView
operator|::
name|setRootIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|doItemsLayout
name|void
name|QTableView
operator|::
name|doItemsLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|QAbstractItemView
operator|::
name|doItemsLayout
argument_list|()
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|d_func
argument_list|()
operator|->
name|setScrollOffset
argument_list|(
name|verticalScrollBar
argument_list|()
argument_list|,
name|verticalScrollMode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|verticalHeader
operator|->
name|updatesEnabled
argument_list|()
condition|)
name|d
operator|->
name|verticalHeader
operator|->
name|setUpdatesEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|setSelectionModel
name|void
name|QTableView
operator|::
name|setSelectionModel
parameter_list|(
name|QItemSelectionModel
modifier|*
name|selectionModel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|selectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
comment|// support row editing
name|disconnect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|currentRowChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|d
operator|->
name|model
argument_list|,
name|SLOT
argument_list|(
name|submit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|verticalHeader
operator|->
name|setSelectionModel
argument_list|(
name|selectionModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setSelectionModel
argument_list|(
name|selectionModel
argument_list|)
expr_stmt|;
name|QAbstractItemView
operator|::
name|setSelectionModel
argument_list|(
name|selectionModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
comment|// support row editing
name|connect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|currentRowChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|d
operator|->
name|model
argument_list|,
name|SLOT
argument_list|(
name|submit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the table view's horizontal header.      \sa setHorizontalHeader(), verticalHeader(), QAbstractItemModel::headerData() */
end_comment
begin_function
DECL|function|horizontalHeader
name|QHeaderView
modifier|*
name|QTableView
operator|::
name|horizontalHeader
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the table view's vertical header.      \sa setVerticalHeader(), horizontalHeader(), QAbstractItemModel::headerData() */
end_comment
begin_function
DECL|function|verticalHeader
name|QHeaderView
modifier|*
name|QTableView
operator|::
name|verticalHeader
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the widget to use for the horizontal header to \a header.      \sa horizontalHeader(), setVerticalHeader() */
end_comment
begin_function
DECL|function|setHorizontalHeader
name|void
name|QTableView
operator|::
name|setHorizontalHeader
parameter_list|(
name|QHeaderView
modifier|*
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header
operator|||
name|header
operator|==
name|d
operator|->
name|horizontalHeader
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|&&
name|d
operator|->
name|horizontalHeader
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|d
operator|->
name|horizontalHeader
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|=
name|header
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|d_func
argument_list|()
operator|->
name|setAllowUserMoveOfSection0
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|horizontalHeader
operator|->
name|model
argument_list|()
condition|)
block|{
name|d
operator|->
name|horizontalHeader
operator|->
name|setModel
argument_list|(
name|d
operator|->
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
name|d
operator|->
name|horizontalHeader
operator|->
name|setSelectionModel
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|)
expr_stmt|;
block|}
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionResized
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|columnResized
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionMoved
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|columnMoved
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionCountChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|columnCountChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionPressed
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionEntered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionHandleDoubleClicked
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|resizeColumnToContents
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|geometriesChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateGeometries
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//update the sorting enabled states on the new header
name|setSortingEnabled
argument_list|(
name|d
operator|->
name|sortingEnabled
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the widget to use for the vertical header to \a header.      \sa verticalHeader(), setHorizontalHeader() */
end_comment
begin_function
DECL|function|setVerticalHeader
name|void
name|QTableView
operator|::
name|setVerticalHeader
parameter_list|(
name|QHeaderView
modifier|*
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header
operator|||
name|header
operator|==
name|d
operator|->
name|verticalHeader
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|verticalHeader
operator|&&
name|d
operator|->
name|verticalHeader
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|d
operator|->
name|verticalHeader
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|=
name|header
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|d_func
argument_list|()
operator|->
name|setAllowUserMoveOfSection0
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|verticalHeader
operator|->
name|model
argument_list|()
condition|)
block|{
name|d
operator|->
name|verticalHeader
operator|->
name|setModel
argument_list|(
name|d
operator|->
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
name|d
operator|->
name|verticalHeader
operator|->
name|setSelectionModel
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|)
expr_stmt|;
block|}
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionResized
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowResized
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionMoved
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowMoved
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionCountChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowCountChanged
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionPressed
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectRow
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionEntered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_selectRow
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionHandleDoubleClicked
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|resizeRowToContents
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|geometriesChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateGeometries
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Scroll the contents of the table view by (\a dx, \a dy). */
end_comment
begin_function
DECL|function|scrollContentsBy
name|void
name|QTableView
operator|::
name|scrollContentsBy
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// auto scroll was canceled by the user scrolling
name|dx
operator|=
name|isRightToLeft
argument_list|()
condition|?
operator|-
name|dx
else|:
name|dx
expr_stmt|;
if|if
condition|(
name|dx
condition|)
block|{
name|int
name|oldOffset
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|d_func
argument_list|()
operator|->
name|setScrollOffset
argument_list|(
name|horizontalScrollBar
argument_list|()
argument_list|,
name|horizontalScrollMode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|horizontalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
name|int
name|newOffset
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|dx
operator|=
name|isRightToLeft
argument_list|()
condition|?
name|newOffset
operator|-
name|oldOffset
else|:
name|oldOffset
operator|-
name|newOffset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dy
condition|)
block|{
name|int
name|oldOffset
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|d_func
argument_list|()
operator|->
name|setScrollOffset
argument_list|(
name|verticalScrollBar
argument_list|()
argument_list|,
name|verticalScrollMode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|verticalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
name|int
name|newOffset
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|dy
operator|=
name|oldOffset
operator|-
name|newOffset
expr_stmt|;
block|}
block|}
name|d
operator|->
name|scrollContentsBy
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|showGrid
condition|)
block|{
comment|//we need to update the first line of the previous top item in the view
comment|//because it has the grid drawn if the header is invisible.
comment|//It is strictly related to what's done at then end of the paintEvent
if|if
condition|(
name|dy
operator|>
literal|0
operator|&&
name|d
operator|->
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
operator|&&
name|d
operator|->
name|verticalScrollMode
operator|==
name|ScrollPerItem
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
literal|0
argument_list|,
name|dy
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|>
literal|0
operator|&&
name|d
operator|->
name|verticalHeader
operator|->
name|isHidden
argument_list|()
operator|&&
name|d
operator|->
name|horizontalScrollMode
operator|==
name|ScrollPerItem
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|dx
argument_list|,
literal|0
argument_list|,
name|dx
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|viewOptions
name|QStyleOptionViewItem
name|QTableViewPrivate
operator|::
name|viewOptions
parameter_list|()
specifier|const
block|{
name|QStyleOptionViewItem
name|option
init|=
name|QAbstractItemViewPrivate
operator|::
name|viewOptions
argument_list|()
decl_stmt|;
name|option
operator|.
name|showDecorationSelected
operator|=
literal|true
expr_stmt|;
return|return
name|option
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|viewOptions
name|QStyleOptionViewItem
name|QTableView
operator|::
name|viewOptions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|viewOptions
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Paints the table on receipt of the given paint event \a event. */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QTableView
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
comment|// setup temp variables for the painting
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|offset
init|=
name|d
operator|->
name|scrollDelayOffset
decl_stmt|;
specifier|const
name|bool
name|showGrid
init|=
name|d
operator|->
name|showGrid
decl_stmt|;
specifier|const
name|int
name|gridSize
init|=
name|showGrid
condition|?
literal|1
else|:
literal|0
decl_stmt|;
specifier|const
name|int
name|gridHint
init|=
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_Table_GridLineColor
argument_list|,
operator|&
name|option
argument_list|,
name|this
argument_list|)
decl_stmt|;
specifier|const
name|QColor
name|gridColor
init|=
cast|static_cast
argument_list|<
name|QRgb
argument_list|>
argument_list|(
name|gridHint
argument_list|)
decl_stmt|;
specifier|const
name|QPen
name|gridPen
init|=
name|QPen
argument_list|(
name|gridColor
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|gridStyle
argument_list|)
decl_stmt|;
specifier|const
name|QHeaderView
modifier|*
name|verticalHeader
init|=
name|d
operator|->
name|verticalHeader
decl_stmt|;
specifier|const
name|QHeaderView
modifier|*
name|horizontalHeader
init|=
name|d
operator|->
name|horizontalHeader
decl_stmt|;
specifier|const
name|bool
name|alternate
init|=
name|d
operator|->
name|alternatingColors
decl_stmt|;
specifier|const
name|bool
name|rightToLeft
init|=
name|isRightToLeft
argument_list|()
decl_stmt|;
name|QPainter
name|painter
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
decl_stmt|;
comment|// if there's nothing to do, clear the area and return
if|if
condition|(
name|horizontalHeader
operator|->
name|count
argument_list|()
operator|==
literal|0
operator|||
name|verticalHeader
operator|->
name|count
argument_list|()
operator|==
literal|0
operator|||
operator|!
name|d
operator|->
name|itemDelegate
condition|)
return|return;
name|uint
name|x
init|=
name|horizontalHeader
operator|->
name|length
argument_list|()
operator|-
name|horizontalHeader
operator|->
name|offset
argument_list|()
operator|-
operator|(
name|rightToLeft
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|uint
name|y
init|=
name|verticalHeader
operator|->
name|length
argument_list|()
operator|-
name|verticalHeader
operator|->
name|offset
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|const
name|QRegion
name|region
init|=
name|event
operator|->
name|region
argument_list|()
operator|.
name|translated
argument_list|(
name|offset
argument_list|)
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
comment|//firstVisualRow is the visual index of the first visible row.  lastVisualRow is the visual index of the last visible Row.
comment|//same goes for ...VisualColumn
name|int
name|firstVisualRow
init|=
name|qMax
argument_list|(
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|lastVisualRow
init|=
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
name|verticalHeader
operator|->
name|viewport
argument_list|()
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastVisualRow
operator|==
operator|-
literal|1
condition|)
name|lastVisualRow
operator|=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|int
name|firstVisualColumn
init|=
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|lastVisualColumn
init|=
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
name|horizontalHeader
operator|->
name|viewport
argument_list|()
operator|->
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightToLeft
condition|)
name|qSwap
argument_list|(
name|firstVisualColumn
argument_list|,
name|lastVisualColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstVisualColumn
operator|==
operator|-
literal|1
condition|)
name|firstVisualColumn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lastVisualColumn
operator|==
operator|-
literal|1
condition|)
name|lastVisualColumn
operator|=
name|horizontalHeader
operator|->
name|count
argument_list|()
operator|-
literal|1
expr_stmt|;
name|QBitArray
name|drawn
argument_list|(
operator|(
name|lastVisualRow
operator|-
name|firstVisualRow
operator|+
literal|1
operator|)
operator|*
operator|(
name|lastVisualColumn
operator|-
name|firstVisualColumn
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|d
operator|->
name|drawAndClipSpans
argument_list|(
name|region
argument_list|,
operator|&
name|painter
argument_list|,
name|option
argument_list|,
operator|&
name|drawn
argument_list|,
name|firstVisualRow
argument_list|,
name|lastVisualRow
argument_list|,
name|firstVisualColumn
argument_list|,
name|lastVisualColumn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRect
name|dirtyArea
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|dirtyArea
operator|.
name|setBottom
argument_list|(
name|qMin
argument_list|(
name|dirtyArea
operator|.
name|bottom
argument_list|()
argument_list|,
name|int
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightToLeft
condition|)
block|{
name|dirtyArea
operator|.
name|setLeft
argument_list|(
name|qMax
argument_list|(
name|dirtyArea
operator|.
name|left
argument_list|()
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
operator|-
name|int
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirtyArea
operator|.
name|setRight
argument_list|(
name|qMin
argument_list|(
name|dirtyArea
operator|.
name|right
argument_list|()
argument_list|,
name|int
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// get the horizontal start and end visual sections
name|int
name|left
init|=
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
name|dirtyArea
operator|.
name|left
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
name|dirtyArea
operator|.
name|right
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightToLeft
condition|)
name|qSwap
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
operator|-
literal|1
condition|)
name|left
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|right
operator|==
operator|-
literal|1
condition|)
name|right
operator|=
name|horizontalHeader
operator|->
name|count
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|// get the vertical start and end visual sections and if alternate color
name|int
name|bottom
init|=
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
name|dirtyArea
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bottom
operator|==
operator|-
literal|1
condition|)
name|bottom
operator|=
name|verticalHeader
operator|->
name|count
argument_list|()
operator|-
literal|1
expr_stmt|;
name|int
name|top
init|=
literal|0
decl_stmt|;
name|bool
name|alternateBase
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|alternate
operator|&&
name|verticalHeader
operator|->
name|sectionsHidden
argument_list|()
condition|)
block|{
name|uint
name|verticalOffset
init|=
name|verticalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|int
name|row
init|=
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|top
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
operator|(
call|(
name|uint
call|)
argument_list|(
name|y
operator|+=
name|verticalHeader
operator|->
name|sectionSize
argument_list|(
name|top
argument_list|)
argument_list|)
operator|<=
name|verticalOffset
operator|)
operator|&&
operator|(
name|top
operator|<
name|bottom
operator|)
condition|;
operator|++
name|top
control|)
block|{
name|row
operator|=
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate
operator|&&
operator|!
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|row
argument_list|)
condition|)
name|alternateBase
operator|=
operator|!
name|alternateBase
expr_stmt|;
block|}
block|}
else|else
block|{
name|top
operator|=
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
name|dirtyArea
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|alternateBase
operator|=
operator|(
name|top
operator|&
literal|1
operator|)
operator|&&
name|alternate
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|==
operator|-
literal|1
operator|||
name|top
operator|>
name|bottom
condition|)
continue|continue;
comment|// Paint each row item
for|for
control|(
name|int
name|visualRowIndex
init|=
name|top
init|;
name|visualRowIndex
operator|<=
name|bottom
condition|;
operator|++
name|visualRowIndex
control|)
block|{
name|int
name|row
init|=
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|visualRowIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|row
argument_list|)
condition|)
continue|continue;
name|int
name|rowY
init|=
name|rowViewportPosition
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|rowY
operator|+=
name|offset
operator|.
name|y
argument_list|()
expr_stmt|;
name|int
name|rowh
init|=
name|rowHeight
argument_list|(
name|row
argument_list|)
operator|-
name|gridSize
decl_stmt|;
comment|// Paint each column item
for|for
control|(
name|int
name|visualColumnIndex
init|=
name|left
init|;
name|visualColumnIndex
operator|<=
name|right
condition|;
operator|++
name|visualColumnIndex
control|)
block|{
name|int
name|currentBit
init|=
operator|(
name|visualRowIndex
operator|-
name|firstVisualRow
operator|)
operator|*
operator|(
name|lastVisualColumn
operator|-
name|firstVisualColumn
operator|+
literal|1
operator|)
operator|+
name|visualColumnIndex
operator|-
name|firstVisualColumn
decl_stmt|;
if|if
condition|(
name|currentBit
operator|<
literal|0
operator|||
name|currentBit
operator|>=
name|drawn
operator|.
name|size
argument_list|()
operator|||
name|drawn
operator|.
name|testBit
argument_list|(
name|currentBit
argument_list|)
condition|)
continue|continue;
name|drawn
operator|.
name|setBit
argument_list|(
name|currentBit
argument_list|)
expr_stmt|;
name|int
name|col
init|=
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|visualColumnIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|col
argument_list|)
condition|)
continue|continue;
name|int
name|colp
init|=
name|columnViewportPosition
argument_list|(
name|col
argument_list|)
decl_stmt|;
name|colp
operator|+=
name|offset
operator|.
name|x
argument_list|()
expr_stmt|;
name|int
name|colw
init|=
name|columnWidth
argument_list|(
name|col
argument_list|)
operator|-
name|gridSize
decl_stmt|;
specifier|const
name|QModelIndex
name|index
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|option
operator|.
name|rect
operator|=
name|QRect
argument_list|(
name|colp
operator|+
operator|(
name|showGrid
operator|&&
name|rightToLeft
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|rowY
argument_list|,
name|colw
argument_list|,
name|rowh
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate
condition|)
block|{
if|if
condition|(
name|alternateBase
condition|)
name|option
operator|.
name|features
operator||=
name|QStyleOptionViewItem
operator|::
name|Alternate
expr_stmt|;
else|else
name|option
operator|.
name|features
operator|&=
operator|~
name|QStyleOptionViewItem
operator|::
name|Alternate
expr_stmt|;
block|}
name|d
operator|->
name|drawCell
argument_list|(
operator|&
name|painter
argument_list|,
name|option
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|alternateBase
operator|=
operator|!
name|alternateBase
operator|&&
name|alternate
expr_stmt|;
block|}
if|if
condition|(
name|showGrid
condition|)
block|{
comment|// Find the bottom right (the last rows/columns might be hidden)
while|while
condition|(
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|bottom
argument_list|)
argument_list|)
condition|)
operator|--
name|bottom
expr_stmt|;
name|QPen
name|old
init|=
name|painter
operator|.
name|pen
argument_list|()
decl_stmt|;
name|painter
operator|.
name|setPen
argument_list|(
name|gridPen
argument_list|)
expr_stmt|;
comment|// Paint each row
for|for
control|(
name|int
name|visualIndex
init|=
name|top
init|;
name|visualIndex
operator|<=
name|bottom
condition|;
operator|++
name|visualIndex
control|)
block|{
name|int
name|row
init|=
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|visualIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|row
argument_list|)
condition|)
continue|continue;
name|int
name|rowY
init|=
name|rowViewportPosition
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|rowY
operator|+=
name|offset
operator|.
name|y
argument_list|()
expr_stmt|;
name|int
name|rowh
init|=
name|rowHeight
argument_list|(
name|row
argument_list|)
operator|-
name|gridSize
decl_stmt|;
name|painter
operator|.
name|drawLine
argument_list|(
name|dirtyArea
operator|.
name|left
argument_list|()
argument_list|,
name|rowY
operator|+
name|rowh
argument_list|,
name|dirtyArea
operator|.
name|right
argument_list|()
argument_list|,
name|rowY
operator|+
name|rowh
argument_list|)
expr_stmt|;
block|}
comment|// Paint each column
for|for
control|(
name|int
name|h
init|=
name|left
init|;
name|h
operator|<=
name|right
condition|;
operator|++
name|h
control|)
block|{
name|int
name|col
init|=
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|h
argument_list|)
decl_stmt|;
if|if
condition|(
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|col
argument_list|)
condition|)
continue|continue;
name|int
name|colp
init|=
name|columnViewportPosition
argument_list|(
name|col
argument_list|)
decl_stmt|;
name|colp
operator|+=
name|offset
operator|.
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rightToLeft
condition|)
name|colp
operator|+=
name|columnWidth
argument_list|(
name|col
argument_list|)
operator|-
name|gridSize
expr_stmt|;
name|painter
operator|.
name|drawLine
argument_list|(
name|colp
argument_list|,
name|dirtyArea
operator|.
name|top
argument_list|()
argument_list|,
name|colp
argument_list|,
name|dirtyArea
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//draw the top& left grid lines if the headers are not visible.
comment|//We do update this line when subsequent scroll happen (see scrollContentsBy)
if|if
condition|(
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
operator|&&
name|verticalScrollMode
argument_list|()
operator|==
name|ScrollPerItem
condition|)
name|painter
operator|.
name|drawLine
argument_list|(
name|dirtyArea
operator|.
name|left
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dirtyArea
operator|.
name|right
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verticalHeader
operator|->
name|isHidden
argument_list|()
operator|&&
name|horizontalScrollMode
argument_list|()
operator|==
name|ScrollPerItem
condition|)
name|painter
operator|.
name|drawLine
argument_list|(
literal|0
argument_list|,
name|dirtyArea
operator|.
name|top
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dirtyArea
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setPen
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
comment|// Paint the dropIndicator
name|d
operator|->
name|paintDropIndicator
argument_list|(
operator|&
name|painter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns the index position of the model item corresponding to the     table item at position \a pos in contents coordinates. */
end_comment
begin_function
DECL|function|indexAt
name|QModelIndex
name|QTableView
operator|::
name|indexAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
name|int
name|r
init|=
name|rowAt
argument_list|(
name|pos
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|columnAt
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|r
operator|=
name|span
operator|.
name|top
argument_list|()
expr_stmt|;
name|c
operator|=
name|span
operator|.
name|left
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|root
argument_list|)
return|;
block|}
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the horizontal offset of the items in the table view.      Note that the table view uses the horizontal header section     positions to determine the positions of columns in the view.      \sa verticalOffset() */
end_comment
begin_function
DECL|function|horizontalOffset
name|int
name|QTableView
operator|::
name|horizontalOffset
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
operator|->
name|offset
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the vertical offset of the items in the table view.      Note that the table view uses the vertical header section     positions to determine the positions of rows in the view.      \sa horizontalOffset() */
end_comment
begin_function
DECL|function|verticalOffset
name|int
name|QTableView
operator|::
name|verticalOffset
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
operator|->
name|offset
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QModelIndex QTableView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers)      Moves the cursor in accordance with the given \a cursorAction, using the     information provided by the \a modifiers.      \sa QAbstractItemView::CursorAction */
end_comment
begin_function
DECL|function|moveCursor
name|QModelIndex
name|QTableView
operator|::
name|moveCursor
parameter_list|(
name|CursorAction
name|cursorAction
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|modifiers
argument_list|)
expr_stmt|;
name|int
name|bottom
init|=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|// make sure that bottom is the bottommost *visible* row
while|while
condition|(
name|bottom
operator|>=
literal|0
operator|&&
name|isRowHidden
argument_list|(
name|d
operator|->
name|logicalRow
argument_list|(
name|bottom
argument_list|)
argument_list|)
condition|)
operator|--
name|bottom
expr_stmt|;
name|int
name|right
init|=
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|right
operator|>=
literal|0
operator|&&
name|isColumnHidden
argument_list|(
name|d
operator|->
name|logicalColumn
argument_list|(
name|right
argument_list|)
argument_list|)
condition|)
operator|--
name|right
expr_stmt|;
if|if
condition|(
name|bottom
operator|==
operator|-
literal|1
operator|||
name|right
operator|==
operator|-
literal|1
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
comment|// model is empty
name|QModelIndex
name|current
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|row
init|=
literal|0
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|column
operator|<
name|right
operator|&&
name|isColumnHidden
argument_list|(
name|d
operator|->
name|logicalColumn
argument_list|(
name|column
argument_list|)
argument_list|)
condition|)
operator|++
name|column
expr_stmt|;
while|while
condition|(
name|isRowHidden
argument_list|(
name|d
operator|->
name|logicalRow
argument_list|(
name|row
argument_list|)
argument_list|)
operator|&&
name|row
operator|<
name|bottom
condition|)
operator|++
name|row
expr_stmt|;
name|d
operator|->
name|visualCursor
operator|=
name|QPoint
argument_list|(
name|column
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|d
operator|->
name|logicalRow
argument_list|(
name|row
argument_list|)
argument_list|,
name|d
operator|->
name|logicalColumn
argument_list|(
name|column
argument_list|)
argument_list|,
name|d
operator|->
name|root
argument_list|)
return|;
block|}
comment|// Update visual cursor if current index has changed.
name|QPoint
name|visualCurrent
argument_list|(
name|d
operator|->
name|visualColumn
argument_list|(
name|current
operator|.
name|column
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|visualRow
argument_list|(
name|current
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|visualCurrent
operator|!=
name|d
operator|->
name|visualCursor
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|current
operator|.
name|row
argument_list|()
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|span
operator|.
name|top
argument_list|()
operator|>
name|d
operator|->
name|visualCursor
operator|.
name|y
argument_list|()
operator|||
name|d
operator|->
name|visualCursor
operator|.
name|y
argument_list|()
operator|>
name|span
operator|.
name|bottom
argument_list|()
operator|||
name|span
operator|.
name|left
argument_list|()
operator|>
name|d
operator|->
name|visualCursor
operator|.
name|x
argument_list|()
operator|||
name|d
operator|->
name|visualCursor
operator|.
name|x
argument_list|()
operator|>
name|span
operator|.
name|right
argument_list|()
condition|)
name|d
operator|->
name|visualCursor
operator|=
name|visualCurrent
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|visualCursor
operator|=
name|visualCurrent
expr_stmt|;
block|}
block|}
name|int
name|visualRow
init|=
name|d
operator|->
name|visualCursor
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|visualRow
operator|>
name|bottom
condition|)
name|visualRow
operator|=
name|bottom
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|visualRow
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|visualColumn
init|=
name|d
operator|->
name|visualCursor
operator|.
name|x
argument_list|()
decl_stmt|;
if|if
condition|(
name|visualColumn
operator|>
name|right
condition|)
name|visualColumn
operator|=
name|right
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|visualColumn
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
block|{
if|if
condition|(
name|cursorAction
operator|==
name|MoveLeft
condition|)
name|cursorAction
operator|=
name|MoveRight
expr_stmt|;
elseif|else
if|if
condition|(
name|cursorAction
operator|==
name|MoveRight
condition|)
name|cursorAction
operator|=
name|MoveLeft
expr_stmt|;
block|}
switch|switch
condition|(
name|cursorAction
condition|)
block|{
case|case
name|MoveUp
case|:
block|{
name|int
name|originalRow
init|=
name|visualRow
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|visualRow
operator|==
literal|0
condition|)
name|visualRow
operator|=
name|d
operator|->
name|visualRow
argument_list|(
name|model
argument_list|()
operator|->
name|rowCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|// FIXME? visualRow = bottom + 1;
endif|#
directive|endif
name|int
name|r
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
operator|-
literal|1
operator|&&
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|span
operator|.
name|width
argument_list|()
operator|>
literal|1
operator|||
name|span
operator|.
name|height
argument_list|()
operator|>
literal|1
condition|)
name|visualRow
operator|=
name|d
operator|->
name|visualRow
argument_list|(
name|span
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|visualRow
operator|>=
literal|0
condition|)
block|{
operator|--
name|visualRow
expr_stmt|;
name|r
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
name|isRowHidden
argument_list|(
name|r
argument_list|)
operator|&&
name|d
operator|->
name|isCellEnabled
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|visualRow
operator|<
literal|0
condition|)
name|visualRow
operator|=
name|originalRow
expr_stmt|;
break|break;
block|}
case|case
name|MoveDown
case|:
block|{
name|int
name|originalRow
init|=
name|visualRow
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|current
operator|.
name|row
argument_list|()
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|visualRow
operator|=
name|d
operator|->
name|visualRow
argument_list|(
name|d
operator|->
name|rowSpanEndLogical
argument_list|(
name|span
operator|.
name|top
argument_list|()
argument_list|,
name|span
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|visualRow
operator|>=
name|bottom
condition|)
name|visualRow
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|int
name|r
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
operator|-
literal|1
operator|&&
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|span
operator|.
name|width
argument_list|()
operator|>
literal|1
operator|||
name|span
operator|.
name|height
argument_list|()
operator|>
literal|1
condition|)
name|visualRow
operator|=
name|d
operator|->
name|visualRow
argument_list|(
name|d
operator|->
name|rowSpanEndLogical
argument_list|(
name|span
operator|.
name|top
argument_list|()
argument_list|,
name|span
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|visualRow
operator|<=
name|bottom
condition|)
block|{
operator|++
name|visualRow
expr_stmt|;
name|r
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
name|isRowHidden
argument_list|(
name|r
argument_list|)
operator|&&
name|d
operator|->
name|isCellEnabled
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|visualRow
operator|>
name|bottom
condition|)
name|visualRow
operator|=
name|originalRow
expr_stmt|;
break|break;
block|}
case|case
name|MovePrevious
case|:
case|case
name|MoveLeft
case|:
block|{
name|int
name|originalRow
init|=
name|visualRow
decl_stmt|;
name|int
name|originalColumn
init|=
name|visualColumn
decl_stmt|;
name|bool
name|firstTime
init|=
literal|true
decl_stmt|;
name|bool
name|looped
init|=
literal|false
decl_stmt|;
name|bool
name|wrapped
init|=
literal|false
decl_stmt|;
do|do
block|{
name|int
name|r
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstTime
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|firstTime
operator|=
literal|false
expr_stmt|;
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|span
operator|.
name|width
argument_list|()
operator|>
literal|1
operator|||
name|span
operator|.
name|height
argument_list|()
operator|>
literal|1
condition|)
name|visualColumn
operator|=
name|d
operator|->
name|visualColumn
argument_list|(
name|span
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|visualColumn
operator|>=
literal|0
condition|)
block|{
operator|--
name|visualColumn
expr_stmt|;
name|r
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
name|c
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
name|isRowHidden
argument_list|(
name|r
argument_list|)
operator|&&
operator|!
name|isColumnHidden
argument_list|(
name|c
argument_list|)
operator|&&
name|d
operator|->
name|isCellEnabled
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|wrapped
operator|&&
operator|(
name|originalRow
operator|<
name|visualRow
operator|||
operator|(
name|originalRow
operator|==
name|visualRow
operator|&&
name|originalColumn
operator|<=
name|visualColumn
operator|)
operator|)
condition|)
block|{
name|looped
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cursorAction
operator|==
name|MoveLeft
operator|||
name|visualColumn
operator|>=
literal|0
condition|)
break|break;
name|visualColumn
operator|=
name|right
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|visualRow
operator|==
literal|0
condition|)
block|{
name|wrapped
operator|=
literal|true
expr_stmt|;
name|visualRow
operator|=
name|bottom
expr_stmt|;
block|}
else|else
block|{
operator|--
name|visualRow
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|looped
condition|)
do|;
if|if
condition|(
name|visualColumn
operator|<
literal|0
condition|)
name|visualColumn
operator|=
name|originalColumn
expr_stmt|;
break|break;
block|}
case|case
name|MoveNext
case|:
case|case
name|MoveRight
case|:
block|{
name|int
name|originalRow
init|=
name|visualRow
decl_stmt|;
name|int
name|originalColumn
init|=
name|visualColumn
decl_stmt|;
name|bool
name|firstTime
init|=
literal|true
decl_stmt|;
name|bool
name|looped
init|=
literal|false
decl_stmt|;
name|bool
name|wrapped
init|=
literal|false
decl_stmt|;
do|do
block|{
name|int
name|r
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstTime
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|firstTime
operator|=
literal|false
expr_stmt|;
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|span
operator|.
name|width
argument_list|()
operator|>
literal|1
operator|||
name|span
operator|.
name|height
argument_list|()
operator|>
literal|1
condition|)
name|visualColumn
operator|=
name|d
operator|->
name|visualColumn
argument_list|(
name|d
operator|->
name|columnSpanEndLogical
argument_list|(
name|span
operator|.
name|left
argument_list|()
argument_list|,
name|span
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|visualColumn
operator|<=
name|right
condition|)
block|{
operator|++
name|visualColumn
expr_stmt|;
name|r
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
operator|||
name|c
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
name|isRowHidden
argument_list|(
name|r
argument_list|)
operator|&&
operator|!
name|isColumnHidden
argument_list|(
name|c
argument_list|)
operator|&&
name|d
operator|->
name|isCellEnabled
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|wrapped
operator|&&
operator|(
name|originalRow
operator|>
name|visualRow
operator|||
operator|(
name|originalRow
operator|==
name|visualRow
operator|&&
name|originalColumn
operator|>=
name|visualColumn
operator|)
operator|)
condition|)
block|{
name|looped
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cursorAction
operator|==
name|MoveRight
operator|||
name|visualColumn
operator|<=
name|right
condition|)
break|break;
name|visualColumn
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|visualRow
operator|==
name|bottom
condition|)
block|{
name|wrapped
operator|=
literal|true
expr_stmt|;
name|visualRow
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|visualRow
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|looped
condition|)
do|;
if|if
condition|(
name|visualColumn
operator|>
name|right
condition|)
name|visualColumn
operator|=
name|originalColumn
expr_stmt|;
break|break;
block|}
case|case
name|MoveHome
case|:
name|visualColumn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|visualColumn
operator|<
name|right
operator|&&
name|d
operator|->
name|isVisualColumnHiddenOrDisabled
argument_list|(
name|visualRow
argument_list|,
name|visualColumn
argument_list|)
condition|)
operator|++
name|visualColumn
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
block|{
name|visualRow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|visualRow
operator|<
name|bottom
operator|&&
name|d
operator|->
name|isVisualRowHiddenOrDisabled
argument_list|(
name|visualRow
argument_list|,
name|visualColumn
argument_list|)
condition|)
operator|++
name|visualRow
expr_stmt|;
block|}
break|break;
case|case
name|MoveEnd
case|:
name|visualColumn
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
name|visualRow
operator|=
name|bottom
expr_stmt|;
break|break;
case|case
name|MovePageUp
case|:
block|{
name|int
name|newRow
init|=
name|rowAt
argument_list|(
name|visualRect
argument_list|(
name|current
argument_list|)
operator|.
name|bottom
argument_list|()
operator|-
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRow
operator|==
operator|-
literal|1
condition|)
name|newRow
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|newRow
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|,
name|d
operator|->
name|root
argument_list|)
return|;
block|}
case|case
name|MovePageDown
case|:
block|{
name|int
name|newRow
init|=
name|rowAt
argument_list|(
name|visualRect
argument_list|(
name|current
argument_list|)
operator|.
name|top
argument_list|()
operator|+
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRow
operator|==
operator|-
literal|1
condition|)
name|newRow
operator|=
name|d
operator|->
name|logicalRow
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|newRow
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|,
name|d
operator|->
name|root
argument_list|)
return|;
block|}
block|}
name|d
operator|->
name|visualCursor
operator|=
name|QPoint
argument_list|(
name|visualColumn
argument_list|,
name|visualRow
argument_list|)
expr_stmt|;
name|int
name|logicalRow
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visualRow
argument_list|)
decl_stmt|;
name|int
name|logicalColumn
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visualColumn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|model
operator|->
name|hasIndex
argument_list|(
name|logicalRow
argument_list|,
name|logicalColumn
argument_list|,
name|d
operator|->
name|root
argument_list|)
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QModelIndex
name|result
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|logicalRow
argument_list|,
name|logicalColumn
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isRowHidden
argument_list|(
name|logicalRow
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|isColumnHidden
argument_list|(
name|logicalColumn
argument_list|)
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTableView::setSelection(const QRect&rect,     QItemSelectionModel::SelectionFlags flags)      Selects the items within the given \a rect and in accordance with     the specified selection \a flags. */
end_comment
begin_function
DECL|function|setSelection
name|void
name|QTableView
operator|::
name|setSelection
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|QModelIndex
name|tl
init|=
name|indexAt
argument_list|(
name|QPoint
argument_list|(
name|isRightToLeft
argument_list|()
condition|?
name|qMax
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
else|:
name|qMin
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|indexAt
argument_list|(
name|QPoint
argument_list|(
name|isRightToLeft
argument_list|()
condition|?
name|qMin
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
else|:
name|qMax
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|selectionModel
operator|||
operator|!
name|tl
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|br
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|tl
argument_list|)
operator|||
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|br
argument_list|)
condition|)
return|return;
name|bool
name|verticalMoved
init|=
name|verticalHeader
argument_list|()
operator|->
name|sectionsMoved
argument_list|()
decl_stmt|;
name|bool
name|horizontalMoved
init|=
name|horizontalHeader
argument_list|()
operator|->
name|sectionsMoved
argument_list|()
decl_stmt|;
name|QItemSelection
name|selection
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|bool
name|expanded
decl_stmt|;
name|int
name|top
init|=
name|qMin
argument_list|(
name|d
operator|->
name|visualRow
argument_list|(
name|tl
operator|.
name|row
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|visualRow
argument_list|(
name|br
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|left
init|=
name|qMin
argument_list|(
name|d
operator|->
name|visualColumn
argument_list|(
name|tl
operator|.
name|column
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|visualColumn
argument_list|(
name|br
operator|.
name|column
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|qMax
argument_list|(
name|d
operator|->
name|visualRow
argument_list|(
name|tl
operator|.
name|row
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|visualRow
argument_list|(
name|br
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|qMax
argument_list|(
name|d
operator|->
name|visualColumn
argument_list|(
name|tl
operator|.
name|column
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|visualColumn
argument_list|(
name|br
operator|.
name|column
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
do|do
block|{
name|expanded
operator|=
literal|false
expr_stmt|;
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|it
decl|,
name|d
operator|->
name|spans
operator|.
name|spans
control|)
block|{
specifier|const
name|QSpanCollection
operator|::
name|Span
modifier|&
name|span
init|=
operator|*
name|it
decl_stmt|;
name|int
name|t
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|span
operator|.
name|top
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|span
operator|.
name|left
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|b
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|d
operator|->
name|rowSpanEndLogical
argument_list|(
name|span
operator|.
name|top
argument_list|()
argument_list|,
name|span
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|d
operator|->
name|columnSpanEndLogical
argument_list|(
name|span
operator|.
name|left
argument_list|()
argument_list|,
name|span
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|>
name|bottom
operator|)
operator|||
operator|(
name|l
operator|>
name|right
operator|)
operator|||
operator|(
name|top
operator|>
name|b
operator|)
operator|||
operator|(
name|left
operator|>
name|r
operator|)
condition|)
continue|continue;
comment|// no intersect
if|if
condition|(
name|t
operator|<
name|top
condition|)
block|{
name|top
operator|=
name|t
expr_stmt|;
name|expanded
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
name|left
condition|)
block|{
name|left
operator|=
name|l
expr_stmt|;
name|expanded
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|>
name|bottom
condition|)
block|{
name|bottom
operator|=
name|b
expr_stmt|;
name|expanded
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|>
name|right
condition|)
block|{
name|right
operator|=
name|r
expr_stmt|;
name|expanded
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|expanded
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|expanded
condition|)
do|;
for|for
control|(
name|int
name|horizontal
init|=
name|left
init|;
name|horizontal
operator|<=
name|right
condition|;
operator|++
name|horizontal
control|)
block|{
name|int
name|column
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|horizontal
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|vertical
init|=
name|top
init|;
name|vertical
operator|<=
name|bottom
condition|;
operator|++
name|vertical
control|)
block|{
name|int
name|row
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|vertical
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|selection
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|verticalMoved
operator|&&
name|horizontalMoved
condition|)
block|{
name|int
name|top
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|tl
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|left
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|tl
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|br
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|br
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|horizontal
init|=
name|left
init|;
name|horizontal
operator|<=
name|right
condition|;
operator|++
name|horizontal
control|)
block|{
name|int
name|column
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|horizontal
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|vertical
init|=
name|top
init|;
name|vertical
operator|<=
name|bottom
condition|;
operator|++
name|vertical
control|)
block|{
name|int
name|row
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|vertical
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|selection
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|horizontalMoved
condition|)
block|{
name|int
name|left
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|tl
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|d
operator|->
name|visualColumn
argument_list|(
name|br
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|visual
init|=
name|left
init|;
name|visual
operator|<=
name|right
condition|;
operator|++
name|visual
control|)
block|{
name|int
name|column
init|=
name|d
operator|->
name|logicalColumn
argument_list|(
name|visual
argument_list|)
decl_stmt|;
name|QModelIndex
name|topLeft
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|tl
operator|.
name|row
argument_list|()
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|bottomRight
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|br
operator|.
name|row
argument_list|()
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|selection
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|verticalMoved
condition|)
block|{
name|int
name|top
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|tl
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|d
operator|->
name|visualRow
argument_list|(
name|br
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|visual
init|=
name|top
init|;
name|visual
operator|<=
name|bottom
condition|;
operator|++
name|visual
control|)
block|{
name|int
name|row
init|=
name|d
operator|->
name|logicalRow
argument_list|(
name|visual
argument_list|)
decl_stmt|;
name|QModelIndex
name|topLeft
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|tl
operator|.
name|column
argument_list|()
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|bottomRight
init|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|br
operator|.
name|column
argument_list|()
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|selection
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// nothing moved
name|QItemSelectionRange
name|range
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|isEmpty
argument_list|()
condition|)
name|selection
operator|.
name|append
argument_list|(
name|range
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|selectionModel
operator|->
name|select
argument_list|(
name|selection
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the rectangle from the viewport of the items in the given     \a selection.      Since 4.7, the returned region only contains rectangles intersecting     (or included in) the viewport. */
end_comment
begin_function
DECL|function|visualRegionForSelection
name|QRegion
name|QTableView
operator|::
name|visualRegionForSelection
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selection
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|selection
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|QRegion
name|selectionRegion
decl_stmt|;
specifier|const
name|QRect
modifier|&
name|viewportRect
init|=
name|d
operator|->
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
name|bool
name|verticalMoved
init|=
name|verticalHeader
argument_list|()
operator|->
name|sectionsMoved
argument_list|()
decl_stmt|;
name|bool
name|horizontalMoved
init|=
name|horizontalHeader
argument_list|()
operator|->
name|sectionsMoved
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|verticalMoved
operator|&&
name|horizontalMoved
operator|)
operator|||
operator|(
name|d
operator|->
name|hasSpans
argument_list|()
operator|&&
operator|(
name|verticalMoved
operator|||
name|horizontalMoved
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QItemSelectionRange
name|range
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|d
operator|->
name|root
operator|||
operator|!
name|range
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
for|for
control|(
name|int
name|r
init|=
name|range
operator|.
name|top
argument_list|()
init|;
name|r
operator|<=
name|range
operator|.
name|bottom
argument_list|()
condition|;
operator|++
name|r
control|)
for|for
control|(
name|int
name|c
init|=
name|range
operator|.
name|left
argument_list|()
init|;
name|c
operator|<=
name|range
operator|.
name|right
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|QRect
modifier|&
name|rangeRect
init|=
name|visualRect
argument_list|(
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|root
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewportRect
operator|.
name|intersects
argument_list|(
name|rangeRect
argument_list|)
condition|)
name|selectionRegion
operator|+=
name|rangeRect
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|horizontalMoved
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QItemSelectionRange
name|range
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|d
operator|->
name|root
operator|||
operator|!
name|range
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
name|int
name|top
init|=
name|rowViewportPosition
argument_list|(
name|range
operator|.
name|top
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|rowViewportPosition
argument_list|(
name|range
operator|.
name|bottom
argument_list|()
argument_list|)
operator|+
name|rowHeight
argument_list|(
name|range
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|top
operator|>
name|bottom
condition|)
name|qSwap
argument_list|<
name|int
argument_list|>
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|int
name|height
init|=
name|bottom
operator|-
name|top
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|range
operator|.
name|left
argument_list|()
init|;
name|c
operator|<=
name|range
operator|.
name|right
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|QRect
name|rangeRect
argument_list|(
name|columnViewportPosition
argument_list|(
name|c
argument_list|)
argument_list|,
name|top
argument_list|,
name|columnWidth
argument_list|(
name|c
argument_list|)
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewportRect
operator|.
name|intersects
argument_list|(
name|rangeRect
argument_list|)
condition|)
name|selectionRegion
operator|+=
name|rangeRect
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|verticalMoved
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QItemSelectionRange
name|range
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|d
operator|->
name|root
operator|||
operator|!
name|range
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
name|int
name|left
init|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|left
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|right
argument_list|()
argument_list|)
operator|+
name|columnWidth
argument_list|(
name|range
operator|.
name|right
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|>
name|right
condition|)
name|qSwap
argument_list|<
name|int
argument_list|>
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|int
name|width
init|=
name|right
operator|-
name|left
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
name|range
operator|.
name|top
argument_list|()
init|;
name|r
operator|<=
name|range
operator|.
name|bottom
argument_list|()
condition|;
operator|++
name|r
control|)
block|{
specifier|const
name|QRect
name|rangeRect
argument_list|(
name|left
argument_list|,
name|rowViewportPosition
argument_list|(
name|r
argument_list|)
argument_list|,
name|width
argument_list|,
name|rowHeight
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewportRect
operator|.
name|intersects
argument_list|(
name|rangeRect
argument_list|)
condition|)
name|selectionRegion
operator|+=
name|rangeRect
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// nothing moved
specifier|const
name|int
name|gridAdjust
init|=
name|showGrid
argument_list|()
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selection
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QItemSelectionRange
name|range
init|=
name|selection
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|.
name|parent
argument_list|()
operator|!=
name|d
operator|->
name|root
operator|||
operator|!
name|range
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
name|d
operator|->
name|trimHiddenSelections
argument_list|(
operator|&
name|range
argument_list|)
expr_stmt|;
specifier|const
name|int
name|rtop
init|=
name|rowViewportPosition
argument_list|(
name|range
operator|.
name|top
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|rbottom
init|=
name|rowViewportPosition
argument_list|(
name|range
operator|.
name|bottom
argument_list|()
argument_list|)
operator|+
name|rowHeight
argument_list|(
name|range
operator|.
name|bottom
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|rleft
decl_stmt|;
name|int
name|rright
decl_stmt|;
if|if
condition|(
name|isLeftToRight
argument_list|()
condition|)
block|{
name|rleft
operator|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
name|rright
operator|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|right
argument_list|()
argument_list|)
operator|+
name|columnWidth
argument_list|(
name|range
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rleft
operator|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|right
argument_list|()
argument_list|)
expr_stmt|;
name|rright
operator|=
name|columnViewportPosition
argument_list|(
name|range
operator|.
name|left
argument_list|()
argument_list|)
operator|+
name|columnWidth
argument_list|(
name|range
operator|.
name|left
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QRect
name|rangeRect
argument_list|(
name|QPoint
argument_list|(
name|rleft
argument_list|,
name|rtop
argument_list|)
argument_list|,
name|QPoint
argument_list|(
name|rright
operator|-
literal|1
operator|-
name|gridAdjust
argument_list|,
name|rbottom
operator|-
literal|1
operator|-
name|gridAdjust
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewportRect
operator|.
name|intersects
argument_list|(
name|rangeRect
argument_list|)
condition|)
name|selectionRegion
operator|+=
name|rangeRect
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QSpanCollection
operator|::
name|Span
modifier|*
name|s
decl|,
name|d
operator|->
name|spans
operator|.
name|spansInRect
argument_list|(
name|range
operator|.
name|left
argument_list|()
argument_list|,
name|range
operator|.
name|top
argument_list|()
argument_list|,
name|range
operator|.
name|width
argument_list|()
argument_list|,
name|range
operator|.
name|height
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|range
operator|.
name|contains
argument_list|(
name|s
operator|->
name|top
argument_list|()
argument_list|,
name|s
operator|->
name|left
argument_list|()
argument_list|,
name|range
operator|.
name|parent
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|QRect
modifier|&
name|visualSpanRect
init|=
name|d
operator|->
name|visualSpanRect
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewportRect
operator|.
name|intersects
argument_list|(
name|visualSpanRect
argument_list|)
condition|)
name|selectionRegion
operator|+=
name|visualSpanRect
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|selectionRegion
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|selectedIndexes
name|QModelIndexList
name|QTableView
operator|::
name|selectedIndexes
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|QModelIndexList
name|viewSelected
decl_stmt|;
name|QModelIndexList
name|modelSelected
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
name|modelSelected
operator|=
name|d
operator|->
name|selectionModel
operator|->
name|selectedIndexes
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelSelected
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QModelIndex
name|index
init|=
name|modelSelected
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isIndexHidden
argument_list|(
name|index
argument_list|)
operator|&&
name|index
operator|.
name|parent
argument_list|()
operator|==
name|d
operator|->
name|root
condition|)
name|viewSelected
operator|.
name|append
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|viewSelected
return|;
block|}
end_function
begin_comment
comment|/*!     This slot is called whenever rows are added or deleted. The     previous number of rows is specified by \a oldCount, and the new     number of rows is specified by \a newCount. */
end_comment
begin_function
DECL|function|rowCountChanged
name|void
name|QTableView
operator|::
name|rowCountChanged
parameter_list|(
name|int
name|oldCount
parameter_list|,
name|int
name|newCount
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
comment|//when removing rows, we need to disable updates for the header until the geometries have been
comment|//updated and the offset has been adjusted, or we risk calling paintSection for all the sections
if|if
condition|(
name|newCount
operator|<
name|oldCount
condition|)
name|d
operator|->
name|verticalHeader
operator|->
name|setUpdatesEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called whenever columns are added or deleted. The     previous number of columns is specified by \a oldCount, and the new     number of columns is specified by \a newCount. */
end_comment
begin_function
DECL|function|columnCountChanged
name|void
name|QTableView
operator|::
name|columnCountChanged
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
if|if
condition|(
name|horizontalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
name|d
operator|->
name|horizontalHeader
operator|->
name|setOffsetToSectionPosition
argument_list|(
name|horizontalScrollBar
argument_list|()
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|horizontalHeader
operator|->
name|setOffset
argument_list|(
name|horizontalScrollBar
argument_list|()
operator|->
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|updateGeometries
name|void
name|QTableView
operator|::
name|updateGeometries
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|geometryRecursionBlock
condition|)
return|return;
name|d
operator|->
name|geometryRecursionBlock
operator|=
literal|true
expr_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|verticalHeader
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|width
operator|=
name|qMax
argument_list|(
name|d
operator|->
name|verticalHeader
operator|->
name|minimumWidth
argument_list|()
argument_list|,
name|d
operator|->
name|verticalHeader
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|width
operator|=
name|qMin
argument_list|(
name|width
argument_list|,
name|d
operator|->
name|verticalHeader
operator|->
name|maximumWidth
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|height
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|height
operator|=
name|qMax
argument_list|(
name|d
operator|->
name|horizontalHeader
operator|->
name|minimumHeight
argument_list|()
argument_list|,
name|d
operator|->
name|horizontalHeader
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|height
operator|=
name|qMin
argument_list|(
name|height
argument_list|,
name|d
operator|->
name|horizontalHeader
operator|->
name|maximumHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|bool
name|reverse
init|=
name|isRightToLeft
argument_list|()
decl_stmt|;
if|if
condition|(
name|reverse
condition|)
name|setViewportMargins
argument_list|(
literal|0
argument_list|,
name|height
argument_list|,
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|setViewportMargins
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// update headers
name|QRect
name|vg
init|=
name|d
operator|->
name|viewport
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|int
name|verticalLeft
init|=
name|reverse
condition|?
name|vg
operator|.
name|right
argument_list|()
operator|+
literal|1
else|:
operator|(
name|vg
operator|.
name|left
argument_list|()
operator|-
name|width
operator|)
decl_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|setGeometry
argument_list|(
name|verticalLeft
argument_list|,
name|vg
operator|.
name|top
argument_list|()
argument_list|,
name|width
argument_list|,
name|vg
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|verticalHeader
operator|->
name|isHidden
argument_list|()
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
literal|"updateGeometries"
argument_list|)
expr_stmt|;
name|int
name|horizontalTop
init|=
name|vg
operator|.
name|top
argument_list|()
operator|-
name|height
decl_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setGeometry
argument_list|(
name|vg
operator|.
name|left
argument_list|()
argument_list|,
name|horizontalTop
argument_list|,
name|vg
operator|.
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
literal|"updateGeometries"
argument_list|)
expr_stmt|;
comment|// update cornerWidget
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|->
name|isHidden
argument_list|()
operator|||
name|d
operator|->
name|verticalHeader
operator|->
name|isHidden
argument_list|()
condition|)
block|{
name|d
operator|->
name|cornerWidget
operator|->
name|setHidden
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|cornerWidget
operator|->
name|setHidden
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|cornerWidget
operator|->
name|setGeometry
argument_list|(
name|verticalLeft
argument_list|,
name|horizontalTop
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
comment|// update scroll bars
comment|// ### move this block into the if
name|QSize
name|vsize
init|=
name|d
operator|->
name|viewport
operator|->
name|size
argument_list|()
decl_stmt|;
name|QSize
name|max
init|=
name|maximumViewportSize
argument_list|()
decl_stmt|;
name|uint
name|horizontalLength
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|length
argument_list|()
decl_stmt|;
name|uint
name|verticalLength
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|uint
operator|)
name|max
operator|.
name|width
argument_list|()
operator|>=
name|horizontalLength
operator|&&
operator|(
name|uint
operator|)
name|max
operator|.
name|height
argument_list|()
operator|>=
name|verticalLength
condition|)
name|vsize
operator|=
name|max
expr_stmt|;
comment|// horizontal scroll bar
specifier|const
name|int
name|columnCount
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|count
argument_list|()
decl_stmt|;
specifier|const
name|int
name|viewportWidth
init|=
name|vsize
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|columnsInViewport
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|width
init|=
literal|0
init|,
name|column
init|=
name|columnCount
operator|-
literal|1
init|;
name|column
operator|>=
literal|0
condition|;
operator|--
name|column
control|)
block|{
name|int
name|logical
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|logical
argument_list|)
condition|)
block|{
name|width
operator|+=
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionSize
argument_list|(
name|logical
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|viewportWidth
condition|)
break|break;
operator|++
name|columnsInViewport
expr_stmt|;
block|}
block|}
name|columnsInViewport
operator|=
name|qMax
argument_list|(
name|columnsInViewport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//there must be always at least 1 column
if|if
condition|(
name|horizontalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
specifier|const
name|int
name|visibleColumns
init|=
name|columnCount
operator|-
name|d
operator|->
name|horizontalHeader
operator|->
name|hiddenSectionCount
argument_list|()
decl_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|visibleColumns
operator|-
name|columnsInViewport
argument_list|)
expr_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setPageStep
argument_list|(
name|columnsInViewport
argument_list|)
expr_stmt|;
if|if
condition|(
name|columnsInViewport
operator|>=
name|visibleColumns
condition|)
name|d
operator|->
name|horizontalHeader
operator|->
name|setOffset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setSingleStep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ScrollPerPixel
name|horizontalScrollBar
argument_list|()
operator|->
name|setPageStep
argument_list|(
name|vsize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|horizontalLength
operator|-
name|vsize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setSingleStep
argument_list|(
name|qMax
argument_list|(
name|vsize
operator|.
name|width
argument_list|()
operator|/
operator|(
name|columnsInViewport
operator|+
literal|1
operator|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// vertical scroll bar
specifier|const
name|int
name|rowCount
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|count
argument_list|()
decl_stmt|;
specifier|const
name|int
name|viewportHeight
init|=
name|vsize
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|rowsInViewport
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|height
init|=
literal|0
init|,
name|row
init|=
name|rowCount
operator|-
literal|1
init|;
name|row
operator|>=
literal|0
condition|;
operator|--
name|row
control|)
block|{
name|int
name|logical
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|logical
argument_list|)
condition|)
block|{
name|height
operator|+=
name|d
operator|->
name|verticalHeader
operator|->
name|sectionSize
argument_list|(
name|logical
argument_list|)
expr_stmt|;
if|if
condition|(
name|height
operator|>
name|viewportHeight
condition|)
break|break;
operator|++
name|rowsInViewport
expr_stmt|;
block|}
block|}
name|rowsInViewport
operator|=
name|qMax
argument_list|(
name|rowsInViewport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//there must be always at least 1 row
if|if
condition|(
name|verticalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
specifier|const
name|int
name|visibleRows
init|=
name|rowCount
operator|-
name|d
operator|->
name|verticalHeader
operator|->
name|hiddenSectionCount
argument_list|()
decl_stmt|;
name|verticalScrollBar
argument_list|()
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|visibleRows
operator|-
name|rowsInViewport
argument_list|)
expr_stmt|;
name|verticalScrollBar
argument_list|()
operator|->
name|setPageStep
argument_list|(
name|rowsInViewport
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowsInViewport
operator|>=
name|visibleRows
condition|)
name|d
operator|->
name|verticalHeader
operator|->
name|setOffset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|verticalScrollBar
argument_list|()
operator|->
name|setSingleStep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ScrollPerPixel
name|verticalScrollBar
argument_list|()
operator|->
name|setPageStep
argument_list|(
name|vsize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|verticalScrollBar
argument_list|()
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
name|verticalLength
operator|-
name|vsize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|verticalScrollBar
argument_list|()
operator|->
name|setSingleStep
argument_list|(
name|qMax
argument_list|(
name|vsize
operator|.
name|height
argument_list|()
operator|/
operator|(
name|rowsInViewport
operator|+
literal|1
operator|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|geometryRecursionBlock
operator|=
literal|false
expr_stmt|;
name|QAbstractItemView
operator|::
name|updateGeometries
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the size hint for the given \a row's height or -1 if there     is no model.      If you need to set the height of a given row to a fixed value, call     QHeaderView::resizeSection() on the table's vertical header.      If you reimplement this function in a subclass, note that the value you     return is only used when resizeRowToContents() is called. In that case,     if a larger row height is required by either the vertical header or     the item delegate, that width will be used instead.      \sa QWidget::sizeHint, verticalHeader() */
end_comment
begin_function
DECL|function|sizeHintForRow
name|int
name|QTableView
operator|::
name|sizeHintForRow
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|model
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|ensurePolished
argument_list|()
expr_stmt|;
specifier|const
name|int
name|maximumProcessCols
init|=
literal|1000
decl_stmt|;
comment|// To avoid this to take forever.
name|int
name|left
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|visualIndexAt
argument_list|(
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|==
operator|-
literal|1
condition|)
comment|// the table don't have enough columns to fill the viewport
name|right
operator|=
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|int
name|hint
init|=
literal|0
decl_stmt|;
name|QModelIndex
name|index
decl_stmt|;
name|int
name|columnsProcessed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|column
init|=
name|left
init|;
name|column
operator|<=
name|right
condition|;
operator|++
name|column
control|)
block|{
name|int
name|logicalColumn
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|logicalColumn
argument_list|)
condition|)
continue|continue;
name|index
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|logicalColumn
argument_list|,
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|wrapItemText
condition|)
block|{
comment|// for wrapping boundaries
name|option
operator|.
name|rect
operator|.
name|setY
argument_list|(
name|rowViewportPosition
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|option
operator|.
name|rect
operator|.
name|setHeight
argument_list|(
name|rowHeight
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|option
operator|.
name|rect
operator|.
name|setX
argument_list|(
name|columnViewportPosition
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|option
operator|.
name|rect
operator|.
name|setWidth
argument_list|(
name|columnWidth
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|editor
operator|&&
name|d
operator|->
name|persistent
operator|.
name|contains
argument_list|(
name|editor
argument_list|)
condition|)
block|{
name|hint
operator|=
name|qMax
argument_list|(
name|hint
argument_list|,
name|editor
operator|->
name|sizeHint
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|min
init|=
name|editor
operator|->
name|minimumSize
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|editor
operator|->
name|maximumSize
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|hint
operator|=
name|qBound
argument_list|(
name|min
argument_list|,
name|hint
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|hint
operator|=
name|qMax
argument_list|(
name|hint
argument_list|,
name|itemDelegate
argument_list|(
name|index
argument_list|)
operator|->
name|sizeHint
argument_list|(
name|option
argument_list|,
name|index
argument_list|)
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|columnsProcessed
expr_stmt|;
if|if
condition|(
name|columnsProcessed
operator|==
name|maximumProcessCols
condition|)
break|break;
block|}
return|return
name|d
operator|->
name|showGrid
condition|?
name|hint
operator|+
literal|1
else|:
name|hint
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size hint for the given \a column's width or -1 if     there is no model.      If you need to set the width of a given column to a fixed value, call     QHeaderView::resizeSection() on the table's horizontal header.      If you reimplement this function in a subclass, note that the value you     return will be used when resizeColumnToContents() or     QHeaderView::resizeSections() is called. If a larger column width is     required by either the horizontal header or the item delegate, the larger     width will be used instead.      \sa QWidget::sizeHint, horizontalHeader() */
end_comment
begin_function
DECL|function|sizeHintForColumn
name|int
name|QTableView
operator|::
name|sizeHintForColumn
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|model
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|ensurePolished
argument_list|()
expr_stmt|;
specifier|const
name|int
name|maximumProcessRows
init|=
literal|1000
decl_stmt|;
comment|// To avoid this to take forever.
name|int
name|top
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|visualIndexAt
argument_list|(
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isVisible
argument_list|()
operator|||
name|bottom
operator|==
operator|-
literal|1
condition|)
comment|// the table don't have enough rows to fill the viewport
name|bottom
operator|=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
expr_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|int
name|hint
init|=
literal|0
decl_stmt|;
name|int
name|rowsProcessed
init|=
literal|0
decl_stmt|;
name|QModelIndex
name|index
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
name|top
init|;
name|row
operator|<=
name|bottom
condition|;
operator|++
name|row
control|)
block|{
name|int
name|logicalRow
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|logicalRow
argument_list|)
condition|)
continue|continue;
name|index
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|logicalRow
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|editor
operator|&&
name|d
operator|->
name|persistent
operator|.
name|contains
argument_list|(
name|editor
argument_list|)
condition|)
block|{
name|hint
operator|=
name|qMax
argument_list|(
name|hint
argument_list|,
name|editor
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|min
init|=
name|editor
operator|->
name|minimumSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|editor
operator|->
name|maximumSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|hint
operator|=
name|qBound
argument_list|(
name|min
argument_list|,
name|hint
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|hint
operator|=
name|qMax
argument_list|(
name|hint
argument_list|,
name|itemDelegate
argument_list|(
name|index
argument_list|)
operator|->
name|sizeHint
argument_list|(
name|option
argument_list|,
name|index
argument_list|)
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|rowsProcessed
expr_stmt|;
if|if
condition|(
name|rowsProcessed
operator|==
name|maximumProcessRows
condition|)
break|break;
block|}
return|return
name|d
operator|->
name|showGrid
condition|?
name|hint
operator|+
literal|1
else|:
name|hint
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the y-coordinate in contents coordinates of the given \a     row. */
end_comment
begin_function
DECL|function|rowViewportPosition
name|int
name|QTableView
operator|::
name|rowViewportPosition
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
operator|->
name|sectionViewportPosition
argument_list|(
name|row
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the row in which the given y-coordinate, \a y, in contents     coordinates is located.      \note This function returns -1 if the given coordinate is not valid     (has no row).      \sa columnAt() */
end_comment
begin_function
DECL|function|rowAt
name|int
name|QTableView
operator|::
name|rowAt
parameter_list|(
name|int
name|y
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndexAt
argument_list|(
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the height of the given \a row to be \a height. */
end_comment
begin_function
DECL|function|setRowHeight
name|void
name|QTableView
operator|::
name|setRowHeight
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|resizeSection
argument_list|(
name|row
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the height of the given \a row.      \sa resizeRowToContents(), columnWidth() */
end_comment
begin_function
DECL|function|rowHeight
name|int
name|QTableView
operator|::
name|rowHeight
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
operator|->
name|sectionSize
argument_list|(
name|row
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the x-coordinate in contents coordinates of the given \a     column. */
end_comment
begin_function
DECL|function|columnViewportPosition
name|int
name|QTableView
operator|::
name|columnViewportPosition
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionViewportPosition
argument_list|(
name|column
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the column in which the given x-coordinate, \a x, in contents     coordinates is located.      \note This function returns -1 if the given coordinate is not valid     (has no column).      \sa rowAt() */
end_comment
begin_function
DECL|function|columnAt
name|int
name|QTableView
operator|::
name|columnAt
parameter_list|(
name|int
name|x
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndexAt
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the width of the given \a column to be \a width. */
end_comment
begin_function
DECL|function|setColumnWidth
name|void
name|QTableView
operator|::
name|setColumnWidth
parameter_list|(
name|int
name|column
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|resizeSection
argument_list|(
name|column
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the given \a column.      \sa resizeColumnToContents(), rowHeight() */
end_comment
begin_function
DECL|function|columnWidth
name|int
name|QTableView
operator|::
name|columnWidth
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionSize
argument_list|(
name|column
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the given \a row is hidden; otherwise returns false.      \sa isColumnHidden() */
end_comment
begin_function
DECL|function|isRowHidden
name|bool
name|QTableView
operator|::
name|isRowHidden
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|row
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If \a hide is true \a row will be hidden, otherwise it will be shown.      \sa setColumnHidden() */
end_comment
begin_function
DECL|function|setRowHidden
name|void
name|QTableView
operator|::
name|setRowHidden
parameter_list|(
name|int
name|row
parameter_list|,
name|bool
name|hide
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|d
operator|->
name|verticalHeader
operator|->
name|count
argument_list|()
condition|)
return|return;
name|d
operator|->
name|verticalHeader
operator|->
name|setSectionHidden
argument_list|(
name|row
argument_list|,
name|hide
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the given \a column is hidden; otherwise returns false.      \sa isRowHidden() */
end_comment
begin_function
DECL|function|isColumnHidden
name|bool
name|QTableView
operator|::
name|isColumnHidden
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|column
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   If \a hide is true the given \a column will be hidden; otherwise it   will be shown.    \sa setRowHidden() */
end_comment
begin_function
DECL|function|setColumnHidden
name|void
name|QTableView
operator|::
name|setColumnHidden
parameter_list|(
name|int
name|column
parameter_list|,
name|bool
name|hide
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|d
operator|->
name|horizontalHeader
operator|->
name|count
argument_list|()
condition|)
return|return;
name|d
operator|->
name|horizontalHeader
operator|->
name|setSectionHidden
argument_list|(
name|column
argument_list|,
name|hide
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \property QTableView::sortingEnabled     \brief whether sorting is enabled      If this property is true, sorting is enabled for the table.  If     this property is false, sorting is not enabled. The default value     is false.      \note. Setting the property to true with setSortingEnabled()     immediately triggers a call to sortByColumn() with the current     sort section and order.      \sa sortByColumn() */
end_comment
begin_comment
comment|/*!   If \a enabled true enables sorting for the table and immediately   trigger a call to sortByColumn() with the current sort section and   order  */
end_comment
begin_function
DECL|function|setSortingEnabled
name|void
name|QTableView
operator|::
name|setSortingEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|sortingEnabled
operator|=
name|enable
expr_stmt|;
name|horizontalHeader
argument_list|()
operator|->
name|setSortIndicatorShown
argument_list|(
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionEntered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|horizontalHeader
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|sectionPressed
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|horizontalHeader
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|sortIndicatorChanged
argument_list|(
name|int
argument_list|,
name|Qt
operator|::
name|SortOrder
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sortByColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
name|sortByColumn
argument_list|(
name|horizontalHeader
argument_list|()
operator|->
name|sortIndicatorSection
argument_list|()
argument_list|,
name|horizontalHeader
argument_list|()
operator|->
name|sortIndicatorOrder
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|connect
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
name|SIGNAL
argument_list|(
name|sectionEntered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|horizontalHeader
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|sectionPressed
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|horizontalHeader
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|sortIndicatorChanged
argument_list|(
name|int
argument_list|,
name|Qt
operator|::
name|SortOrder
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sortByColumn
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isSortingEnabled
name|bool
name|QTableView
operator|::
name|isSortingEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sortingEnabled
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTableView::showGrid     \brief whether the grid is shown      If this property is true a grid is drawn for the table; if the     property is false, no grid is drawn. The default value is true. */
end_comment
begin_function
DECL|function|showGrid
name|bool
name|QTableView
operator|::
name|showGrid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|showGrid
return|;
block|}
end_function
begin_function
DECL|function|setShowGrid
name|void
name|QTableView
operator|::
name|setShowGrid
parameter_list|(
name|bool
name|show
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|showGrid
operator|!=
name|show
condition|)
block|{
name|d
operator|->
name|showGrid
operator|=
name|show
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \property QTableView::gridStyle   \brief  the pen style used to draw the grid.    This property holds the style used when drawing the grid (see \l{showGrid}). */
end_comment
begin_function
DECL|function|gridStyle
name|Qt
operator|::
name|PenStyle
name|QTableView
operator|::
name|gridStyle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|gridStyle
return|;
block|}
end_function
begin_function
DECL|function|setGridStyle
name|void
name|QTableView
operator|::
name|setGridStyle
parameter_list|(
name|Qt
operator|::
name|PenStyle
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|gridStyle
operator|!=
name|style
condition|)
block|{
name|d
operator|->
name|gridStyle
operator|=
name|style
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QTableView::wordWrap     \brief the item text word-wrapping policy     \since 4.3      If this property is true then the item text is wrapped where     necessary at word-breaks; otherwise it is not wrapped at all.     This property is true by default.      Note that even of wrapping is enabled, the cell will not be     expanded to fit all text. Ellipsis will be inserted according to     the current \l{QAbstractItemView::}{textElideMode}.  */
end_comment
begin_function
DECL|function|setWordWrap
name|void
name|QTableView
operator|::
name|setWordWrap
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|wrapItemText
operator|==
name|on
condition|)
return|return;
name|d
operator|->
name|wrapItemText
operator|=
name|on
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|d
operator|->
name|verticalHeader
argument_list|,
literal|"resizeSections"
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|d
operator|->
name|horizontalHeader
argument_list|,
literal|"resizeSections"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wordWrap
name|bool
name|QTableView
operator|::
name|wordWrap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|wrapItemText
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTableView::cornerButtonEnabled     \brief whether the button in the top-left corner is enabled     \since 4.3      If this property is true then button in the top-left corner     of the table view is enabled. Clicking on this button will     select all the cells in the table view.      This property is true by default. */
end_comment
begin_function
DECL|function|setCornerButtonEnabled
name|void
name|QTableView
operator|::
name|setCornerButtonEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|cornerWidget
operator|->
name|setEnabled
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isCornerButtonEnabled
name|bool
name|QTableView
operator|::
name|isCornerButtonEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cornerWidget
operator|->
name|isEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the rectangle on the viewport occupied by the given \a     index.     If the index is hidden in the view it will return a null QRect. */
end_comment
begin_function
DECL|function|visualRect
name|QRect
name|QTableView
operator|::
name|visualRect
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
operator|||
name|index
operator|.
name|parent
argument_list|()
operator|!=
name|d
operator|->
name|root
operator|||
operator|(
operator|!
name|d
operator|->
name|hasSpans
argument_list|()
operator|&&
name|isIndexHidden
argument_list|(
name|index
argument_list|)
operator|)
condition|)
return|return
name|QRect
argument_list|()
return|;
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|visualSpanRect
argument_list|(
name|span
argument_list|)
return|;
block|}
name|int
name|rowp
init|=
name|rowViewportPosition
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|rowh
init|=
name|rowHeight
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|colp
init|=
name|columnViewportPosition
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|colw
init|=
name|columnWidth
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|i
init|=
name|showGrid
argument_list|()
condition|?
literal|1
else|:
literal|0
decl_stmt|;
return|return
name|QRect
argument_list|(
name|colp
argument_list|,
name|rowp
argument_list|,
name|colw
operator|-
name|i
argument_list|,
name|rowh
operator|-
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Makes sure that the given \a item is visible in the table view,     scrolling if necessary. */
end_comment
begin_function
DECL|function|scrollTo
name|void
name|QTableView
operator|::
name|scrollTo
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|ScrollHint
name|hint
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
comment|// check if we really need to do anything
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
operator|||
operator|(
name|d
operator|->
name|model
operator|->
name|parent
argument_list|(
name|index
argument_list|)
operator|!=
name|d
operator|->
name|root
operator|)
operator|||
name|isRowHidden
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
operator|||
name|isColumnHidden
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
condition|)
return|return;
name|QSpanCollection
operator|::
name|Span
name|span
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
name|span
operator|=
name|d
operator|->
name|span
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
comment|// Adjust horizontal position
name|int
name|viewportWidth
init|=
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|horizontalOffset
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|int
name|horizontalPosition
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionPosition
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|horizontalIndex
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|visualIndex
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|cellWidth
init|=
name|d
operator|->
name|hasSpans
argument_list|()
condition|?
name|d
operator|->
name|columnSpanWidth
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|,
name|span
operator|.
name|width
argument_list|()
argument_list|)
else|:
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionSize
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|horizontalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
name|bool
name|positionAtLeft
init|=
operator|(
name|horizontalPosition
operator|-
name|horizontalOffset
operator|<
literal|0
operator|)
decl_stmt|;
name|bool
name|positionAtRight
init|=
operator|(
name|horizontalPosition
operator|-
name|horizontalOffset
operator|+
name|cellWidth
operator|>
name|viewportWidth
operator|)
decl_stmt|;
if|if
condition|(
name|hint
operator|==
name|PositionAtCenter
operator|||
name|positionAtRight
condition|)
block|{
name|int
name|w
init|=
operator|(
name|hint
operator|==
name|PositionAtCenter
condition|?
name|viewportWidth
operator|/
literal|2
else|:
name|viewportWidth
operator|)
decl_stmt|;
name|int
name|x
init|=
name|cellWidth
decl_stmt|;
while|while
condition|(
name|horizontalIndex
operator|>
literal|0
condition|)
block|{
name|x
operator|+=
name|columnWidth
argument_list|(
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|horizontalIndex
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|w
condition|)
break|break;
operator|--
name|horizontalIndex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positionAtRight
operator|||
name|hint
operator|==
name|PositionAtCenter
operator|||
name|positionAtLeft
condition|)
block|{
name|int
name|hiddenSections
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionsHidden
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|s
init|=
name|horizontalIndex
operator|-
literal|1
init|;
name|s
operator|>=
literal|0
condition|;
operator|--
name|s
control|)
block|{
name|int
name|column
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|horizontalHeader
operator|->
name|isSectionHidden
argument_list|(
name|column
argument_list|)
condition|)
operator|++
name|hiddenSections
expr_stmt|;
block|}
block|}
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|horizontalIndex
operator|-
name|hiddenSections
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ScrollPerPixel
if|if
condition|(
name|hint
operator|==
name|PositionAtCenter
condition|)
block|{
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|horizontalPosition
operator|-
operator|(
operator|(
name|viewportWidth
operator|-
name|cellWidth
operator|)
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|horizontalPosition
operator|-
name|horizontalOffset
argument_list|<
literal|0
operator|||
name|cellWidth
argument_list|>
name|viewportWidth
condition|)
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|horizontalPosition
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|horizontalPosition
operator|-
name|horizontalOffset
operator|+
name|cellWidth
operator|>
name|viewportWidth
condition|)
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|horizontalPosition
operator|-
name|viewportWidth
operator|+
name|cellWidth
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Adjust vertical position
name|int
name|viewportHeight
init|=
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
decl_stmt|;
name|int
name|verticalOffset
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|offset
argument_list|()
decl_stmt|;
name|int
name|verticalPosition
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|sectionPosition
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|verticalIndex
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|visualIndex
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|cellHeight
init|=
name|d
operator|->
name|hasSpans
argument_list|()
condition|?
name|d
operator|->
name|rowSpanHeight
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|span
operator|.
name|height
argument_list|()
argument_list|)
else|:
name|d
operator|->
name|verticalHeader
operator|->
name|sectionSize
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|verticalPosition
operator|-
name|verticalOffset
argument_list|<
literal|0
operator|||
name|cellHeight
argument_list|>
name|viewportHeight
condition|)
block|{
if|if
condition|(
name|hint
operator|==
name|EnsureVisible
condition|)
name|hint
operator|=
name|PositionAtTop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verticalPosition
operator|-
name|verticalOffset
operator|+
name|cellHeight
operator|>
name|viewportHeight
condition|)
block|{
if|if
condition|(
name|hint
operator|==
name|EnsureVisible
condition|)
name|hint
operator|=
name|PositionAtBottom
expr_stmt|;
block|}
if|if
condition|(
name|verticalScrollMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|ScrollPerItem
condition|)
block|{
if|if
condition|(
name|hint
operator|==
name|PositionAtBottom
operator|||
name|hint
operator|==
name|PositionAtCenter
condition|)
block|{
name|int
name|h
init|=
operator|(
name|hint
operator|==
name|PositionAtCenter
condition|?
name|viewportHeight
operator|/
literal|2
else|:
name|viewportHeight
operator|)
decl_stmt|;
name|int
name|y
init|=
name|cellHeight
decl_stmt|;
while|while
condition|(
name|verticalIndex
operator|>
literal|0
condition|)
block|{
name|int
name|row
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|verticalIndex
operator|-
literal|1
argument_list|)
decl_stmt|;
name|y
operator|+=
name|d
operator|->
name|verticalHeader
operator|->
name|sectionSize
argument_list|(
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|h
condition|)
break|break;
operator|--
name|verticalIndex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hint
operator|==
name|PositionAtBottom
operator|||
name|hint
operator|==
name|PositionAtCenter
operator|||
name|hint
operator|==
name|PositionAtTop
condition|)
block|{
name|int
name|hiddenSections
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|verticalHeader
operator|->
name|sectionsHidden
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|s
init|=
name|verticalIndex
operator|-
literal|1
init|;
name|s
operator|>=
literal|0
condition|;
operator|--
name|s
control|)
block|{
name|int
name|row
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|verticalHeader
operator|->
name|isSectionHidden
argument_list|(
name|row
argument_list|)
condition|)
operator|++
name|hiddenSections
expr_stmt|;
block|}
block|}
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalIndex
operator|-
name|hiddenSections
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ScrollPerPixel
if|if
condition|(
name|hint
operator|==
name|PositionAtTop
condition|)
block|{
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalPosition
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hint
operator|==
name|PositionAtBottom
condition|)
block|{
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalPosition
operator|-
name|viewportHeight
operator|+
name|cellHeight
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hint
operator|==
name|PositionAtCenter
condition|)
block|{
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalPosition
operator|-
operator|(
operator|(
name|viewportHeight
operator|-
name|cellHeight
operator|)
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|update
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called to change the height of the given \a row. The     old height is specified by \a oldHeight, and the new height by \a     newHeight.      \sa columnResized() */
end_comment
begin_function
DECL|function|rowResized
name|void
name|QTableView
operator|::
name|rowResized
parameter_list|(
name|int
name|row
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|rowsToUpdate
operator|.
name|append
argument_list|(
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rowResizeTimerID
operator|==
literal|0
condition|)
name|d
operator|->
name|rowResizeTimerID
operator|=
name|startTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called to change the width of the given \a column.     The old width is specified by \a oldWidth, and the new width by \a     newWidth.      \sa rowResized() */
end_comment
begin_function
DECL|function|columnResized
name|void
name|QTableView
operator|::
name|columnResized
parameter_list|(
name|int
name|column
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|columnsToUpdate
operator|.
name|append
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|columnResizeTimerID
operator|==
literal|0
condition|)
name|d
operator|->
name|columnResizeTimerID
operator|=
name|startTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  \reimp  */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QTableView
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|columnResizeTimerID
condition|)
block|{
name|updateGeometries
argument_list|()
expr_stmt|;
name|killTimer
argument_list|(
name|d
operator|->
name|columnResizeTimerID
argument_list|)
expr_stmt|;
name|d
operator|->
name|columnResizeTimerID
operator|=
literal|0
expr_stmt|;
name|QRect
name|rect
decl_stmt|;
name|int
name|viewportHeight
init|=
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
decl_stmt|;
name|int
name|viewportWidth
init|=
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|rect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|viewportWidth
argument_list|,
name|viewportHeight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|columnsToUpdate
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|column
init|=
name|d
operator|->
name|columnsToUpdate
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|columnViewportPosition
argument_list|(
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
name|rect
operator||=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|x
operator|+
name|columnWidth
argument_list|(
name|column
argument_list|)
argument_list|,
name|viewportHeight
argument_list|)
expr_stmt|;
else|else
name|rect
operator||=
name|QRect
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|viewportWidth
operator|-
name|x
argument_list|,
name|viewportHeight
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|rect
operator|.
name|normalized
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|columnsToUpdate
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|rowResizeTimerID
condition|)
block|{
name|updateGeometries
argument_list|()
expr_stmt|;
name|killTimer
argument_list|(
name|d
operator|->
name|rowResizeTimerID
argument_list|)
expr_stmt|;
name|d
operator|->
name|rowResizeTimerID
operator|=
literal|0
expr_stmt|;
name|int
name|viewportHeight
init|=
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
decl_stmt|;
name|int
name|viewportWidth
init|=
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|top
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|top
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|viewportHeight
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|rowsToUpdate
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|y
init|=
name|rowViewportPosition
argument_list|(
name|d
operator|->
name|rowsToUpdate
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|top
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
name|top
argument_list|,
name|viewportWidth
argument_list|,
name|viewportHeight
operator|-
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|rowsToUpdate
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|QAbstractItemView
operator|::
name|timerEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called to change the index of the given \a row in the     table view. The old index is specified by \a oldIndex, and the new     index by \a newIndex.      \sa columnMoved() */
end_comment
begin_function
DECL|function|rowMoved
name|void
name|QTableView
operator|::
name|rowMoved
parameter_list|(
name|int
parameter_list|,
name|int
name|oldIndex
parameter_list|,
name|int
name|newIndex
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
name|int
name|logicalOldIndex
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
name|int
name|logicalNewIndex
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|logicalIndex
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldTop
init|=
name|rowViewportPosition
argument_list|(
name|logicalOldIndex
argument_list|)
decl_stmt|;
name|int
name|newTop
init|=
name|rowViewportPosition
argument_list|(
name|logicalNewIndex
argument_list|)
decl_stmt|;
name|int
name|oldBottom
init|=
name|oldTop
operator|+
name|rowHeight
argument_list|(
name|logicalOldIndex
argument_list|)
decl_stmt|;
name|int
name|newBottom
init|=
name|newTop
operator|+
name|rowHeight
argument_list|(
name|logicalNewIndex
argument_list|)
decl_stmt|;
name|int
name|top
init|=
name|qMin
argument_list|(
name|oldTop
argument_list|,
name|newTop
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|qMax
argument_list|(
name|oldBottom
argument_list|,
name|newBottom
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|bottom
operator|-
name|top
decl_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
literal|0
argument_list|,
name|top
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This slot is called to change the index of the given \a column in     the table view. The old index is specified by \a oldIndex, and     the new index by \a newIndex.      \sa rowMoved() */
end_comment
begin_function
DECL|function|columnMoved
name|void
name|QTableView
operator|::
name|columnMoved
parameter_list|(
name|int
parameter_list|,
name|int
name|oldIndex
parameter_list|,
name|int
name|newIndex
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
name|int
name|logicalOldIndex
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|oldIndex
argument_list|)
decl_stmt|;
name|int
name|logicalNewIndex
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|logicalIndex
argument_list|(
name|newIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|oldLeft
init|=
name|columnViewportPosition
argument_list|(
name|logicalOldIndex
argument_list|)
decl_stmt|;
name|int
name|newLeft
init|=
name|columnViewportPosition
argument_list|(
name|logicalNewIndex
argument_list|)
decl_stmt|;
name|int
name|oldRight
init|=
name|oldLeft
operator|+
name|columnWidth
argument_list|(
name|logicalOldIndex
argument_list|)
decl_stmt|;
name|int
name|newRight
init|=
name|newLeft
operator|+
name|columnWidth
argument_list|(
name|logicalNewIndex
argument_list|)
decl_stmt|;
name|int
name|left
init|=
name|qMin
argument_list|(
name|oldLeft
argument_list|,
name|newLeft
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|qMax
argument_list|(
name|oldRight
argument_list|,
name|newRight
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|right
operator|-
name|left
decl_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|d
operator|->
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Selects the given \a row in the table view if the current     SelectionMode and SelectionBehavior allows rows to be selected.      \sa selectColumn() */
end_comment
begin_function
DECL|function|selectRow
name|void
name|QTableView
operator|::
name|selectRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectRow
argument_list|(
name|row
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Selects the given \a column in the table view if the current     SelectionMode and SelectionBehavior allows columns to be selected.      \sa selectRow() */
end_comment
begin_function
DECL|function|selectColumn
name|void
name|QTableView
operator|::
name|selectColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectColumn
argument_list|(
name|column
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Hide the given \a row.      \sa showRow(), hideColumn() */
end_comment
begin_function
DECL|function|hideRow
name|void
name|QTableView
operator|::
name|hideRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|hideSection
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Hide the given \a column.      \sa showColumn(), hideRow() */
end_comment
begin_function
DECL|function|hideColumn
name|void
name|QTableView
operator|::
name|hideColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|hideSection
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Show the given \a row.      \sa hideRow(), showColumn() */
end_comment
begin_function
DECL|function|showRow
name|void
name|QTableView
operator|::
name|showRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|showSection
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Show the given \a column.      \sa hideColumn(), showRow() */
end_comment
begin_function
DECL|function|showColumn
name|void
name|QTableView
operator|::
name|showColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|showSection
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resizes the given \a row based on the size hints of the delegate     used to render each item in the row. */
end_comment
begin_function
DECL|function|resizeRowToContents
name|void
name|QTableView
operator|::
name|resizeRowToContents
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|int
name|content
init|=
name|sizeHintForRow
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|int
name|header
init|=
name|d
operator|->
name|verticalHeader
operator|->
name|sectionSizeHint
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|resizeSection
argument_list|(
name|row
argument_list|,
name|qMax
argument_list|(
name|content
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resizes all rows based on the size hints of the delegate     used to render each item in the rows. */
end_comment
begin_function
DECL|function|resizeRowsToContents
name|void
name|QTableView
operator|::
name|resizeRowsToContents
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|verticalHeader
operator|->
name|resizeSections
argument_list|(
name|QHeaderView
operator|::
name|ResizeToContents
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resizes the given \a column based on the size hints of the delegate     used to render each item in the column.      \note Only visible columns will be resized. Reimplement sizeHintForColumn()     to resize hidden columns as well. */
end_comment
begin_function
DECL|function|resizeColumnToContents
name|void
name|QTableView
operator|::
name|resizeColumnToContents
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|int
name|content
init|=
name|sizeHintForColumn
argument_list|(
name|column
argument_list|)
decl_stmt|;
name|int
name|header
init|=
name|d
operator|->
name|horizontalHeader
operator|->
name|sectionSizeHint
argument_list|(
name|column
argument_list|)
decl_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|resizeSection
argument_list|(
name|column
argument_list|,
name|qMax
argument_list|(
name|content
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resizes all columns based on the size hints of the delegate     used to render each item in the columns. */
end_comment
begin_function
DECL|function|resizeColumnsToContents
name|void
name|QTableView
operator|::
name|resizeColumnsToContents
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|resizeSections
argument_list|(
name|QHeaderView
operator|::
name|ResizeToContents
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \obsolete   \overload    Sorts the model by the values in the given \a column. */
end_comment
begin_function
DECL|function|sortByColumn
name|void
name|QTableView
operator|::
name|sortByColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|==
operator|-
literal|1
condition|)
return|return;
name|d
operator|->
name|model
operator|->
name|sort
argument_list|(
name|column
argument_list|,
name|d
operator|->
name|horizontalHeader
operator|->
name|sortIndicatorOrder
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.2    Sorts the model by the values in the given \a column in the given \a order.    \sa sortingEnabled  */
end_comment
begin_function
DECL|function|sortByColumn
name|void
name|QTableView
operator|::
name|sortByColumn
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalHeader
operator|->
name|setSortIndicator
argument_list|(
name|column
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|sortByColumn
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|verticalScrollbarAction
name|void
name|QTableView
operator|::
name|verticalScrollbarAction
parameter_list|(
name|int
name|action
parameter_list|)
block|{
name|QAbstractItemView
operator|::
name|verticalScrollbarAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|horizontalScrollbarAction
name|void
name|QTableView
operator|::
name|horizontalScrollbarAction
parameter_list|(
name|int
name|action
parameter_list|)
block|{
name|QAbstractItemView
operator|::
name|horizontalScrollbarAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|isIndexHidden
name|bool
name|QTableView
operator|::
name|isIndexHidden
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRowHidden
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|)
operator|||
name|isColumnHidden
argument_list|(
name|index
operator|.
name|column
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|hasSpans
argument_list|()
condition|)
block|{
name|QSpanCollection
operator|::
name|Span
name|span
init|=
name|d
operator|->
name|span
argument_list|(
name|index
operator|.
name|row
argument_list|()
argument_list|,
name|index
operator|.
name|column
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
operator|(
name|span
operator|.
name|top
argument_list|()
operator|==
name|index
operator|.
name|row
argument_list|()
operator|)
operator|&&
operator|(
name|span
operator|.
name|left
argument_list|()
operator|==
name|index
operator|.
name|column
argument_list|()
operator|)
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTableView::setSpan(int row, int column, int rowSpanCount, int columnSpanCount)     \since 4.2      Sets the span of the table element at (\a row, \a column) to the number of     rows and columns specified by (\a rowSpanCount, \a columnSpanCount).      \sa rowSpan(), columnSpan() */
end_comment
begin_function
DECL|function|setSpan
name|void
name|QTableView
operator|::
name|setSpan
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|rowSpan
parameter_list|,
name|int
name|columnSpan
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|column
operator|<
literal|0
operator|||
name|rowSpan
operator|<
literal|0
operator|||
name|columnSpan
operator|<
literal|0
condition|)
return|return;
name|d
operator|->
name|setSpan
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|rowSpan
argument_list|,
name|columnSpan
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.2    Returns the row span of the table element at (\a row, \a column).   The default is 1.    \sa setSpan(), columnSpan() */
end_comment
begin_function
DECL|function|rowSpan
name|int
name|QTableView
operator|::
name|rowSpan
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rowSpan
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.2    Returns the column span of the table element at (\a row, \a   column). The default is 1.    \sa setSpan(), rowSpan() */
end_comment
begin_function
DECL|function|columnSpan
name|int
name|QTableView
operator|::
name|columnSpan
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTableView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|columnSpan
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Removes all row and column spans in the table view.    \sa setSpan() */
end_comment
begin_function
DECL|function|clearSpans
name|void
name|QTableView
operator|::
name|clearSpans
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|d
operator|->
name|spans
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_selectRow
name|void
name|QTableViewPrivate
operator|::
name|_q_selectRow
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|selectRow
argument_list|(
name|row
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_selectColumn
name|void
name|QTableViewPrivate
operator|::
name|_q_selectColumn
parameter_list|(
name|int
name|column
parameter_list|)
block|{
name|selectColumn
argument_list|(
name|column
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|selectRow
name|void
name|QTableViewPrivate
operator|::
name|selectRow
parameter_list|(
name|int
name|row
parameter_list|,
name|bool
name|anchor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|selectionBehavior
argument_list|()
operator|==
name|QTableView
operator|::
name|SelectColumns
operator|||
operator|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|==
name|QTableView
operator|::
name|SingleSelection
operator|&&
name|q
operator|->
name|selectionBehavior
argument_list|()
operator|==
name|QTableView
operator|::
name|SelectItems
operator|)
condition|)
return|return;
if|if
condition|(
name|row
operator|>=
literal|0
operator|&&
name|row
operator|<
name|model
operator|->
name|rowCount
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|int
name|column
init|=
name|horizontalHeader
operator|->
name|logicalIndexAt
argument_list|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|?
name|viewport
operator|->
name|width
argument_list|()
else|:
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
init|=
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|q
operator|->
name|selectionCommand
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|anchor
operator|&&
operator|!
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Current
operator|)
operator|)
operator|||
operator|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|==
name|QTableView
operator|::
name|SingleSelection
operator|)
condition|)
name|rowSectionAnchor
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|!=
name|QTableView
operator|::
name|SingleSelection
operator|&&
name|command
operator|.
name|testFlag
argument_list|(
name|QItemSelectionModel
operator|::
name|Toggle
argument_list|)
condition|)
block|{
if|if
condition|(
name|anchor
condition|)
name|ctrlDragSelectionFlag
operator|=
name|verticalHeader
operator|->
name|selectionModel
argument_list|()
operator|->
name|selectedRows
argument_list|()
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|?
name|QItemSelectionModel
operator|::
name|Deselect
else|:
name|QItemSelectionModel
operator|::
name|Select
expr_stmt|;
name|command
operator|&=
operator|~
name|QItemSelectionModel
operator|::
name|Toggle
expr_stmt|;
name|command
operator||=
name|ctrlDragSelectionFlag
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
name|command
operator||=
name|QItemSelectionModel
operator|::
name|Current
expr_stmt|;
block|}
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|qMin
argument_list|(
name|rowSectionAnchor
argument_list|,
name|row
argument_list|)
argument_list|,
name|logicalColumn
argument_list|(
literal|0
argument_list|)
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|qMax
argument_list|(
name|rowSectionAnchor
argument_list|,
name|row
argument_list|)
argument_list|,
name|logicalColumn
argument_list|(
name|model
operator|->
name|columnCount
argument_list|(
name|root
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|verticalHeader
operator|->
name|sectionsMoved
argument_list|()
operator|&&
name|tl
operator|.
name|row
argument_list|()
operator|!=
name|br
operator|.
name|row
argument_list|()
operator|)
operator|||
name|horizontalHeader
operator|->
name|sectionsMoved
argument_list|()
condition|)
block|{
name|q
operator|->
name|setSelection
argument_list|(
name|q
operator|->
name|visualRect
argument_list|(
name|tl
argument_list|)
operator||
name|q
operator|->
name|visualRect
argument_list|(
name|br
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectionModel
operator|->
name|select
argument_list|(
name|QItemSelection
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|selectColumn
name|void
name|QTableViewPrivate
operator|::
name|selectColumn
parameter_list|(
name|int
name|column
parameter_list|,
name|bool
name|anchor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|selectionBehavior
argument_list|()
operator|==
name|QTableView
operator|::
name|SelectRows
operator|||
operator|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|==
name|QTableView
operator|::
name|SingleSelection
operator|&&
name|q
operator|->
name|selectionBehavior
argument_list|()
operator|==
name|QTableView
operator|::
name|SelectItems
operator|)
condition|)
return|return;
if|if
condition|(
name|column
operator|>=
literal|0
operator|&&
name|column
operator|<
name|model
operator|->
name|columnCount
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|int
name|row
init|=
name|verticalHeader
operator|->
name|logicalIndexAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
init|=
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|q
operator|->
name|selectionCommand
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|anchor
operator|&&
operator|!
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Current
operator|)
operator|)
operator|||
operator|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|==
name|QTableView
operator|::
name|SingleSelection
operator|)
condition|)
name|columnSectionAnchor
operator|=
name|column
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|selectionMode
argument_list|()
operator|!=
name|QTableView
operator|::
name|SingleSelection
operator|&&
name|command
operator|.
name|testFlag
argument_list|(
name|QItemSelectionModel
operator|::
name|Toggle
argument_list|)
condition|)
block|{
if|if
condition|(
name|anchor
condition|)
name|ctrlDragSelectionFlag
operator|=
name|horizontalHeader
operator|->
name|selectionModel
argument_list|()
operator|->
name|selectedColumns
argument_list|()
operator|.
name|contains
argument_list|(
name|index
argument_list|)
condition|?
name|QItemSelectionModel
operator|::
name|Deselect
else|:
name|QItemSelectionModel
operator|::
name|Select
expr_stmt|;
name|command
operator|&=
operator|~
name|QItemSelectionModel
operator|::
name|Toggle
expr_stmt|;
name|command
operator||=
name|ctrlDragSelectionFlag
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
name|command
operator||=
name|QItemSelectionModel
operator|::
name|Current
expr_stmt|;
block|}
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
name|logicalRow
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|columnSectionAnchor
argument_list|,
name|column
argument_list|)
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|logicalRow
argument_list|(
name|model
operator|->
name|rowCount
argument_list|(
name|root
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|columnSectionAnchor
argument_list|,
name|column
argument_list|)
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|horizontalHeader
operator|->
name|sectionsMoved
argument_list|()
operator|&&
name|tl
operator|.
name|column
argument_list|()
operator|!=
name|br
operator|.
name|column
argument_list|()
operator|)
operator|||
name|verticalHeader
operator|->
name|sectionsMoved
argument_list|()
condition|)
block|{
name|q
operator|->
name|setSelection
argument_list|(
name|q
operator|->
name|visualRect
argument_list|(
name|tl
argument_list|)
operator||
name|q
operator|->
name|visualRect
argument_list|(
name|br
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectionModel
operator|->
name|select
argument_list|(
name|QItemSelection
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \reimp  */
end_comment
begin_function
DECL|function|currentChanged
name|void
name|QTableView
operator|::
name|currentChanged
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|current
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|previous
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
name|current
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|int
name|entry
init|=
name|d
operator|->
name|accessibleTable2Index
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|Focus
argument_list|)
decl_stmt|;
name|event
operator|.
name|setChild
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|QAbstractItemView
operator|::
name|currentChanged
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \reimp  */
end_comment
begin_function
DECL|function|selectionChanged
name|void
name|QTableView
operator|::
name|selectionChanged
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selected
parameter_list|,
specifier|const
name|QItemSelection
modifier|&
name|deselected
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTableView
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
argument|d
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
comment|// ### does not work properly for selection ranges.
name|QModelIndex
name|sel
init|=
name|selected
operator|.
name|indexes
argument_list|()
operator|.
name|value
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sel
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|entry
init|=
name|d
operator|->
name|accessibleTable2Index
argument_list|(
name|sel
argument_list|)
decl_stmt|;
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|Selection
argument_list|)
decl_stmt|;
name|event
operator|.
name|setChild
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
name|QModelIndex
name|desel
init|=
name|deselected
operator|.
name|indexes
argument_list|()
operator|.
name|value
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|desel
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|entry
init|=
name|d
operator|->
name|accessibleTable2Index
argument_list|(
name|desel
argument_list|)
decl_stmt|;
name|QAccessibleEvent
name|event
argument_list|(
name|this
argument_list|,
name|QAccessible
operator|::
name|SelectionRemove
argument_list|)
decl_stmt|;
name|event
operator|.
name|setChild
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|QAbstractItemView
operator|::
name|selectionChanged
argument_list|(
name|selected
argument_list|,
name|deselected
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|visualIndex
name|int
name|QTableView
operator|::
name|visualIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|index
operator|.
name|row
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qtableview.moc"
end_include
begin_include
include|#
directive|include
file|"moc_qtableview.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABLEVIEW
end_comment
end_unit
