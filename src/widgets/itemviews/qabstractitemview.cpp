begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstractitemview.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ITEMVIEWS
end_ifndef
begin_include
include|#
directive|include
file|<qpointer.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qclipboard.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qdrag.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qscrollbar.h>
end_include
begin_include
include|#
directive|include
file|<qwhatsthis.h>
end_include
begin_include
include|#
directive|include
file|<qtooltip.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qlineedit.h>
end_include
begin_include
include|#
directive|include
file|<qspinbox.h>
end_include
begin_include
include|#
directive|include
file|<qtreeview.h>
end_include
begin_include
include|#
directive|include
file|<qtableview.h>
end_include
begin_include
include|#
directive|include
file|<qheaderview.h>
end_include
begin_include
include|#
directive|include
file|<qstyleditemdelegate.h>
end_include
begin_include
include|#
directive|include
file|<private/qabstractitemview_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qabstractitemmodel_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|<qaccessible.h>
end_include
begin_include
include|#
directive|include
file|<qaccessible2.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_include
include|#
directive|include
file|<qscroller.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QAbstractItemViewPrivate
name|QAbstractItemViewPrivate
operator|::
name|QAbstractItemViewPrivate
parameter_list|()
member_init_list|:
name|model
argument_list|(
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
argument_list|)
member_init_list|,
name|itemDelegate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|selectionModel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ctrlDragSelectionFlag
argument_list|(
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
member_init_list|,
name|noSelectionOnMousePress
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|selectionMode
argument_list|(
name|QAbstractItemView
operator|::
name|ExtendedSelection
argument_list|)
member_init_list|,
name|selectionBehavior
argument_list|(
name|QAbstractItemView
operator|::
name|SelectItems
argument_list|)
member_init_list|,
name|currentlyCommittingEditor
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pressedModifiers
argument_list|(
name|Qt
operator|::
name|NoModifier
argument_list|)
member_init_list|,
name|pressedPosition
argument_list|(
name|QPoint
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
member_init_list|,
name|pressedAlreadySelected
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|viewportEnteredNeeded
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QAbstractItemView
operator|::
name|NoState
argument_list|)
member_init_list|,
name|stateBeforeAnimation
argument_list|(
name|QAbstractItemView
operator|::
name|NoState
argument_list|)
member_init_list|,
name|editTriggers
argument_list|(
name|QAbstractItemView
operator|::
name|DoubleClicked
operator||
name|QAbstractItemView
operator|::
name|EditKeyPressed
argument_list|)
member_init_list|,
name|lastTrigger
argument_list|(
name|QAbstractItemView
operator|::
name|NoEditTriggers
argument_list|)
member_init_list|,
name|tabKeyNavigation
argument_list|(
literal|false
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|showDropIndicator
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|dragEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dragDropMode
argument_list|(
name|QAbstractItemView
operator|::
name|NoDragDrop
argument_list|)
member_init_list|,
name|overwrite
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dropIndicatorPosition
argument_list|(
name|QAbstractItemView
operator|::
name|OnItem
argument_list|)
member_init_list|,
name|defaultDropAction
argument_list|(
name|Qt
operator|::
name|IgnoreAction
argument_list|)
member_init_list|,
endif|#
directive|endif
name|autoScroll
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|autoScrollMargin
argument_list|(
literal|16
argument_list|)
member_init_list|,
name|autoScrollCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|shouldScrollToCurrentOnShow
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|shouldClearStatusTip
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|alternatingColors
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|textElideMode
argument_list|(
name|Qt
operator|::
name|ElideRight
argument_list|)
member_init_list|,
name|verticalScrollMode
argument_list|(
name|QAbstractItemView
operator|::
name|ScrollPerItem
argument_list|)
member_init_list|,
name|horizontalScrollMode
argument_list|(
name|QAbstractItemView
operator|::
name|ScrollPerItem
argument_list|)
member_init_list|,
name|currentIndexSet
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|wrapItemText
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|delayedPendingLayout
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|moveCursorUpdatedView
argument_list|(
literal|false
argument_list|)
block|{
name|keyboardInputTime
operator|.
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QAbstractItemViewPrivate
name|QAbstractItemViewPrivate
operator|::
name|~
name|QAbstractItemViewPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|init
name|void
name|QAbstractItemViewPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|q
operator|->
name|setItemDelegate
argument_list|(
operator|new
name|QStyledItemDelegate
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|vbar
argument_list|,
name|SIGNAL
argument_list|(
name|actionTriggered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|verticalScrollbarAction
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|hbar
argument_list|,
name|SIGNAL
argument_list|(
name|actionTriggered
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|horizontalScrollbarAction
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|vbar
argument_list|,
name|SIGNAL
argument_list|(
name|valueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|verticalScrollbarValueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|hbar
argument_list|,
name|SIGNAL
argument_list|(
name|valueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|horizontalScrollbarValueChanged
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setHoverIndex
name|void
name|QAbstractItemViewPrivate
operator|::
name|setHoverIndex
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|hover
operator|==
name|index
condition|)
return|return;
if|if
condition|(
name|selectionBehavior
operator|!=
name|QAbstractItemView
operator|::
name|SelectRows
condition|)
block|{
name|q
operator|->
name|update
argument_list|(
name|hover
argument_list|)
expr_stmt|;
comment|//update the old one
name|q
operator|->
name|update
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|//update the new one
block|}
else|else
block|{
name|QRect
name|oldHoverRect
init|=
name|q
operator|->
name|visualRect
argument_list|(
name|hover
argument_list|)
decl_stmt|;
name|QRect
name|newHoverRect
init|=
name|q
operator|->
name|visualRect
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|viewport
operator|->
name|update
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
name|newHoverRect
operator|.
name|y
argument_list|()
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|newHoverRect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|viewport
operator|->
name|update
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
name|oldHoverRect
operator|.
name|y
argument_list|()
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|oldHoverRect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hover
operator|=
name|index
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkMouseMove
name|void
name|QAbstractItemViewPrivate
operator|::
name|checkMouseMove
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|index
parameter_list|)
block|{
comment|//we take a persistent model index because the model might change by emitting signals
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|setHoverIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewportEnteredNeeded
operator|||
name|enteredIndex
operator|!=
name|index
condition|)
block|{
name|viewportEnteredNeeded
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
emit|emit
name|q
operator|->
name|entered
argument_list|(
name|index
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
name|QString
name|statustip
init|=
name|model
operator|->
name|data
argument_list|(
name|index
argument_list|,
name|Qt
operator|::
name|StatusTipRole
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|parent
operator|&&
operator|(
name|shouldClearStatusTip
operator|||
operator|!
name|statustip
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|QStatusTipEvent
name|tip
argument_list|(
name|statustip
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
name|shouldClearStatusTip
operator|=
operator|!
name|statustip
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
if|if
condition|(
name|parent
operator|&&
name|shouldClearStatusTip
condition|)
block|{
name|QString
name|emptyString
decl_stmt|;
name|QStatusTipEvent
name|tip
argument_list|(
name|emptyString
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
emit|emit
name|q
operator|->
name|viewportEntered
argument_list|()
emit|;
block|}
name|enteredIndex
operator|=
name|index
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_comment
comment|// stores and restores the selection and current item when flicking
end_comment
begin_function
DECL|function|_q_scrollerStateChanged
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_scrollerStateChanged
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QScroller
modifier|*
name|scroller
init|=
name|QScroller
operator|::
name|scroller
argument_list|(
name|viewport
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|scroller
operator|->
name|state
argument_list|()
condition|)
block|{
case|case
name|QScroller
operator|::
name|Pressed
case|:
comment|// store the current selection in case we start scrolling
if|if
condition|(
name|q
operator|->
name|selectionModel
argument_list|()
condition|)
block|{
name|oldSelection
operator|=
name|q
operator|->
name|selectionModel
argument_list|()
operator|->
name|selection
argument_list|()
expr_stmt|;
name|oldCurrent
operator|=
name|q
operator|->
name|selectionModel
argument_list|()
operator|->
name|currentIndex
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QScroller
operator|::
name|Dragging
case|:
comment|// restore the old selection if we really start scrolling
if|if
condition|(
name|q
operator|->
name|selectionModel
argument_list|()
condition|)
block|{
name|q
operator|->
name|selectionModel
argument_list|()
operator|->
name|select
argument_list|(
name|oldSelection
argument_list|,
name|QItemSelectionModel
operator|::
name|ClearAndSelect
argument_list|)
expr_stmt|;
name|q
operator|->
name|selectionModel
argument_list|()
operator|->
name|setCurrentIndex
argument_list|(
name|oldCurrent
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
block|}
comment|// fall through
default|default:
name|oldSelection
operator|=
name|QItemSelection
argument_list|()
expr_stmt|;
name|oldCurrent
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_comment
comment|/*!     \class QAbstractItemView      \brief The QAbstractItemView class provides the basic functionality for     item view classes.      \ingroup model-view     \inmodule QtWidgets      QAbstractItemView class is the base class for every standard view     that uses a QAbstractItemModel. QAbstractItemView is an abstract     class and cannot itself be instantiated. It provides a standard     interface for interoperating with models through the signals and     slots mechanism, enabling subclasses to be kept up-to-date with     changes to their models.  This class provides standard support for     keyboard and mouse navigation, viewport scrolling, item editing,     and selections. The keyboard navigation implements this     functionality:      \table         \header             \li Keys             \li Functionality         \row             \li Arrow keys             \li Changes the current item and selects it.         \row             \li Ctrl+Arrow keys             \li Changes the current item but does not select it.         \row             \li Shift+Arrow keys             \li Changes the current item and selects it. The previously                selected item(s) is not deselected.         \row             \li Ctr+Space             \li Toggles selection of the current item.         \row             \li Tab/Backtab             \li Changes the current item to the next/previous item.         \row             \li Home/End             \li Selects the first/last item in the model.         \row             \li Page up/Page down             \li Scrolls the rows shown up/down by the number of                visible rows in the view.         \row             \li Ctrl+A             \li Selects all items in the model.     \endtable      Note that the above table assumes that the     \l{selectionMode}{selection mode} allows the operations. For     instance, you cannot select items if the selection mode is     QAbstractItemView::NoSelection.      The QAbstractItemView class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      The view classes that inherit QAbstractItemView only need     to implement their own view-specific functionality, such as     drawing items, returning the geometry of items, finding items,     etc.      QAbstractItemView provides common slots such as edit() and     setCurrentIndex(). Many protected slots are also provided, including     dataChanged(), rowsInserted(), rowsAboutToBeRemoved(), selectionChanged(),     and currentChanged().      The root item is returned by rootIndex(), and the current item by     currentIndex(). To make sure that an item is visible use     scrollTo().      Some of QAbstractItemView's functions are concerned with     scrolling, for example setHorizontalScrollMode() and     setVerticalScrollMode(). To set the range of the scroll bars, you     can, for example, reimplement the view's resizeEvent() function:      \snippet code/src_gui_itemviews_qabstractitemview.cpp 0      Note that the range is not updated until the widget is shown.      Several other functions are concerned with selection control; for     example setSelectionMode(), and setSelectionBehavior(). This class     provides a default selection model to work with     (selectionModel()), but this can be replaced by using     setSelectionModel() with an instance of QItemSelectionModel.      For complete control over the display and editing of items you can     specify a delegate with setItemDelegate().      QAbstractItemView provides a lot of protected functions. Some are     concerned with editing, for example, edit(), and commitData(),     whilst others are keyboard and mouse event handlers.      \note If you inherit QAbstractItemView and intend to update the contents     of the viewport, you should use viewport->update() instead of     \l{QWidget::update()}{update()} as all painting operations take place on the     viewport.      \sa {View Classes}, {Model/View Programming}, QAbstractItemModel, {Chart Example} */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::SelectionMode      This enum indicates how the view responds to user selections:      \value SingleSelection  When the user selects an item, any already-selected     item becomes unselected, and the user cannot unselect the selected item by     clicking on it.      \value ContiguousSelection When the user selects an item in the usual way,     the selection is cleared and the new item selected. However, if the user     presses the Shift key while clicking on an item, all items between the     current item and the clicked item are selected or unselected, depending on     the state of the clicked item.      \value ExtendedSelection When the user selects an item in the usual way,     the selection is cleared and the new item selected. However, if the user     presses the Ctrl key when clicking on an item, the clicked item gets     toggled and all other items are left untouched. If the user presses the     Shift key while clicking on an item, all items between the current item     and the clicked item are selected or unselected, depending on the state of     the clicked item. Multiple items can be selected by dragging the mouse over     them.      \value MultiSelection When the user selects an item in the usual way, the     selection status of that item is toggled and the other items are left     alone. Multiple items can be toggled by dragging the mouse over them.      \value NoSelection Items cannot be selected.      The most commonly used modes are SingleSelection and ExtendedSelection. */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::SelectionBehavior      \value SelectItems   Selecting single items.     \value SelectRows    Selecting only rows.     \value SelectColumns Selecting only columns. */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::ScrollHint      \value EnsureVisible  Scroll to ensure that the item is visible.     \value PositionAtTop  Scroll to position the item at the top of the            viewport.     \value PositionAtBottom  Scroll to position the item at the bottom of the            viewport.     \value PositionAtCenter  Scroll to position the item at the center of the            viewport. */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::EditTrigger      This enum describes actions which will initiate item editing.      \value NoEditTriggers  No editing possible.     \value CurrentChanged  Editing start whenever current item changes.     \value DoubleClicked   Editing starts when an item is double clicked.     \value SelectedClicked Editing starts when clicking on an already selected            item.     \value EditKeyPressed  Editing starts when the platform edit key has been            pressed over an item.     \value AnyKeyPressed   Editing starts when any key is pressed over an item.     \value AllEditTriggers Editing starts for all above actions. */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::CursorAction      This enum describes the different ways to navigate between items,     \sa moveCursor()      \value MoveUp       Move to the item above the current item.     \value MoveDown     Move to the item below the current item.     \value MoveLeft     Move to the item left of the current item.     \value MoveRight    Move to the item right of the current item.     \value MoveHome     Move to the top-left corner item.     \value MoveEnd      Move to the bottom-right corner item.     \value MovePageUp   Move one page up above the current item.     \value MovePageDown Move one page down below the current item.     \value MoveNext     Move to the item after the current item.     \value MovePrevious Move to the item before the current item. */
end_comment
begin_comment
comment|/*!     \enum QAbstractItemView::State      Describes the different states the view can be in. This is usually     only interesting when reimplementing your own view.      \value NoState        The is the default state.     \value DraggingState  The user is dragging items.     \value DragSelectingState The user is selecting items.     \value EditingState   The user is editing an item in a widget editor.     \value ExpandingState   The user is opening a branch of items.     \value CollapsingState   The user is closing a branch of items.     \value AnimatingState The item view is performing an animation. */
end_comment
begin_comment
comment|/*!     \since 4.2     \enum QAbstractItemView::ScrollMode      \value ScrollPerItem    The view will scroll the contents one item at a time.     \value ScrollPerPixel   The view will scroll the contents one pixel at a time. */
end_comment
begin_comment
comment|/*!     \fn QRect QAbstractItemView::visualRect(const QModelIndex&index) const = 0     Returns the rectangle on the viewport occupied by the item at \a index.      If your item is displayed in several areas then visualRect should return     the primary area that contains index and not the complete area that index     might encompasses, touch or cause drawing.      In the base class this is a pure virtual function.      \sa indexAt(), visualRegionForSelection() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::scrollTo(const QModelIndex&index, ScrollHint hint) = 0      Scrolls the view if necessary to ensure that the item at \a index     is visible. The view will try to position the item according to the given \a hint.      In the base class this is a pure virtual function. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemView::indexAt(const QPoint&point) const = 0      Returns the model index of the item at the viewport coordinates \a point.      In the base class this is a pure virtual function.      \sa visualRect() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::activated(const QModelIndex&index)      This signal is emitted when the item specified by \a index is     activated by the user. How to activate items depends on the     platform; e.g., by single- or double-clicking the item, or by     pressing the Return or Enter key when the item is current.      \sa clicked(), doubleClicked(), entered(), pressed() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::entered(const QModelIndex&index)      This signal is emitted when the mouse cursor enters the item     specified by \a index.     Mouse tracking needs to be enabled for this feature to work.      \sa viewportEntered(), activated(), clicked(), doubleClicked(), pressed() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::viewportEntered()      This signal is emitted when the mouse cursor enters the viewport.     Mouse tracking needs to be enabled for this feature to work.      \sa entered() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::pressed(const QModelIndex&index)      This signal is emitted when a mouse button is pressed. The item     the mouse was pressed on is specified by \a index. The signal is     only emitted when the index is valid.      Use the QApplication::mouseButtons() function to get the state     of the mouse buttons.      \sa activated(), clicked(), doubleClicked(), entered() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::clicked(const QModelIndex&index)      This signal is emitted when a mouse button is left-clicked. The item     the mouse was clicked on is specified by \a index. The signal is     only emitted when the index is valid.      \sa activated(), doubleClicked(), entered(), pressed() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::doubleClicked(const QModelIndex&index)      This signal is emitted when a mouse button is double-clicked. The     item the mouse was double-clicked on is specified by \a index.     The signal is only emitted when the index is valid.      \sa clicked(), activated() */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers) = 0      Returns a QModelIndex object pointing to the next object in the view,     based on the given \a cursorAction and keyboard modifiers specified     by \a modifiers.      In the base class this is a pure virtual function. */
end_comment
begin_comment
comment|/*!     \fn int QAbstractItemView::horizontalOffset() const = 0      Returns the horizontal offset of the view.      In the base class this is a pure virtual function.      \sa verticalOffset() */
end_comment
begin_comment
comment|/*!     \fn int QAbstractItemView::verticalOffset() const = 0      Returns the vertical offset of the view.      In the base class this is a pure virtual function.      \sa horizontalOffset() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractItemView::isIndexHidden(const QModelIndex&index) const      Returns true if the item referred to by the given \a index is hidden in the view,     otherwise returns false.      Hiding is a view specific feature.  For example in TableView a column can be marked     as hidden or a row in the TreeView.      In the base class this is a pure virtual function. */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::setSelection(const QRect&rect, QItemSelectionModel::SelectionFlags flags)      Applies the selection \a flags to the items in or touched by the     rectangle, \a rect.      When implementing your own itemview setSelection should call     selectionModel()->select(selection, flags) where selection     is either an empty QModelIndex or a QItemSelection that contains     all items that are contained in \a rect.      \sa selectionCommand(), selectedIndexes() */
end_comment
begin_comment
comment|/*!     \fn QRegion QAbstractItemView::visualRegionForSelection(const QItemSelection&selection) const = 0      Returns the region from the viewport of the items in the given     \a selection.      In the base class this is a pure virtual function.      \sa visualRect(), selectedIndexes() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemView::update()     \internal */
end_comment
begin_comment
comment|/*!     Constructs an abstract item view with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractItemView
name|QAbstractItemView
operator|::
name|QAbstractItemView
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|(
operator|new
name|QAbstractItemViewPrivate
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAbstractItemView
name|QAbstractItemView
operator|::
name|QAbstractItemView
parameter_list|(
name|QAbstractItemViewPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the view. */
end_comment
begin_destructor
DECL|function|~QAbstractItemView
name|QAbstractItemView
operator|::
name|~
name|QAbstractItemView
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
comment|// stop these timers here before ~QObject
name|d
operator|->
name|delayedReset
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|delayedEditing
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|autoScrollTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|delayedLayout
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|fetchMoreTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the \a model for the view to present.      This function will create and set a new selection model, replacing any     model that was previously set with setSelectionModel(). However, the old     selection model will not be deleted as it may be shared between several     views. We recommend that you delete the old selection model if it is no     longer required. This is done with the following code:      \snippet code/src_gui_itemviews_qabstractitemview.cpp 2      If both the old model and the old selection model do not have parents, or     if their parents are long-lived objects, it may be preferable to call their     deleteLater() functions to explicitly delete them.      The view \e{does not} take ownership of the model unless it is the model's     parent object because the model may be shared between many different views.      \sa selectionModel(), setSelectionModel() */
end_comment
begin_function
DECL|function|setModel
name|void
name|QAbstractItemView
operator|::
name|setModel
parameter_list|(
name|QAbstractItemModel
modifier|*
name|model
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|==
name|d
operator|->
name|model
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|model
operator|&&
name|d
operator|->
name|model
operator|!=
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_modelDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|,
name|QVector
argument_list|<
name|int
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|,
name|QVector
argument_list|<
name|int
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Orientation
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_headerDataChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|modelReset
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|reset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|model
operator|=
operator|(
name|model
condition|?
name|model
else|:
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
operator|)
expr_stmt|;
comment|// These asserts do basic sanity checking of the model
name|Q_ASSERT_X
argument_list|(
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"QAbstractItemView::setModel"
argument_list|,
literal|"A model should return the exact same index "
literal|"(including its internal id/pointer) when asked for it twice in a row."
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|parent
argument_list|()
operator|.
name|isValid
argument_list|()
argument_list|,
literal|"QAbstractItemView::setModel"
argument_list|,
literal|"The parent of a top level index should be invalid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|model
operator|!=
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
condition|)
block|{
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_modelDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|,
name|QVector
argument_list|<
name|int
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|dataChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|,
name|QVector
argument_list|<
name|int
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|headerDataChanged
argument_list|(
name|Qt
operator|::
name|Orientation
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_headerDataChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|rowsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|rowsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_rowsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsAboutToBeRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsRemoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsInserted
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|columnsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_columnsMoved
argument_list|(
name|QModelIndex
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|QModelIndex
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|modelReset
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|reset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|layoutChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_layoutChanged
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QItemSelectionModel
modifier|*
name|selection_model
init|=
operator|new
name|QItemSelectionModel
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|model
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|selection_model
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setSelectionModel
argument_list|(
name|selection_model
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
comment|// kill editors, set new root and do layout
block|}
end_function
begin_comment
comment|/*!     Returns the model that this view is presenting. */
end_comment
begin_function
DECL|function|model
name|QAbstractItemModel
modifier|*
name|QAbstractItemView
operator|::
name|model
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|model
operator|==
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
condition|?
literal|0
else|:
name|d
operator|->
name|model
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current selection model to the given \a selectionModel.      Note that, if you call setModel() after this function, the given \a selectionModel     will be replaced by one created by the view.      \note It is up to the application to delete the old selection model if it is no     longer needed; i.e., if it is not being used by other views. This will happen     automatically when its parent object is deleted. However, if it does not have a     parent, or if the parent is a long-lived object, it may be preferable to call its     deleteLater() function to explicitly delete it.      \sa selectionModel(), setModel(), clearSelection() */
end_comment
begin_function
DECL|function|setSelectionModel
name|void
name|QAbstractItemView
operator|::
name|setSelectionModel
parameter_list|(
name|QItemSelectionModel
modifier|*
name|selectionModel
parameter_list|)
block|{
comment|// ### if the given model is null, we should use the original selection model
name|Q_ASSERT
argument_list|(
name|selectionModel
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectionModel
operator|->
name|model
argument_list|()
operator|!=
name|d
operator|->
name|model
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractItemView::setSelectionModel() failed: "
literal|"Trying to set a selection model, which works on "
literal|"a different model than the view."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|,
name|QItemSelection
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|,
name|QItemSelection
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|currentChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|currentChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|selectionModel
operator|=
name|selectionModel
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
name|connect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|,
name|QItemSelection
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|selectionChanged
argument_list|(
name|QItemSelection
argument_list|,
name|QItemSelection
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|selectionModel
argument_list|,
name|SIGNAL
argument_list|(
name|currentChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|currentChanged
argument_list|(
name|QModelIndex
argument_list|,
name|QModelIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the current selection model.      \sa setSelectionModel(), selectedIndexes() */
end_comment
begin_function
DECL|function|selectionModel
name|QItemSelectionModel
modifier|*
name|QAbstractItemView
operator|::
name|selectionModel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|selectionModel
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item delegate for this view and its model to \a delegate.     This is useful if you want complete control over the editing and     display of items.      Any existing delegate will be removed, but not deleted. QAbstractItemView     does not take ownership of \a delegate.      \warning You should not share the same instance of a delegate between views.     Doing so can cause incorrect or unintuitive editing behavior since each     view connected to a given delegate may receive the \l{QAbstractItemDelegate::}{closeEditor()}     signal, and attempt to access, modify or close an editor that has already been closed.      \sa itemDelegate() */
end_comment
begin_function
DECL|function|setItemDelegate
name|void
name|QAbstractItemView
operator|::
name|setItemDelegate
parameter_list|(
name|QAbstractItemDelegate
modifier|*
name|delegate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegate
operator|==
name|d
operator|->
name|itemDelegate
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|itemDelegate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|d
operator|->
name|itemDelegate
argument_list|)
operator|==
literal|1
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|itemDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|itemDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|itemDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|sizeHintChanged
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|doItemsLayout
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delegate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|delegate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|sizeHintChanged
argument_list|(
name|QModelIndex
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|doItemsLayout
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|itemDelegate
operator|=
name|delegate
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item delegate used by this view and model. This is     either one set with setItemDelegate(), or the default one.      \sa setItemDelegate() */
end_comment
begin_function
DECL|function|itemDelegate
name|QAbstractItemDelegate
modifier|*
name|QAbstractItemView
operator|::
name|itemDelegate
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|itemDelegate
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QAbstractItemView
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
specifier|const
name|QModelIndex
name|current
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|isValid
argument_list|()
operator|||
name|query
operator|!=
name|Qt
operator|::
name|ImCursorRectangle
condition|)
return|return
name|QAbstractScrollArea
operator|::
name|inputMethodQuery
argument_list|(
name|query
argument_list|)
return|;
return|return
name|visualRect
argument_list|(
name|current
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the given item \a delegate used by this view and model for the given     \a row. All items on \a row will be drawn and managed by \a delegate     instead of using the default delegate (i.e., itemDelegate()).      Any existing row delegate for \a row will be removed, but not     deleted. QAbstractItemView does not take ownership of \a delegate.      \note If a delegate has been assigned to both a row and a column, the row     delegate (i.e., this delegate) will take precedence and manage the     intersecting cell index.      \warning You should not share the same instance of a delegate between views.     Doing so can cause incorrect or unintuitive editing behavior since each     view connected to a given delegate may receive the \l{QAbstractItemDelegate::}{closeEditor()}     signal, and attempt to access, modify or close an editor that has already been closed.      \sa itemDelegateForRow(), setItemDelegateForColumn(), itemDelegate() */
end_comment
begin_function
DECL|function|setItemDelegateForRow
name|void
name|QAbstractItemView
operator|::
name|setItemDelegateForRow
parameter_list|(
name|int
name|row
parameter_list|,
name|QAbstractItemDelegate
modifier|*
name|delegate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QAbstractItemDelegate
modifier|*
name|rowDelegate
init|=
name|d
operator|->
name|rowDelegates
operator|.
name|value
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|rowDelegate
argument_list|)
operator|==
literal|1
condition|)
block|{
name|disconnect
argument_list|(
name|rowDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|rowDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|rowDelegates
operator|.
name|remove
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delegate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|delegate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|rowDelegates
operator|.
name|insert
argument_list|(
name|row
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \since 4.2     Returns the item delegate used by this view and model for the given \a row,    or 0 if no delegate has been assigned. You can call itemDelegate() to get a    pointer to the current delegate for a given index.     \sa setItemDelegateForRow(), itemDelegateForColumn(), setItemDelegate() */
end_comment
begin_function
DECL|function|itemDelegateForRow
name|QAbstractItemDelegate
modifier|*
name|QAbstractItemView
operator|::
name|itemDelegateForRow
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rowDelegates
operator|.
name|value
argument_list|(
name|row
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the given item \a delegate used by this view and model for the given     \a column. All items on \a column will be drawn and managed by \a delegate     instead of using the default delegate (i.e., itemDelegate()).      Any existing column delegate for \a column will be removed, but not     deleted. QAbstractItemView does not take ownership of \a delegate.      \note If a delegate has been assigned to both a row and a column, the row     delegate will take precedence and manage the intersecting cell index.      \warning You should not share the same instance of a delegate between views.     Doing so can cause incorrect or unintuitive editing behavior since each     view connected to a given delegate may receive the \l{QAbstractItemDelegate::}{closeEditor()}     signal, and attempt to access, modify or close an editor that has already been closed.      \sa itemDelegateForColumn(), setItemDelegateForRow(), itemDelegate() */
end_comment
begin_function
DECL|function|setItemDelegateForColumn
name|void
name|QAbstractItemView
operator|::
name|setItemDelegateForColumn
parameter_list|(
name|int
name|column
parameter_list|,
name|QAbstractItemDelegate
modifier|*
name|delegate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QAbstractItemDelegate
modifier|*
name|columnDelegate
init|=
name|d
operator|->
name|columnDelegates
operator|.
name|value
argument_list|(
name|column
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|columnDelegate
argument_list|)
operator|==
literal|1
condition|)
block|{
name|disconnect
argument_list|(
name|columnDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|columnDelegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|columnDelegates
operator|.
name|remove
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delegate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|delegateRefCount
argument_list|(
name|delegate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|closeEditor
argument_list|(
name|QWidget
operator|*
argument_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|commitData
argument_list|(
name|QWidget
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|columnDelegates
operator|.
name|insert
argument_list|(
name|column
argument_list|,
name|delegate
argument_list|)
expr_stmt|;
block|}
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the item delegate used by this view and model for the given \a     column.  You can call itemDelegate() to get a pointer to the current delegate     for a given index.      \sa setItemDelegateForColumn(), itemDelegateForRow(), itemDelegate() */
end_comment
begin_function
DECL|function|itemDelegateForColumn
name|QAbstractItemDelegate
modifier|*
name|QAbstractItemView
operator|::
name|itemDelegateForColumn
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|columnDelegates
operator|.
name|value
argument_list|(
name|column
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item delegate used by this view and model for     the given \a index. */
end_comment
begin_function
DECL|function|itemDelegate
name|QAbstractItemDelegate
modifier|*
name|QAbstractItemView
operator|::
name|itemDelegate
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::selectionMode     \brief which selection mode the view operates in      This property controls whether the user can select one or many items     and, in many-item selections, whether the selection must be a     continuous range of items.      \sa SelectionMode, SelectionBehavior */
end_comment
begin_function
DECL|function|setSelectionMode
name|void
name|QAbstractItemView
operator|::
name|setSelectionMode
parameter_list|(
name|SelectionMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectionMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_function
DECL|function|selectionMode
name|QAbstractItemView
operator|::
name|SelectionMode
name|QAbstractItemView
operator|::
name|selectionMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|selectionMode
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::selectionBehavior     \brief which selection behavior the view uses      This property holds whether selections are done     in terms of single items, rows or columns.      \sa SelectionMode, SelectionBehavior */
end_comment
begin_function
DECL|function|setSelectionBehavior
name|void
name|QAbstractItemView
operator|::
name|setSelectionBehavior
parameter_list|(
name|QAbstractItemView
operator|::
name|SelectionBehavior
name|behavior
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectionBehavior
operator|=
name|behavior
expr_stmt|;
block|}
end_function
begin_function
DECL|function|selectionBehavior
name|QAbstractItemView
operator|::
name|SelectionBehavior
name|QAbstractItemView
operator|::
name|selectionBehavior
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|selectionBehavior
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current item to be the item at \a index.      Unless the current selection mode is     \l{QAbstractItemView::}{NoSelection}, the item is also be selected.     Note that this function also updates the starting position for any     new selections the user performs.      To set an item as the current item without selecting it, call      \c{selectionModel()->setCurrentIndex(index, QItemSelectionModel::NoUpdate);}      \sa currentIndex(), currentChanged(), selectionMode */
end_comment
begin_function
DECL|function|setCurrentIndex
name|void
name|QAbstractItemView
operator|::
name|setCurrentIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
operator|&&
operator|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|selectionCommand
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentIndexSet
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Current
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|pressedPosition
operator|=
name|visualRect
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
operator|.
name|center
argument_list|()
operator|+
name|d
operator|->
name|offset
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the model index of the current item.      \sa setCurrentIndex() */
end_comment
begin_function
DECL|function|currentIndex
name|QModelIndex
name|QAbstractItemView
operator|::
name|currentIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|selectionModel
condition|?
name|d
operator|->
name|selectionModel
operator|->
name|currentIndex
argument_list|()
else|:
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Reset the internal state of the view.      \warning This function will reset open editors, scroll bar positions,     selections, etc. Existing changes will not be committed. If you would like     to save your changes when resetting the view, you can reimplement this     function, commit your changes, and then call the superclass'     implementation. */
end_comment
begin_function
DECL|function|reset
name|void
name|QAbstractItemView
operator|::
name|reset
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedReset
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//make sure we stop the timer
foreach|foreach
control|(
specifier|const
name|QEditorInfo
modifier|&
name|info
decl|,
name|d
operator|->
name|indexEditorHash
control|)
block|{
if|if
condition|(
name|info
operator|.
name|widget
condition|)
name|d
operator|->
name|releaseEditor
argument_list|(
name|info
operator|.
name|widget
operator|.
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|indexForEditor
argument_list|(
name|info
operator|.
name|widget
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|editorIndexHash
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|indexEditorHash
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|persistent
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|currentIndexSet
operator|=
literal|false
expr_stmt|;
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
name|setRootIndex
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
name|d
operator|->
name|selectionModel
operator|->
name|reset
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|this
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|ModelReset
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Sets the root item to the item at the given \a index.      \sa rootIndex() */
end_comment
begin_function
DECL|function|setRootIndex
name|void
name|QAbstractItemView
operator|::
name|setRootIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|index
operator|.
name|model
argument_list|()
operator|!=
name|d
operator|->
name|model
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractItemView::setRootIndex failed : index must be from the currently set model"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|root
operator|=
name|index
expr_stmt|;
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the model index of the model's root item. The root item is     the parent item to the view's toplevel items. The root can be invalid.      \sa setRootIndex() */
end_comment
begin_function
DECL|function|rootIndex
name|QModelIndex
name|QAbstractItemView
operator|::
name|rootIndex
parameter_list|()
specifier|const
block|{
return|return
name|QModelIndex
argument_list|(
name|d_func
argument_list|()
operator|->
name|root
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Selects all items in the view.     This function will use the selection behavior     set on the view when selecting.      \sa setSelection(), selectedIndexes(), clearSelection() */
end_comment
begin_function
DECL|function|selectAll
name|void
name|QAbstractItemView
operator|::
name|selectAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|SelectionMode
name|mode
init|=
name|d
operator|->
name|selectionMode
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|MultiSelection
operator|||
name|mode
operator|==
name|ExtendedSelection
condition|)
name|d
operator|->
name|selectAll
argument_list|(
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|d
operator|->
name|selectionBehaviorFlags
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|!=
name|SingleSelection
condition|)
name|d
operator|->
name|selectAll
argument_list|(
name|selectionCommand
argument_list|(
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|root
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts editing the item corresponding to the given \a index if it is     editable.      Note that this function does not change the current index. Since the current     index defines the next and previous items to edit, users may find that     keyboard navigation does not work as expected. To provide consistent navigation     behavior, call setCurrentIndex() before this function with the same model     index.      \sa QModelIndex::flags() */
end_comment
begin_function
DECL|function|edit
name|void
name|QAbstractItemView
operator|::
name|edit
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"edit: index was invalid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edit
argument_list|(
name|index
argument_list|,
name|AllEditTriggers
argument_list|,
literal|0
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"edit: editing failed"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Deselects all selected items. The current index will not be changed.      \sa setSelection(), selectAll() */
end_comment
begin_function
DECL|function|clearSelection
name|void
name|QAbstractItemView
operator|::
name|clearSelection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
name|d
operator|->
name|selectionModel
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      This function is intended to lay out the items in the view.     The default implementation just calls updateGeometries() and updates the viewport. */
end_comment
begin_function
DECL|function|doItemsLayout
name|void
name|QAbstractItemView
operator|::
name|doItemsLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|interruptDelayedItemsLayout
argument_list|()
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::editTriggers     \brief which actions will initiate item editing      This property is a selection of flags defined by     \l{EditTrigger}, combined using the OR     operator. The view will only initiate the editing of an item if the     action performed is set in this property. */
end_comment
begin_function
DECL|function|setEditTriggers
name|void
name|QAbstractItemView
operator|::
name|setEditTriggers
parameter_list|(
name|EditTriggers
name|actions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|editTriggers
operator|=
name|actions
expr_stmt|;
block|}
end_function
begin_function
DECL|function|editTriggers
name|QAbstractItemView
operator|::
name|EditTriggers
name|QAbstractItemView
operator|::
name|editTriggers
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|editTriggers
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \property QAbstractItemView::verticalScrollMode     \brief how the view scrolls its contents in the vertical direction      This property controls how the view scroll its contents vertically.     Scrolling can be done either per pixel or per item. */
end_comment
begin_function
DECL|function|setVerticalScrollMode
name|void
name|QAbstractItemView
operator|::
name|setVerticalScrollMode
parameter_list|(
name|ScrollMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|d
operator|->
name|verticalScrollMode
condition|)
return|return;
name|QModelIndex
name|topLeft
init|=
name|indexAt
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|verticalScrollMode
operator|=
name|mode
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
comment|// update the scroll bars
name|scrollTo
argument_list|(
name|topLeft
argument_list|,
name|QAbstractItemView
operator|::
name|PositionAtTop
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|verticalScrollMode
name|QAbstractItemView
operator|::
name|ScrollMode
name|QAbstractItemView
operator|::
name|verticalScrollMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verticalScrollMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \property QAbstractItemView::horizontalScrollMode     \brief how the view scrolls its contents in the horizontal direction      This property controls how the view scroll its contents horizontally.     Scrolling can be done either per pixel or per item. */
end_comment
begin_function
DECL|function|setHorizontalScrollMode
name|void
name|QAbstractItemView
operator|::
name|setHorizontalScrollMode
parameter_list|(
name|ScrollMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|horizontalScrollMode
operator|=
name|mode
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
comment|// update the scroll bars
block|}
end_function
begin_function
DECL|function|horizontalScrollMode
name|QAbstractItemView
operator|::
name|ScrollMode
name|QAbstractItemView
operator|::
name|horizontalScrollMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|horizontalScrollMode
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     \since 4.2     \property QAbstractItemView::dragDropOverwriteMode     \brief the view's drag and drop behavior      If its value is \c true, the selected data will overwrite the     existing item data when dropped, while moving the data will clear     the item. If its value is \c false, the selected data will be     inserted as a new item when the data is dropped. When the data is     moved, the item is removed as well.      The default value is \c false, as in the QListView and QTreeView     subclasses. In the QTableView subclass, on the other hand, the     property has been set to \c true.      Note: This is not intended to prevent overwriting of items.     The model's implementation of flags() should do that by not     returning Qt::ItemIsDropEnabled.      \sa dragDropMode */
end_comment
begin_function
DECL|function|setDragDropOverwriteMode
name|void
name|QAbstractItemView
operator|::
name|setDragDropOverwriteMode
parameter_list|(
name|bool
name|overwrite
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|overwrite
operator|=
name|overwrite
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dragDropOverwriteMode
name|bool
name|QAbstractItemView
operator|::
name|dragDropOverwriteMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|overwrite
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \property QAbstractItemView::autoScroll     \brief whether autoscrolling in drag move events is enabled      If this property is set to true (the default), the     QAbstractItemView automatically scrolls the contents of the view     if the user drags within 16 pixels of the viewport edge. If the current     item changes, then the view will scroll automatically to ensure that the     current item is fully visible.      This property only works if the viewport accepts drops. Autoscroll is     switched off by setting this property to false. */
end_comment
begin_function
DECL|function|setAutoScroll
name|void
name|QAbstractItemView
operator|::
name|setAutoScroll
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoScroll
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hasAutoScroll
name|bool
name|QAbstractItemView
operator|::
name|hasAutoScroll
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoScroll
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     \property QAbstractItemView::autoScrollMargin     \brief the size of the area when auto scrolling is triggered      This property controls the size of the area at the edge of the viewport that     triggers autoscrolling. The default value is 16 pixels. */
end_comment
begin_function
DECL|function|setAutoScrollMargin
name|void
name|QAbstractItemView
operator|::
name|setAutoScrollMargin
parameter_list|(
name|int
name|margin
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoScrollMargin
operator|=
name|margin
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoScrollMargin
name|int
name|QAbstractItemView
operator|::
name|autoScrollMargin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoScrollMargin
return|;
block|}
end_function
begin_comment
comment|/*!   \property QAbstractItemView::tabKeyNavigation   \brief whether item navigation with tab and backtab is enabled. */
end_comment
begin_function
DECL|function|setTabKeyNavigation
name|void
name|QAbstractItemView
operator|::
name|setTabKeyNavigation
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|tabKeyNavigation
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tabKeyNavigation
name|bool
name|QAbstractItemView
operator|::
name|tabKeyNavigation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|tabKeyNavigation
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     \property QAbstractItemView::showDropIndicator     \brief whether the drop indicator is shown when dragging items and dropping.      \sa dragEnabled, DragDropMode, dragDropOverwriteMode, acceptDrops */
end_comment
begin_function
DECL|function|setDropIndicatorShown
name|void
name|QAbstractItemView
operator|::
name|setDropIndicatorShown
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|showDropIndicator
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|showDropIndicator
name|bool
name|QAbstractItemView
operator|::
name|showDropIndicator
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|showDropIndicator
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::dragEnabled     \brief whether the view supports dragging of its own items      \sa showDropIndicator, DragDropMode, dragDropOverwriteMode, acceptDrops */
end_comment
begin_function
DECL|function|setDragEnabled
name|void
name|QAbstractItemView
operator|::
name|setDragEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragEnabled
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dragEnabled
name|bool
name|QAbstractItemView
operator|::
name|dragEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dragEnabled
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     \enum QAbstractItemView::DragDropMode      Describes the various drag and drop events the view can act upon.     By default the view does not support dragging or dropping (\c     NoDragDrop).      \value NoDragDrop Does not support dragging or dropping.     \value DragOnly The view supports dragging of its own items     \value DropOnly The view accepts drops     \value DragDrop The view supports both dragging and dropping     \value InternalMove The view accepts move (\b{not copy}) operations only            from itself.      Note that the model used needs to provide support for drag and drop operations.      \sa setDragDropMode(), {Using drag and drop with item views} */
end_comment
begin_comment
comment|/*!     \property QAbstractItemView::dragDropMode     \brief the drag and drop event the view will act upon      \since 4.2     \sa showDropIndicator, dragDropOverwriteMode */
end_comment
begin_function
DECL|function|setDragDropMode
name|void
name|QAbstractItemView
operator|::
name|setDragDropMode
parameter_list|(
name|DragDropMode
name|behavior
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragDropMode
operator|=
name|behavior
expr_stmt|;
name|setDragEnabled
argument_list|(
name|behavior
operator|==
name|DragOnly
operator|||
name|behavior
operator|==
name|DragDrop
operator|||
name|behavior
operator|==
name|InternalMove
argument_list|)
expr_stmt|;
name|setAcceptDrops
argument_list|(
name|behavior
operator|==
name|DropOnly
operator|||
name|behavior
operator|==
name|DragDrop
operator|||
name|behavior
operator|==
name|InternalMove
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dragDropMode
name|QAbstractItemView
operator|::
name|DragDropMode
name|QAbstractItemView
operator|::
name|dragDropMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|DragDropMode
name|setBehavior
init|=
name|d
operator|->
name|dragDropMode
decl_stmt|;
if|if
condition|(
operator|!
name|dragEnabled
argument_list|()
operator|&&
operator|!
name|acceptDrops
argument_list|()
condition|)
return|return
name|NoDragDrop
return|;
if|if
condition|(
name|dragEnabled
argument_list|()
operator|&&
operator|!
name|acceptDrops
argument_list|()
condition|)
return|return
name|DragOnly
return|;
if|if
condition|(
operator|!
name|dragEnabled
argument_list|()
operator|&&
name|acceptDrops
argument_list|()
condition|)
return|return
name|DropOnly
return|;
if|if
condition|(
name|dragEnabled
argument_list|()
operator|&&
name|acceptDrops
argument_list|()
condition|)
block|{
if|if
condition|(
name|setBehavior
operator|==
name|InternalMove
condition|)
return|return
name|setBehavior
return|;
else|else
return|return
name|DragDrop
return|;
block|}
return|return
name|NoDragDrop
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::defaultDropAction     \brief the drop action that will be used by default in QAbstractItemView::drag()      If the property is not set, the drop action is CopyAction when the supported     actions support CopyAction.      \since 4.6     \sa showDropIndicator, dragDropOverwriteMode */
end_comment
begin_function
DECL|function|setDefaultDropAction
name|void
name|QAbstractItemView
operator|::
name|setDefaultDropAction
parameter_list|(
name|Qt
operator|::
name|DropAction
name|dropAction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultDropAction
operator|=
name|dropAction
expr_stmt|;
block|}
end_function
begin_function
DECL|function|defaultDropAction
name|Qt
operator|::
name|DropAction
name|QAbstractItemView
operator|::
name|defaultDropAction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultDropAction
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_comment
comment|/*!     \property QAbstractItemView::alternatingRowColors     \brief whether to draw the background using alternating colors      If this property is true, the item background will be drawn using     QPalette::Base and QPalette::AlternateBase; otherwise the background     will be drawn using the QPalette::Base color.      By default, this property is false. */
end_comment
begin_function
DECL|function|setAlternatingRowColors
name|void
name|QAbstractItemView
operator|::
name|setAlternatingRowColors
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|alternatingColors
operator|=
name|enable
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|alternatingRowColors
name|bool
name|QAbstractItemView
operator|::
name|alternatingRowColors
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|alternatingColors
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::iconSize     \brief the size of items' icons      Setting this property when the view is visible will cause the     items to be laid out again. */
end_comment
begin_function
DECL|function|setIconSize
name|void
name|QAbstractItemView
operator|::
name|setIconSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|d
operator|->
name|iconSize
condition|)
return|return;
name|d
operator|->
name|iconSize
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|iconSize
name|QSize
name|QAbstractItemView
operator|::
name|iconSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|iconSize
return|;
block|}
end_function
begin_comment
comment|/*!     \property QAbstractItemView::textElideMode      \brief the position of the "..." in elided text.      The default value for all item views is Qt::ElideRight. */
end_comment
begin_function
DECL|function|setTextElideMode
name|void
name|QAbstractItemView
operator|::
name|setTextElideMode
parameter_list|(
name|Qt
operator|::
name|TextElideMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|textElideMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textElideMode
name|Qt
operator|::
name|TextElideMode
name|QAbstractItemView
operator|::
name|textElideMode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|textElideMode
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QAbstractItemView
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tabKeyNavigation
operator|&&
name|isEnabled
argument_list|()
operator|&&
name|d
operator|->
name|viewport
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|QKeyEvent
name|event
argument_list|(
name|QEvent
operator|::
name|KeyPress
argument_list|,
name|next
condition|?
name|Qt
operator|::
name|Key_Tab
else|:
name|Qt
operator|::
name|Key_Backtab
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
name|keyPressEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|isAccepted
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QAbstractItemView
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Paint
case|:
comment|//we call this here because the scrollbars' visibility might be altered
comment|//so this can't be done in the paintEvent method
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
comment|//make sure we set the layout properly
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
comment|//make sure we set the layout properly
if|if
condition|(
name|d
operator|->
name|shouldScrollToCurrentOnShow
condition|)
block|{
name|d
operator|->
name|shouldScrollToCurrentOnShow
operator|=
literal|false
expr_stmt|;
specifier|const
name|QModelIndex
name|current
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|d
operator|->
name|state
operator|==
name|QAbstractItemView
operator|::
name|EditingState
operator|||
name|d
operator|->
name|autoScroll
operator|)
condition|)
name|scrollTo
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|LocaleChange
case|:
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
case|case
name|QEvent
operator|::
name|ApplicationLayoutDirectionChange
case|:
name|updateGeometries
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleChange
case|:
name|doItemsLayout
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusOut
case|:
name|d
operator|->
name|checkPersistentEditorFocus
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FontChange
case|:
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
comment|// the size of the items will change
break|break;
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAbstractItemView::viewportEvent(QEvent *event)      This function is used to handle tool tips, and What's     This? mode, if the given \a event is a QEvent::ToolTip,or a     QEvent::WhatsThis. It passes all other     events on to its base class viewportEvent() handler. */
end_comment
begin_function
DECL|function|viewportEvent
name|bool
name|QAbstractItemView
operator|::
name|viewportEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|HoverMove
case|:
case|case
name|QEvent
operator|::
name|HoverEnter
case|:
name|d
operator|->
name|setHoverIndex
argument_list|(
name|indexAt
argument_list|(
cast|static_cast
argument_list|<
name|QHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|HoverLeave
case|:
name|d
operator|->
name|setHoverIndex
argument_list|(
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Enter
case|:
name|d
operator|->
name|viewportEnteredNeeded
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Leave
case|:
ifndef|#
directive|ifndef
name|QT_NO_STATUSTIP
if|if
condition|(
name|d
operator|->
name|shouldClearStatusTip
operator|&&
name|d
operator|->
name|parent
condition|)
block|{
name|QString
name|empty
decl_stmt|;
name|QStatusTipEvent
name|tip
argument_list|(
name|empty
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|parent
argument_list|,
operator|&
name|tip
argument_list|)
expr_stmt|;
name|d
operator|->
name|shouldClearStatusTip
operator|=
literal|false
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|enteredIndex
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ToolTip
case|:
case|case
name|QEvent
operator|::
name|QueryWhatsThis
case|:
case|case
name|QEvent
operator|::
name|WhatsThis
case|:
block|{
name|QHelpEvent
modifier|*
name|he
init|=
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
specifier|const
name|QModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|he
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|option
operator|.
name|rect
operator|=
name|visualRect
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|option
operator|.
name|state
operator||=
operator|(
name|index
operator|==
name|currentIndex
argument_list|()
condition|?
name|QStyle
operator|::
name|State_HasFocus
else|:
name|QStyle
operator|::
name|State_None
operator|)
expr_stmt|;
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|delegate
condition|)
return|return
literal|false
return|;
return|return
name|delegate
operator|->
name|helpEvent
argument_list|(
name|he
argument_list|,
name|this
argument_list|,
name|option
argument_list|,
name|index
argument_list|)
return|;
block|}
case|case
name|QEvent
operator|::
name|FontChange
case|:
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
comment|// the size of the items will change
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ScrollPrepare
case|:
name|executeDelayedItemsLayout
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|connect
argument_list|(
name|QScroller
operator|::
name|scroller
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QScroller
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_scrollerStateChanged
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|viewportEvent
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a mouse button is pressed     while the cursor is inside the widget. If a valid item is pressed on it is made     into the current item. This function emits the pressed() signal. */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QAbstractItemView
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//any interaction with the view cancel the auto scrolling
name|QPoint
name|pos
init|=
name|event
operator|->
name|pos
argument_list|()
decl_stmt|;
name|QPersistentModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|selectionModel
operator|||
operator|(
name|d
operator|->
name|state
operator|==
name|EditingState
operator|&&
name|d
operator|->
name|hasEditor
argument_list|(
name|index
argument_list|)
operator|)
condition|)
return|return;
name|d
operator|->
name|pressedAlreadySelected
operator|=
name|d
operator|->
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|d
operator|->
name|pressedIndex
operator|=
name|index
expr_stmt|;
name|d
operator|->
name|pressedModifiers
operator|=
name|event
operator|->
name|modifiers
argument_list|()
expr_stmt|;
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|selectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
decl_stmt|;
name|d
operator|->
name|noSelectionOnMousePress
operator|=
name|command
operator|==
name|QItemSelectionModel
operator|::
name|NoUpdate
operator|||
operator|!
name|index
operator|.
name|isValid
argument_list|()
expr_stmt|;
name|QPoint
name|offset
init|=
name|d
operator|->
name|offset
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Current
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|pressedPosition
operator|=
name|pos
operator|+
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indexAt
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|offset
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|pressedPosition
operator|=
name|visualRect
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
operator|.
name|center
argument_list|()
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|edit
argument_list|(
name|index
argument_list|,
name|NoEditTriggers
argument_list|,
name|event
argument_list|)
condition|)
return|return;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
condition|)
block|{
comment|// we disable scrollTo for mouse press so the item doesn't change position
comment|// when the user is interacting with it (ie. clicking on it)
name|bool
name|autoScroll
init|=
name|d
operator|->
name|autoScroll
decl_stmt|;
name|d
operator|->
name|autoScroll
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoScroll
operator|=
name|autoScroll
expr_stmt|;
name|QRect
name|rect
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|offset
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|command
operator|.
name|testFlag
argument_list|(
name|QItemSelectionModel
operator|::
name|Toggle
argument_list|)
condition|)
block|{
name|command
operator|&=
operator|~
name|QItemSelectionModel
operator|::
name|Toggle
expr_stmt|;
name|d
operator|->
name|ctrlDragSelectionFlag
operator|=
name|d
operator|->
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
condition|?
name|QItemSelectionModel
operator|::
name|Deselect
else|:
name|QItemSelectionModel
operator|::
name|Select
expr_stmt|;
name|command
operator||=
name|d
operator|->
name|ctrlDragSelectionFlag
expr_stmt|;
block|}
name|setSelection
argument_list|(
name|rect
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// signal handlers may change the model
emit|emit
name|pressed
argument_list|(
name|index
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|autoScroll
condition|)
block|{
comment|//we delay the autoscrolling to filter out double click event
comment|//100 is to be sure that there won't be a double-click misinterpreted as a 2 single clicks
name|d
operator|->
name|delayedAutoScroll
operator|.
name|start
argument_list|(
name|QApplication
operator|::
name|doubleClickInterval
argument_list|()
operator|+
literal|100
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Forces a finalize() even if mouse is pressed, but not on a item
name|d
operator|->
name|selectionModel
operator|->
name|select
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|QItemSelectionModel
operator|::
name|Select
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a mouse move event is     sent to the widget. If a selection is in progress and new items are moved     over the selection is extended; if a drag is in progress it is continued. */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QAbstractItemView
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QPoint
name|topLeft
decl_stmt|;
name|QPoint
name|bottomRight
init|=
name|event
operator|->
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|==
name|ExpandingState
operator|||
name|state
argument_list|()
operator|==
name|CollapsingState
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|state
argument_list|()
operator|==
name|DraggingState
condition|)
block|{
name|topLeft
operator|=
name|d
operator|->
name|pressedPosition
operator|-
name|d
operator|->
name|offset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|topLeft
operator|-
name|bottomRight
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|>
name|QApplication
operator|::
name|startDragDistance
argument_list|()
condition|)
block|{
name|d
operator|->
name|pressedIndex
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|startDrag
argument_list|(
name|d
operator|->
name|model
operator|->
name|supportedDragActions
argument_list|()
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
comment|// the startDrag will return when the dnd operation is done
name|stopAutoScroll
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|// QT_NO_DRAGANDDROP
name|QPersistentModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|bottomRight
argument_list|)
decl_stmt|;
name|QModelIndex
name|buddy
init|=
name|d
operator|->
name|model
operator|->
name|buddy
argument_list|(
name|d
operator|->
name|pressedIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|state
argument_list|()
operator|==
name|EditingState
operator|&&
name|d
operator|->
name|hasEditor
argument_list|(
name|buddy
argument_list|)
operator|)
operator|||
name|edit
argument_list|(
name|index
argument_list|,
name|NoEditTriggers
argument_list|,
name|event
argument_list|)
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|selectionMode
operator|!=
name|SingleSelection
condition|)
name|topLeft
operator|=
name|d
operator|->
name|pressedPosition
operator|-
name|d
operator|->
name|offset
argument_list|()
expr_stmt|;
else|else
name|topLeft
operator|=
name|bottomRight
expr_stmt|;
name|d
operator|->
name|checkMouseMove
argument_list|(
name|index
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|d
operator|->
name|pressedIndex
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|dragEnabled
operator|&&
operator|(
name|state
argument_list|()
operator|!=
name|DragSelectingState
operator|)
operator|&&
operator|(
name|event
operator|->
name|buttons
argument_list|()
operator|!=
name|Qt
operator|::
name|NoButton
operator|)
operator|&&
operator|!
name|d
operator|->
name|selectedDraggableIndexes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setState
argument_list|(
name|DraggingState
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
operator|&&
name|d
operator|->
name|selectionAllowed
argument_list|(
name|index
argument_list|)
operator|&&
name|d
operator|->
name|selectionModel
condition|)
block|{
name|setState
argument_list|(
name|DragSelectingState
argument_list|)
expr_stmt|;
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|selectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ctrlDragSelectionFlag
operator|!=
name|QItemSelectionModel
operator|::
name|NoUpdate
operator|&&
name|command
operator|.
name|testFlag
argument_list|(
name|QItemSelectionModel
operator|::
name|Toggle
argument_list|)
condition|)
block|{
name|command
operator|&=
operator|~
name|QItemSelectionModel
operator|::
name|Toggle
expr_stmt|;
name|command
operator||=
name|d
operator|->
name|ctrlDragSelectionFlag
expr_stmt|;
block|}
comment|// Do the normalize ourselves, since QRect::normalized() is flawed
name|QRect
name|selectionRect
init|=
name|QRect
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
decl_stmt|;
name|setSelection
argument_list|(
name|selectionRect
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// set at the end because it might scroll the view
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|index
operator|!=
name|d
operator|->
name|selectionModel
operator|->
name|currentIndex
argument_list|()
operator|)
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
condition|)
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a mouse button is released,     after a mouse press event on the widget. If a user presses the mouse inside your     widget and then drags the mouse to another location before releasing the mouse button,     your widget receives the release event. The function will emit the clicked() signal if an     item was being pressed. */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QAbstractItemView
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QPoint
name|pos
init|=
name|event
operator|->
name|pos
argument_list|()
decl_stmt|;
name|QPersistentModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|==
name|EditingState
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
operator|&&
name|d
operator|->
name|sendDelegateEvent
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
condition|)
name|update
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|click
init|=
operator|(
name|index
operator|==
name|d
operator|->
name|pressedIndex
operator|&&
name|index
operator|.
name|isValid
argument_list|()
operator|)
decl_stmt|;
name|bool
name|selectedClicked
init|=
name|click
operator|&&
operator|(
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
operator|)
operator|&&
name|d
operator|->
name|pressedAlreadySelected
decl_stmt|;
name|EditTrigger
name|trigger
init|=
operator|(
name|selectedClicked
condition|?
name|SelectedClicked
else|:
name|NoEditTriggers
operator|)
decl_stmt|;
name|bool
name|edited
init|=
name|edit
argument_list|(
name|index
argument_list|,
name|trigger
argument_list|,
name|event
argument_list|)
decl_stmt|;
name|d
operator|->
name|ctrlDragSelectionFlag
operator|=
name|QItemSelectionModel
operator|::
name|NoUpdate
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
operator|&&
name|d
operator|->
name|noSelectionOnMousePress
condition|)
block|{
name|d
operator|->
name|noSelectionOnMousePress
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|selectionModel
operator|->
name|select
argument_list|(
name|index
argument_list|,
name|selectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
if|if
condition|(
name|click
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
emit|emit
name|clicked
argument_list|(
name|index
argument_list|)
emit|;
if|if
condition|(
name|edited
condition|)
return|return;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|pressedAlreadySelected
condition|)
name|option
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Selected
expr_stmt|;
if|if
condition|(
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ItemView_ActivateItemOnSingleClick
argument_list|,
operator|&
name|option
argument_list|,
name|this
argument_list|)
condition|)
emit|emit
name|activated
argument_list|(
name|index
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a mouse button is     double clicked inside the widget. If the double-click is on a valid item it     emits the doubleClicked() signal and calls edit() on the item. */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QAbstractItemView
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
operator|||
operator|(
name|d
operator|->
name|pressedIndex
operator|!=
name|index
operator|)
condition|)
block|{
name|QMouseEvent
name|me
argument_list|(
name|QEvent
operator|::
name|MouseButtonPress
argument_list|,
name|event
operator|->
name|localPos
argument_list|()
argument_list|,
name|event
operator|->
name|windowPos
argument_list|()
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|,
name|event
operator|->
name|button
argument_list|()
argument_list|,
name|event
operator|->
name|buttons
argument_list|()
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
decl_stmt|;
name|mousePressEvent
argument_list|(
operator|&
name|me
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// signal handlers may change the model
name|QPersistentModelIndex
name|persistent
init|=
name|index
decl_stmt|;
emit|emit
name|doubleClicked
argument_list|(
name|persistent
argument_list|)
emit|;
if|if
condition|(
operator|(
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
operator|)
operator|&&
operator|!
name|edit
argument_list|(
name|persistent
argument_list|,
name|DoubleClicked
argument_list|,
name|event
argument_list|)
operator|&&
operator|!
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ItemView_ActivateItemOnSingleClick
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
condition|)
emit|emit
name|activated
argument_list|(
name|persistent
argument_list|)
emit|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     This function is called with the given \a event when a drag and drop operation enters     the widget. If the drag is over a valid dropping place (e.g. over an item that     accepts drops), the event is accepted; otherwise it is ignored.      \sa dropEvent(), startDrag() */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QAbstractItemView
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|dragDropMode
argument_list|()
operator|==
name|InternalMove
operator|&&
operator|(
name|event
operator|->
name|source
argument_list|()
operator|!=
name|this
operator|||
operator|!
operator|(
name|event
operator|->
name|possibleActions
argument_list|()
operator|&
name|Qt
operator|::
name|MoveAction
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|canDecode
argument_list|(
name|event
argument_list|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|DraggingState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called continuously with the given \a event during a drag and     drop operation over the widget. It can cause the view to scroll if, for example,     the user drags a selection to view's right or bottom edge. In this case, the     event will be accepted; otherwise it will be ignored.      \sa dropEvent(), startDrag() */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QAbstractItemView
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|dragDropMode
argument_list|()
operator|==
name|InternalMove
operator|&&
operator|(
name|event
operator|->
name|source
argument_list|()
operator|!=
name|this
operator|||
operator|!
operator|(
name|event
operator|->
name|possibleActions
argument_list|()
operator|&
name|Qt
operator|::
name|MoveAction
operator|)
operator|)
condition|)
return|return;
comment|// ignore by default
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|QModelIndex
name|index
init|=
name|indexAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|d
operator|->
name|hover
operator|=
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|droppingOnItself
argument_list|(
name|event
argument_list|,
name|index
argument_list|)
operator|&&
name|d
operator|->
name|canDecode
argument_list|(
name|event
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|showDropIndicator
condition|)
block|{
name|QRect
name|rect
init|=
name|visualRect
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|d
operator|->
name|dropIndicatorPosition
operator|=
name|d
operator|->
name|position
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|,
name|rect
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|dropIndicatorPosition
condition|)
block|{
case|case
name|AboveItem
case|:
if|if
condition|(
name|d
operator|->
name|isIndexDropEnabled
argument_list|(
name|index
operator|.
name|parent
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|BelowItem
case|:
if|if
condition|(
name|d
operator|->
name|isIndexDropEnabled
argument_list|(
name|index
operator|.
name|parent
argument_list|()
argument_list|)
condition|)
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|(
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|bottom
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OnItem
case|:
if|if
condition|(
name|d
operator|->
name|isIndexDropEnabled
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|rect
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OnViewport
case|:
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isIndexDropEnabled
argument_list|(
name|rootIndex
argument_list|()
argument_list|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// allow dropping in empty areas
block|}
break|break;
block|}
block|}
else|else
block|{
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|d
operator|->
name|dropIndicatorPosition
operator|=
name|OnViewport
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isIndexDropEnabled
argument_list|(
name|rootIndex
argument_list|()
argument_list|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// allow dropping in empty areas
block|}
block|}
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
comment|// can decode
if|if
condition|(
name|d
operator|->
name|shouldAutoScroll
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|startAutoScroll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Return true if this is a move from ourself and \a index is a child of the selection that     is being moved.  */
end_comment
begin_function
DECL|function|droppingOnItself
name|bool
name|QAbstractItemViewPrivate
operator|::
name|droppingOnItself
parameter_list|(
name|QDropEvent
modifier|*
name|event
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|DropAction
name|dropAction
init|=
name|event
operator|->
name|dropAction
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|dragDropMode
argument_list|()
operator|==
name|QAbstractItemView
operator|::
name|InternalMove
condition|)
name|dropAction
operator|=
name|Qt
operator|::
name|MoveAction
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|source
argument_list|()
operator|==
name|q
operator|&&
name|event
operator|->
name|possibleActions
argument_list|()
operator|&
name|Qt
operator|::
name|MoveAction
operator|&&
name|dropAction
operator|==
name|Qt
operator|::
name|MoveAction
condition|)
block|{
name|QModelIndexList
name|selectedIndexes
init|=
name|q
operator|->
name|selectedIndexes
argument_list|()
decl_stmt|;
name|QModelIndex
name|child
init|=
name|index
decl_stmt|;
while|while
condition|(
name|child
operator|.
name|isValid
argument_list|()
operator|&&
name|child
operator|!=
name|root
condition|)
block|{
if|if
condition|(
name|selectedIndexes
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
return|return
literal|true
return|;
name|child
operator|=
name|child
operator|.
name|parent
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAbstractItemView::dragLeaveEvent(QDragLeaveEvent *event)      This function is called when the item being dragged leaves the view.     The \a event describes the state of the drag and drop operation. */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QAbstractItemView
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|stopAutoScroll
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
name|d
operator|->
name|hover
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a drop event occurs over     the widget. If the model accepts the even position the drop event is accepted;     otherwise it is ignored.      \sa startDrag() */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QAbstractItemView
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|dragDropMode
argument_list|()
operator|==
name|InternalMove
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|source
argument_list|()
operator|!=
name|this
operator|||
operator|!
operator|(
name|event
operator|->
name|possibleActions
argument_list|()
operator|&
name|Qt
operator|::
name|MoveAction
operator|)
condition|)
return|return;
block|}
name|QModelIndex
name|index
decl_stmt|;
name|int
name|col
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|row
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|dropOn
argument_list|(
name|event
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|,
operator|&
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|model
operator|->
name|dropMimeData
argument_list|(
name|event
operator|->
name|mimeData
argument_list|()
argument_list|,
name|dragDropMode
argument_list|()
operator|==
name|InternalMove
condition|?
name|Qt
operator|::
name|MoveAction
else|:
name|event
operator|->
name|dropAction
argument_list|()
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|dragDropMode
argument_list|()
operator|==
name|InternalMove
condition|)
name|event
operator|->
name|setDropAction
argument_list|(
name|Qt
operator|::
name|MoveAction
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
block|}
name|stopAutoScroll
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the event hasn't already been accepted, determines the index to drop on.      if (row == -1&& col == -1)         // append to this drop index     else         // place at row, col in drop index      If it returns true a drop can be done, and dropRow, dropCol and dropIndex reflects the position of the drop.     \internal   */
end_comment
begin_function
DECL|function|dropOn
name|bool
name|QAbstractItemViewPrivate
operator|::
name|dropOn
parameter_list|(
name|QDropEvent
modifier|*
name|event
parameter_list|,
name|int
modifier|*
name|dropRow
parameter_list|,
name|int
modifier|*
name|dropCol
parameter_list|,
name|QModelIndex
modifier|*
name|dropIndex
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
return|return
literal|false
return|;
name|QModelIndex
name|index
decl_stmt|;
comment|// rootIndex() (i.e. the viewport) might be a valid index
if|if
condition|(
name|viewport
operator|->
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|index
operator|=
name|q
operator|->
name|indexAt
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|q
operator|->
name|visualRect
argument_list|(
name|index
argument_list|)
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|index
operator|=
name|root
expr_stmt|;
block|}
comment|// If we are allowed to do the drop
if|if
condition|(
name|model
operator|->
name|supportedDropActions
argument_list|()
operator|&
name|event
operator|->
name|dropAction
argument_list|()
condition|)
block|{
name|int
name|row
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|col
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|index
operator|!=
name|root
condition|)
block|{
name|dropIndicatorPosition
operator|=
name|position
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|,
name|q
operator|->
name|visualRect
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dropIndicatorPosition
condition|)
block|{
case|case
name|QAbstractItemView
operator|::
name|AboveItem
case|:
name|row
operator|=
name|index
operator|.
name|row
argument_list|()
expr_stmt|;
name|col
operator|=
name|index
operator|.
name|column
argument_list|()
expr_stmt|;
name|index
operator|=
name|index
operator|.
name|parent
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractItemView
operator|::
name|BelowItem
case|:
name|row
operator|=
name|index
operator|.
name|row
argument_list|()
operator|+
literal|1
expr_stmt|;
name|col
operator|=
name|index
operator|.
name|column
argument_list|()
expr_stmt|;
name|index
operator|=
name|index
operator|.
name|parent
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractItemView
operator|::
name|OnItem
case|:
case|case
name|QAbstractItemView
operator|::
name|OnViewport
case|:
break|break;
block|}
block|}
else|else
block|{
name|dropIndicatorPosition
operator|=
name|QAbstractItemView
operator|::
name|OnViewport
expr_stmt|;
block|}
operator|*
name|dropIndex
operator|=
name|index
expr_stmt|;
operator|*
name|dropRow
operator|=
name|row
expr_stmt|;
operator|*
name|dropCol
operator|=
name|col
expr_stmt|;
if|if
condition|(
operator|!
name|droppingOnItself
argument_list|(
name|event
argument_list|,
name|index
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
name|QAbstractItemView
operator|::
name|DropIndicatorPosition
DECL|function|position
name|QAbstractItemViewPrivate
operator|::
name|position
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|QAbstractItemView
operator|::
name|DropIndicatorPosition
name|r
init|=
name|QAbstractItemView
operator|::
name|OnViewport
decl_stmt|;
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
specifier|const
name|int
name|margin
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|pos
operator|.
name|y
argument_list|()
operator|-
name|rect
operator|.
name|top
argument_list|()
operator|<
name|margin
condition|)
block|{
name|r
operator|=
name|QAbstractItemView
operator|::
name|AboveItem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rect
operator|.
name|bottom
argument_list|()
operator|-
name|pos
operator|.
name|y
argument_list|()
operator|<
name|margin
condition|)
block|{
name|r
operator|=
name|QAbstractItemView
operator|::
name|BelowItem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rect
operator|.
name|contains
argument_list|(
name|pos
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|r
operator|=
name|QAbstractItemView
operator|::
name|OnItem
expr_stmt|;
block|}
block|}
else|else
block|{
name|QRect
name|touchingRect
init|=
name|rect
decl_stmt|;
name|touchingRect
operator|.
name|adjust
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|touchingRect
operator|.
name|contains
argument_list|(
name|pos
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|r
operator|=
name|QAbstractItemView
operator|::
name|OnItem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|QAbstractItemView
operator|::
name|OnItem
operator|&&
operator|(
operator|!
operator|(
name|model
operator|->
name|flags
argument_list|(
name|index
argument_list|)
operator|&
name|Qt
operator|::
name|ItemIsDropEnabled
operator|)
operator|)
condition|)
name|r
operator|=
name|pos
operator|.
name|y
argument_list|()
operator|<
name|rect
operator|.
name|center
argument_list|()
operator|.
name|y
argument_list|()
condition|?
name|QAbstractItemView
operator|::
name|AboveItem
else|:
name|QAbstractItemView
operator|::
name|BelowItem
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_comment
comment|/*!     This function is called with the given \a event when the widget obtains the focus.     By default, the event is ignored.      \sa setFocus(), focusOutEvent() */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QAbstractItemView
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|focusInEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
specifier|const
name|QItemSelectionModel
modifier|*
name|model
init|=
name|selectionModel
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|currentIndexValid
init|=
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
decl_stmt|;
if|if
condition|(
name|model
operator|&&
operator|!
name|d
operator|->
name|currentIndexSet
operator|&&
operator|!
name|currentIndexValid
condition|)
block|{
name|bool
name|autoScroll
init|=
name|d
operator|->
name|autoScroll
decl_stmt|;
name|d
operator|->
name|autoScroll
operator|=
literal|false
expr_stmt|;
name|QModelIndex
name|index
init|=
name|moveCursor
argument_list|(
name|MoveNext
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
comment|// first visible index
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
operator|&&
name|event
operator|->
name|reason
argument_list|()
operator|!=
name|Qt
operator|::
name|MouseFocusReason
condition|)
name|selectionModel
argument_list|()
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoScroll
operator|=
name|autoScroll
expr_stmt|;
block|}
if|if
condition|(
name|model
operator|&&
name|currentIndexValid
condition|)
block|{
if|if
condition|(
name|currentIndex
argument_list|()
operator|.
name|flags
argument_list|()
operator|!=
name|Qt
operator|::
name|ItemIsEditable
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|currentIndexValid
condition|)
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when the widget     looses the focus. By default, the event is ignored.      \sa clearFocus(), focusInEvent() */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QAbstractItemView
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|focusOutEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a key event is sent to     the widget. The default implementation handles basic cursor movement, e.g. Up,     Down, Left, Right, Home, PageUp, and PageDown; the activated() signal is     emitted if the current index is valid and the activation key is pressed     (e.g. Enter or Return, depending on the platform).     This function is where editing is initiated by key press, e.g. if F2 is     pressed.      \sa edit(), moveCursor(), keyboardSearch(), tabKeyNavigation */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QAbstractItemView
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//any interaction with the view cancel the auto scrolling
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Back
case|:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|hasEditFocus
argument_list|()
condition|)
block|{
name|setEditFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
name|Qt
operator|::
name|Key_Down
case|:
case|case
name|Qt
operator|::
name|Key_Up
case|:
comment|// Let's ignore vertical navigation events, only if there is no other widget
comment|// what can take the focus in vertical direction. This means widget can handle navigation events
comment|// even the widget don't have edit focus, and there is no other widget in requested direction.
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
operator|&&
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Left
case|:
case|case
name|Qt
operator|::
name|Key_Right
case|:
comment|// Similar logic as in up and down events
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
operator|&&
operator|(
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|||
name|QWidgetPrivate
operator|::
name|inTabWidget
argument_list|(
name|this
argument_list|)
operator|)
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
operator|!
name|hasEditFocus
argument_list|()
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_CLIPBOARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SHORTCUT
argument_list|)
if|if
condition|(
name|event
operator|==
name|QKeySequence
operator|::
name|Copy
condition|)
block|{
name|QVariant
name|variant
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|model
condition|)
name|variant
operator|=
name|d
operator|->
name|model
operator|->
name|data
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|Qt
operator|::
name|DisplayRole
argument_list|)
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|String
condition|)
name|QApplication
operator|::
name|clipboard
argument_list|()
operator|->
name|setText
argument_list|(
name|variant
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|QPersistentModelIndex
name|newCurrent
decl_stmt|;
name|d
operator|->
name|moveCursorUpdatedView
operator|=
literal|false
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Down
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveDown
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Up
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveUp
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Left
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveLeft
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Right
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveRight
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Home
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveHome
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_End
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveEnd
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_PageUp
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MovePageUp
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_PageDown
case|:
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MovePageDown
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Tab
case|:
if|if
condition|(
name|d
operator|->
name|tabKeyNavigation
condition|)
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MoveNext
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Backtab
case|:
if|if
condition|(
name|d
operator|->
name|tabKeyNavigation
condition|)
name|newCurrent
operator|=
name|moveCursor
argument_list|(
name|MovePrevious
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|QPersistentModelIndex
name|oldCurrent
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|newCurrent
operator|!=
name|oldCurrent
operator|&&
name|newCurrent
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|newCurrent
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hasFocus
argument_list|()
operator|&&
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|==
name|indexWidget
argument_list|(
name|oldCurrent
argument_list|)
condition|)
name|setFocus
argument_list|()
expr_stmt|;
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
init|=
name|selectionCommand
argument_list|(
name|newCurrent
argument_list|,
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|command
operator|!=
name|QItemSelectionModel
operator|::
name|NoUpdate
operator|||
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ItemView_MovementWithoutUpdatingSelection
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
condition|)
block|{
comment|// note that we don't check if the new current index is enabled because moveCursor() makes sure it is
if|if
condition|(
name|command
operator|&
name|QItemSelectionModel
operator|::
name|Current
condition|)
block|{
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|newCurrent
argument_list|,
name|QItemSelectionModel
operator|::
name|NoUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexAt
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|d
operator|->
name|offset
argument_list|()
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|pressedPosition
operator|=
name|visualRect
argument_list|(
name|oldCurrent
argument_list|)
operator|.
name|center
argument_list|()
operator|+
name|d
operator|->
name|offset
argument_list|()
expr_stmt|;
name|QRect
name|rect
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|d
operator|->
name|offset
argument_list|()
argument_list|,
name|visualRect
argument_list|(
name|newCurrent
argument_list|)
operator|.
name|center
argument_list|()
argument_list|)
decl_stmt|;
name|setSelection
argument_list|(
name|rect
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|newCurrent
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|d
operator|->
name|pressedPosition
operator|=
name|visualRect
argument_list|(
name|newCurrent
argument_list|)
operator|.
name|center
argument_list|()
operator|+
name|d
operator|->
name|offset
argument_list|()
expr_stmt|;
if|if
condition|(
name|newCurrent
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// We copy the same behaviour as for mousePressEvent().
name|QRect
name|rect
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|d
operator|->
name|offset
argument_list|()
argument_list|,
name|QSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|setSelection
argument_list|(
name|rect
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|event
operator|->
name|key
argument_list|()
condition|)
block|{
comment|// ignored keys
case|case
name|Qt
operator|::
name|Key_Down
case|:
case|case
name|Qt
operator|::
name|Key_Up
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|keypadNavigationEnabled
argument_list|()
operator|&&
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// don't change focus
break|break;
block|}
endif|#
directive|endif
case|case
name|Qt
operator|::
name|Key_Left
case|:
case|case
name|Qt
operator|::
name|Key_Right
case|:
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadDirectional
operator|&&
operator|(
name|QWidgetPrivate
operator|::
name|canKeypadNavigate
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|)
operator|||
operator|(
name|QWidgetPrivate
operator|::
name|inTabWidget
argument_list|(
name|this
argument_list|)
operator|&&
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// don't change focus
break|break;
block|}
endif|#
directive|endif
comment|// QT_KEYPAD_NAVIGATION
case|case
name|Qt
operator|::
name|Key_Home
case|:
case|case
name|Qt
operator|::
name|Key_End
case|:
case|case
name|Qt
operator|::
name|Key_PageUp
case|:
case|case
name|Qt
operator|::
name|Key_PageDown
case|:
case|case
name|Qt
operator|::
name|Key_Escape
case|:
case|case
name|Qt
operator|::
name|Key_Shift
case|:
case|case
name|Qt
operator|::
name|Key_Control
case|:
case|case
name|Qt
operator|::
name|Key_Delete
case|:
case|case
name|Qt
operator|::
name|Key_Backspace
case|:
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Space
case|:
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
operator|!
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|AnyKeyPressed
argument_list|,
name|event
argument_list|)
operator|&&
name|d
operator|->
name|selectionModel
condition|)
name|d
operator|->
name|selectionModel
operator|->
name|select
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|selectionCommand
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|event
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Select
condition|)
block|{
comment|// Also do Key_Enter action.
if|if
condition|(
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|state
argument_list|()
operator|!=
name|EditingState
condition|)
emit|emit
name|activated
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
emit|;
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|Q_WS_MAC
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
comment|// Propagate the enter if you couldn't edit the item and there are no
comment|// current editors (if there are editors, the event was most likely propagated from it).
if|if
condition|(
operator|!
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|EditKeyPressed
argument_list|,
name|event
argument_list|)
operator|&&
name|d
operator|->
name|editorIndexHash
operator|.
name|isEmpty
argument_list|()
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|Qt
operator|::
name|Key_F2
case|:
if|if
condition|(
operator|!
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|EditKeyPressed
argument_list|,
name|event
argument_list|)
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Key_Enter
case|:
case|case
name|Qt
operator|::
name|Key_Return
case|:
comment|// ### we can't open the editor on enter, becuse
comment|// some widgets will forward the enter event back
comment|// to the viewport, starting an endless loop
if|if
condition|(
name|state
argument_list|()
operator|!=
name|EditingState
operator|||
name|hasFocus
argument_list|()
condition|)
block|{
if|if
condition|(
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
emit|emit
name|activated
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
emit|;
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|Key_A
case|:
if|if
condition|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
block|{
name|selectAll
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
block|{
ifdef|#
directive|ifdef
name|Q_WS_MAC
if|if
condition|(
name|event
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_O
operator|&&
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|&&
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
emit|emit
name|activated
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
emit|;
break|break;
block|}
endif|#
directive|endif
name|bool
name|modified
init|=
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator||
name|Qt
operator|::
name|MetaModifier
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|modified
operator|&&
operator|!
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|AnyKeyPressed
argument_list|,
name|event
argument_list|)
condition|)
block|{
name|keyboardSearch
argument_list|(
name|event
operator|->
name|text
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|moveCursorUpdatedView
condition|)
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called with the given \a event when a resize event is sent to     the widget.      \sa QWidget::resizeEvent() */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QAbstractItemView
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|event
parameter_list|)
block|{
name|QAbstractScrollArea
operator|::
name|resizeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   This function is called with the given \a event when a timer event is sent   to the widget.    \sa QObject::timerEvent() */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QAbstractItemView
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|fetchMoreTimer
operator|.
name|timerId
argument_list|()
condition|)
name|d
operator|->
name|fetchMore
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|delayedReset
operator|.
name|timerId
argument_list|()
condition|)
name|reset
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|autoScrollTimer
operator|.
name|timerId
argument_list|()
condition|)
name|doAutoScroll
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|updateTimer
operator|.
name|timerId
argument_list|()
condition|)
name|d
operator|->
name|updateDirtyRegion
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|delayedEditing
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|delayedEditing
operator|.
name|stop
argument_list|()
expr_stmt|;
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|delayedLayout
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|delayedLayout
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|d
operator|->
name|interruptDelayedItemsLayout
argument_list|()
expr_stmt|;
name|doItemsLayout
argument_list|()
expr_stmt|;
specifier|const
name|QModelIndex
name|current
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|state
operator|==
name|QAbstractItemView
operator|::
name|EditingState
condition|)
name|scrollTo
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|delayedAutoScroll
operator|.
name|timerId
argument_list|()
condition|)
block|{
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//end of the timer: if the current item is still the same as the one when the mouse press occurred
comment|//we only get here if there was no double click
if|if
condition|(
name|d
operator|->
name|pressedIndex
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|pressedIndex
operator|==
name|currentIndex
argument_list|()
condition|)
name|scrollTo
argument_list|(
name|d
operator|->
name|pressedIndex
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QAbstractItemView
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|commitString
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|event
operator|->
name|preeditString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|edit
argument_list|(
name|currentIndex
argument_list|()
argument_list|,
name|AnyKeyPressed
argument_list|,
name|event
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|event
operator|->
name|commitString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|keyboardSearch
argument_list|(
name|event
operator|->
name|commitString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     \enum QAbstractItemView::DropIndicatorPosition      This enum indicates the position of the drop indicator in     relation to the index at the current mouse position:      \value OnItem  The item will be dropped on the index.      \value AboveItem  The item will be dropped above the index.      \value BelowItem  The item will be dropped below the index.      \value OnViewport  The item will be dropped onto a region of the viewport with     no items. The way each view handles items dropped onto the viewport depends on     the behavior of the underlying model in use. */
end_comment
begin_comment
comment|/*!     \since 4.1      Returns the position of the drop indicator in relation to the closest item. */
end_comment
begin_function
DECL|function|dropIndicatorPosition
name|QAbstractItemView
operator|::
name|DropIndicatorPosition
name|QAbstractItemView
operator|::
name|dropIndicatorPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dropIndicatorPosition
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     This convenience function returns a list of all selected and     non-hidden item indexes in the view. The list contains no     duplicates, and is not sorted.      \sa QItemSelectionModel::selectedIndexes() */
end_comment
begin_function
DECL|function|selectedIndexes
name|QModelIndexList
name|QAbstractItemView
operator|::
name|selectedIndexes
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndexList
name|indexes
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionModel
condition|)
block|{
name|indexes
operator|=
name|d
operator|->
name|selectionModel
operator|->
name|selectedIndexes
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QModelIndex
argument_list|>
operator|::
name|iterator
name|it
init|=
name|indexes
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|indexes
operator|.
name|end
argument_list|()
condition|)
if|if
condition|(
name|isIndexHidden
argument_list|(
operator|*
name|it
argument_list|)
condition|)
name|it
operator|=
name|indexes
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
return|return
name|indexes
return|;
block|}
end_function
begin_comment
comment|/*!     Starts editing the item at \a index, creating an editor if     necessary, and returns true if the view's \l{State} is now     EditingState; otherwise returns false.      The action that caused the editing process is described by     \a trigger, and the associated event is specified by \a event.      Editing can be forced by specifying the \a trigger to be     QAbstractItemView::AllEditTriggers.      \sa closeEditor() */
end_comment
begin_function
DECL|function|edit
name|bool
name|QAbstractItemView
operator|::
name|edit
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|EditTrigger
name|trigger
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QWidget
modifier|*
name|w
init|=
operator|(
name|d
operator|->
name|persistent
operator|.
name|isEmpty
argument_list|()
condition|?
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
else|:
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|focusPolicy
argument_list|()
operator|==
name|Qt
operator|::
name|NoFocus
condition|)
return|return
literal|false
return|;
name|w
operator|->
name|setFocus
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|trigger
operator|==
name|DoubleClicked
condition|)
block|{
name|d
operator|->
name|delayedEditing
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|delayedAutoScroll
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trigger
operator|==
name|CurrentChanged
condition|)
block|{
name|d
operator|->
name|delayedEditing
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|sendDelegateEvent
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
condition|)
block|{
name|update
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// save the previous trigger before updating
name|EditTriggers
name|lastTrigger
init|=
name|d
operator|->
name|lastTrigger
decl_stmt|;
name|d
operator|->
name|lastTrigger
operator|=
name|trigger
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|shouldEdit
argument_list|(
name|trigger
argument_list|,
name|d
operator|->
name|model
operator|->
name|buddy
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|delayedEditing
operator|.
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// we will receive a mouseButtonReleaseEvent after a
comment|// mouseDoubleClickEvent, so we need to check the previous trigger
if|if
condition|(
name|lastTrigger
operator|==
name|DoubleClicked
operator|&&
name|trigger
operator|==
name|SelectedClicked
condition|)
return|return
literal|false
return|;
comment|// we may get a double click event later
if|if
condition|(
name|trigger
operator|==
name|SelectedClicked
condition|)
name|d
operator|->
name|delayedEditing
operator|.
name|start
argument_list|(
name|QApplication
operator|::
name|doubleClickInterval
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|openEditor
argument_list|(
name|index
argument_list|,
name|d
operator|->
name|shouldForwardEvent
argument_list|(
name|trigger
argument_list|,
name|event
argument_list|)
condition|?
name|event
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Updates the data shown in the open editor widgets in the view. */
end_comment
begin_function
DECL|function|updateEditorData
name|void
name|QAbstractItemView
operator|::
name|updateEditorData
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateEditorData
argument_list|(
name|QModelIndex
argument_list|()
argument_list|,
name|QModelIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Updates the geometry of the open editor widgets in the view. */
end_comment
begin_function
DECL|function|updateEditorGeometries
name|void
name|QAbstractItemView
operator|::
name|updateEditorGeometries
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|editorIndexHash
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|QEditorIndexHash
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|editorIndexHash
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QWidgetList
name|editorsToRelease
decl_stmt|;
name|QWidgetList
name|editorsToHide
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|editorIndexHash
operator|.
name|end
argument_list|()
condition|)
block|{
name|QModelIndex
name|index
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|editor
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|editor
condition|)
block|{
name|option
operator|.
name|rect
operator|=
name|visualRect
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|.
name|rect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|editor
operator|->
name|show
argument_list|()
expr_stmt|;
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|delegate
condition|)
name|delegate
operator|->
name|updateEditorGeometry
argument_list|(
name|editor
argument_list|,
name|option
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|editorsToHide
operator|<<
name|editor
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|indexEditorHash
operator|.
name|remove
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|d
operator|->
name|editorIndexHash
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|editorsToRelease
operator|<<
name|editor
expr_stmt|;
block|}
block|}
comment|//we hide and release the editor outside of the loop because it might change the focus and try
comment|//to change the editors hashes.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|editorsToHide
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|editorsToHide
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|hide
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|editorsToRelease
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|releaseEditor
argument_list|(
name|editorsToRelease
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Updates the geometry of the child widgets of the view. */
end_comment
begin_function
DECL|function|updateGeometries
name|void
name|QAbstractItemView
operator|::
name|updateGeometries
parameter_list|()
block|{
name|updateEditorGeometries
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|fetchMoreTimer
operator|.
name|start
argument_list|(
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|//fetch more later
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|verticalScrollbarValueChanged
name|void
name|QAbstractItemView
operator|::
name|verticalScrollbarValueChanged
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|verticalScrollBar
argument_list|()
operator|->
name|maximum
argument_list|()
operator|==
name|value
operator|&&
name|d
operator|->
name|model
operator|->
name|canFetchMore
argument_list|(
name|d
operator|->
name|root
argument_list|)
condition|)
name|d
operator|->
name|model
operator|->
name|fetchMore
argument_list|(
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
name|QPoint
name|posInVp
init|=
name|viewport
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|posInVp
argument_list|)
condition|)
name|d
operator|->
name|checkMouseMove
argument_list|(
name|posInVp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|horizontalScrollbarValueChanged
name|void
name|QAbstractItemView
operator|::
name|horizontalScrollbarValueChanged
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|horizontalScrollBar
argument_list|()
operator|->
name|maximum
argument_list|()
operator|==
name|value
operator|&&
name|d
operator|->
name|model
operator|->
name|canFetchMore
argument_list|(
name|d
operator|->
name|root
argument_list|)
condition|)
name|d
operator|->
name|model
operator|->
name|fetchMore
argument_list|(
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
name|QPoint
name|posInVp
init|=
name|viewport
argument_list|()
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|posInVp
argument_list|)
condition|)
name|d
operator|->
name|checkMouseMove
argument_list|(
name|posInVp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|verticalScrollbarAction
name|void
name|QAbstractItemView
operator|::
name|verticalScrollbarAction
parameter_list|(
name|int
parameter_list|)
block|{
comment|//do nothing
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|horizontalScrollbarAction
name|void
name|QAbstractItemView
operator|::
name|horizontalScrollbarAction
parameter_list|(
name|int
parameter_list|)
block|{
comment|//do nothing
block|}
end_function
begin_comment
comment|/*!     Closes the given \a editor, and releases it. The \a hint is     used to specify how the view should respond to the end of the editing     operation. For example, the hint may indicate that the next item in     the view should be opened for editing.      \sa edit(), commitData() */
end_comment
begin_function
DECL|function|closeEditor
name|void
name|QAbstractItemView
operator|::
name|closeEditor
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|,
name|QAbstractItemDelegate
operator|::
name|EndEditHint
name|hint
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
comment|// Close the editor
if|if
condition|(
name|editor
condition|)
block|{
name|bool
name|isPersistent
init|=
name|d
operator|->
name|persistent
operator|.
name|contains
argument_list|(
name|editor
argument_list|)
decl_stmt|;
name|bool
name|hadFocus
init|=
name|editor
operator|->
name|hasFocus
argument_list|()
decl_stmt|;
name|QModelIndex
name|index
init|=
name|d
operator|->
name|indexForEditor
argument_list|(
name|editor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return;
comment|// the editor was not registered
if|if
condition|(
operator|!
name|isPersistent
condition|)
block|{
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
name|QModelIndex
name|index
init|=
name|d
operator|->
name|indexForEditor
argument_list|(
name|editor
argument_list|)
decl_stmt|;
name|editor
operator|->
name|removeEventFilter
argument_list|(
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|removeEditor
argument_list|(
name|editor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hadFocus
condition|)
name|setFocus
argument_list|()
expr_stmt|;
comment|// this will send a focusLost event to the editor
else|else
name|d
operator|->
name|checkPersistentEditorFocus
argument_list|()
expr_stmt|;
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|ed
init|=
name|editor
decl_stmt|;
name|QApplication
operator|::
name|sendPostedEvents
argument_list|(
name|editor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|editor
operator|=
name|ed
expr_stmt|;
if|if
condition|(
operator|!
name|isPersistent
operator|&&
name|editor
condition|)
name|d
operator|->
name|releaseEditor
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// The EndEditHint part
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|flags
init|=
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|d
operator|->
name|selectionBehaviorFlags
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|hint
condition|)
block|{
case|case
name|QAbstractItemDelegate
operator|::
name|EditNextItem
case|:
block|{
name|QModelIndex
name|index
init|=
name|moveCursor
argument_list|(
name|MoveNext
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QPersistentModelIndex
name|persistent
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|persistent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|// currentChanged signal would have already started editing
if|if
condition|(
name|index
operator|.
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|ItemIsEditable
operator|&&
operator|(
operator|!
operator|(
name|editTriggers
argument_list|()
operator|&
name|QAbstractItemView
operator|::
name|CurrentChanged
operator|)
operator|)
condition|)
name|edit
argument_list|(
name|persistent
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QAbstractItemDelegate
operator|::
name|EditPreviousItem
case|:
block|{
name|QModelIndex
name|index
init|=
name|moveCursor
argument_list|(
name|MovePrevious
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QPersistentModelIndex
name|persistent
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|d
operator|->
name|selectionModel
operator|->
name|setCurrentIndex
argument_list|(
name|persistent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|// currentChanged signal would have already started editing
if|if
condition|(
name|index
operator|.
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|ItemIsEditable
operator|&&
operator|(
operator|!
operator|(
name|editTriggers
argument_list|()
operator|&
name|QAbstractItemView
operator|::
name|CurrentChanged
operator|)
operator|)
condition|)
name|edit
argument_list|(
name|persistent
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QAbstractItemDelegate
operator|::
name|SubmitModelCache
case|:
name|d
operator|->
name|model
operator|->
name|submit
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractItemDelegate
operator|::
name|RevertModelCache
case|:
name|d
operator|->
name|model
operator|->
name|revert
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Commit the data in the \a editor to the model.      \sa closeEditor() */
end_comment
begin_function
DECL|function|commitData
name|void
name|QAbstractItemView
operator|::
name|commitData
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|editor
operator|||
operator|!
name|d
operator|->
name|itemDelegate
operator|||
name|d
operator|->
name|currentlyCommittingEditor
condition|)
return|return;
name|QModelIndex
name|index
init|=
name|d
operator|->
name|indexForEditor
argument_list|(
name|editor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|d
operator|->
name|currentlyCommittingEditor
operator|=
name|editor
expr_stmt|;
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|editor
operator|->
name|removeEventFilter
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|delegate
operator|->
name|setModelData
argument_list|(
name|editor
argument_list|,
name|d
operator|->
name|model
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|editor
operator|->
name|installEventFilter
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentlyCommittingEditor
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called when the given \a editor has been destroyed.      \sa closeEditor() */
end_comment
begin_function
DECL|function|editorDestroyed
name|void
name|QAbstractItemView
operator|::
name|editorDestroyed
parameter_list|(
name|QObject
modifier|*
name|editor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|editor
argument_list|)
decl_stmt|;
name|d
operator|->
name|removeEditor
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|d
operator|->
name|persistent
operator|.
name|remove
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|==
name|EditingState
condition|)
name|setState
argument_list|(
name|NoState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     Sets the horizontal scroll bar's steps per item to \a steps.      This is the number of steps used by the horizontal scroll bar to     represent the width of an item.      Note that if the view has a horizontal header, the item steps     will be ignored and the header section size will be used instead.      \sa horizontalStepsPerItem(), setVerticalStepsPerItem() */
end_comment
begin_function
DECL|function|setHorizontalStepsPerItem
name|void
name|QAbstractItemView
operator|::
name|setHorizontalStepsPerItem
parameter_list|(
name|int
name|steps
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|steps
argument_list|)
comment|// do nothing
block|}
end_function
begin_comment
comment|/*!     \obsolete     Returns the horizontal scroll bar's steps per item.      \sa setHorizontalStepsPerItem(), verticalStepsPerItem() */
end_comment
begin_function
DECL|function|horizontalStepsPerItem
name|int
name|QAbstractItemView
operator|::
name|horizontalStepsPerItem
parameter_list|()
specifier|const
block|{
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     Sets the vertical scroll bar's steps per item to \a steps.      This is the number of steps used by the vertical scroll bar to     represent the height of an item.      Note that if the view has a vertical header, the item steps     will be ignored and the header section size will be used instead.      \sa verticalStepsPerItem(), setHorizontalStepsPerItem() */
end_comment
begin_function
DECL|function|setVerticalStepsPerItem
name|void
name|QAbstractItemView
operator|::
name|setVerticalStepsPerItem
parameter_list|(
name|int
name|steps
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|steps
argument_list|)
comment|// do nothing
block|}
end_function
begin_comment
comment|/*!     \obsolete     Returns the vertical scroll bar's steps per item.      \sa setVerticalStepsPerItem(), horizontalStepsPerItem() */
end_comment
begin_function
DECL|function|verticalStepsPerItem
name|int
name|QAbstractItemView
operator|::
name|verticalStepsPerItem
parameter_list|()
specifier|const
block|{
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Moves to and selects the item best matching the string \a search.     If no item is found nothing happens.      In the default implementation, the search is reset if \a search is empty, or     the time interval since the last search has exceeded     QApplication::keyboardInputInterval(). */
end_comment
begin_function
DECL|function|keyboardSearch
name|void
name|QAbstractItemView
operator|::
name|keyboardSearch
parameter_list|(
specifier|const
name|QString
modifier|&
name|search
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|||
operator|!
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
condition|)
return|return;
name|QModelIndex
name|start
init|=
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
condition|?
name|currentIndex
argument_list|()
else|:
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|bool
name|skipRow
init|=
literal|false
decl_stmt|;
name|bool
name|keyboardTimeWasValid
init|=
name|d
operator|->
name|keyboardInputTime
operator|.
name|isValid
argument_list|()
decl_stmt|;
name|qint64
name|keyboardInputTimeElapsed
init|=
name|d
operator|->
name|keyboardInputTime
operator|.
name|restart
argument_list|()
decl_stmt|;
if|if
condition|(
name|search
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|keyboardTimeWasValid
operator|||
name|keyboardInputTimeElapsed
operator|>
name|QApplication
operator|::
name|keyboardInputInterval
argument_list|()
condition|)
block|{
name|d
operator|->
name|keyboardInput
operator|=
name|search
expr_stmt|;
name|skipRow
operator|=
name|currentIndex
argument_list|()
operator|.
name|isValid
argument_list|()
expr_stmt|;
comment|//if it is not valid we should really start at QModelIndex(0,0)
block|}
else|else
block|{
name|d
operator|->
name|keyboardInput
operator|+=
name|search
expr_stmt|;
block|}
comment|// special case for searches with same key like 'aaaaa'
name|bool
name|sameKey
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|keyboardInput
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|int
name|c
init|=
name|d
operator|->
name|keyboardInput
operator|.
name|count
argument_list|(
name|d
operator|->
name|keyboardInput
operator|.
name|at
argument_list|(
name|d
operator|->
name|keyboardInput
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|sameKey
operator|=
operator|(
name|c
operator|==
name|d
operator|->
name|keyboardInput
operator|.
name|length
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|sameKey
condition|)
name|skipRow
operator|=
literal|true
expr_stmt|;
block|}
comment|// skip if we are searching for the same key or a new search started
if|if
condition|(
name|skipRow
condition|)
block|{
name|QModelIndex
name|parent
init|=
name|start
operator|.
name|parent
argument_list|()
decl_stmt|;
name|int
name|newRow
init|=
operator|(
name|start
operator|.
name|row
argument_list|()
operator|<
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
operator|)
condition|?
name|start
operator|.
name|row
argument_list|()
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|start
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|newRow
argument_list|,
name|start
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// search from start with wraparound
specifier|const
name|QString
name|searchString
init|=
name|sameKey
condition|?
name|QString
argument_list|(
name|d
operator|->
name|keyboardInput
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
name|d
operator|->
name|keyboardInput
decl_stmt|;
name|QModelIndex
name|current
init|=
name|start
decl_stmt|;
name|QModelIndexList
name|match
decl_stmt|;
name|QModelIndex
name|firstMatch
decl_stmt|;
name|QModelIndex
name|startMatch
decl_stmt|;
name|QModelIndexList
name|previous
decl_stmt|;
do|do
block|{
name|match
operator|=
name|d
operator|->
name|model
operator|->
name|match
argument_list|(
name|current
argument_list|,
name|Qt
operator|::
name|DisplayRole
argument_list|,
name|searchString
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|previous
condition|)
break|break;
name|firstMatch
operator|=
name|match
operator|.
name|value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|previous
operator|=
name|match
expr_stmt|;
if|if
condition|(
name|firstMatch
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|firstMatch
argument_list|)
condition|)
block|{
name|setCurrentIndex
argument_list|(
name|firstMatch
argument_list|)
expr_stmt|;
break|break;
block|}
name|int
name|row
init|=
name|firstMatch
operator|.
name|row
argument_list|()
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|row
operator|>=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|firstMatch
operator|.
name|parent
argument_list|()
argument_list|)
condition|)
name|row
operator|=
literal|0
expr_stmt|;
name|current
operator|=
name|firstMatch
operator|.
name|sibling
argument_list|(
name|row
argument_list|,
name|firstMatch
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
comment|//avoid infinite loop if all the matching items are disabled.
if|if
condition|(
operator|!
name|startMatch
operator|.
name|isValid
argument_list|()
condition|)
name|startMatch
operator|=
name|firstMatch
expr_stmt|;
elseif|else
if|if
condition|(
name|startMatch
operator|==
name|firstMatch
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|current
operator|!=
name|start
operator|&&
name|firstMatch
operator|.
name|isValid
argument_list|()
condition|)
do|;
block|}
end_function
begin_comment
comment|/*!     Returns the size hint for the item with the specified \a index or     an invalid size for invalid indexes.      \sa sizeHintForRow(), sizeHintForColumn() */
end_comment
begin_function
DECL|function|sizeHintForIndex
name|QSize
name|QAbstractItemView
operator|::
name|sizeHintForIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
operator|||
operator|!
name|d
operator|->
name|itemDelegate
condition|)
return|return
name|QSize
argument_list|()
return|;
return|return
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
operator|->
name|sizeHint
argument_list|(
name|d
operator|->
name|viewOptions
argument_list|()
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the height size hint for the specified \a row or -1 if     there is no model.      The returned height is calculated using the size hints of the     given \a row's items, i.e. the returned value is the maximum     height among the items. Note that to control the height of a row,     you must reimplement the QAbstractItemDelegate::sizeHint()     function.      This function is used in views with a vertical header to find the     size hint for a header section based on the contents of the given     \a row.      \sa sizeHintForColumn() */
end_comment
begin_function
DECL|function|sizeHintForRow
name|int
name|QAbstractItemView
operator|::
name|sizeHintForRow
parameter_list|(
name|int
name|row
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|int
name|height
init|=
literal|0
decl_stmt|;
name|int
name|colCount
init|=
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|colCount
condition|;
operator|++
name|c
control|)
block|{
name|index
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
condition|)
name|height
operator|=
name|qMax
argument_list|(
name|height
argument_list|,
name|editor
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|hint
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
operator|->
name|sizeHint
argument_list|(
name|option
argument_list|,
name|index
argument_list|)
operator|.
name|height
argument_list|()
decl_stmt|;
name|height
operator|=
name|qMax
argument_list|(
name|height
argument_list|,
name|hint
argument_list|)
expr_stmt|;
block|}
return|return
name|height
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width size hint for the specified \a column or -1 if there is no model.      This function is used in views with a horizontal header to find the size hint for     a header section based on the contents of the given \a column.      \sa sizeHintForRow() */
end_comment
begin_function
DECL|function|sizeHintForColumn
name|int
name|QAbstractItemView
operator|::
name|sizeHintForColumn
parameter_list|(
name|int
name|column
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|<
literal|0
operator|||
name|column
operator|>=
name|d
operator|->
name|model
operator|->
name|columnCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ensurePolished
argument_list|()
expr_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|rows
init|=
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|index
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
block|{
name|index
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|r
argument_list|,
name|column
argument_list|,
name|d
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
condition|)
name|width
operator|=
name|qMax
argument_list|(
name|width
argument_list|,
name|editor
operator|->
name|sizeHint
argument_list|()
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|hint
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|index
argument_list|)
operator|->
name|sizeHint
argument_list|(
name|option
argument_list|,
name|index
argument_list|)
operator|.
name|width
argument_list|()
decl_stmt|;
name|width
operator|=
name|qMax
argument_list|(
name|width
argument_list|,
name|hint
argument_list|)
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/*!     Opens a persistent editor on the item at the given \a index.     If no editor exists, the delegate will create a new editor.      \sa closePersistentEditor() */
end_comment
begin_function
DECL|function|openPersistentEditor
name|void
name|QAbstractItemView
operator|::
name|openPersistentEditor
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QStyleOptionViewItem
name|options
init|=
name|d
operator|->
name|viewOptions
argument_list|()
decl_stmt|;
name|options
operator|.
name|rect
operator|=
name|visualRect
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|options
operator|.
name|state
operator||=
operator|(
name|index
operator|==
name|currentIndex
argument_list|()
condition|?
name|QStyle
operator|::
name|State_HasFocus
else|:
name|QStyle
operator|::
name|State_None
operator|)
expr_stmt|;
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editor
argument_list|(
name|index
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|editor
condition|)
block|{
name|editor
operator|->
name|show
argument_list|()
expr_stmt|;
name|d
operator|->
name|persistent
operator|.
name|insert
argument_list|(
name|editor
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Closes the persistent editor for the item at the given \a index.      \sa openPersistentEditor() */
end_comment
begin_function
DECL|function|closePersistentEditor
name|void
name|QAbstractItemView
operator|::
name|closePersistentEditor
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
condition|)
block|{
if|if
condition|(
name|index
operator|==
name|selectionModel
argument_list|()
operator|->
name|currentIndex
argument_list|()
condition|)
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|RevertModelCache
argument_list|)
expr_stmt|;
name|d
operator|->
name|persistent
operator|.
name|remove
argument_list|(
name|editor
argument_list|)
expr_stmt|;
name|d
operator|->
name|removeEditor
argument_list|(
name|editor
argument_list|)
expr_stmt|;
name|d
operator|->
name|releaseEditor
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the given \a widget on the item at the given \a index, passing the     ownership of the widget to the viewport.      If \a index is invalid (e.g., if you pass the root index), this function     will do nothing.      The given \a widget's \l{QWidget}{autoFillBackground} property must be set     to true, otherwise the widget's background will be transparent, showing     both the model data and the item at the given \a index.      If index widget A is replaced with index widget B, index widget A will be     deleted. For example, in the code snippet below, the QLineEdit object will     be deleted.      \snippet code/src_gui_itemviews_qabstractitemview.cpp 1      This function should only be used to display static content within the     visible area corresponding to an item of data. If you want to display     custom dynamic content or implement a custom editor widget, subclass     QItemDelegate instead.      \sa {Delegate Classes} */
end_comment
begin_function
DECL|function|setIndexWidget
name|void
name|QAbstractItemView
operator|::
name|setIndexWidget
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return;
if|if
condition|(
name|QWidget
modifier|*
name|oldWidget
init|=
name|indexWidget
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|d
operator|->
name|persistent
operator|.
name|remove
argument_list|(
name|oldWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|removeEditor
argument_list|(
name|oldWidget
argument_list|)
expr_stmt|;
name|oldWidget
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|widget
condition|)
block|{
name|widget
operator|->
name|setParent
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|persistent
operator|.
name|insert
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|d
operator|->
name|addEditor
argument_list|(
name|index
argument_list|,
name|widget
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|widget
operator|->
name|show
argument_list|()
expr_stmt|;
name|dataChanged
argument_list|(
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|// update the geometry
if|if
condition|(
operator|!
name|d
operator|->
name|delayedPendingLayout
condition|)
name|widget
operator|->
name|setGeometry
argument_list|(
name|visualRect
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the widget for the item at the given \a index. */
end_comment
begin_function
DECL|function|indexWidget
name|QWidget
modifier|*
name|QAbstractItemView
operator|::
name|indexWidget
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isIndexValid
argument_list|(
name|index
argument_list|)
condition|)
if|if
condition|(
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
condition|)
return|return
name|editor
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Scrolls the view to the top.      \sa scrollTo(), scrollToBottom() */
end_comment
begin_function
DECL|function|scrollToTop
name|void
name|QAbstractItemView
operator|::
name|scrollToTop
parameter_list|()
block|{
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalScrollBar
argument_list|()
operator|->
name|minimum
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Scrolls the view to the bottom.      \sa scrollTo(), scrollToTop() */
end_comment
begin_function
DECL|function|scrollToBottom
name|void
name|QAbstractItemView
operator|::
name|scrollToBottom
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|delayedPendingLayout
condition|)
block|{
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
name|updateGeometries
argument_list|()
expr_stmt|;
block|}
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|verticalScrollBar
argument_list|()
operator|->
name|maximum
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Updates the area occupied by the given \a index.  */
end_comment
begin_function
DECL|function|update
name|void
name|QAbstractItemView
operator|::
name|update
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|QRect
name|rect
init|=
name|visualRect
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|//this test is important for peformance reason
comment|//For example in dataChanged we simply update all the cells without checking
comment|//it can be a major bottleneck to update rects that aren't even part of the viewport
if|if
condition|(
name|d
operator|->
name|viewport
operator|->
name|rect
argument_list|()
operator|.
name|intersects
argument_list|(
name|rect
argument_list|)
condition|)
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This slot is called when items with the given \a roles are changed in the     model. The changed items are those from \a topLeft to \a bottomRight     inclusive. If just one item is changed \a topLeft == \a bottomRight.      The \a roles which have been changed can either be an empty container (meaning everything     has changed), or a non-empty container with the subset of roles which have changed. */
end_comment
begin_function
DECL|function|dataChanged
name|void
name|QAbstractItemView
operator|::
name|dataChanged
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|topLeft
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|bottomRight
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|roles
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|roles
argument_list|)
expr_stmt|;
comment|// Single item changed
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|topLeft
operator|==
name|bottomRight
operator|&&
name|topLeft
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|QEditorInfo
modifier|&
name|editorInfo
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|topLeft
argument_list|)
decl_stmt|;
comment|//we don't update the edit data if it is static
if|if
condition|(
operator|!
name|editorInfo
operator|.
name|isStatic
operator|&&
name|editorInfo
operator|.
name|widget
condition|)
block|{
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|d
operator|->
name|delegateForIndex
argument_list|(
name|topLeft
argument_list|)
decl_stmt|;
if|if
condition|(
name|delegate
condition|)
block|{
name|delegate
operator|->
name|setEditorData
argument_list|(
name|editorInfo
operator|.
name|widget
operator|.
name|data
argument_list|()
argument_list|,
name|topLeft
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|delayedPendingLayout
condition|)
block|{
comment|// otherwise the items will be update later anyway
name|update
argument_list|(
name|topLeft
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|updateEditorData
argument_list|(
name|topLeft
argument_list|,
name|bottomRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|delayedPendingLayout
condition|)
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|this
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|DataChanged
argument_list|)
decl_stmt|;
name|accessibleEvent
operator|.
name|setFirstRow
argument_list|(
name|topLeft
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setFirstColumn
argument_list|(
name|topLeft
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastRow
argument_list|(
name|bottomRight
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastColumn
argument_list|(
name|bottomRight
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     This slot is called when rows are inserted. The new rows are those     under the given \a parent from \a start to \a end inclusive. The     base class implementation calls fetchMore() on the model to check     for more data.      \sa rowsAboutToBeRemoved() */
end_comment
begin_function
DECL|function|rowsInserted
name|void
name|QAbstractItemView
operator|::
name|rowsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isVisible
argument_list|()
condition|)
name|d_func
argument_list|()
operator|->
name|fetchMoreTimer
operator|.
name|start
argument_list|(
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|//fetch more later
else|else
name|updateEditorGeometries
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called when rows are about to be removed. The deleted rows are     those under the given \a parent from \a start to \a end inclusive.      \sa rowsInserted() */
end_comment
begin_function
DECL|function|rowsAboutToBeRemoved
name|void
name|QAbstractItemView
operator|::
name|rowsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|CollapsingState
argument_list|)
expr_stmt|;
comment|// Ensure one selected item in single selection mode.
name|QModelIndex
name|current
init|=
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|selectionMode
operator|==
name|SingleSelection
operator|&&
name|current
operator|.
name|isValid
argument_list|()
operator|&&
name|current
operator|.
name|row
argument_list|()
operator|>=
name|start
operator|&&
name|current
operator|.
name|row
argument_list|()
operator|<=
name|end
operator|&&
name|current
operator|.
name|parent
argument_list|()
operator|==
name|parent
condition|)
block|{
name|int
name|totalToRemove
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|<=
name|totalToRemove
condition|)
block|{
comment|// no more children
name|QModelIndex
name|index
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|index
operator|!=
name|d
operator|->
name|root
operator|&&
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
condition|)
name|index
operator|=
name|index
operator|.
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|d
operator|->
name|root
condition|)
name|setCurrentIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|row
init|=
name|end
operator|+
literal|1
decl_stmt|;
name|QModelIndex
name|next
decl_stmt|;
do|do
block|{
comment|// find the next visible and enabled item
name|next
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
operator|++
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|,
name|current
operator|.
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|isIndexHidden
argument_list|(
name|next
argument_list|)
operator|||
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|next
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|row
operator|>
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|row
operator|=
name|start
operator|-
literal|1
expr_stmt|;
do|do
block|{
comment|// find the previous visible and enabled item
name|next
operator|=
name|d
operator|->
name|model
operator|->
name|index
argument_list|(
name|row
operator|--
argument_list|,
name|current
operator|.
name|column
argument_list|()
argument_list|,
name|current
operator|.
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|isIndexHidden
argument_list|(
name|next
argument_list|)
operator|||
operator|!
name|d
operator|->
name|isIndexEnabled
argument_list|(
name|next
argument_list|)
operator|)
condition|)
do|;
block|}
name|setCurrentIndex
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove all affected editors; this is more efficient than waiting for updateGeometries() to clean out editors for invalid indexes
name|QEditorIndexHash
operator|::
name|iterator
name|i
init|=
name|d
operator|->
name|editorIndexHash
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|d
operator|->
name|editorIndexHash
operator|.
name|end
argument_list|()
condition|)
block|{
specifier|const
name|QModelIndex
name|index
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|row
argument_list|()
operator|>=
name|start
operator|&&
name|index
operator|.
name|row
argument_list|()
operator|<=
name|end
operator|&&
name|d
operator|->
name|model
operator|->
name|parent
argument_list|(
name|index
argument_list|)
operator|==
name|parent
condition|)
block|{
name|QWidget
modifier|*
name|editor
init|=
name|i
operator|.
name|key
argument_list|()
decl_stmt|;
name|QEditorInfo
name|info
init|=
name|d
operator|->
name|indexEditorHash
operator|.
name|take
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|i
operator|=
name|d
operator|->
name|editorIndexHash
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|widget
condition|)
name|d
operator|->
name|releaseEditor
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when rows have been removed. The deleted     rows are those under the given \a parent from \a start to \a end     inclusive. */
end_comment
begin_function
DECL|function|_q_rowsRemoved
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_rowsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|index
argument_list|)
name|Q_UNUSED
argument_list|(
argument|start
argument_list|)
name|Q_UNUSED
argument_list|(
argument|end
argument_list|)
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|q
operator|->
name|updateEditorGeometries
argument_list|()
expr_stmt|;
name|q
operator|->
name|setState
argument_list|(
name|QAbstractItemView
operator|::
name|NoState
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|q
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|RowsRemoved
argument_list|)
decl_stmt|;
name|accessibleEvent
operator|.
name|setFirstRow
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastRow
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when columns are about to be removed. The deleted     columns are those under the given \a parent from \a start to \a end     inclusive. */
end_comment
begin_function
DECL|function|_q_columnsAboutToBeRemoved
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_columnsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|q
operator|->
name|setState
argument_list|(
name|QAbstractItemView
operator|::
name|CollapsingState
argument_list|)
expr_stmt|;
comment|// Ensure one selected item in single selection mode.
name|QModelIndex
name|current
init|=
name|q
operator|->
name|currentIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|isValid
argument_list|()
operator|&&
name|selectionMode
operator|==
name|QAbstractItemView
operator|::
name|SingleSelection
operator|&&
name|current
operator|.
name|column
argument_list|()
operator|>=
name|start
operator|&&
name|current
operator|.
name|column
argument_list|()
operator|<=
name|end
condition|)
block|{
name|int
name|totalToRemove
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|model
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|<
name|totalToRemove
condition|)
block|{
comment|// no more columns
name|QModelIndex
name|index
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|index
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|isIndexEnabled
argument_list|(
name|index
argument_list|)
condition|)
name|index
operator|=
name|index
operator|.
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
name|q
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|column
init|=
name|end
decl_stmt|;
name|QModelIndex
name|next
decl_stmt|;
do|do
block|{
comment|// find the next visible and enabled item
name|next
operator|=
name|model
operator|->
name|index
argument_list|(
name|current
operator|.
name|row
argument_list|()
argument_list|,
name|column
operator|++
argument_list|,
name|current
operator|.
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|q
operator|->
name|isIndexHidden
argument_list|(
name|next
argument_list|)
operator|||
operator|!
name|isIndexEnabled
argument_list|(
name|next
argument_list|)
operator|)
condition|)
do|;
name|q
operator|->
name|setCurrentIndex
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove all affected editors; this is more efficient than waiting for updateGeometries() to clean out editors for invalid indexes
name|QEditorIndexHash
operator|::
name|iterator
name|it
init|=
name|editorIndexHash
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|editorIndexHash
operator|.
name|end
argument_list|()
condition|)
block|{
name|QModelIndex
name|index
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|column
argument_list|()
operator|<=
name|start
operator|&&
name|index
operator|.
name|column
argument_list|()
operator|>=
name|end
operator|&&
name|model
operator|->
name|parent
argument_list|(
name|index
argument_list|)
operator|==
name|parent
condition|)
block|{
name|QWidget
modifier|*
name|editor
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|QEditorInfo
name|info
init|=
name|indexEditorHash
operator|.
name|take
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|it
operator|=
name|editorIndexHash
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|widget
condition|)
name|releaseEditor
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when columns have been removed. The deleted     rows are those under the given \a parent from \a start to \a end     inclusive. */
end_comment
begin_function
DECL|function|_q_columnsRemoved
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_columnsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|index
argument_list|)
name|Q_UNUSED
argument_list|(
argument|start
argument_list|)
name|Q_UNUSED
argument_list|(
argument|end
argument_list|)
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|q
operator|->
name|updateEditorGeometries
argument_list|()
expr_stmt|;
name|q
operator|->
name|setState
argument_list|(
name|QAbstractItemView
operator|::
name|NoState
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|q
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|ColumnsRemoved
argument_list|)
decl_stmt|;
name|accessibleEvent
operator|.
name|setFirstColumn
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastColumn
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when rows have been inserted. */
end_comment
begin_function
DECL|function|_q_rowsInserted
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_rowsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|index
argument_list|)
name|Q_UNUSED
argument_list|(
argument|start
argument_list|)
name|Q_UNUSED
argument_list|(
argument|end
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|q
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|RowsInserted
argument_list|)
decl_stmt|;
name|accessibleEvent
operator|.
name|setFirstRow
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastRow
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when columns have been inserted. */
end_comment
begin_function
DECL|function|_q_columnsInserted
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_columnsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|index
argument_list|)
name|Q_UNUSED
argument_list|(
argument|start
argument_list|)
name|Q_UNUSED
argument_list|(
argument|end
argument_list|)
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isVisible
argument_list|()
condition|)
name|q
operator|->
name|updateEditorGeometries
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|q
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|ColumnsInserted
argument_list|)
decl_stmt|;
name|accessibleEvent
operator|.
name|setFirstColumn
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|accessibleEvent
operator|.
name|setLastColumn
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_modelDestroyed
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_modelDestroyed
parameter_list|()
block|{
name|model
operator|=
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
argument_list|()
expr_stmt|;
name|doDelayedReset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      This slot is called when the layout is changed. */
end_comment
begin_function
DECL|function|_q_layoutChanged
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_layoutChanged
parameter_list|()
block|{
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QAccessible
operator|::
name|isActive
argument_list|()
condition|)
block|{
name|QAccessibleTableModelChangeEvent
name|accessibleEvent
argument_list|(
name|q
argument_list|,
name|QAccessibleTableModelChangeEvent
operator|::
name|ModelReset
argument_list|)
decl_stmt|;
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
operator|&
name|accessibleEvent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_rowsMoved
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_rowsMoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|)
block|{
name|_q_layoutChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_columnsMoved
name|void
name|QAbstractItemViewPrivate
operator|::
name|_q_columnsMoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|)
block|{
name|_q_layoutChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot is called when the selection is changed. The previous     selection (which may be empty), is specified by \a deselected, and the     new selection by \a selected.      \sa setSelection() */
end_comment
begin_function
DECL|function|selectionChanged
name|void
name|QAbstractItemView
operator|::
name|selectionChanged
parameter_list|(
specifier|const
name|QItemSelection
modifier|&
name|selected
parameter_list|,
specifier|const
name|QItemSelection
modifier|&
name|deselected
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|isVisible
argument_list|()
operator|&&
name|updatesEnabled
argument_list|()
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|(
name|visualRegionForSelection
argument_list|(
name|deselected
argument_list|)
operator||
name|visualRegionForSelection
argument_list|(
name|selected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This slot is called when a new item becomes the current item.     The previous current item is specified by the \a previous index, and the new     item by the \a current index.      If you want to know about changes to items see the     dataChanged() signal. */
end_comment
begin_function
DECL|function|currentChanged
name|void
name|QAbstractItemView
operator|::
name|currentChanged
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|current
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|previous
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QModelIndex
name|buddy
init|=
name|d
operator|->
name|model
operator|->
name|buddy
argument_list|(
name|previous
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|editor
init|=
name|d
operator|->
name|editorForIndex
argument_list|(
name|buddy
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|editor
operator|&&
operator|!
name|d
operator|->
name|persistent
operator|.
name|contains
argument_list|(
name|editor
argument_list|)
condition|)
block|{
name|commitData
argument_list|(
name|editor
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|row
argument_list|()
operator|!=
name|previous
operator|.
name|row
argument_list|()
condition|)
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|SubmitModelCache
argument_list|)
expr_stmt|;
else|else
name|closeEditor
argument_list|(
name|editor
argument_list|,
name|QAbstractItemDelegate
operator|::
name|NoHint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|update
argument_list|(
name|previous
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|autoScrollTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|autoScroll
condition|)
name|scrollTo
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|edit
argument_list|(
name|current
argument_list|,
name|CurrentChanged
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|row
argument_list|()
operator|==
operator|(
name|d
operator|->
name|model
operator|->
name|rowCount
argument_list|(
name|d
operator|->
name|root
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|d
operator|->
name|fetchMore
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|shouldScrollToCurrentOnShow
operator|=
name|d
operator|->
name|autoScroll
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
end_ifndef
begin_comment
comment|/*!     Starts a drag by calling drag->exec() using the given \a supportedActions. */
end_comment
begin_function
DECL|function|startDrag
name|void
name|QAbstractItemView
operator|::
name|startDrag
parameter_list|(
name|Qt
operator|::
name|DropActions
name|supportedActions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndexList
name|indexes
init|=
name|d
operator|->
name|selectedDraggableIndexes
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexes
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|QMimeData
modifier|*
name|data
init|=
name|d
operator|->
name|model
operator|->
name|mimeData
argument_list|(
name|indexes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return;
name|QRect
name|rect
decl_stmt|;
name|QPixmap
name|pixmap
init|=
name|d
operator|->
name|renderToPixmap
argument_list|(
name|indexes
argument_list|,
operator|&
name|rect
argument_list|)
decl_stmt|;
name|rect
operator|.
name|adjust
argument_list|(
name|horizontalOffset
argument_list|()
argument_list|,
name|verticalOffset
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QDrag
modifier|*
name|drag
init|=
operator|new
name|QDrag
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|drag
operator|->
name|setPixmap
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
name|drag
operator|->
name|setMimeData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|drag
operator|->
name|setHotSpot
argument_list|(
name|d
operator|->
name|pressedPosition
operator|-
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|DropAction
name|defaultDropAction
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|defaultDropAction
operator|!=
name|Qt
operator|::
name|IgnoreAction
operator|&&
operator|(
name|supportedActions
operator|&
name|d
operator|->
name|defaultDropAction
operator|)
condition|)
name|defaultDropAction
operator|=
name|d
operator|->
name|defaultDropAction
expr_stmt|;
elseif|else
if|if
condition|(
name|supportedActions
operator|&
name|Qt
operator|::
name|CopyAction
operator|&&
name|dragDropMode
argument_list|()
operator|!=
name|QAbstractItemView
operator|::
name|InternalMove
condition|)
name|defaultDropAction
operator|=
name|Qt
operator|::
name|CopyAction
expr_stmt|;
if|if
condition|(
name|drag
operator|->
name|exec
argument_list|(
name|supportedActions
argument_list|,
name|defaultDropAction
argument_list|)
operator|==
name|Qt
operator|::
name|MoveAction
condition|)
name|d
operator|->
name|clearOrRemove
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DRAGANDDROP
end_comment
begin_comment
comment|/*!     Returns a QStyleOptionViewItem structure populated with the view's     palette, font, state, alignments etc. */
end_comment
begin_function
DECL|function|viewOptions
name|QStyleOptionViewItem
name|QAbstractItemView
operator|::
name|viewOptions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|viewOptions
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|viewOptions
name|QStyleOptionViewItem
name|QAbstractItemViewPrivate
operator|::
name|viewOptions
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QStyleOptionViewItem
name|option
decl_stmt|;
name|option
operator|.
name|init
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|option
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
name|option
operator|.
name|font
operator|=
name|q
operator|->
name|font
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_WS_MAC
comment|// On mac the focus appearance follows window activation
comment|// not widget activation
if|if
condition|(
operator|!
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
name|option
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_Active
expr_stmt|;
endif|#
directive|endif
name|option
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
if|if
condition|(
name|iconSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|option
operator|.
name|decorationSize
operator|=
name|iconSize
expr_stmt|;
block|}
else|else
block|{
name|int
name|pm
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_SmallIconSize
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|option
operator|.
name|decorationSize
operator|=
name|QSize
argument_list|(
name|pm
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
name|option
operator|.
name|decorationPosition
operator|=
name|QStyleOptionViewItem
operator|::
name|Left
expr_stmt|;
name|option
operator|.
name|decorationAlignment
operator|=
name|Qt
operator|::
name|AlignCenter
expr_stmt|;
name|option
operator|.
name|displayAlignment
operator|=
name|Qt
operator|::
name|AlignLeft
operator||
name|Qt
operator|::
name|AlignVCenter
expr_stmt|;
name|option
operator|.
name|textElideMode
operator|=
name|textElideMode
expr_stmt|;
name|option
operator|.
name|rect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|option
operator|.
name|showDecorationSelected
operator|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ItemView_ShowDecorationSelected
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrapItemText
condition|)
name|option
operator|.
name|features
operator|=
name|QStyleOptionViewItem
operator|::
name|WrapText
expr_stmt|;
name|option
operator|.
name|locale
operator|=
name|q
operator|->
name|locale
argument_list|()
expr_stmt|;
name|option
operator|.
name|locale
operator|.
name|setNumberOptions
argument_list|(
name|QLocale
operator|::
name|OmitGroupSeparator
argument_list|)
expr_stmt|;
name|option
operator|.
name|widget
operator|=
name|q
expr_stmt|;
return|return
name|option
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item view's state.      \sa setState() */
end_comment
begin_function
DECL|function|state
name|QAbstractItemView
operator|::
name|State
name|QAbstractItemView
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item view's state to the given \a state.      \sa state() */
end_comment
begin_function
DECL|function|setState
name|void
name|QAbstractItemView
operator|::
name|setState
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|state
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Schedules a layout of the items in the view to be executed when the   event processing starts.    Even if scheduleDelayedItemsLayout() is called multiple times before   events are processed, the view will only do the layout once.    \sa executeDelayedItemsLayout() */
end_comment
begin_function
DECL|function|scheduleDelayedItemsLayout
name|void
name|QAbstractItemView
operator|::
name|scheduleDelayedItemsLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|doDelayedItemsLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Executes the scheduled layouts without waiting for the event processing   to begin.    \sa scheduleDelayedItemsLayout() */
end_comment
begin_function
DECL|function|executeDelayedItemsLayout
name|void
name|QAbstractItemView
operator|::
name|executeDelayedItemsLayout
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|executePostedLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Marks the given \a region as dirty and schedules it to be updated.     You only need to call this function if you are implementing     your own view subclass.      \sa scrollDirtyRegion(), dirtyRegionOffset() */
end_comment
begin_function
DECL|function|setDirtyRegion
name|void
name|QAbstractItemView
operator|::
name|setDirtyRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDirtyRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Prepares the view for scrolling by (\a{dx},\a{dy}) pixels by moving the dirty regions in the     opposite direction. You only need to call this function if you are implementing a scrolling     viewport in your view subclass.      If you implement scrollContentsBy() in a subclass of QAbstractItemView, call this function     before you call QWidget::scroll() on the viewport. Alternatively, just call update().      \sa scrollContentsBy(), dirtyRegionOffset(), setDirtyRegion() */
end_comment
begin_function
DECL|function|scrollDirtyRegion
name|void
name|QAbstractItemView
operator|::
name|scrollDirtyRegion
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|d
operator|->
name|scrollDirtyRegion
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset of the dirty regions in the view.      If you use scrollDirtyRegion() and implement a paintEvent() in a subclass of     QAbstractItemView, you should translate the area given by the paint event with     the offset returned from this function.      \sa scrollDirtyRegion(), setDirtyRegion() */
end_comment
begin_function
DECL|function|dirtyRegionOffset
name|QPoint
name|QAbstractItemView
operator|::
name|dirtyRegionOffset
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|scrollDelayOffset
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|startAutoScroll
name|void
name|QAbstractItemView
operator|::
name|startAutoScroll
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|startAutoScroll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|stopAutoScroll
name|void
name|QAbstractItemView
operator|::
name|stopAutoScroll
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|stopAutoScroll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|doAutoScroll
name|void
name|QAbstractItemView
operator|::
name|doAutoScroll
parameter_list|()
block|{
comment|// find how much we should scroll with
name|Q_D
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QScrollBar
modifier|*
name|verticalScroll
init|=
name|verticalScrollBar
argument_list|()
decl_stmt|;
name|QScrollBar
modifier|*
name|horizontalScroll
init|=
name|horizontalScrollBar
argument_list|()
decl_stmt|;
comment|// QHeaderView does not (normally) have scrollbars
comment|// It needs to use its parents scroll instead
name|QHeaderView
modifier|*
name|hv
init|=
name|qobject_cast
argument_list|<
name|QHeaderView
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|hv
condition|)
block|{
name|QAbstractScrollArea
modifier|*
name|parent
init|=
name|qobject_cast
argument_list|<
name|QAbstractScrollArea
operator|*
argument_list|>
argument_list|(
name|parentWidget
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|hv
operator|->
name|orientation
argument_list|()
operator|==
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
operator|!
name|hv
operator|->
name|horizontalScrollBar
argument_list|()
operator|||
operator|!
name|hv
operator|->
name|horizontalScrollBar
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
name|horizontalScroll
operator|=
name|parent
operator|->
name|horizontalScrollBar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hv
operator|->
name|verticalScrollBar
argument_list|()
operator|||
operator|!
name|hv
operator|->
name|verticalScrollBar
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
name|verticalScroll
operator|=
name|parent
operator|->
name|verticalScrollBar
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|int
name|verticalStep
init|=
name|verticalScroll
operator|->
name|pageStep
argument_list|()
decl_stmt|;
name|int
name|horizontalStep
init|=
name|horizontalScroll
operator|->
name|pageStep
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|autoScrollCount
operator|<
name|qMax
argument_list|(
name|verticalStep
argument_list|,
name|horizontalStep
argument_list|)
condition|)
operator|++
name|d
operator|->
name|autoScrollCount
expr_stmt|;
name|int
name|margin
init|=
name|d
operator|->
name|autoScrollMargin
decl_stmt|;
name|int
name|verticalValue
init|=
name|verticalScroll
operator|->
name|value
argument_list|()
decl_stmt|;
name|int
name|horizontalValue
init|=
name|horizontalScroll
operator|->
name|value
argument_list|()
decl_stmt|;
name|QPoint
name|pos
init|=
name|d
operator|->
name|viewport
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|area
init|=
cast|static_cast
argument_list|<
name|QAbstractItemView
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|viewport
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|clipRect
argument_list|()
decl_stmt|;
comment|// access QWidget private by bending C++ rules
comment|// do the scrolling if we are in the scroll margins
if|if
condition|(
name|pos
operator|.
name|y
argument_list|()
operator|-
name|area
operator|.
name|top
argument_list|()
operator|<
name|margin
condition|)
name|verticalScroll
operator|->
name|setValue
argument_list|(
name|verticalValue
operator|-
name|d
operator|->
name|autoScrollCount
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|area
operator|.
name|bottom
argument_list|()
operator|-
name|pos
operator|.
name|y
argument_list|()
operator|<
name|margin
condition|)
name|verticalScroll
operator|->
name|setValue
argument_list|(
name|verticalValue
operator|+
name|d
operator|->
name|autoScrollCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|x
argument_list|()
operator|-
name|area
operator|.
name|left
argument_list|()
operator|<
name|margin
condition|)
name|horizontalScroll
operator|->
name|setValue
argument_list|(
name|horizontalValue
operator|-
name|d
operator|->
name|autoScrollCount
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|area
operator|.
name|right
argument_list|()
operator|-
name|pos
operator|.
name|x
argument_list|()
operator|<
name|margin
condition|)
name|horizontalScroll
operator|->
name|setValue
argument_list|(
name|horizontalValue
operator|+
name|d
operator|->
name|autoScrollCount
argument_list|)
expr_stmt|;
comment|// if nothing changed, stop scrolling
name|bool
name|verticalUnchanged
init|=
operator|(
name|verticalValue
operator|==
name|verticalScroll
operator|->
name|value
argument_list|()
operator|)
decl_stmt|;
name|bool
name|horizontalUnchanged
init|=
operator|(
name|horizontalValue
operator|==
name|horizontalScroll
operator|->
name|value
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|verticalUnchanged
operator|&&
name|horizontalUnchanged
condition|)
block|{
name|stopAutoScroll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|d
operator|->
name|dropIndicatorRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|d
operator|->
name|dropIndicatorPosition
operator|=
name|QAbstractItemView
operator|::
name|OnViewport
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the SelectionFlags to be used when updating a selection with     to include the \a index specified. The \a event is a user input event,     such as a mouse or keyboard event.      Reimplement this function to define your own selection behavior.      \sa setSelection() */
end_comment
begin_function
DECL|function|selectionCommand
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|QAbstractItemView
operator|::
name|selectionCommand
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|KeyboardModifiers
name|keyModifiers
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
if|if
condition|(
name|event
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|keyModifiers
operator|=
operator|(
cast|static_cast
argument_list|<
specifier|const
name|QInputEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|)
operator|->
name|modifiers
argument_list|()
expr_stmt|;
break|break;
default|default:
name|keyModifiers
operator|=
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|d
operator|->
name|selectionMode
condition|)
block|{
case|case
name|NoSelection
case|:
comment|// Never update selection model
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
case|case
name|SingleSelection
case|:
comment|// ClearAndSelect on valid index otherwise NoUpdate
if|if
condition|(
name|event
operator|&&
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
if|if
condition|(
operator|(
name|keyModifiers
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
operator|&&
name|d
operator|->
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Deselect
operator||
name|d
operator|->
name|selectionBehaviorFlags
argument_list|()
return|;
else|else
return|return
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|d
operator|->
name|selectionBehaviorFlags
argument_list|()
return|;
case|case
name|MultiSelection
case|:
return|return
name|d
operator|->
name|multiSelectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
return|;
case|case
name|ExtendedSelection
case|:
return|return
name|d
operator|->
name|extendedSelectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
return|;
case|case
name|ContiguousSelection
case|:
return|return
name|d
operator|->
name|contiguousSelectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
return|;
block|}
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
block|}
end_function
begin_function
DECL|function|multiSelectionCommand
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|QAbstractItemViewPrivate
operator|::
name|multiSelectionCommand
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|index
argument_list|)
if|if
condition|(
name|event
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|KeyPress
case|:
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Space
operator|||
cast|static_cast
argument_list|<
specifier|const
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Select
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
comment|// toggle
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
comment|// finalize
break|break;
case|case
name|QEvent
operator|::
name|MouseMove
case|:
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
condition|)
return|return
name|QItemSelectionModel
operator|::
name|ToggleCurrent
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
comment|// toggle drag select
default|default:
break|break;
block|}
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
block|}
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|extendedSelectionCommand
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|QAbstractItemViewPrivate
operator|::
name|extendedSelectionCommand
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
init|=
name|QApplication
operator|::
name|keyboardModifiers
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseMove
case|:
block|{
comment|// Toggle on MouseMove
name|modifiers
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|modifiers
argument_list|()
expr_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
return|return
name|QItemSelectionModel
operator|::
name|ToggleCurrent
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
block|{
name|modifiers
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|modifiers
argument_list|()
expr_stmt|;
specifier|const
name|Qt
operator|::
name|MouseButton
name|button
init|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|button
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|rightButtonPressed
init|=
name|button
operator|&
name|Qt
operator|::
name|RightButton
decl_stmt|;
specifier|const
name|bool
name|shiftKeyPressed
init|=
name|modifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
decl_stmt|;
specifier|const
name|bool
name|controlKeyPressed
init|=
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
decl_stmt|;
specifier|const
name|bool
name|indexIsSelected
init|=
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|shiftKeyPressed
operator|||
name|controlKeyPressed
operator|)
operator|&&
name|rightButtonPressed
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
if|if
condition|(
operator|!
name|shiftKeyPressed
operator|&&
operator|!
name|controlKeyPressed
operator|&&
name|indexIsSelected
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|rightButtonPressed
operator|&&
operator|!
name|shiftKeyPressed
operator|&&
operator|!
name|controlKeyPressed
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Clear
return|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
block|{
comment|// ClearAndSelect on MouseButtonRelease if MouseButtonPress on selected item or empty area
name|modifiers
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|modifiers
argument_list|()
expr_stmt|;
specifier|const
name|Qt
operator|::
name|MouseButton
name|button
init|=
cast|static_cast
argument_list|<
specifier|const
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|button
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|rightButtonPressed
init|=
name|button
operator|&
name|Qt
operator|::
name|RightButton
decl_stmt|;
specifier|const
name|bool
name|shiftKeyPressed
init|=
name|modifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
decl_stmt|;
specifier|const
name|bool
name|controlKeyPressed
init|=
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|index
operator|==
name|pressedIndex
operator|&&
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
operator|)
operator|||
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|)
operator|&&
name|state
operator|!=
name|QAbstractItemView
operator|::
name|DragSelectingState
operator|&&
operator|!
name|shiftKeyPressed
operator|&&
operator|!
name|controlKeyPressed
operator|&&
operator|(
operator|!
name|rightButtonPressed
operator|||
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|)
condition|)
return|return
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
block|}
case|case
name|QEvent
operator|::
name|KeyPress
case|:
block|{
comment|// NoUpdate on Key movement and Ctrl
name|modifiers
operator|=
cast|static_cast
argument_list|<
specifier|const
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|modifiers
argument_list|()
expr_stmt|;
switch|switch
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_Backtab
case|:
name|modifiers
operator|=
name|modifiers
operator|&
operator|~
name|Qt
operator|::
name|ShiftModifier
expr_stmt|;
comment|// special case for backtab
case|case
name|Qt
operator|::
name|Key_Down
case|:
case|case
name|Qt
operator|::
name|Key_Up
case|:
case|case
name|Qt
operator|::
name|Key_Left
case|:
case|case
name|Qt
operator|::
name|Key_Right
case|:
case|case
name|Qt
operator|::
name|Key_Home
case|:
case|case
name|Qt
operator|::
name|Key_End
case|:
case|case
name|Qt
operator|::
name|Key_PageUp
case|:
case|case
name|Qt
operator|::
name|Key_PageDown
case|:
case|case
name|Qt
operator|::
name|Key_Tab
case|:
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
comment|// Preserve historical tab order navigation behavior
operator|||
name|QApplication
operator|::
name|navigationMode
argument_list|()
operator|==
name|Qt
operator|::
name|NavigationModeKeypadTabOrder
endif|#
directive|endif
condition|)
return|return
name|QItemSelectionModel
operator|::
name|NoUpdate
return|;
break|break;
case|case
name|Qt
operator|::
name|Key_Select
case|:
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
case|case
name|Qt
operator|::
name|Key_Space
case|:
comment|// Toggle on Ctrl-Qt::Key_Space, Select on Space
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
return|return
name|QItemSelectionModel
operator|::
name|Select
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
default|default:
break|break;
block|}
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ShiftModifier
condition|)
return|return
name|QItemSelectionModel
operator|::
name|SelectCurrent
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|ControlModifier
condition|)
return|return
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
if|if
condition|(
name|state
operator|==
name|QAbstractItemView
operator|::
name|DragSelectingState
condition|)
block|{
comment|//when drag-selecting we need to clear any previous selection and select the current one
return|return
name|QItemSelectionModel
operator|::
name|Clear
operator||
name|QItemSelectionModel
operator|::
name|SelectCurrent
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
block|}
return|return
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
block|}
end_function
begin_function
name|QItemSelectionModel
operator|::
name|SelectionFlags
DECL|function|contiguousSelectionCommand
name|QAbstractItemViewPrivate
operator|::
name|contiguousSelectionCommand
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|flags
init|=
name|extendedSelectionCommand
argument_list|(
name|index
argument_list|,
name|event
argument_list|)
decl_stmt|;
specifier|const
name|int
name|Mask
init|=
name|QItemSelectionModel
operator|::
name|Clear
operator||
name|QItemSelectionModel
operator|::
name|Select
operator||
name|QItemSelectionModel
operator|::
name|Deselect
operator||
name|QItemSelectionModel
operator|::
name|Toggle
operator||
name|QItemSelectionModel
operator|::
name|Current
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|Mask
condition|)
block|{
case|case
name|QItemSelectionModel
operator|::
name|Clear
case|:
case|case
name|QItemSelectionModel
operator|::
name|ClearAndSelect
case|:
case|case
name|QItemSelectionModel
operator|::
name|SelectCurrent
case|:
return|return
name|flags
return|;
case|case
name|QItemSelectionModel
operator|::
name|NoUpdate
case|:
if|if
condition|(
name|event
operator|&&
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
operator|)
condition|)
return|return
name|flags
return|;
return|return
name|QItemSelectionModel
operator|::
name|ClearAndSelect
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
default|default:
return|return
name|QItemSelectionModel
operator|::
name|SelectCurrent
operator||
name|selectionBehaviorFlags
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|fetchMore
name|void
name|QAbstractItemViewPrivate
operator|::
name|fetchMore
parameter_list|()
block|{
name|fetchMoreTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|model
operator|->
name|canFetchMore
argument_list|(
name|root
argument_list|)
condition|)
return|return;
name|int
name|last
init|=
name|model
operator|->
name|rowCount
argument_list|(
name|root
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
block|{
name|model
operator|->
name|fetchMore
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return;
block|}
name|QModelIndex
name|index
init|=
name|model
operator|->
name|index
argument_list|(
name|last
argument_list|,
literal|0
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QRect
name|rect
init|=
name|q_func
argument_list|()
operator|->
name|visualRect
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewport
operator|->
name|rect
argument_list|()
operator|.
name|intersects
argument_list|(
name|rect
argument_list|)
condition|)
name|model
operator|->
name|fetchMore
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|shouldEdit
name|bool
name|QAbstractItemViewPrivate
operator|::
name|shouldEdit
parameter_list|(
name|QAbstractItemView
operator|::
name|EditTrigger
name|trigger
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|Qt
operator|::
name|ItemFlags
name|flags
init|=
name|model
operator|->
name|flags
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEditable
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ItemIsEnabled
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|state
operator|==
name|QAbstractItemView
operator|::
name|EditingState
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|hasEditor
argument_list|(
name|index
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|trigger
operator|==
name|QAbstractItemView
operator|::
name|AllEditTriggers
condition|)
comment|// force editing
return|return
literal|true
return|;
if|if
condition|(
operator|(
name|trigger
operator|&
name|editTriggers
operator|)
operator|==
name|QAbstractItemView
operator|::
name|SelectedClicked
operator|&&
operator|!
name|selectionModel
operator|->
name|isSelected
argument_list|(
name|index
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|trigger
operator|&
name|editTriggers
operator|)
return|;
block|}
end_function
begin_function
DECL|function|shouldForwardEvent
name|bool
name|QAbstractItemViewPrivate
operator|::
name|shouldForwardEvent
parameter_list|(
name|QAbstractItemView
operator|::
name|EditTrigger
name|trigger
parameter_list|,
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|event
operator|||
operator|(
name|trigger
operator|&
name|editTriggers
operator|)
operator|!=
name|QAbstractItemView
operator|::
name|AnyKeyPressed
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
empty_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|shouldAutoScroll
name|bool
name|QAbstractItemViewPrivate
operator|::
name|shouldAutoScroll
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|autoScroll
condition|)
return|return
literal|false
return|;
name|QRect
name|area
init|=
cast|static_cast
argument_list|<
name|QAbstractItemView
operator|*
argument_list|>
argument_list|(
name|viewport
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|clipRect
argument_list|()
decl_stmt|;
comment|// access QWidget private by bending C++ rules
return|return
operator|(
name|pos
operator|.
name|y
argument_list|()
operator|-
name|area
operator|.
name|top
argument_list|()
operator|<
name|autoScrollMargin
operator|)
operator|||
operator|(
name|area
operator|.
name|bottom
argument_list|()
operator|-
name|pos
operator|.
name|y
argument_list|()
operator|<
name|autoScrollMargin
operator|)
operator|||
operator|(
name|pos
operator|.
name|x
argument_list|()
operator|-
name|area
operator|.
name|left
argument_list|()
operator|<
name|autoScrollMargin
operator|)
operator|||
operator|(
name|area
operator|.
name|right
argument_list|()
operator|-
name|pos
operator|.
name|x
argument_list|()
operator|<
name|autoScrollMargin
operator|)
return|;
block|}
end_function
begin_function
DECL|function|doDelayedItemsLayout
name|void
name|QAbstractItemViewPrivate
operator|::
name|doDelayedItemsLayout
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
if|if
condition|(
operator|!
name|delayedPendingLayout
condition|)
block|{
name|delayedPendingLayout
operator|=
literal|true
expr_stmt|;
name|delayedLayout
operator|.
name|start
argument_list|(
name|delay
argument_list|,
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|interruptDelayedItemsLayout
name|void
name|QAbstractItemViewPrivate
operator|::
name|interruptDelayedItemsLayout
parameter_list|()
specifier|const
block|{
name|delayedLayout
operator|.
name|stop
argument_list|()
expr_stmt|;
name|delayedPendingLayout
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|editor
name|QWidget
modifier|*
name|QAbstractItemViewPrivate
operator|::
name|editor
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QStyleOptionViewItem
modifier|&
name|options
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|editorForIndex
argument_list|(
name|index
argument_list|)
operator|.
name|widget
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|delegate
condition|)
return|return
literal|0
return|;
name|w
operator|=
name|delegate
operator|->
name|createEditor
argument_list|(
name|viewport
argument_list|,
name|options
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|installEventFilter
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|w
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|editorDestroyed
argument_list|(
name|QObject
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delegate
operator|->
name|updateEditorGeometry
argument_list|(
name|w
argument_list|,
name|options
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|delegate
operator|->
name|setEditorData
argument_list|(
name|w
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|addEditor
argument_list|(
name|index
argument_list|,
name|w
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|parent
argument_list|()
operator|==
name|viewport
condition|)
name|QWidget
operator|::
name|setTabOrder
argument_list|(
name|q
argument_list|,
name|w
argument_list|)
expr_stmt|;
comment|// Special cases for some editors containing QLineEdit
name|QWidget
modifier|*
name|focusWidget
init|=
name|w
decl_stmt|;
while|while
condition|(
name|QWidget
modifier|*
name|fp
init|=
name|focusWidget
operator|->
name|focusProxy
argument_list|()
condition|)
name|focusWidget
operator|=
name|fp
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LINEEDIT
if|if
condition|(
name|QLineEdit
modifier|*
name|le
init|=
name|qobject_cast
argument_list|<
name|QLineEdit
operator|*
argument_list|>
argument_list|(
name|focusWidget
argument_list|)
condition|)
name|le
operator|->
name|selectAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SPINBOX
if|if
condition|(
name|QSpinBox
modifier|*
name|sb
init|=
name|qobject_cast
argument_list|<
name|QSpinBox
operator|*
argument_list|>
argument_list|(
name|focusWidget
argument_list|)
condition|)
name|sb
operator|->
name|selectAll
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|QDoubleSpinBox
modifier|*
name|dsb
init|=
name|qobject_cast
argument_list|<
name|QDoubleSpinBox
operator|*
argument_list|>
argument_list|(
name|focusWidget
argument_list|)
condition|)
name|dsb
operator|->
name|selectAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|w
return|;
block|}
end_function
begin_function
DECL|function|updateEditorData
name|void
name|QAbstractItemViewPrivate
operator|::
name|updateEditorData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|tl
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|br
parameter_list|)
block|{
comment|// we are counting on having relatively few editors
specifier|const
name|bool
name|checkIndexes
init|=
name|tl
operator|.
name|isValid
argument_list|()
operator|&&
name|br
operator|.
name|isValid
argument_list|()
decl_stmt|;
specifier|const
name|QModelIndex
name|parent
init|=
name|tl
operator|.
name|parent
argument_list|()
decl_stmt|;
comment|// QTBUG-25370: We need to copy the indexEditorHash, because while we're
comment|// iterating over it, we are calling methods which can allow user code to
comment|// call a method on *this which can modify the member indexEditorHash.
specifier|const
name|QIndexEditorHash
name|indexEditorHashCopy
init|=
name|indexEditorHash
decl_stmt|;
name|QIndexEditorHash
operator|::
name|const_iterator
name|it
init|=
name|indexEditorHashCopy
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|indexEditorHashCopy
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QWidget
modifier|*
name|editor
init|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|widget
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|QModelIndex
name|index
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|isStatic
operator|||
operator|!
name|editor
operator|||
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|(
name|checkIndexes
operator|&&
operator|(
name|index
operator|.
name|row
argument_list|()
operator|<
name|tl
operator|.
name|row
argument_list|()
operator|||
name|index
operator|.
name|row
argument_list|()
operator|>
name|br
operator|.
name|row
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|<
name|tl
operator|.
name|column
argument_list|()
operator|||
name|index
operator|.
name|column
argument_list|()
operator|>
name|br
operator|.
name|column
argument_list|()
operator|||
name|index
operator|.
name|parent
argument_list|()
operator|!=
name|parent
operator|)
operator|)
condition|)
continue|continue;
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|delegate
condition|)
block|{
name|delegate
operator|->
name|setEditorData
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      In DND if something has been moved then this is called.     Typically this means you should "remove" the selected item or row,     but the behavior is view dependant (table just clears the selected indexes for example).      Either remove the selected rows or clear them */
end_comment
begin_function
DECL|function|clearOrRemove
name|void
name|QAbstractItemViewPrivate
operator|::
name|clearOrRemove
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
specifier|const
name|QItemSelection
name|selection
init|=
name|selectionModel
operator|->
name|selection
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QItemSelectionRange
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|selection
operator|.
name|constBegin
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
for|for
control|(
init|;
name|it
operator|!=
name|selection
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QModelIndex
name|parent
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|left
argument_list|()
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|right
argument_list|()
operator|!=
operator|(
name|model
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|-
literal|1
operator|)
condition|)
continue|continue;
name|int
name|count
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|bottom
argument_list|()
operator|-
operator|(
operator|*
name|it
operator|)
operator|.
name|top
argument_list|()
operator|+
literal|1
decl_stmt|;
name|model
operator|->
name|removeRows
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|top
argument_list|()
argument_list|,
name|count
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we can't remove the rows so reset the items (i.e. the view is like a table)
name|QModelIndexList
name|list
init|=
name|selection
operator|.
name|indexes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QModelIndex
name|index
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|roles
init|=
name|model
operator|->
name|itemData
argument_list|(
name|index
argument_list|)
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|roles
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|roles
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|it
operator|.
name|value
argument_list|()
operator|=
name|QVariant
argument_list|()
expr_stmt|;
name|model
operator|->
name|setItemData
argument_list|(
name|index
argument_list|,
name|roles
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      When persistent aeditor gets/loses focus, we need to check     and setcorrectly the current index. */
end_comment
begin_function
DECL|function|checkPersistentEditorFocus
name|void
name|QAbstractItemViewPrivate
operator|::
name|checkPersistentEditorFocus
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|widget
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|persistent
operator|.
name|contains
argument_list|(
name|widget
argument_list|)
condition|)
block|{
comment|//a persistent editor has gained the focus
name|QModelIndex
name|index
init|=
name|indexForEditor
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectionModel
operator|->
name|currentIndex
argument_list|()
operator|!=
name|index
condition|)
name|q
operator|->
name|setCurrentIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|editorForIndex
specifier|const
name|QEditorInfo
modifier|&
name|QAbstractItemViewPrivate
operator|::
name|editorForIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
specifier|static
name|QEditorInfo
name|nullInfo
decl_stmt|;
comment|// do not try to search to avoid slow implicit cast from QModelIndex to QPersistentModelIndex
if|if
condition|(
name|indexEditorHash
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|nullInfo
return|;
name|QIndexEditorHash
operator|::
name|const_iterator
name|it
init|=
name|indexEditorHash
operator|.
name|find
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|indexEditorHash
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullInfo
return|;
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|indexForEditor
name|QModelIndex
name|QAbstractItemViewPrivate
operator|::
name|indexForEditor
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|)
specifier|const
block|{
comment|// do not try to search to avoid slow implicit cast from QModelIndex to QPersistentModelIndex
if|if
condition|(
name|indexEditorHash
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
name|QEditorIndexHash
operator|::
name|const_iterator
name|it
init|=
name|editorIndexHash
operator|.
name|find
argument_list|(
name|editor
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|editorIndexHash
operator|.
name|end
argument_list|()
condition|)
return|return
name|QModelIndex
argument_list|()
return|;
return|return
name|it
operator|.
name|value
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|removeEditor
name|void
name|QAbstractItemViewPrivate
operator|::
name|removeEditor
parameter_list|(
name|QWidget
modifier|*
name|editor
parameter_list|)
block|{
name|QEditorIndexHash
operator|::
name|iterator
name|it
init|=
name|editorIndexHash
operator|.
name|find
argument_list|(
name|editor
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|editorIndexHash
operator|.
name|end
argument_list|()
condition|)
block|{
name|indexEditorHash
operator|.
name|remove
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|editorIndexHash
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|addEditor
name|void
name|QAbstractItemViewPrivate
operator|::
name|addEditor
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QWidget
modifier|*
name|editor
parameter_list|,
name|bool
name|isStatic
parameter_list|)
block|{
name|editorIndexHash
operator|.
name|insert
argument_list|(
name|editor
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|indexEditorHash
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|QEditorInfo
argument_list|(
name|editor
argument_list|,
name|isStatic
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendDelegateEvent
name|bool
name|QAbstractItemViewPrivate
operator|::
name|sendDelegateEvent
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndex
name|buddy
init|=
name|model
operator|->
name|buddy
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QStyleOptionViewItem
name|options
init|=
name|viewOptions
argument_list|()
decl_stmt|;
name|options
operator|.
name|rect
operator|=
name|q
operator|->
name|visualRect
argument_list|(
name|buddy
argument_list|)
expr_stmt|;
name|options
operator|.
name|state
operator||=
operator|(
name|buddy
operator|==
name|q
operator|->
name|currentIndex
argument_list|()
condition|?
name|QStyle
operator|::
name|State_HasFocus
else|:
name|QStyle
operator|::
name|State_None
operator|)
expr_stmt|;
name|QAbstractItemDelegate
modifier|*
name|delegate
init|=
name|delegateForIndex
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
operator|(
name|event
operator|&&
name|delegate
operator|&&
name|delegate
operator|->
name|editorEvent
argument_list|(
name|event
argument_list|,
name|model
argument_list|,
name|options
argument_list|,
name|buddy
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|openEditor
name|bool
name|QAbstractItemViewPrivate
operator|::
name|openEditor
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndex
name|buddy
init|=
name|model
operator|->
name|buddy
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|QStyleOptionViewItem
name|options
init|=
name|viewOptions
argument_list|()
decl_stmt|;
name|options
operator|.
name|rect
operator|=
name|q
operator|->
name|visualRect
argument_list|(
name|buddy
argument_list|)
expr_stmt|;
name|options
operator|.
name|state
operator||=
operator|(
name|buddy
operator|==
name|q
operator|->
name|currentIndex
argument_list|()
condition|?
name|QStyle
operator|::
name|State_HasFocus
else|:
name|QStyle
operator|::
name|State_None
operator|)
expr_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|editor
argument_list|(
name|buddy
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
literal|false
return|;
name|q
operator|->
name|setState
argument_list|(
name|QAbstractItemView
operator|::
name|EditingState
argument_list|)
expr_stmt|;
name|w
operator|->
name|show
argument_list|()
expr_stmt|;
name|w
operator|->
name|setFocus
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|w
operator|->
name|focusProxy
argument_list|()
condition|?
name|w
operator|->
name|focusProxy
argument_list|()
else|:
name|w
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     \internal      returns the pair QRect/QModelIndex that should be painted on the viewports's rect */
end_comment
begin_function
DECL|function|draggablePaintPairs
name|QItemViewPaintPairs
name|QAbstractItemViewPrivate
operator|::
name|draggablePaintPairs
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|indexes
parameter_list|,
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QRect
modifier|&
name|rect
init|=
operator|*
name|r
decl_stmt|;
specifier|const
name|QRect
name|viewportRect
init|=
name|viewport
operator|->
name|rect
argument_list|()
decl_stmt|;
name|QItemViewPaintPairs
name|ret
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexes
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QModelIndex
modifier|&
name|index
init|=
name|indexes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|current
init|=
name|q
operator|->
name|visualRect
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|intersects
argument_list|(
name|viewportRect
argument_list|)
condition|)
block|{
name|ret
operator|+=
name|qMakePair
argument_list|(
name|current
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|rect
operator||=
name|current
expr_stmt|;
block|}
block|}
name|rect
operator|&=
name|viewportRect
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|renderToPixmap
name|QPixmap
name|QAbstractItemViewPrivate
operator|::
name|renderToPixmap
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|indexes
parameter_list|,
name|QRect
modifier|*
name|r
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|QItemViewPaintPairs
name|paintPairs
init|=
name|draggablePaintPairs
argument_list|(
name|indexes
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|paintPairs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QPixmap
name|pixmap
argument_list|(
name|r
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|QPainter
name|painter
argument_list|(
operator|&
name|pixmap
argument_list|)
decl_stmt|;
name|QStyleOptionViewItem
name|option
init|=
name|viewOptions
argument_list|()
decl_stmt|;
name|option
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Selected
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|paintPairs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|option
operator|.
name|rect
operator|=
name|paintPairs
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|first
operator|.
name|translated
argument_list|(
operator|-
name|r
operator|->
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QModelIndex
modifier|&
name|current
init|=
name|paintPairs
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|second
decl_stmt|;
name|adjustViewOptionsForIndex
argument_list|(
operator|&
name|option
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|delegateForIndex
argument_list|(
name|current
argument_list|)
operator|->
name|paint
argument_list|(
operator|&
name|painter
argument_list|,
name|option
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
return|return
name|pixmap
return|;
block|}
end_function
begin_function
DECL|function|selectAll
name|void
name|QAbstractItemViewPrivate
operator|::
name|selectAll
parameter_list|(
name|QItemSelectionModel
operator|::
name|SelectionFlags
name|command
parameter_list|)
block|{
if|if
condition|(
operator|!
name|selectionModel
condition|)
return|return;
name|QItemSelection
name|selection
decl_stmt|;
name|QModelIndex
name|tl
init|=
name|model
operator|->
name|index
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|QModelIndex
name|br
init|=
name|model
operator|->
name|index
argument_list|(
name|model
operator|->
name|rowCount
argument_list|(
name|root
argument_list|)
operator|-
literal|1
argument_list|,
name|model
operator|->
name|columnCount
argument_list|(
name|root
argument_list|)
operator|-
literal|1
argument_list|,
name|root
argument_list|)
decl_stmt|;
name|selection
operator|.
name|append
argument_list|(
name|QItemSelectionRange
argument_list|(
name|tl
argument_list|,
name|br
argument_list|)
argument_list|)
expr_stmt|;
name|selectionModel
operator|->
name|select
argument_list|(
name|selection
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|selectedDraggableIndexes
name|QModelIndexList
name|QAbstractItemViewPrivate
operator|::
name|selectedDraggableIndexes
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QAbstractItemView
argument_list|)
expr_stmt|;
name|QModelIndexList
name|indexes
init|=
name|q
operator|->
name|selectedIndexes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|indexes
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isIndexDragEnabled
argument_list|(
name|indexes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|indexes
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|indexes
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qabstractitemview.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ITEMVIEWS
end_comment
end_unit
