begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// Uncomment the next line to enable the MIT Shared Memory extension
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// WARNING:  This has some problems:
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//    1. Consumes a 800x600 pixmap
end_comment
begin_comment
comment|//    2. Qt does not handle the ShmCompletion message, so you will
end_comment
begin_comment
comment|//        get strange effects if you xForm() repeatedly.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// #define QT_MITSHM
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
end_if
begin_undef
DECL|macro|QT_MITSHM
undef|#
directive|undef
name|QT_MITSHM
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qiodevice.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap_x11_p.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|"qx11info_x11.h"
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimage_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimagepixmapcleanuphooks_p.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
end_if
begin_define
DECL|macro|for
define|#
directive|define
name|for
value|if(0){}else for
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_toX11Pixmap
name|QPixmap
name|qt_toX11Pixmap
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QPixmapData
modifier|*
name|data
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|?
name|QPixmapData
operator|::
name|BitmapType
else|:
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_toX11Pixmap
name|QPixmap
name|qt_toX11Pixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
if|if
condition|(
name|QPixmap
argument_list|(
name|pixmap
argument_list|)
operator|.
name|data_ptr
argument_list|()
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
return|return
name|pixmap
return|;
return|return
name|qt_toX11Pixmap
argument_list|(
name|pixmap
operator|.
name|toImage
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// For thread-safety:
end_comment
begin_comment
comment|//   image->data does not belong to X11, so we must free it ourselves.
end_comment
begin_function
DECL|function|qSafeXDestroyImage
specifier|inline
specifier|static
name|void
name|qSafeXDestroyImage
parameter_list|(
name|XImage
modifier|*
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|x
operator|->
name|data
argument_list|)
expr_stmt|;
name|x
operator|->
name|data
operator|=
literal|0
expr_stmt|;
block|}
name|XDestroyImage
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mask_to_bitmap
name|QBitmap
name|QX11PixmapData
operator|::
name|mask_to_bitmap
parameter_list|(
name|int
name|screen
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|x11_mask
condition|)
return|return
name|QBitmap
argument_list|()
return|;
name|QPixmap
operator|::
name|x11SetDefaultScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|QBitmap
name|bm
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|bm
operator|.
name|handle
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|,
name|bm
operator|.
name|handle
argument_list|()
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|bm
operator|.
name|data
operator|->
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
return|return
name|bm
return|;
block|}
end_function
begin_function
DECL|function|bitmap_to_mask
name|Qt
operator|::
name|HANDLE
name|QX11PixmapData
operator|::
name|bitmap_to_mask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|bitmap
parameter_list|,
name|int
name|screen
parameter_list|)
block|{
if|if
condition|(
name|bitmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|QBitmap
name|bm
init|=
name|bitmap
decl_stmt|;
name|bm
operator|.
name|x11SetScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|Pixmap
name|mask
init|=
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
argument_list|,
name|bm
operator|.
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|bm
operator|.
name|data
operator|->
name|height
argument_list|()
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|bm
operator|.
name|handle
argument_list|()
argument_list|,
name|mask
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bm
operator|.
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|bm
operator|.
name|data
operator|->
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   MIT Shared Memory Extension support: makes xForm noticeably (~20%) faster.  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
end_if
begin_decl_stmt
DECL|variable|xshminit
specifier|static
name|bool
name|xshminit
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xshminfo
specifier|static
name|XShmSegmentInfo
name|xshminfo
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xshmimg
specifier|static
name|XImage
modifier|*
name|xshmimg
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xshmpm
specifier|static
name|Pixmap
name|xshmpm
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_cleanup_mitshm
specifier|static
name|void
name|qt_cleanup_mitshm
parameter_list|()
block|{
if|if
condition|(
name|xshmimg
operator|==
literal|0
condition|)
return|return;
name|Display
modifier|*
name|dpy
init|=
name|QX11Info
operator|::
name|appDisplay
argument_list|()
decl_stmt|;
if|if
condition|(
name|xshmpm
condition|)
block|{
name|XFreePixmap
argument_list|(
name|dpy
argument_list|,
name|xshmpm
argument_list|)
expr_stmt|;
name|xshmpm
operator|=
literal|0
expr_stmt|;
block|}
name|XShmDetach
argument_list|(
name|dpy
argument_list|,
operator|&
name|xshminfo
argument_list|)
expr_stmt|;
name|xshmimg
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|qSafeXDestroyImage
argument_list|(
name|xshmimg
argument_list|)
expr_stmt|;
name|xshmimg
operator|=
literal|0
expr_stmt|;
name|shmdt
argument_list|(
name|xshminfo
operator|.
name|shmaddr
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|xshminfo
operator|.
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_create_mitshm_buffer
specifier|static
name|bool
name|qt_create_mitshm_buffer
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|dev
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|static
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
specifier|static
name|Bool
name|pixmaps_ok
decl_stmt|;
name|Display
modifier|*
name|dpy
init|=
name|dev
operator|->
name|data
operator|->
name|xinfo
operator|->
name|display
argument_list|()
decl_stmt|;
name|int
name|dd
init|=
name|dev
operator|->
name|x11Depth
argument_list|()
decl_stmt|;
name|Visual
modifier|*
name|vis
init|=
operator|(
name|Visual
operator|*
operator|)
name|dev
operator|->
name|x11Visual
argument_list|()
decl_stmt|;
if|if
condition|(
name|xshminit
condition|)
block|{
name|qt_cleanup_mitshm
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|XShmQueryVersion
argument_list|(
name|dpy
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|pixmaps_ok
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// MIT Shm not supported
name|qAddPostRoutine
argument_list|(
name|qt_cleanup_mitshm
argument_list|)
expr_stmt|;
name|xshminit
operator|=
literal|true
expr_stmt|;
block|}
name|xshmimg
operator|=
name|XShmCreateImage
argument_list|(
name|dpy
argument_list|,
name|vis
argument_list|,
name|dd
argument_list|,
name|ZPixmap
argument_list|,
literal|0
argument_list|,
operator|&
name|xshminfo
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xshmimg
condition|)
return|return
literal|false
return|;
name|bool
name|ok
decl_stmt|;
name|xshminfo
operator|.
name|shmid
operator|=
name|shmget
argument_list|(
name|IPC_PRIVATE
argument_list|,
name|xshmimg
operator|->
name|bytes_per_line
operator|*
name|xshmimg
operator|->
name|height
argument_list|,
name|IPC_CREAT
operator||
literal|0777
argument_list|)
expr_stmt|;
name|ok
operator|=
name|xshminfo
operator|.
name|shmid
operator|!=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|xshmimg
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|shmat
argument_list|(
name|xshminfo
operator|.
name|shmid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xshminfo
operator|.
name|shmaddr
operator|=
name|xshmimg
operator|->
name|data
expr_stmt|;
name|ok
operator|=
operator|(
name|xshminfo
operator|.
name|shmaddr
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|xshminfo
operator|.
name|readOnly
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|ok
operator|=
name|XShmAttach
argument_list|(
name|dpy
argument_list|,
operator|&
name|xshminfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|qSafeXDestroyImage
argument_list|(
name|xshmimg
argument_list|)
expr_stmt|;
name|xshmimg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xshminfo
operator|.
name|shmaddr
condition|)
name|shmdt
argument_list|(
name|xshminfo
operator|.
name|shmaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|xshminfo
operator|.
name|shmid
operator|!=
operator|-
literal|1
condition|)
name|shmctl
argument_list|(
name|xshminfo
operator|.
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|pixmaps_ok
condition|)
name|xshmpm
operator|=
name|XShmCreatePixmap
argument_list|(
name|dpy
argument_list|,
name|DefaultRootWindow
argument_list|(
name|dpy
argument_list|)
argument_list|,
name|xshmimg
operator|->
name|data
argument_list|,
operator|&
name|xshminfo
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|dd
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// If extern, need a dummy.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// static bool qt_create_mitshm_buffer(QPaintDevice*, int, int)
end_comment
begin_comment
comment|// {
end_comment
begin_comment
comment|//     return false;
end_comment
begin_comment
comment|// }
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_MITSHM
end_comment
begin_comment
comment|/*****************************************************************************   Internal functions  *****************************************************************************/
end_comment
begin_function_decl
specifier|extern
specifier|const
name|uchar
modifier|*
name|qt_get_bitflip_array
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|// defined in qimage.cpp
end_comment
begin_comment
comment|// Returns position of highest bit set or -1 if none
end_comment
begin_function
DECL|function|highest_bit
specifier|static
name|int
name|highest_bit
parameter_list|(
name|uint
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint
name|b
init|=
operator|(
name|uint
operator|)
literal|1
operator|<<
literal|31
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|31
init|;
operator|(
operator|(
name|b
operator|&
name|v
operator|)
operator|==
literal|0
operator|)
operator|&&
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|b
operator|>>=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|// Returns position of lowest set bit in 'v' as an integer (0-31), or -1
end_comment
begin_function
DECL|function|lowest_bit
specifier|static
name|int
name|lowest_bit
parameter_list|(
name|uint
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ulong
name|lb
decl_stmt|;
name|lb
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|v
operator|&
name|lb
operator|)
operator|==
literal|0
operator|)
operator|&&
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|lb
operator|<<=
literal|1
control|)
block|{}
return|return
name|i
operator|==
literal|32
condition|?
operator|-
literal|1
else|:
name|i
return|;
block|}
end_function
begin_comment
comment|// Counts the number of bits set in 'v'
end_comment
begin_function
DECL|function|n_bits
specifier|static
name|uint
name|n_bits
parameter_list|(
name|uint
name|v
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|v
condition|)
block|{
name|v
operator|=
name|v
operator|&
operator|(
name|v
operator|-
literal|1
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|red_scale_table
specifier|static
name|uint
modifier|*
name|red_scale_table
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|green_scale_table
specifier|static
name|uint
modifier|*
name|green_scale_table
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blue_scale_table
specifier|static
name|uint
modifier|*
name|blue_scale_table
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cleanup_scale_tables
specifier|static
name|void
name|cleanup_scale_tables
parameter_list|()
block|{
operator|delete
index|[]
name|red_scale_table
expr_stmt|;
operator|delete
index|[]
name|green_scale_table
expr_stmt|;
operator|delete
index|[]
name|blue_scale_table
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Could do smart bitshifting, but the "obvious" algorithm only works for   nBits>= 4. This is more robust. */
end_comment
begin_function
DECL|function|build_scale_table
specifier|static
name|void
name|build_scale_table
parameter_list|(
name|uint
modifier|*
modifier|*
name|table
parameter_list|,
name|uint
name|nBits
parameter_list|)
block|{
if|if
condition|(
name|nBits
operator|>
literal|7
condition|)
block|{
name|qWarning
argument_list|(
literal|"build_scale_table: internal error, nBits = %i"
argument_list|,
name|nBits
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|table
condition|)
block|{
specifier|static
name|bool
name|firstTable
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|firstTable
condition|)
block|{
name|qAddPostRoutine
argument_list|(
name|cleanup_scale_tables
argument_list|)
expr_stmt|;
name|firstTable
operator|=
literal|false
expr_stmt|;
block|}
operator|*
name|table
operator|=
operator|new
name|uint
index|[
literal|256
index|]
expr_stmt|;
block|}
name|int
name|maxVal
init|=
operator|(
literal|1
operator|<<
name|nBits
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|valShift
init|=
literal|8
operator|-
name|nBits
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxVal
operator|+
literal|1
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|table
operator|)
index|[
name|i
operator|<<
name|valShift
index|]
operator|=
name|i
operator|*
literal|255
operator|/
name|maxVal
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|defaultScreen
specifier|static
name|int
name|defaultScreen
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*****************************************************************************   QPixmap member functions  *****************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|qt_pixmap_serial
name|QBasicAtomicInt
name|qt_pixmap_serial
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_x11_preferred_pixmap_depth
name|int
name|Q_GUI_EXPORT
name|qt_x11_preferred_pixmap_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QX11PixmapData
name|QX11PixmapData
operator|::
name|QX11PixmapData
parameter_list|(
name|PixelType
name|type
parameter_list|)
member_init_list|:
name|QPixmapData
argument_list|(
name|type
argument_list|,
name|X11Class
argument_list|)
member_init_list|,
name|gl_surface
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hd
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|flags
argument_list|(
name|Uninitialized
argument_list|)
member_init_list|,
name|x11_mask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|picture
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mask_picture
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hd2
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|share_mode
argument_list|(
name|QPixmap
operator|::
name|ImplicitlyShared
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|createCompatiblePixmapData
name|QPixmapData
modifier|*
name|QX11PixmapData
operator|::
name|createCompatiblePixmapData
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QX11PixmapData
argument_list|(
name|pixelType
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resize
name|void
name|QX11PixmapData
operator|::
name|resize
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|setSerialNumber
argument_list|(
name|qt_pixmap_serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|width
expr_stmt|;
name|h
operator|=
name|height
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|defaultScreen
operator|>=
literal|0
operator|&&
name|defaultScreen
operator|!=
name|xinfo
operator|.
name|screen
argument_list|()
condition|)
block|{
name|QX11InfoData
modifier|*
name|xd
init|=
name|xinfo
operator|.
name|getX11Data
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|xd
operator|->
name|screen
operator|=
name|defaultScreen
expr_stmt|;
name|xd
operator|->
name|depth
operator|=
name|QX11Info
operator|::
name|appDepth
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cells
operator|=
name|QX11Info
operator|::
name|appCells
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|colormap
operator|=
name|QX11Info
operator|::
name|appColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultColormap
operator|=
name|QX11Info
operator|::
name|appDefaultColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|visual
operator|=
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultVisual
operator|=
name|QX11Info
operator|::
name|appDefaultVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xinfo
operator|.
name|setX11Data
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
name|int
name|dd
init|=
name|xinfo
operator|.
name|depth
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_x11_preferred_pixmap_depth
condition|)
name|dd
operator|=
name|qt_x11_preferred_pixmap_depth
expr_stmt|;
name|bool
name|make_null
init|=
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
decl_stmt|;
comment|// create null pixmap
name|d
operator|=
operator|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|?
literal|1
else|:
name|dd
operator|)
expr_stmt|;
if|if
condition|(
name|make_null
operator|||
name|d
operator|==
literal|0
condition|)
block|{
name|w
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|is_null
operator|=
literal|true
expr_stmt|;
name|hd
operator|=
literal|0
expr_stmt|;
name|picture
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|make_null
condition|)
name|qWarning
argument_list|(
literal|"QPixmap: Invalid pixmap parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hd
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|XRenderPictFormat
modifier|*
name|format
init|=
name|d
operator|==
literal|1
condition|?
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
else|:
name|XRenderFindVisualFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
block|}
end_function
begin_struct
DECL|struct|QX11AlphaDetector
struct|struct
name|QX11AlphaDetector
block|{
DECL|function|hasAlpha
name|bool
name|hasAlpha
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|checked
condition|)
return|return
name|has
return|;
comment|// Will implicitly also check format and return quickly for opaque types...
name|checked
operator|=
literal|true
expr_stmt|;
name|has
operator|=
name|image
operator|->
name|isNull
argument_list|()
condition|?
literal|false
else|:
cast|const_cast
argument_list|<
name|QImage
operator|*
argument_list|>
argument_list|(
name|image
argument_list|)
operator|->
name|data_ptr
argument_list|()
operator|->
name|checkForAlphaPixels
argument_list|()
expr_stmt|;
return|return
name|has
return|;
block|}
DECL|function|hasXRenderAndAlpha
name|bool
name|hasXRenderAndAlpha
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|X11
operator|->
name|use_xrender
condition|)
return|return
literal|false
return|;
return|return
name|hasAlpha
argument_list|()
return|;
block|}
DECL|function|QX11AlphaDetector
name|QX11AlphaDetector
parameter_list|(
specifier|const
name|QImage
modifier|*
name|i
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|image
argument_list|(
name|i
argument_list|)
member_init_list|,
name|checked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has
argument_list|(
literal|false
argument_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|NoOpaqueDetection
condition|)
block|{
name|checked
operator|=
literal|true
expr_stmt|;
name|has
operator|=
name|image
operator|->
name|hasAlphaChannel
argument_list|()
expr_stmt|;
block|}
block|}
DECL|member|image
specifier|const
name|QImage
modifier|*
name|image
decl_stmt|;
DECL|member|checked
specifier|mutable
name|bool
name|checked
decl_stmt|;
DECL|member|has
specifier|mutable
name|bool
name|has
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|fromImage
name|void
name|QX11PixmapData
operator|::
name|fromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|setSerialNumber
argument_list|(
name|qt_pixmap_serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|img
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|img
operator|.
name|height
argument_list|()
expr_stmt|;
name|d
operator|=
name|img
operator|.
name|depth
argument_list|()
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_null
condition|)
block|{
name|w
operator|=
name|h
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|defaultScreen
operator|>=
literal|0
operator|&&
name|defaultScreen
operator|!=
name|xinfo
operator|.
name|screen
argument_list|()
condition|)
block|{
name|QX11InfoData
modifier|*
name|xd
init|=
name|xinfo
operator|.
name|getX11Data
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|xd
operator|->
name|screen
operator|=
name|defaultScreen
expr_stmt|;
name|xd
operator|->
name|depth
operator|=
name|QX11Info
operator|::
name|appDepth
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cells
operator|=
name|QX11Info
operator|::
name|appCells
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|colormap
operator|=
name|QX11Info
operator|::
name|appColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultColormap
operator|=
name|QX11Info
operator|::
name|appDefaultColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|visual
operator|=
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultVisual
operator|=
name|QX11Info
operator|::
name|appDefaultVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xinfo
operator|.
name|setX11Data
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|)
block|{
name|bitmapFromImage
argument_list|(
name|img
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uint
argument_list|(
name|w
argument_list|)
operator|>=
literal|32768
operator|||
name|uint
argument_list|(
name|h
argument_list|)
operator|>=
literal|32768
condition|)
block|{
name|w
operator|=
name|h
operator|=
literal|0
expr_stmt|;
name|is_null
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|QX11AlphaDetector
name|alphaCheck
argument_list|(
operator|&
name|img
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|int
name|dd
init|=
name|alphaCheck
operator|.
name|hasXRenderAndAlpha
argument_list|()
condition|?
literal|32
else|:
name|xinfo
operator|.
name|depth
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_x11_preferred_pixmap_depth
condition|)
name|dd
operator|=
name|qt_x11_preferred_pixmap_depth
expr_stmt|;
name|QImage
name|image
init|=
name|img
decl_stmt|;
comment|// must be monochrome
if|if
condition|(
name|dd
operator|==
literal|1
operator|||
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ColorMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|MonoOnly
condition|)
block|{
if|if
condition|(
name|d
operator|!=
literal|1
condition|)
block|{
comment|// dither
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// can be both
name|bool
name|conv8
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|8
operator|&&
name|dd
operator|<=
literal|8
condition|)
block|{
comment|// convert to 8 bit
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|AutoDither
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator||
name|Qt
operator|::
name|PreferDither
expr_stmt|;
name|conv8
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ColorMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|ColorOnly
condition|)
block|{
name|conv8
operator|=
operator|(
name|d
operator|==
literal|1
operator|)
expr_stmt|;
comment|// native depth wanted
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|QRgb
name|c0
init|=
name|image
operator|.
name|color
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Auto: convert to best
name|QRgb
name|c1
init|=
name|image
operator|.
name|color
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|conv8
operator|=
name|qMin
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|!=
name|qRgb
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|||
name|qMax
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|!=
name|qRgb
argument_list|(
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// eg. 1-color monochrome images (they do exist).
name|conv8
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conv8
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_Indexed8
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|d
operator|=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|==
literal|1
operator|||
name|d
operator|==
literal|16
operator|||
name|d
operator|==
literal|24
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fromImage
argument_list|(
name|image
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
return|return;
block|}
name|Display
modifier|*
name|dpy
init|=
name|X11
operator|->
name|display
decl_stmt|;
name|Visual
modifier|*
name|visual
init|=
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
decl_stmt|;
name|XImage
modifier|*
name|xi
init|=
literal|0
decl_stmt|;
name|bool
name|trucol
init|=
operator|(
name|visual
operator|->
name|c_class
operator|>=
name|TrueColor
operator|)
decl_stmt|;
name|int
name|nbytes
init|=
name|image
operator|.
name|byteCount
argument_list|()
decl_stmt|;
name|uchar
modifier|*
name|newbits
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|alphaCheck
operator|.
name|hasXRenderAndAlpha
argument_list|()
condition|)
block|{
specifier|const
name|QImage
modifier|&
name|cimage
init|=
name|image
decl_stmt|;
name|d
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|QX11Info
operator|::
name|appDepth
argument_list|()
operator|!=
name|d
condition|)
block|{
if|if
condition|(
name|xinfo
operator|.
name|x11data
condition|)
block|{
name|xinfo
operator|.
name|x11data
operator|->
name|depth
operator|=
name|d
expr_stmt|;
block|}
else|else
block|{
name|QX11InfoData
modifier|*
name|xd
init|=
name|xinfo
operator|.
name|getX11Data
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|xd
operator|->
name|screen
operator|=
name|QX11Info
operator|::
name|appScreen
argument_list|()
expr_stmt|;
name|xd
operator|->
name|depth
operator|=
name|d
expr_stmt|;
name|xd
operator|->
name|cells
operator|=
name|QX11Info
operator|::
name|appCells
argument_list|()
expr_stmt|;
name|xd
operator|->
name|colormap
operator|=
name|QX11Info
operator|::
name|appColormap
argument_list|()
expr_stmt|;
name|xd
operator|->
name|defaultColormap
operator|=
name|QX11Info
operator|::
name|appDefaultColormap
argument_list|()
expr_stmt|;
name|xd
operator|->
name|visual
operator|=
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|()
expr_stmt|;
name|xd
operator|->
name|defaultVisual
operator|=
name|QX11Info
operator|::
name|appDefaultVisual
argument_list|()
expr_stmt|;
name|xinfo
operator|.
name|setX11Data
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
block|}
name|hd
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardARGB32
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xi
operator|=
name|XCreateImage
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|d
argument_list|,
name|ZPixmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|newbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|xi
operator|->
name|bytes_per_line
operator|*
name|h
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|newbits
argument_list|)
expr_stmt|;
name|xi
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|newbits
expr_stmt|;
switch|switch
condition|(
name|cimage
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
block|{
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colorTable
init|=
name|cimage
operator|.
name|colorTable
argument_list|()
decl_stmt|;
name|uint
modifier|*
name|xidata
init|=
operator|(
name|uint
operator|*
operator|)
name|xi
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|p
init|=
name|cimage
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|QRgb
name|rgb
init|=
name|colorTable
index|[
name|p
index|[
name|x
index|]
index|]
decl_stmt|;
specifier|const
name|int
name|a
init|=
name|qAlpha
argument_list|(
name|rgb
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0xff
condition|)
operator|*
name|xidata
operator|=
name|rgb
expr_stmt|;
else|else
comment|// RENDER expects premultiplied alpha
operator|*
name|xidata
operator|=
name|qRgba
argument_list|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|++
name|xidata
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
block|{
name|uint
modifier|*
name|xidata
init|=
operator|(
name|uint
operator|*
operator|)
name|xi
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|cimage
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
operator|*
name|xidata
operator|++
operator|=
name|p
index|[
name|x
index|]
operator||
literal|0xff000000
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
block|{
name|uint
modifier|*
name|xidata
init|=
operator|(
name|uint
operator|*
operator|)
name|xi
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|cimage
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|QRgb
name|rgb
init|=
name|p
index|[
name|x
index|]
decl_stmt|;
specifier|const
name|int
name|a
init|=
name|qAlpha
argument_list|(
name|rgb
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0xff
condition|)
operator|*
name|xidata
operator|=
name|rgb
expr_stmt|;
else|else
comment|// RENDER expects premultiplied alpha
operator|*
name|xidata
operator|=
name|qRgba
argument_list|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
name|rgb
argument_list|)
operator|*
name|a
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|++
name|xidata
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
block|{
name|uint
modifier|*
name|xidata
init|=
operator|(
name|uint
operator|*
operator|)
name|xi
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|cimage
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|xidata
argument_list|,
name|p
argument_list|,
name|w
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
name|xidata
operator|+=
name|w
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xi
operator|->
name|byte_order
operator|==
name|MSBFirst
operator|)
operator|!=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|)
block|{
name|uint
modifier|*
name|xidata
init|=
operator|(
name|uint
operator|*
operator|)
name|xi
operator|->
name|data
decl_stmt|;
name|uint
modifier|*
name|xiend
init|=
name|xidata
operator|+
name|w
operator|*
name|h
decl_stmt|;
while|while
condition|(
name|xidata
operator|<
name|xiend
condition|)
block|{
operator|*
name|xidata
operator|=
operator|(
operator|*
name|xidata
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
name|xidata
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|*
name|xidata
operator|<<
literal|8
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|*
name|xidata
operator|<<
literal|24
operator|)
expr_stmt|;
operator|++
name|xidata
expr_stmt|;
block|}
block|}
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|dpy
argument_list|,
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XPutImage
argument_list|(
name|dpy
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|)
expr_stmt|;
name|qSafeXDestroyImage
argument_list|(
name|xi
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
if|if
condition|(
name|trucol
condition|)
block|{
comment|// truecolor display
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
specifier|const
name|QImage
modifier|&
name|cimage
init|=
name|image
decl_stmt|;
name|QRgb
name|pix
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel translation table
specifier|const
name|bool
name|d8
init|=
operator|(
name|d
operator|==
literal|8
operator|)
decl_stmt|;
specifier|const
name|uint
name|red_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|red_mask
decl_stmt|;
specifier|const
name|uint
name|green_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|green_mask
decl_stmt|;
specifier|const
name|uint
name|blue_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|blue_mask
decl_stmt|;
specifier|const
name|int
name|red_shift
init|=
name|highest_bit
argument_list|(
name|red_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|int
name|green_shift
init|=
name|highest_bit
argument_list|(
name|green_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|int
name|blue_shift
init|=
name|highest_bit
argument_list|(
name|blue_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|uint
name|rbits
init|=
name|highest_bit
argument_list|(
name|red_mask
argument_list|)
operator|-
name|lowest_bit
argument_list|(
name|red_mask
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|uint
name|gbits
init|=
name|highest_bit
argument_list|(
name|green_mask
argument_list|)
operator|-
name|lowest_bit
argument_list|(
name|green_mask
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|uint
name|bbits
init|=
name|highest_bit
argument_list|(
name|blue_mask
argument_list|)
operator|-
name|lowest_bit
argument_list|(
name|blue_mask
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|d8
condition|)
block|{
comment|// setup pixel translation
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|ctable
init|=
name|cimage
operator|.
name|colorTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cimage
operator|.
name|colorCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|qRed
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|g
init|=
name|qGreen
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|b
init|=
name|qBlue
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|r
operator|=
name|red_shift
operator|>
literal|0
condition|?
name|r
operator|<<
name|red_shift
else|:
name|r
operator|>>
operator|-
name|red_shift
expr_stmt|;
name|g
operator|=
name|green_shift
operator|>
literal|0
condition|?
name|g
operator|<<
name|green_shift
else|:
name|g
operator|>>
operator|-
name|green_shift
expr_stmt|;
name|b
operator|=
name|blue_shift
operator|>
literal|0
condition|?
name|b
operator|<<
name|blue_shift
else|:
name|b
operator|>>
operator|-
name|blue_shift
expr_stmt|;
name|pix
index|[
name|i
index|]
operator|=
operator|(
name|b
operator|&
name|blue_mask
operator|)
operator||
operator|(
name|g
operator|&
name|green_mask
operator|)
operator||
operator|(
name|r
operator|&
name|red_mask
operator|)
operator||
operator|~
operator|(
name|blue_mask
operator||
name|green_mask
operator||
name|red_mask
operator|)
expr_stmt|;
block|}
block|}
name|xi
operator|=
name|XCreateImage
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|dd
argument_list|,
name|ZPixmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|newbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|xi
operator|->
name|bytes_per_line
operator|*
name|h
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|newbits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newbits
condition|)
comment|// no memory
return|return;
name|int
name|bppc
init|=
name|xi
operator|->
name|bits_per_pixel
decl_stmt|;
name|bool
name|contig_bits
init|=
name|n_bits
argument_list|(
name|red_mask
argument_list|)
operator|==
name|rbits
operator|&&
name|n_bits
argument_list|(
name|green_mask
argument_list|)
operator|==
name|gbits
operator|&&
name|n_bits
argument_list|(
name|blue_mask
argument_list|)
operator|==
name|bbits
decl_stmt|;
name|bool
name|dither_tc
init|=
comment|// Want it?
operator|(
name|flags
operator|&
name|Qt
operator|::
name|Dither_Mask
operator|)
operator|!=
name|Qt
operator|::
name|ThresholdDither
operator|&&
operator|(
name|flags
operator|&
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator|!=
name|Qt
operator|::
name|AvoidDither
operator|&&
comment|// Need it?
name|bppc
operator|<
literal|24
operator|&&
operator|!
name|d8
operator|&&
comment|// Can do it? (Contiguous bits?)
name|contig_bits
decl_stmt|;
specifier|static
name|bool
name|init
init|=
literal|false
decl_stmt|;
specifier|static
name|int
name|D
index|[
literal|16
index|]
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|dither_tc
operator|&&
operator|!
name|init
condition|)
block|{
comment|// I also contributed this code to XV - WWA.
comment|/*               The dither matrix, D, is obtained with this formula:                D2 = [0 2]               [3 1]                 D2*n = [4*Dn       4*Dn+2*Un]               [4*Dn+3*Un  4*Dn+1*Un]             */
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|init
operator|=
literal|1
expr_stmt|;
comment|/* Set D2 */
name|D
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|D
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|D
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|D
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Expand using recursive definition given above */
for|for
control|(
name|n
operator|=
literal|2
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|*=
literal|2
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|D
index|[
name|i
index|]
index|[
name|j
index|]
operator|*=
literal|4
expr_stmt|;
name|D
index|[
name|i
operator|+
name|n
index|]
index|[
name|j
index|]
operator|=
name|D
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
literal|2
expr_stmt|;
name|D
index|[
name|i
index|]
index|[
name|j
operator|+
name|n
index|]
operator|=
name|D
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
literal|3
expr_stmt|;
name|D
index|[
name|i
operator|+
name|n
index|]
index|[
name|j
operator|+
name|n
index|]
operator|=
name|D
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|init
operator|=
literal|true
expr_stmt|;
block|}
enum|enum
block|{
name|BPP8
block|,
name|BPP16_565
block|,
name|BPP16_555
block|,
name|BPP16_MSB
block|,
name|BPP16_LSB
block|,
name|BPP24_888
block|,
name|BPP24_MSB
block|,
name|BPP24_LSB
block|,
name|BPP32_8888
block|,
name|BPP32_MSB
block|,
name|BPP32_LSB
block|}
name|mode
init|=
name|BPP8
enum|;
name|bool
name|same_msb_lsb
init|=
operator|(
name|xi
operator|->
name|byte_order
operator|==
name|MSBFirst
operator|)
operator|==
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
decl_stmt|;
if|if
condition|(
name|bppc
operator|==
literal|8
condition|)
comment|// 8 bit
name|mode
operator|=
name|BPP8
expr_stmt|;
elseif|else
if|if
condition|(
name|bppc
operator|==
literal|16
condition|)
block|{
comment|// 16 bit MSB/LSB
if|if
condition|(
name|red_shift
operator|==
literal|8
operator|&&
name|green_shift
operator|==
literal|3
operator|&&
name|blue_shift
operator|==
operator|-
literal|3
operator|&&
operator|!
name|d8
operator|&&
name|same_msb_lsb
condition|)
name|mode
operator|=
name|BPP16_565
expr_stmt|;
elseif|else
if|if
condition|(
name|red_shift
operator|==
literal|7
operator|&&
name|green_shift
operator|==
literal|2
operator|&&
name|blue_shift
operator|==
operator|-
literal|3
operator|&&
operator|!
name|d8
operator|&&
name|same_msb_lsb
condition|)
name|mode
operator|=
name|BPP16_555
expr_stmt|;
else|else
name|mode
operator|=
operator|(
name|xi
operator|->
name|byte_order
operator|==
name|LSBFirst
operator|)
condition|?
name|BPP16_LSB
else|:
name|BPP16_MSB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bppc
operator|==
literal|24
condition|)
block|{
comment|// 24 bit MSB/LSB
if|if
condition|(
name|red_shift
operator|==
literal|16
operator|&&
name|green_shift
operator|==
literal|8
operator|&&
name|blue_shift
operator|==
literal|0
operator|&&
operator|!
name|d8
operator|&&
name|same_msb_lsb
condition|)
name|mode
operator|=
name|BPP24_888
expr_stmt|;
else|else
name|mode
operator|=
operator|(
name|xi
operator|->
name|byte_order
operator|==
name|LSBFirst
operator|)
condition|?
name|BPP24_LSB
else|:
name|BPP24_MSB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bppc
operator|==
literal|32
condition|)
block|{
comment|// 32 bit MSB/LSB
if|if
condition|(
name|red_shift
operator|==
literal|16
operator|&&
name|green_shift
operator|==
literal|8
operator|&&
name|blue_shift
operator|==
literal|0
operator|&&
operator|!
name|d8
operator|&&
name|same_msb_lsb
condition|)
name|mode
operator|=
name|BPP32_8888
expr_stmt|;
else|else
name|mode
operator|=
operator|(
name|xi
operator|->
name|byte_order
operator|==
name|LSBFirst
operator|)
condition|?
name|BPP32_LSB
else|:
name|BPP32_MSB
expr_stmt|;
block|}
else|else
name|qFatal
argument_list|(
literal|"Logic error 3"
argument_list|)
expr_stmt|;
DECL|macro|GET_PIXEL
define|#
directive|define
name|GET_PIXEL
define|\
value|uint pixel;                                                     \         if (d8) pixel = pix[*src++];                                    \         else {                                                          \             int r = qRed  (*p);                                         \             int g = qGreen(*p);                                         \             int b = qBlue (*p++);                                       \             r = red_shift> 0                                         \                 ? r<< red_shift   : r>> -red_shift;                   \             g = green_shift> 0                                         \                 ? g<< green_shift : g>> -green_shift;                 \             b = blue_shift> 0                                         \                 ? b<< blue_shift  : b>> -blue_shift;                  \             pixel = (r& red_mask)|(g& green_mask) | (b& blue_mask)   \                     | ~(blue_mask | green_mask | red_mask);             \         }
DECL|macro|GET_PIXEL_DITHER_TC
define|#
directive|define
name|GET_PIXEL_DITHER_TC
define|\
value|int r = qRed  (*p);                                             \         int g = qGreen(*p);                                             \         int b = qBlue (*p++);                                           \         const int thres = D[x%16][y%16];                                \         if (r<= (255-(1<<(8-rbits)))&& ((r<<rbits)& 255)             \> thres)                                                    \             r += (1<<(8-rbits));                                        \         if (g<= (255-(1<<(8-gbits)))&& ((g<<gbits)& 255)             \> thres)                                                    \             g += (1<<(8-gbits));                                        \         if (b<= (255-(1<<(8-bbits)))&& ((b<<bbits)& 255)             \> thres)                                                    \             b += (1<<(8-bbits));                                        \         r = red_shift> 0                                             \             ? r<< red_shift   : r>> -red_shift;                       \         g = green_shift> 0                                             \             ? g<< green_shift : g>> -green_shift;                     \         b = blue_shift> 0                                             \             ? b<< blue_shift  : b>> -blue_shift;                      \         uint pixel = (r& red_mask)|(g& green_mask) | (b& blue_mask);
comment|// again, optimized case
comment|// can't be optimized that much :(
DECL|macro|GET_PIXEL_DITHER_TC_OPT
define|#
directive|define
name|GET_PIXEL_DITHER_TC_OPT
parameter_list|(
name|red_shift
parameter_list|,
name|green_shift
parameter_list|,
name|blue_shift
parameter_list|,
name|red_mask
parameter_list|,
name|green_mask
parameter_list|,
name|blue_mask
parameter_list|, \
name|rbits
parameter_list|,
name|gbits
parameter_list|,
name|bbits
parameter_list|)
define|\
value|const int thres = D[x%16][y%16];                                \         int r = qRed  (*p);                                             \         if (r<= (255-(1<<(8-rbits)))&& ((r<<rbits)& 255)             \> thres)                                                    \             r += (1<<(8-rbits));                                        \         int g = qGreen(*p);                                             \         if (g<= (255-(1<<(8-gbits)))&& ((g<<gbits)& 255)             \> thres)                                                    \             g += (1<<(8-gbits));                                        \         int b = qBlue (*p++);                                           \         if (b<= (255-(1<<(8-bbits)))&& ((b<<bbits)& 255)             \> thres)                                                    \             b += (1<<(8-bbits));                                        \         uint pixel = ((r red_shift)& red_mask)                         \                      | ((g green_shift)& green_mask)                   \                      | ((b blue_shift)& blue_mask);
DECL|macro|CYCLE
define|#
directive|define
name|CYCLE
parameter_list|(
name|body
parameter_list|)
define|\
value|for (int y=0; y<h; y++) {                               \             const uchar* src = cimage.scanLine(y);              \             uchar* dst = newbits + xi->bytes_per_line*y;        \             const QRgb* p = (const QRgb *)src;                  \             body                                                \                 }
if|if
condition|(
name|dither_tc
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|BPP16_565
case|:
name|CYCLE
argument_list|(
argument|quint16* dst16 = (quint16*)dst;                     for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL_DITHER_TC_OPT(<<
literal|8
argument|,<<
literal|3
argument|,>>
literal|3
argument|,
literal|0xf800
argument|,
literal|0x7e0
argument|,
literal|0x1f
argument|,
literal|5
argument|,
literal|6
argument|,
literal|5
argument|)                             *dst16++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP16_555
case|:
name|CYCLE
argument_list|(
argument|quint16* dst16 = (quint16*)dst;                     for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL_DITHER_TC_OPT(<<
literal|7
argument|,<<
literal|2
argument|,>>
literal|3
argument|,
literal|0x7c00
argument|,
literal|0x3e0
argument|,
literal|0x1f
argument|,
literal|5
argument|,
literal|5
argument|,
literal|5
argument|)                             *dst16++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP16_MSB
case|:
comment|// 16 bit MSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL_DITHER_TC                             *dst++ = (pixel>>
literal|8
argument|);                         *dst++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP16_LSB
case|:
comment|// 16 bit LSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL_DITHER_TC                             *dst++ = pixel;                         *dst++ = pixel>>
literal|8
argument|;                     }
argument_list|)
break|break;
default|default:
name|qFatal
argument_list|(
literal|"Logic error"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|BPP8
case|:
comment|// 8 bit
name|CYCLE
argument_list|(
argument|Q_UNUSED(p);                     for (int x=
literal|0
argument|; x<w; x++)                         *dst++ = pix[*src++];
argument_list|)
break|break;
case|case
name|BPP16_565
case|:
name|CYCLE
argument_list|(
argument|quint16* dst16 = (quint16*)dst;                     for (int x =
literal|0
argument|; x< w; x++) {                         *dst16++ = ((*p>>
literal|8
argument|)&
literal|0xf800
argument|)                                    | ((*p>>
literal|5
argument|)&
literal|0x7e0
argument|)                                    | ((*p>>
literal|3
argument|)&
literal|0x1f
argument|);                         ++p;                     }
argument_list|)
break|break;
case|case
name|BPP16_555
case|:
name|CYCLE
argument_list|(
argument|quint16* dst16 = (quint16*)dst;                     for (int x=
literal|0
argument|; x<w; x++) {                         *dst16++ = ((*p>>
literal|9
argument|)&
literal|0x7c00
argument|)                                    | ((*p>>
literal|6
argument|)&
literal|0x3e0
argument|)                                    | ((*p>>
literal|3
argument|)&
literal|0x1f
argument|);                         ++p;                     }
argument_list|)
break|break;
case|case
name|BPP16_MSB
case|:
comment|// 16 bit MSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = (pixel>>
literal|8
argument|);                         *dst++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP16_LSB
case|:
comment|// 16 bit LSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = pixel;                         *dst++ = pixel>>
literal|8
argument|;                     }
argument_list|)
break|break;
case|case
name|BPP24_888
case|:
comment|// 24 bit MSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         *dst++ = qRed  (*p);                         *dst++ = qGreen(*p);                         *dst++ = qBlue (*p++);                     }
argument_list|)
break|break;
case|case
name|BPP24_MSB
case|:
comment|// 24 bit MSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = pixel>>
literal|16
argument|;                         *dst++ = pixel>>
literal|8
argument|;                         *dst++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP24_LSB
case|:
comment|// 24 bit LSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = pixel;                         *dst++ = pixel>>
literal|8
argument|;                         *dst++ = pixel>>
literal|16
argument|;                     }
argument_list|)
break|break;
case|case
name|BPP32_8888
case|:
name|CYCLE
argument_list|(
argument|memcpy(dst, p, w *
literal|4
argument|);
argument_list|)
break|break;
case|case
name|BPP32_MSB
case|:
comment|// 32 bit MSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = pixel>>
literal|24
argument|;                         *dst++ = pixel>>
literal|16
argument|;                         *dst++ = pixel>>
literal|8
argument|;                         *dst++ = pixel;                     }
argument_list|)
break|break;
case|case
name|BPP32_LSB
case|:
comment|// 32 bit LSB
name|CYCLE
argument_list|(
argument|for (int x=
literal|0
argument|; x<w; x++) {                         GET_PIXEL                             *dst++ = pixel;                         *dst++ = pixel>>
literal|8
argument|;                         *dst++ = pixel>>
literal|16
argument|;                         *dst++ = pixel>>
literal|24
argument|;                     }
argument_list|)
break|break;
default|default:
name|qFatal
argument_list|(
literal|"Logic error 2"
argument_list|)
expr_stmt|;
block|}
block|}
name|xi
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|newbits
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|8
operator|&&
operator|!
name|trucol
condition|)
block|{
comment|// 8 bit pixmap
name|int
name|pop
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel popularity
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|==
literal|0
condition|)
name|image
operator|.
name|setColorCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QImage
modifier|&
name|cimage
init|=
name|image
decl_stmt|;
name|memset
argument_list|(
name|pop
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|256
argument_list|)
expr_stmt|;
comment|// reset popularity array
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
comment|// for each scanline...
specifier|const
name|uchar
modifier|*
name|p
init|=
name|cimage
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
comment|// compute popularity
name|pop
index|[
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
block|}
name|newbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|// copy image into newbits
name|Q_CHECK_PTR
argument_list|(
name|newbits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newbits
condition|)
comment|// no memory
return|return;
name|uchar
modifier|*
name|p
init|=
name|newbits
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|cimage
operator|.
name|bits
argument_list|()
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|// copy image data into newbits
comment|/*          * The code below picks the most important colors. It is based on the          * diversity algorithm, implemented in XV 3.10. XV is (C) by John Bradley.          */
struct|struct
name|PIX
block|{
comment|// pixel sort element
name|uchar
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|,
name|n
decl_stmt|;
comment|// color + pad
name|int
name|use
decl_stmt|;
comment|// popularity
name|int
name|index
decl_stmt|;
comment|// index in colormap
name|int
name|mindist
decl_stmt|;
block|}
struct|;
name|int
name|ncols
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cimage
operator|.
name|colorCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// compute number of colors
if|if
condition|(
name|pop
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|ncols
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|cimage
operator|.
name|colorCount
argument_list|()
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|// ignore out-of-range pixels
name|pop
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|// works since we make sure above to have at least
comment|// one color in the image
if|if
condition|(
name|ncols
operator|==
literal|0
condition|)
name|ncols
operator|=
literal|1
expr_stmt|;
name|PIX
name|pixarr
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel array
name|PIX
name|pixarr_sorted
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel array (sorted)
name|memset
argument_list|(
name|pixarr
argument_list|,
literal|0
argument_list|,
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|PIX
argument_list|)
argument_list|)
expr_stmt|;
name|PIX
modifier|*
name|px
init|=
operator|&
name|pixarr
index|[
literal|0
index|]
decl_stmt|;
name|int
name|maxpop
init|=
literal|0
decl_stmt|;
name|int
name|maxpix
init|=
literal|0
decl_stmt|;
name|uint
name|j
init|=
literal|0
decl_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|ctable
init|=
name|cimage
operator|.
name|colorTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
comment|// init pixel array
if|if
condition|(
name|pop
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|px
operator|->
name|r
operator|=
name|qRed
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|px
operator|->
name|g
operator|=
name|qGreen
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|px
operator|->
name|b
operator|=
name|qBlue
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|px
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|px
operator|->
name|use
operator|=
name|pop
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pop
index|[
name|i
index|]
operator|>
name|maxpop
condition|)
block|{
comment|// select most popular entry
name|maxpop
operator|=
name|pop
index|[
name|i
index|]
expr_stmt|;
name|maxpix
operator|=
name|j
expr_stmt|;
block|}
name|px
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|px
operator|->
name|mindist
operator|=
literal|1000000
expr_stmt|;
name|px
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|pixarr_sorted
index|[
literal|0
index|]
operator|=
name|pixarr
index|[
name|maxpix
index|]
expr_stmt|;
name|pixarr
index|[
name|maxpix
index|]
operator|.
name|use
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
comment|// sort pixels
name|int
name|minpix
init|=
operator|-
literal|1
decl_stmt|,
name|mindist
init|=
operator|-
literal|1
decl_stmt|;
name|px
operator|=
operator|&
name|pixarr_sorted
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|int
name|r
init|=
name|px
operator|->
name|r
decl_stmt|;
name|int
name|g
init|=
name|px
operator|->
name|g
decl_stmt|;
name|int
name|b
init|=
name|px
operator|->
name|b
decl_stmt|;
name|int
name|dist
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|||
name|i
operator|<
literal|10
condition|)
block|{
comment|// sort on max distance
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ncols
condition|;
name|j
operator|++
control|)
block|{
name|px
operator|=
operator|&
name|pixarr
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|use
condition|)
block|{
name|dist
operator|=
operator|(
name|px
operator|->
name|r
operator|-
name|r
operator|)
operator|*
operator|(
name|px
operator|->
name|r
operator|-
name|r
operator|)
operator|+
operator|(
name|px
operator|->
name|g
operator|-
name|g
operator|)
operator|*
operator|(
name|px
operator|->
name|g
operator|-
name|g
operator|)
operator|+
operator|(
name|px
operator|->
name|b
operator|-
name|b
operator|)
operator|*
operator|(
name|px
operator|->
name|b
operator|-
name|b
operator|)
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|mindist
operator|>
name|dist
condition|)
name|px
operator|->
name|mindist
operator|=
name|dist
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|mindist
operator|>
name|mindist
condition|)
block|{
name|mindist
operator|=
name|px
operator|->
name|mindist
expr_stmt|;
name|minpix
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// sort on max popularity
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ncols
condition|;
name|j
operator|++
control|)
block|{
name|px
operator|=
operator|&
name|pixarr
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|use
condition|)
block|{
name|dist
operator|=
operator|(
name|px
operator|->
name|r
operator|-
name|r
operator|)
operator|*
operator|(
name|px
operator|->
name|r
operator|-
name|r
operator|)
operator|+
operator|(
name|px
operator|->
name|g
operator|-
name|g
operator|)
operator|*
operator|(
name|px
operator|->
name|g
operator|-
name|g
operator|)
operator|+
operator|(
name|px
operator|->
name|b
operator|-
name|b
operator|)
operator|*
operator|(
name|px
operator|->
name|b
operator|-
name|b
operator|)
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|mindist
operator|>
name|dist
condition|)
name|px
operator|->
name|mindist
operator|=
name|dist
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|use
operator|>
name|mindist
condition|)
block|{
name|mindist
operator|=
name|px
operator|->
name|use
expr_stmt|;
name|minpix
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
block|}
name|pixarr_sorted
index|[
name|i
index|]
operator|=
name|pixarr
index|[
name|minpix
index|]
expr_stmt|;
name|pixarr
index|[
name|minpix
index|]
operator|.
name|use
operator|=
literal|0
expr_stmt|;
block|}
name|QColormap
name|cmap
init|=
name|QColormap
operator|::
name|instance
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
decl_stmt|;
name|uint
name|pix
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel translation table
name|px
operator|=
operator|&
name|pixarr_sorted
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate colors
name|QColor
name|c
argument_list|(
name|px
operator|->
name|r
argument_list|,
name|px
operator|->
name|g
argument_list|,
name|px
operator|->
name|b
argument_list|)
decl_stmt|;
name|pix
index|[
name|px
operator|->
name|index
index|]
operator|=
name|cmap
operator|.
name|pixel
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|px
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|newbits
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
comment|// translate pixels
operator|*
name|p
operator|=
name|pix
index|[
operator|*
name|p
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|xi
condition|)
block|{
comment|// X image not created
name|xi
operator|=
name|XCreateImage
argument_list|(
name|dpy
argument_list|,
name|visual
argument_list|,
name|dd
argument_list|,
name|ZPixmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xi
operator|->
name|bits_per_pixel
operator|==
literal|16
condition|)
block|{
comment|// convert 8 bpp ==> 16 bpp
name|ushort
modifier|*
name|p2
decl_stmt|;
name|int
name|p2inc
init|=
name|xi
operator|->
name|bytes_per_line
operator|/
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|newerbits
init|=
operator|(
name|ushort
operator|*
operator|)
name|malloc
argument_list|(
name|xi
operator|->
name|bytes_per_line
operator|*
name|h
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|newerbits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newerbits
condition|)
comment|// no memory
return|return;
name|uchar
modifier|*
name|p
init|=
name|newbits
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
comment|// OOPS: Do right byte order!!
name|p2
operator|=
name|newerbits
operator|+
name|p2inc
operator|*
name|y
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|newbits
argument_list|)
expr_stmt|;
name|newbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|newerbits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xi
operator|->
name|bits_per_pixel
operator|!=
literal|8
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::fromImage: Display not supported "
literal|"(bpp=%d)"
argument_list|,
name|xi
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
block|}
name|xi
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|newbits
expr_stmt|;
block|}
name|hd
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|dd
argument_list|)
expr_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|dpy
argument_list|,
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XPutImage
argument_list|(
name|dpy
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|)
expr_stmt|;
name|qSafeXDestroyImage
argument_list|(
name|xi
argument_list|)
expr_stmt|;
name|d
operator|=
name|dd
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|XRenderPictFormat
modifier|*
name|format
init|=
name|d
operator|==
literal|1
condition|?
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
else|:
name|XRenderFindVisualFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|alphaCheck
operator|.
name|hasAlpha
argument_list|()
condition|)
block|{
name|QBitmap
name|m
init|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
operator|.
name|createAlphaMask
argument_list|(
name|flags
argument_list|)
argument_list|)
decl_stmt|;
name|setMask
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createBitmapFromImage
name|Qt
operator|::
name|HANDLE
name|QX11PixmapData
operator|::
name|createBitmapFromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QImage
name|img
init|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
specifier|const
name|QRgb
name|c0
init|=
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
operator|.
name|rgb
argument_list|()
decl_stmt|;
specifier|const
name|QRgb
name|c1
init|=
name|QColor
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
operator|.
name|rgb
argument_list|()
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|color
argument_list|(
literal|0
argument_list|)
operator|==
name|c0
operator|&&
name|img
operator|.
name|color
argument_list|(
literal|1
argument_list|)
operator|==
name|c1
condition|)
block|{
name|img
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|img
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|img
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|c0
argument_list|)
expr_stmt|;
block|}
name|char
modifier|*
name|bits
decl_stmt|;
name|uchar
modifier|*
name|tmp_bits
decl_stmt|;
name|int
name|w
init|=
name|img
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|img
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|bpl
init|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|ibpl
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|bpl
operator|!=
name|ibpl
condition|)
block|{
name|tmp_bits
operator|=
operator|new
name|uchar
index|[
name|bpl
operator|*
name|h
index|]
expr_stmt|;
name|bits
operator|=
operator|(
name|char
operator|*
operator|)
name|tmp_bits
expr_stmt|;
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|y
decl_stmt|;
name|b
operator|=
name|tmp_bits
expr_stmt|;
name|p
operator|=
name|img
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
name|b
operator|+=
name|bpl
expr_stmt|;
name|p
operator|+=
name|ibpl
expr_stmt|;
block|}
block|}
else|else
block|{
name|bits
operator|=
operator|(
name|char
operator|*
operator|)
name|img
operator|.
name|bits
argument_list|()
expr_stmt|;
name|tmp_bits
operator|=
literal|0
expr_stmt|;
block|}
name|Qt
operator|::
name|HANDLE
name|hd
init|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreateBitmapFromData
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|QX11Info
operator|::
name|appRootWindow
argument_list|()
argument_list|,
name|bits
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_bits
condition|)
comment|// Avoid purify complaint
operator|delete
index|[]
name|tmp_bits
expr_stmt|;
return|return
name|hd
return|;
block|}
end_function
begin_function
DECL|function|bitmapFromImage
name|void
name|QX11PixmapData
operator|::
name|bitmapFromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|w
operator|=
name|image
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|image
operator|.
name|height
argument_list|()
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
name|hd
operator|=
name|createBitmapFromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_XRENDER
block|}
end_function
begin_function
DECL|function|fill
name|void
name|QX11PixmapData
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|fillColor
parameter_list|)
block|{
if|if
condition|(
name|fillColor
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
if|if
condition|(
operator|!
name|picture
operator|||
name|d
operator|!=
literal|32
condition|)
name|convertToARGB32
argument_list|(
comment|/*preserveContents = */
literal|false
argument_list|)
expr_stmt|;
operator|::
name|Picture
name|src
init|=
name|X11
operator|->
name|getSolidFill
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|,
name|fillColor
argument_list|)
decl_stmt|;
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpSrc
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|picture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|QImage
name|im
argument_list|(
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|im
operator|.
name|fill
argument_list|(
name|PREMUL
argument_list|(
name|fillColor
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|im
argument_list|,
name|Qt
operator|::
name|AutoColor
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|XSetForeground
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|,
name|qGray
argument_list|(
name|fillColor
operator|.
name|rgb
argument_list|()
argument_list|)
operator|>
literal|127
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X11
operator|->
name|use_xrender
operator|&&
name|d
operator|>=
literal|24
condition|)
block|{
name|XSetForeground
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|,
name|fillColor
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XSetForeground
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|,
name|QColormap
operator|::
name|instance
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
operator|.
name|pixel
argument_list|(
name|fillColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|XFillRectangle
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QX11PixmapData
name|QX11PixmapData
operator|::
name|~
name|QX11PixmapData
parameter_list|()
block|{
comment|// Cleanup hooks have to be called before the handles are freed
if|if
condition|(
name|is_cached
condition|)
block|{
name|QImagePixmapCleanupHooks
operator|::
name|executePixmapDataDestructionHooks
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|is_cached
operator|=
literal|false
expr_stmt|;
block|}
name|release
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|release
name|void
name|QX11PixmapData
operator|::
name|release
parameter_list|()
block|{
operator|delete
name|pengine
expr_stmt|;
name|pengine
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|X11
condition|)
block|{
comment|// At this point, the X server will already have freed our resources,
comment|// so there is nothing to do.
return|return;
block|}
if|if
condition|(
name|x11_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|mask_picture
condition|)
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask_picture
argument_list|)
expr_stmt|;
name|mask_picture
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|)
expr_stmt|;
name|x11_mask
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hd
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
condition|)
block|{
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|picture
argument_list|)
expr_stmt|;
name|picture
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
if|if
condition|(
name|hd2
condition|)
block|{
name|XFreePixmap
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|hd2
argument_list|)
expr_stmt|;
name|hd2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|Readonly
operator|)
condition|)
name|XFreePixmap
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|hd
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|alphaChannel
name|QPixmap
name|QX11PixmapData
operator|::
name|alphaChannel
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|QPixmap
name|pm
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|pm
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
expr_stmt|;
return|return
name|pm
return|;
block|}
name|QImage
name|im
argument_list|(
name|toImage
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|im
operator|.
name|alphaChannel
argument_list|()
argument_list|,
name|Qt
operator|::
name|OrderedDither
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAlphaChannel
name|void
name|QX11PixmapData
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|alpha
parameter_list|)
block|{
name|QImage
name|image
argument_list|(
name|toImage
argument_list|()
argument_list|)
decl_stmt|;
name|image
operator|.
name|setAlphaChannel
argument_list|(
name|alpha
operator|.
name|toImage
argument_list|()
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|image
argument_list|,
name|Qt
operator|::
name|OrderedDither
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mask
name|QBitmap
name|QX11PixmapData
operator|::
name|mask
parameter_list|()
specifier|const
block|{
name|QBitmap
name|mask
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
operator|&&
name|d
operator|==
literal|32
condition|)
block|{
comment|// #### slow - there must be a better way..
name|mask
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|toImage
argument_list|()
operator|.
name|createAlphaMask
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
name|QX11PixmapData
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|mask
operator|=
name|QPixmap
argument_list|(
name|that
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|mask_to_bitmap
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function
begin_comment
comment|/*!     Sets a mask bitmap.      The \a newmask bitmap defines the clip mask for this pixmap. Every     pixel in \a newmask corresponds to a pixel in this pixmap. Pixel     value 1 means opaque and pixel value 0 means transparent. The mask     must have the same size as this pixmap.      \warning Setting the mask on a pixmap will cause any alpha channel     data to be cleared. For example:     \snippet doc/src/snippets/image/image.cpp 2     Now, alpha and alphacopy are visually different.      Setting a null mask resets the mask.      The effect of this function is undefined when the pixmap is being     painted on.      \sa mask(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations}, QBitmap */
end_comment
begin_function
DECL|function|setMask
name|void
name|QX11PixmapData
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|newmask
parameter_list|)
block|{
if|if
condition|(
name|newmask
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// clear mask
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
operator|&&
name|d
operator|==
literal|32
condition|)
block|{
name|QX11PixmapData
name|newData
argument_list|(
name|pixelType
argument_list|()
argument_list|)
decl_stmt|;
name|newData
operator|.
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|newData
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
expr_stmt|;
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpOver
argument_list|,
name|picture
argument_list|,
literal|0
argument_list|,
name|newData
operator|.
name|picture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
operator|*
name|this
operator|=
name|newData
expr_stmt|;
comment|// the new QX11PixmapData object isn't referenced yet, so
comment|// ref it
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
comment|// the below is to make sure the QX11PixmapData destructor
comment|// doesn't delete our newly created render picture
name|newData
operator|.
name|hd
operator|=
literal|0
expr_stmt|;
name|newData
operator|.
name|x11_mask
operator|=
literal|0
expr_stmt|;
name|newData
operator|.
name|picture
operator|=
literal|0
expr_stmt|;
name|newData
operator|.
name|mask_picture
operator|=
literal|0
expr_stmt|;
name|newData
operator|.
name|hd2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|x11_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
condition|)
block|{
name|XRenderPictureAttributes
name|attrs
decl_stmt|;
name|attrs
operator|.
name|alpha_map
operator|=
literal|0
expr_stmt|;
name|XRenderChangePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|picture
argument_list|,
name|CPAlphaMap
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask_picture
condition|)
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask_picture
argument_list|)
expr_stmt|;
name|mask_picture
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|)
expr_stmt|;
name|x11_mask
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
operator|&&
name|d
operator|==
literal|32
condition|)
block|{
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpSrc
argument_list|,
name|picture
argument_list|,
name|newmask
operator|.
name|x11PictureHandle
argument_list|()
argument_list|,
name|picture
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|XGCValues
name|vals
decl_stmt|;
name|vals
operator|.
name|function
operator|=
name|GXand
expr_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|GCFunction
argument_list|,
operator|&
name|vals
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|newmask
operator|.
name|handle
argument_list|()
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ##### should or the masks together
if|if
condition|(
name|x11_mask
condition|)
block|{
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|mask_picture
condition|)
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask_picture
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|x11_mask
operator|=
name|QX11PixmapData
operator|::
name|bitmap_to_mask
argument_list|(
name|newmask
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|picture
condition|)
block|{
name|mask_picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|,
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XRenderPictureAttributes
name|attrs
decl_stmt|;
name|attrs
operator|.
name|alpha_map
operator|=
name|mask_picture
expr_stmt|;
name|XRenderChangePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|picture
argument_list|,
name|CPAlphaMap
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|metric
name|int
name|QX11PixmapData
operator|::
name|metric
parameter_list|(
name|QPaintDevice
operator|::
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|QPaintDevice
operator|::
name|PdmWidth
case|:
return|return
name|w
return|;
case|case
name|QPaintDevice
operator|::
name|PdmHeight
case|:
return|return
name|h
return|;
case|case
name|QPaintDevice
operator|::
name|PdmNumColors
case|:
return|return
literal|1
operator|<<
name|d
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDepth
case|:
return|return
name|d
return|;
case|case
name|QPaintDevice
operator|::
name|PdmWidthMM
case|:
block|{
specifier|const
name|int
name|screen
init|=
name|xinfo
operator|.
name|screen
argument_list|()
decl_stmt|;
specifier|const
name|int
name|mm
init|=
name|DisplayWidthMM
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
operator|*
name|w
operator|/
name|DisplayWidth
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
decl_stmt|;
return|return
name|mm
return|;
block|}
case|case
name|QPaintDevice
operator|::
name|PdmHeightMM
case|:
block|{
specifier|const
name|int
name|screen
init|=
name|xinfo
operator|.
name|screen
argument_list|()
decl_stmt|;
specifier|const
name|int
name|mm
init|=
operator|(
name|DisplayHeightMM
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
operator|*
name|h
operator|)
operator|/
name|DisplayHeight
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
decl_stmt|;
return|return
name|mm
return|;
block|}
case|case
name|QPaintDevice
operator|::
name|PdmDpiX
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiX
case|:
return|return
name|QX11Info
operator|::
name|appDpiX
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDpiY
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiY
case|:
return|return
name|QX11Info
operator|::
name|appDpiY
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
return|;
default|default:
name|qWarning
argument_list|(
literal|"QX11PixmapData::metric(): Invalid metric"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_struct
DECL|struct|QXImageWrapper
struct|struct
name|QXImageWrapper
block|{
DECL|member|xi
name|XImage
modifier|*
name|xi
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|canTakeQImageFromXImage
name|bool
name|QX11PixmapData
operator|::
name|canTakeQImageFromXImage
parameter_list|(
specifier|const
name|QXImageWrapper
modifier|&
name|xiWrapper
parameter_list|)
specifier|const
block|{
name|XImage
modifier|*
name|xi
init|=
name|xiWrapper
operator|.
name|xi
decl_stmt|;
comment|// ARGB32_Premultiplied
if|if
condition|(
name|picture
operator|&&
name|depth
argument_list|()
operator|==
literal|32
condition|)
return|return
literal|true
return|;
name|Visual
modifier|*
name|visual
init|=
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
decl_stmt|;
comment|// RGB32
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|24
operator|&&
name|xi
operator|->
name|bits_per_pixel
operator|==
literal|32
operator|&&
name|visual
operator|->
name|red_mask
operator|==
literal|0xff0000
operator|&&
name|visual
operator|->
name|green_mask
operator|==
literal|0xff00
operator|&&
name|visual
operator|->
name|blue_mask
operator|==
literal|0xff
condition|)
return|return
literal|true
return|;
comment|// RGB16
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|16
operator|&&
name|xi
operator|->
name|bits_per_pixel
operator|==
literal|16
operator|&&
name|visual
operator|->
name|red_mask
operator|==
literal|0xf800
operator|&&
name|visual
operator|->
name|green_mask
operator|==
literal|0x7e0
operator|&&
name|visual
operator|->
name|blue_mask
operator|==
literal|0x1f
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|takeQImageFromXImage
name|QImage
name|QX11PixmapData
operator|::
name|takeQImageFromXImage
parameter_list|(
specifier|const
name|QXImageWrapper
modifier|&
name|xiWrapper
parameter_list|)
specifier|const
block|{
name|XImage
modifier|*
name|xi
init|=
name|xiWrapper
operator|.
name|xi
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
decl_stmt|;
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|24
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
elseif|else
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|16
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
name|QImage
name|image
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|xi
operator|->
name|data
argument_list|,
name|xi
operator|->
name|width
argument_list|,
name|xi
operator|->
name|height
argument_list|,
name|xi
operator|->
name|bytes_per_line
argument_list|,
name|format
argument_list|)
decl_stmt|;
comment|// take ownership
name|image
operator|.
name|data_ptr
argument_list|()
operator|->
name|own_data
operator|=
literal|true
expr_stmt|;
name|xi
operator|->
name|data
operator|=
literal|0
expr_stmt|;
comment|// we may have to swap the byte order
if|if
condition|(
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|LittleEndian
operator|&&
name|xi
operator|->
name|byte_order
operator|==
name|MSBFirst
operator|)
operator|||
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|&&
name|xi
operator|->
name|byte_order
operator|==
name|LSBFirst
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|image
operator|.
name|height
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|16
condition|)
block|{
name|ushort
modifier|*
name|p
init|=
operator|(
name|ushort
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|end
init|=
name|p
operator|+
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// fix-up alpha channel
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
name|QRgb
modifier|*
name|p
init|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|.
name|bits
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|xi
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
operator|++
name|x
control|)
name|p
index|[
name|x
index|]
operator||=
literal|0xff000000
expr_stmt|;
name|p
operator|+=
name|xi
operator|->
name|bytes_per_line
operator|/
literal|4
expr_stmt|;
block|}
block|}
name|XDestroyImage
argument_list|(
name|xi
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_function
DECL|function|toImage
name|QImage
name|QX11PixmapData
operator|::
name|toImage
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QXImageWrapper
name|xiWrapper
decl_stmt|;
name|xiWrapper
operator|.
name|xi
operator|=
name|XGetImage
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|AllPlanes
argument_list|,
operator|(
name|depth
argument_list|()
operator|==
literal|1
operator|)
condition|?
name|XYPixmap
else|:
name|ZPixmap
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|xiWrapper
operator|.
name|xi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xiWrapper
operator|.
name|xi
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
operator|!
name|x11_mask
operator|&&
name|canTakeQImageFromXImage
argument_list|(
name|xiWrapper
argument_list|)
condition|)
return|return
name|takeQImageFromXImage
argument_list|(
name|xiWrapper
argument_list|)
return|;
name|QImage
name|image
init|=
name|toImage
argument_list|(
name|xiWrapper
argument_list|,
name|rect
argument_list|)
decl_stmt|;
name|qSafeXDestroyImage
argument_list|(
name|xiWrapper
operator|.
name|xi
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the pixmap to a QImage. Returns a null image if the     conversion fails.      If the pixmap has 1-bit depth, the returned image will also be 1     bit deep. If the pixmap has 2- to 8-bit depth, the returned image     has 8-bit depth. If the pixmap has greater than 8-bit depth, the     returned image has 32-bit depth.      Note that for the moment, alpha masks on monochrome images are     ignored.      \sa fromImage(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QX11PixmapData
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
return|return
name|toImage
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toImage
name|QImage
name|QX11PixmapData
operator|::
name|toImage
parameter_list|(
specifier|const
name|QXImageWrapper
modifier|&
name|xiWrapper
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|XImage
modifier|*
name|xi
init|=
name|xiWrapper
operator|.
name|xi
decl_stmt|;
name|int
name|d
init|=
name|depth
argument_list|()
decl_stmt|;
name|Visual
modifier|*
name|visual
init|=
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
decl_stmt|;
name|bool
name|trucol
init|=
operator|(
name|visual
operator|->
name|c_class
operator|>=
name|TrueColor
operator|)
operator|&&
name|d
operator|>
literal|1
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|QImage
operator|::
name|Format_Mono
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|1
operator|&&
name|d
operator|<=
literal|8
condition|)
block|{
name|d
operator|=
literal|8
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format_Indexed8
expr_stmt|;
block|}
comment|// we could run into the situation where d == 8 AND trucol is true, which can
comment|// cause problems when converting to and from images.  in this case, always treat
comment|// the depth as 32...
if|if
condition|(
name|d
operator|>
literal|8
operator|||
name|trucol
condition|)
block|{
name|d
operator|=
literal|32
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|1
operator|&&
name|xi
operator|->
name|bitmap_bit_order
operator|==
name|LSBFirst
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_MonoLSB
expr_stmt|;
if|if
condition|(
name|x11_mask
operator|&&
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32
expr_stmt|;
name|QImage
name|image
argument_list|(
name|xi
operator|->
name|width
argument_list|,
name|xi
operator|->
name|height
argument_list|,
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
comment|// could not create image
return|return
name|image
return|;
name|QImage
name|alpha
decl_stmt|;
if|if
condition|(
name|x11_mask
condition|)
block|{
if|if
condition|(
name|rect
operator|.
name|contains
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
condition|)
name|alpha
operator|=
name|mask
argument_list|()
operator|.
name|toImage
argument_list|()
expr_stmt|;
else|else
name|alpha
operator|=
name|mask
argument_list|()
operator|.
name|toImage
argument_list|()
operator|.
name|copy
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
name|bool
name|ale
init|=
name|alpha
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_MonoLSB
decl_stmt|;
if|if
condition|(
name|trucol
condition|)
block|{
comment|// truecolor
specifier|const
name|uint
name|red_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|red_mask
decl_stmt|;
specifier|const
name|uint
name|green_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|green_mask
decl_stmt|;
specifier|const
name|uint
name|blue_mask
init|=
operator|(
name|uint
operator|)
name|visual
operator|->
name|blue_mask
decl_stmt|;
specifier|const
name|int
name|red_shift
init|=
name|highest_bit
argument_list|(
name|red_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|int
name|green_shift
init|=
name|highest_bit
argument_list|(
name|green_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|int
name|blue_shift
init|=
name|highest_bit
argument_list|(
name|blue_mask
argument_list|)
operator|-
literal|7
decl_stmt|;
specifier|const
name|uint
name|red_bits
init|=
name|n_bits
argument_list|(
name|red_mask
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|green_bits
init|=
name|n_bits
argument_list|(
name|green_mask
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|blue_bits
init|=
name|n_bits
argument_list|(
name|blue_mask
argument_list|)
decl_stmt|;
specifier|static
name|uint
name|red_table_bits
init|=
literal|0
decl_stmt|;
specifier|static
name|uint
name|green_table_bits
init|=
literal|0
decl_stmt|;
specifier|static
name|uint
name|blue_table_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|red_bits
operator|<
literal|8
operator|&&
name|red_table_bits
operator|!=
name|red_bits
condition|)
block|{
name|build_scale_table
argument_list|(
operator|&
name|red_scale_table
argument_list|,
name|red_bits
argument_list|)
expr_stmt|;
name|red_table_bits
operator|=
name|red_bits
expr_stmt|;
block|}
if|if
condition|(
name|blue_bits
operator|<
literal|8
operator|&&
name|blue_table_bits
operator|!=
name|blue_bits
condition|)
block|{
name|build_scale_table
argument_list|(
operator|&
name|blue_scale_table
argument_list|,
name|blue_bits
argument_list|)
expr_stmt|;
name|blue_table_bits
operator|=
name|blue_bits
expr_stmt|;
block|}
if|if
condition|(
name|green_bits
operator|<
literal|8
operator|&&
name|green_table_bits
operator|!=
name|green_bits
condition|)
block|{
name|build_scale_table
argument_list|(
operator|&
name|green_scale_table
argument_list|,
name|green_bits
argument_list|)
expr_stmt|;
name|green_table_bits
operator|=
name|green_bits
expr_stmt|;
block|}
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|QRgb
modifier|*
name|dst
decl_stmt|;
name|uchar
modifier|*
name|src
decl_stmt|;
name|uint
name|pixel
decl_stmt|;
name|int
name|bppc
init|=
name|xi
operator|->
name|bits_per_pixel
decl_stmt|;
if|if
condition|(
name|bppc
operator|>
literal|8
operator|&&
name|xi
operator|->
name|byte_order
operator|==
name|LSBFirst
condition|)
name|bppc
operator|++
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|xi
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
name|uchar
modifier|*
name|asrc
init|=
name|x11_mask
condition|?
name|alpha
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
else|:
literal|0
decl_stmt|;
name|dst
operator|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|uchar
operator|*
operator|)
name|xi
operator|->
name|data
operator|+
name|xi
operator|->
name|bytes_per_line
operator|*
name|y
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
switch|switch
condition|(
name|bppc
condition|)
block|{
case|case
literal|8
case|:
name|pixel
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|// 16 bit MSB
name|pixel
operator|=
name|src
index|[
literal|1
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|0
index|]
operator|<<
literal|8
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|17
case|:
comment|// 16 bit LSB
name|pixel
operator|=
name|src
index|[
literal|0
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|// 24 bit MSB
name|pixel
operator|=
name|src
index|[
literal|2
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|0
index|]
operator|<<
literal|16
expr_stmt|;
name|src
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|// 24 bit LSB
name|pixel
operator|=
name|src
index|[
literal|0
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|src
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|// 32 bit MSB
name|pixel
operator|=
name|src
index|[
literal|3
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|2
index|]
operator|<<
literal|8
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|1
index|]
operator|<<
literal|16
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|src
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|33
case|:
comment|// 32 bit LSB
name|pixel
operator|=
name|src
index|[
literal|0
index|]
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|2
index|]
operator|<<
literal|16
operator||
operator|(
name|uint
operator|)
name|src
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|src
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
comment|// should not really happen
name|x
operator|=
name|xi
operator|->
name|width
expr_stmt|;
comment|// leave loop
name|y
operator|=
name|xi
operator|->
name|height
expr_stmt|;
name|pixel
operator|=
literal|0
expr_stmt|;
comment|// eliminate compiler warning
name|qWarning
argument_list|(
literal|"QPixmap::convertToImage: Invalid depth %d"
argument_list|,
name|bppc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|red_shift
operator|>
literal|0
condition|)
name|r
operator|=
operator|(
name|pixel
operator|&
name|red_mask
operator|)
operator|>>
name|red_shift
expr_stmt|;
else|else
name|r
operator|=
operator|(
name|pixel
operator|&
name|red_mask
operator|)
operator|<<
operator|-
name|red_shift
expr_stmt|;
if|if
condition|(
name|green_shift
operator|>
literal|0
condition|)
name|g
operator|=
operator|(
name|pixel
operator|&
name|green_mask
operator|)
operator|>>
name|green_shift
expr_stmt|;
else|else
name|g
operator|=
operator|(
name|pixel
operator|&
name|green_mask
operator|)
operator|<<
operator|-
name|green_shift
expr_stmt|;
if|if
condition|(
name|blue_shift
operator|>
literal|0
condition|)
name|b
operator|=
operator|(
name|pixel
operator|&
name|blue_mask
operator|)
operator|>>
name|blue_shift
expr_stmt|;
else|else
name|b
operator|=
operator|(
name|pixel
operator|&
name|blue_mask
operator|)
operator|<<
operator|-
name|blue_shift
expr_stmt|;
if|if
condition|(
name|red_bits
operator|<
literal|8
condition|)
name|r
operator|=
name|red_scale_table
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|green_bits
operator|<
literal|8
condition|)
name|g
operator|=
name|green_scale_table
index|[
name|g
index|]
expr_stmt|;
if|if
condition|(
name|blue_bits
operator|<
literal|8
condition|)
name|b
operator|=
name|blue_scale_table
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|x11_mask
condition|)
block|{
if|if
condition|(
name|ale
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
condition|?
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|0xff
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
condition|?
name|qRgba
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
literal|0xff
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
name|qRgb
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|xi
operator|->
name|bits_per_pixel
operator|==
name|d
condition|)
block|{
comment|// compatible depth
name|char
modifier|*
name|xidata
init|=
name|xi
operator|->
name|data
decl_stmt|;
comment|// copy each scanline
name|int
name|bpl
init|=
name|qMin
argument_list|(
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|xi
operator|->
name|bytes_per_line
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|xi
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|xidata
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
name|xidata
operator|+=
name|xi
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Typically 2 or 4 bits display depth */
name|qWarning
argument_list|(
literal|"QPixmap::convertToImage: Display not supported (bpp=%d)"
argument_list|,
name|xi
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
comment|// bitmap
name|image
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|qRgb
argument_list|(
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|qRgb
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|trucol
condition|)
block|{
comment|// pixmap with colormap
specifier|register
name|uchar
modifier|*
name|p
decl_stmt|;
name|uchar
modifier|*
name|end
decl_stmt|;
name|uchar
name|use
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel-in-use table
name|uchar
name|pix
index|[
literal|256
index|]
decl_stmt|;
comment|// pixel translation table
name|int
name|ncols
decl_stmt|,
name|bpl
decl_stmt|;
name|memset
argument_list|(
name|use
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pix
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|bpl
operator|=
name|image
operator|.
name|bytesPerLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|x11_mask
condition|)
block|{
comment|// which pixels are used?
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xi
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uchar
modifier|*
name|asrc
init|=
name|alpha
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|p
operator|=
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
condition|)
name|use
index|[
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
condition|)
name|use
index|[
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xi
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|bpl
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
name|use
index|[
operator|*
name|p
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ncols
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
comment|// build translation table
if|if
condition|(
name|use
index|[
name|i
index|]
condition|)
name|pix
index|[
name|i
index|]
operator|=
name|ncols
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xi
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
comment|// translate pixels
name|p
operator|=
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|bpl
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
name|pix
index|[
operator|*
name|p
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x11_mask
condition|)
block|{
name|int
name|trans
decl_stmt|;
if|if
condition|(
name|ncols
operator|<
literal|256
condition|)
block|{
name|trans
operator|=
name|ncols
operator|++
expr_stmt|;
name|image
operator|.
name|setColorCount
argument_list|(
name|ncols
argument_list|)
expr_stmt|;
comment|// create color table
name|image
operator|.
name|setColor
argument_list|(
name|trans
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|image
operator|.
name|setColorCount
argument_list|(
name|ncols
argument_list|)
expr_stmt|;
comment|// create color table
comment|// oh dear... no spare "transparent" pixel.
comment|// use first pixel in image (as good as any).
name|trans
operator|=
name|image
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xi
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uchar
modifier|*
name|asrc
init|=
name|alpha
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|p
operator|=
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ale
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
operator|*
name|p
operator|=
name|trans
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|xi
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|asrc
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
operator|*
name|p
operator|=
name|trans
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|image
operator|.
name|setColorCount
argument_list|(
name|ncols
argument_list|)
expr_stmt|;
comment|// create color table
block|}
name|QVector
argument_list|<
name|QColor
argument_list|>
name|colors
init|=
name|QColormap
operator|::
name|instance
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
operator|.
name|colormap
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colors
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// translate pixels
if|if
condition|(
name|use
index|[
name|i
index|]
condition|)
name|image
operator|.
name|setColor
argument_list|(
name|j
operator|++
argument_list|,
literal|0xff000000
operator||
name|colors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|rgb
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the pixmap that is transformed using the given     transformation \a matrix and transformation \a mode. The original     pixmap is not changed.      The transformation \a matrix is internally adjusted to compensate     for unwanted translation; i.e. the pixmap produced is the smallest     pixmap that contains all the transformed points of the original     pixmap. Use the trueMatrix() function to retrieve the actual     matrix used for transforming the pixmap.      This function is slow because it involves transformation to a     QImage, non-trivial computations and a transformation back to a     QPixmap.      \sa trueMatrix(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QPixmap
name|QX11PixmapData
operator|::
name|transformed
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
operator|||
name|transform
operator|.
name|type
argument_list|()
operator|>=
name|QTransform
operator|::
name|TxProject
condition|)
block|{
name|QImage
name|image
init|=
name|toImage
argument_list|()
decl_stmt|;
return|return
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
operator|.
name|transformed
argument_list|(
name|transform
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
name|uint
name|w
init|=
literal|0
decl_stmt|;
name|uint
name|h
init|=
literal|0
decl_stmt|;
comment|// size of target pixmap
name|uint
name|ws
decl_stmt|,
name|hs
decl_stmt|;
comment|// size of source pixmap
name|uchar
modifier|*
name|dptr
decl_stmt|;
comment|// data in target pixmap
name|uint
name|dbpl
decl_stmt|,
name|dbytes
decl_stmt|;
comment|// bytes per line/bytes total
name|uchar
modifier|*
name|sptr
decl_stmt|;
comment|// data in original pixmap
name|int
name|sbpl
decl_stmt|;
comment|// bytes per line in original
name|int
name|bpp
decl_stmt|;
comment|// bits per pixel
name|bool
name|depth1
init|=
name|depth
argument_list|()
operator|==
literal|1
decl_stmt|;
name|Display
modifier|*
name|dpy
init|=
name|X11
operator|->
name|display
decl_stmt|;
name|ws
operator|=
name|width
argument_list|()
expr_stmt|;
name|hs
operator|=
name|height
argument_list|()
expr_stmt|;
name|QTransform
name|mat
argument_list|(
name|transform
operator|.
name|m11
argument_list|()
argument_list|,
name|transform
operator|.
name|m12
argument_list|()
argument_list|,
name|transform
operator|.
name|m13
argument_list|()
argument_list|,
name|transform
operator|.
name|m21
argument_list|()
argument_list|,
name|transform
operator|.
name|m22
argument_list|()
argument_list|,
name|transform
operator|.
name|m23
argument_list|()
argument_list|,
literal|0.
argument_list|,
literal|0.
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bool
name|complex_xform
init|=
literal|false
decl_stmt|;
name|qreal
name|scaledWidth
decl_stmt|;
name|qreal
name|scaledHeight
decl_stmt|;
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
name|scaledHeight
operator|=
name|qAbs
argument_list|(
name|mat
operator|.
name|m22
argument_list|()
argument_list|)
operator|*
name|hs
operator|+
literal|0.9999
expr_stmt|;
name|scaledWidth
operator|=
name|qAbs
argument_list|(
name|mat
operator|.
name|m11
argument_list|()
argument_list|)
operator|*
name|ws
operator|+
literal|0.9999
expr_stmt|;
name|h
operator|=
name|qAbs
argument_list|(
name|int
argument_list|(
name|scaledHeight
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|qAbs
argument_list|(
name|int
argument_list|(
name|scaledWidth
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// rotation or shearing
name|QPolygonF
name|a
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|mat
operator|.
name|map
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|a
operator|.
name|boundingRect
argument_list|()
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|w
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
name|scaledWidth
operator|=
name|w
expr_stmt|;
name|scaledHeight
operator|=
name|h
expr_stmt|;
name|complex_xform
operator|=
literal|true
expr_stmt|;
block|}
name|mat
operator|=
name|QPixmap
operator|::
name|trueMatrix
argument_list|(
name|mat
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
expr_stmt|;
comment|// true matrix
name|bool
name|invertible
decl_stmt|;
name|mat
operator|=
name|mat
operator|.
name|inverted
argument_list|(
operator|&
name|invertible
argument_list|)
expr_stmt|;
comment|// invert matrix
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|w
operator|==
literal|0
operator|||
operator|!
name|invertible
operator|||
name|qAbs
argument_list|(
name|scaledWidth
argument_list|)
operator|>=
literal|32768
operator|||
name|qAbs
argument_list|(
name|scaledHeight
argument_list|)
operator|>=
literal|32768
condition|)
comment|// error, return null pixmap
return|return
name|QPixmap
argument_list|()
return|;
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
specifier|static
name|bool
name|try_once
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|try_once
condition|)
block|{
name|try_once
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|xshminit
condition|)
name|qt_create_mitshm_buffer
argument_list|(
name|this
argument_list|,
literal|800
argument_list|,
literal|600
argument_list|)
expr_stmt|;
block|}
name|bool
name|use_mitshm
init|=
name|xshmimg
operator|&&
operator|!
name|depth1
operator|&&
name|xshmimg
operator|->
name|width
operator|>=
name|w
operator|&&
name|xshmimg
operator|->
name|height
operator|>=
name|h
decl_stmt|;
endif|#
directive|endif
name|XImage
modifier|*
name|xi
init|=
name|XGetImage
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|handle
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|,
name|AllPlanes
argument_list|,
name|depth1
condition|?
name|XYPixmap
else|:
name|ZPixmap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xi
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|sbpl
operator|=
name|xi
operator|->
name|bytes_per_line
expr_stmt|;
name|sptr
operator|=
operator|(
name|uchar
operator|*
operator|)
name|xi
operator|->
name|data
expr_stmt|;
name|bpp
operator|=
name|xi
operator|->
name|bits_per_pixel
expr_stmt|;
if|if
condition|(
name|depth1
condition|)
name|dbpl
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
else|else
name|dbpl
operator|=
operator|(
operator|(
name|w
operator|*
name|bpp
operator|+
literal|31
operator|)
operator|/
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
name|dbytes
operator|=
name|dbpl
operator|*
name|h
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
if|if
condition|(
name|use_mitshm
condition|)
block|{
name|dptr
operator|=
operator|(
name|uchar
operator|*
operator|)
name|xshmimg
operator|->
name|data
expr_stmt|;
name|uchar
name|fillbyte
init|=
name|bpp
operator|==
literal|8
condition|?
name|white
operator|.
name|pixel
argument_list|()
else|:
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
name|memset
argument_list|(
name|dptr
operator|+
name|y
operator|*
name|xshmimg
operator|->
name|bytes_per_line
argument_list|,
name|fillbyte
argument_list|,
name|dbpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|dptr
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|dbytes
argument_list|)
expr_stmt|;
comment|// create buffer for bits
name|Q_CHECK_PTR
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth1
condition|)
comment|// fill with zeros
name|memset
argument_list|(
name|dptr
argument_list|,
literal|0
argument_list|,
name|dbytes
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bpp
operator|==
literal|8
condition|)
comment|// fill with background color
name|memset
argument_list|(
name|dptr
argument_list|,
name|WhitePixel
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|dbytes
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|dptr
argument_list|,
literal|0
argument_list|,
name|dbytes
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
block|}
endif|#
directive|endif
comment|// #define QT_DEBUG_XIMAGE
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG_XIMAGE
argument_list|)
name|qDebug
argument_list|(
literal|"----IMAGE--INFO--------------"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"width............. %d"
argument_list|,
name|xi
operator|->
name|width
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"height............ %d"
argument_list|,
name|xi
operator|->
name|height
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"xoffset........... %d"
argument_list|,
name|xi
operator|->
name|xoffset
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"format............ %d"
argument_list|,
name|xi
operator|->
name|format
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"byte order........ %d"
argument_list|,
name|xi
operator|->
name|byte_order
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"bitmap unit....... %d"
argument_list|,
name|xi
operator|->
name|bitmap_unit
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"bitmap bit order.. %d"
argument_list|,
name|xi
operator|->
name|bitmap_bit_order
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"depth............. %d"
argument_list|,
name|xi
operator|->
name|depth
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"bytes per line.... %d"
argument_list|,
name|xi
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"bits per pixel.... %d"
argument_list|,
name|xi
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|type
decl_stmt|;
if|if
condition|(
name|xi
operator|->
name|bitmap_bit_order
operator|==
name|MSBFirst
condition|)
name|type
operator|=
name|QT_XFORM_TYPE_MSBFIRST
expr_stmt|;
else|else
name|type
operator|=
name|QT_XFORM_TYPE_LSBFIRST
expr_stmt|;
name|int
name|xbpl
decl_stmt|,
name|p_inc
decl_stmt|;
if|if
condition|(
name|depth1
condition|)
block|{
name|xbpl
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|p_inc
operator|=
name|dbpl
operator|-
name|xbpl
expr_stmt|;
block|}
else|else
block|{
name|xbpl
operator|=
operator|(
name|w
operator|*
name|bpp
operator|)
operator|/
literal|8
expr_stmt|;
name|p_inc
operator|=
name|dbpl
operator|-
name|xbpl
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
if|if
condition|(
name|use_mitshm
condition|)
name|p_inc
operator|=
name|xshmimg
operator|->
name|bytes_per_line
operator|-
name|xbpl
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|qt_xForm_helper
argument_list|(
name|mat
argument_list|,
name|xi
operator|->
name|xoffset
argument_list|,
name|type
argument_list|,
name|bpp
argument_list|,
name|dptr
argument_list|,
name|xbpl
argument_list|,
name|p_inc
argument_list|,
name|h
argument_list|,
name|sptr
argument_list|,
name|sbpl
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::transform: display not supported (bpp=%d)"
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|QPixmap
name|pm
decl_stmt|;
return|return
name|pm
return|;
block|}
name|qSafeXDestroyImage
argument_list|(
name|xi
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth1
condition|)
block|{
comment|// mono bitmap
name|QBitmap
name|bm
init|=
name|QBitmap
operator|::
name|fromData
argument_list|(
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|dptr
argument_list|,
name|BitmapBitOrder
argument_list|(
name|X11
operator|->
name|display
argument_list|)
operator|==
name|MSBFirst
condition|?
name|QImage
operator|::
name|Format_Mono
else|:
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
return|return
name|bm
return|;
block|}
else|else
block|{
comment|// color pixmap
name|QX11PixmapData
modifier|*
name|x11Data
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|QPixmap
name|pm
argument_list|(
name|x11Data
argument_list|)
decl_stmt|;
name|x11Data
operator|->
name|flags
operator|&=
operator|~
name|QX11PixmapData
operator|::
name|Uninitialized
expr_stmt|;
name|x11Data
operator|->
name|xinfo
operator|=
name|xinfo
expr_stmt|;
name|x11Data
operator|->
name|d
operator|=
name|d
expr_stmt|;
name|x11Data
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|x11Data
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|x11Data
operator|->
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
name|x11Data
operator|->
name|hd
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|x11Data
operator|->
name|setSerialNumber
argument_list|(
name|qt_pixmap_serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|XRenderPictFormat
modifier|*
name|format
init|=
name|x11Data
operator|->
name|d
operator|==
literal|32
condition|?
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardARGB32
argument_list|)
else|:
name|XRenderFindVisualFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|x11Data
operator|->
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|x11Data
operator|->
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|hd
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_MITSHM
argument_list|)
if|if
condition|(
name|use_mitshm
condition|)
block|{
name|XCopyArea
argument_list|(
name|dpy
argument_list|,
name|xshmpm
argument_list|,
name|x11Data
operator|->
name|hd
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|xi
operator|=
name|XCreateImage
argument_list|(
name|dpy
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|x11Data
operator|->
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|,
name|x11Data
operator|->
name|d
argument_list|,
name|ZPixmap
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dptr
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPutImage
argument_list|(
name|dpy
argument_list|,
name|pm
operator|.
name|handle
argument_list|()
argument_list|,
name|gc
argument_list|,
name|xi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|qSafeXDestroyImage
argument_list|(
name|xi
argument_list|)
expr_stmt|;
block|}
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11_mask
condition|)
block|{
comment|// xform mask, too
name|pm
operator|.
name|setMask
argument_list|(
name|mask_to_bitmap
argument_list|(
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
operator|.
name|transformed
argument_list|(
name|transform
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|!=
literal|32
operator|&&
name|complex_xform
condition|)
block|{
comment|// need a mask!
name|QBitmap
name|mask
argument_list|(
name|ws
argument_list|,
name|hs
argument_list|)
decl_stmt|;
name|mask
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
expr_stmt|;
name|pm
operator|.
name|setMask
argument_list|(
name|mask
operator|.
name|transformed
argument_list|(
name|transform
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pm
return|;
block|}
block|}
end_function
begin_function
DECL|function|x11SetDefaultScreen
name|int
name|QPixmap
operator|::
name|x11SetDefaultScreen
parameter_list|(
name|int
name|screen
parameter_list|)
block|{
name|int
name|old
init|=
name|defaultScreen
decl_stmt|;
name|defaultScreen
operator|=
name|screen
expr_stmt|;
return|return
name|old
return|;
block|}
end_function
begin_function
DECL|function|x11SetScreen
name|void
name|QPixmap
operator|::
name|x11SetScreen
parameter_list|(
name|int
name|screen
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::x11SetScreen(): Cannot change screens during painting"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|data
operator|->
name|classId
argument_list|()
operator|!=
name|QPixmapData
operator|::
name|X11Class
condition|)
return|return;
if|if
condition|(
name|screen
operator|<
literal|0
condition|)
name|screen
operator|=
name|QX11Info
operator|::
name|appScreen
argument_list|()
expr_stmt|;
name|QX11PixmapData
modifier|*
name|x11Data
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|screen
operator|==
name|x11Data
operator|->
name|xinfo
operator|.
name|screen
argument_list|()
condition|)
return|return;
comment|// nothing to do
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|QX11InfoData
modifier|*
name|xd
init|=
name|x11Data
operator|->
name|xinfo
operator|.
name|getX11Data
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|xd
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
name|xd
operator|->
name|depth
operator|=
name|QX11Info
operator|::
name|appDepth
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cells
operator|=
name|QX11Info
operator|::
name|appCells
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|colormap
operator|=
name|QX11Info
operator|::
name|appColormap
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultColormap
operator|=
name|QX11Info
operator|::
name|appDefaultColormap
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|visual
operator|=
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultVisual
operator|=
name|QX11Info
operator|::
name|appDefaultVisual
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|x11Data
operator|->
name|xinfo
operator|.
name|setX11Data
argument_list|(
name|xd
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|qDebug("QPixmap::x11SetScreen for %p from %d to %d. Size is %d/%d", x11Data, x11Data->xinfo.screen(), screen, width(), height());
endif|#
directive|endif
name|x11SetDefaultScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
operator|*
name|this
operator|=
name|qt_toX11Pixmap
argument_list|(
name|toImage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grabWindow
name|QPixmap
name|QPixmap
operator|::
name|grabWindow
parameter_list|(
name|WId
name|window
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|Display
modifier|*
name|dpy
init|=
name|X11
operator|->
name|display
decl_stmt|;
name|XWindowAttributes
name|window_attr
decl_stmt|;
if|if
condition|(
operator|!
name|XGetWindowAttributes
argument_list|(
name|dpy
argument_list|,
name|window
argument_list|,
operator|&
name|window_attr
argument_list|)
condition|)
return|return
name|QPixmap
argument_list|()
return|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
name|window_attr
operator|.
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
name|window_attr
operator|.
name|height
operator|-
name|y
expr_stmt|;
comment|// determine the screen
name|int
name|scr
decl_stmt|;
for|for
control|(
name|scr
operator|=
literal|0
init|;
name|scr
operator|<
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
condition|;
operator|++
name|scr
control|)
block|{
if|if
condition|(
name|window_attr
operator|.
name|root
operator|==
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|scr
argument_list|)
condition|)
comment|// found it
break|break;
block|}
if|if
condition|(
name|scr
operator|>=
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
condition|)
comment|// sanity check
return|return
name|QPixmap
argument_list|()
return|;
comment|// get the depth of the root window
name|XWindowAttributes
name|root_attr
decl_stmt|;
if|if
condition|(
operator|!
name|XGetWindowAttributes
argument_list|(
name|dpy
argument_list|,
name|window_attr
operator|.
name|root
argument_list|,
operator|&
name|root_attr
argument_list|)
condition|)
return|return
name|QPixmap
argument_list|()
return|;
if|if
condition|(
name|window_attr
operator|.
name|depth
operator|==
name|root_attr
operator|.
name|depth
condition|)
block|{
comment|// if the depth of the specified window and the root window are the
comment|// same, grab pixels from the root window (so that we get the any
comment|// overlapping windows and window manager frames)
comment|// map x and y to the root window
name|WId
name|unused
decl_stmt|;
if|if
condition|(
operator|!
name|XTranslateCoordinates
argument_list|(
name|dpy
argument_list|,
name|window
argument_list|,
name|window_attr
operator|.
name|root
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|unused
argument_list|)
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|window
operator|=
name|window_attr
operator|.
name|root
expr_stmt|;
name|window_attr
operator|=
name|root_attr
expr_stmt|;
block|}
name|QX11PixmapData
modifier|*
name|data
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|void
name|qt_x11_getX11InfoForWindow
argument_list|(
name|QX11Info
operator|*
name|xinfo
argument_list|,
specifier|const
name|XWindowAttributes
operator|&
name|a
argument_list|)
decl_stmt|;
name|qt_x11_getX11InfoForWindow
argument_list|(
operator|&
name|data
operator|->
name|xinfo
argument_list|,
name|window_attr
argument_list|)
expr_stmt|;
name|data
operator|->
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|QPixmap
name|pm
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|data
operator|->
name|flags
operator|&=
operator|~
name|QX11PixmapData
operator|::
name|Uninitialized
expr_stmt|;
name|pm
operator|.
name|x11SetScreen
argument_list|(
name|scr
argument_list|)
expr_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|dpy
argument_list|,
name|pm
operator|.
name|handle
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XSetSubwindowMode
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|,
name|IncludeInferiors
argument_list|)
expr_stmt|;
name|XCopyArea
argument_list|(
name|dpy
argument_list|,
name|window
argument_list|,
name|pm
operator|.
name|handle
argument_list|()
argument_list|,
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|)
expr_stmt|;
return|return
name|pm
return|;
block|}
end_function
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QX11PixmapData
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
literal|32
return|;
block|}
end_function
begin_function
DECL|function|x11Info
specifier|const
name|QX11Info
modifier|&
name|QPixmap
operator|::
name|x11Info
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
return|return
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|xinfo
return|;
else|else
block|{
specifier|static
name|QX11Info
name|nullX11Info
decl_stmt|;
return|return
name|nullX11Info
return|;
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
end_if
begin_function
DECL|function|qt_renderformat_for_depth
specifier|static
name|XRenderPictFormat
modifier|*
name|qt_renderformat_for_depth
parameter_list|(
specifier|const
name|QX11Info
modifier|&
name|xinfo
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
return|return
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|depth
operator|==
literal|32
condition|)
return|return
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardARGB32
argument_list|)
return|;
else|else
return|return
name|XRenderFindVisualFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QX11PixmapData
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
name|QX11PixmapData
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Readonly
operator|)
operator|&&
name|share_mode
operator|==
name|QPixmap
operator|::
name|ImplicitlyShared
condition|)
block|{
comment|// if someone wants to draw onto us, copy the shared contents
comment|// and turn it into a fully fledged QPixmap
operator|::
name|Pixmap
name|hd_copy
init|=
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
name|XRenderPictFormat
modifier|*
name|format
init|=
name|qt_renderformat_for_depth
argument_list|(
name|xinfo
argument_list|,
name|d
argument_list|)
decl_stmt|;
operator|::
name|Picture
name|picture_copy
init|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd_copy
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|picture
operator|&&
name|d
operator|==
literal|32
condition|)
block|{
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpSrc
argument_list|,
name|picture
argument_list|,
literal|0
argument_list|,
name|picture_copy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|picture
argument_list|)
expr_stmt|;
name|that
operator|->
name|picture
operator|=
name|picture_copy
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd_copy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|hd_copy
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
block|}
name|that
operator|->
name|hd
operator|=
name|hd_copy
expr_stmt|;
name|that
operator|->
name|flags
operator|&=
operator|~
name|QX11PixmapData
operator|::
name|Readonly
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|that
operator|->
name|pengine
condition|)
name|that
operator|->
name|pengine
operator|=
operator|new
name|QX11PaintEngine
expr_stmt|;
return|return
name|that
operator|->
name|pengine
return|;
block|}
end_function
begin_function
DECL|function|x11PictureHandle
name|Qt
operator|::
name|HANDLE
name|QPixmap
operator|::
name|x11PictureHandle
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
return|return
cast|static_cast
argument_list|<
specifier|const
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|picture
return|;
else|else
return|return
literal|0
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
comment|// QT_NO_XRENDER
block|}
end_function
begin_function
DECL|function|x11ConvertToDefaultDepth
name|Qt
operator|::
name|HANDLE
name|QX11PixmapData
operator|::
name|x11ConvertToDefaultDepth
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|d
operator|==
name|QX11Info
operator|::
name|appDepth
argument_list|()
operator|||
operator|!
name|X11
operator|->
name|use_xrender
condition|)
return|return
name|hd
return|;
if|if
condition|(
operator|!
name|hd2
condition|)
block|{
name|hd2
operator|=
name|XCreatePixmap
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|hd
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|QX11Info
operator|::
name|appDepth
argument_list|()
argument_list|)
expr_stmt|;
name|XRenderPictFormat
modifier|*
name|format
init|=
name|XRenderFindVisualFormat
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|Picture
name|pic
init|=
name|XRenderCreatePicture
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|hd2
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XRenderComposite
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|PictOpSrc
argument_list|,
name|picture
argument_list|,
name|XNone
argument_list|,
name|pic
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|XRenderFreePicture
argument_list|(
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|pic
argument_list|)
expr_stmt|;
block|}
return|return
name|hd2
return|;
else|#
directive|else
return|return
name|hd
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|copy
name|void
name|QX11PixmapData
operator|::
name|copy
parameter_list|(
specifier|const
name|QPixmapData
modifier|*
name|data
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|)
block|{
name|fromImage
argument_list|(
name|data
operator|->
name|toImage
argument_list|()
operator|.
name|copy
argument_list|(
name|rect
argument_list|)
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|QX11PixmapData
modifier|*
name|x11Data
init|=
cast|static_cast
argument_list|<
specifier|const
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|setSerialNumber
argument_list|(
name|qt_pixmap_serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|Uninitialized
expr_stmt|;
name|xinfo
operator|=
name|x11Data
operator|->
name|xinfo
expr_stmt|;
name|d
operator|=
name|x11Data
operator|->
name|d
expr_stmt|;
name|w
operator|=
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
name|hd
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|XRenderPictFormat
modifier|*
name|format
init|=
name|d
operator|==
literal|32
condition|?
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardARGB32
argument_list|)
else|:
name|XRenderFindVisualFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
operator|(
name|Visual
operator|*
operator|)
name|xinfo
operator|.
name|visual
argument_list|()
argument_list|)
decl_stmt|;
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
if|if
condition|(
name|x11Data
operator|->
name|x11_mask
condition|)
block|{
name|x11_mask
operator|=
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|mask_picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|,
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardA1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XRenderPictureAttributes
name|attrs
decl_stmt|;
name|attrs
operator|.
name|alpha_map
operator|=
name|x11Data
operator|->
name|mask_picture
expr_stmt|;
name|XRenderChangePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|picture
argument_list|,
name|CPAlphaMap
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
if|if
condition|(
name|x11Data
operator|->
name|picture
operator|&&
name|x11Data
operator|->
name|d
operator|==
literal|32
condition|)
block|{
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpSrc
argument_list|,
name|x11Data
operator|->
name|picture
argument_list|,
literal|0
argument_list|,
name|picture
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|hd
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11Data
operator|->
name|x11_mask
condition|)
block|{
name|GC
name|monogc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|x11_mask
argument_list|,
name|x11_mask
argument_list|,
name|monogc
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|monogc
argument_list|)
expr_stmt|;
block|}
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QX11PixmapData
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|,
name|hd
argument_list|,
name|gc
argument_list|,
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|rect
operator|.
name|left
argument_list|()
operator|+
name|dx
argument_list|,
name|rect
operator|.
name|top
argument_list|()
operator|+
name|dy
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_XRENDER
argument_list|)
end_if
begin_function
DECL|function|convertToARGB32
name|void
name|QX11PixmapData
operator|::
name|convertToARGB32
parameter_list|(
name|bool
name|preserveContents
parameter_list|)
block|{
if|if
condition|(
operator|!
name|X11
operator|->
name|use_xrender
condition|)
return|return;
comment|// Q_ASSERT(count == 1);
if|if
condition|(
operator|(
name|flags
operator|&
name|Readonly
operator|)
operator|&&
name|share_mode
operator|==
name|QPixmap
operator|::
name|ExplicitlyShared
condition|)
return|return;
name|Pixmap
name|pm
init|=
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|32
argument_list|)
decl_stmt|;
name|Picture
name|p
init|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|pm
argument_list|,
name|XRenderFindStandardFormat
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictStandardARGB32
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|picture
condition|)
block|{
if|if
condition|(
name|preserveContents
condition|)
name|XRenderComposite
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|PictOpSrc
argument_list|,
name|picture
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|Readonly
operator|)
condition|)
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|picture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hd
operator|&&
operator|!
operator|(
name|flags
operator|&
name|Readonly
operator|)
condition|)
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|hd
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11_mask
condition|)
block|{
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask_picture
condition|)
name|XRenderFreePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|mask_picture
argument_list|)
expr_stmt|;
name|x11_mask
operator|=
literal|0
expr_stmt|;
name|mask_picture
operator|=
literal|0
expr_stmt|;
block|}
name|hd
operator|=
name|pm
expr_stmt|;
name|picture
operator|=
name|p
expr_stmt|;
name|d
operator|=
literal|32
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|fromX11Pixmap
name|QPixmap
name|QPixmap
operator|::
name|fromX11Pixmap
parameter_list|(
name|Qt
operator|::
name|HANDLE
name|pixmap
parameter_list|,
name|QPixmap
operator|::
name|ShareMode
name|mode
parameter_list|)
block|{
name|Window
name|root
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|uint
name|width
decl_stmt|;
name|uint
name|height
decl_stmt|;
name|uint
name|border_width
decl_stmt|;
name|uint
name|depth
decl_stmt|;
name|XWindowAttributes
name|win_attribs
decl_stmt|;
name|int
name|num_screens
init|=
name|ScreenCount
argument_list|(
name|X11
operator|->
name|display
argument_list|)
decl_stmt|;
name|int
name|screen
init|=
literal|0
decl_stmt|;
name|XGetGeometry
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|pixmap
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|border_width
argument_list|,
operator|&
name|depth
argument_list|)
expr_stmt|;
name|XGetWindowAttributes
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|root
argument_list|,
operator|&
name|win_attribs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|screen
operator|<
name|num_screens
condition|;
operator|++
name|screen
control|)
block|{
if|if
condition|(
name|win_attribs
operator|.
name|screen
operator|==
name|ScreenOfDisplay
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|screen
argument_list|)
condition|)
break|break;
block|}
name|QX11PixmapData
modifier|*
name|data
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|depth
operator|==
literal|1
condition|?
name|QPixmapData
operator|::
name|BitmapType
else|:
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|data
operator|->
name|setSerialNumber
argument_list|(
name|qt_pixmap_serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|flags
operator|=
name|QX11PixmapData
operator|::
name|Readonly
expr_stmt|;
name|data
operator|->
name|share_mode
operator|=
name|mode
expr_stmt|;
name|data
operator|->
name|w
operator|=
name|width
expr_stmt|;
name|data
operator|->
name|h
operator|=
name|height
expr_stmt|;
name|data
operator|->
name|is_null
operator|=
operator|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|)
expr_stmt|;
name|data
operator|->
name|d
operator|=
name|depth
expr_stmt|;
name|data
operator|->
name|hd
operator|=
name|pixmap
expr_stmt|;
if|if
condition|(
name|defaultScreen
operator|>=
literal|0
operator|&&
name|defaultScreen
operator|!=
name|screen
condition|)
block|{
name|QX11InfoData
modifier|*
name|xd
init|=
name|data
operator|->
name|xinfo
operator|.
name|getX11Data
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|xd
operator|->
name|screen
operator|=
name|defaultScreen
expr_stmt|;
name|xd
operator|->
name|depth
operator|=
name|QX11Info
operator|::
name|appDepth
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|cells
operator|=
name|QX11Info
operator|::
name|appCells
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|colormap
operator|=
name|QX11Info
operator|::
name|appColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultColormap
operator|=
name|QX11Info
operator|::
name|appDefaultColormap
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|visual
operator|=
operator|(
name|Visual
operator|*
operator|)
name|QX11Info
operator|::
name|appVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|xd
operator|->
name|defaultVisual
operator|=
name|QX11Info
operator|::
name|appDefaultVisual
argument_list|(
name|xd
operator|->
name|screen
argument_list|)
expr_stmt|;
name|data
operator|->
name|xinfo
operator|.
name|setX11Data
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|X11
operator|->
name|use_xrender
condition|)
block|{
name|XRenderPictFormat
modifier|*
name|format
init|=
name|qt_renderformat_for_depth
argument_list|(
name|data
operator|->
name|xinfo
argument_list|,
name|depth
argument_list|)
decl_stmt|;
name|data
operator|->
name|picture
operator|=
name|XRenderCreatePicture
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|data
operator|->
name|hd
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_XRENDER
return|return
name|QPixmap
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
