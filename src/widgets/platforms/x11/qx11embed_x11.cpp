begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qx11embed_x11.h"
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qlayout.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qpointer.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qx11info_x11.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_define
DECL|macro|XK_MISCELLANY
define|#
directive|define
name|XK_MISCELLANY
end_define
begin_define
DECL|macro|XK_LATIN1
define|#
directive|define
name|XK_LATIN1
end_define
begin_define
DECL|macro|None
define|#
directive|define
name|None
value|0
end_define
begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include
begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include
begin_include
include|#
directive|include
file|<X11/X.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|XK_ISO_Left_Tab
end_ifndef
begin_define
DECL|macro|XK_ISO_Left_Tab
define|#
directive|define
name|XK_ISO_Left_Tab
value|0xFE20
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define QX11EMBED_DEBUG
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QX11EmbedWidget     \ingroup advanced      \brief The QX11EmbedWidget class provides an XEmbed client widget.      XEmbed is an X11 protocol that supports the embedding of a widget     from one application into another application.      An XEmbed \e{client widget} is a window that is embedded into a     \e container. A container is the graphical location that embeds     (or \e swallows) an external application.      QX11EmbedWidget is a widget used for writing XEmbed applets or     plugins. When it has been embedded and the container receives tab     focus, focus is passed on to the widget. When the widget reaches     the end of its focus chain, focus is passed back to the     container. Window activation, accelerator support, modality and     drag and drop (XDND) are also handled.      The widget and container can both initiate the embedding. If the     widget is the initiator, the X11 window ID of the container that     it wants to embed itself into must be passed to embedInto().      If the container initiates the embedding, the window ID of the     embedded widget must be known. The container calls embed(),     passing the window ID.      This example shows an application that embeds a QX11EmbedWidget     subclass into the window whose ID is passed as a command-line     argument:      \snippet doc/src/snippets/qx11embedwidget/main.cpp 0      The problem of obtaining the window IDs is often solved by the     container invoking the application that provides the widget as a     separate process (as a panel invokes a docked applet), passing     its window ID to the new process as a command-line argument. The     new process can then call embedInto() with the container's window     ID, as shown in the example code above. Similarly, the new     process can report its window ID to the container through IPC, in     which case the container can embed the widget.      When the widget has been embedded, it emits the signal     embedded(). If it is closed by the container, the widget emits     containerClosed(). If an error occurs when embedding, error() is     emitted.      There are XEmbed widgets available for KDE and GTK+. The GTK+     equivalent of QX11EmbedWidget is GtkPlug. The corresponding KDE 3     widget is called QXEmbed.      \sa QX11EmbedContainer, {XEmbed Specification} */
comment|/*!     \class QX11EmbedContainer     \ingroup advanced      \brief The QX11EmbedContainer class provides an XEmbed container     widget.      XEmbed is an X11 protocol that supports the embedding of a widget     from one application into another application.      An XEmbed \e container is the graphical location that embeds an     external \e {client widget}. A client widget is a window that is     embedded into a container.      When a widget has been embedded and the container receives tab     focus, focus is passed on to the widget. When the widget reaches     the end of its focus chain, focus is passed back to the     container. Window activation, accelerator support, modality and     drag and drop (XDND) are also handled.      QX11EmbedContainer is commonly used for writing panels or     toolbars that hold applets, or for \e swallowing X11     applications. When writing a panel application, one container     widget is created on the toolbar, and it can then either swallow     another widget using embed(), or allow an XEmbed widget to be     embedded into itself. The container's X11 window ID, which is     retrieved with winId(), must then be known to the client widget.     After embedding, the client's window ID can be retrieved with     clientWinId().      In the following example, a container widget is created as the     main widget. It then invokes an application called "playmovie",     passing its window ID as a command line argument. The "playmovie"     program is an XEmbed client widget. The widget embeds itself into     the container using the container's window ID.      \snippet doc/src/snippets/qx11embedcontainer/main.cpp 0      When the client widget is embedded, the container emits the     signal clientIsEmbedded(). The signal clientClosed() is emitted     when a widget is closed.      It is possible for QX11EmbedContainer to embed XEmbed widgets     from toolkits other than Qt, such as GTK+. Arbitrary (non-XEmbed)     X11 widgets can also be embedded, but the XEmbed-specific     features such as window activation and focus handling are then     lost.      The GTK+ equivalent of QX11EmbedContainer is GtkSocket. The     corresponding KDE 3 widget is called QXEmbed.      \sa QX11EmbedWidget, {XEmbed Specification} */
comment|/*! \fn void QX11EmbedWidget::embedded()      This signal is emitted by the widget that has been embedded by an     XEmbed container. */
comment|/*! \fn void QX11EmbedWidget::containerClosed()      This signal is emitted by the client widget when the container     closes the widget. This can happen if the container itself     closes, or if the widget is rejected.      The container can reject a widget for any reason, but the most     common cause of a rejection is when an attempt is made to embed a     widget into a container that already has an embedded widget. */
comment|/*! \fn void QX11EmbedContainer::clientIsEmbedded()      This signal is emitted by the container when a client widget has     been embedded. */
comment|/*! \fn void QX11EmbedContainer::clientClosed()      This signal is emitted by the container when the client widget     closes. */
comment|/*!     \fn void QX11EmbedWidget::error(QX11EmbedWidget::Error error)      This signal is emitted if an error occurred as a result of     embedding into or communicating with a container. The specified     \a error describes the problem that occurred.      \sa QX11EmbedWidget::Error */
comment|/*!     \fn QX11EmbedContainer::Error QX11EmbedContainer::error() const      Returns the last error that occurred. */
comment|/*! \fn void QX11EmbedContainer::error(QX11EmbedContainer::Error error)      This signal is emitted if an error occurred when embedding or     communicating with a client. The specified \a error describes the     problem that occurred.      \sa QX11EmbedContainer::Error */
comment|/*!     \enum QX11EmbedWidget::Error      \value Unknown An unrecognized error occurred.      \value InvalidWindowID The X11 window ID of the container was         invalid. This error is usually triggered by passing an invalid         window ID to embedInto().      \omitvalue Internal */
comment|/*!     \enum QX11EmbedContainer::Error      \value Unknown An unrecognized error occurred.      \value InvalidWindowID The X11 window ID of the container was         invalid. This error is usually triggered by passing an invalid         window ID to embed().      \omitvalue Internal */
DECL|variable|XButtonPress
specifier|const
name|int
name|XButtonPress
init|=
name|ButtonPress
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|XButtonRelease
specifier|const
name|int
name|XButtonRelease
init|=
name|ButtonRelease
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|ButtonPress
undef|#
directive|undef
name|ButtonPress
end_undef
begin_undef
DECL|macro|ButtonRelease
undef|#
directive|undef
name|ButtonRelease
end_undef
begin_comment
comment|// This is a hack to move topData() out from QWidgetPrivate to public.  We
end_comment
begin_comment
comment|// need to to inspect window()'s embedded state.
end_comment
begin_class
DECL|class|QHackWidget
class|class
name|QHackWidget
super|:
specifier|public
name|QWidget
block|{
name|Q_DECLARE_PRIVATE
parameter_list|(
name|QWidget
parameter_list|)
specifier|public
private|:
DECL|function|topData
name|QTLWExtra
modifier|*
name|topData
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
return|;
block|}
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|XEMBED_VERSION
specifier|static
name|unsigned
name|int
name|XEMBED_VERSION
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|QX11EmbedMessageType
enum|enum
name|QX11EmbedMessageType
block|{
DECL|enumerator|XEMBED_EMBEDDED_NOTIFY
name|XEMBED_EMBEDDED_NOTIFY
init|=
literal|0
block|,
DECL|enumerator|XEMBED_WINDOW_ACTIVATE
name|XEMBED_WINDOW_ACTIVATE
init|=
literal|1
block|,
DECL|enumerator|XEMBED_WINDOW_DEACTIVATE
name|XEMBED_WINDOW_DEACTIVATE
init|=
literal|2
block|,
DECL|enumerator|XEMBED_REQUEST_FOCUS
name|XEMBED_REQUEST_FOCUS
init|=
literal|3
block|,
DECL|enumerator|XEMBED_FOCUS_IN
name|XEMBED_FOCUS_IN
init|=
literal|4
block|,
DECL|enumerator|XEMBED_FOCUS_OUT
name|XEMBED_FOCUS_OUT
init|=
literal|5
block|,
DECL|enumerator|XEMBED_FOCUS_NEXT
name|XEMBED_FOCUS_NEXT
init|=
literal|6
block|,
DECL|enumerator|XEMBED_FOCUS_PREV
name|XEMBED_FOCUS_PREV
init|=
literal|7
block|,
DECL|enumerator|XEMBED_MODALITY_ON
name|XEMBED_MODALITY_ON
init|=
literal|10
block|,
DECL|enumerator|XEMBED_MODALITY_OFF
name|XEMBED_MODALITY_OFF
init|=
literal|11
block|,
DECL|enumerator|XEMBED_REGISTER_ACCELERATOR
name|XEMBED_REGISTER_ACCELERATOR
init|=
literal|12
block|,
DECL|enumerator|XEMBED_UNREGISTER_ACCELERATOR
name|XEMBED_UNREGISTER_ACCELERATOR
init|=
literal|13
block|,
DECL|enumerator|XEMBED_ACTIVATE_ACCELERATOR
name|XEMBED_ACTIVATE_ACCELERATOR
init|=
literal|14
block|}
enum|;
end_enum
begin_enum
DECL|enum|QX11EmbedFocusInDetail
enum|enum
name|QX11EmbedFocusInDetail
block|{
DECL|enumerator|XEMBED_FOCUS_CURRENT
name|XEMBED_FOCUS_CURRENT
init|=
literal|0
block|,
DECL|enumerator|XEMBED_FOCUS_FIRST
name|XEMBED_FOCUS_FIRST
init|=
literal|1
block|,
DECL|enumerator|XEMBED_FOCUS_LAST
name|XEMBED_FOCUS_LAST
init|=
literal|2
block|}
enum|;
end_enum
begin_enum
DECL|enum|QX11EmbedFocusInFlags
enum|enum
name|QX11EmbedFocusInFlags
block|{
DECL|enumerator|XEMBED_FOCUS_OTHER
name|XEMBED_FOCUS_OTHER
init|=
operator|(
literal|0
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|XEMBED_FOCUS_WRAPAROUND
name|XEMBED_FOCUS_WRAPAROUND
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|}
enum|;
end_enum
begin_enum
DECL|enum|QX11EmbedInfoFlags
enum|enum
name|QX11EmbedInfoFlags
block|{
DECL|enumerator|XEMBED_MAPPED
name|XEMBED_MAPPED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|}
enum|;
end_enum
begin_enum
DECL|enum|QX11EmbedAccelModifiers
enum|enum
name|QX11EmbedAccelModifiers
block|{
DECL|enumerator|XEMBED_MODIFIER_SHIFT
name|XEMBED_MODIFIER_SHIFT
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|XEMBED_MODIFIER_CONTROL
name|XEMBED_MODIFIER_CONTROL
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|XEMBED_MODIFIER_ALT
name|XEMBED_MODIFIER_ALT
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
DECL|enumerator|XEMBED_MODIFIER_SUPER
name|XEMBED_MODIFIER_SUPER
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
DECL|enumerator|XEMBED_MODIFIER_HYPER
name|XEMBED_MODIFIER_HYPER
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|}
enum|;
end_enum
begin_enum
DECL|enum|QX11EmbedAccelFlags
enum|enum
name|QX11EmbedAccelFlags
block|{
DECL|enumerator|XEMBED_ACCELERATOR_OVERLOADED
name|XEMBED_ACCELERATOR_OVERLOADED
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|}
enum|;
end_enum
begin_comment
comment|// Silence the default X11 error handler.
end_comment
begin_function
DECL|function|x11ErrorHandler
specifier|static
name|int
name|x11ErrorHandler
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|XErrorEvent
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Returns the X11 timestamp. Maintained mainly by qapplication
end_comment
begin_comment
comment|// internals, but also updated by the XEmbed widgets.
end_comment
begin_function
DECL|function|x11Time
specifier|static
name|Time
name|x11Time
parameter_list|()
block|{
return|return
name|qt_x11Data
operator|->
name|time
return|;
block|}
end_function
begin_comment
comment|// Gives the version and flags of the supported XEmbed protocol.
end_comment
begin_function
DECL|function|XEmbedVersion
specifier|static
name|unsigned
name|int
name|XEmbedVersion
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Sends an XEmbed message.
end_comment
begin_function
DECL|function|sendXEmbedMessage
specifier|static
name|void
name|sendXEmbedMessage
parameter_list|(
name|WId
name|window
parameter_list|,
name|Display
modifier|*
name|display
parameter_list|,
name|long
name|message
parameter_list|,
name|long
name|detail
init|=
literal|0
parameter_list|,
name|long
name|data1
init|=
literal|0
parameter_list|,
name|long
name|data2
init|=
literal|0
parameter_list|)
block|{
name|XClientMessageEvent
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|type
operator|=
name|ClientMessage
expr_stmt|;
name|c
operator|.
name|message_type
operator|=
name|ATOM
argument_list|(
name|_XEMBED
argument_list|)
expr_stmt|;
name|c
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|c
operator|.
name|display
operator|=
name|display
expr_stmt|;
name|c
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|c
operator|.
name|data
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|x11Time
argument_list|()
expr_stmt|;
name|c
operator|.
name|data
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|message
expr_stmt|;
name|c
operator|.
name|data
operator|.
name|l
index|[
literal|2
index|]
operator|=
name|detail
expr_stmt|;
name|c
operator|.
name|data
operator|.
name|l
index|[
literal|3
index|]
operator|=
name|data1
expr_stmt|;
name|c
operator|.
name|data
operator|.
name|l
index|[
literal|4
index|]
operator|=
name|data2
expr_stmt|;
name|XSendEvent
argument_list|(
name|display
argument_list|,
name|window
argument_list|,
literal|false
argument_list|,
name|NoEventMask
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// From qapplication_x11.cpp
end_comment
begin_decl_stmt
DECL|variable|lastKeyEvent
specifier|static
name|XKeyEvent
name|lastKeyEvent
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|oldX11EventFilter
specifier|static
name|QCoreApplication
operator|::
name|EventFilter
name|oldX11EventFilter
decl_stmt|;
end_decl_stmt
begin_comment
comment|// The purpose of this global x11 filter is for one to capture the key
end_comment
begin_comment
comment|// events in their original state, but most importantly this is the
end_comment
begin_comment
comment|// only way to get the WM_TAKE_FOCUS message from WM_PROTOCOLS.
end_comment
begin_function
DECL|function|x11EventFilter
specifier|static
name|bool
name|x11EventFilter
parameter_list|(
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
name|XEvent
modifier|*
name|event
init|=
cast|reinterpret_cast
argument_list|<
name|XEvent
operator|*
argument_list|>
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|XKeyPress
operator|||
name|event
operator|->
name|type
operator|==
name|XKeyRelease
condition|)
name|lastKeyEvent
operator|=
name|event
operator|->
name|xkey
expr_stmt|;
if|if
condition|(
name|oldX11EventFilter
operator|&&
name|oldX11EventFilter
operator|!=
operator|&
name|x11EventFilter
condition|)
return|return
name|oldX11EventFilter
argument_list|(
name|message
argument_list|,
name|result
argument_list|)
return|;
else|else
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|functorData
struct|struct
name|functorData
block|{
DECL|member|id
DECL|member|rootWindow
name|Window
name|id
decl_stmt|,
name|rootWindow
decl_stmt|;
DECL|member|clearedWmState
name|bool
name|clearedWmState
decl_stmt|;
DECL|member|reparentedToRoot
name|bool
name|reparentedToRoot
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|functor
specifier|static
name|Bool
name|functor
parameter_list|(
name|Display
modifier|*
name|display
parameter_list|,
name|XEvent
modifier|*
name|event
parameter_list|,
name|XPointer
name|arg
parameter_list|)
block|{
name|functorData
modifier|*
name|data
init|=
operator|(
name|functorData
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|reparentedToRoot
operator|&&
name|event
operator|->
name|type
operator|==
name|ReparentNotify
operator|&&
name|event
operator|->
name|xreparent
operator|.
name|window
operator|==
name|data
operator|->
name|id
operator|&&
name|event
operator|->
name|xreparent
operator|.
name|parent
operator|==
name|data
operator|->
name|rootWindow
condition|)
block|{
name|data
operator|->
name|reparentedToRoot
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|data
operator|->
name|clearedWmState
operator|&&
name|event
operator|->
name|type
operator|==
name|PropertyNotify
operator|&&
name|event
operator|->
name|xproperty
operator|.
name|window
operator|==
name|data
operator|->
name|id
operator|&&
name|event
operator|->
name|xproperty
operator|.
name|atom
operator|==
name|ATOM
argument_list|(
name|WM_STATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|xproperty
operator|.
name|state
operator|==
name|PropertyDelete
condition|)
block|{
name|data
operator|->
name|clearedWmState
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Atom
name|ret
decl_stmt|;
name|int
name|format
decl_stmt|,
name|status
decl_stmt|;
name|unsigned
name|char
modifier|*
name|retval
decl_stmt|;
name|unsigned
name|long
name|nitems
decl_stmt|,
name|after
decl_stmt|;
name|status
operator|=
name|XGetWindowProperty
argument_list|(
name|display
argument_list|,
name|data
operator|->
name|id
argument_list|,
name|ATOM
argument_list|(
name|WM_STATE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|False
argument_list|,
name|ATOM
argument_list|(
name|WM_STATE
argument_list|)
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|after
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|Success
operator|&&
name|ret
operator|==
name|ATOM
argument_list|(
name|WM_STATE
argument_list|)
operator|&&
name|format
operator|==
literal|32
operator|&&
name|nitems
operator|>
literal|0
condition|)
block|{
name|long
name|state
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|retval
decl_stmt|;
name|XFree
argument_list|(
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|WithdrawnState
condition|)
block|{
name|data
operator|->
name|clearedWmState
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_class
DECL|class|QX11EmbedWidgetPrivate
class|class
name|QX11EmbedWidgetPrivate
super|:
specifier|public
name|QWidgetPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QX11EmbedWidget
parameter_list|)
specifier|public
private|:
DECL|function|QX11EmbedWidgetPrivate
specifier|inline
name|QX11EmbedWidgetPrivate
parameter_list|()
block|{
name|lastError
operator|=
name|QX11EmbedWidget
operator|::
name|Unknown
expr_stmt|;
name|container
operator|=
literal|0
expr_stmt|;
block|}
name|void
name|setEmbedded
parameter_list|()
function_decl|;
DECL|function|emitError
name|void
name|emitError
parameter_list|(
name|QX11EmbedWidget
operator|::
name|Error
name|error
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|error
argument_list|)
emit|;
block|}
DECL|enum|FocusWidgets
enum|enum
name|FocusWidgets
block|{
DECL|enumerator|FirstFocusWidget
name|FirstFocusWidget
block|,
DECL|enumerator|LastFocusWidget
name|LastFocusWidget
block|}
enum|;
DECL|member|focusOriginator
name|int
name|focusOriginator
decl_stmt|;
name|QWidget
modifier|*
name|getFocusWidget
parameter_list|(
name|FocusWidgets
name|fw
parameter_list|)
function_decl|;
name|void
name|checkActivateWindow
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
function_decl|;
name|QX11EmbedWidget
modifier|*
name|xEmbedWidget
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
specifier|const
function_decl|;
name|void
name|clearFocus
parameter_list|()
function_decl|;
DECL|member|container
name|WId
name|container
decl_stmt|;
DECL|member|currentFocus
name|QPointer
argument_list|<
name|QWidget
argument_list|>
name|currentFocus
decl_stmt|;
DECL|member|lastError
name|QX11EmbedWidget
operator|::
name|Error
name|lastError
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QX11EmbedWidget object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QX11EmbedWidget
name|QX11EmbedWidget
operator|::
name|QX11EmbedWidget
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QX11EmbedWidgetPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|XSetErrorHandler
argument_list|(
name|x11ErrorHandler
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
expr_stmt|;
name|createWinId
argument_list|()
expr_stmt|;
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|KeyPressMask
operator||
name|KeyReleaseMask
operator||
name|ButtonPressMask
operator||
name|ButtonReleaseMask
operator||
name|KeymapStateMask
operator||
name|ButtonMotionMask
operator||
name|PointerMotionMask
operator||
name|FocusChangeMask
operator||
name|ExposureMask
operator||
name|StructureNotifyMask
operator||
name|SubstructureNotifyMask
operator||
name|PropertyChangeMask
argument_list|)
expr_stmt|;
name|long
name|data
index|[]
init|=
block|{
name|XEMBED_VERSION
block|,
name|XEMBED_MAPPED
block|}
decl_stmt|;
name|XChangeProperty
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
literal|32
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|StrongFocus
argument_list|)
expr_stmt|;
name|setSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Expanding
argument_list|,
name|QSizePolicy
operator|::
name|Expanding
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|instance
argument_list|()
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::QX11EmbedWidget: constructed client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QX11EmbedWidget object. If the widget is embedded     when deleted, it is hidden and then detached from its container,     so that the container is free to embed a new widget. */
end_comment
begin_destructor
DECL|function|~QX11EmbedWidget
name|QX11EmbedWidget
operator|::
name|~
name|QX11EmbedWidget
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|container
condition|)
block|{
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::~QX11EmbedWidget: unmapping"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
operator|<<
literal|"from container with winId"
operator|<<
name|d
operator|->
name|container
expr_stmt|;
endif|#
directive|endif
name|XUnmapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
name|XReparentWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::~QX11EmbedWidget: destructed client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Returns the type of error that occurred last. This is the same error code     that is emitted by the error() signal.      \sa Error */
end_comment
begin_function
DECL|function|error
name|QX11EmbedWidget
operator|::
name|Error
name|QX11EmbedWidget
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|lastError
return|;
block|}
end_function
begin_comment
comment|/*!     When this function is called, the widget embeds itself into the     container whose window ID is \a id.      If \a id is \e not the window ID of a container this function will     behave unpredictably. */
end_comment
begin_function
DECL|function|embedInto
name|void
name|QX11EmbedWidget
operator|::
name|embedInto
parameter_list|(
name|WId
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::embedInto: embedding client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
operator|<<
literal|"into container"
operator|<<
name|id
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|container
operator|=
name|id
expr_stmt|;
switch|switch
condition|(
name|XReparentWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|d
operator|->
name|container
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|BadWindow
case|:
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
break|break;
case|case
name|BadMatch
case|:
name|d
operator|->
name|emitError
argument_list|(
name|Internal
argument_list|)
expr_stmt|;
break|break;
case|case
name|Success
case|:
default|default:
break|break;
block|}
name|QTLWExtra
modifier|*
name|x
init|=
name|d
operator|->
name|extra
condition|?
name|d
operator|->
name|extra
operator|->
name|topextra
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|x
condition|)
name|x
operator|->
name|frameStrut
operator|.
name|setCoords
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
operator|.
name|fstrut_dirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Gets the first or last child widget that can get focus. */
end_comment
begin_function
DECL|function|getFocusWidget
name|QWidget
modifier|*
name|QX11EmbedWidgetPrivate
operator|::
name|getFocusWidget
parameter_list|(
name|FocusWidgets
name|fw
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
name|QWidget
modifier|*
name|tlw
init|=
name|q
decl_stmt|;
name|QWidget
modifier|*
name|w
init|=
name|tlw
operator|->
name|nextInFocusChain
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|last
init|=
name|tlw
decl_stmt|;
specifier|extern
name|bool
name|qt_tab_all_widgets
decl_stmt|;
name|uint
name|focus_flag
init|=
name|qt_tab_all_widgets
condition|?
name|Qt
operator|::
name|TabFocus
else|:
name|Qt
operator|::
name|StrongFocus
decl_stmt|;
while|while
condition|(
name|w
operator|!=
name|tlw
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|w
operator|->
name|focusPolicy
argument_list|()
operator|&
name|focus_flag
operator|)
operator|==
name|focus_flag
operator|)
operator|&&
name|w
operator|->
name|isVisibleTo
argument_list|(
name|q
argument_list|)
operator|&&
name|w
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|last
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|FirstFocusWidget
condition|)
break|break;
block|}
name|w
operator|=
name|w
operator|->
name|nextInFocusChain
argument_list|()
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Returns the xembed widget that the widget is a child of */
end_comment
begin_function
DECL|function|xEmbedWidget
name|QX11EmbedWidget
modifier|*
name|QX11EmbedWidgetPrivate
operator|::
name|xEmbedWidget
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
specifier|const
block|{
name|QX11EmbedWidget
modifier|*
name|xec
init|=
literal|0
decl_stmt|;
comment|// Check the widget itself, then its parents, and find the first
comment|// QX11EmbedWidget.
do|do
block|{
if|if
condition|(
operator|(
name|xec
operator|=
name|qobject_cast
argument_list|<
name|QX11EmbedWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
operator|)
condition|)
return|return
name|xec
return|;
block|}
do|while
condition|(
operator|(
name|o
operator|=
name|o
operator|->
name|parent
argument_list|()
operator|)
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Checks the active window. */
end_comment
begin_function
DECL|function|checkActivateWindow
name|void
name|QX11EmbedWidgetPrivate
operator|::
name|checkActivateWindow
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
name|QX11EmbedWidget
modifier|*
name|xec
init|=
name|xEmbedWidget
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// check if we are in the right xembed client
if|if
condition|(
name|q
operator|!=
name|xec
condition|)
return|return;
name|QWidget
modifier|*
name|w
init|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// if it is no active window, then don't do the change
if|if
condition|(
operator|!
operator|(
name|w
operator|&&
name|qApp
operator|->
name|activeWindow
argument_list|()
operator|)
condition|)
return|return;
comment|// if it already is the active window, don't do anything
if|if
condition|(
name|w
operator|->
name|window
argument_list|()
operator|!=
name|qApp
operator|->
name|activeWindow
argument_list|()
condition|)
block|{
name|qApp
operator|->
name|setActiveWindow
argument_list|(
name|w
operator|->
name|window
argument_list|()
argument_list|)
expr_stmt|;
name|currentFocus
operator|=
name|w
expr_stmt|;
name|sendXEmbedMessage
argument_list|(
name|xec
operator|->
name|containerWinId
argument_list|()
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_REQUEST_FOCUS
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Clears the focus */
end_comment
begin_function
DECL|function|clearFocus
name|void
name|QX11EmbedWidgetPrivate
operator|::
name|clearFocus
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
comment|// Setting focus on the client itself removes Qt's
comment|// logical focus rectangle. We can't just do a
comment|// clearFocus here, because when we send the synthetic
comment|// FocusIn to ourselves on activation, Qt will set
comment|// focus on focusWidget() again. This way, we "hide"
comment|// focus rather than clearing it.
if|if
condition|(
operator|!
name|q
operator|->
name|window
argument_list|()
operator|->
name|hasFocus
argument_list|()
condition|)
name|q
operator|->
name|window
argument_list|()
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
name|currentFocus
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Sets the embedded flag on the client. */
end_comment
begin_function
DECL|function|setEmbedded
name|void
name|QX11EmbedWidgetPrivate
operator|::
name|setEmbedded
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
operator|(
operator|(
name|QHackWidget
operator|*
operator|)
name|q
operator|->
name|window
argument_list|()
operator|)
operator|->
name|topData
argument_list|()
operator|->
name|embedded
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Handles WindowActivate and FocusIn events for the client. */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QX11EmbedWidget
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|FocusIn
case|:
switch|switch
condition|(
operator|(
operator|(
name|QFocusEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|reason
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|MouseFocusReason
case|:
comment|// If the user clicks into one of the client widget's
comment|// children and we didn't have focus already, we request
comment|// focus from our container.
if|if
condition|(
name|d
operator|->
name|xEmbedWidget
argument_list|(
name|o
argument_list|)
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|currentFocus
operator|.
name|isNull
argument_list|()
condition|)
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|container
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_REQUEST_FOCUS
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentFocus
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|TabFocusReason
case|:
comment|// If the xembed client receives a focus event because of
comment|// a Tab, then we are at the end of our focus chain and we
comment|// ask the container to move to its next focus widget.
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
name|d
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|container
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_NEXT
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// We're listening on events from qApp, so in order
comment|// for us to know who to set focus on if we receive an
comment|// activation event, we note the widget that got the
comment|// focusin last.
if|if
condition|(
name|d
operator|->
name|xEmbedWidget
argument_list|(
name|o
argument_list|)
operator|==
name|this
condition|)
name|d
operator|->
name|currentFocus
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|BacktabFocusReason
case|:
comment|// If the window receives a focus event because of
comment|// a Backtab, then we are at the start of our focus chain
comment|// and we ask the container to move to its previous focus
comment|// widget.
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
comment|// See comment for Tab.
comment|// If we receive a XEMBED_FOCUS_IN
comment|// XEMBED_FOCUS_CURRENT, we will set focus in
comment|// currentFocus. To avoid that in this case, we reset
comment|// currentFocus.
name|d
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|container
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_PREV
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|xEmbedWidget
argument_list|(
name|o
argument_list|)
operator|==
name|this
condition|)
name|d
operator|->
name|currentFocus
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ActiveWindowFocusReason
case|:
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|currentFocus
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|currentFocus
operator|->
name|hasFocus
argument_list|()
condition|)
name|d
operator|->
name|currentFocus
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|PopupFocusReason
case|:
case|case
name|Qt
operator|::
name|ShortcutFocusReason
case|:
case|case
name|Qt
operator|::
name|OtherFocusReason
case|:
comment|// If focus is received to any child widget because of any
comment|// other reason, remember the widget so that we can give
comment|// it focus again if we're activated.
if|if
condition|(
name|d
operator|->
name|xEmbedWidget
argument_list|(
name|o
argument_list|)
operator|==
name|this
condition|)
block|{
name|d
operator|->
name|currentFocus
operator|=
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
comment|// If we get a mouse button press event inside a embedded widget
comment|// make sure this is the active window in qapp.
name|d
operator|->
name|checkActivateWindow
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|eventFilter
argument_list|(
name|o
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Handles some notification events and client messages. Client side     XEmbed message receiving is also handled here. */
end_comment
begin_function
DECL|function|x11Event
name|bool
name|QX11EmbedWidget
operator|::
name|x11Event
parameter_list|(
name|XEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|DestroyNotify
case|:
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::x11Event: client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
operator|<<
literal|"received a DestroyNotify"
expr_stmt|;
endif|#
directive|endif
comment|// If the container window is destroyed, we signal this to the user.
name|d
operator|->
name|container
operator|=
literal|0
expr_stmt|;
emit|emit
name|containerClosed
argument_list|()
emit|;
break|break;
case|case
name|ReparentNotify
case|:
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::x11Event: client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
operator|<<
literal|"received a ReparentNotify to"
operator|<<
operator|(
operator|(
name|event
operator|->
name|xreparent
operator|.
name|parent
operator|==
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
operator|)
condition|?
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"root"
argument_list|)
else|:
name|QString
operator|::
name|number
argument_list|(
name|event
operator|->
name|xreparent
operator|.
name|parent
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|// If the container shuts down, we will be reparented to the
comment|// root window. We must also consider the case that we may be
comment|// reparented from one container to another.
if|if
condition|(
name|event
operator|->
name|xreparent
operator|.
name|parent
operator|==
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|QHackWidget
operator|*
operator|)
name|this
operator|)
operator|->
name|topData
argument_list|()
operator|->
name|embedded
condition|)
block|{
name|d
operator|->
name|container
operator|=
literal|0
expr_stmt|;
emit|emit
name|containerClosed
argument_list|()
emit|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
name|d
operator|->
name|container
operator|=
name|event
operator|->
name|xreparent
operator|.
name|parent
expr_stmt|;
block|}
break|break;
case|case
name|UnmapNotify
case|:
comment|// Mapping and unmapping are handled by changes to the
comment|// _XEMBED_INFO property. Any default map/unmap requests are
comment|// ignored.
return|return
literal|true
return|;
case|case
name|PropertyNotify
case|:
comment|// The container sends us map/unmap messages through the
comment|// _XEMBED_INFO property. We adhere to the XEMBED_MAPPED bit in
comment|// data2.
if|if
condition|(
name|event
operator|->
name|xproperty
operator|.
name|atom
operator|==
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
condition|)
block|{
name|Atom
name|actual_type_return
decl_stmt|;
name|int
name|actual_format_return
decl_stmt|;
name|unsigned
name|long
name|nitems_return
decl_stmt|;
name|unsigned
name|long
name|bytes_after_return
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prop_return
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XGetWindowProperty
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|false
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
operator|&
name|actual_type_return
argument_list|,
operator|&
name|actual_format_return
argument_list|,
operator|&
name|nitems_return
argument_list|,
operator|&
name|bytes_after_return
argument_list|,
operator|&
name|prop_return
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
name|nitems_return
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|long
operator|*
operator|)
name|prop_return
operator|)
index|[
literal|1
index|]
operator|&
name|XEMBED_MAPPED
condition|)
block|{
name|XMapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XUnmapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prop_return
condition|)
name|XFree
argument_list|(
name|prop_return
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ClientMessage
case|:
comment|// XEMBED messages have message_type _XEMBED
if|if
condition|(
name|event
operator|->
name|xclient
operator|.
name|message_type
operator|==
name|ATOM
argument_list|(
name|_XEMBED
argument_list|)
condition|)
block|{
comment|// Discard XEMBED messages not to ourselves. (### dead code?)
if|if
condition|(
name|event
operator|->
name|xclient
operator|.
name|window
operator|!=
name|internalWinId
argument_list|()
condition|)
break|break;
comment|// Update qt_x_time if necessary
name|Time
name|msgtime
init|=
operator|(
name|Time
operator|)
name|event
operator|->
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|msgtime
operator|>
name|X11
operator|->
name|time
condition|)
name|X11
operator|->
name|time
operator|=
name|msgtime
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|1
index|]
condition|)
block|{
case|case
name|XEMBED_WINDOW_ACTIVATE
case|:
block|{
comment|// When we receive an XEMBED_WINDOW_ACTIVATE, we simply send
comment|// ourselves a WindowActivate event. Real activation happens
comment|// when receive XEMBED_FOCUS_IN.
if|if
condition|(
operator|!
name|isActiveWindow
argument_list|()
condition|)
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XEMBED_WINDOW_DEACTIVATE
case|:
block|{
comment|// When we receive an XEMBED_WINDOW_DEACTIVATE, we simply send
comment|// ourselves a WindowDeactivate event. Real activation happens
comment|// when receive XEMBED_FOCUS_IN.
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|qApp
operator|->
name|activePopupWidget
argument_list|()
condition|)
name|QApplication
operator|::
name|setActiveWindow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XEMBED_EMBEDDED_NOTIFY
case|:
block|{
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedWidget::x11Event: client"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
operator|<<
literal|"received an XEMBED EMBEDDED NOTIFY message"
expr_stmt|;
endif|#
directive|endif
comment|// In this message's l[2] we have the max version
comment|// supported by both the client and the
comment|// container. QX11EmbedWidget does not use this field.
comment|// We have been embedded, so we set our
comment|// client's embedded flag.
name|d
operator|->
name|setEmbedded
argument_list|()
expr_stmt|;
emit|emit
name|embedded
argument_list|()
emit|;
block|}
break|break;
case|case
name|XEMBED_FOCUS_IN
case|:
comment|// don't set the focus if a modal dialog is open
if|if
condition|(
name|qApp
operator|->
name|activeModalWidget
argument_list|()
condition|)
break|break;
comment|// in case we embed more than one topLevel window inside the same
comment|// host window.
if|if
condition|(
name|window
argument_list|()
operator|!=
name|qApp
operator|->
name|activeWindow
argument_list|()
condition|)
name|qApp
operator|->
name|setActiveWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|2
index|]
condition|)
block|{
case|case
name|XEMBED_FOCUS_CURRENT
case|:
comment|// The container sends us this message if it wants
comment|// us to focus on the widget that last had focus.
comment|// This is the reply when XEMBED_REQUEST_FOCUS is
comment|// sent to the container.
if|if
condition|(
operator|!
name|d
operator|->
name|currentFocus
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|currentFocus
operator|->
name|hasFocus
argument_list|()
condition|)
name|d
operator|->
name|currentFocus
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No widget currently has focus. We set focus
comment|// on the first widget next to the
comment|// client widget. Since the setFocus will not work
comment|// if the window is disabled, set the currentFocus
comment|// directly so that it's set on window activate.
name|d
operator|->
name|currentFocus
operator|=
name|d
operator|->
name|getFocusWidget
argument_list|(
name|QX11EmbedWidgetPrivate
operator|::
name|FirstFocusWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentFocus
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XEMBED_FOCUS_FIRST
case|:
comment|// The container sends this message when it wants
comment|// us to focus on the first widget in our focus
comment|// chain (typically because of a tab).
name|d
operator|->
name|currentFocus
operator|=
name|d
operator|->
name|getFocusWidget
argument_list|(
name|QX11EmbedWidgetPrivate
operator|::
name|FirstFocusWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentFocus
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|TabFocusReason
argument_list|)
expr_stmt|;
break|break;
case|case
name|XEMBED_FOCUS_LAST
case|:
comment|// The container sends this message when it wants
comment|// us to focus on the last widget in our focus
comment|// chain (typically because of a backtab).
name|d
operator|->
name|currentFocus
operator|=
name|d
operator|->
name|getFocusWidget
argument_list|(
name|QX11EmbedWidgetPrivate
operator|::
name|LastFocusWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentFocus
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Ignore any other XEMBED_FOCUS_IN details.
break|break;
block|}
break|break;
case|case
name|XEMBED_FOCUS_OUT
case|:
comment|// The container sends us this message when it wants us
comment|// to lose focus and forget about the widget that last
comment|// had focus. Typically sent by the container when it
comment|// loses focus because of mouse or tab activity. We do
comment|// then not want to set focus on anything if we're
comment|// activated.
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
name|d
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|// Ignore any other XEMBED messages.
break|break;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|// Non-XEMBED client messages are not interesting.
block|}
break|break;
default|default:
comment|// Ignore all other x11 events.
break|break;
block|}
comment|// Allow default handling.
return|return
name|QWidget
operator|::
name|x11Event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QX11EmbedWidget
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ParentChange
condition|)
block|{
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|KeyPressMask
operator||
name|KeyReleaseMask
operator||
name|ButtonPressMask
operator||
name|ButtonReleaseMask
operator||
name|KeymapStateMask
operator||
name|ButtonMotionMask
operator||
name|PointerMotionMask
operator||
name|FocusChangeMask
operator||
name|ExposureMask
operator||
name|StructureNotifyMask
operator||
name|SubstructureNotifyMask
operator||
name|PropertyChangeMask
argument_list|)
expr_stmt|;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QX11EmbedWidget
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|layout
argument_list|()
condition|)
name|layout
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
name|QWidget
operator|::
name|resizeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the widget is embedded, returns the window ID of the     container; otherwize returns 0. */
end_comment
begin_function
DECL|function|containerWinId
name|WId
name|QX11EmbedWidget
operator|::
name|containerWinId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QX11EmbedWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|container
return|;
block|}
end_function
begin_class
DECL|class|QX11EmbedContainerPrivate
class|class
name|QX11EmbedContainerPrivate
super|:
specifier|public
name|QWidgetPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QX11EmbedContainer
parameter_list|)
specifier|public
private|:
DECL|function|QX11EmbedContainerPrivate
specifier|inline
name|QX11EmbedContainerPrivate
parameter_list|()
block|{
name|lastError
operator|=
name|QX11EmbedContainer
operator|::
name|Unknown
expr_stmt|;
name|client
operator|=
literal|0
expr_stmt|;
name|focusProxy
operator|=
literal|0
expr_stmt|;
name|clientIsXEmbed
operator|=
literal|false
expr_stmt|;
name|xgrab
operator|=
literal|false
expr_stmt|;
block|}
name|bool
name|isEmbedded
parameter_list|()
specifier|const
function_decl|;
name|void
name|moveInputToProxy
parameter_list|()
function_decl|;
name|void
name|acceptClient
parameter_list|(
name|WId
name|window
parameter_list|)
function_decl|;
name|void
name|rejectClient
parameter_list|(
name|WId
name|window
parameter_list|)
function_decl|;
name|void
name|checkGrab
parameter_list|()
function_decl|;
name|WId
name|topLevelParentWinId
parameter_list|()
specifier|const
function_decl|;
DECL|function|emitError
name|void
name|emitError
parameter_list|(
name|QX11EmbedContainer
operator|::
name|Error
name|error
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
name|lastError
operator|=
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|error
argument_list|)
emit|;
block|}
DECL|member|client
name|WId
name|client
decl_stmt|;
DECL|member|focusProxy
name|QWidget
modifier|*
name|focusProxy
decl_stmt|;
DECL|member|clientIsXEmbed
name|bool
name|clientIsXEmbed
decl_stmt|;
DECL|member|xgrab
name|bool
name|xgrab
decl_stmt|;
DECL|member|clientOriginalRect
name|QRect
name|clientOriginalRect
decl_stmt|;
DECL|member|wmMinimumSizeHint
name|QSize
name|wmMinimumSizeHint
decl_stmt|;
DECL|member|lastError
name|QX11EmbedContainer
operator|::
name|Error
name|lastError
decl_stmt|;
DECL|member|activeContainer
specifier|static
name|QX11EmbedContainer
modifier|*
name|activeContainer
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|activeContainer
name|QX11EmbedContainer
modifier|*
name|QX11EmbedContainerPrivate
operator|::
name|activeContainer
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Creates a QX11EmbedContainer object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QX11EmbedContainer
name|QX11EmbedContainer
operator|::
name|QX11EmbedContainer
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QWidget
argument_list|(
operator|*
operator|new
name|QX11EmbedContainerPrivate
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
name|XSetErrorHandler
argument_list|(
name|x11ErrorHandler
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
expr_stmt|;
name|createWinId
argument_list|()
expr_stmt|;
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|StrongFocus
argument_list|)
expr_stmt|;
name|setSizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Expanding
argument_list|,
name|QSizePolicy
operator|::
name|Expanding
argument_list|)
expr_stmt|;
comment|// ### PORT setKeyCompression(false);
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Everybody gets a focus proxy, but only one toplevel container's
comment|// focus proxy is actually in use.
name|d
operator|->
name|focusProxy
operator|=
operator|new
name|QWidget
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|focusProxy
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_NativeWindow
argument_list|)
expr_stmt|;
name|d
operator|->
name|focusProxy
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_DontCreateNativeAncestors
argument_list|)
expr_stmt|;
name|d
operator|->
name|focusProxy
operator|->
name|createWinId
argument_list|()
expr_stmt|;
name|d
operator|->
name|focusProxy
operator|->
name|setGeometry
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// We need events from the window (activation status) and
comment|// from qApp (keypress/release).
name|qApp
operator|->
name|installEventFilter
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Install X11 event filter.
if|if
condition|(
operator|!
name|oldX11EventFilter
condition|)
name|oldX11EventFilter
operator|=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|setEventFilter
argument_list|(
name|x11EventFilter
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|KeyPressMask
operator||
name|KeyReleaseMask
operator||
name|ButtonPressMask
operator||
name|ButtonReleaseMask
operator||
name|ButtonMotionMask
operator||
name|KeymapStateMask
operator||
name|PointerMotionMask
operator||
name|EnterWindowMask
operator||
name|LeaveWindowMask
operator||
name|FocusChangeMask
operator||
name|ExposureMask
operator||
name|StructureNotifyMask
operator||
name|SubstructureNotifyMask
argument_list|)
expr_stmt|;
comment|// Make sure our new event mask takes effect as soon as possible.
name|XFlush
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|)
expr_stmt|;
comment|// Move input to our focusProxy if this widget is active, and not
comment|// shaded by a modal dialog (in which case isActiveWindow() would
comment|// still return true, but where we must not move input focus).
if|if
condition|(
name|qApp
operator|->
name|activeWindow
argument_list|()
operator|==
name|window
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
name|d
operator|->
name|moveInputToProxy
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QX11EMBED_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QX11EmbedContainer::QX11EmbedContainer: constructed container"
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
operator|<<
literal|"with winId"
operator|<<
name|winId
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destructs a QX11EmbedContainer. */
end_comment
begin_destructor
DECL|function|~QX11EmbedContainer
name|QX11EmbedContainer
operator|::
name|~
name|QX11EmbedContainer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|client
condition|)
block|{
name|XUnmapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|)
expr_stmt|;
name|XReparentWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|xgrab
condition|)
name|XUngrabButton
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|AnyButton
argument_list|,
name|AnyModifier
argument_list|,
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|error
name|QX11EmbedContainer
operator|::
name|Error
name|QX11EmbedContainer
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|lastError
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QX11EmbedContainer
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*! \internal      Returns whether or not the windows' embedded flag is set. */
end_comment
begin_function
DECL|function|isEmbedded
name|bool
name|QX11EmbedContainerPrivate
operator|::
name|isEmbedded
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|QHackWidget
operator|*
operator|)
name|q
operator|->
name|window
argument_list|()
operator|)
operator|->
name|topData
argument_list|()
operator|->
name|embedded
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Returns the parentWinId of the window. */
end_comment
begin_function
DECL|function|topLevelParentWinId
name|WId
name|QX11EmbedContainerPrivate
operator|::
name|topLevelParentWinId
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|QHackWidget
operator|*
operator|)
name|q
operator|->
name|window
argument_list|()
operator|)
operator|->
name|topData
argument_list|()
operator|->
name|parentWinId
return|;
block|}
end_function
begin_comment
comment|/*!     If the container has an embedded widget, this function returns     the X11 window ID of the client; otherwise it returns 0. */
end_comment
begin_function
DECL|function|clientWinId
name|WId
name|QX11EmbedContainer
operator|::
name|clientWinId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|client
return|;
block|}
end_function
begin_comment
comment|/*!     Instructs the container to embed the X11 window with window ID \a     id. The client widget will then move on top of the container     window and be resized to fit into the container.      The \a id should be the ID of a window controlled by an XEmbed     enabled application, but this is not mandatory. If \a id does not     belong to an XEmbed client widget, then focus handling,     activation, accelerators and other features will not work     properly. */
end_comment
begin_function
DECL|function|embedClient
name|void
name|QX11EmbedContainer
operator|::
name|embedClient
parameter_list|(
name|WId
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Walk up the tree of parent windows to prevent embedding of ancestors.
name|WId
name|thisId
init|=
name|internalWinId
argument_list|()
decl_stmt|;
name|Window
name|rootReturn
decl_stmt|;
name|Window
name|parentReturn
decl_stmt|;
name|Window
modifier|*
name|childrenReturn
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nchildrenReturn
decl_stmt|;
do|do
block|{
if|if
condition|(
name|XQueryTree
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|thisId
argument_list|,
operator|&
name|rootReturn
argument_list|,
operator|&
name|parentReturn
argument_list|,
operator|&
name|childrenReturn
argument_list|,
operator|&
name|nchildrenReturn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|childrenReturn
condition|)
block|{
name|XFree
argument_list|(
name|childrenReturn
argument_list|)
expr_stmt|;
name|childrenReturn
operator|=
literal|0
expr_stmt|;
block|}
name|thisId
operator|=
name|parentReturn
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|thisId
condition|)
block|{
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|thisId
operator|!=
name|rootReturn
condition|)
do|;
comment|// watch for property notify events (see below)
name|XGrabServer
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|)
expr_stmt|;
name|XWindowAttributes
name|attrib
decl_stmt|;
if|if
condition|(
operator|!
name|XGetWindowAttributes
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|id
argument_list|,
operator|&
name|attrib
argument_list|)
condition|)
block|{
name|XUngrabServer
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
return|return;
block|}
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|id
argument_list|,
name|attrib
operator|.
name|your_event_mask
operator||
name|PropertyChangeMask
operator||
name|StructureNotifyMask
argument_list|)
expr_stmt|;
name|XUngrabServer
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|)
expr_stmt|;
comment|// Put the window into WithdrawnState
name|XUnmapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|False
argument_list|)
expr_stmt|;
comment|// make sure the window is hidden
comment|/*       Wait for notification from the window manager that the window is       in withdrawn state.  According to the ICCCM section 4.1.3.1,       we should wait for the WM_STATE property to either be deleted or       set to WithdrawnState.        For safety, we will not wait more than 500 ms, so that we can       preemptively workaround buggy window managers.     */
name|QElapsedTimer
name|t
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
name|functorData
name|data
decl_stmt|;
name|data
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|data
operator|.
name|rootWindow
operator|=
name|attrib
operator|.
name|root
expr_stmt|;
name|data
operator|.
name|clearedWmState
operator|=
literal|false
expr_stmt|;
name|data
operator|.
name|reparentedToRoot
operator|=
literal|false
expr_stmt|;
do|do
block|{
if|if
condition|(
name|t
operator|.
name|elapsed
argument_list|()
operator|>
literal|500
condition|)
comment|// time-out after 500 ms
break|break;
name|XEvent
name|event
decl_stmt|;
if|if
condition|(
operator|!
name|XCheckIfEvent
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
operator|&
name|event
argument_list|,
name|functor
argument_list|,
operator|(
name|XPointer
operator|)
operator|&
name|data
argument_list|)
condition|)
block|{
name|XSync
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|qApp
operator|->
name|x11ProcessEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|data
operator|.
name|clearedWmState
operator|||
operator|!
name|data
operator|.
name|reparentedToRoot
condition|)
do|;
comment|// restore the event mask
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|id
argument_list|,
name|attrib
operator|.
name|your_event_mask
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XReparentWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|id
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|BadWindow
case|:
case|case
name|BadMatch
case|:
name|d
operator|->
name|emitError
argument_list|(
name|InvalidWindowID
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Handles key, activation and focus events for the container. */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QX11EmbedContainer
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|KeyPress
case|:
comment|// Forward any keypresses to our client.
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
condition|)
block|{
name|lastKeyEvent
operator|.
name|window
operator|=
name|d
operator|->
name|client
expr_stmt|;
name|XSendEvent
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
literal|false
argument_list|,
name|KeyPressMask
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|lastKeyEvent
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
comment|// Forward any keyreleases to our client.
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
condition|)
block|{
name|lastKeyEvent
operator|.
name|window
operator|=
name|d
operator|->
name|client
expr_stmt|;
name|XSendEvent
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
literal|false
argument_list|,
name|KeyReleaseMask
argument_list|,
operator|(
name|XEvent
operator|*
operator|)
operator|&
name|lastKeyEvent
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
comment|// When our container window is activated, we pass the
comment|// activation message on to our client. Note that X input
comment|// focus is set to our focus proxy. We want to intercept all
comment|// keypresses.
if|if
condition|(
name|o
operator|==
name|window
argument_list|()
operator|&&
name|d
operator|->
name|client
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|clientIsXEmbed
condition|)
block|{
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_WINDOW_ACTIVATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|checkGrab
argument_list|()
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
name|XSetInputFocus
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|XRevertToParent
argument_list|,
name|x11Time
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
name|d
operator|->
name|moveInputToProxy
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
comment|// When our container window is deactivated, we pass the
comment|// deactivation message to our client.
if|if
condition|(
name|o
operator|==
name|window
argument_list|()
operator|&&
name|d
operator|->
name|client
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|clientIsXEmbed
condition|)
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_WINDOW_DEACTIVATE
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|checkGrab
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|FocusIn
case|:
comment|// When receiving FocusIn events generated by Tab or Backtab,
comment|// we pass focus on to our client. Any mouse activity is sent
comment|// directly to the client, and it will ask us for focus with
comment|// XEMBED_REQUEST_FOCUS.
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
name|d
operator|->
name|activeContainer
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clientIsXEmbed
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
name|d
operator|->
name|moveInputToProxy
argument_list|()
expr_stmt|;
name|QFocusEvent
modifier|*
name|fe
init|=
operator|(
name|QFocusEvent
operator|*
operator|)
name|event
decl_stmt|;
switch|switch
condition|(
name|fe
operator|->
name|reason
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|TabFocusReason
case|:
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_IN
argument_list|,
name|XEMBED_FOCUS_FIRST
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|BacktabFocusReason
case|:
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_IN
argument_list|,
name|XEMBED_FOCUS_LAST
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_IN
argument_list|,
name|XEMBED_FOCUS_CURRENT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|d
operator|->
name|checkGrab
argument_list|()
expr_stmt|;
name|XSetInputFocus
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|XRevertToParent
argument_list|,
name|x11Time
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|FocusOut
case|:
block|{
comment|// When receiving a FocusOut, we ask our client to remove its
comment|// focus.
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
block|{
name|d
operator|->
name|activeContainer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
name|d
operator|->
name|moveInputToProxy
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|clientIsXEmbed
condition|)
block|{
name|QFocusEvent
modifier|*
name|fe
init|=
operator|(
name|QFocusEvent
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
operator|&&
name|fe
operator|->
name|reason
argument_list|()
operator|!=
name|Qt
operator|::
name|ActiveWindowFocusReason
condition|)
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_OUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|checkGrab
argument_list|()
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|Close
case|:
block|{
if|if
condition|(
name|o
operator|==
name|this
operator|&&
name|d
operator|->
name|client
condition|)
block|{
comment|// Unmap the client and reparent it to the root window.
comment|// Wait until the messages have been processed. Then ask
comment|// the window manager to delete the window.
name|XUnmapWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|)
expr_stmt|;
name|XReparentWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|XEvent
name|ev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|ev
operator|.
name|xclient
operator|.
name|type
operator|=
name|ClientMessage
expr_stmt|;
name|ev
operator|.
name|xclient
operator|.
name|window
operator|=
name|d
operator|->
name|client
expr_stmt|;
name|ev
operator|.
name|xclient
operator|.
name|message_type
operator|=
name|ATOM
argument_list|(
name|WM_PROTOCOLS
argument_list|)
expr_stmt|;
name|ev
operator|.
name|xclient
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|ev
operator|.
name|xclient
operator|.
name|data
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|ATOM
argument_list|(
name|WM_DELETE_WINDOW
argument_list|)
expr_stmt|;
name|XSendEvent
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
literal|false
argument_list|,
name|NoEventMask
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|client
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clientIsXEmbed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|wmMinimumSizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|clientClosed
argument_list|()
emit|;
block|}
block|}
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|eventFilter
argument_list|(
name|o
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Handles X11 events for the container. */
end_comment
begin_function
DECL|function|x11Event
name|bool
name|QX11EmbedContainer
operator|::
name|x11Event
parameter_list|(
name|XEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
case|case
name|CreateNotify
case|:
comment|// The client created an embedded window.
if|if
condition|(
name|d
operator|->
name|client
condition|)
name|d
operator|->
name|rejectClient
argument_list|(
name|event
operator|->
name|xcreatewindow
operator|.
name|window
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|acceptClient
argument_list|(
name|event
operator|->
name|xcreatewindow
operator|.
name|window
argument_list|)
expr_stmt|;
break|break;
case|case
name|DestroyNotify
case|:
if|if
condition|(
name|event
operator|->
name|xdestroywindow
operator|.
name|window
operator|==
name|d
operator|->
name|client
condition|)
block|{
comment|// The client died.
name|d
operator|->
name|client
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clientIsXEmbed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|wmMinimumSizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
emit|emit
name|clientClosed
argument_list|()
emit|;
block|}
break|break;
case|case
name|ReparentNotify
case|:
comment|// The client sends us this if it reparents itself out of our
comment|// widget.
if|if
condition|(
name|event
operator|->
name|xreparent
operator|.
name|window
operator|==
name|d
operator|->
name|client
operator|&&
name|event
operator|->
name|xreparent
operator|.
name|parent
operator|!=
name|internalWinId
argument_list|()
condition|)
block|{
name|d
operator|->
name|client
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clientIsXEmbed
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|wmMinimumSizeHint
operator|=
name|QSize
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
emit|emit
name|clientClosed
argument_list|()
emit|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|xreparent
operator|.
name|parent
operator|==
name|internalWinId
argument_list|()
condition|)
block|{
comment|// The client reparented itself into this window.
if|if
condition|(
name|d
operator|->
name|client
condition|)
name|d
operator|->
name|rejectClient
argument_list|(
name|event
operator|->
name|xreparent
operator|.
name|window
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|acceptClient
argument_list|(
name|event
operator|->
name|xreparent
operator|.
name|window
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ClientMessage
case|:
block|{
if|if
condition|(
name|event
operator|->
name|xclient
operator|.
name|message_type
operator|==
name|ATOM
argument_list|(
name|_XEMBED
argument_list|)
condition|)
block|{
comment|// Ignore XEMBED messages not to ourselves
if|if
condition|(
name|event
operator|->
name|xclient
operator|.
name|window
operator|!=
name|internalWinId
argument_list|()
condition|)
break|break;
comment|// Receiving an XEmbed message means the client
comment|// is an XEmbed client.
name|d
operator|->
name|clientIsXEmbed
operator|=
literal|true
expr_stmt|;
name|Time
name|msgtime
init|=
operator|(
name|Time
operator|)
name|event
operator|->
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|msgtime
operator|>
name|X11
operator|->
name|time
condition|)
name|X11
operator|->
name|time
operator|=
name|msgtime
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|1
index|]
condition|)
block|{
case|case
name|XEMBED_REQUEST_FOCUS
case|:
block|{
comment|// This typically happens when the client gets focus
comment|// because of a mouse click.
if|if
condition|(
operator|!
name|hasFocus
argument_list|()
condition|)
name|setFocus
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
comment|// The message is passed along to the topmost container
comment|// that eventually responds with a XEMBED_FOCUS_IN
comment|// message. The focus in message is passed all the way
comment|// back until it reaches the original focus
comment|// requestor. In the end, not only the original client
comment|// has focus, but also all its ancestor containers.
if|if
condition|(
name|d
operator|->
name|isEmbedded
argument_list|()
condition|)
block|{
comment|// If our window's embedded flag is set, then
comment|// that suggests that we are part of a client. The
comment|// parentWinId will then point to an container to whom
comment|// we must pass this message.
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|topLevelParentWinId
argument_list|()
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_REQUEST_FOCUS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Our window's embedded flag is not set,
comment|// so we are the topmost container. We respond to
comment|// the focus request message with a focus in
comment|// message. This message will pass on from client
comment|// to container to client until it reaches the
comment|// originator of the XEMBED_REQUEST_FOCUS message.
name|sendXEmbedMessage
argument_list|(
name|d
operator|->
name|client
argument_list|,
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_IN
argument_list|,
name|XEMBED_FOCUS_CURRENT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XEMBED_FOCUS_NEXT
case|:
comment|// Client sends this event when it received a tab
comment|// forward and was at the end of its focus chain. If
comment|// we are the only widget in the focus chain, we send
comment|// ourselves a FocusIn event.
if|if
condition|(
name|d
operator|->
name|focus_next
operator|!=
name|this
condition|)
block|{
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|TabFocusReason
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XEMBED_FOCUS_PREV
case|:
comment|// Client sends this event when it received a backtab
comment|// and was at the start of its focus chain. If we are
comment|// the only widget in the focus chain, we send
comment|// ourselves a FocusIn event.
if|if
condition|(
name|d
operator|->
name|focus_next
operator|!=
name|this
condition|)
block|{
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
decl_stmt|;
name|qApp
operator|->
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
break|break;
case|case
name|XButtonPress
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|clientIsXEmbed
condition|)
block|{
name|setFocus
argument_list|(
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
name|XAllowEvents
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|ReplayPointer
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|XButtonRelease
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|clientIsXEmbed
condition|)
name|XAllowEvents
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|SyncPointer
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|QWidget
operator|::
name|x11Event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Whenever the container is resized, we need to resize our client. */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QX11EmbedContainer
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|client
condition|)
name|XResizeWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      We use the QShowEvent to signal to our client that we want it to     map itself. We do this by changing its window property     XEMBED_INFO. The client will get an X11 PropertyNotify. */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QX11EmbedContainer
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|client
condition|)
block|{
name|long
name|data
index|[]
init|=
block|{
name|XEMBED_VERSION
block|,
name|XEMBED_MAPPED
block|}
decl_stmt|;
name|XChangeProperty
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
literal|32
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      We use the QHideEvent to signal to our client that we want it to     unmap itself. We do this by changing its window property     XEMBED_INFO. The client will get an X11 PropertyNotify. */
end_comment
begin_function
DECL|function|hideEvent
name|void
name|QX11EmbedContainer
operator|::
name|hideEvent
parameter_list|(
name|QHideEvent
modifier|*
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|client
condition|)
block|{
name|long
name|data
index|[]
init|=
block|{
name|XEMBED_VERSION
block|,
name|XEMBED_MAPPED
block|}
decl_stmt|;
name|XChangeProperty
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
literal|32
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QX11EmbedContainer
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ParentChange
condition|)
block|{
name|XSelectInput
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|internalWinId
argument_list|()
argument_list|,
name|KeyPressMask
operator||
name|KeyReleaseMask
operator||
name|ButtonPressMask
operator||
name|ButtonReleaseMask
operator||
name|ButtonMotionMask
operator||
name|KeymapStateMask
operator||
name|PointerMotionMask
operator||
name|EnterWindowMask
operator||
name|LeaveWindowMask
operator||
name|FocusChangeMask
operator||
name|ExposureMask
operator||
name|StructureNotifyMask
operator||
name|SubstructureNotifyMask
argument_list|)
expr_stmt|;
block|}
return|return
name|QWidget
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Rejects a client window by reparenting it to the root window.  The     client will receive a reparentnotify, and will most likely assume     that the container has shut down. The XEmbed protocol does not     define any way to reject a client window, but this is a clean way     to do it. */
end_comment
begin_function
DECL|function|rejectClient
name|void
name|QX11EmbedContainerPrivate
operator|::
name|rejectClient
parameter_list|(
name|WId
name|window
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
name|q
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|XRemoveFromSaveSet
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|XReparentWindow
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|window
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|appRootWindow
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Accepts a client by mapping it, resizing it and optionally     activating and giving it logical focusing through XEMBED messages. */
end_comment
begin_function
DECL|function|acceptClient
name|void
name|QX11EmbedContainerPrivate
operator|::
name|acceptClient
parameter_list|(
name|WId
name|window
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
name|client
operator|=
name|window
expr_stmt|;
name|q
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// This tells Qt that we wish to forward DnD messages to
comment|// our client.
if|if
condition|(
operator|!
name|extra
condition|)
name|createExtra
argument_list|()
expr_stmt|;
name|extraData
argument_list|()
operator|->
name|xDndProxy
operator|=
name|client
expr_stmt|;
name|unsigned
name|int
name|version
init|=
name|XEmbedVersion
argument_list|()
decl_stmt|;
name|Atom
name|actual_type_return
decl_stmt|;
name|int
name|actual_format_return
decl_stmt|;
name|unsigned
name|long
name|nitems_return
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|bytes_after_return
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prop_return
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|clientversion
init|=
literal|0
decl_stmt|;
comment|// Add this client to our saveset, so if we crash, the client window
comment|// doesn't get destroyed. This is useful for containers that restart
comment|// automatically after a crash, because it can simply reembed its clients
comment|// without having to restart them (KDE panel).
name|XAddToSaveSet
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|// XEmbed clients have an _XEMBED_INFO property in which we can
comment|// fetch the version
if|if
condition|(
name|XGetWindowProperty
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|false
argument_list|,
name|ATOM
argument_list|(
name|_XEMBED_INFO
argument_list|)
argument_list|,
operator|&
name|actual_type_return
argument_list|,
operator|&
name|actual_format_return
argument_list|,
operator|&
name|nitems_return
argument_list|,
operator|&
name|bytes_after_return
argument_list|,
operator|&
name|prop_return
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
name|actual_type_return
operator|!=
name|None
operator|&&
name|actual_format_return
operator|!=
literal|0
condition|)
block|{
comment|// Clients with the _XEMBED_INFO property are XEMBED clients.
name|clientIsXEmbed
operator|=
literal|true
expr_stmt|;
name|long
modifier|*
name|p
init|=
operator|(
name|long
operator|*
operator|)
name|prop_return
decl_stmt|;
if|if
condition|(
name|nitems_return
operator|>=
literal|2
condition|)
name|clientversion
operator|=
operator|(
name|unsigned
name|int
operator|)
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
name|XFree
argument_list|(
name|prop_return
argument_list|)
expr_stmt|;
block|}
comment|// Store client window's original size and placement.
name|Window
name|root
decl_stmt|;
name|int
name|x_return
decl_stmt|,
name|y_return
decl_stmt|;
name|unsigned
name|int
name|width_return
decl_stmt|,
name|height_return
decl_stmt|,
name|border_width_return
decl_stmt|,
name|depth_return
decl_stmt|;
name|XGetGeometry
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|x_return
argument_list|,
operator|&
name|y_return
argument_list|,
operator|&
name|width_return
argument_list|,
operator|&
name|height_return
argument_list|,
operator|&
name|border_width_return
argument_list|,
operator|&
name|depth_return
argument_list|)
expr_stmt|;
name|clientOriginalRect
operator|.
name|setCoords
argument_list|(
name|x_return
argument_list|,
name|y_return
argument_list|,
name|x_return
operator|+
name|width_return
operator|-
literal|1
argument_list|,
name|y_return
operator|+
name|height_return
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Ask the client for its minimum size.
name|XSizeHints
name|size
decl_stmt|;
name|long
name|msize
decl_stmt|;
if|if
condition|(
name|XGetWMNormalHints
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|msize
argument_list|)
operator|&&
operator|(
name|size
operator|.
name|flags
operator|&
name|PMinSize
operator|)
condition|)
block|{
name|wmMinimumSizeHint
operator|=
name|QSize
argument_list|(
name|size
operator|.
name|min_width
argument_list|,
name|size
operator|.
name|min_height
argument_list|)
expr_stmt|;
name|q
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
comment|// The container should set the data2 field to the lowest of its
comment|// supported version number and that of the client (from
comment|// _XEMBED_INFO property).
name|unsigned
name|int
name|minversion
init|=
name|version
operator|>
name|clientversion
condition|?
name|clientversion
else|:
name|version
decl_stmt|;
name|sendXEmbedMessage
argument_list|(
name|client
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_EMBEDDED_NOTIFY
argument_list|,
name|q
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|minversion
argument_list|)
expr_stmt|;
name|XMapWindow
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|// Resize it, but no smaller than its minimum size hint.
name|XResizeWindow
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|,
name|qMax
argument_list|(
name|q
operator|->
name|width
argument_list|()
argument_list|,
name|wmMinimumSizeHint
operator|.
name|width
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|q
operator|->
name|height
argument_list|()
argument_list|,
name|wmMinimumSizeHint
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
comment|// Not mentioned in the protocol is that if the container
comment|// is already active, the client must be activated to work
comment|// properly.
if|if
condition|(
name|q
operator|->
name|window
argument_list|()
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|sendXEmbedMessage
argument_list|(
name|client
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_WINDOW_ACTIVATE
argument_list|)
expr_stmt|;
comment|// Also, if the container already has focus, then it must
comment|// send a focus in message to its new client; otherwise we ask
comment|// it to remove focus.
if|if
condition|(
name|q
operator|->
name|focusWidget
argument_list|()
operator|==
name|q
operator|&&
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
name|sendXEmbedMessage
argument_list|(
name|client
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_IN
argument_list|,
name|XEMBED_FOCUS_FIRST
argument_list|)
expr_stmt|;
else|else
name|sendXEmbedMessage
argument_list|(
name|client
argument_list|,
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|XEMBED_FOCUS_OUT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clientIsXEmbed
condition|)
block|{
name|checkGrab
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
name|XSetInputFocus
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|client
argument_list|,
name|XRevertToParent
argument_list|,
name|x11Time
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isEmbedded
argument_list|()
condition|)
name|moveInputToProxy
argument_list|()
expr_stmt|;
block|}
emit|emit
name|q
operator|->
name|clientIsEmbedded
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*! \internal      Moves X11 keyboard input focus to the focusProxy, unless the focus     is there already. When X11 keyboard input focus is on the     focusProxy, which is a child of the container and a sibling of the     client, X11 keypresses and keyreleases will always go to the proxy     and not to the client. */
end_comment
begin_function
DECL|function|moveInputToProxy
name|void
name|QX11EmbedContainerPrivate
operator|::
name|moveInputToProxy
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
comment|// Following Owen Taylor's advice from the XEmbed specification to
comment|// always use CurrentTime when no explicit user action is involved.
name|XSetInputFocus
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|focusProxy
operator|->
name|internalWinId
argument_list|()
argument_list|,
name|XRevertToParent
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Ask the window manager to give us a default minimum size. */
end_comment
begin_function
DECL|function|minimumSizeHint
name|QSize
name|QX11EmbedContainer
operator|::
name|minimumSizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|client
operator|||
operator|!
name|d
operator|->
name|wmMinimumSizeHint
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QWidget
operator|::
name|minimumSizeHint
argument_list|()
return|;
return|return
name|d
operator|->
name|wmMinimumSizeHint
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|checkGrab
name|void
name|QX11EmbedContainerPrivate
operator|::
name|checkGrab
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clientIsXEmbed
operator|&&
name|q
operator|->
name|isActiveWindow
argument_list|()
operator|&&
operator|!
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|xgrab
condition|)
block|{
name|XGrabButton
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|AnyButton
argument_list|,
name|AnyModifier
argument_list|,
name|q
operator|->
name|internalWinId
argument_list|()
argument_list|,
literal|true
argument_list|,
name|ButtonPressMask
argument_list|,
name|GrabModeSync
argument_list|,
name|GrabModeAsync
argument_list|,
name|None
argument_list|,
name|None
argument_list|)
expr_stmt|;
block|}
name|xgrab
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xgrab
condition|)
name|XUngrabButton
argument_list|(
name|q
operator|->
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|AnyButton
argument_list|,
name|AnyModifier
argument_list|,
name|q
operator|->
name|internalWinId
argument_list|()
argument_list|)
expr_stmt|;
name|xgrab
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Detaches the client from the embedder. The client will appear as a     standalone window on the desktop. */
end_comment
begin_function
DECL|function|discardClient
name|void
name|QX11EmbedContainer
operator|::
name|discardClient
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QX11EmbedContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|client
condition|)
block|{
name|XResizeWindow
argument_list|(
name|x11Info
argument_list|()
operator|.
name|display
argument_list|()
argument_list|,
name|d
operator|->
name|client
argument_list|,
name|d
operator|->
name|clientOriginalRect
operator|.
name|width
argument_list|()
argument_list|,
name|d
operator|->
name|clientOriginalRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|rejectClient
argument_list|(
name|d
operator|->
name|client
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
