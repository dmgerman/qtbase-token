begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qtransform.h"
end_include
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_cocoa_helpers_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
comment|/*****************************************************************************   Externals  *****************************************************************************/
specifier|extern
specifier|const
name|uchar
modifier|*
name|qt_get_bitflip_array
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qimage.cpp
end_comment
begin_function_decl
specifier|extern
name|CGContextRef
name|qt_mac_cg_context
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//qpaintdevice_mac.cpp
end_comment
begin_function_decl
specifier|extern
name|RgnHandle
name|qt_mac_get_rgn
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|//qregion_mac.cpp
end_comment
begin_function_decl
specifier|extern
name|void
name|qt_mac_dispose_rgn
parameter_list|(
name|RgnHandle
name|r
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//qregion_mac.cpp
end_comment
begin_function_decl
specifier|extern
name|QRegion
name|qt_mac_convert_mac_region
parameter_list|(
name|RgnHandle
name|rgn
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|//qregion_mac.cpp
end_comment
begin_decl_stmt
DECL|variable|qt_pixmap_serial
specifier|static
name|int
name|qt_pixmap_serial
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_mac_pixmap_get_base
name|Q_WIDGETS_EXPORT
name|quint32
modifier|*
name|qt_mac_pixmap_get_base
parameter_list|(
specifier|const
name|QPixmap
modifier|*
name|pix
parameter_list|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|==
name|QLatin1String
argument_list|(
literal|"raster"
argument_list|)
condition|)
return|return
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|QRasterPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pix
operator|->
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|buffer
argument_list|()
operator|->
name|bits
argument_list|()
argument_list|)
return|;
else|else
return|return
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pix
operator|->
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|pixels
return|;
block|}
end_function
begin_function
DECL|function|qt_mac_pixmap_get_bytes_per_line
name|Q_WIDGETS_EXPORT
name|int
name|qt_mac_pixmap_get_bytes_per_line
parameter_list|(
specifier|const
name|QPixmap
modifier|*
name|pix
parameter_list|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|==
name|QLatin1String
argument_list|(
literal|"raster"
argument_list|)
condition|)
return|return
cast|static_cast
argument_list|<
name|QRasterPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pix
operator|->
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|buffer
argument_list|()
operator|->
name|bytesPerLine
argument_list|()
return|;
else|else
return|return
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pix
operator|->
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|bytesPerRow
return|;
block|}
end_function
begin_function
DECL|function|qt_mac_cgimage_data_free
name|void
name|qt_mac_cgimage_data_free
parameter_list|(
name|void
modifier|*
name|info
parameter_list|,
specifier|const
name|void
modifier|*
name|memoryToFree
parameter_list|,
name|size_t
parameter_list|)
block|{
name|QMacPlatformPixmap
modifier|*
name|pmdata
init|=
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pmdata
condition|)
block|{
name|free
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|memoryToFree
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|QMacPlatformPixmap
operator|::
name|validDataPointers
operator|.
name|contains
argument_list|(
name|pmdata
argument_list|)
operator|==
literal|false
condition|)
block|{
name|free
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|memoryToFree
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pmdata
operator|->
name|pixels
operator|==
name|pmdata
operator|->
name|pixelsToFree
condition|)
block|{
comment|// something we aren't expecting, just free it.
name|Q_ASSERT
argument_list|(
name|memoryToFree
operator|!=
name|pmdata
operator|->
name|pixelsToFree
argument_list|)
expr_stmt|;
name|free
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|memoryToFree
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|pmdata
operator|->
name|pixelsToFree
argument_list|)
expr_stmt|;
name|pmdata
operator|->
name|pixelsToFree
operator|=
cast|static_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|memoryToFree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pmdata
operator|->
name|cg_dataBeingReleased
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPixmap member functions  *****************************************************************************/
end_comment
begin_function
DECL|function|qt_conv16ToRgb
specifier|static
specifier|inline
name|QRgb
name|qt_conv16ToRgb
parameter_list|(
name|ushort
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|qt_rbits
init|=
operator|(
literal|565
operator|/
literal|100
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_gbits
init|=
operator|(
literal|565
operator|/
literal|10
operator|%
literal|10
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_bbits
init|=
operator|(
literal|565
operator|%
literal|10
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_red_shift
init|=
name|qt_bbits
operator|+
name|qt_gbits
operator|-
operator|(
literal|8
operator|-
name|qt_rbits
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_green_shift
init|=
name|qt_bbits
operator|-
operator|(
literal|8
operator|-
name|qt_gbits
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_neg_blue_shift
init|=
literal|8
operator|-
name|qt_bbits
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_blue_mask
init|=
operator|(
literal|1
operator|<<
name|qt_bbits
operator|)
operator|-
literal|1
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_green_mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|qt_gbits
operator|+
name|qt_bbits
operator|)
operator|)
operator|-
operator|(
operator|(
literal|1
operator|<<
name|qt_bbits
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
specifier|static
specifier|const
name|int
name|qt_red_mask
init|=
operator|(
literal|1
operator|<<
operator|(
name|qt_rbits
operator|+
name|qt_gbits
operator|+
name|qt_bbits
operator|)
operator|)
operator|-
operator|(
literal|1
operator|<<
operator|(
name|qt_gbits
operator|+
name|qt_bbits
operator|)
operator|)
decl_stmt|;
specifier|const
name|int
name|r
init|=
operator|(
name|c
operator|&
name|qt_red_mask
operator|)
decl_stmt|;
specifier|const
name|int
name|g
init|=
operator|(
name|c
operator|&
name|qt_green_mask
operator|)
decl_stmt|;
specifier|const
name|int
name|b
init|=
operator|(
name|c
operator|&
name|qt_blue_mask
operator|)
decl_stmt|;
specifier|const
name|int
name|tr
init|=
name|r
operator|>>
name|qt_red_shift
decl_stmt|;
specifier|const
name|int
name|tg
init|=
name|g
operator|>>
name|qt_green_shift
decl_stmt|;
specifier|const
name|int
name|tb
init|=
name|b
operator|<<
name|qt_neg_blue_shift
decl_stmt|;
return|return
name|qRgb
argument_list|(
name|tr
argument_list|,
name|tg
argument_list|,
name|tb
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|member|validDataPointers
name|QSet
argument_list|<
name|QMacPlatformPixmap
modifier|*
argument_list|>
name|QMacPlatformPixmap
operator|::
name|validDataPointers
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QMacPlatformPixmap
name|QMacPlatformPixmap
operator|::
name|QMacPlatformPixmap
parameter_list|(
name|PixelType
name|type
parameter_list|)
member_init_list|:
name|QPlatformPixmap
argument_list|(
name|type
argument_list|,
name|MacClass
argument_list|)
member_init_list|,
name|has_alpha
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|has_mask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|uninit
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|pixels
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pixelsSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pixelsToFree
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesPerRow
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cg_data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cg_dataBeingReleased
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cg_mask
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|createCompatiblePlatformPixmap
name|QPlatformPixmap
modifier|*
name|QMacPlatformPixmap
operator|::
name|createCompatiblePlatformPixmap
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QMacPlatformPixmap
argument_list|(
name|pixelType
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|BEST_BYTE_ALIGNMENT
define|#
directive|define
name|BEST_BYTE_ALIGNMENT
value|16
end_define
begin_define
DECL|macro|COMPTUE_BEST_BYTES_PER_ROW
define|#
directive|define
name|COMPTUE_BEST_BYTES_PER_ROW
parameter_list|(
name|bpr
parameter_list|)
define|\
value|(((bpr) + (BEST_BYTE_ALIGNMENT - 1))& ~(BEST_BYTE_ALIGNMENT - 1))
end_define
begin_function
DECL|function|resize
name|void
name|QMacPlatformPixmap
operator|::
name|resize
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|setSerialNumber
argument_list|(
operator|++
name|qt_pixmap_serial
argument_list|)
expr_stmt|;
name|w
operator|=
name|width
expr_stmt|;
name|h
operator|=
name|height
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|?
literal|1
else|:
literal|32
operator|)
expr_stmt|;
name|bool
name|make_null
init|=
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
decl_stmt|;
comment|// create null pixmap
if|if
condition|(
name|make_null
operator|||
name|d
operator|==
literal|0
condition|)
block|{
name|w
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|is_null
operator|=
literal|true
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|make_null
condition|)
name|qWarning
argument_list|(
literal|"Qt: QPixmap: Invalid pixmap parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|w
operator|<
literal|1
operator|||
name|h
operator|<
literal|1
condition|)
return|return;
comment|//create the pixels
name|bytesPerRow
operator|=
name|w
operator|*
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
comment|// Minimum bytes per row.
comment|// Quartz2D likes things as a multple of 16 (for now).
name|bytesPerRow
operator|=
name|COMPTUE_BEST_BYTES_PER_ROW
argument_list|(
name|bytesPerRow
argument_list|)
expr_stmt|;
name|macCreatePixels
argument_list|()
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|COMPUTE_BEST_BYTES_PER_ROW
undef|#
directive|undef
name|COMPUTE_BEST_BYTES_PER_ROW
end_undef
begin_function
DECL|function|fromImage
name|void
name|QMacPlatformPixmap
operator|::
name|fromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|setSerialNumber
argument_list|(
operator|++
name|qt_pixmap_serial
argument_list|)
expr_stmt|;
comment|// the conversion code only handles format>=
comment|// Format_ARGB32_Premultiplied at the moment..
if|if
condition|(
name|img
operator|.
name|format
argument_list|()
operator|>
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
block|{
name|QImage
name|image
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|image
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
else|else
name|image
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|w
operator|=
name|img
operator|.
name|width
argument_list|()
expr_stmt|;
name|h
operator|=
name|img
operator|.
name|height
argument_list|()
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|?
literal|1
else|:
name|img
operator|.
name|depth
argument_list|()
operator|)
expr_stmt|;
name|QImage
name|image
init|=
name|img
decl_stmt|;
name|int
name|dd
init|=
name|QPixmap
operator|::
name|defaultDepth
argument_list|()
decl_stmt|;
name|bool
name|force_mono
init|=
operator|(
name|dd
operator|==
literal|1
operator|||
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ColorMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|MonoOnly
operator|)
decl_stmt|;
if|if
condition|(
name|force_mono
condition|)
block|{
comment|// must be monochrome
if|if
condition|(
name|d
operator|!=
literal|1
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|// dither
name|d
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// can be both
name|bool
name|conv8
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|8
operator|&&
name|dd
operator|<=
literal|8
condition|)
block|{
comment|// convert to 8 bit
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|AutoDither
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator||
name|Qt
operator|::
name|PreferDither
expr_stmt|;
name|conv8
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|ColorMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|ColorOnly
condition|)
block|{
name|conv8
operator|=
name|d
operator|==
literal|1
expr_stmt|;
comment|// native depth wanted
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|QRgb
name|c0
init|=
name|image
operator|.
name|color
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Auto: convert to best
name|QRgb
name|c1
init|=
name|image
operator|.
name|color
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|conv8
operator|=
name|qMin
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|!=
name|qRgb
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|||
name|qMax
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|!=
name|qRgb
argument_list|(
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// eg. 1-color monochrome images (they do exist).
name|conv8
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conv8
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_Indexed8
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|d
operator|=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|image
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|16
operator|||
name|d
operator|==
literal|24
condition|)
block|{
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// different size or depth, make a new pixmap
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|quint32
modifier|*
name|dptr
init|=
name|pixels
decl_stmt|,
modifier|*
name|drow
decl_stmt|;
specifier|const
name|uint
name|dbpr
init|=
name|bytesPerRow
decl_stmt|;
specifier|const
name|QImage
operator|::
name|Format
name|sfmt
init|=
name|image
operator|.
name|format
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|short
name|sbpr
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
comment|// use const_cast to prevent a detach
specifier|const
name|uchar
modifier|*
name|sptr
init|=
cast|const_cast
argument_list|<
specifier|const
name|QImage
operator|&
argument_list|>
argument_list|(
name|image
argument_list|)
operator|.
name|bits
argument_list|()
decl_stmt|,
modifier|*
name|srow
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|drow
operator|=
name|dptr
operator|+
operator|(
name|y
operator|*
operator|(
name|dbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
name|sbpr
operator|)
expr_stmt|;
switch|switch
condition|(
name|sfmt
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
case|case
name|QImage
operator|::
name|Format_Mono
case|:
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|char
name|one_bit
init|=
operator|*
operator|(
name|srow
operator|+
operator|(
name|x
operator|/
literal|8
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|sfmt
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
name|one_bit
operator|=
name|one_bit
operator|>>
operator|(
literal|7
operator|-
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
else|else
name|one_bit
operator|=
name|one_bit
operator|>>
operator|(
name|x
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|one_bit
operator|&
literal|0x01
operator|)
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0xFF000000
expr_stmt|;
else|else
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
block|{
name|int
name|numColors
init|=
name|image
operator|.
name|numColors
argument_list|()
decl_stmt|;
if|if
condition|(
name|numColors
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|index
init|=
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
decl_stmt|;
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|PREMUL
argument_list|(
name|image
operator|.
name|color
argument_list|(
name|qMin
argument_list|(
name|index
argument_list|,
name|numColors
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|*
operator|(
operator|(
operator|(
name|quint32
operator|*
operator|)
name|srow
operator|)
operator|+
name|x
operator|)
operator||
literal|0xFF000000
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|sfmt
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0xFF000000
operator||
operator|(
operator|*
operator|(
operator|(
operator|(
name|quint32
operator|*
operator|)
name|srow
operator|)
operator|+
name|x
operator|)
operator|&
literal|0x00FFFFFF
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sfmt
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|*
operator|(
operator|(
operator|(
name|quint32
operator|*
operator|)
name|srow
operator|)
operator|+
name|x
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|PREMUL
argument_list|(
operator|*
operator|(
operator|(
operator|(
name|quint32
operator|*
operator|)
name|srow
operator|)
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|qWarning
argument_list|(
literal|"Qt: internal: Oops: Forgot a format [%d] %s:%d"
argument_list|,
name|sfmt
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sfmt
operator|!=
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
comment|//setup the alpha
name|bool
name|alphamap
init|=
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|32
decl_stmt|;
if|if
condition|(
name|sfmt
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|rgb
init|=
name|image
operator|.
name|colorTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|image
operator|.
name|colorCount
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|alpha
init|=
name|qAlpha
argument_list|(
name|rgb
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|alpha
operator|!=
literal|0xff
condition|)
block|{
name|alphamap
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|macSetHasAlpha
argument_list|(
name|alphamap
argument_list|)
expr_stmt|;
block|}
name|uninit
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_index
name|int
name|get_index
parameter_list|(
name|QImage
modifier|*
name|qi
parameter_list|,
name|QRgb
name|mycol
parameter_list|)
block|{
name|int
name|loopc
decl_stmt|;
for|for
control|(
name|loopc
operator|=
literal|0
init|;
name|loopc
operator|<
name|qi
operator|->
name|colorCount
argument_list|()
condition|;
name|loopc
operator|++
control|)
block|{
if|if
condition|(
name|qi
operator|->
name|color
argument_list|(
name|loopc
argument_list|)
operator|==
name|mycol
condition|)
return|return
name|loopc
return|;
block|}
name|qi
operator|->
name|setColorCount
argument_list|(
name|qi
operator|->
name|colorCount
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qi
operator|->
name|setColor
argument_list|(
name|qi
operator|->
name|colorCount
argument_list|()
argument_list|,
name|mycol
argument_list|)
expr_stmt|;
return|return
name|qi
operator|->
name|colorCount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|toImage
name|QImage
name|QMacPlatformPixmap
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
name|QImage
operator|::
name|Format
name|format
init|=
name|QImage
operator|::
name|Format_MonoLSB
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|1
condition|)
comment|//Doesn't support index color modes
name|format
operator|=
operator|(
name|has_alpha
condition|?
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
else|:
name|QImage
operator|::
name|Format_RGB32
operator|)
expr_stmt|;
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|quint32
modifier|*
name|sptr
init|=
name|pixels
decl_stmt|,
modifier|*
name|srow
decl_stmt|;
specifier|const
name|uint
name|sbpr
init|=
name|bytesPerRow
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
name|image
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|uchar
modifier|*
name|scanLine
init|=
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
condition|)
name|scanLine
index|[
name|x
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|srow
argument_list|,
name|w
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|image
return|;
block|}
end_function
begin_function
DECL|function|fill
name|void
name|QMacPlatformPixmap
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|fillColor
parameter_list|)
block|{
block|{
comment|//we don't know what backend to use so we cannot paint here
name|quint32
modifier|*
name|dptr
init|=
name|pixels
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|dptr
argument_list|,
literal|"QPixmap::fill"
argument_list|,
literal|"No dptr"
argument_list|)
expr_stmt|;
specifier|const
name|quint32
name|colr
init|=
name|PREMUL
argument_list|(
name|fillColor
operator|.
name|rgba
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|nbytes
init|=
name|bytesPerRow
operator|*
name|h
decl_stmt|;
if|if
condition|(
operator|!
name|colr
condition|)
block|{
name|memset
argument_list|(
name|dptr
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbytes
operator|/
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
condition|;
operator|++
name|i
control|)
operator|*
operator|(
name|dptr
operator|+
name|i
operator|)
operator|=
name|colr
expr_stmt|;
block|}
block|}
comment|// If we had an alpha channel from before, don't
comment|// switch it off. Only go from no alpha to alpha:
if|if
condition|(
name|fillColor
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
condition|)
name|macSetHasAlpha
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|alphaChannel
name|QPixmap
name|QMacPlatformPixmap
operator|::
name|alphaChannel
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|has_alpha
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QMacPlatformPixmap
modifier|*
name|alpha
init|=
operator|new
name|QMacPlatformPixmap
argument_list|(
name|PixmapType
argument_list|)
decl_stmt|;
name|alpha
operator|->
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|macGetAlphaChannel
argument_list|(
name|alpha
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|alpha
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAlphaChannel
name|void
name|QMacPlatformPixmap
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|alpha
parameter_list|)
block|{
name|has_mask
operator|=
literal|true
expr_stmt|;
name|QMacPlatformPixmap
modifier|*
name|alphaData
init|=
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|alpha
operator|.
name|data
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|macSetAlphaChannel
argument_list|(
name|alphaData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mask
name|QBitmap
name|QMacPlatformPixmap
operator|::
name|mask
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|has_mask
operator|&&
operator|!
name|has_alpha
condition|)
return|return
name|QBitmap
argument_list|()
return|;
name|QMacPlatformPixmap
modifier|*
name|mask
init|=
operator|new
name|QMacPlatformPixmap
argument_list|(
name|BitmapType
argument_list|)
decl_stmt|;
name|mask
operator|->
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|macGetAlphaChannel
argument_list|(
name|mask
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|mask
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setMask
name|void
name|QMacPlatformPixmap
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mask
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QMacPlatformPixmap
name|opaque
argument_list|(
name|PixmapType
argument_list|)
decl_stmt|;
name|opaque
operator|.
name|resize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|opaque
operator|.
name|fill
argument_list|(
name|QColor
argument_list|(
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
argument_list|)
expr_stmt|;
name|macSetAlphaChannel
argument_list|(
operator|&
name|opaque
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|has_mask
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|has_alpha
operator|=
literal|false
expr_stmt|;
name|has_mask
operator|=
literal|true
expr_stmt|;
name|QMacPlatformPixmap
modifier|*
name|maskData
init|=
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|mask
operator|.
name|data
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|macSetAlphaChannel
argument_list|(
name|maskData
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|metric
name|int
name|QMacPlatformPixmap
operator|::
name|metric
parameter_list|(
name|QPaintDevice
operator|::
name|PaintDeviceMetric
name|theMetric
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|theMetric
condition|)
block|{
case|case
name|QPaintDevice
operator|::
name|PdmWidth
case|:
return|return
name|w
return|;
case|case
name|QPaintDevice
operator|::
name|PdmHeight
case|:
return|return
name|h
return|;
case|case
name|QPaintDevice
operator|::
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmWidth
argument_list|)
operator|*
literal|25.4
operator|/
name|qreal
argument_list|(
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmDpiX
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmHeight
argument_list|)
operator|*
literal|25.4
operator|/
name|qreal
argument_list|(
name|metric
argument_list|(
name|QPaintDevice
operator|::
name|PdmDpiY
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmNumColors
case|:
return|return
literal|1
operator|<<
name|d
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDpiX
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiX
case|:
block|{
specifier|extern
name|float
name|qt_mac_defaultDpi_x
argument_list|()
decl_stmt|;
comment|//qpaintdevice_mac.cpp
return|return
name|int
argument_list|(
name|qt_mac_defaultDpi_x
argument_list|()
argument_list|)
return|;
block|}
case|case
name|QPaintDevice
operator|::
name|PdmDpiY
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiY
case|:
block|{
specifier|extern
name|float
name|qt_mac_defaultDpi_y
argument_list|()
decl_stmt|;
comment|//qpaintdevice_mac.cpp
return|return
name|int
argument_list|(
name|qt_mac_defaultDpi_y
argument_list|()
argument_list|)
return|;
block|}
case|case
name|QPaintDevice
operator|::
name|PdmDepth
case|:
return|return
name|d
return|;
default|default:
name|qWarning
argument_list|(
literal|"QPixmap::metric: Invalid metric command"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_destructor
DECL|function|~QMacPlatformPixmap
name|QMacPlatformPixmap
operator|::
name|~
name|QMacPlatformPixmap
parameter_list|()
block|{
name|validDataPointers
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg_mask
condition|)
block|{
name|CGImageRelease
argument_list|(
name|cg_mask
argument_list|)
expr_stmt|;
name|cg_mask
operator|=
literal|0
expr_stmt|;
block|}
operator|delete
name|pengine
expr_stmt|;
comment|// Make sure we aren't drawing on the context anymore.
if|if
condition|(
name|cg_data
condition|)
block|{
name|CGImageRelease
argument_list|(
name|cg_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cg_dataBeingReleased
operator|&&
name|pixels
operator|!=
name|pixelsToFree
condition|)
block|{
name|free
argument_list|(
name|pixels
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pixelsToFree
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|macSetAlphaChannel
name|void
name|QMacPlatformPixmap
operator|::
name|macSetAlphaChannel
parameter_list|(
specifier|const
name|QMacPlatformPixmap
modifier|*
name|pix
parameter_list|,
name|bool
name|asMask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pixels
operator|||
operator|!
name|h
operator|||
operator|!
name|w
operator|||
name|pix
operator|->
name|w
operator|!=
name|w
operator|||
name|pix
operator|->
name|h
operator|!=
name|h
condition|)
return|return;
name|quint32
modifier|*
name|dptr
init|=
name|pixels
decl_stmt|,
modifier|*
name|drow
decl_stmt|;
specifier|const
name|uint
name|dbpr
init|=
name|bytesPerRow
decl_stmt|;
specifier|const
name|unsigned
name|short
name|sbpr
init|=
name|pix
operator|->
name|bytesPerRow
decl_stmt|;
name|quint32
modifier|*
name|sptr
init|=
name|pix
operator|->
name|pixels
decl_stmt|,
modifier|*
name|srow
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|drow
operator|=
name|dptr
operator|+
operator|(
name|y
operator|*
operator|(
name|dbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
operator||
operator|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asMask
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
operator||
literal|0xFF000000
expr_stmt|;
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|PREMUL
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|uchar
name|alpha
init|=
name|qGray
argument_list|(
name|qRed
argument_list|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
argument_list|)
argument_list|,
name|qGreen
argument_list|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
argument_list|)
argument_list|,
name|qBlue
argument_list|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uchar
name|destAlpha
init|=
name|qt_div_255
argument_list|(
name|alpha
operator|*
name|qAlpha
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
literal|1
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
operator|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|&
name|RGB_MASK
operator|)
operator||
operator|(
name|destAlpha
operator|<<
literal|24
operator|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|qRgba
argument_list|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|*
name|alpha
argument_list|)
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|*
name|alpha
argument_list|)
argument_list|)
argument_list|,
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|*
name|alpha
argument_list|)
argument_list|)
argument_list|,
name|destAlpha
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|PREMUL
argument_list|(
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|macSetHasAlpha
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|macGetAlphaChannel
name|void
name|QMacPlatformPixmap
operator|::
name|macGetAlphaChannel
parameter_list|(
name|QMacPlatformPixmap
modifier|*
name|pix
parameter_list|,
name|bool
name|asMask
parameter_list|)
specifier|const
block|{
name|quint32
modifier|*
name|dptr
init|=
name|pix
operator|->
name|pixels
decl_stmt|,
modifier|*
name|drow
decl_stmt|;
specifier|const
name|uint
name|dbpr
init|=
name|pix
operator|->
name|bytesPerRow
decl_stmt|;
specifier|const
name|unsigned
name|short
name|sbpr
init|=
name|bytesPerRow
decl_stmt|;
name|quint32
modifier|*
name|sptr
init|=
name|pixels
decl_stmt|,
modifier|*
name|srow
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|drow
operator|=
name|dptr
operator|+
operator|(
name|y
operator|*
operator|(
name|dbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|asMask
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|&
name|qRgba
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
condition|)
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0x00000000
expr_stmt|;
else|else
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
specifier|const
name|int
name|alpha
init|=
name|qAlpha
argument_list|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
argument_list|)
decl_stmt|;
operator|*
operator|(
name|drow
operator|+
name|x
operator|)
operator|=
name|qRgb
argument_list|(
name|alpha
argument_list|,
name|alpha
argument_list|,
name|alpha
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|macSetHasAlpha
name|void
name|QMacPlatformPixmap
operator|::
name|macSetHasAlpha
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|has_alpha
operator|=
name|b
expr_stmt|;
name|macReleaseCGImageRef
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|macCreateCGImageRef
name|void
name|QMacPlatformPixmap
operator|::
name|macCreateCGImageRef
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|cg_data
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|//create the cg data
name|CGColorSpaceRef
name|colorspace
init|=
name|QCoreGraphicsPaintEngine
operator|::
name|macDisplayColorSpace
argument_list|()
decl_stmt|;
name|QCFType
argument_list|<
name|CGDataProviderRef
argument_list|>
name|provider
init|=
name|CGDataProviderCreateWithData
argument_list|(
name|this
argument_list|,
name|pixels
argument_list|,
name|bytesPerRow
operator|*
name|h
argument_list|,
name|qt_mac_cgimage_data_free
argument_list|)
decl_stmt|;
name|validDataPointers
operator|.
name|insert
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|uint
name|cgflags
init|=
name|kCGImageAlphaPremultipliedFirst
decl_stmt|;
ifdef|#
directive|ifdef
name|kCGBitmapByteOrder32Host
comment|//only needed because CGImage.h added symbols in the minor version
name|cgflags
operator||=
name|kCGBitmapByteOrder32Host
expr_stmt|;
endif|#
directive|endif
name|cg_data
operator|=
name|CGImageCreate
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
literal|8
argument_list|,
literal|32
argument_list|,
name|bytesPerRow
argument_list|,
name|colorspace
argument_list|,
name|cgflags
argument_list|,
name|provider
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kCGRenderingIntentDefault
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|macReleaseCGImageRef
name|void
name|QMacPlatformPixmap
operator|::
name|macReleaseCGImageRef
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cg_data
condition|)
return|return;
comment|// There's nothing we need to do
name|cg_dataBeingReleased
operator|=
name|cg_data
expr_stmt|;
name|CGImageRelease
argument_list|(
name|cg_data
argument_list|)
expr_stmt|;
name|cg_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pixels
operator|!=
name|pixelsToFree
condition|)
block|{
name|macCreatePixels
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pixelsToFree
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// We create our space in memory to paint on here. If we already have existing pixels
end_comment
begin_comment
comment|// copy them over. This is to preserve the fact that CGImageRef's are immutable.
end_comment
begin_function
DECL|function|macCreatePixels
name|void
name|QMacPlatformPixmap
operator|::
name|macCreatePixels
parameter_list|()
block|{
specifier|const
name|int
name|numBytes
init|=
name|bytesPerRow
operator|*
name|h
decl_stmt|;
name|quint32
modifier|*
name|base_pixels
decl_stmt|;
if|if
condition|(
name|pixelsToFree
operator|&&
name|pixelsToFree
operator|!=
name|pixels
condition|)
block|{
comment|// Reuse unused block of memory lying around from a previous callback.
name|base_pixels
operator|=
name|pixelsToFree
expr_stmt|;
name|pixelsToFree
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// We need a block of memory to do stuff with.
name|base_pixels
operator|=
cast|static_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
name|numBytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixels
condition|)
name|memcpy
argument_list|(
name|base_pixels
argument_list|,
name|pixels
argument_list|,
name|pixelsSize
argument_list|)
expr_stmt|;
name|pixels
operator|=
name|base_pixels
expr_stmt|;
name|pixelsSize
operator|=
name|numBytes
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|QPixmap QMacPlatformPixmap::transformed(const QTransform&transform,                                     Qt::TransformationMode mode) const {     int w, h;
comment|// size of target pixmap
end_comment
begin_comment
unit|const int ws = width();     const int hs = height();      QTransform mat(transform.m11(), transform.m12(),                    transform.m21(), transform.m22(), 0., 0.);     if (transform.m12() == 0.0F&& transform.m21() == 0.0F&&         transform.m11()>= 0.0F&& transform.m22()>= 0.0F)     {         h = int(qAbs(mat.m22()) * hs + 0.9999);         w = int(qAbs(mat.m11()) * ws + 0.9999);         h = qAbs(h);         w = qAbs(w);     } else {
comment|// rotation or shearing
end_comment
begin_comment
unit|QPolygonF a(QRectF(0,0,ws+1,hs+1));         a = mat.map(a);         QRectF r = a.boundingRect().normalized();         w = int(r.width() + 0.9999);         h = int(r.height() + 0.9999);     }     mat = QPixmap::trueMatrix(mat, ws, hs);     if (!h || !w)         return QPixmap();
comment|// create destination
end_comment
begin_comment
unit|QMacPlatformPixmap *pm = new QMacPlatformPixmap(pixelType(), w, h);     const quint32 *sptr = pixels;     quint32 *dptr = pm->pixels;     memset(dptr, 0, (pm->bytesPerRow * pm->h));
comment|// do the transform
end_comment
begin_warning
unit|if (mode == Qt::SmoothTransformation) {
warning|#
directive|warning
warning|QMacPlatformPixmap::transformed not properly implemented
end_warning
begin_if
unit|qWarning("QMacPlatformPixmap::transformed not properly implemented");
if|#
directive|if
literal|0
end_if
begin_endif
unit|QPainter p(&pm);         p.setRenderHint(QPainter::Antialiasing);         p.setRenderHint(QPainter::SmoothPixmapTransform);         p.setTransform(mat);         p.drawPixmap(0, 0, *this);
endif|#
directive|endif
end_endif
begin_comment
unit|} else {         bool invertible;         mat = mat.inverted(&invertible);         if (!invertible)             return QPixmap();          const int bpp = 32;         const int xbpl = (w * bpp) / 8;         if (!qt_xForm_helper(mat, 0, QT_XFORM_TYPE_MSBFIRST, bpp,                              (uchar*)dptr, xbpl, (pm->bytesPerRow) - xbpl,                              h, (uchar*)sptr, (bytesPerRow), ws, hs)) {             qWarning("QMacPlatformPixmap::transform(): failure");             return QPixmap();         }     }
comment|// update the alpha
end_comment
begin_endif
unit|pm->macSetHasAlpha(true);     return QPixmap(pm); }
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<OpenGL/OpenGL.h>
include|#
directive|include
file|<OpenGL/gl.h>
name|QT_END_INCLUDE_NAMESPACE
comment|// Load and resolve the symbols we need from OpenGL manually so QtGui doesn't have to link against the OpenGL framework.
decl|typedef
DECL|typedef|PtrCGLChoosePixelFormat
name|CGLError
argument_list|(
operator|*
name|PtrCGLChoosePixelFormat
argument_list|)
argument_list|(
specifier|const
name|CGLPixelFormatAttribute
operator|*
argument_list|,
name|CGLPixelFormatObj
operator|*
argument_list|,
name|long
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|PtrCGLClearDrawable
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLClearDrawable
function_decl|)
parameter_list|(
name|CGLContextObj
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCGLCreateContext
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLCreateContext
function_decl|)
parameter_list|(
name|CGLPixelFormatObj
parameter_list|,
name|CGLContextObj
parameter_list|,
name|CGLContextObj
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCGLDestroyContext
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLDestroyContext
function_decl|)
parameter_list|(
name|CGLContextObj
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCGLDestroyPixelFormat
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLDestroyPixelFormat
function_decl|)
parameter_list|(
name|CGLPixelFormatObj
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCGLSetCurrentContext
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLSetCurrentContext
function_decl|)
parameter_list|(
name|CGLContextObj
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCGLSetFullScreen
typedef|typedef
name|CGLError
function_decl|(
modifier|*
name|PtrCGLSetFullScreen
function_decl|)
parameter_list|(
name|CGLContextObj
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrglFinish
typedef|typedef
name|void
function_decl|(
modifier|*
name|PtrglFinish
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrglPixelStorei
typedef|typedef
name|void
function_decl|(
modifier|*
name|PtrglPixelStorei
function_decl|)
parameter_list|(
name|GLenum
parameter_list|,
name|GLint
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrglReadBuffer
typedef|typedef
name|void
function_decl|(
modifier|*
name|PtrglReadBuffer
function_decl|)
parameter_list|(
name|GLenum
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrglReadPixels
typedef|typedef
name|void
function_decl|(
modifier|*
name|PtrglReadPixels
function_decl|)
parameter_list|(
name|GLint
parameter_list|,
name|GLint
parameter_list|,
name|GLsizei
parameter_list|,
name|GLsizei
parameter_list|,
name|GLenum
parameter_list|,
name|GLenum
parameter_list|,
name|GLvoid
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|ptrCGLChoosePixelFormat
specifier|static
name|PtrCGLChoosePixelFormat
name|ptrCGLChoosePixelFormat
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLClearDrawable
specifier|static
name|PtrCGLClearDrawable
name|ptrCGLClearDrawable
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLCreateContext
specifier|static
name|PtrCGLCreateContext
name|ptrCGLCreateContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLDestroyContext
specifier|static
name|PtrCGLDestroyContext
name|ptrCGLDestroyContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLDestroyPixelFormat
specifier|static
name|PtrCGLDestroyPixelFormat
name|ptrCGLDestroyPixelFormat
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLSetCurrentContext
specifier|static
name|PtrCGLSetCurrentContext
name|ptrCGLSetCurrentContext
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrCGLSetFullScreen
specifier|static
name|PtrCGLSetFullScreen
name|ptrCGLSetFullScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrglFinish
specifier|static
name|PtrglFinish
name|ptrglFinish
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrglPixelStorei
specifier|static
name|PtrglPixelStorei
name|ptrglPixelStorei
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrglReadBuffer
specifier|static
name|PtrglReadBuffer
name|ptrglReadBuffer
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ptrglReadPixels
specifier|static
name|PtrglReadPixels
name|ptrglReadPixels
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|resolveOpenGLSymbols
specifier|static
name|bool
name|resolveOpenGLSymbols
parameter_list|()
block|{
if|if
condition|(
name|ptrCGLChoosePixelFormat
operator|==
literal|0
condition|)
block|{
name|QLibrary
name|library
argument_list|(
name|QLatin1String
argument_list|(
literal|"/System/Library/Frameworks/OpenGL.framework/OpenGL"
argument_list|)
argument_list|)
decl_stmt|;
name|ptrCGLChoosePixelFormat
operator|=
call|(
name|PtrCGLChoosePixelFormat
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLChoosePixelFormat"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLClearDrawable
operator|=
call|(
name|PtrCGLClearDrawable
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLClearDrawable"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLCreateContext
operator|=
call|(
name|PtrCGLCreateContext
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLCreateContext"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLDestroyContext
operator|=
call|(
name|PtrCGLDestroyContext
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLDestroyContext"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLDestroyPixelFormat
operator|=
call|(
name|PtrCGLDestroyPixelFormat
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLDestroyPixelFormat"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLSetCurrentContext
operator|=
call|(
name|PtrCGLSetCurrentContext
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLSetCurrentContext"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrCGLSetFullScreen
operator|=
call|(
name|PtrCGLSetFullScreen
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"CGLSetFullScreen"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrglFinish
operator|=
call|(
name|PtrglFinish
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"glFinish"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrglPixelStorei
operator|=
call|(
name|PtrglPixelStorei
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"glPixelStorei"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrglReadBuffer
operator|=
call|(
name|PtrglReadBuffer
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"glReadBuffer"
argument_list|)
argument_list|)
expr_stmt|;
name|ptrglReadPixels
operator|=
call|(
name|PtrglReadPixels
call|)
argument_list|(
name|library
operator|.
name|resolve
argument_list|(
literal|"glReadPixels"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ptrCGLChoosePixelFormat
operator|&&
name|ptrCGLClearDrawable
operator|&&
name|ptrCGLCreateContext
operator|&&
name|ptrCGLDestroyContext
operator|&&
name|ptrCGLDestroyPixelFormat
operator|&&
name|ptrCGLSetCurrentContext
operator|&&
name|ptrCGLSetFullScreen
operator|&&
name|ptrglFinish
operator|&&
name|ptrglPixelStorei
operator|&&
name|ptrglReadBuffer
operator|&&
name|ptrglReadPixels
return|;
block|}
end_function
begin_comment
comment|// Inverts the given pixmap in the y direction.
end_comment
begin_function
DECL|function|qt_mac_flipPixmap
specifier|static
name|void
name|qt_mac_flipPixmap
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|rowBytes
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|bottom
init|=
name|height
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|base
init|=
name|data
decl_stmt|;
name|void
modifier|*
name|buffer
init|=
name|malloc
argument_list|(
name|rowBytes
argument_list|)
decl_stmt|;
name|int
name|top
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|top
operator|<
name|bottom
condition|)
block|{
name|void
modifier|*
name|topP
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|top
operator|*
name|rowBytes
operator|)
operator|+
operator|(
name|intptr_t
operator|)
name|base
operator|)
decl_stmt|;
name|void
modifier|*
name|bottomP
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|bottom
operator|*
name|rowBytes
operator|)
operator|+
operator|(
name|intptr_t
operator|)
name|base
operator|)
decl_stmt|;
name|bcopy
argument_list|(
name|topP
argument_list|,
name|buffer
argument_list|,
name|rowBytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bottomP
argument_list|,
name|topP
argument_list|,
name|rowBytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|bottomP
argument_list|,
name|rowBytes
argument_list|)
expr_stmt|;
operator|++
name|top
expr_stmt|;
operator|--
name|bottom
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Grabs displayRect from display and places it into buffer.
end_comment
begin_function
DECL|function|qt_mac_grabDisplayRect
specifier|static
name|void
name|qt_mac_grabDisplayRect
parameter_list|(
name|CGDirectDisplayID
name|display
parameter_list|,
specifier|const
name|QRect
modifier|&
name|displayRect
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|display
operator|==
name|kCGNullDirectDisplay
condition|)
return|return;
name|CGLPixelFormatAttribute
name|attribs
index|[]
init|=
block|{
name|kCGLPFAFullScreen
block|,
name|kCGLPFADisplayMask
block|,
operator|(
name|CGLPixelFormatAttribute
operator|)
literal|0
block|,
comment|/* Display mask bit goes here */
operator|(
name|CGLPixelFormatAttribute
operator|)
literal|0
block|}
decl_stmt|;
name|attribs
index|[
literal|2
index|]
operator|=
operator|(
name|CGLPixelFormatAttribute
operator|)
name|CGDisplayIDToOpenGLDisplayMask
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|// Build a full-screen GL context
name|CGLPixelFormatObj
name|pixelFormatObj
decl_stmt|;
name|long
name|numPixelFormats
decl_stmt|;
name|ptrCGLChoosePixelFormat
argument_list|(
name|attribs
argument_list|,
operator|&
name|pixelFormatObj
argument_list|,
operator|&
name|numPixelFormats
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pixelFormatObj
condition|)
comment|// No full screen context support
return|return;
name|CGLContextObj
name|glContextObj
decl_stmt|;
name|ptrCGLCreateContext
argument_list|(
name|pixelFormatObj
argument_list|,
literal|0
argument_list|,
operator|&
name|glContextObj
argument_list|)
expr_stmt|;
name|ptrCGLDestroyPixelFormat
argument_list|(
name|pixelFormatObj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glContextObj
condition|)
return|return;
name|ptrCGLSetCurrentContext
argument_list|(
name|glContextObj
argument_list|)
expr_stmt|;
name|ptrCGLSetFullScreen
argument_list|(
name|glContextObj
argument_list|)
expr_stmt|;
name|ptrglReadBuffer
argument_list|(
name|GL_FRONT
argument_list|)
expr_stmt|;
name|ptrglFinish
argument_list|()
expr_stmt|;
comment|// Finish all OpenGL commands
name|ptrglPixelStorei
argument_list|(
name|GL_PACK_ALIGNMENT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// Force 4-byte alignment
name|ptrglPixelStorei
argument_list|(
name|GL_PACK_ROW_LENGTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrglPixelStorei
argument_list|(
name|GL_PACK_SKIP_ROWS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrglPixelStorei
argument_list|(
name|GL_PACK_SKIP_PIXELS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Fetch the data in XRGB format, matching the bitmap context.
name|ptrglReadPixels
argument_list|(
argument|GLint(displayRect.x())
argument_list|,
argument|GLint(displayRect.y())
argument_list|,
argument|GLint(displayRect.width())
argument_list|,
argument|GLint(displayRect.height())
argument_list|,
ifdef|#
directive|ifdef
name|__BIG_ENDIAN__
argument|GL_BGRA
argument_list|,
argument|GL_UNSIGNED_INT_8_8_8_8_REV
argument_list|,
argument|buffer
else|#
directive|else
argument|GL_BGRA
argument_list|,
argument|GL_UNSIGNED_INT_8_8_8_8
argument_list|,
argument|buffer
endif|#
directive|endif
argument_list|)
empty_stmt|;
name|ptrCGLSetCurrentContext
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptrCGLClearDrawable
argument_list|(
name|glContextObj
argument_list|)
expr_stmt|;
comment|// disassociate from full screen
name|ptrCGLDestroyContext
argument_list|(
name|glContextObj
argument_list|)
expr_stmt|;
comment|// and destroy the context
block|}
end_function
begin_comment
comment|// Returns a pixmap containing the screen contents at rect.
end_comment
begin_function
DECL|function|qt_mac_grabScreenRect
specifier|static
name|QPixmap
name|qt_mac_grabScreenRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|resolveOpenGLSymbols
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
specifier|const
name|int
name|maxDisplays
init|=
literal|128
decl_stmt|;
comment|// 128 displays should be enough for everyone.
name|CGDirectDisplayID
name|displays
index|[
name|maxDisplays
index|]
decl_stmt|;
name|CGDisplayCount
name|displayCount
decl_stmt|;
specifier|const
name|CGRect
name|cgRect
init|=
name|CGRectMake
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|CGDisplayErr
name|err
init|=
name|CGGetDisplaysWithRect
argument_list|(
name|cgRect
argument_list|,
name|maxDisplays
argument_list|,
name|displays
argument_list|,
operator|&
name|displayCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|displayCount
operator|==
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|long
name|bytewidth
init|=
name|rect
operator|.
name|width
argument_list|()
operator|*
literal|4
decl_stmt|;
comment|// Assume 4 bytes/pixel for now
name|bytewidth
operator|=
operator|(
name|bytewidth
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|// Align to 4 bytes
name|QVarLengthArray
argument_list|<
name|char
argument_list|>
name|buffer
argument_list|(
name|rect
operator|.
name|height
argument_list|()
operator|*
name|bytewidth
argument_list|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|displayCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|CGRect
name|bounds
init|=
name|CGDisplayBounds
argument_list|(
name|displays
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// Translate to display-local coordinates
name|QRect
name|displayRect
init|=
name|rect
operator|.
name|translated
argument_list|(
name|qRound
argument_list|(
operator|-
name|bounds
operator|.
name|origin
operator|.
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
operator|-
name|bounds
operator|.
name|origin
operator|.
name|y
argument_list|)
argument_list|)
decl_stmt|;
comment|// Adjust for inverted y axis.
name|displayRect
operator|.
name|moveTop
argument_list|(
name|qRound
argument_list|(
name|bounds
operator|.
name|size
operator|.
name|height
argument_list|)
operator|-
name|displayRect
operator|.
name|y
argument_list|()
operator|-
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|qt_mac_grabDisplayRect
argument_list|(
name|displays
index|[
name|i
index|]
argument_list|,
name|displayRect
argument_list|,
name|buffer
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|qt_mac_flipPixmap
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|bytewidth
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QCFType
argument_list|<
name|CGContextRef
argument_list|>
name|bitmap
init|=
name|CGBitmapContextCreate
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
literal|8
argument_list|,
name|bytewidth
argument_list|,
name|QCoreGraphicsPaintEngine
operator|::
name|macGenericColorSpace
argument_list|()
argument_list|,
name|kCGImageAlphaNoneSkipFirst
argument_list|)
decl_stmt|;
name|QCFType
argument_list|<
name|CGImageRef
argument_list|>
name|image
init|=
name|CGBitmapContextCreateImage
argument_list|(
name|bitmap
argument_list|)
decl_stmt|;
return|return
name|QPixmap
operator|::
name|fromMacCGImageRef
argument_list|(
name|image
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_MAC_USE_COCOA
end_ifndef
begin_comment
comment|// no QuickDraw in 64-bit mode
end_comment
begin_function
DECL|function|qt_mac_grabScreenRect_10_3
specifier|static
name|QPixmap
name|qt_mac_grabScreenRect_10_3
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QPixmap
name|pm
init|=
name|QPixmap
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
specifier|extern
name|WindowPtr
name|qt_mac_window_for
argument_list|(
specifier|const
name|QWidget
operator|*
argument_list|)
decl_stmt|;
comment|// qwidget_mac.cpp
specifier|const
name|BitMap
modifier|*
name|windowPort
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
name|GDHandle
name|gdh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|gdh
operator|=
name|GetMainDevice
argument_list|()
operator|)
condition|)
name|qDebug
argument_list|(
literal|"Qt: internal: Unexpected condition reached: %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|windowPort
operator|=
operator|(
name|BitMap
operator|*
operator|)
operator|(
operator|*
operator|(
operator|*
name|gdh
operator|)
operator|->
name|gdPMap
operator|)
expr_stmt|;
block|}
else|else
block|{
name|windowPort
operator|=
name|GetPortBitMapForCopyBits
argument_list|(
name|GetWindowPort
argument_list|(
name|qt_mac_window_for
argument_list|(
name|widget
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|const
name|BitMap
modifier|*
name|pixmapPort
init|=
name|GetPortBitMapForCopyBits
argument_list|(
cast|static_cast
argument_list|<
name|GWorldPtr
argument_list|>
argument_list|(
name|pm
operator|.
name|macQDHandle
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Rect
name|macSrcRect
decl_stmt|,
name|macDstRect
decl_stmt|;
name|SetRect
argument_list|(
operator|&
name|macSrcRect
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|w
argument_list|,
name|y
operator|+
name|h
argument_list|)
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|macDstRect
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|CopyBits
argument_list|(
name|windowPort
argument_list|,
name|pixmapPort
argument_list|,
operator|&
name|macSrcRect
argument_list|,
operator|&
name|macDstRect
argument_list|,
name|srcCopy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pm
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|grabWindow
name|QPixmap
name|QPixmap
operator|::
name|grabWindow
parameter_list|(
name|WId
name|window
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|QWidget
operator|::
name|find
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|==
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|w
operator|=
name|widget
operator|->
name|width
argument_list|()
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|-
literal|1
condition|)
name|h
operator|=
name|widget
operator|->
name|height
argument_list|()
operator|-
name|y
expr_stmt|;
name|QPoint
name|globalCoord
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|globalCoord
operator|=
name|widget
operator|->
name|mapToGlobal
argument_list|(
name|globalCoord
argument_list|)
expr_stmt|;
name|QRect
name|rect
argument_list|(
name|globalCoord
operator|.
name|x
argument_list|()
operator|+
name|x
argument_list|,
name|globalCoord
operator|.
name|y
argument_list|()
operator|+
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_MAC_USE_COCOA
return|return
name|qt_mac_grabScreenRect
argument_list|(
name|rect
argument_list|)
return|;
else|#
directive|else
if|#
directive|if
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>=
name|MAC_OS_X_VERSION_10_4
operator|)
if|if
condition|(
name|QSysInfo
operator|::
name|MacintoshVersion
operator|>=
name|QSysInfo
operator|::
name|MV_10_4
condition|)
block|{
return|return
name|qt_mac_grabScreenRect
argument_list|(
name|rect
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
return|return
name|qt_mac_grabScreenRect_10_3
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|widget
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|// ifdef Q_WS_MAC64
block|}
end_function
begin_comment
comment|/*! \internal      Returns the QuickDraw CGrafPtr of the pixmap. 0 is returned if it can't     be obtained. Do not hold the pointer around for long as it can be     relocated.      \warning This function is only available on Mac OS X.     \warning As of Qt 4.6, this function \e{always} returns zero. */
end_comment
begin_function
DECL|function|macQDHandle
name|Qt
operator|::
name|HANDLE
name|QPixmap
operator|::
name|macQDHandle
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Returns the QuickDraw CGrafPtr of the pixmap's alpha channel. 0 is     returned if it can't be obtained. Do not hold the pointer around for     long as it can be relocated.      \warning This function is only available on Mac OS X.     \warning As of Qt 4.6, this function \e{always} returns zero. */
end_comment
begin_function
DECL|function|macQDAlphaHandle
name|Qt
operator|::
name|HANDLE
name|QPixmap
operator|::
name|macQDAlphaHandle
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Returns the CoreGraphics CGContextRef of the pixmap. 0 is returned if     it can't be obtained. It is the caller's responsiblity to     CGContextRelease the context when finished using it.      \warning This function is only available on Mac OS X. */
end_comment
begin_function
DECL|function|macCGHandle
name|Qt
operator|::
name|HANDLE
name|QPixmap
operator|::
name|macCGHandle
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|data
operator|->
name|classId
argument_list|()
operator|==
name|QPlatformPixmap
operator|::
name|MacClass
condition|)
block|{
name|QMacPlatformPixmap
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cg_data
condition|)
name|d
operator|->
name|macCreateCGImageRef
argument_list|()
expr_stmt|;
name|CGImageRef
name|ret
init|=
name|d
operator|->
name|cg_data
decl_stmt|;
name|CGImageRetain
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|classId
argument_list|()
operator|==
name|QPlatformPixmap
operator|::
name|RasterClass
condition|)
block|{
return|return
name|qt_mac_image_to_cgimage
argument_list|(
cast|static_cast
argument_list|<
name|QRasterPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|image
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QMacPlatformPixmap
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|has_alpha
return|;
block|}
end_function
begin_function
DECL|function|qt_mac_create_imagemask
name|CGImageRef
name|qt_mac_create_imagemask
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|)
block|{
name|QMacPlatformPixmap
modifier|*
name|px
init|=
cast|static_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pixmap
operator|.
name|data
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|px
operator|->
name|cg_mask
condition|)
block|{
if|if
condition|(
name|px
operator|->
name|cg_mask_rect
operator|==
name|sr
condition|)
block|{
name|CGImageRetain
argument_list|(
name|px
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
comment|//reference for the caller
return|return
name|px
operator|->
name|cg_mask
return|;
block|}
name|CGImageRelease
argument_list|(
name|px
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
name|px
operator|->
name|cg_mask
operator|=
literal|0
expr_stmt|;
block|}
specifier|const
name|int
name|sx
init|=
name|qRound
argument_list|(
name|sr
operator|.
name|x
argument_list|()
argument_list|)
decl_stmt|,
name|sy
init|=
name|qRound
argument_list|(
name|sr
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|,
name|sw
init|=
name|qRound
argument_list|(
name|sr
operator|.
name|width
argument_list|()
argument_list|)
decl_stmt|,
name|sh
init|=
name|qRound
argument_list|(
name|sr
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|sbpr
init|=
name|px
operator|->
name|bytesPerRow
decl_stmt|;
specifier|const
name|uint
name|nbytes
init|=
name|sw
operator|*
name|sh
decl_stmt|;
comment|//  alpha is always 255 for bitmaps, ignore it in this case.
specifier|const
name|quint32
name|mask
init|=
name|px
operator|->
name|depth
argument_list|()
operator|==
literal|1
condition|?
literal|0x00ffffff
else|:
literal|0xffffffff
decl_stmt|;
name|quint8
modifier|*
name|dptr
init|=
cast|static_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
name|nbytes
argument_list|)
argument_list|)
decl_stmt|;
name|quint32
modifier|*
name|sptr
init|=
name|px
operator|->
name|pixels
decl_stmt|,
modifier|*
name|srow
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|sy
init|,
name|offset
init|=
literal|0
init|;
name|y
operator|<
name|sh
condition|;
operator|++
name|y
control|)
block|{
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
name|sx
init|;
name|x
operator|<
name|sw
condition|;
operator|++
name|x
control|)
operator|*
operator|(
name|dptr
operator|+
operator|(
name|offset
operator|++
operator|)
operator|)
operator|=
operator|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
operator|&
name|mask
operator|)
condition|?
literal|255
else|:
literal|0
expr_stmt|;
block|}
name|QCFType
argument_list|<
name|CGDataProviderRef
argument_list|>
name|provider
init|=
name|CGDataProviderCreateWithData
argument_list|(
literal|0
argument_list|,
name|dptr
argument_list|,
name|nbytes
argument_list|,
name|qt_mac_cgimage_data_free
argument_list|)
decl_stmt|;
name|px
operator|->
name|cg_mask
operator|=
name|CGImageMaskCreate
argument_list|(
name|sw
argument_list|,
name|sh
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|nbytes
operator|/
name|sh
argument_list|,
name|provider
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|px
operator|->
name|cg_mask_rect
operator|=
name|sr
expr_stmt|;
name|CGImageRetain
argument_list|(
name|px
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
comment|//reference for the caller
return|return
name|px
operator|->
name|cg_mask
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_MAC_USE_COCOA
end_ifndef
begin_function
DECL|function|qt_mac_create_iconref
name|IconRef
name|qt_mac_create_iconref
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|px
parameter_list|)
block|{
if|if
condition|(
name|px
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
comment|//create icon
name|IconFamilyHandle
name|iconFamily
init|=
cast|reinterpret_cast
argument_list|<
name|IconFamilyHandle
argument_list|>
argument_list|(
name|NewHandle
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|//create data
block|{
struct|struct
block|{
name|OSType
name|mac_type
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|,
name|depth
decl_stmt|;
name|bool
name|mask
decl_stmt|;
block|}
name|images
index|[]
init|=
block|{
block|{
name|kThumbnail32BitData
block|,
literal|128
block|,
literal|128
block|,
literal|32
block|,
literal|false
block|}
block|,
block|{
name|kThumbnail8BitMask
block|,
literal|128
block|,
literal|128
block|,
literal|8
block|,
literal|true
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|false
block|}
comment|//end marker
block|}
struct|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|images
index|[
name|i
index|]
operator|.
name|mac_type
condition|;
name|i
operator|++
control|)
block|{
comment|//get QPixmap data
name|QImage
name|scaled_px
init|=
name|px
operator|.
name|toImage
argument_list|()
operator|.
name|scaled
argument_list|(
name|images
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|images
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
name|quint32
modifier|*
name|sptr
init|=
operator|(
name|quint32
operator|*
operator|)
name|scaled_px
operator|.
name|bits
argument_list|()
decl_stmt|;
name|quint32
modifier|*
name|srow
decl_stmt|;
name|uint
name|sbpr
init|=
name|scaled_px
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
comment|//get Handle data
specifier|const
name|int
name|dbpr
init|=
name|images
index|[
name|i
index|]
operator|.
name|width
operator|*
operator|(
name|images
index|[
name|i
index|]
operator|.
name|depth
operator|/
literal|8
operator|)
decl_stmt|;
name|Handle
name|hdl
init|=
name|NewHandle
argument_list|(
name|dbpr
operator|*
name|images
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sptr
condition|)
block|{
comment|//handle null pixmap
name|memset
argument_list|(
operator|(
operator|*
name|hdl
operator|)
argument_list|,
literal|'\0'
argument_list|,
name|dbpr
operator|*
name|images
index|[
name|i
index|]
operator|.
name|height
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|images
index|[
name|i
index|]
operator|.
name|mask
condition|)
block|{
if|if
condition|(
name|images
index|[
name|i
index|]
operator|.
name|mac_type
operator|==
name|kThumbnail8BitMask
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|,
name|hindex
init|=
literal|0
init|;
name|y
operator|<
name|images
index|[
name|i
index|]
operator|.
name|height
condition|;
operator|++
name|y
control|)
block|{
name|srow
operator|=
name|sptr
operator|+
operator|(
name|y
operator|*
operator|(
name|sbpr
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|images
index|[
name|i
index|]
operator|.
name|width
condition|;
operator|++
name|x
control|)
operator|*
operator|(
operator|(
operator|*
name|hdl
operator|)
operator|+
operator|(
name|hindex
operator|++
operator|)
operator|)
operator|=
name|qAlpha
argument_list|(
operator|*
operator|(
name|srow
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|dest
init|=
operator|(
operator|*
name|hdl
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
name|images
index|[
name|i
index|]
operator|.
name|depth
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|images
index|[
name|i
index|]
operator|.
name|height
condition|;
operator|++
name|y
control|)
block|{
name|uint
modifier|*
name|source
init|=
operator|(
name|uint
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|sptr
operator|+
operator|(
name|sbpr
operator|*
name|y
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|images
index|[
name|i
index|]
operator|.
name|width
condition|;
operator|++
name|x
operator|,
name|dest
operator|+=
literal|4
control|)
operator|*
operator|(
operator|(
name|uint
operator|*
operator|)
name|dest
operator|)
operator|=
name|CFSwapInt32
argument_list|(
operator|*
operator|(
name|source
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|images
index|[
name|i
index|]
operator|.
name|height
condition|;
operator|++
name|y
control|)
name|memcpy
argument_list|(
name|dest
operator|+
operator|(
name|y
operator|*
name|dbpr
operator|)
argument_list|,
operator|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|sptr
operator|+
operator|(
name|sbpr
operator|*
name|y
operator|)
operator|)
argument_list|,
name|dbpr
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set the family data to the Handle
name|OSStatus
name|set
init|=
name|SetIconFamilyData
argument_list|(
name|iconFamily
argument_list|,
name|images
index|[
name|i
index|]
operator|.
name|mac_type
argument_list|,
name|hdl
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
name|noErr
condition|)
name|qWarning
argument_list|(
literal|"%s: %d -- Unable to create icon data[%d]!! %ld"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|,
name|long
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|DisposeHandle
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
block|}
block|}
comment|//acquire and cleanup
name|IconRef
name|ret
decl_stmt|;
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
specifier|const
name|OSType
name|kQtCreator
init|=
literal|'CUTE'
decl_stmt|;
name|RegisterIconRefFromIconFamily
argument_list|(
name|kQtCreator
argument_list|,
operator|(
name|OSType
operator|)
name|counter
argument_list|,
name|iconFamily
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|AcquireIconRef
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|UnregisterIconRef
argument_list|(
name|kQtCreator
argument_list|,
operator|(
name|OSType
operator|)
name|counter
argument_list|)
expr_stmt|;
name|DisposeHandle
argument_list|(
cast|reinterpret_cast
argument_list|<
name|Handle
argument_list|>
argument_list|(
name|iconFamily
argument_list|)
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QMacPlatformPixmap
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|pengine
condition|)
block|{
name|QMacPlatformPixmap
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|pengine
operator|=
operator|new
name|QCoreGraphicsPaintEngine
argument_list|()
expr_stmt|;
block|}
return|return
name|pengine
return|;
block|}
end_function
begin_function
DECL|function|copy
name|void
name|QMacPlatformPixmap
operator|::
name|copy
parameter_list|(
specifier|const
name|QPlatformPixmap
modifier|*
name|data
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|)
block|{
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|toImage
argument_list|()
operator|.
name|copy
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|QMacPlatformPixmap
modifier|*
name|macData
init|=
cast|static_cast
argument_list|<
specifier|const
name|QMacPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|resize
argument_list|(
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|has_alpha
operator|=
name|macData
operator|->
name|has_alpha
expr_stmt|;
name|has_mask
operator|=
name|macData
operator|->
name|has_mask
expr_stmt|;
name|uninit
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
decl_stmt|;
specifier|const
name|int
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
decl_stmt|;
name|char
modifier|*
name|dest
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|pixels
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|macData
operator|->
name|pixels
operator|+
name|x
argument_list|)
operator|+
name|y
operator|*
name|macData
operator|->
name|bytesPerRow
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|w
operator|*
literal|4
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytesPerRow
expr_stmt|;
name|src
operator|+=
name|macData
operator|->
name|bytesPerRow
expr_stmt|;
block|}
name|has_alpha
operator|=
name|macData
operator|->
name|has_alpha
expr_stmt|;
name|has_mask
operator|=
name|macData
operator|->
name|has_mask
expr_stmt|;
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QMacPlatformPixmap
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Creates a \c CGImageRef equivalent to the QPixmap. Returns the \c CGImageRef handle.      It is the caller's responsibility to release the \c CGImageRef data     after use.      \warning This function is only available on Mac OS X.      \sa fromMacCGImageRef() */
end_comment
begin_function
DECL|function|toMacCGImageRef
name|CGImageRef
name|QPixmap
operator|::
name|toMacCGImageRef
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|CGImageRef
operator|)
name|macCGHandle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns a QPixmap that is equivalent to the given \a image.      \warning This function is only available on Mac OS X.      \sa toMacCGImageRef(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromMacCGImageRef
name|QPixmap
name|QPixmap
operator|::
name|fromMacCGImageRef
parameter_list|(
name|CGImageRef
name|image
parameter_list|)
block|{
specifier|const
name|size_t
name|w
init|=
name|CGImageGetWidth
argument_list|(
name|image
argument_list|)
decl_stmt|,
name|h
init|=
name|CGImageGetHeight
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|QPixmap
name|ret
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|ret
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|CGRect
name|rect
init|=
name|CGRectMake
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|CGContextRef
name|ctx
init|=
name|qt_mac_cg_context
argument_list|(
operator|&
name|ret
argument_list|)
decl_stmt|;
name|qt_mac_drawCGImage
argument_list|(
name|ctx
argument_list|,
operator|&
name|rect
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|CGContextRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
