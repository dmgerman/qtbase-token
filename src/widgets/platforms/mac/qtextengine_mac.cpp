begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextengine_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_coretext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfontengine_mac_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|// set the glyph attributes heuristically. Assumes a 1 to 1 relationship between chars and glyphs
comment|// and no reordering.
comment|// also computes logClusters heuristically
DECL|function|heuristicSetGlyphAttributes
specifier|static
name|void
name|heuristicSetGlyphAttributes
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|length
parameter_list|,
name|QGlyphLayout
modifier|*
name|glyphs
parameter_list|,
name|unsigned
name|short
modifier|*
name|logClusters
parameter_list|,
name|int
name|num_glyphs
parameter_list|)
block|{
comment|// ### zeroWidth and justification are missing here!!!!!
name|Q_UNUSED
argument_list|(
name|num_glyphs
argument_list|)
expr_stmt|;
comment|//     qDebug("QScriptEngine::heuristicSetGlyphAttributes, num_glyphs=%d", item->num_glyphs);
specifier|const
name|bool
name|symbolFont
init|=
literal|false
decl_stmt|;
comment|// ####
name|glyphs
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|mark
operator|=
literal|false
expr_stmt|;
name|glyphs
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
literal|true
expr_stmt|;
name|glyphs
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|dontPrint
operator|=
operator|(
operator|!
name|symbolFont
operator|&&
name|uc
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|0x00ad
operator|)
operator|||
name|qIsControlChar
argument_list|(
name|uc
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|lastCat
init|=
name|QChar
operator|::
name|category
argument_list|(
name|uc
index|[
literal|0
index|]
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|logClusters
index|[
name|i
index|]
operator|==
name|pos
condition|)
comment|// same glyph
continue|continue;
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|logClusters
index|[
name|i
index|]
condition|)
block|{
operator|++
name|pos
expr_stmt|;
block|}
comment|// hide soft-hyphens by default
if|if
condition|(
operator|(
operator|!
name|symbolFont
operator|&&
name|uc
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
operator|==
literal|0x00ad
operator|)
operator|||
name|qIsControlChar
argument_list|(
name|uc
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
argument_list|)
condition|)
name|glyphs
operator|->
name|attributes
index|[
name|pos
index|]
operator|.
name|dontPrint
operator|=
literal|true
expr_stmt|;
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|uc
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|cat
init|=
name|prop
operator|->
name|category
decl_stmt|;
comment|// one gets an inter character justification point if the current char is not a non spacing mark.
comment|// as then the current char belongs to the last one and one gets a space justification point
comment|// after the space char.
if|if
condition|(
name|lastCat
operator|==
name|QChar
operator|::
name|Separator_Space
condition|)
name|glyphs
operator|->
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Space
expr_stmt|;
elseif|else
if|if
condition|(
name|cat
operator|!=
name|QChar
operator|::
name|Mark_NonSpacing
condition|)
name|glyphs
operator|->
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Character
expr_stmt|;
else|else
name|glyphs
operator|->
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
name|lastCat
operator|=
name|cat
expr_stmt|;
block|}
name|pos
operator|=
name|logClusters
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|lastCat
operator|==
name|QChar
operator|::
name|Separator_Space
condition|)
name|glyphs
operator|->
name|attributes
index|[
name|pos
index|]
operator|.
name|justification
operator|=
name|HB_Space
expr_stmt|;
else|else
name|glyphs
operator|->
name|attributes
index|[
name|pos
index|]
operator|.
name|justification
operator|=
name|HB_Character
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|QArabicProperties
struct|struct
name|QArabicProperties
block|{
DECL|member|shape
name|unsigned
name|char
name|shape
decl_stmt|;
DECL|member|justification
name|unsigned
name|char
name|justification
decl_stmt|;
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QArabicProperties
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_enum
DECL|enum|QArabicShape
enum|enum
name|QArabicShape
block|{
DECL|enumerator|XIsolated
name|XIsolated
block|,
DECL|enumerator|XFinal
name|XFinal
block|,
DECL|enumerator|XInitial
name|XInitial
block|,
DECL|enumerator|XMedial
name|XMedial
block|,
comment|// intermediate state
DECL|enumerator|XCausing
name|XCausing
block|}
enum|;
end_enum
begin_comment
comment|// these groups correspond to the groups defined in the Unicode standard.
end_comment
begin_comment
comment|// Some of these groups are equal with regards to both joining and line breaking behaviour,
end_comment
begin_comment
comment|// and thus have the same enum value
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// I'm not sure the mapping of syriac to arabic enums is correct with regards to justification, but as
end_comment
begin_comment
comment|// I couldn't find any better document I'll hope for the best.
end_comment
begin_enum
DECL|enum|ArabicGroup
enum|enum
name|ArabicGroup
block|{
comment|// NonJoining
DECL|enumerator|ArabicNone
name|ArabicNone
block|,
DECL|enumerator|ArabicSpace
name|ArabicSpace
block|,
comment|// Transparent
DECL|enumerator|Transparent
name|Transparent
block|,
comment|// Causing
DECL|enumerator|Center
name|Center
block|,
DECL|enumerator|Kashida
name|Kashida
block|,
comment|// Arabic
comment|// Dual
DECL|enumerator|Beh
name|Beh
block|,
DECL|enumerator|Noon
name|Noon
block|,
DECL|enumerator|Meem
name|Meem
init|=
name|Noon
block|,
DECL|enumerator|Heh
name|Heh
init|=
name|Noon
block|,
DECL|enumerator|KnottedHeh
name|KnottedHeh
init|=
name|Noon
block|,
DECL|enumerator|HehGoal
name|HehGoal
init|=
name|Noon
block|,
DECL|enumerator|SwashKaf
name|SwashKaf
init|=
name|Noon
block|,
DECL|enumerator|Yeh
name|Yeh
block|,
DECL|enumerator|Hah
name|Hah
block|,
DECL|enumerator|Seen
name|Seen
block|,
DECL|enumerator|Sad
name|Sad
init|=
name|Seen
block|,
DECL|enumerator|Tah
name|Tah
block|,
DECL|enumerator|Kaf
name|Kaf
init|=
name|Tah
block|,
DECL|enumerator|Gaf
name|Gaf
init|=
name|Tah
block|,
DECL|enumerator|Lam
name|Lam
init|=
name|Tah
block|,
DECL|enumerator|Ain
name|Ain
block|,
DECL|enumerator|Feh
name|Feh
init|=
name|Ain
block|,
DECL|enumerator|Qaf
name|Qaf
init|=
name|Ain
block|,
comment|// Right
DECL|enumerator|Alef
name|Alef
block|,
DECL|enumerator|Waw
name|Waw
block|,
DECL|enumerator|Dal
name|Dal
block|,
DECL|enumerator|TehMarbuta
name|TehMarbuta
init|=
name|Dal
block|,
DECL|enumerator|Reh
name|Reh
block|,
DECL|enumerator|HamzaOnHehGoal
name|HamzaOnHehGoal
block|,
DECL|enumerator|YehWithTail
name|YehWithTail
init|=
name|HamzaOnHehGoal
block|,
DECL|enumerator|YehBarre
name|YehBarre
init|=
name|HamzaOnHehGoal
block|,
comment|// Syriac
comment|// Dual
DECL|enumerator|Beth
name|Beth
init|=
name|Beh
block|,
DECL|enumerator|Gamal
name|Gamal
init|=
name|Ain
block|,
DECL|enumerator|Heth
name|Heth
init|=
name|Noon
block|,
DECL|enumerator|Teth
name|Teth
init|=
name|Hah
block|,
DECL|enumerator|Yudh
name|Yudh
init|=
name|Noon
block|,
DECL|enumerator|Kaph
name|Kaph
init|=
name|Noon
block|,
DECL|enumerator|Lamadh
name|Lamadh
init|=
name|Lam
block|,
DECL|enumerator|Mim
name|Mim
init|=
name|Noon
block|,
DECL|enumerator|Nun
name|Nun
init|=
name|Noon
block|,
DECL|enumerator|Semakh
name|Semakh
init|=
name|Noon
block|,
DECL|enumerator|FinalSemakh
name|FinalSemakh
init|=
name|Noon
block|,
DECL|enumerator|SyriacE
name|SyriacE
init|=
name|Ain
block|,
DECL|enumerator|Pe
name|Pe
init|=
name|Ain
block|,
DECL|enumerator|ReversedPe
name|ReversedPe
init|=
name|Hah
block|,
DECL|enumerator|Qaph
name|Qaph
init|=
name|Noon
block|,
DECL|enumerator|Shin
name|Shin
init|=
name|Noon
block|,
DECL|enumerator|Fe
name|Fe
init|=
name|Ain
block|,
comment|// Right
DECL|enumerator|Alaph
name|Alaph
init|=
name|Alef
block|,
DECL|enumerator|Dalath
name|Dalath
init|=
name|Dal
block|,
DECL|enumerator|He
name|He
init|=
name|Dal
block|,
DECL|enumerator|SyriacWaw
name|SyriacWaw
init|=
name|Waw
block|,
DECL|enumerator|Zain
name|Zain
init|=
name|Alef
block|,
DECL|enumerator|YudhHe
name|YudhHe
init|=
name|Waw
block|,
DECL|enumerator|Sadhe
name|Sadhe
init|=
name|HamzaOnHehGoal
block|,
DECL|enumerator|Taw
name|Taw
init|=
name|Dal
block|,
comment|// Compiler bug? Otherwise ArabicGroupsEnd would be equal to Dal + 1.
DECL|enumerator|Dummy
name|Dummy
init|=
name|HamzaOnHehGoal
block|,
DECL|enumerator|ArabicGroupsEnd
name|ArabicGroupsEnd
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|arabic_group
specifier|static
specifier|const
name|unsigned
name|char
name|arabic_group
index|[
literal|0x150
index|]
init|=
block|{
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Alef
block|,
name|Alef
block|,
name|Waw
block|,
name|Alef
block|,
name|Yeh
block|,
name|Alef
block|,
name|Beh
block|,
name|TehMarbuta
block|,
name|Beh
block|,
name|Beh
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Dal
block|,
name|Dal
block|,
name|Reh
block|,
name|Reh
block|,
name|Seen
block|,
name|Seen
block|,
name|Sad
block|,
name|Sad
block|,
name|Tah
block|,
name|Tah
block|,
name|Ain
block|,
name|Ain
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
comment|// 0x640
name|Kashida
block|,
name|Feh
block|,
name|Qaf
block|,
name|Kaf
block|,
name|Lam
block|,
name|Meem
block|,
name|Noon
block|,
name|Heh
block|,
name|Waw
block|,
name|Yeh
block|,
name|Yeh
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Beh
block|,
name|Qaf
block|,
name|Transparent
block|,
name|Alef
block|,
name|Alef
block|,
name|Alef
block|,
name|ArabicNone
block|,
name|Alef
block|,
name|Waw
block|,
name|Waw
block|,
name|Yeh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
comment|// 0x680
name|Beh
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Seen
block|,
name|Seen
block|,
name|Seen
block|,
name|Sad
block|,
name|Sad
block|,
name|Tah
block|,
name|Ain
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Qaf
block|,
name|Qaf
block|,
name|Gaf
block|,
name|SwashKaf
block|,
name|Gaf
block|,
name|Kaf
block|,
name|Kaf
block|,
name|Kaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Lam
block|,
name|Lam
block|,
name|Lam
block|,
name|Lam
block|,
name|Noon
block|,
name|Noon
block|,
name|Noon
block|,
name|Noon
block|,
name|Noon
block|,
name|KnottedHeh
block|,
name|Hah
block|,
comment|// 0x6c0
name|TehMarbuta
block|,
name|HehGoal
block|,
name|HamzaOnHehGoal
block|,
name|HamzaOnHehGoal
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Yeh
block|,
name|YehWithTail
block|,
name|Yeh
block|,
name|Waw
block|,
name|Yeh
block|,
name|Yeh
block|,
name|YehBarre
block|,
name|YehBarre
block|,
name|ArabicNone
block|,
name|TehMarbuta
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Dal
block|,
name|Reh
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Seen
block|,
name|Sad
block|,
name|Ain
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|KnottedHeh
block|,
comment|// 0x700
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Alaph
block|,
name|Transparent
block|,
name|Beth
block|,
name|Gamal
block|,
name|Gamal
block|,
name|Dalath
block|,
name|Dalath
block|,
name|He
block|,
name|SyriacWaw
block|,
name|Zain
block|,
name|Heth
block|,
name|Teth
block|,
name|Teth
block|,
name|Yudh
block|,
name|YudhHe
block|,
name|Kaph
block|,
name|Lamadh
block|,
name|Mim
block|,
name|Nun
block|,
name|Semakh
block|,
name|FinalSemakh
block|,
name|SyriacE
block|,
name|Pe
block|,
name|ReversedPe
block|,
name|Sadhe
block|,
name|Qaph
block|,
name|Dalath
block|,
name|Shin
block|,
name|Taw
block|,
name|Beth
block|,
name|Gamal
block|,
name|Dalath
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Zain
block|,
name|Kaph
block|,
name|Fe
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|arabicGroup
specifier|static
specifier|inline
name|ArabicGroup
name|arabicGroup
parameter_list|(
name|unsigned
name|short
name|uc
parameter_list|)
block|{
if|if
condition|(
name|uc
operator|>=
literal|0x0600
operator|&&
name|uc
operator|<
literal|0x750
condition|)
return|return
operator|(
name|ArabicGroup
operator|)
name|arabic_group
index|[
name|uc
operator|-
literal|0x600
index|]
return|;
elseif|else
if|if
condition|(
name|uc
operator|==
literal|0x200d
condition|)
return|return
name|Center
return|;
elseif|else
if|if
condition|(
name|QChar
operator|::
name|category
argument_list|(
name|uc
argument_list|)
operator|==
name|QChar
operator|::
name|Separator_Space
condition|)
return|return
name|ArabicSpace
return|;
else|else
return|return
name|ArabicNone
return|;
block|}
end_function
begin_comment
comment|/*    Arabic shaping obeys a number of rules according to the joining classes (see Unicode book, section on    arabic).     Each unicode char has a joining class (right, dual (left&right), center (joincausing) or transparent).    transparent joining is not encoded in QChar::joining(), but applies to all combining marks and format marks.     Right join-causing: dual + center    Left join-causing: dual + right + center     Rules are as follows (for a string already in visual order, as we have it here):     R1 Transparent characters do not affect joining behaviour.    R2 A right joining character, that has a right join-causing char on the right will get form XRight    (R3 A left joining character, that has a left join-causing char on the left will get form XLeft)    Note: the above rule is meaningless, as there are no pure left joining characters defined in Unicode    R4 A dual joining character, that has a left join-causing char on the left and a right join-causing char on              the right will get form XMedial    R5  A dual joining character, that has a right join causing char on the right, and no left join causing char on the left          will get form XRight    R6 A dual joining character, that has a  left join causing char on the left, and no right join causing char on the right          will get form XLeft    R7 Otherwise the character will get form XIsolated     Additionally we have to do the minimal ligature support for lam-alef ligatures:     L1 Transparent characters do not affect ligature behaviour.    L2 Any sequence of Alef(XRight) + Lam(XMedial) will form the ligature Alef.Lam(XLeft)    L3 Any sequence of Alef(XRight) + Lam(XLeft) will form the ligature Alef.Lam(XIsolated)     The state table below handles rules R1-R7. */
end_comment
begin_enum
DECL|enum|Joining
enum|enum
name|Joining
block|{
DECL|enumerator|JNone
name|JNone
block|,
DECL|enumerator|JCausing
name|JCausing
block|,
DECL|enumerator|JDual
name|JDual
block|,
DECL|enumerator|JRight
name|JRight
block|,
DECL|enumerator|JTransparent
name|JTransparent
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|joining_for_group
specifier|static
specifier|const
name|Joining
name|joining_for_group
index|[
name|ArabicGroupsEnd
index|]
init|=
block|{
comment|// NonJoining
name|JNone
block|,
comment|// ArabicNone
name|JNone
block|,
comment|// ArabicSpace
comment|// Transparent
name|JTransparent
block|,
comment|// Transparent
comment|// Causing
name|JCausing
block|,
comment|// Center
name|JCausing
block|,
comment|// Kashida
comment|// Dual
name|JDual
block|,
comment|// Beh
name|JDual
block|,
comment|// Noon
name|JDual
block|,
comment|// Yeh
name|JDual
block|,
comment|// Hah
name|JDual
block|,
comment|// Seen
name|JDual
block|,
comment|// Tah
name|JDual
block|,
comment|// Ain
comment|// Right
name|JRight
block|,
comment|// Alef
name|JRight
block|,
comment|// Waw
name|JRight
block|,
comment|// Dal
name|JRight
block|,
comment|// Reh
name|JRight
comment|// HamzaOnHehGoal
block|}
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|JoiningPair
struct|struct
name|JoiningPair
block|{
DECL|member|form1
name|QArabicShape
name|form1
decl_stmt|;
DECL|member|form2
name|QArabicShape
name|form2
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|joining_table
specifier|static
specifier|const
name|JoiningPair
name|joining_table
index|[
literal|5
index|]
index|[
literal|4
index|]
init|=
comment|// None, Causing, Dual, Right
block|{
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XIsolated
block|,
name|XCausing
block|}
block|,
block|{
name|XIsolated
block|,
name|XInitial
block|}
block|,
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|}
block|,
comment|// XIsolated
block|{
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|,
block|{
name|XFinal
block|,
name|XCausing
block|}
block|,
block|{
name|XFinal
block|,
name|XInitial
block|}
block|,
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|}
block|,
comment|// XFinal
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XInitial
block|,
name|XCausing
block|}
block|,
block|{
name|XInitial
block|,
name|XMedial
block|}
block|,
block|{
name|XInitial
block|,
name|XFinal
block|}
block|}
block|,
comment|// XInitial
block|{
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|,
block|{
name|XMedial
block|,
name|XCausing
block|}
block|,
block|{
name|XMedial
block|,
name|XMedial
block|}
block|,
block|{
name|XMedial
block|,
name|XFinal
block|}
block|}
block|,
comment|// XMedial
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XIsolated
block|,
name|XCausing
block|}
block|,
block|{
name|XIsolated
block|,
name|XMedial
block|}
block|,
block|{
name|XIsolated
block|,
name|XFinal
block|}
block|}
block|,
comment|// XCausing
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* According to http://www.microsoft.com/middleeast/Arabicdev/IE6/KBase.asp  1. Find the priority of the connecting opportunities in each word 2. Add expansion at the highest priority connection opportunity 3. If more than one connection opportunity have the same highest value,    use the opportunity closest to the end of the word.  Following is a chart that provides the priority for connection opportunities and where expansion occurs. The character group names are those in table 6.6 of the UNICODE 2.0 book.   PrioritY        Glyph                   Condition                                       Kashida Location  Arabic_Kashida        User inserted Kashida   The user entered a Kashida in a position.       After the user                 (Shift+j or Shift+[E with hat])    Thus, it is the highest priority to insert an   inserted kashida                                         automatic kashida.  Arabic_Seen        Seen, Sad               Connecting to the next character.               After the character.                                         (Initial or medial form).  Arabic_HaaDal        Teh Marbutah, Haa, Dal  Connecting to previous character.               Before the final form                                                                                         of these characters.  Arabic_Alef     Alef, Tah, Lam,         Connecting to previous character.               Before the final form                 Kaf and Gaf                                                             of these characters.  Arabic_BaRa     Reh, Yeh                Connected to medial Beh                         Before preceding medial Baa  Arabic_Waw        Waw, Ain, Qaf, Feh      Connecting to previous character.               Before the final form of                                                                                         these characters.  Arabic_Normal   Other connecting        Connecting to previous character.               Before the final form                 characters                                                              of these characters.    This seems to imply that we have at most one kashida point per arabic word.  */
end_comment
begin_function
DECL|function|qt_getArabicProperties
name|void
name|qt_getArabicProperties
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QArabicProperties
modifier|*
name|properties
parameter_list|)
block|{
comment|//     qDebug("arabicSyriacOpenTypeShape: properties:");
name|int
name|lastPos
init|=
literal|0
decl_stmt|;
name|int
name|lastGroup
init|=
name|ArabicNone
decl_stmt|;
name|ArabicGroup
name|group
init|=
name|arabicGroup
argument_list|(
name|chars
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Joining
name|j
init|=
name|joining_for_group
index|[
name|group
index|]
decl_stmt|;
name|QArabicShape
name|shape
init|=
name|joining_table
index|[
name|XIsolated
index|]
index|[
name|j
index|]
operator|.
name|form2
decl_stmt|;
name|properties
index|[
literal|0
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
comment|// #### fix handling for spaces and punktuation
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
name|group
operator|=
name|arabicGroup
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|joining_for_group
index|[
name|group
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|JTransparent
condition|)
block|{
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|=
name|XIsolated
expr_stmt|;
continue|continue;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form1
expr_stmt|;
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form2
expr_stmt|;
switch|switch
condition|(
name|lastGroup
condition|)
block|{
case|case
name|Seen
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XInitial
operator|||
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XMedial
condition|)
name|properties
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Seen
expr_stmt|;
break|break;
case|case
name|Hah
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_HaaDal
expr_stmt|;
break|break;
case|case
name|Alef
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Alef
expr_stmt|;
break|break;
case|case
name|Ain
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Waw
expr_stmt|;
break|break;
case|case
name|Noon
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Normal
expr_stmt|;
break|break;
case|case
name|ArabicNone
case|:
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|lastGroup
operator|=
name|ArabicNone
expr_stmt|;
switch|switch
condition|(
name|group
condition|)
block|{
case|case
name|ArabicNone
case|:
case|case
name|Transparent
case|:
comment|// ### Center should probably be treated as transparent when it comes to justification.
case|case
name|Center
case|:
break|break;
case|case
name|ArabicSpace
case|:
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Space
expr_stmt|;
break|break;
case|case
name|Kashida
case|:
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Kashida
expr_stmt|;
break|break;
case|case
name|Seen
case|:
name|lastGroup
operator|=
name|Seen
expr_stmt|;
break|break;
case|case
name|Hah
case|:
case|case
name|Dal
case|:
name|lastGroup
operator|=
name|Hah
expr_stmt|;
break|break;
case|case
name|Alef
case|:
case|case
name|Tah
case|:
name|lastGroup
operator|=
name|Alef
expr_stmt|;
break|break;
case|case
name|Yeh
case|:
case|case
name|Reh
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XMedial
operator|&&
name|arabicGroup
argument_list|(
name|chars
index|[
name|lastPos
index|]
argument_list|)
operator|==
name|Beh
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_BaRa
expr_stmt|;
break|break;
case|case
name|Ain
case|:
case|case
name|Waw
case|:
name|lastGroup
operator|=
name|Ain
expr_stmt|;
break|break;
case|case
name|Noon
case|:
case|case
name|Beh
case|:
case|case
name|HamzaOnHehGoal
case|:
name|lastGroup
operator|=
name|Noon
expr_stmt|;
break|break;
case|case
name|ArabicGroupsEnd
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|lastPos
operator|=
name|i
expr_stmt|;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|JNone
index|]
operator|.
name|form1
expr_stmt|;
comment|//     for (int i = 0; i< len; ++i)
comment|//         qDebug("arabic properties(%d): uc=%x shape=%d, justification=%d", i, chars[i], properties[i].shape, properties[i].justification);
block|}
end_function
begin_function
DECL|function|shapeTextMac
name|void
name|QTextEngine
operator|::
name|shapeTextMac
parameter_list|(
name|int
name|item
parameter_list|)
specifier|const
block|{
name|QScriptItem
modifier|&
name|si
init|=
name|layoutData
operator|->
name|items
index|[
name|item
index|]
decl_stmt|;
name|si
operator|.
name|glyph_data_offset
operator|=
name|layoutData
operator|->
name|used
expr_stmt|;
name|QFontEngine
modifier|*
name|font
init|=
name|fontEngine
argument_list|(
name|si
argument_list|,
operator|&
name|si
operator|.
name|ascent
argument_list|,
operator|&
name|si
operator|.
name|descent
argument_list|,
operator|&
name|si
operator|.
name|leading
argument_list|)
decl_stmt|;
if|if
condition|(
name|font
operator|->
name|type
argument_list|()
operator|!=
name|QFontEngine
operator|::
name|Multi
condition|)
block|{
name|shapeTextWithHarfbuzz
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
name|QCoreTextFontEngineMulti
modifier|*
name|fe
init|=
cast|static_cast
argument_list|<
name|QCoreTextFontEngineMulti
operator|*
argument_list|>
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|QTextEngine
operator|::
name|ShaperFlags
name|flags
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
name|flags
operator||=
name|RightToLeft
expr_stmt|;
if|if
condition|(
name|option
operator|.
name|useDesignMetrics
argument_list|()
condition|)
name|flags
operator||=
name|DesignMetrics
expr_stmt|;
name|attributes
argument_list|()
expr_stmt|;
comment|// pre-initialize char attributes
specifier|const
name|int
name|len
init|=
name|length
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|int
name|num_glyphs
init|=
name|length
argument_list|(
name|item
argument_list|)
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|str
init|=
name|layoutData
operator|->
name|string
operator|.
name|unicode
argument_list|()
operator|+
name|si
operator|.
name|position
decl_stmt|;
name|ushort
name|upperCased
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|SmallCaps
operator|||
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Uppercase
operator|||
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Lowercase
condition|)
block|{
name|ushort
modifier|*
name|uc
init|=
name|upperCased
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|256
condition|)
name|uc
operator|=
operator|new
name|ushort
index|[
name|len
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Lowercase
condition|)
name|uc
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
operator|.
name|toLower
argument_list|()
operator|.
name|unicode
argument_list|()
expr_stmt|;
else|else
name|uc
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
operator|.
name|toUpper
argument_list|()
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
name|str
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
name|ensureSpace
argument_list|(
name|num_glyphs
argument_list|)
expr_stmt|;
name|num_glyphs
operator|=
name|layoutData
operator|->
name|glyphLayout
operator|.
name|numGlyphs
operator|-
name|layoutData
operator|->
name|used
expr_stmt|;
name|QGlyphLayout
name|g
init|=
name|availableGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|g
operator|.
name|numGlyphs
operator|=
name|num_glyphs
expr_stmt|;
name|unsigned
name|short
modifier|*
name|log_clusters
init|=
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
name|bool
name|stringToCMapFailed
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|fe
operator|->
name|stringToCMap
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|num_glyphs
argument_list|,
name|flags
argument_list|,
name|log_clusters
argument_list|,
name|attributes
argument_list|()
argument_list|,
operator|&
name|si
argument_list|)
condition|)
block|{
name|ensureSpace
argument_list|(
name|num_glyphs
argument_list|)
expr_stmt|;
name|g
operator|=
name|availableGlyphs
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|stringToCMapFailed
operator|=
operator|!
name|fe
operator|->
name|stringToCMap
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
operator|&
name|g
argument_list|,
operator|&
name|num_glyphs
argument_list|,
name|flags
argument_list|,
name|log_clusters
argument_list|,
name|attributes
argument_list|()
argument_list|,
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stringToCMapFailed
condition|)
block|{
name|heuristicSetGlyphAttributes
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
operator|&
name|g
argument_list|,
name|log_clusters
argument_list|,
name|num_glyphs
argument_list|)
expr_stmt|;
name|si
operator|.
name|num_glyphs
operator|=
name|num_glyphs
expr_stmt|;
name|layoutData
operator|->
name|used
operator|+=
name|si
operator|.
name|num_glyphs
expr_stmt|;
name|QGlyphLayout
name|g
init|=
name|shapedGlyphs
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|analysis
operator|.
name|script
operator|==
name|QUnicodeTables
operator|::
name|Arabic
condition|)
block|{
name|QVarLengthArray
argument_list|<
name|QArabicProperties
argument_list|>
name|props
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|QArabicProperties
modifier|*
name|properties
init|=
name|props
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|f
init|=
name|si
operator|.
name|position
decl_stmt|;
name|int
name|l
init|=
name|len
decl_stmt|;
if|if
condition|(
name|f
operator|>
literal|0
condition|)
block|{
operator|--
name|f
expr_stmt|;
operator|++
name|l
expr_stmt|;
operator|++
name|properties
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|+
name|l
operator|<
name|layoutData
operator|->
name|string
operator|.
name|length
argument_list|()
condition|)
block|{
operator|++
name|l
expr_stmt|;
block|}
name|qt_getArabicProperties
argument_list|(
operator|(
specifier|const
name|unsigned
name|short
operator|*
operator|)
operator|(
name|layoutData
operator|->
name|string
operator|.
name|unicode
argument_list|()
operator|+
name|f
operator|)
argument_list|,
name|l
argument_list|,
name|props
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|short
modifier|*
name|log_clusters
init|=
name|logClusters
argument_list|(
operator|&
name|si
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|int
name|gpos
init|=
name|log_clusters
index|[
name|i
index|]
decl_stmt|;
name|g
operator|.
name|attributes
index|[
name|gpos
index|]
operator|.
name|justification
operator|=
name|properties
index|[
name|i
index|]
operator|.
name|justification
expr_stmt|;
block|}
block|}
block|}
specifier|const
name|ushort
modifier|*
name|uc
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|SmallCaps
operator|||
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Uppercase
operator|||
name|si
operator|.
name|analysis
operator|.
name|flags
operator|==
name|QScriptAnalysis
operator|::
name|Lowercase
operator|)
operator|&&
name|uc
operator|!=
name|upperCased
condition|)
operator|delete
index|[]
name|uc
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
