begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qsessionmanager.h"
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qsymbianevent.h"
end_include
begin_include
include|#
directive|include
file|"qeventdispatcher_s60_p.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qdesktopwidget.h"
end_include
begin_include
include|#
directive|include
file|"private/qbackingstore_p.h"
end_include
begin_include
include|#
directive|include
file|"qt_s60_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qevent_p.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qcombobox.h"
end_include
begin_include
include|#
directive|include
file|"private/qkeymapper_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfont_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STYLE_S60
end_ifndef
begin_include
include|#
directive|include
file|"private/qs60style_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qwindowsurface_s60_p.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengine.h"
end_include
begin_include
include|#
directive|include
file|"private/qmenubar_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsoftkeymanager_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_GRAPHICSSYSTEM_RUNTIME
end_ifdef
begin_include
include|#
directive|include
file|"private/qgraphicssystem_runtime_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"apgwgnam.h"
end_include
begin_comment
comment|// For CApaWindowGroupName
end_comment
begin_include
include|#
directive|include
file|<mdaaudiotoneplayer.h>
end_include
begin_comment
comment|// For CMdaAudioToneUtility
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qs60mainapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<centralrepository.h>
end_include
begin_include
include|#
directive|include
file|"qs60mainappui.h"
end_include
begin_include
include|#
directive|include
file|"qinputcontext.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_S60
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcoefepinputcontext_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qstylesheetstyle_p.h"
end_include
begin_include
include|#
directive|include
file|<hal.h>
end_include
begin_include
include|#
directive|include
file|<hal_data.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_SYMBIAN_TRANSITION_EFFECTS
end_ifdef
begin_include
include|#
directive|include
file|<graphics/wstfxconst.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// Goom Events through Window Server
DECL|variable|KGoomMemoryLowEvent
specifier|static
specifier|const
name|int
name|KGoomMemoryLowEvent
init|=
literal|0x10282DBF
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|KGoomMemoryGoodEvent
specifier|static
specifier|const
name|int
name|KGoomMemoryGoodEvent
init|=
literal|0x20026790
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Split view open/close events from AVKON
end_comment
begin_decl_stmt
DECL|variable|KSplitViewOpenEvent
specifier|static
specifier|const
name|int
name|KSplitViewOpenEvent
init|=
literal|0x2001E2C0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|KSplitViewCloseEvent
specifier|static
specifier|const
name|int
name|KSplitViewCloseEvent
init|=
literal|0x2001E2C1
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
end_if
begin_decl_stmt
DECL|variable|appNoGrab
specifier|static
name|bool
name|appNoGrab
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|appNoGrab
comment|// Grabbing enabled
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|app_do_modal
specifier|static
name|bool
name|app_do_modal
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|app_do_modal
comment|// modal mode
end_comment
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QS60Data
argument_list|,
name|qt_s60Data
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function_decl
specifier|extern
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
parameter_list|,
name|QEvent
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
specifier|extern
name|QWidgetList
modifier|*
name|qt_modal_stack
decl_stmt|;
end_decl_stmt
begin_comment
comment|// stack of modal widgets
end_comment
begin_decl_stmt
specifier|extern
name|QDesktopWidget
modifier|*
name|qt_desktopWidget
decl_stmt|;
end_decl_stmt
begin_comment
comment|// qapplication.cpp
end_comment
begin_decl_stmt
DECL|variable|qt_button_down
name|QWidget
modifier|*
name|qt_button_down
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_button_down
comment|// widget got last button-down
end_comment
begin_decl_stmt
DECL|member|lastFocusedControl
name|QSymbianControl
modifier|*
name|QSymbianControl
operator|::
name|lastFocusedControl
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qGlobalS60Data
name|QS60Data
modifier|*
name|qGlobalS60Data
parameter_list|()
block|{
return|return
name|qt_s60Data
argument_list|()
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_S60
end_ifdef
begin_function
DECL|function|setStatusPaneAndButtonGroupVisibility
name|void
name|QS60Data
operator|::
name|setStatusPaneAndButtonGroupVisibility
parameter_list|(
name|bool
name|statusPaneVisible
parameter_list|,
name|bool
name|buttonGroupVisible
parameter_list|)
block|{
name|bool
name|buttonGroupVisibilityChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|CEikButtonGroupContainer
modifier|*
specifier|const
name|b
init|=
name|buttonGroupContainer
argument_list|()
condition|)
block|{
name|buttonGroupVisibilityChanged
operator|=
operator|(
name|b
operator|->
name|IsVisible
argument_list|()
operator|!=
name|buttonGroupVisible
operator|)
expr_stmt|;
name|b
operator|->
name|MakeVisible
argument_list|(
name|buttonGroupVisible
argument_list|)
expr_stmt|;
block|}
name|bool
name|statusPaneVisibilityChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|CEikStatusPane
modifier|*
specifier|const
name|s
init|=
name|statusPane
argument_list|()
condition|)
block|{
name|statusPaneVisibilityChanged
operator|=
operator|(
name|s
operator|->
name|IsVisible
argument_list|()
operator|!=
name|statusPaneVisible
operator|)
expr_stmt|;
name|s
operator|->
name|MakeVisible
argument_list|(
name|statusPaneVisible
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buttonGroupVisibilityChanged
operator|||
name|statusPaneVisibilityChanged
condition|)
block|{
specifier|const
name|QSize
name|size
init|=
name|qt_TRect2QRect
argument_list|(
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|QSize
name|oldSize
decl_stmt|;
comment|// note that QDesktopWidget::resizeEvent ignores the QResizeEvent contents
name|QResizeEvent
name|event
argument_list|(
name|size
argument_list|,
name|oldSize
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|instance
argument_list|()
operator|->
name|sendEvent
argument_list|(
name|QApplication
operator|::
name|desktop
argument_list|()
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buttonGroupVisibilityChanged
operator|&&
operator|!
name|statusPaneVisibilityChanged
operator|&&
name|QApplication
operator|::
name|activeWindow
argument_list|()
condition|)
comment|// Ensure that control rectangle is updated
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|QApplication
operator|::
name|activeWindow
argument_list|()
operator|->
name|winId
argument_list|()
argument_list|)
operator|->
name|handleClientAreaChange
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setRecursiveDecorationsVisibility
name|bool
name|QS60Data
operator|::
name|setRecursiveDecorationsVisibility
parameter_list|(
name|QWidget
modifier|*
name|window
parameter_list|,
name|Qt
operator|::
name|WindowStates
name|newState
parameter_list|)
block|{
comment|// Show statusbar:
comment|//   Topmost parent: Show unless fullscreen/minimized.
comment|//   Child windows: Follow topmost parent, unless fullscreen, in which case do not show statusbar
comment|// Show CBA:
comment|//   Topmost parent: Show unless fullscreen/minimized.
comment|//     Exception: Show if fullscreen with Qt::WindowSoftkeysVisibleHint.
comment|//   Child windows:
comment|//     Minimized: Unclear if there is an use case for having focused minimized window at all.
comment|//       Always follow topmost parent just to be safe.
comment|//     Maximized and normal: follow topmost parent.
comment|//       Exception: If topmost parent is not showing CBA, show CBA if any softkey actions are
comment|//                  defined.
comment|//     Fullscreen: Show only if Qt::WindowSoftkeysVisibleHint set.
name|Qt
operator|::
name|WindowStates
name|comparisonState
init|=
name|newState
decl_stmt|;
name|QWidget
modifier|*
name|parentWindow
init|=
name|window
operator|->
name|parentWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentWindow
condition|)
block|{
while|while
condition|(
name|parentWindow
operator|->
name|parentWidget
argument_list|()
condition|)
name|parentWindow
operator|=
name|parentWindow
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
name|comparisonState
operator|=
name|parentWindow
operator|->
name|windowState
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|parentWindow
operator|=
name|window
expr_stmt|;
block|}
name|bool
name|decorationsVisible
init|=
operator|!
operator|(
name|comparisonState
operator|&
operator|(
name|Qt
operator|::
name|WindowFullScreen
operator||
name|Qt
operator|::
name|WindowMinimized
operator|)
operator|)
decl_stmt|;
specifier|const
name|bool
name|parentIsFullscreen
init|=
name|comparisonState
operator|&
name|Qt
operator|::
name|WindowFullScreen
decl_stmt|;
specifier|const
name|bool
name|parentCbaVisibilityHint
init|=
name|parentWindow
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|WindowSoftkeysVisibleHint
decl_stmt|;
name|bool
name|buttonGroupVisibility
init|=
operator|(
name|decorationsVisible
operator|||
operator|(
name|parentIsFullscreen
operator|&&
name|parentCbaVisibilityHint
operator|)
operator|)
decl_stmt|;
comment|// Do extra checking for child windows
if|if
condition|(
name|window
operator|->
name|parentWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|newState
operator|&
name|Qt
operator|::
name|WindowFullScreen
condition|)
block|{
name|decorationsVisible
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|WindowSoftkeysVisibleHint
condition|)
name|buttonGroupVisibility
operator|=
literal|true
expr_stmt|;
else|else
name|buttonGroupVisibility
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|newState
operator|&
name|Qt
operator|::
name|WindowMinimized
operator|)
operator|&&
operator|!
name|buttonGroupVisibility
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|window
operator|->
name|actions
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|window
operator|->
name|actions
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|softKeyRole
argument_list|()
operator|!=
name|QAction
operator|::
name|NoSoftKey
condition|)
block|{
name|buttonGroupVisibility
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|S60
operator|->
name|setStatusPaneAndButtonGroupVisibility
argument_list|(
name|decorationsVisible
argument_list|,
name|buttonGroupVisibility
argument_list|)
expr_stmt|;
return|return
name|decorationsVisible
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|controlVisibilityChanged
name|void
name|QS60Data
operator|::
name|controlVisibilityChanged
parameter_list|(
name|CCoeControl
modifier|*
name|control
parameter_list|,
name|bool
name|visible
parameter_list|)
block|{
if|if
condition|(
name|QWidgetPrivate
operator|::
name|mapper
operator|&&
name|QWidgetPrivate
operator|::
name|mapper
operator|->
name|contains
argument_list|(
name|control
argument_list|)
condition|)
block|{
name|QWidget
modifier|*
specifier|const
name|widget
init|=
name|QWidgetPrivate
operator|::
name|mapper
operator|->
name|value
argument_list|(
name|control
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
specifier|const
name|window
init|=
name|widget
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|QTLWExtra
modifier|*
name|topData
init|=
name|qt_widget_private
argument_list|(
name|window
argument_list|)
operator|->
name|maybeTopData
argument_list|()
condition|)
block|{
name|QWidgetBackingStoreTracker
modifier|&
name|backingStore
init|=
name|topData
operator|->
name|backingStore
decl_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
if|if
condition|(
name|backingStore
operator|.
name|data
argument_list|()
condition|)
block|{
name|backingStore
operator|.
name|registerWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|backingStore
operator|.
name|create
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|backingStore
operator|.
name|registerWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|qt_widget_private
argument_list|(
name|widget
argument_list|)
operator|->
name|invalidateBuffer
argument_list|(
name|widget
operator|->
name|rect
argument_list|()
argument_list|)
expr_stmt|;
name|widget
operator|->
name|repaint
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// In certain special scenarios we may get an ENotVisible event
comment|// without a previous EPartiallyVisible. The backingstore must
comment|// still be destroyed, hence the registerWidget() call below.
if|if
condition|(
name|backingStore
operator|.
name|data
argument_list|()
operator|&&
name|widget
operator|->
name|internalWinId
argument_list|()
operator|&&
name|qt_widget_private
argument_list|(
name|widget
argument_list|)
operator|->
name|maybeBackingStore
argument_list|()
operator|==
name|backingStore
operator|.
name|data
argument_list|()
condition|)
name|backingStore
operator|.
name|registerWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|backingStore
operator|.
name|unregisterWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
comment|// In order to ensure that any resources used by the window surface
comment|// are immediately freed, we flush the WSERV command buffer.
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|Flush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|qt_nograb
name|bool
name|qt_nograb
parameter_list|()
comment|// application no-grab option
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
return|return
name|appNoGrab
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|// Modified from http://www3.symbian.com/faq.nsf/0/0F1464EE96E737E780256D5E00503DD1?OpenDocument
end_comment
begin_class
DECL|class|QS60Beep
class|class
name|QS60Beep
super|:
specifier|public
name|CBase
super|,
specifier|public
name|MMdaAudioToneObserver
block|{
public|public:
specifier|static
name|QS60Beep
modifier|*
name|NewL
parameter_list|(
name|TInt
name|aFrequency
parameter_list|,
name|TTimeIntervalMicroSeconds
name|iDuration
parameter_list|)
function_decl|;
name|void
name|Play
parameter_list|()
function_decl|;
name|~
name|QS60Beep
parameter_list|()
destructor_decl|;
private|private:
name|void
name|ConstructL
parameter_list|(
name|TInt
name|aFrequency
parameter_list|,
name|TTimeIntervalMicroSeconds
name|iDuration
parameter_list|)
function_decl|;
name|void
name|MatoPrepareComplete
parameter_list|(
name|TInt
name|aError
parameter_list|)
function_decl|;
name|void
name|MatoPlayComplete
parameter_list|(
name|TInt
name|aError
parameter_list|)
function_decl|;
private|private:
typedef|typedef
enum|enum
block|{
DECL|enumerator|EBeepNotPrepared
name|EBeepNotPrepared
block|,
DECL|enumerator|EBeepPrepared
name|EBeepPrepared
block|,
DECL|enumerator|EBeepPlaying
name|EBeepPlaying
block|}
DECL|typedef|TBeepState
name|TBeepState
typedef|;
private|private:
DECL|member|iToneUtil
name|CMdaAudioToneUtility
modifier|*
name|iToneUtil
decl_stmt|;
DECL|member|iState
name|TBeepState
name|iState
decl_stmt|;
DECL|member|iFrequency
name|TInt
name|iFrequency
decl_stmt|;
DECL|member|iDuration
name|TTimeIntervalMicroSeconds
name|iDuration
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qt_S60Beep
specifier|static
name|QS60Beep
modifier|*
name|qt_S60Beep
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_destructor
DECL|function|~QS60Beep
name|QS60Beep
operator|::
name|~
name|QS60Beep
parameter_list|()
block|{
if|if
condition|(
name|iToneUtil
condition|)
block|{
switch|switch
condition|(
name|iState
condition|)
block|{
case|case
name|EBeepPlaying
case|:
name|iToneUtil
operator|->
name|CancelPlay
argument_list|()
expr_stmt|;
break|break;
case|case
name|EBeepNotPrepared
case|:
name|iToneUtil
operator|->
name|CancelPrepare
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
operator|delete
name|iToneUtil
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|NewL
name|QS60Beep
modifier|*
name|QS60Beep
operator|::
name|NewL
parameter_list|(
name|TInt
name|aFrequency
parameter_list|,
name|TTimeIntervalMicroSeconds
name|aDuration
parameter_list|)
block|{
name|QS60Beep
modifier|*
name|self
init|=
operator|new
operator|(
name|ELeave
operator|)
name|QS60Beep
argument_list|()
decl_stmt|;
name|CleanupStack
operator|::
name|PushL
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|self
operator|->
name|ConstructL
argument_list|(
name|aFrequency
argument_list|,
name|aDuration
argument_list|)
expr_stmt|;
name|CleanupStack
operator|::
name|Pop
argument_list|()
expr_stmt|;
return|return
name|self
return|;
block|}
end_function
begin_function
DECL|function|ConstructL
name|void
name|QS60Beep
operator|::
name|ConstructL
parameter_list|(
name|TInt
name|aFrequency
parameter_list|,
name|TTimeIntervalMicroSeconds
name|aDuration
parameter_list|)
block|{
name|iToneUtil
operator|=
name|CMdaAudioToneUtility
operator|::
name|NewL
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|iState
operator|=
name|EBeepNotPrepared
expr_stmt|;
name|iFrequency
operator|=
name|aFrequency
expr_stmt|;
name|iDuration
operator|=
name|aDuration
expr_stmt|;
name|iToneUtil
operator|->
name|PrepareToPlayTone
argument_list|(
name|iFrequency
argument_list|,
name|iDuration
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Play
name|void
name|QS60Beep
operator|::
name|Play
parameter_list|()
block|{
if|if
condition|(
name|iState
operator|==
name|EBeepPlaying
condition|)
block|{
name|iToneUtil
operator|->
name|CancelPlay
argument_list|()
expr_stmt|;
name|iState
operator|=
name|EBeepPrepared
expr_stmt|;
block|}
name|iToneUtil
operator|->
name|Play
argument_list|()
expr_stmt|;
name|iState
operator|=
name|EBeepPlaying
expr_stmt|;
block|}
end_function
begin_function
DECL|function|MatoPrepareComplete
name|void
name|QS60Beep
operator|::
name|MatoPrepareComplete
parameter_list|(
name|TInt
name|aError
parameter_list|)
block|{
if|if
condition|(
name|aError
operator|==
name|KErrNone
condition|)
block|{
name|iState
operator|=
name|EBeepPrepared
expr_stmt|;
name|Play
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|MatoPlayComplete
name|void
name|QS60Beep
operator|::
name|MatoPlayComplete
parameter_list|(
name|TInt
name|aError
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|aError
argument_list|)
expr_stmt|;
name|iState
operator|=
name|EBeepPrepared
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mapToQtModifiers
specifier|static
name|Qt
operator|::
name|KeyboardModifiers
name|mapToQtModifiers
parameter_list|(
name|TUint
name|s60Modifiers
parameter_list|)
block|{
name|Qt
operator|::
name|KeyboardModifiers
name|result
init|=
name|Qt
operator|::
name|NoModifier
decl_stmt|;
if|if
condition|(
name|s60Modifiers
operator|&
name|EModifierKeypad
condition|)
name|result
operator||=
name|Qt
operator|::
name|KeypadModifier
expr_stmt|;
if|if
condition|(
name|s60Modifiers
operator|&
name|EModifierShift
operator|||
name|s60Modifiers
operator|&
name|EModifierLeftShift
operator|||
name|s60Modifiers
operator|&
name|EModifierRightShift
condition|)
name|result
operator||=
name|Qt
operator|::
name|ShiftModifier
expr_stmt|;
if|if
condition|(
name|s60Modifiers
operator|&
name|EModifierCtrl
operator|||
name|s60Modifiers
operator|&
name|EModifierLeftCtrl
operator|||
name|s60Modifiers
operator|&
name|EModifierRightCtrl
condition|)
name|result
operator||=
name|Qt
operator|::
name|ControlModifier
expr_stmt|;
if|if
condition|(
name|s60Modifiers
operator|&
name|EModifierAlt
operator|||
name|s60Modifiers
operator|&
name|EModifierLeftAlt
operator|||
name|s60Modifiers
operator|&
name|EModifierRightAlt
condition|)
name|result
operator||=
name|Qt
operator|::
name|AltModifier
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|mapS60MouseEventTypeToQt
specifier|static
name|void
name|mapS60MouseEventTypeToQt
parameter_list|(
name|QEvent
operator|::
name|Type
modifier|*
name|type
parameter_list|,
name|Qt
operator|::
name|MouseButton
modifier|*
name|button
parameter_list|,
specifier|const
name|TPointerEvent
modifier|*
name|pEvent
parameter_list|)
block|{
switch|switch
condition|(
name|pEvent
operator|->
name|iType
condition|)
block|{
case|case
name|TPointerEvent
operator|::
name|EButton1Down
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonPress
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|LeftButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton1Up
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonRelease
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|LeftButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton2Down
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonPress
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|MidButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton2Up
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonRelease
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|MidButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton3Down
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonPress
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|RightButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton3Up
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonRelease
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|RightButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EDrag
case|:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseMove
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EMove
case|:
comment|// Qt makes no distinction between move and drag
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseMove
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
break|break;
default|default:
operator|*
name|type
operator|=
name|QEvent
operator|::
name|None
expr_stmt|;
operator|*
name|button
operator|=
name|Qt
operator|::
name|NoButton
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pEvent
operator|->
name|iModifiers
operator|&
name|EModifierDoubleClick
condition|)
block|{
operator|*
name|type
operator|=
name|QEvent
operator|::
name|MouseButtonDblClick
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|||
operator|*
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonDblClick
condition|)
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|=
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator||
operator|(
operator|*
name|button
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
condition|)
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|=
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|&
operator|(
operator|~
operator|(
operator|*
name|button
operator|)
operator|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|=
name|QApplicationPrivate
operator|::
name|mouse_buttons
operator|&
name|Qt
operator|::
name|MouseButtonMask
expr_stmt|;
block|}
end_function
begin_comment
comment|//### Can be replaced with CAknLongTapDetector if animation is required.
end_comment
begin_comment
comment|//NOTE: if CAknLongTapDetector is used make sure it gets variated out of 3.1 and 3.2,.
end_comment
begin_comment
comment|//also MLongTapObserver needs to be changed to MAknLongTapDetectorCallBack if CAknLongTapDetector is used.
end_comment
begin_class
DECL|class|QLongTapTimer
class|class
name|QLongTapTimer
super|:
specifier|public
name|CTimer
block|{
public|public:
specifier|static
name|QLongTapTimer
modifier|*
name|NewL
parameter_list|(
name|QAbstractLongTapObserver
modifier|*
name|observer
parameter_list|)
function_decl|;
name|QLongTapTimer
parameter_list|(
name|QAbstractLongTapObserver
modifier|*
name|observer
parameter_list|)
constructor_decl|;
name|void
name|ConstructL
parameter_list|()
function_decl|;
public|public:
name|void
name|PointerEventL
parameter_list|(
specifier|const
name|TPointerEvent
modifier|&
name|event
parameter_list|)
function_decl|;
name|void
name|RunL
parameter_list|()
function_decl|;
protected|protected:
private|private:
DECL|member|m_observer
name|QAbstractLongTapObserver
modifier|*
name|m_observer
decl_stmt|;
DECL|member|m_event
name|TPointerEvent
name|m_event
decl_stmt|;
DECL|member|m_pressedCoordinates
name|QPoint
name|m_pressedCoordinates
decl_stmt|;
DECL|member|m_dragDistance
name|int
name|m_dragDistance
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|NewL
name|QLongTapTimer
modifier|*
name|QLongTapTimer
operator|::
name|NewL
parameter_list|(
name|QAbstractLongTapObserver
modifier|*
name|observer
parameter_list|)
block|{
name|QLongTapTimer
modifier|*
name|self
init|=
operator|new
name|QLongTapTimer
argument_list|(
name|observer
argument_list|)
decl_stmt|;
name|self
operator|->
name|ConstructL
argument_list|()
expr_stmt|;
return|return
name|self
return|;
block|}
end_function
begin_function
DECL|function|ConstructL
name|void
name|QLongTapTimer
operator|::
name|ConstructL
parameter_list|()
block|{
name|CTimer
operator|::
name|ConstructL
argument_list|()
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QLongTapTimer
name|QLongTapTimer
operator|::
name|QLongTapTimer
parameter_list|(
name|QAbstractLongTapObserver
modifier|*
name|observer
parameter_list|)
member_init_list|:
name|CTimer
argument_list|(
name|CActive
operator|::
name|EPriorityHigh
argument_list|)
block|{
name|m_observer
operator|=
name|observer
expr_stmt|;
name|m_dragDistance
operator|=
name|qApp
operator|->
name|startDragDistance
argument_list|()
expr_stmt|;
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|PointerEventL
name|void
name|QLongTapTimer
operator|::
name|PointerEventL
parameter_list|(
specifier|const
name|TPointerEvent
modifier|&
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|.
name|iType
operator|==
name|TPointerEvent
operator|::
name|EDrag
operator|||
name|event
operator|.
name|iType
operator|==
name|TPointerEvent
operator|::
name|EButtonRepeat
condition|)
block|{
name|QPoint
name|diff
argument_list|(
name|QPoint
argument_list|(
name|event
operator|.
name|iPosition
operator|.
name|iX
argument_list|,
name|event
operator|.
name|iPosition
operator|.
name|iY
argument_list|)
operator|-
name|m_pressedCoordinates
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|.
name|manhattanLength
argument_list|()
operator|<
name|m_dragDistance
condition|)
return|return;
block|}
name|Cancel
argument_list|()
expr_stmt|;
name|m_event
operator|=
name|event
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|iType
operator|==
name|TPointerEvent
operator|::
name|EButton1Down
condition|)
block|{
name|m_pressedCoordinates
operator|=
name|QPoint
argument_list|(
name|event
operator|.
name|iPosition
operator|.
name|iX
argument_list|,
name|event
operator|.
name|iPosition
operator|.
name|iY
argument_list|)
expr_stmt|;
comment|// must be same as KLongTapDelay in aknlongtapdetector.h
name|After
argument_list|(
literal|800000
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QLongTapTimer
operator|::
name|RunL
parameter_list|()
block|{
if|if
condition|(
name|m_observer
condition|)
name|m_observer
operator|->
name|HandleLongTapEventL
argument_list|(
name|m_event
operator|.
name|iPosition
argument_list|,
name|m_event
operator|.
name|iParentPosition
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QSymbianControl
name|QSymbianControl
operator|::
name|QSymbianControl
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|CCoeControl
argument_list|()
member_init_list|,
name|qwidget
argument_list|(
name|w
argument_list|)
member_init_list|,
name|m_longTapDetector
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_ignoreFocusChanged
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_symbianPopupIsOpen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_inExternalScreenOverride
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_lastStatusPaneVisibility
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|ConstructL
name|void
name|QSymbianControl
operator|::
name|ConstructL
parameter_list|(
name|bool
name|isWindowOwning
parameter_list|,
name|bool
name|desktop
parameter_list|)
block|{
if|if
condition|(
operator|!
name|desktop
condition|)
block|{
if|if
condition|(
name|isWindowOwning
operator|||
operator|!
name|qwidget
operator|->
name|parentWidget
argument_list|()
operator|||
name|qwidget
operator|->
name|parentWidget
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
block|{
name|RWindowGroup
modifier|&
name|wg
argument_list|(
name|S60
operator|->
name|windowGroup
argument_list|(
name|qwidget
argument_list|)
argument_list|)
decl_stmt|;
name|CreateWindowL
argument_list|(
name|wg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/**              * TODO: in order to avoid creating windows for all ancestors of              * this widget up to the root window, the parameter passed to              * CreateWindowL should be              * qwidget->parentWidget()->effectiveWinId().  However, if we do              * this, then we need to take care of re-parenting when a window              * is created for a widget between this one and the root window.              */
name|CreateWindowL
argument_list|(
name|qwidget
operator|->
name|parentWidget
argument_list|()
operator|->
name|winId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Necessary in order to be able to track the activation status of
comment|// the control's window
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|createExtra
argument_list|()
expr_stmt|;
name|SetFocusing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|m_longTapDetector
operator|=
name|QLongTapTimer
operator|::
name|NewL
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_doubleClickTimer
operator|.
name|invalidate
argument_list|()
expr_stmt|;
name|DrawableWindow
argument_list|()
operator|->
name|SetPointerGrab
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_SYMBIAN_TRANSITION_EFFECTS
if|if
condition|(
name|OwnsWindow
argument_list|()
condition|)
block|{
name|TTfxWindowPurpose
name|windowPurpose
argument_list|(
name|ETfxPurposeNone
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|qwidget
operator|->
name|windowType
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Dialog
case|:
name|windowPurpose
operator|=
name|ETfxPurposeDialogWindow
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Popup
case|:
name|windowPurpose
operator|=
name|ETfxPurposePopupWindow
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|Tool
case|:
name|windowPurpose
operator|=
name|ETfxPurposeToolWindow
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|ToolTip
case|:
name|windowPurpose
operator|=
name|ETfxPurposeToolTipWindow
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|SplashScreen
case|:
name|windowPurpose
operator|=
name|ETfxPurposeSplashScreenWindow
expr_stmt|;
break|break;
default|default:
name|windowPurpose
operator|=
operator|(
name|isWindowOwning
operator|||
operator|!
name|qwidget
operator|->
name|parentWidget
argument_list|()
operator|||
name|qwidget
operator|->
name|parentWidget
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|?
name|ETfxPurposeWindow
else|:
name|ETfxPurposeChildWindow
expr_stmt|;
break|break;
block|}
name|Window
argument_list|()
operator|.
name|SetPurpose
argument_list|(
name|windowPurpose
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_destructor
DECL|function|~QSymbianControl
name|QSymbianControl
operator|::
name|~
name|QSymbianControl
parameter_list|()
block|{
comment|// Ensure backing store is deleted before the top-level
comment|// window is destroyed
name|qt_widget_private
argument_list|(
name|qwidget
argument_list|)
operator|->
name|topData
argument_list|()
operator|->
name|backingStore
operator|.
name|destroy
argument_list|()
expr_stmt|;
if|if
condition|(
name|S60
operator|->
name|curWin
operator|==
name|this
condition|)
name|S60
operator|->
name|curWin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
block|{
name|QT_TRY
block|{
name|setFocusSafely
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::exception&
argument_list|)
block|{
comment|// ignore exceptions, nothing can be done
block|}
block|}
name|S60
operator|->
name|appUi
argument_list|()
operator|->
name|RemoveFromStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
operator|delete
name|m_longTapDetector
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setWidget
name|void
name|QSymbianControl
operator|::
name|setWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|qwidget
operator|=
name|w
expr_stmt|;
block|}
end_function
begin_function
DECL|function|translatePointForFixedNativeOrientation
name|QPoint
name|QSymbianControl
operator|::
name|translatePointForFixedNativeOrientation
parameter_list|(
specifier|const
name|TPoint
modifier|&
name|pointerEventPos
parameter_list|)
specifier|const
block|{
name|QPoint
name|pos
argument_list|(
name|pointerEventPos
operator|.
name|iX
argument_list|,
name|pointerEventPos
operator|.
name|iY
argument_list|)
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
condition|)
block|{
name|QSize
name|wsize
init|=
name|qwidget
operator|->
name|size
argument_list|()
decl_stmt|;
name|TSize
name|size
init|=
name|Size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|.
name|iWidth
operator|==
name|wsize
operator|.
name|height
argument_list|()
operator|&&
name|size
operator|.
name|iHeight
operator|==
name|wsize
operator|.
name|width
argument_list|()
condition|)
block|{
name|qreal
name|x
init|=
name|pos
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
name|pos
operator|.
name|setX
argument_list|(
name|size
operator|.
name|iHeight
operator|-
name|y
argument_list|)
expr_stmt|;
name|pos
operator|.
name|setY
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pos
return|;
block|}
end_function
begin_function
DECL|function|translateRectForFixedNativeOrientation
name|TRect
name|QSymbianControl
operator|::
name|translateRectForFixedNativeOrientation
parameter_list|(
specifier|const
name|TRect
modifier|&
name|controlRect
parameter_list|)
specifier|const
block|{
name|TRect
name|rect
init|=
name|controlRect
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
condition|)
block|{
name|QPoint
name|a
init|=
name|translatePointForFixedNativeOrientation
argument_list|(
name|rect
operator|.
name|iTl
argument_list|)
decl_stmt|;
name|QPoint
name|b
init|=
name|translatePointForFixedNativeOrientation
argument_list|(
name|rect
operator|.
name|iBr
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|x
argument_list|()
operator|<
name|b
operator|.
name|x
argument_list|()
condition|)
block|{
name|rect
operator|.
name|iTl
operator|.
name|iX
operator|=
name|a
operator|.
name|x
argument_list|()
expr_stmt|;
name|rect
operator|.
name|iBr
operator|.
name|iX
operator|=
name|b
operator|.
name|x
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rect
operator|.
name|iTl
operator|.
name|iX
operator|=
name|b
operator|.
name|x
argument_list|()
expr_stmt|;
name|rect
operator|.
name|iBr
operator|.
name|iX
operator|=
name|a
operator|.
name|x
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|.
name|y
argument_list|()
operator|<
name|b
operator|.
name|y
argument_list|()
condition|)
block|{
name|rect
operator|.
name|iTl
operator|.
name|iY
operator|=
name|a
operator|.
name|y
argument_list|()
expr_stmt|;
name|rect
operator|.
name|iBr
operator|.
name|iY
operator|=
name|b
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rect
operator|.
name|iTl
operator|.
name|iY
operator|=
name|b
operator|.
name|y
argument_list|()
expr_stmt|;
name|rect
operator|.
name|iBr
operator|.
name|iY
operator|=
name|a
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|rect
return|;
block|}
end_function
begin_function
DECL|function|HandleLongTapEventL
name|void
name|QSymbianControl
operator|::
name|HandleLongTapEventL
parameter_list|(
specifier|const
name|TPoint
modifier|&
name|aPenEventLocation
parameter_list|,
specifier|const
name|TPoint
modifier|&
name|aPenEventScreenLocation
parameter_list|)
block|{
name|QWidget
modifier|*
name|alienWidget
decl_stmt|;
name|QPoint
name|widgetPos
init|=
name|translatePointForFixedNativeOrientation
argument_list|(
name|aPenEventLocation
argument_list|)
decl_stmt|;
name|QPoint
name|globalPos
init|=
name|translatePointForFixedNativeOrientation
argument_list|(
name|aPenEventScreenLocation
argument_list|)
decl_stmt|;
name|alienWidget
operator|=
name|qwidget
operator|->
name|childAt
argument_list|(
name|widgetPos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alienWidget
condition|)
name|alienWidget
operator|=
name|qwidget
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_CONTEXTMENU
argument_list|)
name|QContextMenuEvent
name|contextMenuEvent
argument_list|(
name|QContextMenuEvent
operator|::
name|Mouse
argument_list|,
name|widgetPos
argument_list|,
name|globalPos
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
name|qt_sendSpontaneousEvent
argument_list|(
name|alienWidget
argument_list|,
operator|&
name|contextMenuEvent
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
end_ifdef
begin_function
DECL|function|translateAdvancedPointerEvent
name|void
name|QSymbianControl
operator|::
name|translateAdvancedPointerEvent
parameter_list|(
specifier|const
name|TAdvancedPointerEvent
modifier|*
name|event
parameter_list|)
block|{
name|QApplicationPrivate
modifier|*
name|d
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
name|QPointF
name|screenPos
init|=
name|qwidget
operator|->
name|mapToGlobal
argument_list|(
name|translatePointForFixedNativeOrientation
argument_list|(
name|event
operator|->
name|iPosition
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|pressure
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|pressureSupported
operator|&&
name|event
operator|->
name|Pressure
argument_list|()
operator|>
literal|0
condition|)
comment|//workaround for misconfigured HAL
name|pressure
operator|=
name|event
operator|->
name|Pressure
argument_list|()
operator|/
name|qreal
argument_list|(
name|d
operator|->
name|maxTouchPressure
argument_list|)
expr_stmt|;
else|else
name|pressure
operator|=
name|qreal
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|processTouchEvent
argument_list|(
name|event
operator|->
name|PointerNumber
argument_list|()
argument_list|,
name|event
operator|->
name|iType
argument_list|,
name|screenPos
argument_list|,
name|pressure
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|processTouchEvent
name|void
name|QSymbianControl
operator|::
name|processTouchEvent
parameter_list|(
name|int
name|pointerNumber
parameter_list|,
name|TPointerEvent
operator|::
name|TType
name|type
parameter_list|,
name|QPointF
name|screenPos
parameter_list|,
name|qreal
name|pressure
parameter_list|)
block|{
name|QRect
name|screenGeometry
init|=
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|(
name|qwidget
argument_list|)
decl_stmt|;
name|QApplicationPrivate
modifier|*
name|d
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|points
init|=
name|d
operator|->
name|appAllTouchPoints
decl_stmt|;
while|while
condition|(
name|points
operator|.
name|count
argument_list|()
operator|<=
name|pointerNumber
condition|)
name|points
operator|.
name|append
argument_list|(
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|(
name|points
operator|.
name|count
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|TouchPointStates
name|allStates
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|points
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|points
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|id
argument_list|()
operator|==
name|pointerNumber
condition|)
block|{
name|Qt
operator|::
name|TouchPointStates
name|state
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TPointerEvent
operator|::
name|EButton1Down
case|:
ifdef|#
directive|ifdef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
case|case
name|TPointerEvent
operator|::
name|EEnterHighPressure
case|:
endif|#
directive|endif
name|state
operator|=
name|Qt
operator|::
name|TouchPointPressed
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EButton1Up
case|:
ifdef|#
directive|ifdef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
case|case
name|TPointerEvent
operator|::
name|EExitCloseProximity
case|:
endif|#
directive|endif
name|state
operator|=
name|Qt
operator|::
name|TouchPointReleased
expr_stmt|;
break|break;
case|case
name|TPointerEvent
operator|::
name|EDrag
case|:
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
break|break;
default|default:
comment|// how likely is this to happen?
name|state
operator|=
name|Qt
operator|::
name|TouchPointStationary
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pointerNumber
operator|==
literal|0
condition|)
name|state
operator||=
name|Qt
operator|::
name|TouchPointPrimary
expr_stmt|;
name|touchPoint
operator|.
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setScreenPos
argument_list|(
name|screenPos
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setNormalizedPos
argument_list|(
name|QPointF
argument_list|(
name|screenPos
operator|.
name|x
argument_list|()
operator|/
name|screenGeometry
operator|.
name|width
argument_list|()
argument_list|,
name|screenPos
operator|.
name|y
argument_list|()
operator|/
name|screenGeometry
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setPressure
argument_list|(
name|pressure
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|!=
name|Qt
operator|::
name|TouchPointReleased
condition|)
block|{
comment|// all other active touch points should be marked as stationary
name|touchPoint
operator|.
name|setState
argument_list|(
name|Qt
operator|::
name|TouchPointStationary
argument_list|)
expr_stmt|;
block|}
name|allStates
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|allStates
operator|&
name|Qt
operator|::
name|TouchPointStateMask
operator|)
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
block|{
comment|// all touch points released
name|d
operator|->
name|appAllTouchPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|appAllTouchPoints
operator|=
name|points
expr_stmt|;
block|}
name|QApplicationPrivate
operator|::
name|translateRawTouchEvent
argument_list|(
name|qwidget
argument_list|,
name|QTouchEvent
operator|::
name|TouchScreen
argument_list|,
name|points
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|HandlePointerEventL
name|void
name|QSymbianControl
operator|::
name|HandlePointerEventL
parameter_list|(
specifier|const
name|TPointerEvent
modifier|&
name|pEvent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
if|if
condition|(
name|pEvent
operator|.
name|IsAdvancedPointerEvent
argument_list|()
condition|)
block|{
specifier|const
name|TAdvancedPointerEvent
modifier|*
name|advancedPointerEvent
init|=
name|pEvent
operator|.
name|AdvancedPointerEvent
argument_list|()
decl_stmt|;
name|translateAdvancedPointerEvent
argument_list|(
name|advancedPointerEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|advancedPointerEvent
operator|->
name|PointerNumber
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// only send mouse events for the first touch point
return|return;
block|}
block|}
endif|#
directive|endif
name|m_longTapDetector
operator|->
name|PointerEventL
argument_list|(
name|pEvent
argument_list|)
expr_stmt|;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|HandlePointerEvent
argument_list|(
name|pEvent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|HandlePointerEvent
name|void
name|QSymbianControl
operator|::
name|HandlePointerEvent
parameter_list|(
specifier|const
name|TPointerEvent
modifier|&
name|pEvent
parameter_list|)
block|{
name|QMouseEvent
operator|::
name|Type
name|type
decl_stmt|;
name|Qt
operator|::
name|MouseButton
name|button
decl_stmt|;
name|mapS60MouseEventTypeToQt
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|button
argument_list|,
operator|&
name|pEvent
argument_list|)
expr_stmt|;
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
init|=
name|mapToQtModifiers
argument_list|(
name|pEvent
operator|.
name|iModifiers
argument_list|)
decl_stmt|;
name|QPoint
name|widgetPos
init|=
name|translatePointForFixedNativeOrientation
argument_list|(
name|pEvent
operator|.
name|iPosition
argument_list|)
decl_stmt|;
name|TPoint
name|controlScreenPos
init|=
name|PositionRelativeToScreen
argument_list|()
decl_stmt|;
name|QPoint
name|globalPos
init|=
name|QPoint
argument_list|(
name|controlScreenPos
operator|.
name|iX
argument_list|,
name|controlScreenPos
operator|.
name|iY
argument_list|)
operator|+
name|widgetPos
decl_stmt|;
name|S60
operator|->
name|lastCursorPos
operator|=
name|globalPos
expr_stmt|;
name|S60
operator|->
name|lastPointerEventPos
operator|=
name|widgetPos
expr_stmt|;
name|QWidget
modifier|*
name|mouseGrabber
init|=
name|QWidget
operator|::
name|mouseGrabber
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|popupWidget
init|=
name|qApp
operator|->
name|activePopupWidget
argument_list|()
decl_stmt|;
name|QWidget
modifier|*
name|popupReceiver
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|popupWidget
condition|)
block|{
name|QWidget
modifier|*
name|popupChild
init|=
name|popupWidget
operator|->
name|childAt
argument_list|(
name|popupWidget
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
argument_list|)
decl_stmt|;
name|popupReceiver
operator|=
name|popupChild
condition|?
name|popupChild
else|:
name|popupWidget
expr_stmt|;
block|}
if|if
condition|(
name|mouseGrabber
condition|)
block|{
if|if
condition|(
name|popupReceiver
condition|)
block|{
name|sendMouseEvent
argument_list|(
name|popupReceiver
argument_list|,
name|type
argument_list|,
name|globalPos
argument_list|,
name|button
argument_list|,
name|modifiers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendMouseEvent
argument_list|(
name|mouseGrabber
argument_list|,
name|type
argument_list|,
name|globalPos
argument_list|,
name|button
argument_list|,
name|modifiers
argument_list|)
expr_stmt|;
block|}
comment|// No Enter/Leave events in grabbing mode.
return|return;
block|}
name|QWidget
modifier|*
name|widgetUnderPointer
init|=
name|qwidget
operator|->
name|childAt
argument_list|(
name|widgetPos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widgetUnderPointer
condition|)
name|widgetUnderPointer
operator|=
name|qwidget
expr_stmt|;
name|QApplicationPrivate
operator|::
name|dispatchEnterLeave
argument_list|(
name|widgetUnderPointer
argument_list|,
name|S60
operator|->
name|lastPointerEventTarget
argument_list|)
expr_stmt|;
name|S60
operator|->
name|lastPointerEventTarget
operator|=
name|widgetUnderPointer
expr_stmt|;
name|QWidget
modifier|*
name|receiver
decl_stmt|;
if|if
condition|(
operator|!
name|popupReceiver
operator|&&
name|S60
operator|->
name|mousePressTarget
operator|&&
name|type
operator|!=
name|QEvent
operator|::
name|MouseButtonPress
condition|)
block|{
name|receiver
operator|=
name|S60
operator|->
name|mousePressTarget
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonRelease
condition|)
name|S60
operator|->
name|mousePressTarget
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|receiver
operator|=
name|popupReceiver
condition|?
name|popupReceiver
else|:
name|widgetUnderPointer
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QEvent
operator|::
name|MouseButtonPress
condition|)
name|S60
operator|->
name|mousePressTarget
operator|=
name|receiver
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_CURSOR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
argument_list|)
if|if
condition|(
name|S60
operator|->
name|brokenPointerCursors
condition|)
name|qt_symbian_move_cursor_sprite
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|//Generate single touch event for S60 5.0 (has touchscreen, does not have advanced pointers)
ifndef|#
directive|ifndef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
if|if
condition|(
name|S60
operator|->
name|hasTouchscreen
condition|)
block|{
name|processTouchEvent
argument_list|(
literal|0
argument_list|,
name|pEvent
operator|.
name|iType
argument_list|,
name|QPointF
argument_list|(
name|globalPos
argument_list|)
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sendMouseEvent
argument_list|(
name|receiver
argument_list|,
name|type
argument_list|,
name|globalPos
argument_list|,
name|button
argument_list|,
name|modifiers
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_S60
end_ifdef
begin_function
DECL|function|HandleStatusPaneSizeChange
name|void
name|QSymbianControl
operator|::
name|HandleStatusPaneSizeChange
parameter_list|()
block|{
name|QS60MainAppUi
modifier|*
name|s60AppUi
init|=
cast|static_cast
argument_list|<
name|QS60MainAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
decl_stmt|;
name|s60AppUi
operator|->
name|HandleStatusPaneSizeChange
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sendMouseEvent
name|void
name|QSymbianControl
operator|::
name|sendMouseEvent
parameter_list|(
name|QWidget
modifier|*
name|receiver
parameter_list|,
name|QEvent
operator|::
name|Type
name|type
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|globalPos
parameter_list|,
name|Qt
operator|::
name|MouseButton
name|button
parameter_list|,
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|QMouseEvent
name|mEvent
argument_list|(
name|type
argument_list|,
name|receiver
operator|->
name|mapFromGlobal
argument_list|(
name|globalPos
argument_list|)
argument_list|,
name|globalPos
argument_list|,
name|button
argument_list|,
name|QApplicationPrivate
operator|::
name|mouse_buttons
argument_list|,
name|modifiers
argument_list|)
decl_stmt|;
name|QEventDispatcherS60
modifier|*
name|dispatcher
decl_stmt|;
comment|// It is theoretically possible for someone to install a different event dispatcher.
if|if
condition|(
operator|(
name|dispatcher
operator|=
name|qobject_cast
argument_list|<
name|QEventDispatcherS60
operator|*
argument_list|>
argument_list|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventDispatcher
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dispatcher
operator|->
name|excludeUserInputEvents
argument_list|()
condition|)
block|{
name|dispatcher
operator|->
name|saveInputEvent
argument_list|(
name|this
argument_list|,
name|receiver
argument_list|,
operator|new
name|QMouseEvent
argument_list|(
name|mEvent
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sendMouseEvent
argument_list|(
name|receiver
argument_list|,
operator|&
name|mEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendMouseEvent
name|bool
name|QSymbianControl
operator|::
name|sendMouseEvent
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QMouseEvent
modifier|*
name|mEvent
parameter_list|)
block|{
return|return
name|qt_sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
name|mEvent
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|OfferKeyEventL
name|TKeyResponse
name|QSymbianControl
operator|::
name|OfferKeyEventL
parameter_list|(
specifier|const
name|TKeyEvent
modifier|&
name|keyEvent
parameter_list|,
name|TEventCode
name|type
parameter_list|)
block|{
name|TKeyResponse
name|r
init|=
name|EKeyWasNotConsumed
decl_stmt|;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|r
operator|=
name|OfferKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|OfferKeyEvent
name|TKeyResponse
name|QSymbianControl
operator|::
name|OfferKeyEvent
parameter_list|(
specifier|const
name|TKeyEvent
modifier|&
name|keyEvent
parameter_list|,
name|TEventCode
name|type
parameter_list|)
block|{
comment|/*       S60 has a confusing way of delivering key events. There are three types of       events: EEventKey, EEventKeyDown and EEventKeyUp. When a key is pressed,       EEventKeyDown is first generated, followed by EEventKey. Then, when the key is       released, EEventKeyUp is generated.       However, it is possible that only the EEventKey is generated alone, typically       in relation to virtual keyboards. In that case we need to take care to       generate both press and release events in Qt, since applications expect that.       We do this by having three states for each used scan code, depending on the       events received. See the switch below for what happens in each state       transition.     */
if|if
condition|(
name|type
operator|!=
name|EEventKeyDown
condition|)
if|if
condition|(
name|handleVirtualMouse
argument_list|(
name|keyEvent
argument_list|,
name|type
argument_list|)
operator|==
name|EKeyWasConsumed
condition|)
return|return
name|EKeyWasConsumed
return|;
name|TKeyResponse
name|ret
init|=
name|EKeyWasNotConsumed
decl_stmt|;
DECL|macro|GET_RETURN
define|#
directive|define
name|GET_RETURN
parameter_list|(
name|x
parameter_list|)
value|(ret = ((x) == EKeyWasConsumed) ? EKeyWasConsumed : ret)
comment|// This top level switch corresponds to the states, and the inner switches
comment|// correspond to the transitions.
name|QS60Data
operator|::
name|ScanCodeState
modifier|&
name|scanCodeState
init|=
name|S60
operator|->
name|scanCodeStates
index|[
name|keyEvent
operator|.
name|iScanCode
index|]
decl_stmt|;
switch|switch
condition|(
name|scanCodeState
condition|)
block|{
case|case
name|QS60Data
operator|::
name|Unpressed
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EEventKeyDown
case|:
name|scanCodeState
operator|=
name|QS60Data
operator|::
name|KeyDown
expr_stmt|;
break|break;
case|case
name|EEventKey
case|:
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyPress
argument_list|)
argument_list|)
expr_stmt|;
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyRelease
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEventKeyUp
case|:
comment|// No action.
break|break;
block|}
break|break;
case|case
name|QS60Data
operator|::
name|KeyDown
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EEventKeyDown
case|:
comment|// This should never happen, just stay in this state to be safe.
break|break;
case|case
name|EEventKey
case|:
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyPress
argument_list|)
argument_list|)
expr_stmt|;
name|scanCodeState
operator|=
name|QS60Data
operator|::
name|KeyDownAndKey
expr_stmt|;
break|break;
case|case
name|EEventKeyUp
case|:
name|scanCodeState
operator|=
name|QS60Data
operator|::
name|Unpressed
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|QS60Data
operator|::
name|KeyDownAndKey
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EEventKeyDown
case|:
comment|// This should never happen, just stay in this state to be safe.
break|break;
case|case
name|EEventKey
case|:
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyRelease
argument_list|)
argument_list|)
expr_stmt|;
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyPress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEventKeyUp
case|:
name|GET_RETURN
argument_list|(
name|sendSymbianKeyEvent
argument_list|(
name|keyEvent
argument_list|,
name|QEvent
operator|::
name|KeyRelease
argument_list|)
argument_list|)
expr_stmt|;
name|scanCodeState
operator|=
name|QS60Data
operator|::
name|Unpressed
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
name|ret
return|;
DECL|macro|GET_RETURN
undef|#
directive|undef
name|GET_RETURN
block|}
end_function
begin_function
DECL|function|sendSymbianKeyEvent
name|TKeyResponse
name|QSymbianControl
operator|::
name|sendSymbianKeyEvent
parameter_list|(
specifier|const
name|TKeyEvent
modifier|&
name|keyEvent
parameter_list|,
name|QEvent
operator|::
name|Type
name|type
parameter_list|)
block|{
comment|// Because S60 does not generate keysyms for EKeyEventDown and EKeyEventUp
comment|// events, we need to cache the keysyms from the EKeyEvent events. This is what
comment|// resolveS60ScanCode does.
name|TUint
name|s60Keysym
init|=
name|QApplicationPrivate
operator|::
name|resolveS60ScanCode
argument_list|(
name|keyEvent
operator|.
name|iScanCode
argument_list|,
name|keyEvent
operator|.
name|iCode
argument_list|)
decl_stmt|;
name|int
name|keyCode
decl_stmt|;
if|if
condition|(
name|s60Keysym
operator|==
name|EKeyNull
condition|)
block|{
comment|//some key events have 0 in iCode, for them iScanCode should be used
name|keyCode
operator|=
name|qt_keymapper_private
argument_list|()
operator|->
name|mapS60ScanCodesToQt
argument_list|(
name|keyEvent
operator|.
name|iScanCode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s60Keysym
operator|>=
literal|0x20
operator|&&
name|s60Keysym
operator|<
name|ENonCharacterKeyBase
condition|)
block|{
comment|// Normal characters keys.
name|keyCode
operator|=
name|s60Keysym
expr_stmt|;
block|}
else|else
block|{
comment|// Special S60 keys.
name|keyCode
operator|=
name|qt_keymapper_private
argument_list|()
operator|->
name|mapS60KeyToQt
argument_list|(
name|s60Keysym
argument_list|)
expr_stmt|;
block|}
name|Qt
operator|::
name|KeyboardModifiers
name|mods
init|=
name|mapToQtModifiers
argument_list|(
name|keyEvent
operator|.
name|iModifiers
argument_list|)
decl_stmt|;
name|QKeyEventEx
name|qKeyEvent
argument_list|(
name|type
argument_list|,
name|keyCode
argument_list|,
name|mods
argument_list|,
name|qt_keymapper_private
argument_list|()
operator|->
name|translateKeyEvent
argument_list|(
name|keyCode
argument_list|,
name|mods
argument_list|)
argument_list|,
operator|(
name|keyEvent
operator|.
name|iRepeats
operator|!=
literal|0
operator|)
argument_list|,
literal|1
argument_list|,
name|keyEvent
operator|.
name|iScanCode
argument_list|,
name|s60Keysym
argument_list|,
name|keyEvent
operator|.
name|iModifiers
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|widget
decl_stmt|;
name|widget
operator|=
name|QWidget
operator|::
name|keyboardGrabber
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|!=
literal|0
condition|)
block|{
name|widget
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|->
name|focusWidget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|widget
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|widget
operator|=
name|QApplicationPrivate
operator|::
name|focus_widget
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|widget
operator|=
name|qwidget
expr_stmt|;
block|}
block|}
block|}
name|QEventDispatcherS60
modifier|*
name|dispatcher
decl_stmt|;
comment|// It is theoretically possible for someone to install a different event dispatcher.
if|if
condition|(
operator|(
name|dispatcher
operator|=
name|qobject_cast
argument_list|<
name|QEventDispatcherS60
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventDispatcher
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dispatcher
operator|->
name|excludeUserInputEvents
argument_list|()
condition|)
block|{
name|dispatcher
operator|->
name|saveInputEvent
argument_list|(
name|this
argument_list|,
name|widget
argument_list|,
operator|new
name|QKeyEventEx
argument_list|(
name|qKeyEvent
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EKeyWasConsumed
return|;
block|}
block|}
return|return
name|sendKeyEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|qKeyEvent
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|handleVirtualMouse
name|TKeyResponse
name|QSymbianControl
operator|::
name|handleVirtualMouse
parameter_list|(
specifier|const
name|TKeyEvent
modifier|&
name|keyEvent
parameter_list|,
name|TEventCode
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|S60
operator|->
name|mouseInteractionEnabled
operator|&&
name|S60
operator|->
name|virtualMouseRequired
condition|)
block|{
comment|//translate keys to pointer
if|if
condition|(
operator|(
name|keyEvent
operator|.
name|iScanCode
operator|>=
name|EStdKeyLeftArrow
operator|&&
name|keyEvent
operator|.
name|iScanCode
operator|<=
name|EStdKeyDownArrow
operator|)
operator|||
operator|(
name|keyEvent
operator|.
name|iScanCode
operator|>=
name|EStdKeyDevice10
operator|&&
name|keyEvent
operator|.
name|iScanCode
operator|<=
name|EStdKeyDevice13
operator|)
operator|||
name|keyEvent
operator|.
name|iScanCode
operator|==
name|EStdKeyDevice3
condition|)
block|{
name|QPoint
name|pos
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
name|TPointerEvent
name|fakeEvent
decl_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
call|(
name|TPointerEvent
operator|::
name|TType
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fakeEvent
operator|.
name|iModifiers
operator|=
name|keyEvent
operator|.
name|iModifiers
expr_stmt|;
name|TInt
name|x
init|=
name|pos
operator|.
name|x
argument_list|()
decl_stmt|;
name|TInt
name|y
init|=
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|EEventKeyUp
condition|)
block|{
name|S60
operator|->
name|virtualMouseAccelTimeout
operator|.
name|start
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|keyEvent
operator|.
name|iScanCode
condition|)
block|{
case|case
name|EStdKeyLeftArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|Left
expr_stmt|;
break|break;
case|case
name|EStdKeyRightArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|Right
expr_stmt|;
break|break;
case|case
name|EStdKeyUpArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|Up
expr_stmt|;
break|break;
case|case
name|EStdKeyDownArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|Down
expr_stmt|;
break|break;
comment|// diagonal keys (named aliases don't exist in 3.1 SDK)
case|case
name|EStdKeyDevice10
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|LeftUp
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice11
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|RightUp
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice12
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|RightDown
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice13
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|LeftDown
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice3
case|:
comment|//select
if|if
condition|(
name|S60
operator|->
name|virtualMousePressedKeys
operator|&
name|QS60Data
operator|::
name|Select
condition|)
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EButton1Up
expr_stmt|;
name|S60
operator|->
name|virtualMousePressedKeys
operator|&=
operator|~
name|QS60Data
operator|::
name|Select
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|EEventKey
condition|)
block|{
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|dy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keyEvent
operator|.
name|iScanCode
operator|!=
name|EStdKeyDevice3
condition|)
block|{
name|m_doubleClickTimer
operator|.
name|invalidate
argument_list|()
expr_stmt|;
comment|//reset mouse accelleration after a short time with no moves
specifier|const
name|int
name|maxTimeBetweenKeyEventsMs
init|=
literal|500
decl_stmt|;
if|if
condition|(
name|S60
operator|->
name|virtualMouseAccelTimeout
operator|.
name|isValid
argument_list|()
operator|&&
name|S60
operator|->
name|virtualMouseAccelTimeout
operator|.
name|hasExpired
argument_list|(
name|maxTimeBetweenKeyEventsMs
argument_list|)
condition|)
block|{
name|S60
operator|->
name|virtualMouseAccelDX
operator|=
literal|0
expr_stmt|;
name|S60
operator|->
name|virtualMouseAccelDY
operator|=
literal|0
expr_stmt|;
block|}
name|S60
operator|->
name|virtualMouseAccelTimeout
operator|.
name|invalidate
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|keyEvent
operator|.
name|iScanCode
condition|)
block|{
case|case
name|EStdKeyLeftArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|Left
expr_stmt|;
name|dx
operator|=
operator|-
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyRightArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|Right
expr_stmt|;
name|dx
operator|=
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyUpArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|Up
expr_stmt|;
name|dy
operator|=
operator|-
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDownArrow
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|Down
expr_stmt|;
name|dy
operator|=
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice10
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|LeftUp
expr_stmt|;
name|dx
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice11
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|RightUp
expr_stmt|;
name|dx
operator|=
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice12
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|RightDown
expr_stmt|;
name|dx
operator|=
literal|1
expr_stmt|;
name|dy
operator|=
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice13
case|:
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|LeftDown
expr_stmt|;
name|dx
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
literal|1
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EMove
expr_stmt|;
break|break;
case|case
name|EStdKeyDevice3
case|:
comment|// Platform bug. If you start pressing several keys simultaneously (for
comment|// example for drag'n'drop), Symbian starts producing spurious up and
comment|// down messages for some keys. Therefore, make sure we have a clean slate
comment|// of pressed keys before starting a new button press.
if|if
condition|(
name|S60
operator|->
name|virtualMousePressedKeys
operator|&
name|QS60Data
operator|::
name|Select
condition|)
block|{
return|return
name|EKeyWasConsumed
return|;
block|}
else|else
block|{
name|S60
operator|->
name|virtualMousePressedKeys
operator||=
name|QS60Data
operator|::
name|Select
expr_stmt|;
name|fakeEvent
operator|.
name|iType
operator|=
name|TPointerEvent
operator|::
name|EButton1Down
expr_stmt|;
if|if
condition|(
name|m_doubleClickTimer
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|m_doubleClickTimer
operator|.
name|hasExpired
argument_list|(
name|QApplication
operator|::
name|doubleClickInterval
argument_list|()
argument_list|)
condition|)
block|{
name|fakeEvent
operator|.
name|iModifiers
operator||=
name|EModifierDoubleClick
expr_stmt|;
name|m_doubleClickTimer
operator|.
name|invalidate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|m_doubleClickTimer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|dx
condition|)
block|{
name|int
name|cdx
init|=
name|S60
operator|->
name|virtualMouseAccelDX
decl_stmt|;
comment|//reset accel on change of sign, else double accel
if|if
condition|(
name|dx
operator|*
name|cdx
operator|<=
literal|0
condition|)
name|cdx
operator|=
name|dx
expr_stmt|;
else|else
name|cdx
operator|*=
literal|4
expr_stmt|;
comment|//cap accelleration
if|if
condition|(
name|dx
operator|*
name|cdx
operator|>
name|S60
operator|->
name|virtualMouseMaxAccel
condition|)
name|cdx
operator|=
name|dx
operator|*
name|S60
operator|->
name|virtualMouseMaxAccel
expr_stmt|;
comment|//move mouse position
name|x
operator|+=
name|cdx
expr_stmt|;
name|S60
operator|->
name|virtualMouseAccelDX
operator|=
name|cdx
expr_stmt|;
block|}
if|if
condition|(
name|dy
condition|)
block|{
name|int
name|cdy
init|=
name|S60
operator|->
name|virtualMouseAccelDY
decl_stmt|;
if|if
condition|(
name|dy
operator|*
name|cdy
operator|<=
literal|0
condition|)
name|cdy
operator|=
name|dy
expr_stmt|;
else|else
name|cdy
operator|*=
literal|4
expr_stmt|;
if|if
condition|(
name|dy
operator|*
name|cdy
operator|>
name|S60
operator|->
name|virtualMouseMaxAccel
condition|)
name|cdy
operator|=
name|dy
operator|*
name|S60
operator|->
name|virtualMouseMaxAccel
expr_stmt|;
name|y
operator|+=
name|cdy
expr_stmt|;
name|S60
operator|->
name|virtualMouseAccelDY
operator|=
name|cdy
expr_stmt|;
block|}
block|}
comment|//clip to screen size (window server allows a sprite hotspot to be outside the screen)
name|int
name|screenNumber
init|=
name|S60
operator|->
name|screenNumberForWidget
argument_list|(
name|qwidget
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>=
name|S60
operator|->
name|screenWidthInPixelsForScreen
index|[
name|screenNumber
index|]
condition|)
name|x
operator|=
name|S60
operator|->
name|screenWidthInPixelsForScreen
index|[
name|screenNumber
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|>=
name|S60
operator|->
name|screenHeightInPixelsForScreen
index|[
name|screenNumber
index|]
condition|)
name|y
operator|=
name|S60
operator|->
name|screenHeightInPixelsForScreen
index|[
name|screenNumber
index|]
operator|-
literal|1
expr_stmt|;
name|TPoint
name|epos
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|TPoint
name|cpos
init|=
name|epos
operator|-
name|PositionRelativeToScreen
argument_list|()
decl_stmt|;
name|fakeEvent
operator|.
name|iPosition
operator|=
name|cpos
expr_stmt|;
name|fakeEvent
operator|.
name|iParentPosition
operator|=
name|epos
expr_stmt|;
if|if
condition|(
name|fakeEvent
operator|.
name|iType
operator|!=
operator|-
literal|1
condition|)
name|HandlePointerEvent
argument_list|(
name|fakeEvent
argument_list|)
expr_stmt|;
return|return
name|EKeyWasConsumed
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|EKeyWasNotConsumed
return|;
block|}
end_function
begin_function
DECL|function|sendInputEvent
name|void
name|QSymbianControl
operator|::
name|sendInputEvent
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QInputEvent
modifier|*
name|inputEvent
parameter_list|)
block|{
switch|switch
condition|(
name|inputEvent
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|sendKeyEvent
argument_list|(
name|widget
argument_list|,
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|inputEvent
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MouseButtonDblClick
case|:
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
case|case
name|QEvent
operator|::
name|MouseButtonRelease
case|:
case|case
name|QEvent
operator|::
name|MouseMove
case|:
name|sendMouseEvent
argument_list|(
name|widget
argument_list|,
cast|static_cast
argument_list|<
name|QMouseEvent
operator|*
argument_list|>
argument_list|(
name|inputEvent
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Shouldn't get here.
name|Q_ASSERT_X
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
literal|"QSymbianControl::sendInputEvent()"
argument_list|,
literal|"inputEvent->type() is unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|sendKeyEvent
name|TKeyResponse
name|QSymbianControl
operator|::
name|sendKeyEvent
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|QKeyEvent
modifier|*
name|keyEvent
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_WS_S60
argument_list|)
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|isEnabled
argument_list|()
operator|&&
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
condition|)
block|{
name|QInputContext
modifier|*
name|qic
init|=
name|widget
operator|->
name|inputContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|qic
operator|&&
name|qic
operator|->
name|filterEvent
argument_list|(
name|keyEvent
argument_list|)
condition|)
return|return
name|EKeyWasConsumed
return|;
block|}
endif|#
directive|endif
comment|// !defined(QT_NO_IM)&& defined(Q_OS_SYMBIAN)
if|if
condition|(
name|widget
operator|&&
name|qt_sendSpontaneousEvent
argument_list|(
name|widget
argument_list|,
name|keyEvent
argument_list|)
condition|)
if|if
condition|(
name|keyEvent
operator|->
name|isAccepted
argument_list|()
condition|)
return|return
name|EKeyWasConsumed
return|;
return|return
name|EKeyWasNotConsumed
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_WS_S60
argument_list|)
end_if
begin_function
DECL|function|InputCapabilities
name|TCoeInputCapabilities
name|QSymbianControl
operator|::
name|InputCapabilities
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|hasFocus
argument_list|()
condition|)
name|w
operator|=
name|qwidget
expr_stmt|;
else|else
name|w
operator|=
name|qwidget
operator|->
name|focusWidget
argument_list|()
expr_stmt|;
name|QCoeFepInputContext
modifier|*
name|ic
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|isEnabled
argument_list|()
operator|&&
name|w
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
operator|&&
operator|(
name|ic
operator|=
name|qobject_cast
argument_list|<
name|QCoeFepInputContext
operator|*
argument_list|>
argument_list|(
name|w
operator|->
name|inputContext
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
name|ic
operator|->
name|inputCapabilities
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|TCoeInputCapabilities
argument_list|(
name|TCoeInputCapabilities
operator|::
name|ENone
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|Draw
name|void
name|QSymbianControl
operator|::
name|Draw
parameter_list|(
specifier|const
name|TRect
modifier|&
name|controlRect
parameter_list|)
specifier|const
block|{
comment|// Set flag to avoid calling DrawNow in window surface
name|QWidget
modifier|*
name|window
init|=
name|qwidget
operator|->
name|window
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|QTLWExtra
modifier|*
name|topExtra
init|=
name|window
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|topExtra
argument_list|)
expr_stmt|;
name|TRect
name|wcontrolRect
init|=
name|translateRectForFixedNativeOrientation
argument_list|(
name|controlRect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|topExtra
operator|->
name|inExpose
condition|)
block|{
name|topExtra
operator|->
name|inExpose
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|qwidget
operator|->
name|isWindow
argument_list|()
condition|)
block|{
comment|// If we get here, then it means we have a native child window
comment|// Since no content should ever be painted to these windows, we
comment|// erase them with a transparent brush when they get an expose.
name|CWindowGc
modifier|&
name|gc
init|=
name|SystemGc
argument_list|()
decl_stmt|;
name|gc
operator|.
name|SetBrushColor
argument_list|(
name|TRgb
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gc
operator|.
name|Clear
argument_list|(
name|controlRect
argument_list|)
expr_stmt|;
block|}
name|QRect
name|exposeRect
init|=
name|qt_TRect2QRect
argument_list|(
name|wcontrolRect
argument_list|)
decl_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|syncBackingStore
argument_list|(
name|exposeRect
argument_list|)
expr_stmt|;
name|topExtra
operator|->
name|inExpose
operator|=
literal|false
expr_stmt|;
block|}
name|QWindowSurface
modifier|*
name|surface
init|=
name|qwidget
operator|->
name|windowSurface
argument_list|()
decl_stmt|;
name|QPaintEngine
modifier|*
name|engine
init|=
name|surface
condition|?
name|surface
operator|->
name|paintDevice
argument_list|()
operator|->
name|paintEngine
argument_list|()
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|engine
condition|)
return|return;
specifier|const
name|bool
name|sendNativePaintEvents
init|=
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
argument_list|()
operator|->
name|receiveNativePaintEvents
decl_stmt|;
if|if
condition|(
name|sendNativePaintEvents
condition|)
block|{
specifier|const
name|QRect
name|r
init|=
name|qt_TRect2QRect
argument_list|(
name|wcontrolRect
argument_list|)
decl_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|qwidget
argument_list|,
literal|"beginNativePaintEvent"
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QRect
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Map source rectangle into coordinates of the backing store.
specifier|const
name|QPoint
name|controlBase
argument_list|(
name|controlRect
operator|.
name|iTl
operator|.
name|iX
argument_list|,
name|controlRect
operator|.
name|iTl
operator|.
name|iY
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|backingStoreBase
init|=
name|qwidget
operator|->
name|mapTo
argument_list|(
name|qwidget
operator|->
name|window
argument_list|()
argument_list|,
name|controlBase
argument_list|)
decl_stmt|;
specifier|const
name|TRect
name|backingStoreRect
argument_list|(
name|TPoint
argument_list|(
name|backingStoreBase
operator|.
name|x
argument_list|()
argument_list|,
name|backingStoreBase
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|controlRect
operator|.
name|Size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QPaintEngine
operator|::
name|Raster
condition|)
block|{
name|QS60WindowSurface
modifier|*
name|s60Surface
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_GRAPHICSSYSTEM_RUNTIME
if|if
condition|(
name|QApplicationPrivate
operator|::
name|runtime_graphics_system
condition|)
block|{
name|QRuntimeWindowSurface
modifier|*
name|rtSurface
init|=
cast|static_cast
argument_list|<
name|QRuntimeWindowSurface
operator|*
argument_list|>
argument_list|(
name|qwidget
operator|->
name|windowSurface
argument_list|()
argument_list|)
decl_stmt|;
name|s60Surface
operator|=
cast|static_cast
argument_list|<
name|QS60WindowSurface
operator|*
argument_list|>
argument_list|(
name|rtSurface
operator|->
name|m_windowSurface
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|s60Surface
operator|=
cast|static_cast
argument_list|<
name|QS60WindowSurface
operator|*
argument_list|>
argument_list|(
name|qwidget
operator|->
name|windowSurface
argument_list|()
argument_list|)
expr_stmt|;
name|CFbsBitmap
modifier|*
name|bitmap
init|=
name|s60Surface
operator|->
name|symbianBitmap
argument_list|()
decl_stmt|;
name|CWindowGc
modifier|&
name|gc
init|=
name|SystemGc
argument_list|()
decl_stmt|;
name|QWExtra
operator|::
name|NativePaintMode
name|nativePaintMode
init|=
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
argument_list|()
operator|->
name|nativePaintMode
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|paintOnScreen
argument_list|()
condition|)
name|nativePaintMode
operator|=
name|QWExtra
operator|::
name|Disable
expr_stmt|;
switch|switch
condition|(
name|nativePaintMode
condition|)
block|{
case|case
name|QWExtra
operator|::
name|Disable
case|:
comment|// Do nothing
break|break;
case|case
name|QWExtra
operator|::
name|Blit
case|:
case|case
name|QWExtra
operator|::
name|BlitWriteAlpha
case|:
if|if
condition|(
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|isOpaque
operator|||
name|nativePaintMode
operator|==
name|QWExtra
operator|::
name|BlitWriteAlpha
condition|)
name|gc
operator|.
name|SetDrawMode
argument_list|(
name|CGraphicsContext
operator|::
name|EDrawModeWriteAlpha
argument_list|)
expr_stmt|;
name|gc
operator|.
name|BitBlt
argument_list|(
name|controlRect
operator|.
name|iTl
argument_list|,
name|bitmap
argument_list|,
name|backingStoreRect
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWExtra
operator|::
name|ZeroFill
case|:
if|if
condition|(
name|Window
argument_list|()
operator|.
name|DisplayMode
argument_list|()
operator|==
name|EColor16MA
operator|||
name|Window
argument_list|()
operator|.
name|DisplayMode
argument_list|()
operator|==
name|Q_SYMBIAN_ECOLOR16MAP
condition|)
block|{
name|gc
operator|.
name|SetBrushStyle
argument_list|(
name|CGraphicsContext
operator|::
name|ESolidBrush
argument_list|)
expr_stmt|;
name|gc
operator|.
name|SetDrawMode
argument_list|(
name|CGraphicsContext
operator|::
name|EDrawModeWriteAlpha
argument_list|)
expr_stmt|;
name|gc
operator|.
name|SetBrushColor
argument_list|(
name|TRgb
operator|::
name|Color16MA
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gc
operator|.
name|Clear
argument_list|(
name|controlRect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gc
operator|.
name|SetBrushColor
argument_list|(
name|TRgb
argument_list|(
literal|0x000000
argument_list|)
argument_list|)
expr_stmt|;
name|gc
operator|.
name|Clear
argument_list|(
name|controlRect
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendNativePaintEvents
condition|)
block|{
specifier|const
name|QRect
name|r
init|=
name|qt_TRect2QRect
argument_list|(
name|wcontrolRect
argument_list|)
decl_stmt|;
comment|// The draw ops aren't actually sent to WSERV until the graphics
comment|// context is deactivated, which happens in the function calling
comment|// this one.  We therefore delay the delivery of endNativePaintEvent,
comment|// to ensure that drawing has completed by the time the widget
comment|// receives the event.  Note that, if the widget needs to ensure
comment|// that the draw ops have actually been executed into the output
comment|// framebuffer, a call to RWsSession::Flush is required in the
comment|// endNativePaintEvent implementation.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|qwidget
argument_list|,
literal|"endNativePaintEvent"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QRect
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qwidgetResize_helper
name|void
name|QSymbianControl
operator|::
name|qwidgetResize_helper
parameter_list|(
specifier|const
name|QSize
modifier|&
name|newSize
parameter_list|)
block|{
name|QRect
name|cr
init|=
name|qwidget
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|QSize
name|oldSize
argument_list|(
name|cr
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|cr
operator|.
name|setSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|data
operator|->
name|crect
operator|=
name|cr
expr_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|QTLWExtra
modifier|*
name|tlwExtra
init|=
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
name|bool
name|slowResize
init|=
name|qgetenv
argument_list|(
literal|"QT_SLOW_TOPLEVEL_RESIZE"
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|slowResize
operator|&&
name|tlwExtra
condition|)
name|tlwExtra
operator|->
name|inTopLevelResize
operator|=
literal|true
expr_stmt|;
name|QResizeEvent
name|e
argument_list|(
name|newSize
argument_list|,
name|oldSize
argument_list|)
decl_stmt|;
name|qt_sendSpontaneousEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_StaticContents
argument_list|)
condition|)
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|syncBackingStore
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|slowResize
operator|&&
name|tlwExtra
condition|)
name|tlwExtra
operator|->
name|inTopLevelResize
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
condition|)
block|{
name|QResizeEvent
modifier|*
name|e
init|=
operator|new
name|QResizeEvent
argument_list|(
name|newSize
argument_list|,
name|oldSize
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|postEvent
argument_list|(
name|qwidget
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|SizeChanged
name|void
name|QSymbianControl
operator|::
name|SizeChanged
parameter_list|()
block|{
name|CCoeControl
operator|::
name|SizeChanged
argument_list|()
expr_stmt|;
comment|// When FixNativeOrientation had been called, the RWindow/CCoeControl size
comment|// and the surface/QWidget size have nothing to do with each other.
if|if
condition|(
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
condition|)
return|return;
name|QSize
name|oldSize
init|=
name|qwidget
operator|->
name|size
argument_list|()
decl_stmt|;
name|QSize
name|newSize
argument_list|(
name|Size
argument_list|()
operator|.
name|iWidth
argument_list|,
name|Size
argument_list|()
operator|.
name|iHeight
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSize
operator|!=
name|newSize
condition|)
block|{
comment|// Enforce the proper size for fullscreen widgets on the secondary screen.
specifier|const
name|bool
name|isFullscreen
init|=
name|qwidget
operator|->
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowFullScreen
decl_stmt|;
specifier|const
name|int
name|screenNumber
init|=
name|S60
operator|->
name|screenNumberForWidget
argument_list|(
name|qwidget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_inExternalScreenOverride
operator|&&
name|isFullscreen
operator|&&
name|screenNumber
operator|>
literal|0
condition|)
block|{
name|int
name|screenWidth
init|=
name|S60
operator|->
name|screenWidthInPixelsForScreen
index|[
name|screenNumber
index|]
decl_stmt|;
name|int
name|screenHeight
init|=
name|S60
operator|->
name|screenHeightInPixelsForScreen
index|[
name|screenNumber
index|]
decl_stmt|;
name|TSize
name|screenSize
argument_list|(
name|screenWidth
argument_list|,
name|screenHeight
argument_list|)
decl_stmt|;
if|if
condition|(
name|screenWidth
operator|>
literal|0
operator|&&
name|screenHeight
operator|>
literal|0
operator|&&
name|screenSize
operator|!=
name|Size
argument_list|()
condition|)
block|{
name|m_inExternalScreenOverride
operator|=
literal|true
expr_stmt|;
name|SetExtent
argument_list|(
name|TPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|screenSize
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|qwidgetResize_helper
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
name|m_inExternalScreenOverride
operator|=
literal|false
expr_stmt|;
comment|// CCoeControl::SetExtent calls SizeChanged, but does not call
comment|// PositionChanged, so we call it here to ensure that the widget's
comment|// position is updated.
name|PositionChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PositionChanged
name|void
name|QSymbianControl
operator|::
name|PositionChanged
parameter_list|()
block|{
name|CCoeControl
operator|::
name|PositionChanged
argument_list|()
expr_stmt|;
name|QPoint
name|oldPos
init|=
name|qwidget
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QPoint
name|newPos
argument_list|(
name|Position
argument_list|()
operator|.
name|iX
argument_list|,
name|Position
argument_list|()
operator|.
name|iY
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldPos
operator|!=
name|newPos
condition|)
block|{
name|QRect
name|cr
init|=
name|qwidget
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|cr
operator|.
name|moveTopLeft
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|data
operator|->
name|crect
operator|=
name|cr
expr_stmt|;
name|QTLWExtra
modifier|*
name|top
init|=
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|maybeTopData
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|&&
operator|(
name|qwidget
operator|->
name|windowState
argument_list|()
operator|&
operator|(
operator|~
name|Qt
operator|::
name|WindowActive
operator|)
operator|)
operator|==
name|Qt
operator|::
name|WindowNoState
condition|)
name|top
operator|->
name|normalGeometry
operator|.
name|moveTopLeft
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|QMoveEvent
name|e
argument_list|(
name|newPos
argument_list|,
name|oldPos
argument_list|)
decl_stmt|;
name|qt_sendSpontaneousEvent
argument_list|(
name|qwidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QMoveEvent
modifier|*
name|e
init|=
operator|new
name|QMoveEvent
argument_list|(
name|newPos
argument_list|,
name|oldPos
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|postEvent
argument_list|(
name|qwidget
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|FocusChanged
name|void
name|QSymbianControl
operator|::
name|FocusChanged
parameter_list|(
name|TDrawNow
comment|/* aDrawNow */
parameter_list|)
block|{
if|if
condition|(
name|m_ignoreFocusChanged
operator|||
operator|(
name|qwidget
operator|->
name|windowType
argument_list|()
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|==
name|Qt
operator|::
name|Desktop
condition|)
return|return;
ifdef|#
directive|ifdef
name|Q_WS_S60
if|if
condition|(
name|S60
operator|->
name|splitViewLastWidget
condition|)
return|return;
endif|#
directive|endif
comment|// Popups never get focused, but still receive the FocusChanged when they are hidden.
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|!=
literal|0
operator|||
operator|(
name|qwidget
operator|->
name|windowType
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|==
name|Qt
operator|::
name|Popup
condition|)
return|return;
if|if
condition|(
name|IsFocused
argument_list|()
operator|&&
name|IsVisible
argument_list|()
condition|)
block|{
if|if
condition|(
name|m_symbianPopupIsOpen
condition|)
block|{
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|fw
condition|)
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|fw
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
name|m_symbianPopupIsOpen
operator|=
literal|false
expr_stmt|;
block|}
name|QApplication
operator|::
name|setActiveWindow
argument_list|(
name|qwidget
operator|->
name|window
argument_list|()
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|setWindowIcon_sys
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|setWindowTitle_sys
argument_list|(
name|qwidget
operator|->
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_S60
if|if
condition|(
name|qwidget
operator|->
name|isWindow
argument_list|()
condition|)
name|S60
operator|->
name|setRecursiveDecorationsVisibility
argument_list|(
name|qwidget
argument_list|,
name|qwidget
operator|->
name|windowState
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|QApplication
operator|::
name|activeWindow
argument_list|()
operator|==
name|qwidget
operator|->
name|window
argument_list|()
condition|)
block|{
name|bool
name|focusedControlFound
init|=
literal|false
decl_stmt|;
name|WId
name|winId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QWidget
modifier|*
name|w
init|=
name|qwidget
operator|->
name|parentWidget
argument_list|()
init|;
name|w
operator|&&
operator|(
name|winId
operator|=
name|w
operator|->
name|internalWinId
argument_list|()
operator|)
condition|;
name|w
operator|=
name|w
operator|->
name|parentWidget
argument_list|()
control|)
block|{
if|if
condition|(
name|winId
operator|->
name|IsFocused
argument_list|()
operator|&&
name|winId
operator|->
name|IsVisible
argument_list|()
condition|)
block|{
name|focusedControlFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|isWindow
argument_list|()
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|focusedControlFound
condition|)
block|{
if|if
condition|(
name|CCoeEnv
operator|::
name|Static
argument_list|()
operator|->
name|AppUi
argument_list|()
operator|->
name|IsDisplayingMenuOrDialog
argument_list|()
operator|||
name|S60
operator|->
name|menuBeingConstructed
condition|)
block|{
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|fw
condition|)
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|fw
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
name|m_symbianPopupIsOpen
operator|=
literal|true
expr_stmt|;
return|return;
block|}
name|QApplication
operator|::
name|setActiveWindow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else { We don't touch the active window unless we were explicitly activated or deactivated }
block|}
end_function
begin_function
DECL|function|handleClientAreaChange
name|void
name|QSymbianControl
operator|::
name|handleClientAreaChange
parameter_list|()
block|{
specifier|const
name|bool
name|cbaVisibilityHint
init|=
name|qwidget
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|WindowSoftkeysVisibleHint
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|isFullScreen
argument_list|()
operator|&&
operator|!
name|cbaVisibilityHint
condition|)
block|{
name|SetExtentToWholeScreen
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qwidget
operator|->
name|isMaximized
argument_list|()
operator|||
operator|(
name|qwidget
operator|->
name|isFullScreen
argument_list|()
operator|&&
name|cbaVisibilityHint
operator|)
condition|)
block|{
name|TRect
name|r
init|=
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
decl_stmt|;
name|SetExtent
argument_list|(
name|r
operator|.
name|iTl
argument_list|,
name|r
operator|.
name|Size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qwidget
operator|->
name|isMinimized
argument_list|()
condition|)
block|{
comment|// Normal geometry
if|if
condition|(
operator|!
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
condition|)
block|{
name|qwidget
operator|->
name|adjustSize
argument_list|()
expr_stmt|;
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//not a user resize
block|}
if|if
condition|(
operator|!
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|)
operator|&&
name|qwidget
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Dialog
condition|)
block|{
name|TRect
name|r
init|=
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
decl_stmt|;
name|SetPosition
argument_list|(
name|r
operator|.
name|iTl
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Moved
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// not really an explicit position
block|}
block|}
block|}
end_function
begin_function
DECL|function|isSplitViewWidget
name|bool
name|QSymbianControl
operator|::
name|isSplitViewWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|bool
name|returnValue
init|=
literal|true
decl_stmt|;
comment|//Ignore events sent to non-active windows, not visible widgets and not parents of input widget.
if|if
condition|(
operator|!
name|qwidget
operator|->
name|isActiveWindow
argument_list|()
operator|||
operator|!
name|qwidget
operator|->
name|isVisible
argument_list|()
operator|||
operator|!
name|qwidget
operator|->
name|isAncestorOf
argument_list|(
name|widget
argument_list|)
condition|)
block|{
name|returnValue
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|returnValue
return|;
block|}
end_function
begin_function
DECL|function|HandleResourceChange
name|void
name|QSymbianControl
operator|::
name|HandleResourceChange
parameter_list|(
name|int
name|resourceType
parameter_list|)
block|{
switch|switch
condition|(
name|resourceType
condition|)
block|{
case|case
name|KSplitViewCloseEvent
case|:
comment|//intentional fall-through
case|case
name|KSplitViewOpenEvent
case|:
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_WS_S60
argument_list|)
comment|//Fetch widget getting the text input
name|QWidget
modifier|*
name|widget
init|=
name|QWidget
operator|::
name|keyboardGrabber
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
condition|)
block|{
name|widget
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|->
name|focusWidget
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|widget
operator|=
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|widget
operator|=
name|QApplicationPrivate
operator|::
name|focus_widget
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|widget
operator|=
name|qwidget
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|widget
condition|)
block|{
name|QCoeFepInputContext
modifier|*
name|ic
init|=
name|qobject_cast
argument_list|<
name|QCoeFepInputContext
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|inputContext
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ic
condition|)
block|{
name|ic
operator|=
name|qobject_cast
argument_list|<
name|QCoeFepInputContext
operator|*
argument_list|>
argument_list|(
name|qApp
operator|->
name|inputContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|&&
name|isSplitViewWidget
argument_list|(
name|widget
argument_list|)
condition|)
block|{
if|if
condition|(
name|resourceType
operator|==
name|KSplitViewCloseEvent
condition|)
block|{
name|ic
operator|->
name|resetSplitViewWidget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ensureFocusWidgetVisible
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|// !defined(QT_NO_IM)&& defined(Q_WS_S60)
block|}
break|break;
case|case
name|KInternalStatusPaneChange
case|:
comment|// When status pane is not visible, only handle client area change if status pane was
comment|// previously visible, as size changes to hidden status pane should not affect
comment|// client area.
if|if
condition|(
name|S60
operator|->
name|statusPane
argument_list|()
operator|&&
operator|(
name|S60
operator|->
name|statusPane
argument_list|()
operator|->
name|IsVisible
argument_list|()
operator|||
name|m_lastStatusPaneVisibility
operator|)
condition|)
block|{
name|m_lastStatusPaneVisibility
operator|=
name|S60
operator|->
name|statusPane
argument_list|()
operator|->
name|IsVisible
argument_list|()
expr_stmt|;
name|handleClientAreaChange
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|IsFocused
argument_list|()
operator|&&
name|IsVisible
argument_list|()
condition|)
block|{
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|setWindowIcon_sys
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|setWindowTitle_sys
argument_list|(
name|qwidget
operator|->
name|windowTitle
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KUidValueCoeFontChangeEvent
case|:
comment|// font change event
break|break;
ifdef|#
directive|ifdef
name|Q_WS_S60
case|case
name|KEikDynamicLayoutVariantSwitch
case|:
block|{
name|handleClientAreaChange
argument_list|()
expr_stmt|;
comment|// Send resize event to trigger desktopwidget workAreaResized signal
if|if
condition|(
name|qt_desktopWidget
condition|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|qt_desktopWidget
operator|->
name|size
argument_list|()
argument_list|,
name|qt_desktopWidget
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qt_desktopWidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
name|CCoeControl
operator|::
name|HandleResourceChange
argument_list|(
name|resourceType
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|CancelLongTapTimer
name|void
name|QSymbianControl
operator|::
name|CancelLongTapTimer
parameter_list|()
block|{
name|m_longTapDetector
operator|->
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|MopSupplyObject
name|TTypeUid
operator|::
name|Ptr
name|QSymbianControl
operator|::
name|MopSupplyObject
parameter_list|(
name|TTypeUid
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|iUid
operator|==
name|ETypeId
condition|)
return|return
name|id
operator|.
name|MakePtr
argument_list|(
name|this
argument_list|)
return|;
return|return
name|CCoeControl
operator|::
name|MopSupplyObject
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setFocusSafely
name|void
name|QSymbianControl
operator|::
name|setFocusSafely
parameter_list|(
name|bool
name|focus
parameter_list|)
block|{
comment|// The stack hack in here is very unfortunate, but it is the only way to ensure proper
comment|// focus in Symbian. If this is not executed, the control which happens to be on
comment|// the top of the stack may randomly be assigned focus by Symbian, for example
comment|// when creating new windows (specifically in CCoeAppUi::HandleStackChanged()).
comment|// Close any popups.
name|CEikonEnv
operator|::
name|Static
argument_list|()
operator|->
name|EikAppUi
argument_list|()
operator|->
name|StopDisplayingMenuBar
argument_list|()
expr_stmt|;
if|if
condition|(
name|focus
condition|)
block|{
name|S60
operator|->
name|appUi
argument_list|()
operator|->
name|RemoveFromStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Symbian doesn't automatically remove focus from the last focused control, so we need to
comment|// remember it and clear focus ourselves.
if|if
condition|(
name|lastFocusedControl
operator|&&
name|lastFocusedControl
operator|!=
name|this
condition|)
name|lastFocusedControl
operator|->
name|SetFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
operator|->
name|AddToStackL
argument_list|(
name|this
argument_list|,
name|ECoeStackPriorityDefault
operator|+
literal|1
argument_list|,
name|ECoeStackFlagStandard
argument_list|)
argument_list|)
expr_stmt|;
comment|// Note the + 1
name|lastFocusedControl
operator|=
name|this
expr_stmt|;
name|this
operator|->
name|SetFocus
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S60
operator|->
name|appUi
argument_list|()
operator|->
name|RemoveFromStack
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
operator|->
name|AddToStackL
argument_list|(
name|this
argument_list|,
name|ECoeStackPriorityDefault
argument_list|,
name|ECoeStackFlagStandard
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|==
name|lastFocusedControl
condition|)
name|lastFocusedControl
operator|=
literal|0
expr_stmt|;
name|this
operator|->
name|SetFocus
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isControlActive
name|bool
name|QSymbianControl
operator|::
name|isControlActive
parameter_list|()
block|{
return|return
name|IsActivated
argument_list|()
condition|?
literal|true
else|:
literal|false
return|;
block|}
end_function
begin_function
DECL|function|ensureFixNativeOrientation
name|void
name|QSymbianControl
operator|::
name|ensureFixNativeOrientation
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_SYMBIAN_SUPPORTS_FIXNATIVEORIENTATION
argument_list|)
if|if
condition|(
operator|!
name|qwidget
operator|->
name|isWindow
argument_list|()
operator|||
name|qwidget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
return|return;
if|if
condition|(
name|S60
operator|->
name|screenNumberForWidget
argument_list|(
name|qwidget
argument_list|)
operator|>
literal|0
condition|)
return|return;
specifier|const
name|bool
name|isFixed
init|=
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
decl_stmt|;
specifier|const
name|bool
name|isFixEnabled
init|=
name|qwidget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SymbianNoSystemRotation
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|isFullScreen
init|=
name|qwidget
operator|->
name|windowState
argument_list|()
operator|.
name|testFlag
argument_list|(
name|Qt
operator|::
name|WindowFullScreen
argument_list|)
decl_stmt|;
if|if
condition|(
name|isFullScreen
operator|&&
name|isFixEnabled
condition|)
block|{
specifier|const
name|bool
name|surfaceBasedGs
init|=
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|==
name|QLatin1String
argument_list|(
literal|"openvg"
argument_list|)
operator|||
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|==
name|QLatin1String
argument_list|(
literal|"opengl"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|surfaceBasedGs
condition|)
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SymbianNoSystemRotation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isFixed
operator|&&
name|surfaceBasedGs
condition|)
block|{
if|if
condition|(
name|Window
argument_list|()
operator|.
name|FixNativeOrientation
argument_list|()
operator|==
name|KErrNone
condition|)
block|{
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
operator|=
literal|true
expr_stmt|;
comment|// The EGL window surface is now fixed to the native orientation
comment|// of the device, no matter what size we pass when creating it.
comment|// Enforce the same size for the QWidget too. For the underlying
comment|// CCoeControl and RWindow it is up to the system to resize them
comment|// when the standard auto-rotation mechanism is in use, we must not
comment|// change that behavior by forcing any size for those. In practice
comment|// this means that the QWidget and the underlying native control
comment|// dimensions will be out of sync when FixNativeOrientation was
comment|// called and the device is turned to the non-native (typically
comment|// landscape) orientation. The pointer event handling and certain
comment|// functions like Draw() will need to compensate for this.
name|QSize
name|newSize
argument_list|(
name|S60
operator|->
name|nativeScreenWidthInPixels
argument_list|,
name|S60
operator|->
name|nativeScreenHeightInPixels
argument_list|)
decl_stmt|;
if|if
condition|(
name|qwidget
operator|->
name|size
argument_list|()
operator|!=
name|newSize
condition|)
name|qwidgetResize_helper
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SymbianNoSystemRotation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|isFixed
condition|)
block|{
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SymbianNoSystemRotation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|fixNativeOrientationCalled
operator|=
literal|false
expr_stmt|;
name|qwidget
operator|->
name|hide
argument_list|()
expr_stmt|;
name|qwidget
operator|->
name|d_func
argument_list|()
operator|->
name|create_sys
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|qwidget
operator|->
name|show
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|qwidget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SymbianNoSystemRotation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \typedef QApplication::QS60MainApplicationFactory     \since 4.6      This is a typedef for a pointer to a function with the following     signature:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 47      \sa QApplication::QApplication() */
end_comment
begin_comment
comment|/*!     \since 4.6      Creates an application using the application factory given in     \a factory, and using \a argc command line arguments in \a argv.     \a factory can be leaving, but the error will be converted to a     standard exception.      This function is only available on S60. */
end_comment
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|QApplication
operator|::
name|QS60MainApplicationFactory
name|factory
parameter_list|,
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
member_init_list|:
name|QCoreApplication
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|S60
operator|->
name|s60ApplicationFactory
operator|=
name|factory
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QApplication
name|QApplication
operator|::
name|QApplication
parameter_list|(
name|QApplication
operator|::
name|QS60MainApplicationFactory
name|factory
parameter_list|,
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QCoreApplication
argument_list|(
operator|*
operator|new
name|QApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|GuiClient
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|S60
operator|->
name|s60ApplicationFactory
operator|=
name|factory
expr_stmt|;
name|d
operator|->
name|construct
argument_list|()
expr_stmt|;
name|QApplicationPrivate
operator|::
name|app_compile_version
operator|=
name|_internal
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|qt_init
name|void
name|qt_init
parameter_list|(
name|QApplicationPrivate
modifier|*
comment|/* priv */
parameter_list|,
name|int
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CCoeEnv
operator|::
name|Static
argument_list|()
condition|)
block|{
comment|// The S60 framework creates a new trap handler which will render any existing traps
comment|// invalid as long as it is active. This means that all code in main() that occurs after
comment|// the QApplication construction needs to be surrounded by a new trap, despite having
comment|// an outer one already. To avoid this, we save the original trap handler here, and set
comment|// it back after the S60 framework is constructed. Then we restore it right before the S60
comment|// framework destruction.
name|TTrapHandler
modifier|*
name|origTrapHandler
init|=
name|User
operator|::
name|TrapHandler
argument_list|()
decl_stmt|;
comment|// The S60 framework has not been initialized. We need to do it.
name|TApaApplicationFactory
name|factory
argument_list|(
name|S60
operator|->
name|s60ApplicationFactory
condition|?
name|S60
operator|->
name|s60ApplicationFactory
else|:
name|newS60Application
argument_list|)
decl_stmt|;
name|CApaCommandLine
modifier|*
name|commandLine
init|=
name|q_check_ptr
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|symbianCommandLine
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commandLine
condition|)
block|{
comment|// After this construction, CEikonEnv will be available from CEikonEnv::Static().
comment|// (much like our qApp).
name|QtEikonEnv
modifier|*
name|coe
init|=
operator|new
name|QtEikonEnv
decl_stmt|;
comment|//not using QT_TRAP_THROWING, because coe owns the cleanupstack so it can't be pushed there.
name|TRAPD
argument_list|(
name|err
argument_list|,
name|coe
operator|->
name|ConstructAppFromCommandLineL
argument_list|(
name|factory
argument_list|,
operator|*
name|commandLine
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"qt_init: Eikon application construct failed ("
operator|<<
name|err
operator|<<
literal|"), maybe missing resource file on S60 3.1?"
expr_stmt|;
operator|delete
name|coe
expr_stmt|;
name|qt_symbian_throwIfError
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|S60
operator|->
name|s60InstalledTrapHandler
operator|=
name|User
operator|::
name|SetTrapHandler
argument_list|(
name|origTrapHandler
argument_list|)
expr_stmt|;
name|S60
operator|->
name|qtOwnsS60Environment
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|S60
operator|->
name|qtOwnsS60Environment
operator|=
literal|false
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|qgetenv
argument_list|(
literal|"QT_S60_AUTO_FLUSH_WSERV"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
endif|#
directive|endif
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetAutoFlush
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_WINDOW_SIZE_CACHE
name|TRAP_IGNORE
argument_list|(
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|EnableWindowSizeCacheL
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S60
operator|->
name|updateScreenSize
argument_list|()
expr_stmt|;
name|TDisplayMode
name|mode
init|=
name|S60
operator|->
name|screenDevice
argument_list|()
operator|->
name|DisplayMode
argument_list|()
decl_stmt|;
name|S60
operator|->
name|screenDepth
operator|=
name|TDisplayModeUtils
operator|::
name|NumDisplayModeBitsPerPixel
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|//NB: RWsSession::GetColorModeList tells you what window modes are supported,
comment|//not what bitmap formats.
if|if
condition|(
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
operator|==
name|QSysInfo
operator|::
name|SV_9_2
condition|)
name|S60
operator|->
name|supportsPremultipliedAlpha
operator|=
literal|0
expr_stmt|;
else|else
name|S60
operator|->
name|supportsPremultipliedAlpha
operator|=
literal|1
expr_stmt|;
name|RProcess
name|me
decl_stmt|;
name|TSecureId
name|securId
init|=
name|me
operator|.
name|SecureId
argument_list|()
decl_stmt|;
name|S60
operator|->
name|uid
operator|=
name|securId
operator|.
name|operator
name|TUid
argument_list|()
expr_stmt|;
comment|// enable focus events - used to re-enable mouse after focus changed between mouse and non mouse app,
comment|// and for dimming behind modal windows
name|S60
operator|->
name|windowGroup
argument_list|()
operator|.
name|EnableFocusChangeEvents
argument_list|()
expr_stmt|;
comment|//Check if mouse interaction is supported (either EMouse=1 in the HAL, or EMachineUID is one of the phones known to support this)
specifier|const
name|TInt
name|KMachineUidSamsungI8510
init|=
literal|0x2000C51E
decl_stmt|;
comment|// HAL::Get(HALData::EPen, TInt& result) may set 'result' to 1 on some 3.1 systems (e.g. N95).
comment|// But we know that S60 systems below 5.0 did not support touch.
specifier|static
specifier|const
name|bool
name|touchIsUnsupportedOnSystem
init|=
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|==
name|QSysInfo
operator|::
name|SV_S60_3_1
operator|||
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|==
name|QSysInfo
operator|::
name|SV_S60_3_2
decl_stmt|;
name|TInt
name|machineUID
decl_stmt|;
name|TInt
name|mouse
decl_stmt|;
name|TInt
name|touch
decl_stmt|;
name|TInt
name|err
decl_stmt|;
name|err
operator|=
name|HAL
operator|::
name|Get
argument_list|(
name|HALData
operator|::
name|EMouse
argument_list|,
name|mouse
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
name|mouse
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|HAL
operator|::
name|Get
argument_list|(
name|HALData
operator|::
name|EMachineUid
argument_list|,
name|machineUID
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
name|machineUID
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|HAL
operator|::
name|Get
argument_list|(
name|HALData
operator|::
name|EPen
argument_list|,
name|touch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
operator|||
name|touchIsUnsupportedOnSystem
condition|)
name|touch
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__WINS__
if|if
condition|(
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
operator|<=
name|QSysInfo
operator|::
name|SV_9_4
condition|)
block|{
comment|//for symbian SDK emulator, force values to match typical devices.
name|mouse
operator|=
literal|0
expr_stmt|;
name|touch
operator|=
name|touchIsUnsupportedOnSystem
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mouse
operator|||
name|machineUID
operator|==
name|KMachineUidSamsungI8510
condition|)
block|{
name|S60
operator|->
name|hasTouchscreen
operator|=
literal|false
expr_stmt|;
name|S60
operator|->
name|virtualMouseRequired
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|touch
condition|)
block|{
name|S60
operator|->
name|hasTouchscreen
operator|=
literal|false
expr_stmt|;
name|S60
operator|->
name|virtualMouseRequired
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|S60
operator|->
name|hasTouchscreen
operator|=
literal|true
expr_stmt|;
name|S60
operator|->
name|virtualMouseRequired
operator|=
literal|false
expr_stmt|;
block|}
name|S60
operator|->
name|avkonComponentsSupportTransparency
operator|=
literal|false
expr_stmt|;
name|S60
operator|->
name|menuBeingConstructed
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_S60
name|TUid
name|KCRUidAvkon
init|=
block|{
literal|0x101F876E
block|}
decl_stmt|;
name|TUint32
name|KAknAvkonTransparencyEnabled
init|=
literal|0x0000000D
decl_stmt|;
name|CRepository
modifier|*
name|repository
init|=
literal|0
decl_stmt|;
name|TRAP
argument_list|(
name|err
argument_list|,
name|repository
operator|=
name|CRepository
operator|::
name|NewL
argument_list|(
name|KCRUidAvkon
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|TInt
name|value
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|repository
operator|->
name|Get
argument_list|(
name|KAknAvkonTransparencyEnabled
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|S60
operator|->
name|avkonComponentsSupportTransparency
operator|=
operator|(
name|value
operator|==
literal|1
operator|)
condition|?
literal|true
else|:
literal|false
expr_stmt|;
block|}
block|}
operator|delete
name|repository
expr_stmt|;
name|repository
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|qt_keymapper_private
argument_list|()
operator|->
name|updateInputLanguage
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
if|if
condition|(
name|touch
condition|)
block|{
name|QApplicationPrivate
operator|::
name|navigationMode
operator|=
name|Qt
operator|::
name|NavigationModeNone
expr_stmt|;
block|}
else|else
block|{
name|QApplicationPrivate
operator|::
name|navigationMode
operator|=
name|Qt
operator|::
name|NavigationModeKeypadDirectional
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|//Check if window server pointer cursors are supported or not
ifndef|#
directive|ifndef
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
comment|//In generic binary, use the HAL and OS version
comment|//Any other known good phones should be added here.
if|if
condition|(
name|machineUID
operator|==
name|KMachineUidSamsungI8510
operator|||
operator|(
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
operator|!=
name|QSysInfo
operator|::
name|SV_9_4
operator|&&
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
operator|!=
name|QSysInfo
operator|::
name|SV_9_3
operator|&&
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
operator|!=
name|QSysInfo
operator|::
name|SV_9_2
operator|)
condition|)
block|{
name|S60
operator|->
name|brokenPointerCursors
operator|=
literal|false
expr_stmt|;
name|qt_symbian_setWindowGroupCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|,
name|S60
operator|->
name|windowGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|S60
operator|->
name|brokenPointerCursors
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|S60
operator|->
name|mouseInteractionEnabled
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
if|if
condition|(
name|S60
operator|->
name|brokenPointerCursors
condition|)
block|{
name|qt_symbian_set_pointer_sprite
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|)
expr_stmt|;
name|qt_symbian_show_pointer_sprite
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetPointerCursorMode
argument_list|(
name|EPointerCursorNormal
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QFont
name|systemFont
decl_stmt|;
name|systemFont
operator|.
name|setFamily
argument_list|(
name|systemFont
operator|.
name|defaultFamily
argument_list|()
argument_list|)
expr_stmt|;
name|QApplicationPrivate
operator|::
name|setSystemFont
argument_list|(
name|systemFont
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|qApp
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToQuit
argument_list|()
argument_list|)
argument_list|,
name|qApp
argument_list|,
name|SLOT
argument_list|(
name|_q_aboutToQuit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_SEMITRANSPARENT_BG_SURFACE
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|useTranslucentEGLSurfaces
operator|=
literal|true
expr_stmt|;
specifier|const
name|TUid
name|KIvePropertyCat
init|=
block|{
literal|0x2726beef
block|}
decl_stmt|;
enum|enum
name|TIvePropertyChipType
block|{
name|EVCBCM2727B1
init|=
literal|0x00000000
block|,
name|EVCBCM2763A0
init|=
literal|0x04000100
block|,
name|EVCBCM2763B0
init|=
literal|0x04000102
block|,
name|EVCBCM2763C0
init|=
literal|0x04000103
block|,
name|EVCBCM2763C1
init|=
literal|0x04000104
block|,
name|EVCBCMUnknown
init|=
literal|0x7fffffff
block|}
enum|;
name|TInt
name|chipType
init|=
name|EVCBCMUnknown
decl_stmt|;
if|if
condition|(
name|RProperty
operator|::
name|Get
argument_list|(
name|KIvePropertyCat
argument_list|,
literal|0
comment|/*chip type*/
argument_list|,
name|chipType
argument_list|)
operator|==
name|KErrNone
condition|)
block|{
if|if
condition|(
name|chipType
operator|==
name|EVCBCM2727B1
condition|)
block|{
comment|// We have only 32MB GPU memory. Use raster surfaces
comment|// for transparent TLWs.
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|useTranslucentEGLSurfaces
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|useTranslucentEGLSurfaces
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|==
name|QLatin1String
argument_list|(
literal|"raster"
argument_list|)
condition|)
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|useTranslucentEGLSurfaces
operator|=
literal|false
expr_stmt|;
else|#
directive|else
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|useTranslucentEGLSurfaces
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|/*  ### Commented out for now as parameter handling not needed in SOS(yet). Code below will break testlib with -o flag     int argc = priv->argc;     char **argv = priv->argv;      // Get command line params     int j = argc ? 1 : 0;     for (int i=1; i<argc; i++) {         if (argv[i]&& *argv[i] != '-') {             argv[j++] = argv[i];             continue;         }  #if defined(QT_DEBUG)         if (qstrcmp(argv[i], "-nograb") == 0)             appNoGrab = !appNoGrab;         else #endif // QT_DEBUG             ;     } */
comment|// Register WId with the metatype system.  This is to enable
comment|// QWidgetPrivate::create_sys to used delayed slot invocation in order
comment|// to destroy WId objects during reparenting.
name|qRegisterMetaType
argument_list|<
name|WId
argument_list|>
argument_list|(
literal|"WId"
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_FREETYPE
end_ifdef
begin_function_decl
specifier|extern
name|void
name|qt_cleanup_symbianFontDatabase
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|// qfontdatabase_s60.cpp
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*****************************************************************************   qt_cleanup() - cleans up when the application is finished  *****************************************************************************/
end_comment
begin_function
DECL|function|qt_cleanup
name|void
name|qt_cleanup
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_WS_S60
name|S60
operator|->
name|setButtonGroupContainer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qt_S60Beep
condition|)
block|{
operator|delete
name|qt_S60Beep
expr_stmt|;
name|qt_S60Beep
operator|=
literal|0
expr_stmt|;
block|}
name|QFontCache
operator|::
name|cleanup
argument_list|()
expr_stmt|;
comment|// Has to happen now, since QFontEngineS60 has FBS handles
name|QPixmapCache
operator|::
name|clear
argument_list|()
expr_stmt|;
comment|// Has to happen now, since QS60PixmapData has FBS handles
ifdef|#
directive|ifdef
name|QT_NO_FREETYPE
name|qt_cleanup_symbianFontDatabase
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// S60 structure and window server session are freed in eventdispatcher destructor as they are needed there
comment|// It's important that this happens here, before the event dispatcher gets
comment|// deleted, because the input context needs the event loop one last time before
comment|// it dies.
operator|delete
name|QApplicationPrivate
operator|::
name|inputContext
expr_stmt|;
name|QApplicationPrivate
operator|::
name|inputContext
operator|=
literal|0
expr_stmt|;
comment|//Change mouse pointer back
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetPointerCursorMode
argument_list|(
name|EPointerCursorNone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_S60
comment|// Clear CBA
name|CEikonEnv
operator|::
name|Static
argument_list|()
operator|->
name|AppUiFactory
argument_list|()
operator|->
name|SwapButtonGroup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|delete
name|S60
operator|->
name|buttonGroupContainer
argument_list|()
expr_stmt|;
name|S60
operator|->
name|setButtonGroupContainer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Call EndFullScreen() to prevent confusing the system effect state machine.
name|qt_endFullScreenEffect
argument_list|()
expr_stmt|;
if|if
condition|(
name|S60
operator|->
name|qtOwnsS60Environment
condition|)
block|{
comment|// Restore the S60 framework trap handler. See qt_init().
name|User
operator|::
name|SetTrapHandler
argument_list|(
name|S60
operator|->
name|s60InstalledTrapHandler
argument_list|)
expr_stmt|;
name|CEikonEnv
modifier|*
name|coe
init|=
name|CEikonEnv
operator|::
name|Static
argument_list|()
decl_stmt|;
name|coe
operator|->
name|PrepareToExit
argument_list|()
expr_stmt|;
comment|// The CEikonEnv itself is destroyed in here.
name|coe
operator|->
name|DestroyEnvironment
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initializeWidgetPaletteHash
name|void
name|QApplicationPrivate
operator|::
name|initializeWidgetPaletteHash
parameter_list|()
block|{
comment|// TODO: Implement QApplicationPrivate::initializeWidgetPaletteHash()
comment|// Possibly a task fot the S60Style guys
block|}
end_function
begin_function
DECL|function|createEventDispatcher
name|void
name|QApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherS60
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appName
name|QString
name|QApplicationPrivate
operator|::
name|appName
parameter_list|()
specifier|const
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|appName
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|modalState
name|bool
name|QApplicationPrivate
operator|::
name|modalState
parameter_list|()
block|{
return|return
name|app_do_modal
return|;
block|}
end_function
begin_function
DECL|function|enterModal_sys
name|void
name|QApplicationPrivate
operator|::
name|enterModal_sys
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_SYMBIAN_TRANSITION_EFFECTS
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SendEffectCommand
argument_list|(
name|ETfxCmdAppModalModeEnter
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|widget
condition|)
block|{
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|FadeBehindPopup
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
comment|// Modal partial screen dialogs (like queries) capture pointer events.
comment|// ### FixMe: Add specialized behaviour for fullscreen modal dialogs
name|widget
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetGloballyCapturing
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
name|widget
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qt_modal_stack
condition|)
name|qt_modal_stack
operator|=
operator|new
name|QWidgetList
expr_stmt|;
name|qt_modal_stack
operator|->
name|insert
argument_list|(
literal|0
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|app_do_modal
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|leaveModal_sys
name|void
name|QApplicationPrivate
operator|::
name|leaveModal_sys
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_SYMBIAN_TRANSITION_EFFECTS
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SendEffectCommand
argument_list|(
name|ETfxCmdAppModalModeExit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|widget
condition|)
block|{
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|FadeBehindPopup
argument_list|(
name|EFalse
argument_list|)
expr_stmt|;
comment|// ### FixMe: Add specialized behaviour for fullscreen modal dialogs
name|widget
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetGloballyCapturing
argument_list|(
name|EFalse
argument_list|)
expr_stmt|;
name|widget
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
name|EFalse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qt_modal_stack
operator|&&
name|qt_modal_stack
operator|->
name|removeAll
argument_list|(
name|widget
argument_list|)
condition|)
block|{
if|if
condition|(
name|qt_modal_stack
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
operator|delete
name|qt_modal_stack
expr_stmt|;
name|qt_modal_stack
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|app_do_modal
operator|=
name|qt_modal_stack
operator|!=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|openPopup
name|void
name|QApplicationPrivate
operator|::
name|openPopup
parameter_list|(
name|QWidget
modifier|*
name|popup
parameter_list|)
block|{
if|if
condition|(
name|popup
operator|&&
name|qobject_cast
argument_list|<
name|QComboBox
operator|*
argument_list|>
argument_list|(
name|popup
operator|->
name|parentWidget
argument_list|()
argument_list|)
condition|)
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|popup
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|FadeBehindPopup
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|popupWidgets
condition|)
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|=
operator|new
name|QWidgetList
expr_stmt|;
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|append
argument_list|(
name|popup
argument_list|)
expr_stmt|;
comment|// Cancel focus widget pointer capture and long tap timer
if|if
condition|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
condition|)
block|{
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|CancelLongTapTimer
argument_list|()
expr_stmt|;
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qt_nograb
argument_list|()
condition|)
block|{
comment|// Cancel pointer capture and long tap timer for earlier popup
name|int
name|popupCount
init|=
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|popupCount
operator|>
literal|1
condition|)
block|{
name|QWidget
modifier|*
name|prevPopup
init|=
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|at
argument_list|(
name|popupCount
operator|-
literal|2
argument_list|)
decl_stmt|;
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|prevPopup
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|CancelLongTapTimer
argument_list|()
expr_stmt|;
name|prevPopup
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Enable pointer capture for this (topmost) popup
name|Q_ASSERT
argument_list|(
name|popup
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
argument_list|)
expr_stmt|;
name|WId
name|id
init|=
name|popup
operator|->
name|effectiveWinId
argument_list|()
decl_stmt|;
name|id
operator|->
name|SetPointerCapture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// popups are not focus-handled by the window system (the first
comment|// popup grabbed the keyboard), so we have to do that manually: A
comment|// new popup gets the focus
name|QWidget
modifier|*
name|fw
init|=
name|popup
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|fw
condition|)
block|{
name|fw
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// this was the first popup
name|fw
operator|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|fw
condition|)
block|{
name|QFocusEvent
name|e
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|q_func
argument_list|()
operator|->
name|sendEvent
argument_list|(
name|fw
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|closePopup
name|void
name|QApplicationPrivate
operator|::
name|closePopup
parameter_list|(
name|QWidget
modifier|*
name|popup
parameter_list|)
block|{
if|if
condition|(
name|popup
operator|&&
name|qobject_cast
argument_list|<
name|QComboBox
operator|*
argument_list|>
argument_list|(
name|popup
operator|->
name|parentWidget
argument_list|()
argument_list|)
condition|)
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|popup
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
operator|->
name|FadeBehindPopup
argument_list|(
name|EFalse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|popupWidgets
condition|)
return|return;
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|removeAll
argument_list|(
name|popup
argument_list|)
expr_stmt|;
comment|// Cancel pointer capture and long tap for this popup
name|WId
name|id
init|=
name|popup
operator|->
name|effectiveWinId
argument_list|()
decl_stmt|;
name|id
operator|->
name|SetPointerCapture
argument_list|(
literal|false
argument_list|)
expr_stmt|;
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|id
argument_list|)
operator|->
name|CancelLongTapTimer
argument_list|()
expr_stmt|;
if|if
condition|(
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
comment|// this was the last popup
operator|delete
name|QApplicationPrivate
operator|::
name|popupWidgets
expr_stmt|;
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|qt_nograb
argument_list|()
condition|)
block|{
comment|// grabbing not disabled
name|Q_ASSERT
argument_list|(
name|popup
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QWidgetPrivate
operator|::
name|mouseGrabber
operator|!=
literal|0
condition|)
name|QWidgetPrivate
operator|::
name|mouseGrabber
operator|->
name|grabMouse
argument_list|()
expr_stmt|;
if|if
condition|(
name|QWidgetPrivate
operator|::
name|keyboardGrabber
operator|!=
literal|0
condition|)
name|QWidgetPrivate
operator|::
name|keyboardGrabber
operator|->
name|grabKeyboard
argument_list|()
expr_stmt|;
name|QWidget
modifier|*
name|fw
init|=
name|QApplicationPrivate
operator|::
name|active_window
condition|?
name|QApplicationPrivate
operator|::
name|active_window
operator|->
name|focusWidget
argument_list|()
else|:
name|q_func
argument_list|()
operator|->
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|fw
condition|)
block|{
if|if
condition|(
name|fw
operator|->
name|window
argument_list|()
operator|->
name|isModal
argument_list|()
condition|)
comment|// restore pointer capture for modal window
name|fw
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|!=
name|q_func
argument_list|()
operator|->
name|focusWidget
argument_list|()
condition|)
block|{
name|fw
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QFocusEvent
name|e
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|q_func
argument_list|()
operator|->
name|sendEvent
argument_list|(
name|fw
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// popups are not focus-handled by the window system (the
comment|// first popup grabbed the keyboard), so we have to do that
comment|// manually: A popup was closed, so the previous popup gets
comment|// the focus.
name|QWidget
modifier|*
name|aw
init|=
name|QApplicationPrivate
operator|::
name|popupWidgets
operator|->
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
condition|)
block|{
name|QFocusEvent
name|e
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|q_func
argument_list|()
operator|->
name|sendEvent
argument_list|(
name|fw
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Enable pointer capture for previous popup
if|if
condition|(
name|aw
condition|)
block|{
name|aw
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|SetPointerCapture
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|topLevelAt
name|QWidget
modifier|*
name|QApplication
operator|::
name|topLevelAt
parameter_list|(
name|QPoint
specifier|const
modifier|&
name|point
parameter_list|)
block|{
name|QWidget
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|int
name|lowestZ
init|=
name|INT_MAX
decl_stmt|;
name|QWidgetList
name|list
init|=
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
operator|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|widget
operator|->
name|geometry
argument_list|()
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|contains
argument_list|(
name|point
argument_list|)
condition|)
block|{
comment|// At this point we know there is a Qt widget under the point.
comment|// Now we need to make sure it is the top most in the z-order.
name|RDrawableWindow
modifier|*
specifier|const
name|window
init|=
name|widget
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|DrawableWindow
argument_list|()
decl_stmt|;
name|int
name|z
init|=
name|window
operator|->
name|OrdinalPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|z
operator|<
name|lowestZ
condition|)
block|{
name|lowestZ
operator|=
name|z
expr_stmt|;
name|found
operator|=
name|widget
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function
begin_function
DECL|function|alert
name|void
name|QApplication
operator|::
name|alert
parameter_list|(
name|QWidget
modifier|*
comment|/* widget */
parameter_list|,
name|int
comment|/* duration */
parameter_list|)
block|{
comment|// TODO: Implement QApplication::alert(QWidget *widget, int duration)
block|}
end_function
begin_function
DECL|function|doubleClickInterval
name|int
name|QApplication
operator|::
name|doubleClickInterval
parameter_list|()
block|{
name|TTimeIntervalMicroSeconds32
name|us
decl_stmt|;
name|TInt
name|distance
decl_stmt|;
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|GetDoubleClickSettings
argument_list|(
name|us
argument_list|,
name|distance
argument_list|)
expr_stmt|;
return|return
operator|(
name|us
operator|.
name|Int
argument_list|()
operator|/
literal|1000
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setDoubleClickInterval
name|void
name|QApplication
operator|::
name|setDoubleClickInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|TTimeIntervalMicroSeconds32
name|newUs
argument_list|(
name|ms
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|TTimeIntervalMicroSeconds32
name|us
decl_stmt|;
name|TInt
name|distance
decl_stmt|;
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|GetDoubleClickSettings
argument_list|(
name|us
argument_list|,
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|us
operator|!=
name|newUs
condition|)
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetDoubleClick
argument_list|(
name|newUs
argument_list|,
name|distance
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|keyboardInputInterval
name|int
name|QApplication
operator|::
name|keyboardInputInterval
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|keyboard_input_time
return|;
block|}
end_function
begin_function
DECL|function|setKeyboardInputInterval
name|void
name|QApplication
operator|::
name|setKeyboardInputInterval
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|keyboard_input_time
operator|=
name|ms
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cursorFlashTime
name|int
name|QApplication
operator|::
name|cursorFlashTime
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|cursor_flash_time
return|;
block|}
end_function
begin_function
DECL|function|setCursorFlashTime
name|void
name|QApplication
operator|::
name|setCursorFlashTime
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|cursor_flash_time
operator|=
name|msecs
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beep
name|void
name|QApplication
operator|::
name|beep
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qt_S60Beep
condition|)
block|{
name|TInt
name|frequency
init|=
literal|880
decl_stmt|;
name|TTimeIntervalMicroSeconds
name|duration
argument_list|(
literal|500000
argument_list|)
decl_stmt|;
name|TRAP_IGNORE
argument_list|(
name|qt_S60Beep
operator|=
name|QS60Beep
operator|::
name|NewL
argument_list|(
name|frequency
argument_list|,
name|duration
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qt_S60Beep
condition|)
name|qt_S60Beep
operator|->
name|Play
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|callSymbianEventFilters
specifier|static
specifier|inline
name|bool
name|callSymbianEventFilters
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|event
parameter_list|)
block|{
name|long
name|unused
decl_stmt|;
return|return
name|qApp
operator|->
name|filterEvent
argument_list|(
cast|const_cast
argument_list|<
name|QSymbianEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|,
operator|&
name|unused
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \warning This function is only available on Symbian.     \since 4.6      This function processes an individual Symbian event     \a event. It returns 1 if the event was handled, 0 if     the \a event was not handled, and -1 if the event was     not handled because the event is not known to Qt.  */
end_comment
begin_function
DECL|function|symbianProcessEvent
name|int
name|QApplication
operator|::
name|symbianProcessEvent
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|QScopedLoopLevelCounter
name|counter
argument_list|(
name|d
operator|->
name|threadData
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|eventDispatcher
operator|->
name|filterEvent
argument_list|(
cast|const_cast
argument_list|<
name|QSymbianEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|QWidget
modifier|*
name|w
init|=
name|qApp
condition|?
name|qApp
operator|->
name|focusWidget
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|QInputContext
modifier|*
name|ic
init|=
name|w
operator|->
name|inputContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|ic
operator|&&
name|ic
operator|->
name|symbianFilterEvent
argument_list|(
name|w
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|symbianEventFilter
argument_list|(
name|event
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QSymbianEvent
operator|::
name|WindowServerEvent
case|:
return|return
name|d
operator|->
name|symbianProcessWsEvent
argument_list|(
name|event
argument_list|)
return|;
case|case
name|QSymbianEvent
operator|::
name|CommandEvent
case|:
return|return
name|d
operator|->
name|symbianHandleCommand
argument_list|(
name|event
argument_list|)
return|;
case|case
name|QSymbianEvent
operator|::
name|ResourceChangeEvent
case|:
return|return
name|d
operator|->
name|symbianResourceChange
argument_list|(
name|event
argument_list|)
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|symbianProcessWsEvent
name|int
name|QApplicationPrivate
operator|::
name|symbianProcessWsEvent
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|symbianEvent
parameter_list|)
block|{
comment|// Qt event handling. Handle some events regardless of if the handle is in our
comment|// widget map or not.
specifier|const
name|TWsEvent
modifier|*
name|event
init|=
name|symbianEvent
operator|->
name|windowServerEvent
argument_list|()
decl_stmt|;
name|CCoeControl
modifier|*
name|control
init|=
cast|reinterpret_cast
argument_list|<
name|CCoeControl
operator|*
argument_list|>
argument_list|(
name|event
operator|->
name|Handle
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|controlInMap
init|=
name|QWidgetPrivate
operator|::
name|mapper
operator|&&
name|QWidgetPrivate
operator|::
name|mapper
operator|->
name|contains
argument_list|(
name|control
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|event
operator|->
name|Type
argument_list|()
condition|)
block|{
case|case
name|EEventPointerEnter
case|:
if|if
condition|(
name|controlInMap
condition|)
block|{
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|// Qt::Enter will be generated in HandlePointerL
block|}
break|break;
case|case
name|EEventPointerExit
case|:
if|if
condition|(
name|controlInMap
condition|)
block|{
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S60
condition|)
block|{
comment|// mouseEvent outside our window, send leave event to last focused widget
name|QMouseEvent
name|mEvent
argument_list|(
name|QEvent
operator|::
name|Leave
argument_list|,
name|S60
operator|->
name|lastPointerEventPos
argument_list|,
name|S60
operator|->
name|lastCursorPos
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
name|QApplicationPrivate
operator|::
name|mouse_buttons
argument_list|,
name|Qt
operator|::
name|NoModifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|S60
operator|->
name|lastPointerEventTarget
condition|)
name|qt_sendSpontaneousEvent
argument_list|(
name|S60
operator|->
name|lastPointerEventTarget
argument_list|,
operator|&
name|mEvent
argument_list|)
expr_stmt|;
name|S60
operator|->
name|lastPointerEventTarget
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
break|break;
case|case
name|EEventScreenDeviceChanged
case|:
comment|// fallthrough
if|#
directive|if
name|defined
argument_list|(
name|Q_SYMBIAN_SUPPORTS_MULTIPLE_SCREENS
argument_list|)
case|case
name|EEventDisplayChanged
case|:
endif|#
directive|endif
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S60
condition|)
name|S60
operator|->
name|updateScreenSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_desktopWidget
condition|)
block|{
name|QSize
name|oldSize
init|=
name|qt_desktopWidget
operator|->
name|size
argument_list|()
decl_stmt|;
name|qt_desktopWidget
operator|->
name|data
operator|->
name|crect
operator|.
name|setWidth
argument_list|(
name|S60
operator|->
name|screenWidthInPixels
argument_list|)
expr_stmt|;
name|qt_desktopWidget
operator|->
name|data
operator|->
name|crect
operator|.
name|setHeight
argument_list|(
name|S60
operator|->
name|screenHeightInPixels
argument_list|)
expr_stmt|;
name|QResizeEvent
name|e
argument_list|(
name|qt_desktopWidget
operator|->
name|size
argument_list|()
argument_list|,
name|oldSize
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|qt_desktopWidget
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|// Propagate to CONE
case|case
name|EEventWindowVisibilityChanged
case|:
if|if
condition|(
name|controlInMap
condition|)
block|{
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
specifier|const
name|TWsVisibilityChangedEvent
modifier|*
name|visChangedEvent
init|=
name|event
operator|->
name|VisibilityChanged
argument_list|()
decl_stmt|;
if|if
condition|(
name|visChangedEvent
operator|->
name|iFlags
operator|&
name|TWsVisibilityChangedEvent
operator|::
name|ENotVisible
condition|)
name|S60
operator|->
name|controlVisibilityChanged
argument_list|(
name|control
argument_list|,
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|visChangedEvent
operator|->
name|iFlags
operator|&
name|TWsVisibilityChangedEvent
operator|::
name|EPartiallyVisible
condition|)
name|S60
operator|->
name|controlVisibilityChanged
argument_list|(
name|control
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|EEventFocusGained
case|:
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|//re-enable mouse interaction
if|if
condition|(
name|S60
operator|->
name|mouseInteractionEnabled
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
if|if
condition|(
name|S60
operator|->
name|brokenPointerCursors
condition|)
name|qt_symbian_show_pointer_sprite
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetPointerCursorMode
argument_list|(
name|EPointerCursorNormal
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_SOFTKEYS_ENABLED
if|if
condition|(
operator|!
name|CEikonEnv
operator|::
name|Static
argument_list|()
operator|->
name|EikAppUi
argument_list|()
operator|->
name|IsDisplayingMenuOrDialog
argument_list|()
condition|)
name|QSoftKeyManager
operator|::
name|updateSoftKeys
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EEventFocusLost
case|:
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|//disable mouse as may be moving to application that does not support it
if|if
condition|(
name|S60
operator|->
name|mouseInteractionEnabled
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
if|if
condition|(
name|S60
operator|->
name|brokenPointerCursors
condition|)
name|qt_symbian_hide_pointer_sprite
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SetPointerCursorMode
argument_list|(
name|EPointerCursorNone
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|KGoomMemoryLowEvent
case|:
ifdef|#
directive|ifdef
name|QT_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::symbianProcessWsEvent - KGoomMemoryLowEvent"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|QT_GRAPHICSSYSTEM_RUNTIME
if|if
condition|(
name|QApplicationPrivate
operator|::
name|runtime_graphics_system
condition|)
block|{
name|bool
name|switchToSwRendering
argument_list|(
literal|false
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QWidget
modifier|*
name|w
decl|,
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
control|)
block|{
if|if
condition|(
name|w
operator|->
name|d_func
argument_list|()
operator|->
name|topData
argument_list|()
operator|->
name|backingStore
condition|)
block|{
name|switchToSwRendering
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|switchToSwRendering
condition|)
block|{
name|QRuntimeGraphicsSystem
modifier|*
name|gs
init|=
cast|static_cast
argument_list|<
name|QRuntimeGraphicsSystem
operator|*
argument_list|>
argument_list|(
name|QApplicationPrivate
operator|::
name|graphics_system
argument_list|)
decl_stmt|;
name|gs
operator|->
name|setGraphicsSystem
argument_list|(
name|QLatin1String
argument_list|(
literal|"raster"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|KGoomMemoryGoodEvent
case|:
ifdef|#
directive|ifdef
name|QT_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QApplicationPrivate::symbianProcessWsEvent - KGoomMemoryGoodEvent"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|QT_GRAPHICSSYSTEM_RUNTIME
if|if
condition|(
name|QApplicationPrivate
operator|::
name|runtime_graphics_system
condition|)
block|{
name|QRuntimeGraphicsSystem
modifier|*
name|gs
init|=
cast|static_cast
argument_list|<
name|QRuntimeGraphicsSystem
operator|*
argument_list|>
argument_list|(
name|QApplicationPrivate
operator|::
name|graphics_system
argument_list|)
decl_stmt|;
name|gs
operator|->
name|setGraphicsSystem
argument_list|(
name|QLatin1String
argument_list|(
literal|"openvg"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_SUPPORTS_SURFACES
case|case
name|EEventUser
case|:
block|{
comment|// GOOM is looking for candidates to kill so indicate that we are
comment|// capable of cleaning up by handling this event
name|TInt32
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|TInt32
operator|*
argument_list|>
argument_list|(
name|event
operator|->
name|EventData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
name|EApaSystemEventShutdown
operator|&&
name|data
index|[
literal|1
index|]
operator|==
name|KGoomMemoryLowEvent
condition|)
return|return
literal|1
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_WS_S60
case|case
name|KEikInputLanguageChange
case|:
name|qt_keymapper_private
argument_list|()
operator|->
name|updateInputLanguage
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|controlInMap
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \warning This virtual function is only available on Symbian.   \since 4.6    If you create an application that inherits QApplication and reimplement   this function, you get direct access to events that the are received   from Symbian. The events are passed in the \a event parameter.    Return true if you want to stop the event from being processed. Return   false for normal event dispatching. The default implementation returns   false, and does nothing with \a event.  */
end_comment
begin_function
DECL|function|symbianEventFilter
name|bool
name|QApplication
operator|::
name|symbianEventFilter
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \warning This function is only available on Symbian.   \since 4.6    Handles \a{command}s which are typically handled by   CAknAppUi::HandleCommandL(). Qts Ui integration into Symbian is   partially achieved by deriving from CAknAppUi. Currently, exit,   menu and softkey commands are handled.    \sa s60EventFilter(), s60ProcessEvent() */
end_comment
begin_function
DECL|function|symbianHandleCommand
name|int
name|QApplicationPrivate
operator|::
name|symbianHandleCommand
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|symbianEvent
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QApplication
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
name|int
name|command
init|=
name|symbianEvent
operator|->
name|command
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_S60
case|case
name|EAknSoftkeyExit
case|:
block|{
name|QCloseEvent
name|ev
decl_stmt|;
name|QApplication
operator|::
name|sendSpontaneousEvent
argument_list|(
name|q
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|q
operator|->
name|quit
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|EEikCmdExit
case|:
name|q
operator|->
name|quit
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|Q_WS_S60
name|bool
name|handled
init|=
name|QSoftKeyManager
operator|::
name|handleCommand
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|handled
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|ret
operator|=
name|QMenuBarPrivate
operator|::
name|symbianCommands
argument_list|(
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \warning This function is only available on Symbian.   \since 4.6    Handles the resource change specified by \a type.    Currently, KEikDynamicLayoutVariantSwitch and   KAknsMessageSkinChange are handled.  */
end_comment
begin_function
DECL|function|symbianResourceChange
name|int
name|QApplicationPrivate
operator|::
name|symbianResourceChange
parameter_list|(
specifier|const
name|QSymbianEvent
modifier|*
name|symbianEvent
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|type
init|=
name|symbianEvent
operator|->
name|resourceChangeType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_S60
case|case
name|KEikDynamicLayoutVariantSwitch
case|:
block|{
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S60
condition|)
name|S60
operator|->
name|updateScreenSize
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_S60
name|QS60Style
modifier|*
name|s60Style
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_STYLESHEET
name|QStyleSheetStyle
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QStyleSheetStyle
operator|*
argument_list|>
argument_list|(
name|QApplication
operator|::
name|style
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxy
condition|)
name|s60Style
operator|=
name|qobject_cast
argument_list|<
name|QS60Style
operator|*
argument_list|>
argument_list|(
name|proxy
operator|->
name|baseStyle
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|s60Style
operator|=
name|qobject_cast
argument_list|<
name|QS60Style
operator|*
argument_list|>
argument_list|(
name|QApplication
operator|::
name|style
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|s60Style
condition|)
block|{
name|s60Style
operator|->
name|d_func
argument_list|()
operator|->
name|handleDynamicLayoutVariantSwitch
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_STYLE_S60
case|case
name|KAknsMessageSkinChange
case|:
if|if
condition|(
name|callSymbianEventFilters
argument_list|(
name|symbianEvent
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|QS60Style
modifier|*
name|s60Style
init|=
name|qobject_cast
argument_list|<
name|QS60Style
operator|*
argument_list|>
argument_list|(
name|QApplication
operator|::
name|style
argument_list|()
argument_list|)
condition|)
block|{
name|s60Style
operator|->
name|d_func
argument_list|()
operator|->
name|handleSkinChange
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
endif|#
directive|endif
comment|// Q_WS_S60
default|default:
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_function
DECL|function|wheelScrollLines
name|int
name|QApplication
operator|::
name|wheelScrollLines
parameter_list|()
block|{
return|return
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
return|;
block|}
end_function
begin_function
DECL|function|setWheelScrollLines
name|void
name|QApplication
operator|::
name|setWheelScrollLines
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|QApplicationPrivate
operator|::
name|wheel_scroll_lines
operator|=
name|n
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_WHEELEVENT
end_comment
begin_function
DECL|function|isEffectEnabled
name|bool
name|QApplication
operator|::
name|isEffectEnabled
parameter_list|(
name|Qt
operator|::
name|UIEffect
comment|/* effect */
parameter_list|)
block|{
comment|// TODO: Implement QApplication::isEffectEnabled(Qt::UIEffect effect)
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|setEffectEnabled
name|void
name|QApplication
operator|::
name|setEffectEnabled
parameter_list|(
name|Qt
operator|::
name|UIEffect
comment|/* effect */
parameter_list|,
name|bool
comment|/* enable */
parameter_list|)
block|{
comment|// TODO: Implement QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)
block|}
end_function
begin_function
DECL|function|resolveS60ScanCode
name|TUint
name|QApplicationPrivate
operator|::
name|resolveS60ScanCode
parameter_list|(
name|TInt
name|scanCode
parameter_list|,
name|TUint
name|keysym
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scanCode
condition|)
return|return
name|keysym
return|;
name|QApplicationPrivate
modifier|*
name|d
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|keysym
condition|)
block|{
comment|// If keysym is specified, cache it.
name|d
operator|->
name|scanCodeCache
operator|.
name|insert
argument_list|(
name|scanCode
argument_list|,
name|keysym
argument_list|)
expr_stmt|;
return|return
name|keysym
return|;
block|}
else|else
block|{
comment|// If not, retrieve the cached version.
return|return
name|d
operator|->
name|scanCodeCache
index|[
name|scanCode
index|]
return|;
block|}
block|}
end_function
begin_function
DECL|function|initializeMultitouch_sys
name|void
name|QApplicationPrivate
operator|::
name|initializeMultitouch_sys
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
if|if
condition|(
name|HAL
operator|::
name|Get
argument_list|(
name|HALData
operator|::
name|EPointer3DPressureSupported
argument_list|,
name|pressureSupported
argument_list|)
operator|!=
name|KErrNone
condition|)
name|pressureSupported
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HAL
operator|::
name|Get
argument_list|(
name|HALData
operator|::
name|EPointer3DMaxPressure
argument_list|,
name|maxTouchPressure
argument_list|)
operator|!=
name|KErrNone
condition|)
name|maxTouchPressure
operator|=
name|KMaxTInt
expr_stmt|;
else|#
directive|else
name|pressureSupported
operator|=
literal|0
expr_stmt|;
name|maxTouchPressure
operator|=
name|KMaxTInt
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cleanupMultitouch_sys
name|void
name|QApplicationPrivate
operator|::
name|cleanupMultitouch_sys
parameter_list|()
block|{ }
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SESSIONMANAGER
end_ifndef
begin_constructor
DECL|function|QSessionManager
name|QSessionManager
operator|::
name|QSessionManager
parameter_list|(
name|QApplication
modifier|*
comment|/* app */
parameter_list|,
name|QString
modifier|&
comment|/* id */
parameter_list|,
name|QString
modifier|&
comment|/* key */
parameter_list|)
block|{  }
end_constructor
begin_destructor
DECL|function|~QSessionManager
name|QSessionManager
operator|::
name|~
name|QSessionManager
parameter_list|()
block|{  }
end_destructor
begin_function
DECL|function|allowsInteraction
name|bool
name|QSessionManager
operator|::
name|allowsInteraction
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|cancel
name|void
name|QSessionManager
operator|::
name|cancel
parameter_list|()
block|{  }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SESSIONMANAGER
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_KEYPAD_NAVIGATION
end_ifdef
begin_comment
comment|/*  * Show/Hide the mouse cursor depending on phone type and chosen mode  */
end_comment
begin_function
DECL|function|setNavigationMode
name|void
name|QApplicationPrivate
operator|::
name|setNavigationMode
parameter_list|(
name|Qt
operator|::
name|NavigationMode
name|mode
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
specifier|const
name|bool
name|wasCursorOn
init|=
operator|(
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeCursorAuto
operator|&&
operator|!
name|S60
operator|->
name|hasTouchscreen
operator|)
operator|||
name|QApplicationPrivate
operator|::
name|navigationMode
operator|==
name|Qt
operator|::
name|NavigationModeCursorForceVisible
decl_stmt|;
specifier|const
name|bool
name|isCursorOn
init|=
operator|(
name|mode
operator|==
name|Qt
operator|::
name|NavigationModeCursorAuto
operator|&&
operator|!
name|S60
operator|->
name|hasTouchscreen
operator|)
operator|||
name|mode
operator|==
name|Qt
operator|::
name|NavigationModeCursorForceVisible
decl_stmt|;
if|if
condition|(
operator|!
name|wasCursorOn
operator|&&
name|isCursorOn
condition|)
block|{
comment|//Show the cursor, when changing from another mode to cursor mode
name|qt_symbian_set_cursor_visible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasCursorOn
operator|&&
operator|!
name|isCursorOn
condition|)
block|{
comment|//Hide the cursor, when leaving cursor mode
name|qt_symbian_set_cursor_visible
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QApplicationPrivate
operator|::
name|navigationMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_comment
comment|/*****************************************************************************  QApplication cursor stack  *****************************************************************************/
end_comment
begin_function
DECL|function|setOverrideCursor
name|void
name|QApplication
operator|::
name|setOverrideCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|prepend
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|qt_symbian_setGlobalCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restoreOverrideCursor
name|void
name|QApplication
operator|::
name|restoreOverrideCursor
parameter_list|()
block|{
if|if
condition|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qt_symbian_setGlobalCursor
argument_list|(
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|cursor_list
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//determine which widget has focus
name|QWidget
modifier|*
name|w
init|=
name|QApplication
operator|::
name|widgetAt
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
if|if
condition|(
name|S60
operator|->
name|brokenPointerCursors
condition|)
block|{
name|qt_symbian_set_pointer_sprite
argument_list|(
name|w
condition|?
name|w
operator|->
name|cursor
argument_list|()
else|:
name|Qt
operator|::
name|ArrowCursor
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|//because of the internals of window server, we need to force the cursor
comment|//to be set in all child windows too, otherwise when the cursor is over
comment|//the child window it may show a widget cursor or arrow cursor instead,
comment|//depending on construction order.
name|QListIterator
argument_list|<
name|WId
argument_list|>
name|iter
argument_list|(
name|QWidgetPrivate
operator|::
name|mapper
operator|->
name|uniqueKeys
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CCoeControl
modifier|*
name|ctrl
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|OwnsWindow
argument_list|()
condition|)
block|{
name|ctrl
operator|->
name|DrawableWindow
argument_list|()
operator|->
name|ClearPointerCursor
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|w
condition|)
name|qt_symbian_setWindowCursor
argument_list|(
name|w
operator|->
name|cursor
argument_list|()
argument_list|,
name|w
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qt_symbian_setWindowGroupCursor
argument_list|(
name|Qt
operator|::
name|ArrowCursor
argument_list|,
name|S60
operator|->
name|windowGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CURSOR
end_comment
begin_function
DECL|function|_q_aboutToQuit
name|void
name|QApplicationPrivate
operator|::
name|_q_aboutToQuit
parameter_list|()
block|{
name|qt_beginFullScreenEffect
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_TRANSITION_EFFECTS
comment|// Send the shutdown tfx command
name|S60
operator|->
name|wsSession
argument_list|()
operator|.
name|SendEffectCommand
argument_list|(
name|ETfxCmdAppShutDown
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_constructor
DECL|function|QS60ThreadLocalData
name|QS60ThreadLocalData
operator|::
name|QS60ThreadLocalData
parameter_list|()
block|{
name|CCoeEnv
modifier|*
name|env
init|=
name|CCoeEnv
operator|::
name|Static
argument_list|()
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
comment|//if this is the UI thread, share objects owned by CONE
name|usingCONEinstances
operator|=
literal|true
expr_stmt|;
name|wsSession
operator|=
name|env
operator|->
name|WsSession
argument_list|()
expr_stmt|;
name|screenDevice
operator|=
name|env
operator|->
name|ScreenDevice
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|usingCONEinstances
operator|=
literal|false
expr_stmt|;
name|qt_symbian_throwIfError
argument_list|(
name|wsSession
operator|.
name|Connect
argument_list|(
name|qt_s60GetRFs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|screenDevice
operator|=
operator|new
name|CWsScreenDevice
argument_list|(
name|wsSession
argument_list|)
expr_stmt|;
name|screenDevice
operator|->
name|Construct
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QS60ThreadLocalData
name|QS60ThreadLocalData
operator|::
name|~
name|QS60ThreadLocalData
parameter_list|()
block|{
if|if
condition|(
operator|!
name|usingCONEinstances
condition|)
block|{
operator|delete
name|screenDevice
expr_stmt|;
name|wsSession
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
block|}
end_destructor
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
