begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IM
end_ifndef
begin_include
include|#
directive|include
file|"qcoefepinputcontext_p.h"
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qtextformat.h>
end_include
begin_include
include|#
directive|include
file|<qgraphicsview.h>
end_include
begin_include
include|#
directive|include
file|<qgraphicsscene.h>
end_include
begin_include
include|#
directive|include
file|<qgraphicswidget.h>
end_include
begin_include
include|#
directive|include
file|<qsymbianevent.h>
end_include
begin_include
include|#
directive|include
file|<qlayout.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_symbian_p.h>
end_include
begin_include
include|#
directive|include
file|<fepitfr.h>
end_include
begin_include
include|#
directive|include
file|<hal.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_comment
comment|// You only find these enumerations on SDK 5 onwards, so we need to provide our own
end_comment
begin_comment
comment|// to remain compatible with older releases. They won't be called by pre-5.0 SDKs.
end_comment
begin_comment
comment|// MAknEdStateObserver::EAknCursorPositionChanged
end_comment
begin_define
DECL|macro|QT_EAknCursorPositionChanged
define|#
directive|define
name|QT_EAknCursorPositionChanged
value|MAknEdStateObserver::EAknEdwinStateEvent(6)
end_define
begin_comment
comment|// MAknEdStateObserver::EAknActivatePenInputRequest
end_comment
begin_define
DECL|macro|QT_EAknActivatePenInputRequest
define|#
directive|define
name|QT_EAknActivatePenInputRequest
value|MAknEdStateObserver::EAknEdwinStateEvent(7)
end_define
begin_comment
comment|// EAknEditorFlagSelectionVisible is only valid from 3.2 onwards.
end_comment
begin_comment
comment|// Sym^3 AVKON FEP manager expects that this flag is used for FEP-aware editors
end_comment
begin_comment
comment|// that support text selection.
end_comment
begin_define
DECL|macro|QT_EAknEditorFlagSelectionVisible
define|#
directive|define
name|QT_EAknEditorFlagSelectionVisible
value|0x100000
end_define
begin_comment
comment|// EAknEditorFlagEnablePartialScreen is only valid from Sym^3 onwards.
end_comment
begin_define
DECL|macro|QT_EAknEditorFlagEnablePartialScreen
define|#
directive|define
name|QT_EAknEditorFlagEnablePartialScreen
value|0x200000
end_define
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_s60_setPartialScreenInputMode
name|Q_WIDGETS_EXPORT
name|void
name|qt_s60_setPartialScreenInputMode
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|S60
operator|->
name|partial_keyboard
operator|=
name|enable
expr_stmt|;
name|QInputContext
modifier|*
name|ic
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QApplication
operator|::
name|focusWidget
argument_list|()
condition|)
block|{
name|ic
operator|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
operator|->
name|inputContext
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qApp
operator|&&
name|qApp
operator|->
name|inputContext
argument_list|()
condition|)
block|{
name|ic
operator|=
name|qApp
operator|->
name|inputContext
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ic
condition|)
name|ic
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QCoeFepInputContext
name|QCoeFepInputContext
operator|::
name|QCoeFepInputContext
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QInputContext
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_fepState
argument_list|(
name|q_check_ptr
argument_list|(
operator|new
name|CAknEdwinState
argument_list|)
argument_list|)
member_init_list|,
comment|// CBase derived object needs check on new
name|m_lastImHints
argument_list|(
name|Qt
operator|::
name|ImhNone
argument_list|)
member_init_list|,
name|m_textCapabilities
argument_list|(
name|TCoeInputCapabilities
operator|::
name|EAllText
argument_list|)
member_init_list|,
name|m_inDestruction
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_pendingInputCapabilitiesChanged
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_cursorVisibility
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|m_inlinePosition
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_formatRetriever
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_pointerHandler
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_hasTempPreeditString
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_splitViewResizeBy
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_splitViewPreviousWindowStates
argument_list|(
name|Qt
operator|::
name|WindowNoState
argument_list|)
block|{
name|m_fepState
operator|->
name|SetObjectProvider
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|int
name|defaultFlags
init|=
name|EAknEditorFlagDefault
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|>
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
block|{
if|if
condition|(
name|S60
operator|->
name|partial_keyboard
condition|)
block|{
name|defaultFlags
operator||=
name|QT_EAknEditorFlagEnablePartialScreen
expr_stmt|;
block|}
name|defaultFlags
operator||=
name|QT_EAknEditorFlagSelectionVisible
expr_stmt|;
block|}
name|m_fepState
operator|->
name|SetFlags
argument_list|(
name|defaultFlags
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetDefaultInputMode
argument_list|(
name|EAknEditorTextInputMode
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetPermittedInputModes
argument_list|(
name|EAknEditorAllInputModes
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetDefaultCase
argument_list|(
name|EAknEditorTextCase
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetPermittedCases
argument_list|(
name|EAknEditorAllCaseModes
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
name|R_AVKON_SPECIAL_CHARACTER_TABLE_DIALOG
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetNumericKeymap
argument_list|(
name|EAknEditorAlphanumericNumberModeKeymap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QCoeFepInputContext
name|QCoeFepInputContext
operator|::
name|~
name|QCoeFepInputContext
parameter_list|()
block|{
name|m_inDestruction
operator|=
literal|true
expr_stmt|;
comment|// This is to make sure that the FEP manager "forgets" about us,
comment|// otherwise we may get callbacks even after we're destroyed.
comment|// The call below is essentially equivalent to InputCapabilitiesChanged(),
comment|// but is synchronous, rather than asynchronous.
name|CCoeEnv
operator|::
name|Static
argument_list|()
operator|->
name|SyncNotifyFocusObserversOfChangeInFocus
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_fepState
condition|)
operator|delete
name|m_fepState
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|reset
name|void
name|QCoeFepInputContext
operator|::
name|reset
parameter_list|()
block|{
name|commitCurrentString
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ReportAknEdStateEvent
name|void
name|QCoeFepInputContext
operator|::
name|ReportAknEdStateEvent
parameter_list|(
name|MAknEdStateObserver
operator|::
name|EAknEdwinStateEvent
name|aEventType
parameter_list|)
block|{
name|QT_TRAP_THROWING
argument_list|(
name|m_fepState
operator|->
name|ReportAknEdStateEventL
argument_list|(
name|aEventType
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update
name|void
name|QCoeFepInputContext
operator|::
name|update
parameter_list|()
block|{
name|updateHints
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// For pre-5.0 SDKs, we don't do text updates on S60 side.
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|<
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
block|{
return|return;
block|}
comment|// Don't be fooled (as I was) by the name of this enumeration.
comment|// What it really does is tell the virtual keyboard UI that the text has been
comment|// updated and it should be reflected in the internal display of the VK.
name|ReportAknEdStateEvent
argument_list|(
name|QT_EAknCursorPositionChanged
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFocusWidget
name|void
name|QCoeFepInputContext
operator|::
name|setFocusWidget
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
name|commitCurrentString
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QInputContext
operator|::
name|setFocusWidget
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|updateHints
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|widgetDestroyed
name|void
name|QCoeFepInputContext
operator|::
name|widgetDestroyed
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
block|{
comment|// Make sure that the input capabilities of whatever new widget got focused are queried.
name|CCoeControl
modifier|*
name|ctrl
init|=
name|w
operator|->
name|effectiveWinId
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|IsFocused
argument_list|()
condition|)
block|{
name|queueInputCapabilitiesChanged
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|language
name|QString
name|QCoeFepInputContext
operator|::
name|language
parameter_list|()
block|{
name|TLanguage
name|lang
init|=
name|m_fepState
operator|->
name|LocalLanguage
argument_list|()
decl_stmt|;
specifier|const
name|QByteArray
name|localeName
init|=
name|qt_symbianLocaleName
argument_list|(
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localeName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|localeName
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"C"
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|needsInputPanel
name|bool
name|QCoeFepInputContext
operator|::
name|needsInputPanel
parameter_list|()
block|{
switch|switch
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
condition|)
block|{
case|case
name|QSysInfo
operator|::
name|SV_S60_3_1
case|:
case|case
name|QSysInfo
operator|::
name|SV_S60_3_2
case|:
comment|// There are no touch phones for pre-5.0 SDKs.
return|return
literal|false
return|;
ifdef|#
directive|ifdef
name|Q_CC_NOKIAX86
default|default:
comment|// For emulator we assume that we need an input panel, since we can't
comment|// separate between phone types.
return|return
literal|true
return|;
else|#
directive|else
case|case
name|QSysInfo
operator|::
name|SV_S60_5_0
case|:
block|{
comment|// For SDK == 5.0, we need phone specific detection, since the HAL API
comment|// is no good on most phones. However, all phones at the time of writing use the
comment|// input panel, except N97 in landscape mode, but in this mode it refuses to bring
comment|// up the panel anyway, so we don't have to care.
return|return
literal|true
return|;
block|}
default|default:
comment|// For unknown/newer types, we try to use the HAL API.
name|int
name|keyboardEnabled
decl_stmt|;
name|int
name|keyboardType
decl_stmt|;
name|int
name|err
index|[
literal|2
index|]
decl_stmt|;
name|err
index|[
literal|0
index|]
operator|=
name|HAL
operator|::
name|Get
argument_list|(
name|HAL
operator|::
name|EKeyboard
argument_list|,
name|keyboardType
argument_list|)
expr_stmt|;
name|err
index|[
literal|1
index|]
operator|=
name|HAL
operator|::
name|Get
argument_list|(
name|HAL
operator|::
name|EKeyboardState
argument_list|,
name|keyboardEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
index|[
literal|0
index|]
operator|==
name|KErrNone
operator|&&
name|err
index|[
literal|1
index|]
operator|==
name|KErrNone
operator|&&
name|keyboardType
operator|!=
literal|0
operator|&&
name|keyboardEnabled
condition|)
comment|// Means that we have some sort of keyboard.
return|return
literal|false
return|;
comment|// Fall back to using the input panel.
return|return
literal|true
return|;
endif|#
directive|endif
comment|// !Q_CC_NOKIAX86
block|}
block|}
end_function
begin_function
DECL|function|filterEvent
name|bool
name|QCoeFepInputContext
operator|::
name|filterEvent
parameter_list|(
specifier|const
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// The CloseSoftwareInputPanel event is not handled here, because the VK will automatically
comment|// close when it discovers that the underlying widget does not have input capabilities.
if|if
condition|(
operator|!
name|focusWidget
argument_list|()
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|MouseButtonPress
case|:
comment|// Alphanumeric keypad doesn't like it when we click and text is still getting displayed
comment|// It ignores the mouse event, so we need to commit and send a selection event (which will get triggered
comment|// after the commit)
if|if
condition|(
operator|!
name|m_preeditString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|commitCurrentString
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|focusWidget
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|selectAttributes
decl_stmt|;
name|selectAttributes
operator|<<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Selection
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|selectEvent
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|selectAttributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|selectEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|KeyPress
case|:
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
comment|// fall through intended
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
specifier|const
name|QKeyEvent
modifier|*
name|keyEvent
init|=
cast|static_cast
argument_list|<
specifier|const
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
comment|//If proxy exists, always use hints from proxy.
name|QWidget
modifier|*
name|proxy
init|=
name|focusWidget
argument_list|()
operator|->
name|focusProxy
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|InputMethodHints
name|currentHints
init|=
name|proxy
condition|?
name|proxy
operator|->
name|inputMethodHints
argument_list|()
else|:
name|focusWidget
argument_list|()
operator|->
name|inputMethodHints
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|keyEvent
operator|->
name|key
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|Key_F20
case|:
name|Q_ASSERT
argument_list|(
name|m_lastImHints
operator|==
name|currentHints
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_lastImHints
operator|&
name|Qt
operator|::
name|ImhHiddenText
condition|)
block|{
comment|// Special case in Symbian. On editors with secret text, F20 is for some reason
comment|// considered to be a backspace.
name|QKeyEvent
name|modifiedEvent
argument_list|(
name|keyEvent
operator|->
name|type
argument_list|()
argument_list|,
name|Qt
operator|::
name|Key_Backspace
argument_list|,
name|keyEvent
operator|->
name|modifiers
argument_list|()
argument_list|,
name|keyEvent
operator|->
name|text
argument_list|()
argument_list|,
name|keyEvent
operator|->
name|isAutoRepeat
argument_list|()
argument_list|,
name|keyEvent
operator|->
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|focusWidget
argument_list|()
argument_list|,
operator|&
name|modifiedEvent
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
case|case
name|Qt
operator|::
name|Key_Select
case|:
if|if
condition|(
operator|!
name|m_preeditString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|commitCurrentString
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|QString
name|widgetText
init|=
name|focusWidget
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImSurroundingText
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|bool
name|validLength
decl_stmt|;
name|int
name|maxLength
init|=
name|focusWidget
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImMaximumTextLength
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|validLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyEvent
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|validLength
operator|&&
name|widgetText
operator|.
name|size
argument_list|()
operator|+
name|m_preeditString
operator|.
name|size
argument_list|()
operator|>=
name|maxLength
condition|)
block|{
comment|// Don't send key events with string content if the widget is "full".
return|return
literal|true
return|;
block|}
if|if
condition|(
name|keyEvent
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|KeyPress
operator|&&
name|currentHints
operator|&
name|Qt
operator|::
name|ImhHiddenText
operator|&&
operator|!
name|keyEvent
operator|->
name|text
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Send some temporary preedit text in order to make text visible for a moment.
name|m_preeditString
operator|=
name|keyEvent
operator|->
name|text
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|QInputMethodEvent
name|imEvent
argument_list|(
name|m_preeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|imEvent
argument_list|)
expr_stmt|;
name|m_tempPreeditStringTimeout
operator|.
name|start
argument_list|(
literal|1000
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|m_hasTempPreeditString
operator|=
literal|true
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|needsInputPanel
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|RequestSoftwareInputPanel
condition|)
block|{
comment|// Notify S60 that we want the virtual keyboard to show up.
name|QSymbianControl
modifier|*
name|sControl
decl_stmt|;
name|sControl
operator|=
name|focusWidget
argument_list|()
operator|->
name|effectiveWinId
argument_list|()
operator|->
name|MopGetObject
argument_list|(
name|sControl
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sControl
argument_list|)
expr_stmt|;
comment|// The FEP UI temporarily steals focus when it shows up the first time, causing
comment|// all sorts of weird effects on the focused widgets. Since it will immediately give
comment|// back focus to us, we temporarily disable focus handling until the job's done.
if|if
condition|(
name|sControl
condition|)
block|{
name|sControl
operator|->
name|setIgnoreFocusChanged
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|ensureInputCapabilitiesChanged
argument_list|()
expr_stmt|;
name|m_fepState
operator|->
name|ReportAknEdStateEventL
argument_list|(
name|MAknEdStateObserver
operator|::
name|QT_EAknActivatePenInputRequest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sControl
condition|)
block|{
name|sControl
operator|->
name|setIgnoreFocusChanged
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|symbianFilterEvent
name|bool
name|QCoeFepInputContext
operator|::
name|symbianFilterEvent
parameter_list|(
name|QWidget
modifier|*
name|keyWidget
parameter_list|,
specifier|const
name|QSymbianEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|keyWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QSymbianEvent
operator|::
name|CommandEvent
condition|)
comment|// A command basically means the same as a button being pushed. With Qt buttons
comment|// that would normally result in a reset of the input method due to the focus change.
comment|// This should also happen for commands.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QSymbianEvent
operator|::
name|WindowServerEvent
operator|&&
name|event
operator|->
name|windowServerEvent
argument_list|()
operator|&&
name|event
operator|->
name|windowServerEvent
argument_list|()
operator|->
name|Type
argument_list|()
operator|==
name|EEventWindowVisibilityChanged
operator|&&
name|S60
operator|->
name|splitViewLastWidget
condition|)
block|{
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|splitViewLastWidget
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|alwaysResize
init|=
operator|(
name|gv
operator|&&
name|gv
operator|->
name|verticalScrollBarPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
operator|)
decl_stmt|;
if|if
condition|(
name|alwaysResize
condition|)
block|{
name|TUint
name|visibleFlags
init|=
name|event
operator|->
name|windowServerEvent
argument_list|()
operator|->
name|VisibilityChanged
argument_list|()
operator|->
name|iFlags
decl_stmt|;
if|if
condition|(
name|visibleFlags
operator|&
name|TWsVisibilityChangedEvent
operator|::
name|EPartiallyVisible
condition|)
name|ensureFocusWidgetVisible
argument_list|(
name|S60
operator|->
name|splitViewLastWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibleFlags
operator|&
name|TWsVisibilityChangedEvent
operator|::
name|ENotVisible
condition|)
name|resetSplitViewWidget
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|timerEvent
name|void
name|QCoeFepInputContext
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|timerEvent
parameter_list|)
block|{
if|if
condition|(
name|timerEvent
operator|->
name|timerId
argument_list|()
operator|==
name|m_tempPreeditStringTimeout
operator|.
name|timerId
argument_list|()
condition|)
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commitTemporaryPreeditString
name|void
name|QCoeFepInputContext
operator|::
name|commitTemporaryPreeditString
parameter_list|()
block|{
if|if
condition|(
name|m_tempPreeditStringTimeout
operator|.
name|isActive
argument_list|()
condition|)
name|m_tempPreeditStringTimeout
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_hasTempPreeditString
condition|)
return|return;
name|commitCurrentString
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mouseHandler
name|void
name|QCoeFepInputContext
operator|::
name|mouseHandler
parameter_list|(
name|int
name|x
parameter_list|,
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|focusWidget
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|MouseButtonPress
operator|&&
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
name|commitCurrentString
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|focusWidget
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|attributes
operator|<<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Selection
argument_list|,
name|pos
operator|+
name|x
argument_list|,
literal|0
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|inputCapabilities
name|TCoeInputCapabilities
name|QCoeFepInputContext
operator|::
name|inputCapabilities
parameter_list|()
block|{
if|if
condition|(
name|m_inDestruction
operator|||
operator|!
name|focusWidget
argument_list|()
condition|)
block|{
return|return
name|TCoeInputCapabilities
argument_list|(
name|TCoeInputCapabilities
operator|::
name|ENone
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|TCoeInputCapabilities
argument_list|(
name|m_textCapabilities
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resetSplitViewWidget
name|void
name|QCoeFepInputContext
operator|::
name|resetSplitViewWidget
parameter_list|(
name|bool
name|keepInputWidget
parameter_list|)
block|{
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|splitViewLastWidget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
block|{
return|return;
block|}
name|QSymbianControl
modifier|*
name|symControl
init|=
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|gv
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
decl_stmt|;
name|symControl
operator|->
name|CancelLongTapTimer
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|alwaysResize
init|=
operator|(
name|gv
operator|->
name|verticalScrollBarPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
operator|)
decl_stmt|;
name|QWidget
modifier|*
name|windowToMove
init|=
name|gv
operator|->
name|window
argument_list|()
decl_stmt|;
name|bool
name|userResize
init|=
name|gv
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|windowToMove
operator|->
name|setUpdatesEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alwaysResize
condition|)
block|{
if|if
condition|(
name|gv
operator|->
name|scene
argument_list|()
condition|)
block|{
if|if
condition|(
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
condition|)
block|{
comment|// Check if the widget contains cursorPositionChanged signal and disconnect from it.
name|QByteArray
name|signal
init|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|SIGNAL
argument_list|(
name|cursorPositionChanged
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
operator|->
name|toGraphicsObject
argument_list|()
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfSignal
argument_list|(
name|signal
operator|.
name|right
argument_list|(
name|signal
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|disconnect
argument_list|(
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
operator|->
name|toGraphicsObject
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|cursorPositionChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|translateInputWidget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QGraphicsItem
modifier|*
name|rootItem
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
block|{
name|rootItem
operator|=
name|item
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rootItem
condition|)
name|rootItem
operator|->
name|resetTransform
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|m_splitViewResizeBy
condition|)
name|gv
operator|->
name|resize
argument_list|(
name|gv
operator|->
name|rect
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|m_splitViewResizeBy
argument_list|)
expr_stmt|;
block|}
comment|// Resizing might have led to widget losing its original windowstate.
comment|// Restore previous window state.
if|if
condition|(
name|m_splitViewPreviousWindowStates
operator|!=
name|windowToMove
operator|->
name|windowState
argument_list|()
condition|)
name|windowToMove
operator|->
name|setWindowState
argument_list|(
name|m_splitViewPreviousWindowStates
argument_list|)
expr_stmt|;
name|windowToMove
operator|->
name|setUpdatesEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|gv
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|userResize
argument_list|)
expr_stmt|;
comment|//not a user resize
name|m_splitViewResizeBy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keepInputWidget
condition|)
block|{
name|m_splitViewPreviousWindowStates
operator|=
name|Qt
operator|::
name|WindowNoState
expr_stmt|;
name|S60
operator|->
name|splitViewLastWidget
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Checks if a given widget is visible in the splitview rect. The offset
end_comment
begin_comment
comment|// parameter can be used to validate if moving widget upwards or downwards
end_comment
begin_comment
comment|// by the offset would make a difference for the visibility.
end_comment
begin_function
DECL|function|isWidgetVisible
name|bool
name|QCoeFepInputContext
operator|::
name|isWidgetVisible
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|bool
name|visible
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|widget
condition|)
block|{
name|QRect
name|splitViewRect
init|=
name|qt_TRect2QRect
argument_list|(
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
argument_list|)
decl_stmt|;
name|QWidget
modifier|*
name|window
init|=
name|QApplication
operator|::
name|activeWindow
argument_list|()
decl_stmt|;
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|&&
name|window
condition|)
block|{
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scene
init|=
name|gv
operator|->
name|scene
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|focusItem
init|=
name|scene
operator|->
name|focusItem
argument_list|()
condition|)
block|{
name|QPoint
name|cursorPos
init|=
name|window
operator|->
name|mapToGlobal
argument_list|(
name|focusItem
operator|->
name|cursor
argument_list|()
operator|.
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|cursorPos
operator|.
name|setY
argument_list|(
name|cursorPos
operator|.
name|y
argument_list|()
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitViewRect
operator|.
name|contains
argument_list|(
name|cursorPos
argument_list|)
condition|)
block|{
name|visible
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|visible
return|;
block|}
end_function
begin_comment
comment|// Ensure that the input widget is visible in the splitview rect.
end_comment
begin_function
DECL|function|ensureFocusWidgetVisible
name|void
name|QCoeFepInputContext
operator|::
name|ensureFocusWidgetVisible
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
comment|// Native side opening and closing its virtual keyboard when it changes the keyboard layout,
comment|// has an adverse impact on long tap timer. Cancel the timer when splitview opens to avoid this.
name|QSymbianControl
modifier|*
name|symControl
init|=
cast|static_cast
argument_list|<
name|QSymbianControl
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|effectiveWinId
argument_list|()
argument_list|)
decl_stmt|;
name|symControl
operator|->
name|CancelLongTapTimer
argument_list|()
expr_stmt|;
comment|// Graphicsviews that have vertical scrollbars should always be resized to the splitview area.
comment|// Graphicsviews without scrollbars should be translated.
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
return|return;
specifier|const
name|bool
name|alwaysResize
init|=
operator|(
name|gv
operator|&&
name|gv
operator|->
name|verticalScrollBarPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|ScrollBarAlwaysOff
operator|)
decl_stmt|;
specifier|const
name|bool
name|moveWithinVisibleArea
init|=
operator|(
name|S60
operator|->
name|splitViewLastWidget
operator|!=
literal|0
operator|)
decl_stmt|;
name|QWidget
modifier|*
name|windowToMove
init|=
name|gv
condition|?
name|gv
else|:
name|symControl
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|windowToMove
operator|->
name|isWindow
argument_list|()
condition|)
name|windowToMove
operator|=
name|windowToMove
operator|->
name|window
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|windowToMove
condition|)
block|{
return|return;
block|}
comment|// When opening the keyboard (not moving within the splitview area), save the original
comment|// window state. In some cases, ensuring input widget visibility might lead to window
comment|// states getting changed.
if|if
condition|(
operator|!
name|moveWithinVisibleArea
condition|)
block|{
comment|// Check if the widget contains cursorPositionChanged signal and connect to it.
name|QByteArray
name|signal
init|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|SIGNAL
argument_list|(
name|cursorPositionChanged
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gv
operator|->
name|scene
argument_list|()
operator|&&
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
condition|)
block|{
name|int
name|index
init|=
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
operator|->
name|toGraphicsObject
argument_list|()
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfSignal
argument_list|(
name|signal
operator|.
name|right
argument_list|(
name|signal
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|connect
argument_list|(
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|focusItem
argument_list|()
operator|->
name|toGraphicsObject
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|cursorPositionChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|translateInputWidget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|S60
operator|->
name|splitViewLastWidget
operator|=
name|widget
expr_stmt|;
name|m_splitViewPreviousWindowStates
operator|=
name|windowToMove
operator|->
name|windowState
argument_list|()
expr_stmt|;
block|}
name|int
name|windowTop
init|=
name|widget
operator|->
name|window
argument_list|()
operator|->
name|pos
argument_list|()
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|userResize
init|=
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|QRect
name|splitViewRect
init|=
name|qt_TRect2QRect
argument_list|(
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
argument_list|)
decl_stmt|;
comment|// When resizing a window widget, it will lose its maximized window state.
comment|// Native applications hide statuspane in splitview state, so lets move to
comment|// fullscreen mode. This makes available area slightly bigger, which helps usability
comment|// and greatly reduces event passing in orientation switch cases,
comment|// as the statuspane size is not changing.
if|if
condition|(
name|alwaysResize
condition|)
name|windowToMove
operator|->
name|setUpdatesEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|windowToMove
operator|->
name|windowState
argument_list|()
operator|&
name|Qt
operator|::
name|WindowFullScreen
operator|)
condition|)
block|{
name|windowToMove
operator|->
name|setWindowState
argument_list|(
operator|(
name|windowToMove
operator|->
name|windowState
argument_list|()
operator|&
operator|~
operator|(
name|Qt
operator|::
name|WindowMinimized
operator||
name|Qt
operator|::
name|WindowFullScreen
operator|)
operator|)
operator||
name|Qt
operator|::
name|WindowFullScreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alwaysResize
condition|)
block|{
if|if
condition|(
operator|!
name|moveWithinVisibleArea
condition|)
block|{
name|m_splitViewResizeBy
operator|=
name|widget
operator|->
name|height
argument_list|()
expr_stmt|;
name|windowTop
operator|=
name|widget
operator|->
name|geometry
argument_list|()
operator|.
name|top
argument_list|()
expr_stmt|;
name|widget
operator|->
name|resize
argument_list|(
name|widget
operator|->
name|width
argument_list|()
argument_list|,
name|splitViewRect
operator|.
name|height
argument_list|()
operator|-
name|windowTop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gv
operator|->
name|scene
argument_list|()
condition|)
block|{
specifier|const
name|QRectF
name|microFocusRect
init|=
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImMicroFocus
argument_list|)
operator|.
name|toRectF
argument_list|()
decl_stmt|;
name|gv
operator|->
name|ensureVisible
argument_list|(
name|microFocusRect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|translateInputWidget
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|alwaysResize
condition|)
name|windowToMove
operator|->
name|setUpdatesEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|userResize
argument_list|)
expr_stmt|;
comment|//not a user resize
block|}
end_function
begin_function
DECL|function|qt_TCharFormat2QTextCharFormat
specifier|static
name|QTextCharFormat
name|qt_TCharFormat2QTextCharFormat
parameter_list|(
specifier|const
name|TCharFormat
modifier|&
name|cFormat
parameter_list|,
name|bool
name|validStyleColor
parameter_list|)
block|{
name|QTextCharFormat
name|qFormat
decl_stmt|;
if|if
condition|(
name|validStyleColor
condition|)
block|{
name|QBrush
name|foreground
argument_list|(
name|QColor
argument_list|(
name|cFormat
operator|.
name|iFontPresentation
operator|.
name|iTextColor
operator|.
name|Internal
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|qFormat
operator|.
name|setForeground
argument_list|(
name|foreground
argument_list|)
expr_stmt|;
block|}
name|qFormat
operator|.
name|setFontStrikeOut
argument_list|(
name|cFormat
operator|.
name|iFontPresentation
operator|.
name|iStrikethrough
operator|==
name|EStrikethroughOn
argument_list|)
expr_stmt|;
name|qFormat
operator|.
name|setFontUnderline
argument_list|(
name|cFormat
operator|.
name|iFontPresentation
operator|.
name|iUnderline
operator|==
name|EUnderlineOn
argument_list|)
expr_stmt|;
return|return
name|qFormat
return|;
block|}
end_function
begin_function
DECL|function|updateHints
name|void
name|QCoeFepInputContext
operator|::
name|updateHints
parameter_list|(
name|bool
name|mustUpdateInputCapabilities
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|QWidget
modifier|*
name|proxy
init|=
name|w
operator|->
name|focusProxy
argument_list|()
decl_stmt|;
name|Qt
operator|::
name|InputMethodHints
name|hints
init|=
name|proxy
condition|?
name|proxy
operator|->
name|inputMethodHints
argument_list|()
else|:
name|w
operator|->
name|inputMethodHints
argument_list|()
decl_stmt|;
comment|// Since splitview support works like an input method hint, yet it is private flag,
comment|// we need to update its state separately.
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|>
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
block|{
name|TInt
name|currentFlags
init|=
name|m_fepState
operator|->
name|Flags
argument_list|()
decl_stmt|;
if|if
condition|(
name|S60
operator|->
name|partial_keyboard
condition|)
name|currentFlags
operator||=
name|QT_EAknEditorFlagEnablePartialScreen
expr_stmt|;
else|else
name|currentFlags
operator|&=
operator|~
name|QT_EAknEditorFlagEnablePartialScreen
expr_stmt|;
if|if
condition|(
name|currentFlags
operator|!=
name|m_fepState
operator|->
name|Flags
argument_list|()
condition|)
name|m_fepState
operator|->
name|SetFlags
argument_list|(
name|currentFlags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hints
operator|!=
name|m_lastImHints
condition|)
block|{
name|m_lastImHints
operator|=
name|hints
expr_stmt|;
name|applyHints
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mustUpdateInputCapabilities
condition|)
block|{
comment|// Optimization. Return immediately if there was no change.
return|return;
block|}
block|}
name|queueInputCapabilitiesChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applyHints
name|void
name|QCoeFepInputContext
operator|::
name|applyHints
parameter_list|(
name|Qt
operator|::
name|InputMethodHints
name|hints
parameter_list|)
block|{
using|using
namespace|namespace
name|Qt
namespace|;
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|anynumbermodes
init|=
name|hints
operator|&
operator|(
name|ImhDigitsOnly
operator||
name|ImhFormattedNumbersOnly
operator||
name|ImhDialableCharactersOnly
operator|)
decl_stmt|;
specifier|const
name|bool
name|anytextmodes
init|=
name|hints
operator|&
operator|(
name|ImhUppercaseOnly
operator||
name|ImhLowercaseOnly
operator||
name|ImhEmailCharactersOnly
operator||
name|ImhUrlCharactersOnly
operator|)
decl_stmt|;
specifier|const
name|bool
name|numbersOnly
init|=
name|anynumbermodes
operator|&&
operator|!
name|anytextmodes
decl_stmt|;
specifier|const
name|bool
name|noOnlys
init|=
operator|!
operator|(
name|hints
operator|&
name|ImhExclusiveInputMask
operator|)
decl_stmt|;
comment|// if alphanumeric input, or if multiple incompatible number modes are selected;
comment|// then make all symbols available in numeric mode too.
specifier|const
name|bool
name|needsCharMap
init|=
operator|!
name|numbersOnly
operator|||
operator|(
operator|(
name|hints
operator|&
name|ImhFormattedNumbersOnly
operator|)
operator|&&
operator|(
name|hints
operator|&
name|ImhDialableCharactersOnly
operator|)
operator|)
decl_stmt|;
name|TInt
name|flags
decl_stmt|;
name|Qt
operator|::
name|InputMethodHints
name|oldHints
init|=
name|hints
decl_stmt|;
comment|// Some sanity checking. Make sure that only one preference is set.
name|InputMethodHints
name|prefs
init|=
name|ImhPreferNumbers
operator||
name|ImhPreferUppercase
operator||
name|ImhPreferLowercase
decl_stmt|;
name|prefs
operator|&=
name|hints
expr_stmt|;
if|if
condition|(
name|prefs
operator|!=
name|ImhPreferNumbers
operator|&&
name|prefs
operator|!=
name|ImhPreferUppercase
operator|&&
name|prefs
operator|!=
name|ImhPreferLowercase
condition|)
block|{
name|hints
operator|&=
operator|~
name|prefs
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noOnlys
condition|)
block|{
comment|// Make sure that the preference is within the permitted set.
if|if
condition|(
name|hints
operator|&
name|ImhPreferNumbers
operator|&&
operator|!
name|anynumbermodes
condition|)
block|{
name|hints
operator|&=
operator|~
name|ImhPreferNumbers
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhPreferUppercase
operator|&&
operator|!
operator|(
name|hints
operator|&
name|ImhUppercaseOnly
operator|)
condition|)
block|{
name|hints
operator|&=
operator|~
name|ImhPreferUppercase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhPreferLowercase
operator|&&
operator|!
operator|(
name|hints
operator|&
name|ImhLowercaseOnly
operator|)
condition|)
block|{
name|hints
operator|&=
operator|~
name|ImhPreferLowercase
expr_stmt|;
block|}
comment|// If there is no preference, set it to something within the permitted set.
if|if
condition|(
operator|!
operator|(
name|hints
operator|&
name|ImhPreferNumbers
operator|||
name|hints
operator|&
name|ImhPreferUppercase
operator|||
name|hints
operator|&
name|ImhPreferLowercase
operator|)
condition|)
block|{
if|if
condition|(
name|hints
operator|&
name|ImhLowercaseOnly
condition|)
block|{
name|hints
operator||=
name|ImhPreferLowercase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhUppercaseOnly
condition|)
block|{
name|hints
operator||=
name|ImhPreferUppercase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numbersOnly
condition|)
block|{
name|hints
operator||=
name|ImhPreferNumbers
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hints
operator|&
name|ImhPreferNumbers
condition|)
block|{
name|m_fepState
operator|->
name|SetDefaultInputMode
argument_list|(
name|EAknEditorNumericInputMode
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentInputMode
argument_list|(
name|EAknEditorNumericInputMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_fepState
operator|->
name|SetDefaultInputMode
argument_list|(
name|EAknEditorTextInputMode
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentInputMode
argument_list|(
name|EAknEditorTextInputMode
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noOnlys
operator|||
operator|(
name|anynumbermodes
operator|&&
name|anytextmodes
operator|)
condition|)
block|{
name|flags
operator|=
name|EAknEditorAllInputModes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anynumbermodes
condition|)
block|{
name|flags
operator||=
name|EAknEditorNumericInputMode
expr_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|>
name|QSysInfo
operator|::
name|SV_S60_5_0
operator|&&
operator|(
operator|(
name|hints
operator|&
name|ImhFormattedNumbersOnly
operator|)
operator|||
operator|(
name|hints
operator|&
name|ImhDialableCharactersOnly
operator|)
operator|)
condition|)
block|{
comment|//workaround - the * key does not launch the symbols menu, making it impossible to use these modes unless text mode is enabled.
name|flags
operator||=
name|EAknEditorTextInputMode
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|anytextmodes
condition|)
block|{
name|flags
operator||=
name|EAknEditorTextInputMode
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|EAknEditorAllInputModes
expr_stmt|;
block|}
name|m_fepState
operator|->
name|SetPermittedInputModes
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ReportAknEdStateEvent
argument_list|(
name|MAknEdStateObserver
operator|::
name|EAknEdwinStateInputModeUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|ImhPreferLowercase
condition|)
block|{
name|m_fepState
operator|->
name|SetDefaultCase
argument_list|(
name|EAknEditorLowerCase
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentCase
argument_list|(
name|EAknEditorLowerCase
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhPreferUppercase
condition|)
block|{
name|m_fepState
operator|->
name|SetDefaultCase
argument_list|(
name|EAknEditorUpperCase
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentCase
argument_list|(
name|EAknEditorUpperCase
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhNoAutoUppercase
condition|)
block|{
name|m_fepState
operator|->
name|SetDefaultCase
argument_list|(
name|EAknEditorLowerCase
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentCase
argument_list|(
name|EAknEditorLowerCase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_fepState
operator|->
name|SetDefaultCase
argument_list|(
name|EAknEditorTextCase
argument_list|)
expr_stmt|;
name|m_fepState
operator|->
name|SetCurrentCase
argument_list|(
name|EAknEditorTextCase
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|ImhUppercaseOnly
condition|)
block|{
name|flags
operator||=
name|EAknEditorUpperCase
expr_stmt|;
block|}
if|if
condition|(
name|hints
operator|&
name|ImhLowercaseOnly
condition|)
block|{
name|flags
operator||=
name|EAknEditorLowerCase
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
name|EAknEditorAllCaseModes
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|ImhNoAutoUppercase
condition|)
block|{
name|flags
operator|&=
operator|~
name|EAknEditorTextCase
expr_stmt|;
block|}
block|}
name|m_fepState
operator|->
name|SetPermittedCases
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ReportAknEdStateEvent
argument_list|(
name|MAknEdStateObserver
operator|::
name|EAknEdwinStateCaseModeUpdate
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|>
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
block|{
if|if
condition|(
name|S60
operator|->
name|partial_keyboard
condition|)
name|flags
operator||=
name|QT_EAknEditorFlagEnablePartialScreen
expr_stmt|;
name|flags
operator||=
name|QT_EAknEditorFlagSelectionVisible
expr_stmt|;
block|}
if|if
condition|(
name|hints
operator|&
name|ImhUppercaseOnly
operator|&&
operator|!
operator|(
name|hints
operator|&
name|ImhLowercaseOnly
operator|)
operator|||
name|hints
operator|&
name|ImhLowercaseOnly
operator|&&
operator|!
operator|(
name|hints
operator|&
name|ImhUppercaseOnly
operator|)
condition|)
block|{
name|flags
operator||=
name|EAknEditorFlagFixedCase
expr_stmt|;
block|}
comment|// Using T9 and hidden text together may actually crash the FEP, so check for hidden text too.
if|if
condition|(
name|hints
operator|&
name|ImhNoPredictiveText
operator|||
name|hints
operator|&
name|ImhHiddenText
condition|)
block|{
name|flags
operator||=
name|EAknEditorFlagNoT9
expr_stmt|;
block|}
if|if
condition|(
name|needsCharMap
condition|)
name|flags
operator||=
name|EAknEditorFlagUseSCTNumericCharmap
expr_stmt|;
name|m_fepState
operator|->
name|SetFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ReportAknEdStateEvent
argument_list|(
name|MAknEdStateObserver
operator|::
name|EAknEdwinStateFlagsUpdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|ImhDialableCharactersOnly
condition|)
block|{
comment|// This is first, because if (ImhDialableCharactersOnly | ImhFormattedNumbersOnly)
comment|// is specified, this one is more natural (# key enters a #)
name|flags
operator|=
name|EAknEditorStandardNumberModeKeymap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhFormattedNumbersOnly
condition|)
block|{
comment|// # key enters decimal point
name|flags
operator|=
name|EAknEditorCalculatorNumberModeKeymap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhDigitsOnly
condition|)
block|{
comment|// This is last, because it is most restrictive (# key is inactive)
name|flags
operator|=
name|EAknEditorPlainNumberModeKeymap
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|EAknEditorStandardNumberModeKeymap
expr_stmt|;
block|}
name|m_fepState
operator|->
name|SetNumericKeymap
argument_list|(
cast|static_cast
argument_list|<
name|TAknEditorNumericKeymap
argument_list|>
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|ImhUrlCharactersOnly
condition|)
block|{
comment|// URL characters is everything except space, so a superset of the other restrictions
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
name|R_AVKON_URL_SPECIAL_CHARACTER_TABLE_DIALOG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hints
operator|&
name|ImhEmailCharactersOnly
condition|)
block|{
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
name|R_AVKON_EMAIL_ADDR_SPECIAL_CHARACTER_TABLE_DIALOG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|needsCharMap
condition|)
block|{
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
name|R_AVKON_SPECIAL_CHARACTER_TABLE_DIALOG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hints
operator|&
name|ImhFormattedNumbersOnly
operator|)
operator|||
operator|(
name|hints
operator|&
name|ImhDialableCharactersOnly
operator|)
condition|)
block|{
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
name|R_AVKON_SPECIAL_CHARACTER_TABLE_DIALOG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_fepState
operator|->
name|SetSpecialCharacterTableResourceId
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hints
operator|&
name|ImhHiddenText
condition|)
block|{
name|m_textCapabilities
operator|=
name|TCoeInputCapabilities
operator|::
name|EAllText
operator||
name|TCoeInputCapabilities
operator|::
name|ESecretText
expr_stmt|;
block|}
else|else
block|{
name|m_textCapabilities
operator|=
name|TCoeInputCapabilities
operator|::
name|EAllText
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|applyFormat
name|void
name|QCoeFepInputContext
operator|::
name|applyFormat
parameter_list|(
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
modifier|*
name|attributes
parameter_list|)
block|{
name|TCharFormat
name|cFormat
decl_stmt|;
name|QColor
name|styleTextColor
decl_stmt|;
if|if
condition|(
name|QWidget
modifier|*
name|focused
init|=
name|focusWidget
argument_list|()
condition|)
block|{
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|focused
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
comment|// could be either the QGV or its viewport that has focus
name|gv
operator|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|focused
operator|->
name|parentWidget
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
block|{
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scene
init|=
name|gv
operator|->
name|scene
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|focusItem
init|=
name|scene
operator|->
name|focusItem
argument_list|()
condition|)
block|{
if|if
condition|(
name|focusItem
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|styleTextColor
operator|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|focusItem
argument_list|)
operator|->
name|palette
argument_list|()
operator|.
name|text
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|styleTextColor
operator|=
name|focused
operator|->
name|palette
argument_list|()
operator|.
name|text
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|styleTextColor
operator|=
name|QApplication
operator|::
name|palette
argument_list|(
literal|"QLineEdit"
argument_list|)
operator|.
name|text
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|styleTextColor
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|TLogicalRgb
name|fontColor
argument_list|(
name|TRgb
argument_list|(
name|styleTextColor
operator|.
name|red
argument_list|()
argument_list|,
name|styleTextColor
operator|.
name|green
argument_list|()
argument_list|,
name|styleTextColor
operator|.
name|blue
argument_list|()
argument_list|,
name|styleTextColor
operator|.
name|alpha
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|cFormat
operator|.
name|iFontPresentation
operator|.
name|iTextColor
operator|=
name|fontColor
expr_stmt|;
block|}
name|TInt
name|numChars
init|=
literal|0
decl_stmt|;
name|TInt
name|charPos
init|=
literal|0
decl_stmt|;
name|int
name|oldSize
init|=
name|attributes
operator|->
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|m_formatRetriever
condition|)
block|{
name|m_formatRetriever
operator|->
name|GetFormatOfFepInlineText
argument_list|(
name|cFormat
argument_list|,
name|numChars
argument_list|,
name|charPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|numChars
operator|<=
literal|0
condition|)
block|{
comment|// This shouldn't happen according to S60 docs, but apparently does sometimes.
break|break;
block|}
name|attributes
operator|->
name|append
argument_list|(
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|TextFormat
argument_list|,
name|charPos
argument_list|,
name|numChars
argument_list|,
name|QVariant
argument_list|(
name|qt_TCharFormat2QTextCharFormat
argument_list|(
name|cFormat
argument_list|,
name|styleTextColor
operator|.
name|isValid
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|charPos
operator|+=
name|numChars
expr_stmt|;
if|if
condition|(
name|charPos
operator|>=
name|m_preeditString
operator|.
name|size
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|attributes
operator|->
name|size
argument_list|()
operator|==
name|oldSize
condition|)
block|{
comment|// S60 didn't provide any format, so let's give our own instead.
name|attributes
operator|->
name|append
argument_list|(
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|TextFormat
argument_list|,
literal|0
argument_list|,
name|m_preeditString
operator|.
name|size
argument_list|()
argument_list|,
name|standardFormat
argument_list|(
name|PreeditFormat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|queueInputCapabilitiesChanged
name|void
name|QCoeFepInputContext
operator|::
name|queueInputCapabilitiesChanged
parameter_list|()
block|{
if|if
condition|(
name|m_pendingInputCapabilitiesChanged
condition|)
return|return;
comment|// Call ensureInputCapabilitiesChanged asynchronously. This is done to improve performance
comment|// by not updating input capabilities too often. The reason we don't call the Symbian
comment|// asynchronous version of InputCapabilitiesChanged is because we need to ensure that it
comment|// is synchronous in some specific cases. Those will call ensureInputCapabilitesChanged.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"ensureInputCapabilitiesChanged"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|m_pendingInputCapabilitiesChanged
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ensureInputCapabilitiesChanged
name|void
name|QCoeFepInputContext
operator|::
name|ensureInputCapabilitiesChanged
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_pendingInputCapabilitiesChanged
condition|)
return|return;
comment|// The call below is essentially equivalent to InputCapabilitiesChanged(),
comment|// but is synchronous, rather than asynchronous.
name|CCoeEnv
operator|::
name|Static
argument_list|()
operator|->
name|SyncNotifyFocusObserversOfChangeInFocus
argument_list|()
expr_stmt|;
name|m_pendingInputCapabilitiesChanged
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|translateInputWidget
name|void
name|QCoeFepInputContext
operator|::
name|translateInputWidget
parameter_list|()
block|{
name|QGraphicsView
modifier|*
name|gv
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|splitViewLastWidget
argument_list|)
decl_stmt|;
name|QRect
name|splitViewRect
init|=
name|qt_TRect2QRect
argument_list|(
cast|static_cast
argument_list|<
name|CEikAppUi
operator|*
argument_list|>
argument_list|(
name|S60
operator|->
name|appUi
argument_list|()
argument_list|)
operator|->
name|ClientRect
argument_list|()
argument_list|)
decl_stmt|;
name|QRectF
name|cursor
init|=
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImMicroFocus
argument_list|)
operator|.
name|toRectF
argument_list|()
decl_stmt|;
name|QPolygon
name|cursorP
init|=
name|gv
operator|->
name|mapFromScene
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
name|QRectF
name|vkbRect
init|=
name|QRectF
argument_list|(
name|splitViewRect
operator|.
name|bottomLeft
argument_list|()
argument_list|,
name|qApp
operator|->
name|desktop
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
operator|.
name|isEmpty
argument_list|()
operator|||
name|vkbRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Fetch root item (i.e. graphicsitem with no parent)
name|QGraphicsItem
modifier|*
name|rootItem
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|gv
operator|->
name|scene
argument_list|()
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
block|{
name|rootItem
operator|=
name|item
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|rootItem
condition|)
return|return;
name|m_transformation
operator|=
operator|(
name|rootItem
operator|->
name|transform
argument_list|()
operator|.
name|isTranslating
argument_list|()
operator|)
condition|?
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|gv
operator|->
name|width
argument_list|()
argument_list|,
name|rootItem
operator|->
name|transform
argument_list|()
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|QRectF
argument_list|()
expr_stmt|;
comment|// Do nothing if the cursor is visible in the splitview area.
if|if
condition|(
name|splitViewRect
operator|.
name|contains
argument_list|(
name|cursorP
operator|.
name|boundingRect
argument_list|()
argument_list|)
condition|)
return|return;
comment|// New Y position should be ideally at the center of the splitview area.
comment|// If that would expose unpainted canvas, limit the tranformation to the visible scene bottom.
specifier|const
name|qreal
name|maxY
init|=
name|gv
operator|->
name|sceneRect
argument_list|()
operator|.
name|bottom
argument_list|()
operator|-
name|splitViewRect
operator|.
name|bottom
argument_list|()
operator|+
name|m_transformation
operator|.
name|height
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
operator|-
operator|(
name|qMin
argument_list|(
name|maxY
argument_list|,
operator|(
name|cursor
operator|.
name|bottom
argument_list|()
operator|-
name|vkbRect
operator|.
name|top
argument_list|()
operator|/
literal|2
operator|)
argument_list|)
operator|)
decl_stmt|;
comment|// Do not allow transform above screen top.
if|if
condition|(
name|m_transformation
operator|.
name|height
argument_list|()
operator|+
name|dy
operator|>
literal|0
condition|)
return|return;
name|rootItem
operator|->
name|setTransform
argument_list|(
name|QTransform
operator|::
name|fromTranslate
argument_list|(
literal|0
argument_list|,
name|dy
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|StartFepInlineEditL
name|void
name|QCoeFepInputContext
operator|::
name|StartFepInlineEditL
parameter_list|(
specifier|const
name|TDesC
modifier|&
name|aInitialInlineText
parameter_list|,
name|TInt
name|aPositionOfInsertionPointInInlineText
parameter_list|,
name|TBool
name|aCursorVisibility
parameter_list|,
specifier|const
name|MFormCustomDraw
modifier|*
comment|/*aCustomDraw*/
parameter_list|,
name|MFepInlineTextFormatRetriever
modifier|&
name|aInlineTextFormatRetriever
parameter_list|,
name|MFepPointerEventHandlerDuringInlineEdit
modifier|&
name|aPointerEventHandlerDuringInlineEdit
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|m_cursorVisibility
operator|=
name|aCursorVisibility
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|m_inlinePosition
operator|=
name|aPositionOfInsertionPointInInlineText
expr_stmt|;
name|m_preeditString
operator|=
name|qt_TDesC2QString
argument_list|(
name|aInitialInlineText
argument_list|)
expr_stmt|;
name|m_formatRetriever
operator|=
operator|&
name|aInlineTextFormatRetriever
expr_stmt|;
name|m_pointerHandler
operator|=
operator|&
name|aPointerEventHandlerDuringInlineEdit
expr_stmt|;
comment|// With T9 aInitialInlineText is typically empty when StartFepInlineEditL is called,
comment|// but FEP requires that selected text is always removed at StartFepInlineEditL.
comment|// Let's remove the selected text if aInitialInlineText is empty and there is selected text
if|if
condition|(
name|m_preeditString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|anchor
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImAnchorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|cursorPos
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|replacementLength
init|=
name|qAbs
argument_list|(
name|cursorPos
operator|-
name|anchor
argument_list|)
decl_stmt|;
if|if
condition|(
name|replacementLength
operator|>
literal|0
condition|)
block|{
name|int
name|replacementStart
init|=
name|cursorPos
operator|<
name|anchor
condition|?
literal|0
else|:
operator|-
name|replacementLength
decl_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|clearSelectionAttributes
decl_stmt|;
name|QInputMethodEvent
name|clearSelectionEvent
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|clearSelectionAttributes
argument_list|)
decl_stmt|;
name|clearSelectionEvent
operator|.
name|setCommitString
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|replacementStart
argument_list|,
name|replacementLength
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|clearSelectionEvent
argument_list|)
expr_stmt|;
block|}
block|}
name|applyFormat
argument_list|(
operator|&
name|attributes
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|append
argument_list|(
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Cursor
argument_list|,
name|m_inlinePosition
argument_list|,
name|m_cursorVisibility
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|m_preeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|UpdateFepInlineTextL
name|void
name|QCoeFepInputContext
operator|::
name|UpdateFepInlineTextL
parameter_list|(
specifier|const
name|TDesC
modifier|&
name|aNewInlineText
parameter_list|,
name|TInt
name|aPositionOfInsertionPointInInlineText
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
name|m_inlinePosition
operator|=
name|aPositionOfInsertionPointInInlineText
expr_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|applyFormat
argument_list|(
operator|&
name|attributes
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|append
argument_list|(
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Cursor
argument_list|,
name|m_inlinePosition
argument_list|,
name|m_cursorVisibility
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|newPreeditString
init|=
name|qt_TDesC2QString
argument_list|(
name|aNewInlineText
argument_list|)
decl_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|newPreeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
if|if
condition|(
name|newPreeditString
operator|.
name|isEmpty
argument_list|()
operator|&&
name|m_preeditString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// In Symbian world this means "erase last character".
name|event
operator|.
name|setCommitString
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|m_preeditString
operator|=
name|newPreeditString
expr_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SetInlineEditingCursorVisibilityL
name|void
name|QCoeFepInputContext
operator|::
name|SetInlineEditingCursorVisibilityL
parameter_list|(
name|TBool
name|aCursorVisibility
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|m_cursorVisibility
operator|=
name|aCursorVisibility
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|attributes
operator|.
name|append
argument_list|(
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Cursor
argument_list|,
name|m_inlinePosition
argument_list|,
name|m_cursorVisibility
argument_list|,
name|QVariant
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|m_preeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|CancelFepInlineEdit
name|void
name|QCoeFepInputContext
operator|::
name|CancelFepInlineEdit
parameter_list|()
block|{
comment|// We are not supposed to ever have a tempPreeditString and a real preedit string
comment|// from S60 at the same time, so it should be safe to rely on this test to determine
comment|// whether we should honor S60's request to clear the text or not.
if|if
condition|(
name|m_hasTempPreeditString
condition|)
return|return;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|event
operator|.
name|setCommitString
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_preeditString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_inlinePosition
operator|=
literal|0
expr_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DocumentLengthForFep
name|TInt
name|QCoeFepInputContext
operator|::
name|DocumentLengthForFep
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
literal|0
return|;
name|QVariant
name|variant
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImSurroundingText
argument_list|)
decl_stmt|;
return|return
name|variant
operator|.
name|value
argument_list|<
name|QString
argument_list|>
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|m_preeditString
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|DocumentMaximumLengthForFep
name|TInt
name|QCoeFepInputContext
operator|::
name|DocumentMaximumLengthForFep
parameter_list|()
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
literal|0
return|;
name|QVariant
name|variant
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImMaximumTextLength
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|variant
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|size
operator|=
name|variant
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|INT_MAX
expr_stmt|;
comment|// Sensible default for S60.
block|}
return|return
name|size
return|;
block|}
end_function
begin_function
DECL|function|SetCursorSelectionForFepL
name|void
name|QCoeFepInputContext
operator|::
name|SetCursorSelectionForFepL
parameter_list|(
specifier|const
name|TCursorSelection
modifier|&
name|aCursorSelection
parameter_list|)
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return;
name|commitTemporaryPreeditString
argument_list|()
expr_stmt|;
name|int
name|pos
init|=
name|aCursorSelection
operator|.
name|iAnchorPos
decl_stmt|;
name|int
name|length
init|=
name|aCursorSelection
operator|.
name|iCursorPos
operator|-
name|pos
decl_stmt|;
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|attributes
operator|<<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|(
name|QInputMethodEvent
operator|::
name|Selection
argument_list|,
name|pos
argument_list|,
name|length
argument_list|,
name|QVariant
argument_list|()
argument_list|)
expr_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|m_preeditString
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|GetCursorSelectionForFep
name|void
name|QCoeFepInputContext
operator|::
name|GetCursorSelectionForFep
parameter_list|(
name|TCursorSelection
modifier|&
name|aCursorSelection
parameter_list|)
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|aCursorSelection
operator|.
name|SetSelection
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|cursor
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
operator|+
name|m_preeditString
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|anchor
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImAnchorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
operator|+
name|m_preeditString
operator|.
name|size
argument_list|()
decl_stmt|;
name|QString
name|text
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImSurroundingText
argument_list|)
operator|.
name|value
argument_list|<
name|QString
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|combinedSize
init|=
name|text
operator|.
name|size
argument_list|()
operator|+
name|m_preeditString
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|combinedSize
operator|<
name|anchor
operator|||
name|combinedSize
operator|<
name|cursor
condition|)
block|{
comment|// ### TODO! FIXME! QTBUG-5050
comment|// This is a hack to prevent crashing in 4.6 with QLineEdits that use input masks.
comment|// The root problem is that cursor position is relative to displayed text instead of the
comment|// actual text we get.
comment|//
comment|// To properly fix this we would need to know the displayText of QLineEdits instead
comment|// of just the text, which on itself should be a trivial change. The difficulties start
comment|// when we need to commit the changes back to the QLineEdit, which would have to be somehow
comment|// able to handle displayText, too.
comment|//
comment|// Until properly fixed, the cursor and anchor positions will not reflect correct positions
comment|// for masked QLineEdits, unless all the masked positions are filled in order so that
comment|// cursor position relative to the displayed text matches position relative to actual text.
name|aCursorSelection
operator|.
name|iAnchorPos
operator|=
name|combinedSize
expr_stmt|;
name|aCursorSelection
operator|.
name|iCursorPos
operator|=
name|combinedSize
expr_stmt|;
block|}
else|else
block|{
name|aCursorSelection
operator|.
name|iAnchorPos
operator|=
name|anchor
expr_stmt|;
name|aCursorSelection
operator|.
name|iCursorPos
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|GetEditorContentForFep
name|void
name|QCoeFepInputContext
operator|::
name|GetEditorContentForFep
parameter_list|(
name|TDes
modifier|&
name|aEditorContent
parameter_list|,
name|TInt
name|aDocumentPosition
parameter_list|,
name|TInt
name|aLengthToRetrieve
parameter_list|)
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|aEditorContent
operator|.
name|FillZ
argument_list|(
name|aLengthToRetrieve
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|text
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImSurroundingText
argument_list|)
operator|.
name|value
argument_list|<
name|QString
argument_list|>
argument_list|()
decl_stmt|;
comment|// FEP expects the preedit string to be part of the editor content, so let's mix it in.
name|int
name|cursor
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImCursorPosition
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|text
operator|.
name|insert
argument_list|(
name|cursor
argument_list|,
name|m_preeditString
argument_list|)
expr_stmt|;
name|aEditorContent
operator|.
name|Copy
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|text
operator|.
name|mid
argument_list|(
name|aDocumentPosition
argument_list|,
name|aLengthToRetrieve
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|GetFormatForFep
name|void
name|QCoeFepInputContext
operator|::
name|GetFormatForFep
parameter_list|(
name|TCharFormat
modifier|&
name|aFormat
parameter_list|,
name|TInt
comment|/* aDocumentPosition */
parameter_list|)
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|aFormat
operator|=
name|TCharFormat
argument_list|()
expr_stmt|;
return|return;
block|}
name|QFont
name|font
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImFont
argument_list|)
operator|.
name|value
argument_list|<
name|QFont
argument_list|>
argument_list|()
decl_stmt|;
name|QFontMetrics
name|metrics
argument_list|(
name|font
argument_list|)
decl_stmt|;
comment|//QString name = font.rawName();
name|QString
name|name
init|=
name|font
operator|.
name|defaultFamily
argument_list|()
decl_stmt|;
comment|// TODO! FIXME! Should be the above.
name|QHBufC
name|hBufC
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|aFormat
operator|=
name|TCharFormat
argument_list|(
name|hBufC
operator|->
name|Des
argument_list|()
argument_list|,
name|metrics
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|GetScreenCoordinatesForFepL
name|void
name|QCoeFepInputContext
operator|::
name|GetScreenCoordinatesForFepL
parameter_list|(
name|TPoint
modifier|&
name|aLeftSideOfBaseLine
parameter_list|,
name|TInt
modifier|&
name|aHeight
parameter_list|,
name|TInt
modifier|&
name|aAscent
parameter_list|,
name|TInt
comment|/* aDocumentPosition */
parameter_list|)
specifier|const
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
block|{
name|aLeftSideOfBaseLine
operator|=
name|TPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aHeight
operator|=
literal|0
expr_stmt|;
name|aAscent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|QRect
name|rect
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImMicroFocus
argument_list|)
operator|.
name|value
argument_list|<
name|QRect
argument_list|>
argument_list|()
decl_stmt|;
name|aLeftSideOfBaseLine
operator|.
name|iX
operator|=
name|rect
operator|.
name|left
argument_list|()
expr_stmt|;
name|aLeftSideOfBaseLine
operator|.
name|iY
operator|=
name|rect
operator|.
name|bottom
argument_list|()
expr_stmt|;
name|QFont
name|font
init|=
name|w
operator|->
name|inputMethodQuery
argument_list|(
name|Qt
operator|::
name|ImFont
argument_list|)
operator|.
name|value
argument_list|<
name|QFont
argument_list|>
argument_list|()
decl_stmt|;
name|QFontMetrics
name|metrics
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|aHeight
operator|=
name|metrics
operator|.
name|height
argument_list|()
expr_stmt|;
name|aAscent
operator|=
name|metrics
operator|.
name|ascent
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DoCommitFepInlineEditL
name|void
name|QCoeFepInputContext
operator|::
name|DoCommitFepInlineEditL
parameter_list|()
block|{
name|commitCurrentString
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|>
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
name|ReportAknEdStateEvent
argument_list|(
name|QT_EAknCursorPositionChanged
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commitCurrentString
name|void
name|QCoeFepInputContext
operator|::
name|commitCurrentString
parameter_list|(
name|bool
name|cancelFepTransaction
parameter_list|)
block|{
name|QList
argument_list|<
name|QInputMethodEvent
operator|::
name|Attribute
argument_list|>
name|attributes
decl_stmt|;
name|QInputMethodEvent
name|event
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
name|attributes
argument_list|)
decl_stmt|;
name|event
operator|.
name|setCommitString
argument_list|(
name|m_preeditString
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_preeditString
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_inlinePosition
operator|=
literal|0
expr_stmt|;
name|sendEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|m_hasTempPreeditString
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|cancelFepTransaction
condition|)
block|{
name|CCoeFep
modifier|*
name|fep
init|=
name|CCoeEnv
operator|::
name|Static
argument_list|()
operator|->
name|Fep
argument_list|()
decl_stmt|;
if|if
condition|(
name|fep
condition|)
name|fep
operator|->
name|CancelTransaction
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Extension1
name|MCoeFepAwareTextEditor_Extension1
modifier|*
name|QCoeFepInputContext
operator|::
name|Extension1
parameter_list|(
name|TBool
modifier|&
name|aSetToTrue
parameter_list|)
block|{
name|aSetToTrue
operator|=
name|ETrue
expr_stmt|;
return|return
name|this
return|;
block|}
end_function
begin_function
DECL|function|SetStateTransferingOwnershipL
name|void
name|QCoeFepInputContext
operator|::
name|SetStateTransferingOwnershipL
parameter_list|(
name|MCoeFepAwareTextEditor_Extension1
operator|::
name|CState
modifier|*
name|aState
parameter_list|,
name|TUid
comment|/*aTypeSafetyUid*/
parameter_list|)
block|{
comment|// Note: The S60 docs are wrong! See the State() function.
if|if
condition|(
name|m_fepState
condition|)
operator|delete
name|m_fepState
expr_stmt|;
name|m_fepState
operator|=
cast|static_cast
argument_list|<
name|CAknEdwinState
operator|*
argument_list|>
argument_list|(
name|aState
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|State
name|MCoeFepAwareTextEditor_Extension1
operator|::
name|CState
modifier|*
name|QCoeFepInputContext
operator|::
name|State
parameter_list|(
name|TUid
comment|/*aTypeSafetyUid*/
parameter_list|)
block|{
comment|// Note: The S60 docs are horribly wrong when describing the
comment|// SetStateTransferingOwnershipL function and this function. They say that the former
comment|// sets a CState object identified by the TUid, and the latter retrieves it.
comment|// In reality, the CState is expected to always be a CAknEdwinState (even if it was not
comment|// previously set), and the TUid is ignored. All in all, there is a single CAknEdwinState
comment|// per QCoeFepInputContext, which should be deleted if the SetStateTransferingOwnershipL
comment|// function is used to set a new one.
return|return
name|m_fepState
return|;
block|}
end_function
begin_function
DECL|function|MopSupplyObject
name|TTypeUid
operator|::
name|Ptr
name|QCoeFepInputContext
operator|::
name|MopSupplyObject
parameter_list|(
name|TTypeUid
comment|/*id*/
parameter_list|)
block|{
return|return
name|TTypeUid
operator|::
name|Null
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|MopNext
name|MObjectProvider
modifier|*
name|QCoeFepInputContext
operator|::
name|MopNext
parameter_list|()
block|{
name|QWidget
modifier|*
name|w
init|=
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
return|return
name|w
operator|->
name|effectiveWinId
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IM
end_comment
end_unit
