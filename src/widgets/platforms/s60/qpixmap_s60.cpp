begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<exception>
end_include
begin_include
include|#
directive|include
file|<w32std.h>
end_include
begin_include
include|#
directive|include
file|<fbs.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicssystem_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_s60_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_s60_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap_raster_p.h"
end_include
begin_include
include|#
directive|include
file|<qwidget.h>
end_include
begin_include
include|#
directive|include
file|"qpixmap_s60_p.h"
end_include
begin_include
include|#
directive|include
file|"qnativeimage_p.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qimage_p.h"
end_include
begin_include
include|#
directive|include
file|<fbs.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_pixmap_bit_mask
specifier|const
name|uchar
name|qt_pixmap_bit_mask
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cleanup_function_registered
specifier|static
name|bool
name|cleanup_function_registered
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|firstPixmap
specifier|static
name|QS60PixmapData
modifier|*
name|firstPixmap
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// static
end_comment
begin_function
DECL|function|qt_symbian_register_pixmap
name|void
name|QS60PixmapData
operator|::
name|qt_symbian_register_pixmap
parameter_list|(
name|QS60PixmapData
modifier|*
name|pd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cleanup_function_registered
condition|)
block|{
name|qAddPostRoutine
argument_list|(
name|qt_symbian_release_pixmaps
argument_list|)
expr_stmt|;
name|cleanup_function_registered
operator|=
literal|true
expr_stmt|;
block|}
name|pd
operator|->
name|next
operator|=
name|firstPixmap
expr_stmt|;
name|pd
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firstPixmap
condition|)
name|firstPixmap
operator|->
name|prev
operator|=
name|pd
expr_stmt|;
name|firstPixmap
operator|=
name|pd
expr_stmt|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|qt_symbian_unregister_pixmap
name|void
name|QS60PixmapData
operator|::
name|qt_symbian_unregister_pixmap
parameter_list|(
name|QS60PixmapData
modifier|*
name|pd
parameter_list|)
block|{
if|if
condition|(
name|pd
operator|->
name|next
condition|)
name|pd
operator|->
name|next
operator|->
name|prev
operator|=
name|pd
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|prev
condition|)
name|pd
operator|->
name|prev
operator|->
name|next
operator|=
name|pd
operator|->
name|next
expr_stmt|;
else|else
name|firstPixmap
operator|=
name|pd
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_comment
comment|// static
end_comment
begin_function
DECL|function|qt_symbian_release_pixmaps
name|void
name|QS60PixmapData
operator|::
name|qt_symbian_release_pixmaps
parameter_list|()
block|{
comment|// Scan all QS60PixmapData objects in the system and destroy them.
name|QS60PixmapData
modifier|*
name|pd
init|=
name|firstPixmap
decl_stmt|;
while|while
condition|(
name|pd
operator|!=
literal|0
condition|)
block|{
name|pd
operator|->
name|release
argument_list|()
expr_stmt|;
name|pd
operator|=
name|pd
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     \class QSymbianFbsClient     \since 4.6     \internal      Symbian Font And Bitmap server client that is     used to lock the global bitmap heap. Only used in     S60 v3.1 and S60 v3.2. */
end_comment
begin_expr_stmt
name|_LIT
argument_list|(
name|KFBSERVLargeBitmapAccessName
argument_list|,
literal|"FbsLargeBitmapAccess"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_class
DECL|class|QSymbianFbsClient
class|class
name|QSymbianFbsClient
block|{
public|public:
DECL|function|QSymbianFbsClient
name|QSymbianFbsClient
parameter_list|()
member_init_list|:
name|heapLocked
argument_list|(
literal|false
argument_list|)
block|{
name|heapLock
operator|.
name|OpenGlobal
argument_list|(
name|KFBSERVLargeBitmapAccessName
argument_list|)
expr_stmt|;
block|}
DECL|function|~QSymbianFbsClient
name|~
name|QSymbianFbsClient
parameter_list|()
block|{
name|heapLock
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
DECL|function|lockHeap
name|bool
name|lockHeap
parameter_list|()
block|{
name|bool
name|wasLocked
init|=
name|heapLocked
decl_stmt|;
if|if
condition|(
name|heapLock
operator|.
name|Handle
argument_list|()
operator|&&
operator|!
name|heapLocked
condition|)
block|{
name|heapLock
operator|.
name|Wait
argument_list|()
expr_stmt|;
name|heapLocked
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|wasLocked
return|;
block|}
DECL|function|unlockHeap
name|bool
name|unlockHeap
parameter_list|()
block|{
name|bool
name|wasLocked
init|=
name|heapLocked
decl_stmt|;
if|if
condition|(
name|heapLock
operator|.
name|Handle
argument_list|()
operator|&&
name|heapLocked
condition|)
block|{
name|heapLock
operator|.
name|Signal
argument_list|()
expr_stmt|;
name|heapLocked
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|wasLocked
return|;
block|}
private|private:
DECL|member|heapLock
name|RMutex
name|heapLock
decl_stmt|;
DECL|member|heapLocked
name|bool
name|heapLocked
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QSymbianFbsClient
argument_list|,
name|qt_symbianFbsClient
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// QSymbianFbsHeapLock
end_comment
begin_constructor
DECL|function|QSymbianFbsHeapLock
name|QSymbianFbsHeapLock
operator|::
name|QSymbianFbsHeapLock
parameter_list|(
name|LockAction
name|a
parameter_list|)
member_init_list|:
name|action
argument_list|(
name|a
argument_list|)
member_init_list|,
name|wasLocked
argument_list|(
literal|false
argument_list|)
block|{
name|QSysInfo
operator|::
name|SymbianVersion
name|symbianVersion
init|=
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_2
operator|||
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_3
condition|)
name|wasLocked
operator|=
name|qt_symbianFbsClient
argument_list|()
operator|->
name|unlockHeap
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSymbianFbsHeapLock
name|QSymbianFbsHeapLock
operator|::
name|~
name|QSymbianFbsHeapLock
parameter_list|()
block|{
comment|// Do nothing
block|}
end_destructor
begin_function
DECL|function|relock
name|void
name|QSymbianFbsHeapLock
operator|::
name|relock
parameter_list|()
block|{
name|QSysInfo
operator|::
name|SymbianVersion
name|symbianVersion
init|=
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasLocked
operator|&&
operator|(
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_2
operator|||
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_3
operator|)
condition|)
name|qt_symbianFbsClient
argument_list|()
operator|->
name|lockHeap
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     \class QSymbianBitmapDataAccess     \since 4.6     \internal      Data access class that is used to locks/unlocks pixel data     when drawing or modifying CFbsBitmap pixel data. */
end_comment
begin_class
DECL|class|QSymbianBitmapDataAccess
class|class
name|QSymbianBitmapDataAccess
block|{
public|public:
DECL|member|heapRefCount
specifier|static
name|int
name|heapRefCount
decl_stmt|;
DECL|member|symbianVersion
name|QSysInfo
operator|::
name|SymbianVersion
name|symbianVersion
decl_stmt|;
DECL|function|QSymbianBitmapDataAccess
specifier|explicit
name|QSymbianBitmapDataAccess
parameter_list|()
block|{
name|symbianVersion
operator|=
name|QSysInfo
operator|::
name|symbianVersion
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
DECL|function|~QSymbianBitmapDataAccess
name|~
name|QSymbianBitmapDataAccess
parameter_list|()
block|{}
empty_stmt|;
DECL|function|beginDataAccess
specifier|inline
name|void
name|beginDataAccess
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|)
block|{
if|if
condition|(
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_2
condition|)
block|{
if|if
condition|(
name|heapRefCount
operator|==
literal|0
condition|)
name|qt_symbianFbsClient
argument_list|()
operator|->
name|lockHeap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bitmap
operator|->
name|LockHeap
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
block|}
name|heapRefCount
operator|++
expr_stmt|;
block|}
DECL|function|endDataAccess
specifier|inline
name|void
name|endDataAccess
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|)
block|{
name|heapRefCount
operator|--
expr_stmt|;
if|if
condition|(
name|symbianVersion
operator|==
name|QSysInfo
operator|::
name|SV_9_2
condition|)
block|{
if|if
condition|(
name|heapRefCount
operator|==
literal|0
condition|)
name|qt_symbianFbsClient
argument_list|()
operator|->
name|unlockHeap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bitmap
operator|->
name|UnlockHeap
argument_list|(
name|ETrue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|;
end_class
begin_decl_stmt
DECL|member|heapRefCount
name|int
name|QSymbianBitmapDataAccess
operator|::
name|heapRefCount
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|UPDATE_BUFFER
define|#
directive|define
name|UPDATE_BUFFER
parameter_list|()
define|\
value|{                       \     beginDataAccess();      \     endDataAccess();        \ }
end_define
begin_function
DECL|function|createSymbianCFbsBitmap
specifier|static
name|CFbsBitmap
modifier|*
name|createSymbianCFbsBitmap
parameter_list|(
specifier|const
name|TSize
modifier|&
name|size
parameter_list|,
name|TDisplayMode
name|mode
parameter_list|)
block|{
name|QSymbianFbsHeapLock
name|lock
argument_list|(
name|QSymbianFbsHeapLock
operator|::
name|Unlock
argument_list|)
decl_stmt|;
name|CFbsBitmap
modifier|*
name|bitmap
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|bitmap
operator|=
operator|new
operator|(
name|ELeave
operator|)
name|CFbsBitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
operator|->
name|Create
argument_list|(
name|size
argument_list|,
name|mode
argument_list|)
operator|!=
name|KErrNone
condition|)
block|{
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
block|}
name|lock
operator|.
name|relock
argument_list|()
expr_stmt|;
return|return
name|bitmap
return|;
block|}
end_function
begin_function
DECL|function|uncompress
specifier|static
name|CFbsBitmap
modifier|*
name|uncompress
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|)
block|{
if|if
condition|(
name|bitmap
operator|->
name|IsCompressedInRAM
argument_list|()
condition|)
block|{
name|QSymbianFbsHeapLock
name|lock
argument_list|(
name|QSymbianFbsHeapLock
operator|::
name|Unlock
argument_list|)
decl_stmt|;
name|CFbsBitmap
modifier|*
name|uncompressed
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|uncompressed
operator|=
operator|new
operator|(
name|ELeave
operator|)
name|CFbsBitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|uncompressed
operator|->
name|Create
argument_list|(
name|bitmap
operator|->
name|SizeInPixels
argument_list|()
argument_list|,
name|bitmap
operator|->
name|DisplayMode
argument_list|()
argument_list|)
operator|!=
name|KErrNone
condition|)
block|{
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
name|lock
operator|.
name|relock
argument_list|()
expr_stmt|;
return|return
name|bitmap
return|;
block|}
name|lock
operator|.
name|relock
argument_list|()
expr_stmt|;
name|CFbsBitmapDevice
modifier|*
name|bitmapDevice
init|=
literal|0
decl_stmt|;
name|CFbsBitGc
modifier|*
name|bitmapGc
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|bitmapDevice
operator|=
name|CFbsBitmapDevice
operator|::
name|NewL
argument_list|(
name|uncompressed
argument_list|)
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|bitmapGc
operator|=
name|CFbsBitGc
operator|::
name|NewL
argument_list|()
argument_list|)
expr_stmt|;
name|bitmapGc
operator|->
name|Activate
argument_list|(
name|bitmapDevice
argument_list|)
expr_stmt|;
name|bitmapGc
operator|->
name|BitBlt
argument_list|(
name|TPoint
argument_list|()
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
operator|delete
name|bitmapGc
expr_stmt|;
operator|delete
name|bitmapDevice
expr_stmt|;
return|return
name|uncompressed
return|;
block|}
else|else
block|{
return|return
name|bitmap
return|;
block|}
block|}
end_function
begin_function
DECL|function|grabWindow
name|QPixmap
name|QPixmap
operator|::
name|grabWindow
parameter_list|(
name|WId
name|winId
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|CWsScreenDevice
modifier|*
name|screenDevice
init|=
name|S60
operator|->
name|screenDevice
argument_list|()
decl_stmt|;
name|TSize
name|screenSize
init|=
name|screenDevice
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|TSize
name|srcSize
decl_stmt|;
comment|// Find out if this is one of our windows.
name|QSymbianControl
modifier|*
name|sControl
decl_stmt|;
name|sControl
operator|=
name|winId
operator|->
name|MopGetObject
argument_list|(
name|sControl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sControl
operator|&&
name|sControl
operator|->
name|widget
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
block|{
comment|// Grabbing desktop widget
name|srcSize
operator|=
name|screenSize
expr_stmt|;
block|}
else|else
block|{
name|TPoint
name|relativePos
init|=
name|winId
operator|->
name|PositionRelativeToScreen
argument_list|()
decl_stmt|;
name|x
operator|+=
name|relativePos
operator|.
name|iX
expr_stmt|;
name|y
operator|+=
name|relativePos
operator|.
name|iY
expr_stmt|;
name|srcSize
operator|=
name|winId
operator|->
name|Size
argument_list|()
expr_stmt|;
block|}
name|TRect
name|srcRect
argument_list|(
name|TPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
comment|// Clip to the screen
name|srcRect
operator|.
name|Intersection
argument_list|(
name|TRect
argument_list|(
name|screenSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
condition|)
block|{
name|TRect
name|subRect
argument_list|(
name|TPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|TSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
decl_stmt|;
comment|// Clip to the subRect
name|srcRect
operator|.
name|Intersection
argument_list|(
name|subRect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcRect
operator|.
name|IsEmpty
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|CFbsBitmap
modifier|*
name|temporary
init|=
name|createSymbianCFbsBitmap
argument_list|(
name|srcRect
operator|.
name|Size
argument_list|()
argument_list|,
name|screenDevice
operator|->
name|DisplayMode
argument_list|()
argument_list|)
decl_stmt|;
name|QPixmap
name|pix
decl_stmt|;
if|if
condition|(
name|temporary
operator|&&
name|screenDevice
operator|->
name|CopyScreenToBitmap
argument_list|(
name|temporary
argument_list|,
name|srcRect
argument_list|)
operator|==
name|KErrNone
condition|)
block|{
name|pix
operator|=
name|QPixmap
operator|::
name|fromSymbianCFbsBitmap
argument_list|(
name|temporary
argument_list|)
expr_stmt|;
block|}
operator|delete
name|temporary
expr_stmt|;
return|return
name|pix
return|;
block|}
end_function
begin_comment
comment|/*!     \fn CFbsBitmap *QPixmap::toSymbianCFbsBitmap() const     \since 4.6      Creates a \c CFbsBitmap that is equivalent to the QPixmap. Internally this     function will try to duplicate the handle instead of copying the data,     however in scenarios where this is not possible the data will be copied.     If the creation fails or the pixmap is null, then this function returns 0.      It is the caller's responsibility to release the \c CFbsBitmap data     after use either by deleting the bitmap or calling \c Reset().      \warning On S60 3.1 and S60 3.2, semi-transparent pixmaps are always copied              and not duplicated.     \warning This function is only available on Symbian OS.      \sa fromSymbianCFbsBitmap() */
end_comment
begin_function
DECL|function|toSymbianCFbsBitmap
name|CFbsBitmap
modifier|*
name|QPixmap
operator|::
name|toSymbianCFbsBitmap
parameter_list|()
specifier|const
block|{
name|QPixmapData
modifier|*
name|data
init|=
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
name|data
operator|->
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
cast|reinterpret_cast
argument_list|<
name|CFbsBitmap
operator|*
argument_list|>
argument_list|(
name|data
operator|->
name|toNativeType
argument_list|(
name|QPixmapData
operator|::
name|FbsBitmap
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::fromSymbianCFbsBitmap(CFbsBitmap *bitmap)     \since 4.6      Creates a QPixmap from a \c CFbsBitmap \a bitmap. Internally this function     will try to duplicate the bitmap handle instead of copying the data, however     in scenarios where this is not possible the data will be copied.     To be sure that QPixmap does not modify your original instance, you should     make a copy of your \c CFbsBitmap before calling this function.     If the CFbsBitmap is not valid this function will return a null QPixmap.     For performance reasons it is recommended to use a \a bitmap with a display     mode of EColor16MAP or EColor16MU whenever possible.      \warning This function is only available on Symbian OS.      \sa toSymbianCFbsBitmap(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromSymbianCFbsBitmap
name|QPixmap
name|QPixmap
operator|::
name|fromSymbianCFbsBitmap
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bitmap
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QScopedPointer
argument_list|<
name|QPixmapData
argument_list|>
name|data
argument_list|(
name|QPixmapData
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromNativeType
argument_list|(
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|bitmap
argument_list|)
argument_list|,
name|QPixmapData
operator|::
name|FbsBitmap
argument_list|)
expr_stmt|;
name|QPixmap
name|pixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_constructor
DECL|function|QS60PixmapData
name|QS60PixmapData
operator|::
name|QS60PixmapData
parameter_list|(
name|PixelType
name|type
parameter_list|)
member_init_list|:
name|QRasterPixmapData
argument_list|(
name|type
argument_list|)
member_init_list|,
name|symbianBitmapDataAccess
argument_list|(
operator|new
name|QSymbianBitmapDataAccess
argument_list|)
member_init_list|,
name|cfbsBitmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytes
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|formatLocked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|prev
argument_list|(
literal|0
argument_list|)
block|{
name|qt_symbian_register_pixmap
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QS60PixmapData
name|QS60PixmapData
operator|::
name|~
name|QS60PixmapData
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
operator|delete
name|symbianBitmapDataAccess
expr_stmt|;
name|qt_symbian_unregister_pixmap
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|resize
name|void
name|QS60PixmapData
operator|::
name|resize
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
name|w
operator|=
name|width
expr_stmt|;
name|h
operator|=
name|height
expr_stmt|;
name|is_null
operator|=
literal|true
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|cfbsBitmap
condition|)
block|{
name|TDisplayMode
name|mode
decl_stmt|;
if|if
condition|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|)
name|mode
operator|=
name|EGray2
expr_stmt|;
else|else
name|mode
operator|=
name|EColor16MU
expr_stmt|;
name|CFbsBitmap
modifier|*
name|bitmap
init|=
name|createSymbianCFbsBitmap
argument_list|(
name|TSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|fromSymbianBitmap
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TSize
name|newSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
operator|!=
name|newSize
condition|)
block|{
name|cfbsBitmap
operator|->
name|Resize
argument_list|(
name|TSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pengine
condition|)
block|{
operator|delete
name|pengine
expr_stmt|;
name|pengine
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|UPDATE_BUFFER
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|release
name|void
name|QS60PixmapData
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
name|cfbsBitmap
condition|)
block|{
name|QSymbianFbsHeapLock
name|lock
argument_list|(
name|QSymbianFbsHeapLock
operator|::
name|Unlock
argument_list|)
decl_stmt|;
operator|delete
name|cfbsBitmap
expr_stmt|;
name|lock
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
operator|delete
name|pengine
expr_stmt|;
name|image
operator|=
name|QImage
argument_list|()
expr_stmt|;
name|cfbsBitmap
operator|=
literal|0
expr_stmt|;
name|pengine
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  * Takes ownership of bitmap. Used by window surface  */
end_comment
begin_function
DECL|function|fromSymbianBitmap
name|void
name|QS60PixmapData
operator|::
name|fromSymbianBitmap
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|,
name|bool
name|lockFormat
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
name|cfbsBitmap
operator|=
name|bitmap
expr_stmt|;
name|formatLocked
operator|=
name|lockFormat
expr_stmt|;
name|setSerialNumber
argument_list|(
name|cfbsBitmap
operator|->
name|Handle
argument_list|()
argument_list|)
expr_stmt|;
name|UPDATE_BUFFER
argument_list|()
expr_stmt|;
comment|// Create default palette if needed
if|if
condition|(
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray2
condition|)
block|{
name|image
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
comment|//Symbian thinks set pixels are white/transparent, Qt thinks they are foreground/solid
comment|//So invert mono bitmaps so that masks work correctly.
name|image
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray256
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|image
operator|.
name|setColor
argument_list|(
name|i
argument_list|,
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EColor256
condition|)
block|{
specifier|const
name|TColor256Util
modifier|*
name|palette
init|=
name|TColor256Util
operator|::
name|Default
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|image
operator|.
name|setColor
argument_list|(
name|i
argument_list|,
call|(
name|QRgb
call|)
argument_list|(
name|palette
operator|->
name|Color256
argument_list|(
name|i
argument_list|)
operator|.
name|Value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toImage
name|QImage
name|QS60PixmapData
operator|::
name|toImage
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
name|QS60PixmapData
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QS60PixmapData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QImage
name|copy
init|=
name|that
operator|->
name|image
operator|.
name|copy
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|that
operator|->
name|endDataAccess
argument_list|()
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_function
DECL|function|fromImage
name|void
name|QS60PixmapData
operator|::
name|fromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|release
argument_list|()
expr_stmt|;
name|QImage
name|sourceImage
decl_stmt|;
if|if
condition|(
name|pixelType
argument_list|()
operator|==
name|BitmapType
condition|)
block|{
name|sourceImage
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|img
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|sourceImage
operator|=
name|img
operator|.
name|hasAlphaChannel
argument_list|()
condition|?
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
else|:
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QImage
operator|::
name|Format
name|opaqueFormat
init|=
name|QNativeImage
operator|::
name|systemFormat
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|alphaFormat
init|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
decl_stmt|;
if|if
condition|(
operator|!
name|img
operator|.
name|hasAlphaChannel
argument_list|()
operator|||
operator|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|NoOpaqueDetection
operator|)
operator|==
literal|0
operator|&&
operator|!
cast|const_cast
argument_list|<
name|QImage
operator|&
argument_list|>
argument_list|(
name|img
argument_list|)
operator|.
name|data_ptr
argument_list|()
operator|->
name|checkForAlphaPixels
argument_list|()
operator|)
condition|)
block|{
name|sourceImage
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|opaqueFormat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sourceImage
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|alphaFormat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QImage
operator|::
name|Format
name|destFormat
init|=
name|sourceImage
operator|.
name|format
argument_list|()
decl_stmt|;
name|TDisplayMode
name|mode
decl_stmt|;
switch|switch
condition|(
name|destFormat
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|mode
operator|=
name|EGray2
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|mode
operator|=
name|EColor16MU
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
if|if
condition|(
name|S60
operator|->
name|supportsPremultipliedAlpha
condition|)
block|{
name|mode
operator|=
name|Q_SYMBIAN_ECOLOR16MAP
expr_stmt|;
break|break;
block|}
else|else
block|{
name|destFormat
operator|=
name|QImage
operator|::
name|Format_ARGB32
expr_stmt|;
block|}
comment|// Fall through intended
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
name|mode
operator|=
name|EColor16MA
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Invalid
case|:
return|return;
default|default:
name|qWarning
argument_list|(
literal|"Image format not supported: %d"
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|cfbsBitmap
operator|=
name|createSymbianCFbsBitmap
argument_list|(
name|TSize
argument_list|(
name|sourceImage
operator|.
name|width
argument_list|()
argument_list|,
name|sourceImage
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfbsBitmap
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not create CFbsBitmap"
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
return|return;
block|}
name|setSerialNumber
argument_list|(
name|cfbsBitmap
operator|->
name|Handle
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
cast|const_cast
argument_list|<
specifier|const
name|QImage
operator|&
argument_list|>
argument_list|(
name|sourceImage
argument_list|)
operator|.
name|bits
argument_list|()
decl_stmt|;
name|symbianBitmapDataAccess
operator|->
name|beginDataAccess
argument_list|(
name|cfbsBitmap
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|dptr
init|=
operator|(
name|uchar
operator|*
operator|)
name|cfbsBitmap
operator|->
name|DataAddress
argument_list|()
decl_stmt|;
name|Mem
operator|::
name|Copy
argument_list|(
name|dptr
argument_list|,
name|sptr
argument_list|,
name|sourceImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
name|symbianBitmapDataAccess
operator|->
name|endDataAccess
argument_list|(
name|cfbsBitmap
argument_list|)
expr_stmt|;
name|UPDATE_BUFFER
argument_list|()
expr_stmt|;
if|if
condition|(
name|destFormat
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
name|image
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|image
operator|.
name|setColorTable
argument_list|(
name|sourceImage
operator|.
name|colorTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy
name|void
name|QS60PixmapData
operator|::
name|copy
parameter_list|(
specifier|const
name|QPixmapData
modifier|*
name|data
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|QS60PixmapData
modifier|*
name|s60Data
init|=
cast|static_cast
argument_list|<
specifier|const
name|QS60PixmapData
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|fromImage
argument_list|(
name|s60Data
operator|->
name|toImage
argument_list|(
name|rect
argument_list|)
argument_list|,
name|Qt
operator|::
name|AutoColor
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QS60PixmapData
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|beginDataAccess
argument_list|()
expr_stmt|;
name|bool
name|res
init|=
name|QRasterPixmapData
operator|::
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|rect
argument_list|)
decl_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|metric
name|int
name|QS60PixmapData
operator|::
name|metric
parameter_list|(
name|QPaintDevice
operator|::
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|cfbsBitmap
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|QPaintDevice
operator|::
name|PdmWidth
case|:
return|return
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
operator|.
name|iWidth
return|;
case|case
name|QPaintDevice
operator|::
name|PdmHeight
case|:
return|return
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
operator|.
name|iHeight
return|;
case|case
name|QPaintDevice
operator|::
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
operator|.
name|iWidth
operator|*
literal|25.4
operator|/
name|qt_defaultDpiX
argument_list|()
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
operator|.
name|iHeight
operator|*
literal|25.4
operator|/
name|qt_defaultDpiY
argument_list|()
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmNumColors
case|:
return|return
name|TDisplayModeUtils
operator|::
name|NumDisplayModeColors
argument_list|(
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
argument_list|)
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDpiX
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiX
case|:
return|return
name|qt_defaultDpiX
argument_list|()
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDpiY
case|:
case|case
name|QPaintDevice
operator|::
name|PdmPhysicalDpiY
case|:
return|return
name|qt_defaultDpiY
argument_list|()
return|;
case|case
name|QPaintDevice
operator|::
name|PdmDepth
case|:
return|return
name|TDisplayModeUtils
operator|::
name|NumDisplayModeBitsPerPixel
argument_list|(
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
argument_list|)
return|;
default|default:
name|qWarning
argument_list|(
literal|"QPixmap::metric: Invalid metric command"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fill
name|void
name|QS60PixmapData
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
name|color
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
condition|)
block|{
name|QImage
name|im
argument_list|(
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|im
operator|.
name|fill
argument_list|(
name|PREMUL
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|im
argument_list|,
name|Qt
operator|::
name|AutoColor
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QRasterPixmapData
operator|::
name|fill
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setMask
name|void
name|QS60PixmapData
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mask
operator|.
name|size
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QImage
name|newImage
init|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|newImage
argument_list|,
name|Qt
operator|::
name|AutoColor
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QRasterPixmapData
operator|::
name|setMask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|QImage
name|imageMask
init|=
name|mask
operator|.
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QImage
name|newImage
init|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|mscan
init|=
name|imageMask
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|QRgb
modifier|*
name|tscan
init|=
operator|(
name|QRgb
operator|*
operator|)
name|newImage
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mscan
index|[
name|x
operator|>>
literal|3
index|]
operator|&
name|qt_pixmap_bit_mask
index|[
name|x
operator|&
literal|7
index|]
operator|)
condition|)
name|tscan
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|newImage
argument_list|,
name|Qt
operator|::
name|AutoColor
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setAlphaChannel
name|void
name|QS60PixmapData
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|alphaChannel
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|toImage
argument_list|()
argument_list|)
decl_stmt|;
name|img
operator|.
name|setAlphaChannel
argument_list|(
name|alphaChannel
operator|.
name|toImage
argument_list|()
argument_list|)
expr_stmt|;
name|release
argument_list|()
expr_stmt|;
name|fromImage
argument_list|(
name|img
argument_list|,
name|Qt
operator|::
name|OrderedDither
operator||
name|Qt
operator|::
name|OrderedAlphaDither
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|toImage
name|QImage
name|QS60PixmapData
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
return|return
name|toImage
argument_list|(
name|QRect
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QS60PixmapData
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|pengine
condition|)
block|{
name|QS60PixmapData
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QS60PixmapData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|pengine
operator|=
operator|new
name|QS60PaintEngine
argument_list|(
operator|&
name|that
operator|->
name|image
argument_list|,
name|that
argument_list|)
expr_stmt|;
block|}
return|return
name|pengine
return|;
block|}
end_function
begin_function
DECL|function|beginDataAccess
name|void
name|QS60PixmapData
operator|::
name|beginDataAccess
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cfbsBitmap
condition|)
return|return;
name|symbianBitmapDataAccess
operator|->
name|beginDataAccess
argument_list|(
name|cfbsBitmap
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|newBytes
init|=
operator|(
name|uchar
operator|*
operator|)
name|cfbsBitmap
operator|->
name|DataAddress
argument_list|()
decl_stmt|;
name|TSize
name|size
init|=
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
if|if
condition|(
name|newBytes
operator|==
name|bytes
operator|&&
name|image
operator|.
name|width
argument_list|()
operator|==
name|size
operator|.
name|iWidth
operator|&&
name|image
operator|.
name|height
argument_list|()
operator|==
name|size
operator|.
name|iHeight
condition|)
return|return;
name|bytes
operator|=
name|newBytes
expr_stmt|;
name|TDisplayMode
name|mode
init|=
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|qt_TDisplayMode2Format
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|// On S60 3.1, premultiplied alpha pixels are stored in a bitmap with 16MA type.
comment|// S60 window surface needs backing store pixmap for transparent window in ARGB32 format.
comment|// In that case formatLocked is true.
if|if
condition|(
operator|!
name|formatLocked
operator|&&
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
comment|// pixel data is actually in premultiplied format
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|savedColorTable
decl_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
name|savedColorTable
operator|=
name|image
operator|.
name|colorTable
argument_list|()
expr_stmt|;
name|image
operator|=
name|QImage
argument_list|(
name|bytes
argument_list|,
name|size
operator|.
name|iWidth
argument_list|,
name|size
operator|.
name|iHeight
argument_list|,
name|format
argument_list|)
expr_stmt|;
comment|// Restore the palette or create a default
if|if
condition|(
operator|!
name|savedColorTable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|image
operator|.
name|setColorTable
argument_list|(
name|savedColorTable
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
name|size
operator|.
name|iWidth
expr_stmt|;
name|h
operator|=
name|size
operator|.
name|iHeight
expr_stmt|;
name|d
operator|=
name|image
operator|.
name|depth
argument_list|()
expr_stmt|;
name|is_null
operator|=
operator|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pengine
condition|)
block|{
name|QS60PaintEngine
modifier|*
name|engine
init|=
cast|static_cast
argument_list|<
name|QS60PaintEngine
operator|*
argument_list|>
argument_list|(
name|pengine
argument_list|)
decl_stmt|;
name|engine
operator|->
name|prepare
argument_list|(
operator|&
name|image
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|endDataAccess
name|void
name|QS60PixmapData
operator|::
name|endDataAccess
parameter_list|(
name|bool
name|readOnly
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|readOnly
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfbsBitmap
condition|)
return|return;
name|symbianBitmapDataAccess
operator|->
name|endDataAccess
argument_list|(
name|cfbsBitmap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Returns a QPixmap that wraps given \a sgImage graphics resource.   The data should be valid even when original RSgImage handle has been   closed.    \warning This function is only available on Symbian OS.    \sa toSymbianRSgImage(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromSymbianRSgImage
name|QPixmap
name|QPixmap
operator|::
name|fromSymbianRSgImage
parameter_list|(
name|RSgImage
modifier|*
name|sgImage
parameter_list|)
block|{
comment|// It is expected that RSgImage will
comment|// CURRENTLY be used in conjuction with
comment|// OpenVG graphics system
comment|//
comment|// Surely things might change in future
if|if
condition|(
operator|!
name|sgImage
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QScopedPointer
argument_list|<
name|QPixmapData
argument_list|>
name|data
argument_list|(
name|QPixmapData
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromNativeType
argument_list|(
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|sgImage
argument_list|)
argument_list|,
name|QPixmapData
operator|::
name|SgImage
argument_list|)
expr_stmt|;
name|QPixmap
name|pixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.6  Returns a \c RSgImage that is equivalent to the QPixmap by copying the data.  It is the caller's responsibility to close/delete the \c RSgImage after use.  \warning This function is only available on Symbian OS.  \sa fromSymbianRSgImage() */
end_comment
begin_function
DECL|function|toSymbianRSgImage
name|RSgImage
modifier|*
name|QPixmap
operator|::
name|toSymbianRSgImage
parameter_list|()
specifier|const
block|{
comment|// It is expected that RSgImage will
comment|// CURRENTLY be used in conjuction with
comment|// OpenVG graphics system
comment|//
comment|// Surely things might change in future
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|RSgImage
modifier|*
name|sgImage
init|=
cast|reinterpret_cast
argument_list|<
name|RSgImage
operator|*
argument_list|>
argument_list|(
name|pixmapData
argument_list|()
operator|->
name|toNativeType
argument_list|(
name|QPixmapData
operator|::
name|SgImage
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|sgImage
return|;
block|}
end_function
begin_function
DECL|function|toNativeType
name|void
modifier|*
name|QS60PixmapData
operator|::
name|toNativeType
parameter_list|(
name|NativeType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|QPixmapData
operator|::
name|SgImage
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QPixmapData
operator|::
name|FbsBitmap
condition|)
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|!
name|cfbsBitmap
condition|)
return|return
literal|0
return|;
name|bool
name|convertToArgb32
init|=
literal|false
decl_stmt|;
name|bool
name|needsCopy
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|S60
operator|->
name|supportsPremultipliedAlpha
operator|)
condition|)
block|{
comment|// Convert argb32_premultiplied to argb32 since Symbian 9.2 does
comment|// not support premultipied format.
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
block|{
name|needsCopy
operator|=
literal|true
expr_stmt|;
name|convertToArgb32
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|CFbsBitmap
modifier|*
name|bitmap
init|=
literal|0
decl_stmt|;
name|TDisplayMode
name|displayMode
init|=
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|displayMode
operator|==
name|EGray2
condition|)
block|{
comment|//Symbian thinks set pixels are white/transparent, Qt thinks they are foreground/solid
comment|//So invert mono bitmaps so that masks work correctly.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|image
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
name|needsCopy
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|needsCopy
condition|)
block|{
name|QImage
name|source
decl_stmt|;
if|if
condition|(
name|convertToArgb32
condition|)
block|{
name|beginDataAccess
argument_list|()
expr_stmt|;
name|source
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
name|displayMode
operator|=
name|EColor16MA
expr_stmt|;
block|}
else|else
block|{
name|source
operator|=
name|image
expr_stmt|;
block|}
name|CFbsBitmap
modifier|*
name|newBitmap
init|=
name|createSymbianCFbsBitmap
argument_list|(
name|TSize
argument_list|(
name|source
operator|.
name|width
argument_list|()
argument_list|,
name|source
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|displayMode
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
name|source
operator|.
name|bits
argument_list|()
decl_stmt|;
name|symbianBitmapDataAccess
operator|->
name|beginDataAccess
argument_list|(
name|newBitmap
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|dptr
init|=
operator|(
name|uchar
operator|*
operator|)
name|newBitmap
operator|->
name|DataAddress
argument_list|()
decl_stmt|;
name|Mem
operator|::
name|Copy
argument_list|(
name|dptr
argument_list|,
name|sptr
argument_list|,
name|source
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
name|symbianBitmapDataAccess
operator|->
name|endDataAccess
argument_list|(
name|newBitmap
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|newBitmap
expr_stmt|;
block|}
else|else
block|{
name|QT_TRAP_THROWING
argument_list|(
name|bitmap
operator|=
operator|new
operator|(
name|ELeave
operator|)
name|CFbsBitmap
argument_list|)
expr_stmt|;
name|TInt
name|err
init|=
name|bitmap
operator|->
name|Duplicate
argument_list|(
name|cfbsBitmap
operator|->
name|Handle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not duplicate CFbsBitmap"
argument_list|)
expr_stmt|;
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|displayMode
operator|==
name|EGray2
condition|)
block|{
comment|// restore pixels
name|beginDataAccess
argument_list|()
expr_stmt|;
name|image
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
block|}
return|return
cast|reinterpret_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|bitmap
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fromNativeType
name|void
name|QS60PixmapData
operator|::
name|fromNativeType
parameter_list|(
name|void
modifier|*
name|pixmap
parameter_list|,
name|NativeType
name|nativeType
parameter_list|)
block|{
if|if
condition|(
name|nativeType
operator|==
name|QPixmapData
operator|::
name|SgImage
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|nativeType
operator|==
name|QPixmapData
operator|::
name|FbsBitmap
operator|&&
name|pixmap
condition|)
block|{
name|CFbsBitmap
modifier|*
name|bitmap
init|=
cast|reinterpret_cast
argument_list|<
name|CFbsBitmap
operator|*
argument_list|>
argument_list|(
name|pixmap
argument_list|)
decl_stmt|;
name|bool
name|deleteSourceBitmap
init|=
literal|false
decl_stmt|;
name|bool
name|needsCopy
init|=
literal|false
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_HAS_EXTENDED_BITMAP_TYPE
comment|// Rasterize extended bitmaps
name|TUid
name|extendedBitmapType
init|=
name|bitmap
operator|->
name|ExtendedBitmapType
argument_list|()
decl_stmt|;
if|if
condition|(
name|extendedBitmapType
operator|!=
name|KNullUid
condition|)
block|{
name|CFbsBitmap
modifier|*
name|rasterBitmap
init|=
name|createSymbianCFbsBitmap
argument_list|(
name|bitmap
operator|->
name|SizeInPixels
argument_list|()
argument_list|,
name|EColor16MA
argument_list|)
decl_stmt|;
name|CFbsBitmapDevice
modifier|*
name|rasterBitmapDev
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|rasterBitmapDev
operator|=
name|CFbsBitmapDevice
operator|::
name|NewL
argument_list|(
name|rasterBitmap
argument_list|)
argument_list|)
expr_stmt|;
name|CFbsBitGc
modifier|*
name|rasterBitmapGc
init|=
literal|0
decl_stmt|;
name|TInt
name|err
init|=
name|rasterBitmapDev
operator|->
name|CreateContext
argument_list|(
name|rasterBitmapGc
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
operator|delete
name|rasterBitmap
expr_stmt|;
operator|delete
name|rasterBitmapDev
expr_stmt|;
name|rasterBitmapDev
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|rasterBitmapGc
operator|->
name|BitBlt
argument_list|(
name|TPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|rasterBitmap
expr_stmt|;
operator|delete
name|rasterBitmapDev
expr_stmt|;
operator|delete
name|rasterBitmapGc
expr_stmt|;
name|rasterBitmapDev
operator|=
literal|0
expr_stmt|;
name|rasterBitmapGc
operator|=
literal|0
expr_stmt|;
name|deleteSourceBitmap
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
name|deleteSourceBitmap
operator|=
name|bitmap
operator|->
name|IsCompressedInRAM
argument_list|()
expr_stmt|;
name|CFbsBitmap
modifier|*
name|sourceBitmap
init|=
name|uncompress
argument_list|(
name|bitmap
argument_list|)
decl_stmt|;
name|TDisplayMode
name|displayMode
init|=
name|sourceBitmap
operator|->
name|DisplayMode
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|qt_TDisplayMode2Format
argument_list|(
name|displayMode
argument_list|)
decl_stmt|;
name|QImage
operator|::
name|Format
name|opaqueFormat
init|=
name|QNativeImage
operator|::
name|systemFormat
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|alphaFormat
init|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|opaqueFormat
operator|&&
name|format
operator|!=
name|alphaFormat
operator|&&
name|format
operator|!=
name|QImage
operator|::
name|Format_MonoLSB
condition|)
name|needsCopy
operator|=
literal|true
expr_stmt|;
name|type
operator|=
operator|(
name|format
operator|!=
name|QImage
operator|::
name|Format_MonoLSB
operator|)
condition|?
name|QPixmapData
operator|::
name|PixmapType
else|:
name|QPixmapData
operator|::
name|BitmapType
expr_stmt|;
if|if
condition|(
name|needsCopy
condition|)
block|{
name|TSize
name|size
init|=
name|sourceBitmap
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|int
name|bytesPerLine
init|=
name|sourceBitmap
operator|->
name|ScanLineLength
argument_list|(
name|size
operator|.
name|iWidth
argument_list|,
name|displayMode
argument_list|)
decl_stmt|;
name|QSymbianBitmapDataAccess
name|da
decl_stmt|;
name|da
operator|.
name|beginDataAccess
argument_list|(
name|sourceBitmap
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|bytes
init|=
operator|(
name|uchar
operator|*
operator|)
name|sourceBitmap
operator|->
name|DataAddress
argument_list|()
decl_stmt|;
name|QImage
name|img
init|=
name|QImage
argument_list|(
name|bytes
argument_list|,
name|size
operator|.
name|iWidth
argument_list|,
name|size
operator|.
name|iHeight
argument_list|,
name|bytesPerLine
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|img
operator|=
name|img
operator|.
name|copy
argument_list|()
expr_stmt|;
name|da
operator|.
name|endDataAccess
argument_list|(
name|sourceBitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|displayMode
operator|==
name|EGray2
condition|)
block|{
comment|//Symbian thinks set pixels are white/transparent, Qt thinks they are foreground/solid
comment|//So invert mono bitmaps so that masks work correctly.
name|img
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|displayMode
operator|==
name|EColor16M
condition|)
block|{
name|img
operator|=
name|img
operator|.
name|rgbSwapped
argument_list|()
expr_stmt|;
comment|// EColor16M is BGR
block|}
name|fromImage
argument_list|(
name|img
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleteSourceBitmap
condition|)
operator|delete
name|sourceBitmap
expr_stmt|;
block|}
else|else
block|{
name|CFbsBitmap
modifier|*
name|duplicate
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|duplicate
operator|=
operator|new
operator|(
name|ELeave
operator|)
name|CFbsBitmap
argument_list|)
expr_stmt|;
name|TInt
name|err
init|=
name|duplicate
operator|->
name|Duplicate
argument_list|(
name|sourceBitmap
operator|->
name|Handle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not duplicate CFbsBitmap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleteSourceBitmap
condition|)
operator|delete
name|sourceBitmap
expr_stmt|;
operator|delete
name|duplicate
expr_stmt|;
return|return;
block|}
name|fromSymbianBitmap
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleteSourceBitmap
condition|)
operator|delete
name|sourceBitmap
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|convertToDisplayMode
name|void
name|QS60PixmapData
operator|::
name|convertToDisplayMode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|const
name|TDisplayMode
name|displayMode
init|=
cast|static_cast
argument_list|<
name|TDisplayMode
argument_list|>
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cfbsBitmap
operator|||
name|cfbsBitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|displayMode
condition|)
return|return;
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|!=
name|TDisplayModeUtils
operator|::
name|NumDisplayModeBitsPerPixel
argument_list|(
name|displayMode
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Cannot convert display mode due to depth mismatch"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|TSize
name|size
init|=
name|cfbsBitmap
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|QScopedPointer
argument_list|<
name|CFbsBitmap
argument_list|>
name|newBitmap
argument_list|(
name|createSymbianCFbsBitmap
argument_list|(
name|size
argument_list|,
name|displayMode
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
cast|const_cast
argument_list|<
specifier|const
name|QImage
operator|&
argument_list|>
argument_list|(
name|image
argument_list|)
operator|.
name|bits
argument_list|()
decl_stmt|;
name|symbianBitmapDataAccess
operator|->
name|beginDataAccess
argument_list|(
name|newBitmap
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|dptr
init|=
operator|(
name|uchar
operator|*
operator|)
name|newBitmap
operator|->
name|DataAddress
argument_list|()
decl_stmt|;
name|Mem
operator|::
name|Copy
argument_list|(
name|dptr
argument_list|,
name|sptr
argument_list|,
name|image
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
name|symbianBitmapDataAccess
operator|->
name|endDataAccess
argument_list|(
name|newBitmap
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|QSymbianFbsHeapLock
name|lock
argument_list|(
name|QSymbianFbsHeapLock
operator|::
name|Unlock
argument_list|)
decl_stmt|;
operator|delete
name|cfbsBitmap
expr_stmt|;
name|lock
operator|.
name|relock
argument_list|()
expr_stmt|;
name|cfbsBitmap
operator|=
name|newBitmap
operator|.
name|take
argument_list|()
expr_stmt|;
name|setSerialNumber
argument_list|(
name|cfbsBitmap
operator|->
name|Handle
argument_list|()
argument_list|)
expr_stmt|;
name|UPDATE_BUFFER
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createCompatiblePixmapData
name|QPixmapData
modifier|*
name|QS60PixmapData
operator|::
name|createCompatiblePixmapData
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QS60PixmapData
argument_list|(
name|pixelType
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
