begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtWidgets/qwidget.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qlinkedlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstack.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qgraphicsanchorlayout_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// To ensure that all variables inside the simplex solver are non-negative,
comment|// we limit the size of anchors in the interval [-limit, limit]. Then before
comment|// sending them to the simplex solver we add "limit" as an offset, so that
comment|// they are actually calculated in the interval [0, 2 * limit]
comment|// To avoid numerical errors in platforms where we use single precision,
comment|// we use a tighter limit for the variables range.
DECL|variable|g_offset
specifier|const
name|qreal
name|g_offset
init|=
operator|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|)
condition|?
name|QWIDGETSIZE_MAX
else|:
name|QWIDGETSIZE_MAX
operator|/
literal|32
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QGraphicsAnchorPrivate
name|QGraphicsAnchorPrivate
operator|::
name|QGraphicsAnchorPrivate
parameter_list|(
name|int
name|version
parameter_list|)
member_init_list|:
name|QObjectPrivate
argument_list|(
name|version
argument_list|)
member_init_list|,
name|layoutPrivate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sizePolicy
argument_list|(
name|QSizePolicy
operator|::
name|Fixed
argument_list|)
member_init_list|,
name|preferredSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hasSize
argument_list|(
literal|true
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QGraphicsAnchorPrivate
name|QGraphicsAnchorPrivate
operator|::
name|~
name|QGraphicsAnchorPrivate
parameter_list|()
block|{
if|if
condition|(
name|data
condition|)
block|{
comment|// The QGraphicsAnchor was already deleted at this moment. We must clean
comment|// the dangling pointer to avoid double deletion in the AnchorData dtor.
name|data
operator|->
name|graphicsAnchor
operator|=
literal|0
expr_stmt|;
name|layoutPrivate
operator|->
name|removeAnchor
argument_list|(
name|data
operator|->
name|from
argument_list|,
name|data
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|setSizePolicy
name|void
name|QGraphicsAnchorPrivate
operator|::
name|setSizePolicy
parameter_list|(
name|QSizePolicy
operator|::
name|Policy
name|policy
parameter_list|)
block|{
if|if
condition|(
name|sizePolicy
operator|!=
name|policy
condition|)
block|{
name|sizePolicy
operator|=
name|policy
expr_stmt|;
name|layoutPrivate
operator|->
name|q_func
argument_list|()
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setSpacing
name|void
name|QGraphicsAnchorPrivate
operator|::
name|setSpacing
parameter_list|(
name|qreal
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchor::setSpacing: The anchor does not exist."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hasSize
operator|&&
operator|(
name|preferredSize
operator|==
name|value
operator|)
condition|)
return|return;
comment|// The anchor has an user-defined size
name|hasSize
operator|=
literal|true
expr_stmt|;
name|preferredSize
operator|=
name|value
expr_stmt|;
name|layoutPrivate
operator|->
name|q_func
argument_list|()
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unsetSpacing
name|void
name|QGraphicsAnchorPrivate
operator|::
name|unsetSpacing
parameter_list|()
block|{
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchor::setSpacing: The anchor does not exist."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Return to standard direction
name|hasSize
operator|=
literal|false
expr_stmt|;
name|layoutPrivate
operator|->
name|q_func
argument_list|()
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|spacing
name|qreal
name|QGraphicsAnchorPrivate
operator|::
name|spacing
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchor::setSpacing: The anchor does not exist."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|preferredSize
return|;
block|}
end_function
begin_function
DECL|function|applySizePolicy
specifier|static
name|void
name|applySizePolicy
parameter_list|(
name|QSizePolicy
operator|::
name|Policy
name|policy
parameter_list|,
name|qreal
name|minSizeHint
parameter_list|,
name|qreal
name|prefSizeHint
parameter_list|,
name|qreal
name|maxSizeHint
parameter_list|,
name|qreal
modifier|*
name|minSize
parameter_list|,
name|qreal
modifier|*
name|prefSize
parameter_list|,
name|qreal
modifier|*
name|maxSize
parameter_list|)
block|{
comment|// minSize, prefSize and maxSize are initialized
comment|// with item's preferred Size: this is QSizePolicy::Fixed.
comment|//
comment|// Then we check each flag to find the resultant QSizePolicy,
comment|// according to the following table:
comment|//
comment|//      constant               value
comment|// QSizePolicy::Fixed            0
comment|// QSizePolicy::Minimum       GrowFlag
comment|// QSizePolicy::Maximum       ShrinkFlag
comment|// QSizePolicy::Preferred     GrowFlag | ShrinkFlag
comment|// QSizePolicy::Ignored       GrowFlag | ShrinkFlag | IgnoreFlag
if|if
condition|(
name|policy
operator|&
name|QSizePolicy
operator|::
name|ShrinkFlag
condition|)
operator|*
name|minSize
operator|=
name|minSizeHint
expr_stmt|;
else|else
operator|*
name|minSize
operator|=
name|prefSizeHint
expr_stmt|;
if|if
condition|(
name|policy
operator|&
name|QSizePolicy
operator|::
name|GrowFlag
condition|)
operator|*
name|maxSize
operator|=
name|maxSizeHint
expr_stmt|;
else|else
operator|*
name|maxSize
operator|=
name|prefSizeHint
expr_stmt|;
comment|// Note that these two initializations are affected by the previous flags
if|if
condition|(
name|policy
operator|&
name|QSizePolicy
operator|::
name|IgnoreFlag
condition|)
operator|*
name|prefSize
operator|=
operator|*
name|minSize
expr_stmt|;
else|else
operator|*
name|prefSize
operator|=
name|prefSizeHint
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~AnchorData
name|AnchorData
operator|::
name|~
name|AnchorData
parameter_list|()
block|{
if|if
condition|(
name|graphicsAnchor
condition|)
block|{
comment|// Remove reference to ourself to avoid double removal in
comment|// QGraphicsAnchorPrivate dtor.
name|graphicsAnchor
operator|->
name|d_func
argument_list|()
operator|->
name|data
operator|=
literal|0
expr_stmt|;
operator|delete
name|graphicsAnchor
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|refreshSizeHints
name|void
name|AnchorData
operator|::
name|refreshSizeHints
parameter_list|(
specifier|const
name|QLayoutStyleInfo
modifier|*
name|styleInfo
parameter_list|)
block|{
name|QSizePolicy
operator|::
name|Policy
name|policy
decl_stmt|;
name|qreal
name|minSizeHint
decl_stmt|;
name|qreal
name|prefSizeHint
decl_stmt|;
name|qreal
name|maxSizeHint
decl_stmt|;
if|if
condition|(
name|item
condition|)
block|{
comment|// It is an internal anchor, fetch size information from the item
if|if
condition|(
name|isLayoutAnchor
condition|)
block|{
name|minSize
operator|=
literal|0
expr_stmt|;
name|prefSize
operator|=
literal|0
expr_stmt|;
name|maxSize
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
if|if
condition|(
name|isCenterAnchor
condition|)
name|maxSize
operator|/=
literal|2
expr_stmt|;
name|minPrefSize
operator|=
name|prefSize
expr_stmt|;
name|maxPrefSize
operator|=
name|maxSize
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|orientation
operator|==
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Horizontal
condition|)
block|{
name|policy
operator|=
name|item
operator|->
name|sizePolicy
argument_list|()
operator|.
name|horizontalPolicy
argument_list|()
expr_stmt|;
name|minSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MinimumSize
argument_list|)
operator|.
name|width
argument_list|()
expr_stmt|;
name|prefSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|PreferredSize
argument_list|)
operator|.
name|width
argument_list|()
expr_stmt|;
name|maxSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MaximumSize
argument_list|)
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|policy
operator|=
name|item
operator|->
name|sizePolicy
argument_list|()
operator|.
name|verticalPolicy
argument_list|()
expr_stmt|;
name|minSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MinimumSize
argument_list|)
operator|.
name|height
argument_list|()
expr_stmt|;
name|prefSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|PreferredSize
argument_list|)
operator|.
name|height
argument_list|()
expr_stmt|;
name|maxSizeHint
operator|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MaximumSize
argument_list|)
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isCenterAnchor
condition|)
block|{
name|minSizeHint
operator|/=
literal|2
expr_stmt|;
name|prefSizeHint
operator|/=
literal|2
expr_stmt|;
name|maxSizeHint
operator|/=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// It is a user-created anchor, fetch size information from the associated QGraphicsAnchor
name|Q_ASSERT
argument_list|(
name|graphicsAnchor
argument_list|)
expr_stmt|;
name|QGraphicsAnchorPrivate
modifier|*
name|anchorPrivate
init|=
name|graphicsAnchor
operator|->
name|d_func
argument_list|()
decl_stmt|;
comment|// Policy, min and max sizes are straightforward
name|policy
operator|=
name|anchorPrivate
operator|->
name|sizePolicy
expr_stmt|;
name|minSizeHint
operator|=
literal|0
expr_stmt|;
name|maxSizeHint
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
comment|// Preferred Size
if|if
condition|(
name|anchorPrivate
operator|->
name|hasSize
condition|)
block|{
comment|// Anchor has user-defined size
name|prefSizeHint
operator|=
name|anchorPrivate
operator|->
name|preferredSize
expr_stmt|;
block|}
else|else
block|{
comment|// Fetch size information from style
specifier|const
name|Qt
operator|::
name|Orientation
name|orient
init|=
name|Qt
operator|::
name|Orientation
argument_list|(
name|QGraphicsAnchorLayoutPrivate
operator|::
name|edgeOrientation
argument_list|(
name|from
operator|->
name|m_edge
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|qreal
name|s
init|=
name|styleInfo
operator|->
name|defaultSpacing
argument_list|(
name|orient
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|QSizePolicy
operator|::
name|ControlType
name|controlTypeFrom
init|=
name|from
operator|->
name|m_item
operator|->
name|sizePolicy
argument_list|()
operator|.
name|controlType
argument_list|()
decl_stmt|;
name|QSizePolicy
operator|::
name|ControlType
name|controlTypeTo
init|=
name|to
operator|->
name|m_item
operator|->
name|sizePolicy
argument_list|()
operator|.
name|controlType
argument_list|()
decl_stmt|;
name|s
operator|=
name|styleInfo
operator|->
name|perItemSpacing
argument_list|(
name|controlTypeFrom
argument_list|,
name|controlTypeTo
argument_list|,
name|orient
argument_list|)
expr_stmt|;
comment|// ### Currently we do not support negative anchors inside the graph.
comment|// To avoid those being created by a negative style spacing, we must
comment|// make this test.
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|s
operator|=
literal|0
expr_stmt|;
block|}
name|prefSizeHint
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|// Fill minSize, prefSize and maxSize based on policy and sizeHints
name|applySizePolicy
argument_list|(
name|policy
argument_list|,
name|minSizeHint
argument_list|,
name|prefSizeHint
argument_list|,
name|maxSizeHint
argument_list|,
operator|&
name|minSize
argument_list|,
operator|&
name|prefSize
argument_list|,
operator|&
name|maxSize
argument_list|)
expr_stmt|;
name|minPrefSize
operator|=
name|prefSize
expr_stmt|;
name|maxPrefSize
operator|=
name|maxSize
expr_stmt|;
comment|// Set the anchor effective sizes to preferred.
comment|//
comment|// Note: The idea here is that all items should remain at their
comment|// preferred size unless where that's impossible.  In cases where
comment|// the item is subject to restrictions (anchored to the layout
comment|// edges, for instance), the simplex solver will be run to
comment|// recalculate and override the values we set here.
name|sizeAtMinimum
operator|=
name|prefSize
expr_stmt|;
name|sizeAtPreferred
operator|=
name|prefSize
expr_stmt|;
name|sizeAtMaximum
operator|=
name|prefSize
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateChildrenSizes
name|void
name|ParallelAnchorData
operator|::
name|updateChildrenSizes
parameter_list|()
block|{
name|firstEdge
operator|->
name|sizeAtMinimum
operator|=
name|sizeAtMinimum
expr_stmt|;
name|firstEdge
operator|->
name|sizeAtPreferred
operator|=
name|sizeAtPreferred
expr_stmt|;
name|firstEdge
operator|->
name|sizeAtMaximum
operator|=
name|sizeAtMaximum
expr_stmt|;
if|if
condition|(
name|secondForward
argument_list|()
condition|)
block|{
name|secondEdge
operator|->
name|sizeAtMinimum
operator|=
name|sizeAtMinimum
expr_stmt|;
name|secondEdge
operator|->
name|sizeAtPreferred
operator|=
name|sizeAtPreferred
expr_stmt|;
name|secondEdge
operator|->
name|sizeAtMaximum
operator|=
name|sizeAtMaximum
expr_stmt|;
block|}
else|else
block|{
name|secondEdge
operator|->
name|sizeAtMinimum
operator|=
operator|-
name|sizeAtMinimum
expr_stmt|;
name|secondEdge
operator|->
name|sizeAtPreferred
operator|=
operator|-
name|sizeAtPreferred
expr_stmt|;
name|secondEdge
operator|->
name|sizeAtMaximum
operator|=
operator|-
name|sizeAtMaximum
expr_stmt|;
block|}
name|firstEdge
operator|->
name|updateChildrenSizes
argument_list|()
expr_stmt|;
name|secondEdge
operator|->
name|updateChildrenSizes
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   \internal    Initialize the parallel anchor size hints using the sizeHint information from   its children.    Note that parallel groups can lead to unfeasibility, so during calculation, we can   find out one unfeasibility. Because of that this method return boolean. This can't   happen in sequential, so there the method is void.  */
end_comment
begin_function
DECL|function|calculateSizeHints
name|bool
name|ParallelAnchorData
operator|::
name|calculateSizeHints
parameter_list|()
block|{
comment|// Normalize second child sizes.
comment|// A negative anchor of sizes min, minPref, pref, maxPref and max, is equivalent
comment|// to a forward anchor of sizes -max, -maxPref, -pref, -minPref, -min
name|qreal
name|secondMin
decl_stmt|;
name|qreal
name|secondMinPref
decl_stmt|;
name|qreal
name|secondPref
decl_stmt|;
name|qreal
name|secondMaxPref
decl_stmt|;
name|qreal
name|secondMax
decl_stmt|;
if|if
condition|(
name|secondForward
argument_list|()
condition|)
block|{
name|secondMin
operator|=
name|secondEdge
operator|->
name|minSize
expr_stmt|;
name|secondMinPref
operator|=
name|secondEdge
operator|->
name|minPrefSize
expr_stmt|;
name|secondPref
operator|=
name|secondEdge
operator|->
name|prefSize
expr_stmt|;
name|secondMaxPref
operator|=
name|secondEdge
operator|->
name|maxPrefSize
expr_stmt|;
name|secondMax
operator|=
name|secondEdge
operator|->
name|maxSize
expr_stmt|;
block|}
else|else
block|{
name|secondMin
operator|=
operator|-
name|secondEdge
operator|->
name|maxSize
expr_stmt|;
name|secondMinPref
operator|=
operator|-
name|secondEdge
operator|->
name|maxPrefSize
expr_stmt|;
name|secondPref
operator|=
operator|-
name|secondEdge
operator|->
name|prefSize
expr_stmt|;
name|secondMaxPref
operator|=
operator|-
name|secondEdge
operator|->
name|minPrefSize
expr_stmt|;
name|secondMax
operator|=
operator|-
name|secondEdge
operator|->
name|minSize
expr_stmt|;
block|}
name|minSize
operator|=
name|qMax
argument_list|(
name|firstEdge
operator|->
name|minSize
argument_list|,
name|secondMin
argument_list|)
expr_stmt|;
name|maxSize
operator|=
name|qMin
argument_list|(
name|firstEdge
operator|->
name|maxSize
argument_list|,
name|secondMax
argument_list|)
expr_stmt|;
comment|// This condition means that the maximum size of one anchor being simplified is smaller than
comment|// the minimum size of the other anchor. The consequence is that there won't be a valid size
comment|// for this parallel setup.
if|if
condition|(
name|minSize
operator|>
name|maxSize
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Preferred size calculation
comment|// The calculation of preferred size is done as follows:
comment|//
comment|// 1) Check whether one of the child anchors is the layout structural anchor
comment|//    If so, we can simply copy the preferred information from the other child,
comment|//    after bounding it to our minimum and maximum sizes.
comment|//    If not, then we proceed with the actual calculations.
comment|//
comment|// 2) The whole algorithm for preferred size calculation is based on the fact
comment|//    that, if a given anchor cannot remain at its preferred size, it'd rather
comment|//    grow than shrink.
comment|//
comment|//    What happens though is that while this affirmative is true for simple
comment|//    anchors, it may not be true for sequential anchors that have one or more
comment|//    reversed anchors inside it. That happens because when a sequential anchor
comment|//    grows, any reversed anchors inside it may be required to shrink, something
comment|//    we try to avoid, as said above.
comment|//
comment|//    To overcome this, besides their actual preferred size "prefSize", each anchor
comment|//    exports what we call "minPrefSize" and "maxPrefSize". These two values define
comment|//    a surrounding interval where, if required to move, the anchor would rather
comment|//    remain inside.
comment|//
comment|//    For standard anchors, this area simply represents the region between
comment|//    prefSize and maxSize, which makes sense since our first affirmation.
comment|//    For composed anchors, these values are calculated as to reduce the global
comment|//    "damage", that is, to reduce the total deviation and the total amount of
comment|//    anchors that had to shrink.
if|if
condition|(
name|firstEdge
operator|->
name|isLayoutAnchor
condition|)
block|{
name|prefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|secondPref
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
name|minPrefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|secondMinPref
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
name|maxPrefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|secondMaxPref
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secondEdge
operator|->
name|isLayoutAnchor
condition|)
block|{
name|prefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|firstEdge
operator|->
name|prefSize
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
name|minPrefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|firstEdge
operator|->
name|minPrefSize
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
name|maxPrefSize
operator|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|firstEdge
operator|->
name|maxPrefSize
argument_list|,
name|maxSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Calculate the intersection between the "preferred" regions of each child
specifier|const
name|qreal
name|lowerBoundary
init|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|qMax
argument_list|(
name|firstEdge
operator|->
name|minPrefSize
argument_list|,
name|secondMinPref
argument_list|)
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|upperBoundary
init|=
name|qBound
argument_list|(
name|minSize
argument_list|,
name|qMin
argument_list|(
name|firstEdge
operator|->
name|maxPrefSize
argument_list|,
name|secondMaxPref
argument_list|)
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|prefMean
init|=
name|qBound
argument_list|(
name|minSize
argument_list|,
operator|(
name|firstEdge
operator|->
name|prefSize
operator|+
name|secondPref
operator|)
operator|/
literal|2
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|lowerBoundary
operator|<
name|upperBoundary
condition|)
block|{
comment|// If there is an intersection between the two regions, this intersection
comment|// will be used as the preferred region of the parallel anchor itself.
comment|// The preferred size will be the bounded average between the two preferred
comment|// sizes.
name|prefSize
operator|=
name|qBound
argument_list|(
name|lowerBoundary
argument_list|,
name|prefMean
argument_list|,
name|upperBoundary
argument_list|)
expr_stmt|;
name|minPrefSize
operator|=
name|lowerBoundary
expr_stmt|;
name|maxPrefSize
operator|=
name|upperBoundary
expr_stmt|;
block|}
else|else
block|{
comment|// If there is no intersection, we have to attribute "damage" to at least
comment|// one of the children. The minimum total damage is achieved in points
comment|// inside the region that extends from (1) the upper boundary of the lower
comment|// region to (2) the lower boundary of the upper region.
comment|// Then, we expose this region as _our_ preferred region and once again,
comment|// use the bounded average as our preferred size.
name|prefSize
operator|=
name|qBound
argument_list|(
name|upperBoundary
argument_list|,
name|prefMean
argument_list|,
name|lowerBoundary
argument_list|)
expr_stmt|;
name|minPrefSize
operator|=
name|upperBoundary
expr_stmt|;
name|maxPrefSize
operator|=
name|lowerBoundary
expr_stmt|;
block|}
block|}
comment|// See comment in AnchorData::refreshSizeHints() about sizeAt* values
name|sizeAtMinimum
operator|=
name|prefSize
expr_stmt|;
name|sizeAtPreferred
operator|=
name|prefSize
expr_stmt|;
name|sizeAtMaximum
operator|=
name|prefSize
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     returns the factor in the interval [-1, 1].     -1 is at Minimum      0 is at Preferred      1 is at Maximum */
end_comment
begin_function
DECL|function|getFactor
specifier|static
name|QPair
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
argument_list|,
name|qreal
argument_list|>
name|getFactor
parameter_list|(
name|qreal
name|value
parameter_list|,
name|qreal
name|min
parameter_list|,
name|qreal
name|minPref
parameter_list|,
name|qreal
name|pref
parameter_list|,
name|qreal
name|maxPref
parameter_list|,
name|qreal
name|max
parameter_list|)
block|{
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
name|interval
decl_stmt|;
name|qreal
name|lower
decl_stmt|;
name|qreal
name|upper
decl_stmt|;
if|if
condition|(
name|value
operator|<
name|minPref
condition|)
block|{
name|interval
operator|=
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MinimumToMinPreferred
expr_stmt|;
name|lower
operator|=
name|min
expr_stmt|;
name|upper
operator|=
name|minPref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|<
name|pref
condition|)
block|{
name|interval
operator|=
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MinPreferredToPreferred
expr_stmt|;
name|lower
operator|=
name|minPref
expr_stmt|;
name|upper
operator|=
name|pref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|<
name|maxPref
condition|)
block|{
name|interval
operator|=
name|QGraphicsAnchorLayoutPrivate
operator|::
name|PreferredToMaxPreferred
expr_stmt|;
name|lower
operator|=
name|pref
expr_stmt|;
name|upper
operator|=
name|maxPref
expr_stmt|;
block|}
else|else
block|{
name|interval
operator|=
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MaxPreferredToMaximum
expr_stmt|;
name|lower
operator|=
name|maxPref
expr_stmt|;
name|upper
operator|=
name|max
expr_stmt|;
block|}
name|qreal
name|progress
decl_stmt|;
if|if
condition|(
name|upper
operator|==
name|lower
condition|)
block|{
name|progress
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|progress
operator|=
operator|(
name|value
operator|-
name|lower
operator|)
operator|/
operator|(
name|upper
operator|-
name|lower
operator|)
expr_stmt|;
block|}
return|return
name|qMakePair
argument_list|(
name|interval
argument_list|,
name|progress
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|interpolate
specifier|static
name|qreal
name|interpolate
parameter_list|(
specifier|const
name|QPair
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
argument_list|,
name|qreal
argument_list|>
modifier|&
name|factor
parameter_list|,
name|qreal
name|min
parameter_list|,
name|qreal
name|minPref
parameter_list|,
name|qreal
name|pref
parameter_list|,
name|qreal
name|maxPref
parameter_list|,
name|qreal
name|max
parameter_list|)
block|{
name|qreal
name|lower
init|=
literal|0
decl_stmt|;
name|qreal
name|upper
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|factor
operator|.
name|first
condition|)
block|{
case|case
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MinimumToMinPreferred
case|:
name|lower
operator|=
name|min
expr_stmt|;
name|upper
operator|=
name|minPref
expr_stmt|;
break|break;
case|case
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MinPreferredToPreferred
case|:
name|lower
operator|=
name|minPref
expr_stmt|;
name|upper
operator|=
name|pref
expr_stmt|;
break|break;
case|case
name|QGraphicsAnchorLayoutPrivate
operator|::
name|PreferredToMaxPreferred
case|:
name|lower
operator|=
name|pref
expr_stmt|;
name|upper
operator|=
name|maxPref
expr_stmt|;
break|break;
case|case
name|QGraphicsAnchorLayoutPrivate
operator|::
name|MaxPreferredToMaximum
case|:
name|lower
operator|=
name|maxPref
expr_stmt|;
name|upper
operator|=
name|max
expr_stmt|;
break|break;
block|}
return|return
name|lower
operator|+
name|factor
operator|.
name|second
operator|*
operator|(
name|upper
operator|-
name|lower
operator|)
return|;
block|}
end_function
begin_function
DECL|function|updateChildrenSizes
name|void
name|SequentialAnchorData
operator|::
name|updateChildrenSizes
parameter_list|()
block|{
comment|// Band here refers if the value is in the Minimum To Preferred
comment|// band (the lower band) or the Preferred To Maximum (the upper band).
specifier|const
name|QPair
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
argument_list|,
name|qreal
argument_list|>
name|minFactor
init|=
name|getFactor
argument_list|(
name|sizeAtMinimum
argument_list|,
name|minSize
argument_list|,
name|minPrefSize
argument_list|,
name|prefSize
argument_list|,
name|maxPrefSize
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
specifier|const
name|QPair
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
argument_list|,
name|qreal
argument_list|>
name|prefFactor
init|=
name|getFactor
argument_list|(
name|sizeAtPreferred
argument_list|,
name|minSize
argument_list|,
name|minPrefSize
argument_list|,
name|prefSize
argument_list|,
name|maxPrefSize
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
specifier|const
name|QPair
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Interval
argument_list|,
name|qreal
argument_list|>
name|maxFactor
init|=
name|getFactor
argument_list|(
name|sizeAtMaximum
argument_list|,
name|minSize
argument_list|,
name|minPrefSize
argument_list|,
name|prefSize
argument_list|,
name|maxPrefSize
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
comment|// XXX This is not safe if Vertex simplification takes place after the sequential
comment|// anchor is created. In that case, "prev" will be a group-vertex, different from
comment|// "from" or "to", that _contains_ one of them.
name|AnchorVertex
modifier|*
name|prev
init|=
name|from
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|e
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|edgeIsForward
init|=
operator|(
name|e
operator|->
name|from
operator|==
name|prev
operator|)
decl_stmt|;
if|if
condition|(
name|edgeIsForward
condition|)
block|{
name|e
operator|->
name|sizeAtMinimum
operator|=
name|interpolate
argument_list|(
name|minFactor
argument_list|,
name|e
operator|->
name|minSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|maxSize
argument_list|)
expr_stmt|;
name|e
operator|->
name|sizeAtPreferred
operator|=
name|interpolate
argument_list|(
name|prefFactor
argument_list|,
name|e
operator|->
name|minSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|maxSize
argument_list|)
expr_stmt|;
name|e
operator|->
name|sizeAtMaximum
operator|=
name|interpolate
argument_list|(
name|maxFactor
argument_list|,
name|e
operator|->
name|minSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|maxSize
argument_list|)
expr_stmt|;
name|prev
operator|=
name|e
operator|->
name|to
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|prev
operator|==
name|e
operator|->
name|to
argument_list|)
expr_stmt|;
name|e
operator|->
name|sizeAtMinimum
operator|=
name|interpolate
argument_list|(
name|minFactor
argument_list|,
name|e
operator|->
name|maxSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|minSize
argument_list|)
expr_stmt|;
name|e
operator|->
name|sizeAtPreferred
operator|=
name|interpolate
argument_list|(
name|prefFactor
argument_list|,
name|e
operator|->
name|maxSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|minSize
argument_list|)
expr_stmt|;
name|e
operator|->
name|sizeAtMaximum
operator|=
name|interpolate
argument_list|(
name|maxFactor
argument_list|,
name|e
operator|->
name|maxSize
argument_list|,
name|e
operator|->
name|maxPrefSize
argument_list|,
name|e
operator|->
name|prefSize
argument_list|,
name|e
operator|->
name|minPrefSize
argument_list|,
name|e
operator|->
name|minSize
argument_list|)
expr_stmt|;
name|prev
operator|=
name|e
operator|->
name|from
expr_stmt|;
block|}
name|e
operator|->
name|updateChildrenSizes
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|calculateSizeHints
name|void
name|SequentialAnchorData
operator|::
name|calculateSizeHints
parameter_list|()
block|{
name|minSize
operator|=
literal|0
expr_stmt|;
name|prefSize
operator|=
literal|0
expr_stmt|;
name|maxSize
operator|=
literal|0
expr_stmt|;
name|minPrefSize
operator|=
literal|0
expr_stmt|;
name|maxPrefSize
operator|=
literal|0
expr_stmt|;
name|AnchorVertex
modifier|*
name|prev
init|=
name|from
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_edges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|edge
init|=
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|edgeIsForward
init|=
operator|(
name|edge
operator|->
name|from
operator|==
name|prev
operator|)
decl_stmt|;
if|if
condition|(
name|edgeIsForward
condition|)
block|{
name|minSize
operator|+=
name|edge
operator|->
name|minSize
expr_stmt|;
name|prefSize
operator|+=
name|edge
operator|->
name|prefSize
expr_stmt|;
name|maxSize
operator|+=
name|edge
operator|->
name|maxSize
expr_stmt|;
name|minPrefSize
operator|+=
name|edge
operator|->
name|minPrefSize
expr_stmt|;
name|maxPrefSize
operator|+=
name|edge
operator|->
name|maxPrefSize
expr_stmt|;
name|prev
operator|=
name|edge
operator|->
name|to
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|prev
operator|==
name|edge
operator|->
name|to
argument_list|)
expr_stmt|;
name|minSize
operator|-=
name|edge
operator|->
name|maxSize
expr_stmt|;
name|prefSize
operator|-=
name|edge
operator|->
name|prefSize
expr_stmt|;
name|maxSize
operator|-=
name|edge
operator|->
name|minSize
expr_stmt|;
name|minPrefSize
operator|-=
name|edge
operator|->
name|maxPrefSize
expr_stmt|;
name|maxPrefSize
operator|-=
name|edge
operator|->
name|minPrefSize
expr_stmt|;
name|prev
operator|=
name|edge
operator|->
name|from
expr_stmt|;
block|}
block|}
comment|// See comment in AnchorData::refreshSizeHints() about sizeAt* values
name|sizeAtMinimum
operator|=
name|prefSize
expr_stmt|;
name|sizeAtPreferred
operator|=
name|prefSize
expr_stmt|;
name|sizeAtMaximum
operator|=
name|prefSize
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEBUG
end_ifdef
begin_function
DECL|function|dump
name|void
name|AnchorData
operator|::
name|dump
parameter_list|(
name|int
name|indent
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|Parallel
condition|)
block|{
name|qDebug
argument_list|(
literal|"%*s type: parallel:"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ParallelAnchorData
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|ParallelAnchorData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|p
operator|->
name|firstEdge
operator|->
name|dump
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|->
name|secondEdge
operator|->
name|dump
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Sequential
condition|)
block|{
name|SequentialAnchorData
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|SequentialAnchorData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|kids
init|=
name|s
operator|->
name|m_edges
operator|.
name|count
argument_list|()
decl_stmt|;
name|qDebug
argument_list|(
literal|"%*s type: sequential(%d):"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|kids
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kids
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|dump
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qDebug
argument_list|(
literal|"%*s type: Normal:"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|constraint
name|QSimplexConstraint
modifier|*
name|GraphPath
operator|::
name|constraint
parameter_list|(
specifier|const
name|GraphPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
comment|// Calculate
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|cPositives
decl_stmt|;
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|cNegatives
decl_stmt|;
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|intersection
decl_stmt|;
name|cPositives
operator|=
name|positives
operator|+
name|path
operator|.
name|negatives
expr_stmt|;
name|cNegatives
operator|=
name|negatives
operator|+
name|path
operator|.
name|positives
expr_stmt|;
name|intersection
operator|=
name|cPositives
operator|&
name|cNegatives
expr_stmt|;
name|cPositives
operator|-=
name|intersection
expr_stmt|;
name|cNegatives
operator|-=
name|intersection
expr_stmt|;
comment|// Fill
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
operator|::
name|iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cPositives
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|cPositives
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
operator|*
name|i
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cNegatives
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|cNegatives
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
operator|*
name|i
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEBUG
end_ifdef
begin_function
DECL|function|toString
name|QString
name|GraphPath
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|QString
name|string
argument_list|(
name|QLatin1String
argument_list|(
literal|"Path: "
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|AnchorData
modifier|*
name|edge
decl|,
name|positives
control|)
name|string
operator|+=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|" (+++) %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|edge
operator|->
name|toString
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|AnchorData
modifier|*
name|edge
decl|,
name|negatives
control|)
name|string
operator|+=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|" (---) %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|edge
operator|->
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QGraphicsAnchorLayoutPrivate
name|QGraphicsAnchorLayoutPrivate
operator|::
name|QGraphicsAnchorLayoutPrivate
parameter_list|()
member_init_list|:
name|calculateGraphCacheDirty
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|styleInfoDirty
argument_list|(
literal|true
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NOrientations
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
block|{
name|sizeHints
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|interpolationProgress
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|spacings
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|graphHasConflicts
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
name|layoutFirstVertex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|layoutCentralVertex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|layoutLastVertex
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_constructor
begin_function
DECL|function|oppositeEdge
name|Qt
operator|::
name|AnchorPoint
name|QGraphicsAnchorLayoutPrivate
operator|::
name|oppositeEdge
parameter_list|(
name|Qt
operator|::
name|AnchorPoint
name|edge
parameter_list|)
block|{
switch|switch
condition|(
name|edge
condition|)
block|{
case|case
name|Qt
operator|::
name|AnchorLeft
case|:
name|edge
operator|=
name|Qt
operator|::
name|AnchorRight
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AnchorRight
case|:
name|edge
operator|=
name|Qt
operator|::
name|AnchorLeft
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AnchorTop
case|:
name|edge
operator|=
name|Qt
operator|::
name|AnchorBottom
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AnchorBottom
case|:
name|edge
operator|=
name|Qt
operator|::
name|AnchorTop
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|edge
return|;
block|}
end_function
begin_comment
comment|/*!  * \internal  *  * helper function in order to avoid overflowing anchor sizes  * the returned size will never be larger than FLT_MAX  *  */
end_comment
begin_function
DECL|function|checkAdd
specifier|inline
specifier|static
name|qreal
name|checkAdd
parameter_list|(
name|qreal
name|a
parameter_list|,
name|qreal
name|b
parameter_list|)
block|{
if|if
condition|(
name|FLT_MAX
operator|-
name|b
operator|<
name|a
condition|)
return|return
name|FLT_MAX
return|;
return|return
name|a
operator|+
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Adds \a newAnchor to the graph.      Returns the newAnchor itself if it could be added without further changes to the graph. If a     new parallel anchor had to be created, then returns the new parallel anchor. If a parallel anchor     had to be created and it results in an unfeasible setup, \a feasible is set to false, otherwise     true.      Note that in the case a new parallel anchor is created, it might also take over some constraints     from its children anchors. */
end_comment
begin_function
DECL|function|addAnchorMaybeParallel
name|AnchorData
modifier|*
name|QGraphicsAnchorLayoutPrivate
operator|::
name|addAnchorMaybeParallel
parameter_list|(
name|AnchorData
modifier|*
name|newAnchor
parameter_list|,
name|bool
modifier|*
name|feasible
parameter_list|)
block|{
name|Orientation
name|orientation
init|=
name|Orientation
argument_list|(
name|newAnchor
operator|->
name|orientation
argument_list|)
decl_stmt|;
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
operator|*
name|feasible
operator|=
literal|true
expr_stmt|;
comment|// If already exists one anchor where newAnchor is supposed to be, we create a parallel
comment|// anchor.
if|if
condition|(
name|AnchorData
modifier|*
name|oldAnchor
init|=
name|g
operator|.
name|takeEdge
argument_list|(
name|newAnchor
operator|->
name|from
argument_list|,
name|newAnchor
operator|->
name|to
argument_list|)
condition|)
block|{
name|ParallelAnchorData
modifier|*
name|parallel
init|=
operator|new
name|ParallelAnchorData
argument_list|(
name|oldAnchor
argument_list|,
name|newAnchor
argument_list|)
decl_stmt|;
comment|// The parallel anchor will "replace" its children anchors in
comment|// every center constraint that they appear.
comment|// ### If the dependent (center) anchors had reference(s) to their constraints, we
comment|// could avoid traversing all the itemCenterConstraints.
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
init|=
name|itemCenterConstraints
index|[
name|orientation
index|]
decl_stmt|;
name|AnchorData
modifier|*
name|children
index|[
literal|2
index|]
init|=
block|{
name|oldAnchor
block|,
name|newAnchor
block|}
decl_stmt|;
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|*
name|childrenConstraints
index|[
literal|2
index|]
init|=
block|{
operator|&
name|parallel
operator|->
name|m_firstConstraints
block|,
operator|&
name|parallel
operator|->
name|m_secondConstraints
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|*
name|childConstraints
init|=
name|childrenConstraints
index|[
name|i
index|]
decl_stmt|;
comment|// We need to fix the second child constraints if the parallel group will have the
comment|// opposite direction of the second child anchor. For the point of view of external
comment|// entities, this anchor was reversed. So if at some point we say that the parallel
comment|// has a value of 20, this mean that the second child (when reversed) will be
comment|// assigned -20.
specifier|const
name|bool
name|needsReverse
init|=
name|i
operator|==
literal|1
operator|&&
operator|!
name|parallel
operator|->
name|secondForward
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|isCenterAnchor
condition|)
continue|continue;
name|parallel
operator|->
name|isCenterAnchor
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|constraints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
name|constraints
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|variables
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|childConstraints
operator|->
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|qreal
name|v
init|=
name|c
operator|->
name|variables
operator|.
name|take
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|needsReverse
condition|)
name|v
operator|*=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|parallel
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// At this point we can identify that the parallel anchor is not feasible, e.g. one
comment|// anchor minimum size is bigger than the other anchor maximum size.
operator|*
name|feasible
operator|=
name|parallel
operator|->
name|calculateSizeHints
argument_list|()
expr_stmt|;
name|newAnchor
operator|=
name|parallel
expr_stmt|;
block|}
name|g
operator|.
name|createEdge
argument_list|(
name|newAnchor
operator|->
name|from
argument_list|,
name|newAnchor
operator|->
name|to
argument_list|,
name|newAnchor
argument_list|)
expr_stmt|;
return|return
name|newAnchor
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Takes the sequence of vertices described by (\a before, \a vertices, \a after) and removes     all anchors connected to the vertices in \a vertices, returning one simplified anchor between     \a before and \a after.      Note that this function doesn't add the created anchor to the graph. This should be done by     the caller. */
end_comment
begin_function
DECL|function|createSequence
specifier|static
name|AnchorData
modifier|*
name|createSequence
parameter_list|(
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|*
name|graph
parameter_list|,
name|AnchorVertex
modifier|*
name|before
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
modifier|&
name|vertices
parameter_list|,
name|AnchorVertex
modifier|*
name|after
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
literal|0
name|QString
name|strVertices
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|strVertices
operator|+=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1 - "
argument_list|)
operator|.
name|arg
argument_list|(
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QString
name|strPath
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1 - %2%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|before
operator|->
name|toString
argument_list|()
argument_list|,
name|strVertices
argument_list|,
name|after
operator|->
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|qDebug
argument_list|(
literal|"simplifying [%s] to [%s - %s]"
argument_list|,
name|qPrintable
argument_list|(
name|strPath
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|before
operator|->
name|toString
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|after
operator|->
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AnchorVertex
modifier|*
name|prev
init|=
name|before
decl_stmt|;
name|QVector
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|edges
decl_stmt|;
comment|// Take from the graph, the edges that will be simplificated
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|next
init|=
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|AnchorData
modifier|*
name|ad
init|=
name|graph
operator|->
name|takeEdge
argument_list|(
name|prev
argument_list|,
name|next
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|edges
operator|.
name|append
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|prev
operator|=
name|next
expr_stmt|;
block|}
comment|// Take the last edge (not covered in the loop above)
name|AnchorData
modifier|*
name|ad
init|=
name|graph
operator|->
name|takeEdge
argument_list|(
name|vertices
operator|.
name|last
argument_list|()
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|edges
operator|.
name|append
argument_list|(
name|ad
argument_list|)
expr_stmt|;
comment|// Create sequence
name|SequentialAnchorData
modifier|*
name|sequence
init|=
operator|new
name|SequentialAnchorData
argument_list|(
name|vertices
argument_list|,
name|edges
argument_list|)
decl_stmt|;
name|sequence
operator|->
name|from
operator|=
name|before
expr_stmt|;
name|sequence
operator|->
name|to
operator|=
name|after
expr_stmt|;
name|sequence
operator|->
name|calculateSizeHints
argument_list|()
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function
begin_comment
comment|/*!    \internal     The purpose of this function is to simplify the graph.    Simplification serves two purposes:    1. Reduce the number of edges in the graph, (thus the number of variables to the equation       solver is reduced, and the solver performs better).    2. Be able to do distribution of sequences of edges more intelligently (esp. with sequential       anchors)     It is essential that it must be possible to restore simplified anchors back to their "original"    form. This is done by restoreSimplifiedAnchor().     There are two types of simplification that can be done:    1. Sequential simplification       Sequential simplification means that all sequences of anchors will be merged into one single       anchor. Only anhcors that points in the same direction will be merged.    2. Parallel simplification       If a simplified sequential anchor is about to be inserted between two vertices in the graph       and there already exist an anchor between those two vertices, a parallel anchor will be       created that serves as a placeholder for the sequential anchor and the anchor that was       already between the two vertices.     The process of simplification can be described as:     1. Simplify all sequences of anchors into one anchor.       If no further simplification was done, go to (3)       - If there already exist an anchor where the sequential anchor is supposed to be inserted,         take that anchor out of the graph       - Then create a parallel anchor that holds the sequential anchor and the anchor just taken         out of the graph.    2. Go to (1)    3. Done     When creating the parallel anchors, the algorithm might identify unfeasible situations. In this    case the simplification process stops and returns false. Otherwise returns true. */
end_comment
begin_function
DECL|function|simplifyGraph
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|simplifyGraph
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
if|if
condition|(
name|items
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
literal|0
name|qDebug
argument_list|(
literal|"Simplifying Graph for %s"
argument_list|,
name|orientation
operator|==
name|Horizontal
condition|?
literal|"Horizontal"
else|:
literal|"Vertical"
argument_list|)
expr_stmt|;
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Horizontal
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|dumpGraph
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1-full"
argument_list|)
operator|.
name|arg
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Vertex simplification
if|if
condition|(
operator|!
name|simplifyVertices
argument_list|(
name|orientation
argument_list|)
condition|)
block|{
name|restoreVertices
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Anchor simplification
name|bool
name|dirty
decl_stmt|;
name|bool
name|feasible
init|=
literal|true
decl_stmt|;
do|do
block|{
name|dirty
operator|=
name|simplifyGraphIteration
argument_list|(
name|orientation
argument_list|,
operator|&
name|feasible
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dirty
operator|&&
name|feasible
condition|)
do|;
comment|// Note that if we are not feasible, we fallback and make sure that the graph is fully restored
if|if
condition|(
operator|!
name|feasible
condition|)
block|{
name|restoreSimplifiedGraph
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
name|restoreVertices
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
literal|0
name|dumpGraph
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1-simplified-%2"
argument_list|)
operator|.
name|arg
argument_list|(
name|count
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
name|orientation
operator|==
name|Horizontal
condition|?
literal|"Horizontal"
else|:
literal|"Vertical"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|replaceVertex_helper
specifier|static
name|AnchorVertex
modifier|*
name|replaceVertex_helper
parameter_list|(
name|AnchorData
modifier|*
name|data
parameter_list|,
name|AnchorVertex
modifier|*
name|oldV
parameter_list|,
name|AnchorVertex
modifier|*
name|newV
parameter_list|)
block|{
name|AnchorVertex
modifier|*
name|other
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|from
operator|==
name|oldV
condition|)
block|{
name|data
operator|->
name|from
operator|=
name|newV
expr_stmt|;
name|other
operator|=
name|data
operator|->
name|to
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|to
operator|=
name|newV
expr_stmt|;
name|other
operator|=
name|data
operator|->
name|from
expr_stmt|;
block|}
return|return
name|other
return|;
block|}
end_function
begin_function
DECL|function|replaceVertex
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|replaceVertex
parameter_list|(
name|Orientation
name|orientation
parameter_list|,
name|AnchorVertex
modifier|*
name|oldV
parameter_list|,
name|AnchorVertex
modifier|*
name|newV
parameter_list|,
specifier|const
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|edges
parameter_list|)
block|{
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|bool
name|feasible
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|edges
index|[
name|i
index|]
decl_stmt|;
name|AnchorVertex
modifier|*
name|otherV
init|=
name|replaceVertex_helper
argument_list|(
name|ad
argument_list|,
name|oldV
argument_list|,
name|newV
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|ad
operator|->
name|name
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1 --to--> %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|ad
operator|->
name|from
operator|->
name|toString
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|ad
operator|->
name|to
operator|->
name|toString
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|newFeasible
decl_stmt|;
name|AnchorData
modifier|*
name|newAnchor
init|=
name|addAnchorMaybeParallel
argument_list|(
name|ad
argument_list|,
operator|&
name|newFeasible
argument_list|)
decl_stmt|;
name|feasible
operator|&=
name|newFeasible
expr_stmt|;
if|if
condition|(
name|newAnchor
operator|!=
name|ad
condition|)
block|{
comment|// A parallel was created, we mark that in the list of anchors created by vertex
comment|// simplification. This is needed because we want to restore them in a separate step
comment|// from the restoration of anchor simplification.
name|anchorsFromSimplifiedVertices
index|[
name|orientation
index|]
operator|.
name|append
argument_list|(
name|newAnchor
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|takeEdge
argument_list|(
name|oldV
argument_list|,
name|otherV
argument_list|)
expr_stmt|;
block|}
return|return
name|feasible
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|simplifyVertices
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|simplifyVertices
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
comment|// We'll walk through vertices
name|QStack
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|layoutFirstVertex
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|visited
decl_stmt|;
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|AnchorVertex
modifier|*
name|v
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|visited
operator|.
name|insert
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|// Each adjacent of 'v' is a possible vertex to be merged. So we traverse all of
comment|// them. Since once a merge is made, we might add new adjacents, and we don't want to
comment|// pass two times through one adjacent. The 'index' is used to track our position.
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|adjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|adjacents
operator|.
name|count
argument_list|()
condition|)
block|{
name|AnchorVertex
modifier|*
name|next
init|=
name|adjacents
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|index
operator|++
expr_stmt|;
name|AnchorData
modifier|*
name|data
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|v
argument_list|,
name|next
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|bothLayoutVertices
init|=
name|v
operator|->
name|m_item
operator|==
name|q
operator|&&
name|next
operator|->
name|m_item
operator|==
name|q
decl_stmt|;
specifier|const
name|bool
name|zeroSized
init|=
operator|!
name|data
operator|->
name|minSize
operator|&&
operator|!
name|data
operator|->
name|maxSize
decl_stmt|;
if|if
condition|(
operator|!
name|bothLayoutVertices
operator|&&
name|zeroSized
condition|)
block|{
comment|// Create a new vertex pair, note that we keep a list of those vertices so we can
comment|// easily process them when restoring the graph.
name|AnchorVertexPair
modifier|*
name|newV
init|=
operator|new
name|AnchorVertexPair
argument_list|(
name|v
argument_list|,
name|next
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|simplifiedVertices
index|[
name|orientation
index|]
operator|.
name|append
argument_list|(
name|newV
argument_list|)
expr_stmt|;
comment|// Collect the anchors of both vertices, the new vertex pair will take their place
comment|// in those anchors
specifier|const
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
modifier|&
name|vAdjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|v
argument_list|)
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
modifier|&
name|nextAdjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|next
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vAdjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|adjacent
init|=
name|vAdjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|adjacent
operator|!=
name|next
condition|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|v
argument_list|,
name|adjacent
argument_list|)
decl_stmt|;
name|newV
operator|->
name|m_firstAnchors
operator|.
name|append
argument_list|(
name|ad
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextAdjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|adjacent
init|=
name|nextAdjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|adjacent
operator|!=
name|v
condition|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|next
argument_list|,
name|adjacent
argument_list|)
decl_stmt|;
name|newV
operator|->
name|m_secondAnchors
operator|.
name|append
argument_list|(
name|ad
argument_list|)
expr_stmt|;
comment|// We'll also add new vertices to the adjacent list of the new 'v', to be
comment|// created as a vertex pair and replace the current one.
if|if
condition|(
operator|!
name|adjacents
operator|.
name|contains
argument_list|(
name|adjacent
argument_list|)
condition|)
name|adjacents
operator|.
name|append
argument_list|(
name|adjacent
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ### merge this loop into the ones that calculated m_firstAnchors/m_secondAnchors?
comment|// Make newV take the place of v and next
name|bool
name|feasible
init|=
name|replaceVertex
argument_list|(
name|orientation
argument_list|,
name|v
argument_list|,
name|newV
argument_list|,
name|newV
operator|->
name|m_firstAnchors
argument_list|)
decl_stmt|;
name|feasible
operator|&=
name|replaceVertex
argument_list|(
name|orientation
argument_list|,
name|next
argument_list|,
name|newV
argument_list|,
name|newV
operator|->
name|m_secondAnchors
argument_list|)
expr_stmt|;
comment|// Update the layout vertex information if one of the vertices is a layout vertex.
name|AnchorVertex
modifier|*
name|layoutVertex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|m_item
operator|==
name|q
condition|)
name|layoutVertex
operator|=
name|v
expr_stmt|;
elseif|else
if|if
condition|(
name|next
operator|->
name|m_item
operator|==
name|q
condition|)
name|layoutVertex
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|layoutVertex
condition|)
block|{
comment|// Layout vertices always have m_item == q...
name|newV
operator|->
name|m_item
operator|=
name|q
expr_stmt|;
name|changeLayoutVertex
argument_list|(
name|orientation
argument_list|,
name|layoutVertex
argument_list|,
name|newV
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|takeEdge
argument_list|(
name|v
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|// If a non-feasibility is found, we leave early and cancel the simplification
if|if
condition|(
operator|!
name|feasible
condition|)
return|return
literal|false
return|;
name|v
operator|=
name|newV
expr_stmt|;
name|visited
operator|.
name|insert
argument_list|(
name|newV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
name|stack
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|// If the adjacent is not fit for merge and it wasn't visited by the outermost
comment|// loop, we add it to the stack.
name|stack
operator|.
name|push
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      One iteration of the simplification algorithm. Returns true if another iteration is needed.      The algorithm walks the graph in depth-first order, and only collects vertices that has two     edges connected to it.  If the vertex does not have two edges or if it is a layout edge, it     will take all the previously collected vertices and try to create a simplified sequential     anchor representing all the previously collected vertices.  Once the simplified anchor is     inserted, the collected list is cleared in order to find the next sequence to simplify.      Note that there are some catches to this that are not covered by the above explanation, see     the function comments for more details. */
end_comment
begin_function
DECL|function|simplifyGraphIteration
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|simplifyGraphIteration
parameter_list|(
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Orientation
name|orientation
parameter_list|,
name|bool
modifier|*
name|feasible
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|QSet
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|visited
decl_stmt|;
name|QStack
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
name|stack
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|qMakePair
argument_list|(
cast|static_cast
argument_list|<
name|AnchorVertex
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|,
name|layoutFirstVertex
index|[
name|orientation
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|candidates
decl_stmt|;
comment|// Walk depth-first, in the stack we store start of the candidate sequence (beforeSequence)
comment|// and the vertex to be visited.
while|while
condition|(
operator|!
name|stack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
name|pair
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|AnchorVertex
modifier|*
name|beforeSequence
init|=
name|pair
operator|.
name|first
decl_stmt|;
name|AnchorVertex
modifier|*
name|v
init|=
name|pair
operator|.
name|second
decl_stmt|;
comment|// The basic idea is to determine whether we found an end of sequence,
comment|// if that's the case, we stop adding vertices to the candidate list
comment|// and do a simplification step.
comment|//
comment|// A vertex can trigger an end of sequence if
comment|// (a) it is a layout vertex, we don't simplify away the layout vertices;
comment|// (b) it does not have exactly 2 adjacents;
comment|// (c) its next adjacent is already visited (a cycle in the graph).
comment|// (d) the next anchor is a center anchor.
specifier|const
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
modifier|&
name|adjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|v
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|isLayoutVertex
init|=
name|v
operator|->
name|m_item
operator|==
name|q
decl_stmt|;
name|AnchorVertex
modifier|*
name|afterSequence
init|=
name|v
decl_stmt|;
name|bool
name|endOfSequence
init|=
literal|false
decl_stmt|;
comment|//
comment|// Identify the end cases.
comment|//
comment|// Identifies cases (a) and (b)
name|endOfSequence
operator|=
name|isLayoutVertex
operator|||
name|adjacents
operator|.
name|count
argument_list|()
operator|!=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|endOfSequence
condition|)
block|{
comment|// This is a tricky part. We peek at the next vertex to find out whether
comment|//
comment|// - we already visited the next vertex (c);
comment|// - the next anchor is a center (d).
comment|//
comment|// Those are needed to identify the remaining end of sequence cases. Note that unlike
comment|// (a) and (b), we preempt the end of sequence by looking into the next vertex.
comment|// Peek at the next vertex
name|AnchorVertex
modifier|*
name|after
decl_stmt|;
if|if
condition|(
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
name|after
operator|=
operator|(
name|beforeSequence
operator|==
name|adjacents
operator|.
name|last
argument_list|()
condition|?
name|adjacents
operator|.
name|first
argument_list|()
else|:
name|adjacents
operator|.
name|last
argument_list|()
operator|)
expr_stmt|;
else|else
name|after
operator|=
operator|(
name|candidates
operator|.
name|last
argument_list|()
operator|==
name|adjacents
operator|.
name|last
argument_list|()
condition|?
name|adjacents
operator|.
name|first
argument_list|()
else|:
name|adjacents
operator|.
name|last
argument_list|()
operator|)
expr_stmt|;
comment|// ### At this point we assumed that candidates will not contain 'after', this may not hold
comment|// when simplifying FLOATing anchors.
name|Q_ASSERT
argument_list|(
operator|!
name|candidates
operator|.
name|contains
argument_list|(
name|after
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|AnchorData
modifier|*
name|data
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|v
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|cycleFound
init|=
name|visited
operator|.
name|contains
argument_list|(
name|after
argument_list|)
decl_stmt|;
comment|// Now cases (c) and (d)...
name|endOfSequence
operator|=
name|cycleFound
operator|||
name|data
operator|->
name|isCenterAnchor
expr_stmt|;
if|if
condition|(
operator|!
name|endOfSequence
condition|)
block|{
comment|// If it's not an end of sequence, then the vertex didn't trigger neither of the
comment|// previously three cases, so it can be added to the candidates list.
name|candidates
operator|.
name|append
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cycleFound
operator|&&
operator|(
name|beforeSequence
operator|!=
name|after
operator|)
condition|)
block|{
name|afterSequence
operator|=
name|after
expr_stmt|;
name|candidates
operator|.
name|append
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Add next non-visited vertices to the stack.
comment|//
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|next
init|=
name|adjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|visited
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
comment|// If current vertex is an end of sequence, and it'll reset the candidates list. So
comment|// the next vertices will build candidates lists with the current vertex as 'before'
comment|// vertex. If it's not an end of sequence, we keep the original 'before' vertex,
comment|// since we are keeping the candidates list.
if|if
condition|(
name|endOfSequence
condition|)
name|stack
operator|.
name|push
argument_list|(
name|qMakePair
argument_list|(
name|v
argument_list|,
name|next
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stack
operator|.
name|push
argument_list|(
name|qMakePair
argument_list|(
name|beforeSequence
argument_list|,
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|visited
operator|.
name|insert
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endOfSequence
operator|||
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|//
comment|// Create a sequence for (beforeSequence, candidates, afterSequence).
comment|//
comment|// One restriction we have is to not simplify half of an anchor and let the other half
comment|// unsimplified. So we remove center edges before and after the sequence.
specifier|const
name|AnchorData
modifier|*
name|firstAnchor
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|beforeSequence
argument_list|,
name|candidates
operator|.
name|first
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstAnchor
operator|->
name|isCenterAnchor
condition|)
block|{
name|beforeSequence
operator|=
name|candidates
operator|.
name|first
argument_list|()
expr_stmt|;
name|candidates
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// If there's not candidates to be simplified, leave.
if|if
condition|(
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
block|}
specifier|const
name|AnchorData
modifier|*
name|lastAnchor
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|candidates
operator|.
name|last
argument_list|()
argument_list|,
name|afterSequence
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAnchor
operator|->
name|isCenterAnchor
condition|)
block|{
name|afterSequence
operator|=
name|candidates
operator|.
name|last
argument_list|()
expr_stmt|;
name|candidates
operator|.
name|remove
argument_list|(
name|candidates
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
block|}
comment|//
comment|// Add the sequence to the graph.
comment|//
name|AnchorData
modifier|*
name|sequence
init|=
name|createSequence
argument_list|(
operator|&
name|g
argument_list|,
name|beforeSequence
argument_list|,
name|candidates
argument_list|,
name|afterSequence
argument_list|)
decl_stmt|;
comment|// If 'beforeSequence' and 'afterSequence' already had an anchor between them, we'll
comment|// create a parallel anchor between the new sequence and the old anchor.
name|bool
name|newFeasible
decl_stmt|;
name|AnchorData
modifier|*
name|newAnchor
init|=
name|addAnchorMaybeParallel
argument_list|(
name|sequence
argument_list|,
operator|&
name|newFeasible
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newFeasible
condition|)
block|{
operator|*
name|feasible
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// When a new parallel anchor is create in the graph, we finish the iteration and return
comment|// true to indicate a new iteration is needed. This happens because a parallel anchor
comment|// changes the number of adjacents one vertex has, possibly opening up oportunities for
comment|// building candidate lists (when adjacents == 2).
if|if
condition|(
name|newAnchor
operator|!=
name|sequence
condition|)
return|return
literal|true
return|;
comment|// If there was no parallel simplification, we'll keep walking the graph. So we clear the
comment|// candidates list to start again.
name|candidates
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|restoreSimplifiedAnchor
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|restoreSimplifiedAnchor
parameter_list|(
name|AnchorData
modifier|*
name|edge
parameter_list|)
block|{
if|#
directive|if
literal|0
block|static const char *anchortypes[] = {"Normal",                                         "Sequential",                                         "Parallel"};     qDebug("Restoring %s edge.", anchortypes[int(edge->type)]);
endif|#
directive|endif
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|edge
operator|->
name|orientation
index|]
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Normal
condition|)
block|{
name|g
operator|.
name|createEdge
argument_list|(
name|edge
operator|->
name|from
argument_list|,
name|edge
operator|->
name|to
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Sequential
condition|)
block|{
name|SequentialAnchorData
modifier|*
name|sequence
init|=
cast|static_cast
argument_list|<
name|SequentialAnchorData
operator|*
argument_list|>
argument_list|(
name|edge
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|->
name|m_edges
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|data
init|=
name|sequence
operator|->
name|m_edges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|restoreSimplifiedAnchor
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
operator|delete
name|sequence
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Parallel
condition|)
block|{
comment|// Skip parallel anchors that were created by vertex simplification, they will be processed
comment|// later, when restoring vertex simplification.
comment|// ### we could improve this check bit having a bit inside 'edge'
if|if
condition|(
name|anchorsFromSimplifiedVertices
index|[
name|edge
operator|->
name|orientation
index|]
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
condition|)
return|return;
name|ParallelAnchorData
modifier|*
name|parallel
init|=
cast|static_cast
argument_list|<
name|ParallelAnchorData
operator|*
argument_list|>
argument_list|(
name|edge
argument_list|)
decl_stmt|;
name|restoreSimplifiedConstraints
argument_list|(
name|parallel
argument_list|)
expr_stmt|;
comment|// ### Because of the way parallel anchors are created in the anchor simplification
comment|// algorithm, we know that one of these will be a sequence, so it'll be safe if the other
comment|// anchor create an edge between the same vertices as the parallel.
name|Q_ASSERT
argument_list|(
name|parallel
operator|->
name|firstEdge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Sequential
operator|||
name|parallel
operator|->
name|secondEdge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Sequential
argument_list|)
expr_stmt|;
name|restoreSimplifiedAnchor
argument_list|(
name|parallel
operator|->
name|firstEdge
argument_list|)
expr_stmt|;
name|restoreSimplifiedAnchor
argument_list|(
name|parallel
operator|->
name|secondEdge
argument_list|)
expr_stmt|;
operator|delete
name|parallel
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|restoreSimplifiedConstraints
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|restoreSimplifiedConstraints
parameter_list|(
name|ParallelAnchorData
modifier|*
name|parallel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parallel
operator|->
name|isCenterAnchor
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parallel
operator|->
name|m_firstConstraints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
name|parallel
operator|->
name|m_firstConstraints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qreal
name|v
init|=
name|c
operator|->
name|variables
index|[
name|parallel
index|]
decl_stmt|;
name|c
operator|->
name|variables
operator|.
name|remove
argument_list|(
name|parallel
argument_list|)
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|parallel
operator|->
name|firstEdge
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|// When restoring, we might have to revert constraints back. See comments on
comment|// addAnchorMaybeParallel().
specifier|const
name|bool
name|needsReverse
init|=
operator|!
name|parallel
operator|->
name|secondForward
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parallel
operator|->
name|m_secondConstraints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
name|parallel
operator|->
name|m_secondConstraints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qreal
name|v
init|=
name|c
operator|->
name|variables
index|[
name|parallel
index|]
decl_stmt|;
if|if
condition|(
name|needsReverse
condition|)
name|v
operator|*=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|remove
argument_list|(
name|parallel
argument_list|)
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|parallel
operator|->
name|secondEdge
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|restoreSimplifiedGraph
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|restoreSimplifiedGraph
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
if|#
directive|if
literal|0
block|qDebug("Restoring Simplified Graph for %s",            orientation == Horizontal ? "Horizontal" : "Vertical");
endif|#
directive|endif
comment|// Restore anchor simplification
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
name|connections
init|=
name|g
operator|.
name|connections
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|connections
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|v1
init|=
name|connections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
decl_stmt|;
name|AnchorVertex
modifier|*
name|v2
init|=
name|connections
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
decl_stmt|;
name|AnchorData
modifier|*
name|edge
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
comment|// We restore only sequential anchors and parallels that were not created by
comment|// vertex simplification.
if|if
condition|(
name|edge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Sequential
operator|||
operator|(
name|edge
operator|->
name|type
operator|==
name|AnchorData
operator|::
name|Parallel
operator|&&
operator|!
name|anchorsFromSimplifiedVertices
index|[
name|orientation
index|]
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
operator|)
condition|)
block|{
name|g
operator|.
name|takeEdge
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|restoreSimplifiedAnchor
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
block|}
name|restoreVertices
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restoreVertices
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|restoreVertices
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|QList
argument_list|<
name|AnchorVertexPair
modifier|*
argument_list|>
modifier|&
name|toRestore
init|=
name|simplifiedVertices
index|[
name|orientation
index|]
decl_stmt|;
comment|// Since we keep a list of parallel anchors and vertices that were created during vertex
comment|// simplification, we can now iterate on those lists instead of traversing the graph
comment|// recursively.
comment|// First, restore the constraints changed when we created parallel anchors. Note that this
comment|// works at this point because the constraints doesn't depend on vertex information and at
comment|// this point it's always safe to identify whether the second child is forward or backwards.
comment|// In the next step, we'll change the anchors vertices so that would not be possible anymore.
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|parallelAnchors
init|=
name|anchorsFromSimplifiedVertices
index|[
name|orientation
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|parallelAnchors
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ParallelAnchorData
modifier|*
name|parallel
init|=
cast|static_cast
argument_list|<
name|ParallelAnchorData
operator|*
argument_list|>
argument_list|(
name|parallelAnchors
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|restoreSimplifiedConstraints
argument_list|(
name|parallel
argument_list|)
expr_stmt|;
block|}
comment|// Then, we will restore the vertices in the inverse order of creation, this way we ensure that
comment|// the vertex being restored was not wrapped by another simplification.
for|for
control|(
name|int
name|i
init|=
name|toRestore
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|AnchorVertexPair
modifier|*
name|pair
init|=
name|toRestore
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|adjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|pair
argument_list|)
decl_stmt|;
comment|// Restore the removed edge, this will also restore both vertices 'first' and 'second' to
comment|// the graph structure.
name|AnchorVertex
modifier|*
name|first
init|=
name|pair
operator|->
name|m_first
decl_stmt|;
name|AnchorVertex
modifier|*
name|second
init|=
name|pair
operator|->
name|m_second
decl_stmt|;
name|g
operator|.
name|createEdge
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|pair
operator|->
name|m_removedAnchor
argument_list|)
expr_stmt|;
comment|// Restore the anchors for the first child vertex
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pair
operator|->
name|m_firstAnchors
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|pair
operator|->
name|m_firstAnchors
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ad
operator|->
name|from
operator|==
name|pair
operator|||
name|ad
operator|->
name|to
operator|==
name|pair
argument_list|)
expr_stmt|;
name|replaceVertex_helper
argument_list|(
name|ad
argument_list|,
name|pair
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|g
operator|.
name|createEdge
argument_list|(
name|ad
operator|->
name|from
argument_list|,
name|ad
operator|->
name|to
argument_list|,
name|ad
argument_list|)
expr_stmt|;
block|}
comment|// Restore the anchors for the second child vertex
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pair
operator|->
name|m_secondAnchors
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|pair
operator|->
name|m_secondAnchors
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ad
operator|->
name|from
operator|==
name|pair
operator|||
name|ad
operator|->
name|to
operator|==
name|pair
argument_list|)
expr_stmt|;
name|replaceVertex_helper
argument_list|(
name|ad
argument_list|,
name|pair
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|g
operator|.
name|createEdge
argument_list|(
name|ad
operator|->
name|from
argument_list|,
name|ad
operator|->
name|to
argument_list|,
name|ad
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|adjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|g
operator|.
name|takeEdge
argument_list|(
name|pair
argument_list|,
name|adjacents
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// The pair simplified a layout vertex, so place back the correct vertex in the variable
comment|// that track layout vertices
if|if
condition|(
name|pair
operator|->
name|m_item
operator|==
name|q
condition|)
block|{
name|AnchorVertex
modifier|*
name|layoutVertex
init|=
name|first
operator|->
name|m_item
operator|==
name|q
condition|?
name|first
else|:
name|second
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layoutVertex
operator|->
name|m_item
operator|==
name|q
argument_list|)
expr_stmt|;
name|changeLayoutVertex
argument_list|(
name|orientation
argument_list|,
name|pair
argument_list|,
name|layoutVertex
argument_list|)
expr_stmt|;
block|}
operator|delete
name|pair
expr_stmt|;
block|}
name|qDeleteAll
argument_list|(
name|parallelAnchors
argument_list|)
expr_stmt|;
name|parallelAnchors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|toRestore
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Orientation
DECL|function|edgeOrientation
name|QGraphicsAnchorLayoutPrivate
operator|::
name|edgeOrientation
parameter_list|(
name|Qt
operator|::
name|AnchorPoint
name|edge
parameter_list|)
block|{
return|return
name|edge
operator|>
name|Qt
operator|::
name|AnchorRight
condition|?
name|Vertical
else|:
name|Horizontal
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Create internal anchors to connect the layout edges (Left to Right and   Top to Bottom).    These anchors doesn't have size restrictions, that will be enforced by   other anchors and items in the layout. */
end_comment
begin_function
DECL|function|createLayoutEdges
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|createLayoutEdges
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|QGraphicsLayoutItem
modifier|*
name|layout
init|=
name|q
decl_stmt|;
comment|// Horizontal
name|AnchorData
modifier|*
name|data
init|=
operator|new
name|AnchorData
decl_stmt|;
name|addAnchor_helper
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|,
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|maxSize
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
comment|// Save a reference to layout vertices
name|layoutFirstVertex
index|[
name|Horizontal
index|]
operator|=
name|internalVertex
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|)
expr_stmt|;
name|layoutCentralVertex
index|[
name|Horizontal
index|]
operator|=
literal|0
expr_stmt|;
name|layoutLastVertex
index|[
name|Horizontal
index|]
operator|=
name|internalVertex
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|)
expr_stmt|;
comment|// Vertical
name|data
operator|=
operator|new
name|AnchorData
expr_stmt|;
name|addAnchor_helper
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|,
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|maxSize
operator|=
name|QWIDGETSIZE_MAX
expr_stmt|;
comment|// Save a reference to layout vertices
name|layoutFirstVertex
index|[
name|Vertical
index|]
operator|=
name|internalVertex
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|)
expr_stmt|;
name|layoutCentralVertex
index|[
name|Vertical
index|]
operator|=
literal|0
expr_stmt|;
name|layoutLastVertex
index|[
name|Vertical
index|]
operator|=
name|internalVertex
argument_list|(
name|layout
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deleteLayoutEdges
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|deleteLayoutEdges
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorHorizontalCenter
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorVerticalCenter
argument_list|)
argument_list|)
expr_stmt|;
name|removeAnchor_helper
argument_list|(
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|)
argument_list|,
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|)
argument_list|)
expr_stmt|;
name|removeAnchor_helper
argument_list|(
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|)
argument_list|,
name|internalVertex
argument_list|(
name|q
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createItemEdges
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|createItemEdges
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|)
block|{
name|items
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Create horizontal and vertical internal anchors for the item and
comment|// refresh its size hint / policy values.
name|AnchorData
modifier|*
name|data
init|=
operator|new
name|AnchorData
decl_stmt|;
name|addAnchor_helper
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|,
name|item
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|AnchorData
expr_stmt|;
name|addAnchor_helper
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|,
name|item
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    By default, each item in the layout is represented internally as   a single anchor in each direction. For instance, from Left to Right.    However, to support anchorage of items to the center of items, we   must split this internal anchor into two half-anchors. From Left   to Center and then from Center to Right, with the restriction that   these anchors must have the same time at all times. */
end_comment
begin_function
DECL|function|createCenterAnchors
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|createCenterAnchors
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|centerEdge
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Orientation
name|orientation
decl_stmt|;
switch|switch
condition|(
name|centerEdge
condition|)
block|{
case|case
name|Qt
operator|::
name|AnchorHorizontalCenter
case|:
name|orientation
operator|=
name|Horizontal
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AnchorVerticalCenter
case|:
name|orientation
operator|=
name|Vertical
expr_stmt|;
break|break;
default|default:
comment|// Don't create center edges unless needed
return|return;
block|}
comment|// Check if vertex already exists
if|if
condition|(
name|internalVertex
argument_list|(
name|item
argument_list|,
name|centerEdge
argument_list|)
condition|)
return|return;
comment|// Orientation code
name|Qt
operator|::
name|AnchorPoint
name|firstEdge
decl_stmt|;
name|Qt
operator|::
name|AnchorPoint
name|lastEdge
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Horizontal
condition|)
block|{
name|firstEdge
operator|=
name|Qt
operator|::
name|AnchorLeft
expr_stmt|;
name|lastEdge
operator|=
name|Qt
operator|::
name|AnchorRight
expr_stmt|;
block|}
else|else
block|{
name|firstEdge
operator|=
name|Qt
operator|::
name|AnchorTop
expr_stmt|;
name|lastEdge
operator|=
name|Qt
operator|::
name|AnchorBottom
expr_stmt|;
block|}
name|AnchorVertex
modifier|*
name|first
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|firstEdge
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|last
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|lastEdge
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|&&
name|last
argument_list|)
expr_stmt|;
comment|// Create new anchors
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|AnchorData
modifier|*
name|data
init|=
operator|new
name|AnchorData
decl_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|data
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|addAnchor_helper
argument_list|(
name|item
argument_list|,
name|firstEdge
argument_list|,
name|item
argument_list|,
name|centerEdge
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|isCenterAnchor
operator|=
literal|true
expr_stmt|;
name|data
operator|->
name|dependency
operator|=
name|AnchorData
operator|::
name|Master
expr_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|()
expr_stmt|;
name|data
operator|=
operator|new
name|AnchorData
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|data
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|addAnchor_helper
argument_list|(
name|item
argument_list|,
name|centerEdge
argument_list|,
name|item
argument_list|,
name|lastEdge
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|isCenterAnchor
operator|=
literal|true
expr_stmt|;
name|data
operator|->
name|dependency
operator|=
name|AnchorData
operator|::
name|Slave
expr_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|()
expr_stmt|;
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// Remove old one
name|removeAnchor_helper
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|q
condition|)
block|{
name|layoutCentralVertex
index|[
name|orientation
index|]
operator|=
name|internalVertex
argument_list|(
name|q
argument_list|,
name|centerEdge
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|removeCenterAnchors
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeCenterAnchors
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|centerEdge
parameter_list|,
name|bool
name|substitute
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|Orientation
name|orientation
decl_stmt|;
switch|switch
condition|(
name|centerEdge
condition|)
block|{
case|case
name|Qt
operator|::
name|AnchorHorizontalCenter
case|:
name|orientation
operator|=
name|Horizontal
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AnchorVerticalCenter
case|:
name|orientation
operator|=
name|Vertical
expr_stmt|;
break|break;
default|default:
comment|// Don't remove edges that not the center ones
return|return;
block|}
comment|// Orientation code
name|Qt
operator|::
name|AnchorPoint
name|firstEdge
decl_stmt|;
name|Qt
operator|::
name|AnchorPoint
name|lastEdge
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Horizontal
condition|)
block|{
name|firstEdge
operator|=
name|Qt
operator|::
name|AnchorLeft
expr_stmt|;
name|lastEdge
operator|=
name|Qt
operator|::
name|AnchorRight
expr_stmt|;
block|}
else|else
block|{
name|firstEdge
operator|=
name|Qt
operator|::
name|AnchorTop
expr_stmt|;
name|lastEdge
operator|=
name|Qt
operator|::
name|AnchorBottom
expr_stmt|;
block|}
name|AnchorVertex
modifier|*
name|center
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|centerEdge
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|center
condition|)
return|return;
name|AnchorVertex
modifier|*
name|first
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|firstEdge
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|center
argument_list|)
expr_stmt|;
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|AnchorData
modifier|*
name|oldData
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|first
argument_list|,
name|center
argument_list|)
decl_stmt|;
comment|// Remove center constraint
for|for
control|(
name|int
name|i
init|=
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|variables
operator|.
name|contains
argument_list|(
name|oldData
argument_list|)
condition|)
block|{
operator|delete
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|substitute
condition|)
block|{
comment|// Create the new anchor that should substitute the left-center-right anchors.
name|AnchorData
modifier|*
name|data
init|=
operator|new
name|AnchorData
decl_stmt|;
name|addAnchor_helper
argument_list|(
name|item
argument_list|,
name|firstEdge
argument_list|,
name|item
argument_list|,
name|lastEdge
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|()
expr_stmt|;
comment|// Remove old anchors
name|removeAnchor_helper
argument_list|(
name|first
argument_list|,
name|center
argument_list|)
expr_stmt|;
name|removeAnchor_helper
argument_list|(
name|center
argument_list|,
name|internalVertex
argument_list|(
name|item
argument_list|,
name|lastEdge
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this is only called from removeAnchors()
comment|// first, remove all non-internal anchors
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|adjacents
init|=
name|g
operator|.
name|adjacentVertices
argument_list|(
name|center
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorVertex
modifier|*
name|v
init|=
name|adjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|m_item
operator|!=
name|item
condition|)
block|{
name|removeAnchor_helper
argument_list|(
name|center
argument_list|,
name|internalVertex
argument_list|(
name|v
operator|->
name|m_item
argument_list|,
name|v
operator|->
name|m_edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// when all non-internal anchors is removed it will automatically merge the
comment|// center anchor into a left-right (or top-bottom) anchor. We must also delete that.
comment|// by this time, the center vertex is deleted and merged into a non-centered internal anchor
name|removeAnchor_helper
argument_list|(
name|first
argument_list|,
name|internalVertex
argument_list|(
name|item
argument_list|,
name|lastEdge
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|q
condition|)
block|{
name|layoutCentralVertex
index|[
name|orientation
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|removeCenterConstraints
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeCenterConstraints
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
comment|// Remove the item center constraints associated to this item
comment|// ### This is a temporary solution. We should probably use a better
comment|// data structure to hold items and/or their associated constraints
comment|// so that we can remove those easily
name|AnchorVertex
modifier|*
name|first
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|orientation
operator|==
name|Horizontal
condition|?
name|Qt
operator|::
name|AnchorLeft
else|:
name|Qt
operator|::
name|AnchorTop
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|center
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|orientation
operator|==
name|Horizontal
condition|?
name|Qt
operator|::
name|AnchorHorizontalCenter
else|:
name|Qt
operator|::
name|AnchorVerticalCenter
argument_list|)
decl_stmt|;
comment|// Skip if no center constraints exist
if|if
condition|(
operator|!
name|center
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|AnchorData
modifier|*
name|internalAnchor
init|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|first
argument_list|,
name|center
argument_list|)
decl_stmt|;
comment|// Look for our anchor in all item center constraints, then remove it
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|variables
operator|.
name|contains
argument_list|(
name|internalAnchor
argument_list|)
condition|)
block|{
operator|delete
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!  * \internal  * Implements the high level "addAnchor" feature. Called by the public API  * addAnchor method.  *  * The optional \a spacing argument defines the size of the anchor. If not provided,  * the anchor size is either 0 or not-set, depending on type of anchor created (see  * matrix below).  *  * All anchors that remain with size not-set will assume the standard spacing,  * set either by the layout style or through the "setSpacing" layout API.  */
end_comment
begin_function
DECL|function|addAnchor
name|QGraphicsAnchor
modifier|*
name|QGraphicsAnchorLayoutPrivate
operator|::
name|addAnchor
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|firstItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|firstEdge
parameter_list|,
name|QGraphicsLayoutItem
modifier|*
name|secondItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|secondEdge
parameter_list|,
name|qreal
modifier|*
name|spacing
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firstItem
operator|==
literal|0
operator|)
operator|||
operator|(
name|secondItem
operator|==
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchorLayout::addAnchor(): "
literal|"Cannot anchor NULL items"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|firstItem
operator|==
name|secondItem
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchorLayout::addAnchor(): "
literal|"Cannot anchor the item to itself"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|edgeOrientation
argument_list|(
name|secondEdge
argument_list|)
operator|!=
name|edgeOrientation
argument_list|(
name|firstEdge
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchorLayout::addAnchor(): "
literal|"Cannot anchor edges of different orientations"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|const
name|QGraphicsLayoutItem
modifier|*
name|parentWidget
init|=
name|q
operator|->
name|parentLayoutItem
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstItem
operator|==
name|parentWidget
operator|||
name|secondItem
operator|==
name|parentWidget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchorLayout::addAnchor(): "
literal|"You cannot add the parent of the layout to the layout."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// In QGraphicsAnchorLayout, items are represented in its internal
comment|// graph as four anchors that connect:
comment|//  - Left -> HCenter
comment|//  - HCenter-> Right
comment|//  - Top -> VCenter
comment|//  - VCenter -> Bottom
comment|// Ensure that the internal anchors have been created for both items.
if|if
condition|(
name|firstItem
operator|!=
name|q
operator|&&
operator|!
name|items
operator|.
name|contains
argument_list|(
name|firstItem
argument_list|)
condition|)
block|{
name|createItemEdges
argument_list|(
name|firstItem
argument_list|)
expr_stmt|;
name|addChildLayoutItem
argument_list|(
name|firstItem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secondItem
operator|!=
name|q
operator|&&
operator|!
name|items
operator|.
name|contains
argument_list|(
name|secondItem
argument_list|)
condition|)
block|{
name|createItemEdges
argument_list|(
name|secondItem
argument_list|)
expr_stmt|;
name|addChildLayoutItem
argument_list|(
name|secondItem
argument_list|)
expr_stmt|;
block|}
comment|// Create center edges if needed
name|createCenterAnchors
argument_list|(
name|firstItem
argument_list|,
name|firstEdge
argument_list|)
expr_stmt|;
name|createCenterAnchors
argument_list|(
name|secondItem
argument_list|,
name|secondEdge
argument_list|)
expr_stmt|;
comment|// Use heuristics to find out what the user meant with this anchor.
name|correctEdgeDirection
argument_list|(
name|firstItem
argument_list|,
name|firstEdge
argument_list|,
name|secondItem
argument_list|,
name|secondEdge
argument_list|)
expr_stmt|;
name|AnchorData
modifier|*
name|data
init|=
operator|new
name|AnchorData
decl_stmt|;
name|QGraphicsAnchor
modifier|*
name|graphicsAnchor
init|=
name|acquireGraphicsAnchor
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|addAnchor_helper
argument_list|(
name|firstItem
argument_list|,
name|firstEdge
argument_list|,
name|secondItem
argument_list|,
name|secondEdge
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|spacing
condition|)
block|{
name|graphicsAnchor
operator|->
name|setSpacing
argument_list|(
operator|*
name|spacing
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If firstItem or secondItem is the layout itself, the spacing will default to 0.
comment|// Otherwise, the following matrix is used (questionmark means that the spacing
comment|// is queried from the style):
comment|//                from
comment|//  to      Left    HCenter Right
comment|//  Left    0       0       ?
comment|//  HCenter 0       0       0
comment|//  Right   ?       0       0
if|if
condition|(
name|firstItem
operator|==
name|q
operator|||
name|secondItem
operator|==
name|q
operator|||
name|pickEdge
argument_list|(
name|firstEdge
argument_list|,
name|Horizontal
argument_list|)
operator|==
name|Qt
operator|::
name|AnchorHorizontalCenter
operator|||
name|oppositeEdge
argument_list|(
name|firstEdge
argument_list|)
operator|!=
name|secondEdge
condition|)
block|{
name|graphicsAnchor
operator|->
name|setSpacing
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|graphicsAnchor
operator|->
name|unsetSpacing
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|graphicsAnchor
return|;
block|}
end_function
begin_comment
comment|/*   \internal    This method adds an AnchorData to the internal graph. It is responsible for doing   the boilerplate part of such task.    If another AnchorData exists between the mentioned vertices, it is deleted and   the new one is inserted. */
end_comment
begin_function
DECL|function|addAnchor_helper
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|addAnchor_helper
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|firstItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|firstEdge
parameter_list|,
name|QGraphicsLayoutItem
modifier|*
name|secondItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|secondEdge
parameter_list|,
name|AnchorData
modifier|*
name|data
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
specifier|const
name|Orientation
name|orientation
init|=
name|edgeOrientation
argument_list|(
name|firstEdge
argument_list|)
decl_stmt|;
comment|// Create or increase the reference count for the related vertices.
name|AnchorVertex
modifier|*
name|v1
init|=
name|addInternalVertex
argument_list|(
name|firstItem
argument_list|,
name|firstEdge
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|v2
init|=
name|addInternalVertex
argument_list|(
name|secondItem
argument_list|,
name|secondEdge
argument_list|)
decl_stmt|;
comment|// Remove previous anchor
if|if
condition|(
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
condition|)
block|{
name|removeAnchor_helper
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
comment|// If its an internal anchor, set the associated item
if|if
condition|(
name|firstItem
operator|==
name|secondItem
condition|)
name|data
operator|->
name|item
operator|=
name|firstItem
expr_stmt|;
name|data
operator|->
name|orientation
operator|=
name|orientation
expr_stmt|;
comment|// Create a bi-directional edge in the sense it can be transversed both
comment|// from v1 or v2. "data" however is shared between the two references
comment|// so we still know that the anchor direction is from 1 to 2.
name|data
operator|->
name|from
operator|=
name|v1
expr_stmt|;
name|data
operator|->
name|to
operator|=
name|v2
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_DEBUG
name|data
operator|->
name|name
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1 --to--> %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|v1
operator|->
name|toString
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|v2
operator|->
name|toString
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// ### bit to track internal anchors, since inside AnchorData methods
comment|// we don't have access to the 'q' pointer.
name|data
operator|->
name|isLayoutAnchor
operator|=
operator|(
name|data
operator|->
name|item
operator|==
name|q
operator|)
expr_stmt|;
name|graph
index|[
name|orientation
index|]
operator|.
name|createEdge
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getAnchor
name|QGraphicsAnchor
modifier|*
name|QGraphicsAnchorLayoutPrivate
operator|::
name|getAnchor
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|firstItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|firstEdge
parameter_list|,
name|QGraphicsLayoutItem
modifier|*
name|secondItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|secondEdge
parameter_list|)
block|{
comment|// Do not expose internal anchors
if|if
condition|(
name|firstItem
operator|==
name|secondItem
condition|)
return|return
literal|0
return|;
specifier|const
name|Orientation
name|orientation
init|=
name|edgeOrientation
argument_list|(
name|firstEdge
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|v1
init|=
name|internalVertex
argument_list|(
name|firstItem
argument_list|,
name|firstEdge
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|v2
init|=
name|internalVertex
argument_list|(
name|secondItem
argument_list|,
name|secondEdge
argument_list|)
decl_stmt|;
name|QGraphicsAnchor
modifier|*
name|graphicsAnchor
init|=
literal|0
decl_stmt|;
name|AnchorData
modifier|*
name|data
init|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
condition|)
block|{
comment|// We could use "acquireGraphicsAnchor" here, but to avoid a regression where
comment|// an internal anchor was wrongly exposed, I want to ensure no new
comment|// QGraphicsAnchor instances are created by this call.
comment|// This assumption must hold because anchors are either user-created (and already
comment|// have their public object created), or they are internal (and must not reach
comment|// this point).
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|graphicsAnchor
argument_list|)
expr_stmt|;
name|graphicsAnchor
operator|=
name|data
operator|->
name|graphicsAnchor
expr_stmt|;
block|}
return|return
name|graphicsAnchor
return|;
block|}
end_function
begin_comment
comment|/*!  * \internal  *  * Implements the high level "removeAnchor" feature. Called by  * the QAnchorData destructor.  */
end_comment
begin_function
DECL|function|removeAnchor
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeAnchor
parameter_list|(
name|AnchorVertex
modifier|*
name|firstVertex
parameter_list|,
name|AnchorVertex
modifier|*
name|secondVertex
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
comment|// Save references to items while it's safe to assume the vertices exist
name|QGraphicsLayoutItem
modifier|*
name|firstItem
init|=
name|firstVertex
operator|->
name|m_item
decl_stmt|;
name|QGraphicsLayoutItem
modifier|*
name|secondItem
init|=
name|secondVertex
operator|->
name|m_item
decl_stmt|;
comment|// Delete the anchor (may trigger deletion of center vertices)
name|removeAnchor_helper
argument_list|(
name|firstVertex
argument_list|,
name|secondVertex
argument_list|)
expr_stmt|;
comment|// Ensure no dangling pointer is left behind
name|firstVertex
operator|=
name|secondVertex
operator|=
literal|0
expr_stmt|;
comment|// Checking if the item stays in the layout or not
name|bool
name|keepFirstItem
init|=
literal|false
decl_stmt|;
name|bool
name|keepSecondItem
init|=
literal|false
decl_stmt|;
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|int
argument_list|>
name|v
decl_stmt|;
name|int
name|refcount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|firstItem
operator|!=
name|q
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|Qt
operator|::
name|AnchorLeft
init|;
name|i
operator|<=
name|Qt
operator|::
name|AnchorBottom
condition|;
operator|++
name|i
control|)
block|{
name|v
operator|=
name|m_vertexList
operator|.
name|value
argument_list|(
name|qMakePair
argument_list|(
name|firstItem
argument_list|,
cast|static_cast
argument_list|<
name|Qt
operator|::
name|AnchorPoint
argument_list|>
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|first
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|Qt
operator|::
name|AnchorHorizontalCenter
operator|||
name|i
operator|==
name|Qt
operator|::
name|AnchorVerticalCenter
condition|)
name|refcount
operator|=
literal|2
expr_stmt|;
else|else
name|refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|second
operator|>
name|refcount
condition|)
block|{
name|keepFirstItem
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|keepFirstItem
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|secondItem
operator|!=
name|q
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|Qt
operator|::
name|AnchorLeft
init|;
name|i
operator|<=
name|Qt
operator|::
name|AnchorBottom
condition|;
operator|++
name|i
control|)
block|{
name|v
operator|=
name|m_vertexList
operator|.
name|value
argument_list|(
name|qMakePair
argument_list|(
name|secondItem
argument_list|,
cast|static_cast
argument_list|<
name|Qt
operator|::
name|AnchorPoint
argument_list|>
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|first
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|Qt
operator|::
name|AnchorHorizontalCenter
operator|||
name|i
operator|==
name|Qt
operator|::
name|AnchorVerticalCenter
condition|)
name|refcount
operator|=
literal|2
expr_stmt|;
else|else
name|refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|second
operator|>
name|refcount
condition|)
block|{
name|keepSecondItem
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|keepSecondItem
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|keepFirstItem
condition|)
name|q
operator|->
name|removeAt
argument_list|(
name|items
operator|.
name|indexOf
argument_list|(
name|firstItem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keepSecondItem
condition|)
name|q
operator|->
name|removeAt
argument_list|(
name|items
operator|.
name|indexOf
argument_list|(
name|secondItem
argument_list|)
argument_list|)
expr_stmt|;
comment|// Removing anchors invalidates the layout
name|q
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   \internal    Implements the low level "removeAnchor" feature. Called by   private methods. */
end_comment
begin_function
DECL|function|removeAnchor_helper
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeAnchor_helper
parameter_list|(
name|AnchorVertex
modifier|*
name|v1
parameter_list|,
name|AnchorVertex
modifier|*
name|v2
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|v1
operator|&&
name|v2
argument_list|)
expr_stmt|;
comment|// Remove edge from graph
specifier|const
name|Orientation
name|o
init|=
name|edgeOrientation
argument_list|(
name|v1
operator|->
name|m_edge
argument_list|)
decl_stmt|;
name|graph
index|[
name|o
index|]
operator|.
name|removeEdge
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
comment|// Decrease vertices reference count (may trigger a deletion)
name|removeInternalVertex
argument_list|(
name|v1
operator|->
name|m_item
argument_list|,
name|v1
operator|->
name|m_edge
argument_list|)
expr_stmt|;
name|removeInternalVertex
argument_list|(
name|v2
operator|->
name|m_item
argument_list|,
name|v2
operator|->
name|m_edge
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addInternalVertex
name|AnchorVertex
modifier|*
name|QGraphicsAnchorLayoutPrivate
operator|::
name|addInternalVertex
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|edge
parameter_list|)
block|{
name|QPair
argument_list|<
name|QGraphicsLayoutItem
modifier|*
argument_list|,
name|Qt
operator|::
name|AnchorPoint
argument_list|>
name|pair
argument_list|(
name|item
argument_list|,
name|edge
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|int
argument_list|>
name|v
init|=
name|m_vertexList
operator|.
name|value
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|first
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|v
operator|.
name|second
operator|==
literal|0
argument_list|)
expr_stmt|;
name|v
operator|.
name|first
operator|=
operator|new
name|AnchorVertex
argument_list|(
name|item
argument_list|,
name|edge
argument_list|)
expr_stmt|;
block|}
name|v
operator|.
name|second
operator|++
expr_stmt|;
name|m_vertexList
operator|.
name|insert
argument_list|(
name|pair
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|first
return|;
block|}
end_function
begin_comment
comment|/**  * \internal  *  * returns the AnchorVertex that was dereferenced, also when it was removed.  * returns 0 if it did not exist.  */
end_comment
begin_function
DECL|function|removeInternalVertex
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeInternalVertex
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|edge
parameter_list|)
block|{
name|QPair
argument_list|<
name|QGraphicsLayoutItem
modifier|*
argument_list|,
name|Qt
operator|::
name|AnchorPoint
argument_list|>
name|pair
argument_list|(
name|item
argument_list|,
name|edge
argument_list|)
decl_stmt|;
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|int
argument_list|>
name|v
init|=
name|m_vertexList
operator|.
name|value
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|first
condition|)
block|{
name|qWarning
argument_list|(
literal|"This item with this edge is not in the graph"
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|.
name|second
operator|--
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|second
operator|==
literal|0
condition|)
block|{
comment|// Remove reference and delete vertex
name|m_vertexList
operator|.
name|remove
argument_list|(
name|pair
argument_list|)
expr_stmt|;
operator|delete
name|v
operator|.
name|first
expr_stmt|;
block|}
else|else
block|{
comment|// Update reference count
name|m_vertexList
operator|.
name|insert
argument_list|(
name|pair
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|.
name|second
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|edge
operator|==
name|Qt
operator|::
name|AnchorHorizontalCenter
operator|)
operator|||
operator|(
name|edge
operator|==
name|Qt
operator|::
name|AnchorVerticalCenter
operator|)
operator|)
condition|)
block|{
name|removeCenterAnchors
argument_list|(
name|item
argument_list|,
name|edge
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|removeVertex
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeVertex
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
name|edge
parameter_list|)
block|{
if|if
condition|(
name|AnchorVertex
modifier|*
name|v
init|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|edge
argument_list|)
condition|)
block|{
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|edgeOrientation
argument_list|(
name|edge
argument_list|)
index|]
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|allVertices
init|=
name|graph
index|[
name|edgeOrientation
argument_list|(
name|edge
argument_list|)
index|]
operator|.
name|adjacentVertices
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|AnchorVertex
modifier|*
name|v2
decl_stmt|;
foreach|foreach
control|(
name|v2
init|,
name|allVertices
control|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|removeInternalVertex
argument_list|(
name|item
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|removeInternalVertex
argument_list|(
name|v2
operator|->
name|m_item
argument_list|,
name|v2
operator|->
name|m_edge
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|removeAnchors
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|removeAnchors
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
name|item
parameter_list|)
block|{
comment|// remove the center anchor first!!
name|removeCenterAnchors
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorHorizontalCenter
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|removeVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|)
expr_stmt|;
name|removeVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|)
expr_stmt|;
name|removeCenterAnchors
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorVerticalCenter
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|removeVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|)
expr_stmt|;
name|removeVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Use heuristics to determine the correct orientation of a given anchor.    After API discussions, we decided we would like expressions like   anchor(A, Left, B, Right) to mean the same as anchor(B, Right, A, Left).   The problem with this is that anchors could become ambiguous, for   instance, what does the anchor A, B of size X mean?       "pos(B) = pos(A) + X"  or  "pos(A) = pos(B) + X" ?    To keep the API user friendly and at the same time, keep our algorithm   deterministic, we use an heuristic to determine a direction for each   added anchor and then keep it. The heuristic is based on the fact   that people usually avoid overlapping items, therefore:       "A, RIGHT to B, LEFT" means that B is to the LEFT of A.      "B, LEFT to A, RIGHT" is corrected to the above anchor.    Special correction is also applied when one of the items is the   layout. We handle Layout Left as if it was another items's Right   and Layout Right as another item's Left. */
end_comment
begin_function
DECL|function|correctEdgeDirection
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|correctEdgeDirection
parameter_list|(
name|QGraphicsLayoutItem
modifier|*
modifier|&
name|firstItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
modifier|&
name|firstEdge
parameter_list|,
name|QGraphicsLayoutItem
modifier|*
modifier|&
name|secondItem
parameter_list|,
name|Qt
operator|::
name|AnchorPoint
modifier|&
name|secondEdge
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firstItem
operator|!=
name|q
operator|)
operator|&&
operator|(
name|secondItem
operator|!=
name|q
operator|)
condition|)
block|{
comment|// If connection is between widgets (not the layout itself)
comment|// Ensure that "right-edges" sit to the left of "left-edges".
if|if
condition|(
name|firstEdge
operator|<
name|secondEdge
condition|)
block|{
name|qSwap
argument_list|(
name|firstItem
argument_list|,
name|secondItem
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|firstEdge
argument_list|,
name|secondEdge
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|firstItem
operator|==
name|q
condition|)
block|{
comment|// If connection involves the right or bottom of a layout, ensure
comment|// the layout is the second item.
if|if
condition|(
operator|(
name|firstEdge
operator|==
name|Qt
operator|::
name|AnchorRight
operator|)
operator|||
operator|(
name|firstEdge
operator|==
name|Qt
operator|::
name|AnchorBottom
operator|)
condition|)
block|{
name|qSwap
argument_list|(
name|firstItem
argument_list|,
name|secondItem
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|firstEdge
argument_list|,
name|secondEdge
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|secondEdge
operator|!=
name|Qt
operator|::
name|AnchorRight
operator|)
operator|&&
operator|(
name|secondEdge
operator|!=
name|Qt
operator|::
name|AnchorBottom
operator|)
condition|)
block|{
comment|// If connection involves the left, center or top of layout, ensure
comment|// the layout is the first item.
name|qSwap
argument_list|(
name|firstItem
argument_list|,
name|secondItem
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|firstEdge
argument_list|,
name|secondEdge
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|styleInfo
name|QLayoutStyleInfo
modifier|&
name|QGraphicsAnchorLayoutPrivate
operator|::
name|styleInfo
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|styleInfoDirty
condition|)
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
comment|//### Fix this if QGV ever gets support for Metal style or different Aqua sizes.
name|QWidget
modifier|*
name|wid
init|=
literal|0
decl_stmt|;
name|QGraphicsLayoutItem
modifier|*
name|parent
init|=
name|q
operator|->
name|parentLayoutItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
name|parent
operator|->
name|isLayout
argument_list|()
condition|)
block|{
name|parent
operator|=
name|parent
operator|->
name|parentLayoutItem
argument_list|()
expr_stmt|;
block|}
name|QGraphicsWidget
modifier|*
name|w
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|QGraphicsItem
modifier|*
name|parentItem
init|=
name|parent
operator|->
name|graphicsItem
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentItem
operator|&&
name|parentItem
operator|->
name|isWidget
argument_list|()
condition|)
name|w
operator|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|parentItem
argument_list|)
expr_stmt|;
block|}
name|QStyle
modifier|*
name|style
init|=
name|w
condition|?
name|w
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
decl_stmt|;
name|cachedStyleInfo
operator|=
name|QLayoutStyleInfo
argument_list|(
name|style
argument_list|,
name|wid
argument_list|)
expr_stmt|;
name|cachedStyleInfo
operator|.
name|setDefaultSpacing
argument_list|(
name|Qt
operator|::
name|Horizontal
argument_list|,
name|spacings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cachedStyleInfo
operator|.
name|setDefaultSpacing
argument_list|(
name|Qt
operator|::
name|Vertical
argument_list|,
name|spacings
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|styleInfoDirty
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|cachedStyleInfo
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Called on activation. Uses Linear Programming to define minimum, preferred   and maximum sizes for the layout. Also calculates the sizes that each item   should assume when the layout is in one of such situations. */
end_comment
begin_function
DECL|function|calculateGraphs
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|calculateGraphs
parameter_list|()
block|{
if|if
condition|(
operator|!
name|calculateGraphCacheDirty
condition|)
return|return;
name|calculateGraphs
argument_list|(
name|Horizontal
argument_list|)
expr_stmt|;
name|calculateGraphs
argument_list|(
name|Vertical
argument_list|)
expr_stmt|;
name|calculateGraphCacheDirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|// ### Maybe getGraphParts could return the variables when traversing, at least
end_comment
begin_comment
comment|// for trunk...
end_comment
begin_function
DECL|function|getVariables
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|getVariables
parameter_list|(
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|constraints
parameter_list|)
block|{
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|variableSet
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constraints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QSimplexConstraint
modifier|*
name|c
init|=
name|constraints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QSimplexVariable
modifier|*
name|var
decl|,
name|c
operator|->
name|variables
operator|.
name|keys
argument_list|()
control|)
block|{
name|variableSet
operator|+=
cast|static_cast
argument_list|<
name|AnchorData
operator|*
argument_list|>
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|variableSet
operator|.
name|toList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Calculate graphs is the method that puts together all the helper routines     so that the AnchorLayout can calculate the sizes of each item.      In a nutshell it should do:      1) Refresh anchor nominal sizes, that is, the size that each anchor would        have if no other restrictions applied. This is done by quering the        layout style and the sizeHints of the items belonging to the layout.      2) Simplify the graph by grouping together parallel and sequential anchors        into "group anchors". These have equivalent minimum, preferred and maximum        sizeHints as the anchors they replace.      3) Check if we got to a trivial case. In some cases, the whole graph can be        simplified into a single anchor. If so, use this information. If not,        then call the Simplex solver to calculate the anchors sizes.      4) Once the root anchors had its sizes calculated, propagate that to the        anchors they represent. */
end_comment
begin_function
DECL|function|calculateGraphs
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|calculateGraphs
parameter_list|(
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_AUTOTEST_EXPORT
argument_list|)
name|lastCalculationUsedSimplex
index|[
name|orientation
index|]
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
specifier|static
name|bool
name|simplificationEnabled
init|=
name|qgetenv
argument_list|(
literal|"QT_ANCHORLAYOUT_NO_SIMPLIFICATION"
argument_list|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// Reset the nominal sizes of each anchor based on the current item sizes
name|refreshAllSizeHints
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
comment|// Simplify the graph
if|if
condition|(
name|simplificationEnabled
operator|&&
operator|!
name|simplifyGraph
argument_list|(
name|orientation
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsAnchorLayout: anchor setup is not feasible."
argument_list|)
expr_stmt|;
name|graphHasConflicts
index|[
name|orientation
index|]
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// Traverse all graph edges and store the possible paths to each vertex
name|findPaths
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
comment|// From the paths calculated above, extract the constraints that the current
comment|// anchor setup impose, to our Linear Programming problem.
name|constraintsFromPaths
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
comment|// Split the constraints and anchors into groups that should be fed to the
comment|// simplex solver independently. Currently we find two groups:
comment|//
comment|//  1) The "trunk", that is, the set of anchors (items) that are connected
comment|//     to the two opposite sides of our layout, and thus need to stretch in
comment|//     order to fit in the current layout size.
comment|//
comment|//  2) The floating or semi-floating anchors (items) that are those which
comment|//     are connected to only one (or none) of the layout sides, thus are not
comment|//     influenced by the layout size.
name|QList
argument_list|<
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
argument_list|>
name|parts
init|=
name|getGraphParts
argument_list|(
name|orientation
argument_list|)
decl_stmt|;
comment|// Now run the simplex solver to calculate Minimum, Preferred and Maximum sizes
comment|// of the "trunk" set of constraints and variables.
comment|// ### does trunk always exist? empty = trunk is the layout left->center->right
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|trunkConstraints
init|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|trunkVariables
init|=
name|getVariables
argument_list|(
name|trunkConstraints
argument_list|)
decl_stmt|;
comment|// For minimum and maximum, use the path between the two layout sides as the
comment|// objective function.
name|AnchorVertex
modifier|*
name|v
init|=
name|layoutLastVertex
index|[
name|orientation
index|]
decl_stmt|;
name|GraphPath
name|trunkPath
init|=
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|value
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|bool
name|feasible
init|=
name|calculateTrunk
argument_list|(
name|orientation
argument_list|,
name|trunkPath
argument_list|,
name|trunkConstraints
argument_list|,
name|trunkVariables
argument_list|)
decl_stmt|;
comment|// For the other parts that not the trunk, solve only for the preferred size
comment|// that is the size they will remain at, since they are not stretched by the
comment|// layout.
comment|// Skipping the first (trunk)
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|feasible
condition|)
break|break;
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|partConstraints
init|=
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|partVariables
init|=
name|getVariables
argument_list|(
name|partConstraints
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|partVariables
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|feasible
operator|&=
name|calculateNonTrunk
argument_list|(
name|partConstraints
argument_list|,
name|partVariables
argument_list|)
expr_stmt|;
block|}
comment|// Propagate the new sizes down the simplified graph, ie. tell the
comment|// group anchors to set their children anchors sizes.
name|updateAnchorSizes
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
name|graphHasConflicts
index|[
name|orientation
index|]
operator|=
operator|!
name|feasible
expr_stmt|;
comment|// Clean up our data structures. They are not needed anymore since
comment|// distribution uses just interpolation.
name|qDeleteAll
argument_list|(
name|constraints
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
name|constraints
index|[
name|orientation
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// ###
if|if
condition|(
name|simplificationEnabled
condition|)
name|restoreSimplifiedGraph
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Shift all the constraints by a certain amount. This allows us to deal with negative values in     the linear program if they are bounded by a certain limit. Functions should be careful to     call it again with a negative amount, to shift the constraints back. */
end_comment
begin_function
DECL|function|shiftConstraints
specifier|static
name|void
name|shiftConstraints
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
parameter_list|,
name|qreal
name|amount
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constraints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
name|constraints
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|qreal
name|multiplier
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
name|qreal
name|v
decl|,
name|c
operator|->
name|variables
operator|.
name|values
argument_list|()
control|)
block|{
name|multiplier
operator|+=
name|v
expr_stmt|;
block|}
name|c
operator|->
name|constant
operator|+=
name|multiplier
operator|*
name|amount
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Calculate the sizes for all anchors which are part of the trunk. This works     on top of a (possibly) simplified graph. */
end_comment
begin_function
DECL|function|calculateTrunk
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|calculateTrunk
parameter_list|(
name|Orientation
name|orientation
parameter_list|,
specifier|const
name|GraphPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
parameter_list|,
specifier|const
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|variables
parameter_list|)
block|{
name|bool
name|feasible
init|=
literal|true
decl_stmt|;
name|bool
name|needsSimplex
init|=
operator|!
name|constraints
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|#
directive|if
literal|0
block|qDebug("Simplex %s for trunk of %s", needsSimplex ? "used" : "NOT used",            orientation == Horizontal ? "Horizontal" : "Vertical");
endif|#
directive|endif
if|if
condition|(
name|needsSimplex
condition|)
block|{
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|sizeHintConstraints
init|=
name|constraintsFromSizeHints
argument_list|(
name|variables
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|allConstraints
init|=
name|constraints
operator|+
name|sizeHintConstraints
decl_stmt|;
name|shiftConstraints
argument_list|(
name|allConstraints
argument_list|,
name|g_offset
argument_list|)
expr_stmt|;
comment|// Solve min and max size hints
name|qreal
name|min
decl_stmt|,
name|max
decl_stmt|;
name|feasible
operator|=
name|solveMinMax
argument_list|(
name|allConstraints
argument_list|,
name|path
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|feasible
condition|)
block|{
name|solvePreferred
argument_list|(
name|constraints
argument_list|,
name|variables
argument_list|)
expr_stmt|;
comment|// Calculate and set the preferred size for the layout,
comment|// from the edge sizes that were calculated above.
name|qreal
name|pref
argument_list|(
literal|0.0
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|AnchorData
modifier|*
name|ad
decl|,
name|path
operator|.
name|positives
control|)
block|{
name|pref
operator|+=
name|ad
operator|->
name|sizeAtPreferred
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|AnchorData
modifier|*
name|ad
decl|,
name|path
operator|.
name|negatives
control|)
block|{
name|pref
operator|-=
name|ad
operator|->
name|sizeAtPreferred
expr_stmt|;
block|}
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MinimumSize
index|]
operator|=
name|min
expr_stmt|;
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|PreferredSize
index|]
operator|=
name|pref
expr_stmt|;
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MaximumSize
index|]
operator|=
name|max
expr_stmt|;
block|}
name|qDeleteAll
argument_list|(
name|sizeHintConstraints
argument_list|)
expr_stmt|;
name|shiftConstraints
argument_list|(
name|constraints
argument_list|,
operator|-
name|g_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No Simplex is necessary because the path was simplified all the way to a single
comment|// anchor.
name|Q_ASSERT
argument_list|(
name|path
operator|.
name|positives
operator|.
name|count
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|path
operator|.
name|negatives
operator|.
name|count
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|AnchorData
modifier|*
name|ad
init|=
name|path
operator|.
name|positives
operator|.
name|toList
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|ad
operator|->
name|sizeAtMinimum
operator|=
name|ad
operator|->
name|minSize
expr_stmt|;
name|ad
operator|->
name|sizeAtPreferred
operator|=
name|ad
operator|->
name|prefSize
expr_stmt|;
name|ad
operator|->
name|sizeAtMaximum
operator|=
name|ad
operator|->
name|maxSize
expr_stmt|;
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MinimumSize
index|]
operator|=
name|ad
operator|->
name|sizeAtMinimum
expr_stmt|;
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|PreferredSize
index|]
operator|=
name|ad
operator|->
name|sizeAtPreferred
expr_stmt|;
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MaximumSize
index|]
operator|=
name|ad
operator|->
name|sizeAtMaximum
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_AUTOTEST_EXPORT
argument_list|)
name|lastCalculationUsedSimplex
index|[
name|orientation
index|]
operator|=
name|needsSimplex
expr_stmt|;
endif|#
directive|endif
return|return
name|feasible
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|calculateNonTrunk
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|calculateNonTrunk
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
parameter_list|,
specifier|const
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|variables
parameter_list|)
block|{
name|shiftConstraints
argument_list|(
name|constraints
argument_list|,
name|g_offset
argument_list|)
expr_stmt|;
name|bool
name|feasible
init|=
name|solvePreferred
argument_list|(
name|constraints
argument_list|,
name|variables
argument_list|)
decl_stmt|;
if|if
condition|(
name|feasible
condition|)
block|{
comment|// Propagate size at preferred to other sizes. Semi-floats always will be
comment|// in their sizeAtPreferred.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|variables
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|variables
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|ad
operator|->
name|sizeAtMinimum
operator|=
name|ad
operator|->
name|sizeAtPreferred
expr_stmt|;
name|ad
operator|->
name|sizeAtMaximum
operator|=
name|ad
operator|->
name|sizeAtPreferred
expr_stmt|;
block|}
block|}
name|shiftConstraints
argument_list|(
name|constraints
argument_list|,
operator|-
name|g_offset
argument_list|)
expr_stmt|;
return|return
name|feasible
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Traverse the graph refreshing the size hints. Edges will query their associated     item or graphicsAnchor for their size hints. */
end_comment
begin_function
DECL|function|refreshAllSizeHints
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|refreshAllSizeHints
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
name|vertices
init|=
name|g
operator|.
name|connections
argument_list|()
decl_stmt|;
name|QLayoutStyleInfo
name|styleInf
init|=
name|styleInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|data
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
argument_list|)
decl_stmt|;
name|data
operator|->
name|refreshSizeHints
argument_list|(
operator|&
name|styleInf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    This method walks the graph using a breadth-first search to find paths   between the root vertex and each vertex on the graph. The edges   directions in each path are considered and they are stored as a   positive edge (left-to-right) or negative edge (right-to-left).    The list of paths is used later to generate a list of constraints.  */
end_comment
begin_function
DECL|function|findPaths
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|findPaths
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|QQueue
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
name|queue
decl_stmt|;
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|visited
decl_stmt|;
name|AnchorVertex
modifier|*
name|root
init|=
name|layoutFirstVertex
index|[
name|orientation
index|]
decl_stmt|;
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|insert
argument_list|(
name|root
argument_list|,
name|GraphPath
argument_list|()
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|AnchorVertex
modifier|*
name|v
decl|,
name|graph
index|[
name|orientation
index|]
operator|.
name|adjacentVertices
argument_list|(
name|root
argument_list|)
control|)
block|{
name|queue
operator|.
name|enqueue
argument_list|(
name|qMakePair
argument_list|(
name|root
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
name|pair
init|=
name|queue
operator|.
name|dequeue
argument_list|()
decl_stmt|;
name|AnchorData
modifier|*
name|edge
init|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|pair
operator|.
name|first
argument_list|,
name|pair
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|visited
operator|.
name|contains
argument_list|(
name|edge
argument_list|)
condition|)
continue|continue;
name|visited
operator|.
name|insert
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|GraphPath
name|current
init|=
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|value
argument_list|(
name|pair
operator|.
name|first
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|from
operator|==
name|pair
operator|.
name|first
condition|)
name|current
operator|.
name|positives
operator|.
name|insert
argument_list|(
name|edge
argument_list|)
expr_stmt|;
else|else
name|current
operator|.
name|negatives
operator|.
name|insert
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|insert
argument_list|(
name|pair
operator|.
name|second
argument_list|,
name|current
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|AnchorVertex
modifier|*
name|v
decl|,
name|graph
index|[
name|orientation
index|]
operator|.
name|adjacentVertices
argument_list|(
name|pair
operator|.
name|second
argument_list|)
control|)
block|{
name|queue
operator|.
name|enqueue
argument_list|(
name|qMakePair
argument_list|(
name|pair
operator|.
name|second
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We will walk through every reachable items (non-float) store them in a temporary set.
comment|// We them create a set of all items and subtract the non-floating items from the set in
comment|// order to get the floating items. The floating items is then stored in m_floatItems
name|identifyFloatItems
argument_list|(
name|visited
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Each vertex on the graph that has more than one path to it   represents a contra int to the sizes of the items in these paths.    This method walks the list of paths to each vertex, generate   the constraints and store them in a list so they can be used later   by the Simplex solver. */
end_comment
begin_function
DECL|function|constraintsFromPaths
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|constraintsFromPaths
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
foreach|foreach
control|(
name|AnchorVertex
modifier|*
name|vertex
decl|,
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|uniqueKeys
argument_list|()
control|)
block|{
name|int
name|valueCount
init|=
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|count
argument_list|(
name|vertex
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueCount
operator|==
literal|1
condition|)
continue|continue;
name|QList
argument_list|<
name|GraphPath
argument_list|>
name|pathsToVertex
init|=
name|graphPaths
index|[
name|orientation
index|]
operator|.
name|values
argument_list|(
name|vertex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|valueCount
condition|;
operator|++
name|i
control|)
block|{
name|constraints
index|[
name|orientation
index|]
operator|+=
expr|\
name|pathsToVertex
index|[
literal|0
index|]
operator|.
name|constraint
argument_list|(
name|pathsToVertex
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|updateAnchorSizes
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|updateAnchorSizes
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Graph
argument_list|<
name|AnchorVertex
argument_list|,
name|AnchorData
argument_list|>
modifier|&
name|g
init|=
name|graph
index|[
name|orientation
index|]
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
modifier|&
name|vertices
init|=
name|g
operator|.
name|connections
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vertices
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|g
operator|.
name|edgeData
argument_list|(
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|first
argument_list|,
name|vertices
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|second
argument_list|)
decl_stmt|;
name|ad
operator|->
name|updateChildrenSizes
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    Create LP constraints for each anchor based on its minimum and maximum   sizes, as specified in its size hints */
end_comment
begin_function
DECL|function|constraintsFromSizeHints
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|QGraphicsAnchorLayoutPrivate
operator|::
name|constraintsFromSizeHints
parameter_list|(
specifier|const
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|anchors
parameter_list|)
block|{
if|if
condition|(
name|anchors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QList
argument_list|<
name|QSimplexConstraint
operator|*
argument_list|>
argument_list|()
return|;
comment|// Look for the layout edge. That can be either the first half in case the
comment|// layout is split in two, or the whole layout anchor.
name|Orientation
name|orient
init|=
name|Orientation
argument_list|(
name|anchors
operator|.
name|first
argument_list|()
operator|->
name|orientation
argument_list|)
decl_stmt|;
name|AnchorData
modifier|*
name|layoutEdge
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|layoutCentralVertex
index|[
name|orient
index|]
condition|)
block|{
name|layoutEdge
operator|=
name|graph
index|[
name|orient
index|]
operator|.
name|edgeData
argument_list|(
name|layoutFirstVertex
index|[
name|orient
index|]
argument_list|,
name|layoutCentralVertex
index|[
name|orient
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|layoutEdge
operator|=
name|graph
index|[
name|orient
index|]
operator|.
name|edgeData
argument_list|(
name|layoutFirstVertex
index|[
name|orient
index|]
argument_list|,
name|layoutLastVertex
index|[
name|orient
index|]
argument_list|)
expr_stmt|;
block|}
comment|// If maxSize is less then "infinite", that means there are other anchors
comment|// grouped together with this one. We can't ignore its maximum value so we
comment|// set back the variable to NULL to prevent the continue condition from being
comment|// satisfied in the loop below.
specifier|const
name|qreal
name|expectedMax
init|=
name|layoutCentralVertex
index|[
name|orient
index|]
condition|?
name|QWIDGETSIZE_MAX
operator|/
literal|2
else|:
name|QWIDGETSIZE_MAX
decl_stmt|;
name|qreal
name|actualMax
decl_stmt|;
if|if
condition|(
name|layoutEdge
operator|->
name|from
operator|==
name|layoutFirstVertex
index|[
name|orient
index|]
condition|)
block|{
name|actualMax
operator|=
name|layoutEdge
operator|->
name|maxSize
expr_stmt|;
block|}
else|else
block|{
name|actualMax
operator|=
operator|-
name|layoutEdge
operator|->
name|minSize
expr_stmt|;
block|}
if|if
condition|(
name|actualMax
operator|!=
name|expectedMax
condition|)
block|{
name|layoutEdge
operator|=
literal|0
expr_stmt|;
block|}
comment|// For each variable, create constraints based on size hints
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|anchorConstraints
decl_stmt|;
name|bool
name|unboundedProblem
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|anchors
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|anchors
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Anchors that have their size directly linked to another one don't need constraints
comment|// For exammple, the second half of an item has exactly the same size as the first half
comment|// thus constraining the latter is enough.
if|if
condition|(
name|ad
operator|->
name|dependency
operator|==
name|AnchorData
operator|::
name|Slave
condition|)
continue|continue;
comment|// To use negative variables inside simplex, we shift them so the minimum negative value is
comment|// mapped to zero before solving. To make sure that it works, we need to guarantee that the
comment|// variables are all inside a certain boundary.
name|qreal
name|boundedMin
init|=
name|qBound
argument_list|(
operator|-
name|g_offset
argument_list|,
name|ad
operator|->
name|minSize
argument_list|,
name|g_offset
argument_list|)
decl_stmt|;
name|qreal
name|boundedMax
init|=
name|qBound
argument_list|(
operator|-
name|g_offset
argument_list|,
name|ad
operator|->
name|maxSize
argument_list|,
name|g_offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|boundedMin
operator|==
name|boundedMax
operator|)
operator|||
name|qFuzzyCompare
argument_list|(
name|boundedMin
argument_list|,
name|boundedMax
argument_list|)
condition|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|ad
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|c
operator|->
name|constant
operator|=
name|boundedMin
expr_stmt|;
name|c
operator|->
name|ratio
operator|=
name|QSimplexConstraint
operator|::
name|Equal
expr_stmt|;
name|anchorConstraints
operator|+=
name|c
expr_stmt|;
name|unboundedProblem
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|ad
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|c
operator|->
name|constant
operator|=
name|boundedMin
expr_stmt|;
name|c
operator|->
name|ratio
operator|=
name|QSimplexConstraint
operator|::
name|MoreOrEqual
expr_stmt|;
name|anchorConstraints
operator|+=
name|c
expr_stmt|;
comment|// We avoid adding restrictions to the layout internal anchors. That's
comment|// to prevent unnecessary fair distribution from happening due to this
comment|// artificial restriction.
if|if
condition|(
name|ad
operator|==
name|layoutEdge
condition|)
continue|continue;
name|c
operator|=
operator|new
name|QSimplexConstraint
expr_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|ad
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|c
operator|->
name|constant
operator|=
name|boundedMax
expr_stmt|;
name|c
operator|->
name|ratio
operator|=
name|QSimplexConstraint
operator|::
name|LessOrEqual
expr_stmt|;
name|anchorConstraints
operator|+=
name|c
expr_stmt|;
name|unboundedProblem
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// If no upper boundary restriction was added, add one to avoid unbounded problem
if|if
condition|(
name|unboundedProblem
condition|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|c
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|layoutEdge
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|// The maximum size that the layout can take
name|c
operator|->
name|constant
operator|=
name|g_offset
expr_stmt|;
name|c
operator|->
name|ratio
operator|=
name|QSimplexConstraint
operator|::
name|LessOrEqual
expr_stmt|;
name|anchorConstraints
operator|+=
name|c
expr_stmt|;
block|}
return|return
name|anchorConstraints
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
name|QList
argument_list|<
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
argument_list|>
DECL|function|getGraphParts
name|QGraphicsAnchorLayoutPrivate
operator|::
name|getGraphParts
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|layoutFirstVertex
index|[
name|orientation
index|]
operator|&&
name|layoutLastVertex
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
name|AnchorData
modifier|*
name|edgeL1
init|=
literal|0
decl_stmt|;
name|AnchorData
modifier|*
name|edgeL2
init|=
literal|0
decl_stmt|;
comment|// The layout may have a single anchor between Left and Right or two half anchors
comment|// passing through the center
if|if
condition|(
name|layoutCentralVertex
index|[
name|orientation
index|]
condition|)
block|{
name|edgeL1
operator|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|layoutFirstVertex
index|[
name|orientation
index|]
argument_list|,
name|layoutCentralVertex
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
name|edgeL2
operator|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|layoutCentralVertex
index|[
name|orientation
index|]
argument_list|,
name|layoutLastVertex
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edgeL1
operator|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|layoutFirstVertex
index|[
name|orientation
index|]
argument_list|,
name|layoutLastVertex
index|[
name|orientation
index|]
argument_list|)
expr_stmt|;
block|}
name|QLinkedList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|remainingConstraints
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constraints
index|[
name|orientation
index|]
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|remainingConstraints
operator|+=
name|constraints
index|[
name|orientation
index|]
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|remainingConstraints
operator|+=
name|itemCenterConstraints
index|[
name|orientation
index|]
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|trunkConstraints
decl_stmt|;
name|QSet
argument_list|<
name|QSimplexVariable
modifier|*
argument_list|>
name|trunkVariables
decl_stmt|;
name|trunkVariables
operator|+=
name|edgeL1
expr_stmt|;
if|if
condition|(
name|edgeL2
condition|)
name|trunkVariables
operator|+=
name|edgeL2
expr_stmt|;
name|bool
name|dirty
decl_stmt|;
do|do
block|{
name|dirty
operator|=
literal|false
expr_stmt|;
name|QLinkedList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|remainingConstraints
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|remainingConstraints
operator|.
name|end
argument_list|()
condition|)
block|{
name|QSimplexConstraint
modifier|*
name|c
init|=
operator|*
name|it
decl_stmt|;
name|bool
name|match
init|=
literal|false
decl_stmt|;
comment|// Check if this constraint have some overlap with current
comment|// trunk variables...
foreach|foreach
control|(
name|QSimplexVariable
modifier|*
name|ad
decl|,
name|trunkVariables
control|)
block|{
if|if
condition|(
name|c
operator|->
name|variables
operator|.
name|contains
argument_list|(
name|ad
argument_list|)
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If so, we add it to trunk, and erase it from the
comment|// remaining constraints.
if|if
condition|(
name|match
condition|)
block|{
name|trunkConstraints
operator|+=
name|c
expr_stmt|;
name|trunkVariables
operator|+=
name|QSet
argument_list|<
name|QSimplexVariable
operator|*
argument_list|>
operator|::
name|fromList
argument_list|(
name|c
operator|->
name|variables
operator|.
name|keys
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|remainingConstraints
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Note that we don't erase the constraint if it's not
comment|// a match, since in a next iteration of a do-while we
comment|// can pass on it again and it will be a match.
comment|//
comment|// For example: if trunk share a variable with
comment|// remainingConstraints[1] and it shares with
comment|// remainingConstraints[0], we need a second iteration
comment|// of the do-while loop to match both.
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|dirty
condition|)
do|;
name|QList
argument_list|<
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
argument_list|>
name|result
decl_stmt|;
name|result
operator|+=
name|trunkConstraints
expr_stmt|;
if|if
condition|(
operator|!
name|remainingConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|nonTrunkConstraints
decl_stmt|;
name|QLinkedList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|remainingConstraints
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|remainingConstraints
operator|.
name|end
argument_list|()
condition|)
block|{
name|nonTrunkConstraints
operator|+=
operator|*
name|it
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
name|result
operator|+=
name|nonTrunkConstraints
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!  \internal    Use all visited Anchors on findPaths() so we can identify non-float Items. */
end_comment
begin_function
DECL|function|identifyFloatItems
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|identifyFloatItems
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|visited
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
name|QSet
argument_list|<
name|QGraphicsLayoutItem
modifier|*
argument_list|>
name|nonFloating
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|AnchorData
modifier|*
name|ad
decl|,
name|visited
control|)
name|identifyNonFloatItems_helper
argument_list|(
name|ad
argument_list|,
operator|&
name|nonFloating
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QGraphicsLayoutItem
modifier|*
argument_list|>
name|allItems
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsLayoutItem
modifier|*
name|item
decl|,
name|items
control|)
name|allItems
operator|.
name|insert
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|m_floatItems
index|[
name|orientation
index|]
operator|=
name|allItems
operator|-
name|nonFloating
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  \internal    Given an anchor, if it is an internal anchor and Normal we must mark it's item as non-float.   If the anchor is Sequential or Parallel, we must iterate on its children recursively until we reach   internal anchors (items). */
end_comment
begin_function
DECL|function|identifyNonFloatItems_helper
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|identifyNonFloatItems_helper
parameter_list|(
specifier|const
name|AnchorData
modifier|*
name|ad
parameter_list|,
name|QSet
argument_list|<
name|QGraphicsLayoutItem
modifier|*
argument_list|>
modifier|*
name|nonFloatingItemsIdentifiedSoFar
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ad
operator|->
name|type
condition|)
block|{
case|case
name|AnchorData
operator|::
name|Normal
case|:
if|if
condition|(
name|ad
operator|->
name|item
operator|&&
name|ad
operator|->
name|item
operator|!=
name|q
condition|)
name|nonFloatingItemsIdentifiedSoFar
operator|->
name|insert
argument_list|(
name|ad
operator|->
name|item
argument_list|)
expr_stmt|;
break|break;
case|case
name|AnchorData
operator|::
name|Sequential
case|:
foreach|foreach
control|(
specifier|const
name|AnchorData
modifier|*
name|d
decl|,
cast|static_cast
argument_list|<
specifier|const
name|SequentialAnchorData
operator|*
argument_list|>
argument_list|(
name|ad
argument_list|)
operator|->
name|m_edges
control|)
name|identifyNonFloatItems_helper
argument_list|(
name|d
argument_list|,
name|nonFloatingItemsIdentifiedSoFar
argument_list|)
expr_stmt|;
break|break;
case|case
name|AnchorData
operator|::
name|Parallel
case|:
name|identifyNonFloatItems_helper
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ParallelAnchorData
operator|*
argument_list|>
argument_list|(
name|ad
argument_list|)
operator|->
name|firstEdge
argument_list|,
name|nonFloatingItemsIdentifiedSoFar
argument_list|)
expr_stmt|;
name|identifyNonFloatItems_helper
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|ParallelAnchorData
operator|*
argument_list|>
argument_list|(
name|ad
argument_list|)
operator|->
name|secondEdge
argument_list|,
name|nonFloatingItemsIdentifiedSoFar
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    Use the current vertices distance to calculate and set the geometry of   each item. */
end_comment
begin_function
DECL|function|setItemsGeometries
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|setItemsGeometries
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|geom
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|AnchorVertex
modifier|*
name|firstH
decl_stmt|,
modifier|*
name|secondH
decl_stmt|,
modifier|*
name|firstV
decl_stmt|,
modifier|*
name|secondV
decl_stmt|;
name|qreal
name|top
decl_stmt|;
name|qreal
name|left
decl_stmt|;
name|qreal
name|right
decl_stmt|;
name|q
operator|->
name|getContentsMargins
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|Qt
operator|::
name|LayoutDirection
name|visualDir
init|=
name|visualDirection
argument_list|()
decl_stmt|;
if|if
condition|(
name|visualDir
operator|==
name|Qt
operator|::
name|RightToLeft
condition|)
name|qSwap
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|left
operator|+=
name|geom
operator|.
name|left
argument_list|()
expr_stmt|;
name|top
operator|+=
name|geom
operator|.
name|top
argument_list|()
expr_stmt|;
name|right
operator|=
name|geom
operator|.
name|right
argument_list|()
operator|-
name|right
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsLayoutItem
modifier|*
name|item
decl|,
name|items
control|)
block|{
name|QRectF
name|newGeom
decl_stmt|;
name|QSizeF
name|itemPreferredSize
init|=
name|item
operator|->
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|PreferredSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_floatItems
index|[
name|Horizontal
index|]
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|newGeom
operator|.
name|setLeft
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setRight
argument_list|(
name|itemPreferredSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|firstH
operator|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorLeft
argument_list|)
expr_stmt|;
name|secondH
operator|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|visualDir
operator|==
name|Qt
operator|::
name|LeftToRight
condition|)
block|{
name|newGeom
operator|.
name|setLeft
argument_list|(
name|left
operator|+
name|firstH
operator|->
name|distance
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setRight
argument_list|(
name|left
operator|+
name|secondH
operator|->
name|distance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newGeom
operator|.
name|setLeft
argument_list|(
name|right
operator|-
name|secondH
operator|->
name|distance
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setRight
argument_list|(
name|right
operator|-
name|firstH
operator|->
name|distance
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m_floatItems
index|[
name|Vertical
index|]
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|newGeom
operator|.
name|setTop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setBottom
argument_list|(
name|itemPreferredSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|firstV
operator|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorTop
argument_list|)
expr_stmt|;
name|secondV
operator|=
name|internalVertex
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|AnchorBottom
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setTop
argument_list|(
name|top
operator|+
name|firstV
operator|->
name|distance
argument_list|)
expr_stmt|;
name|newGeom
operator|.
name|setBottom
argument_list|(
name|top
operator|+
name|secondV
operator|->
name|distance
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|setGeometry
argument_list|(
name|newGeom
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    Calculate the position of each vertex based on the paths to each of   them as well as the current edges sizes. */
end_comment
begin_function
DECL|function|calculateVertexPositions
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|calculateVertexPositions
parameter_list|(
name|QGraphicsAnchorLayoutPrivate
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|QQueue
argument_list|<
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
argument_list|>
name|queue
decl_stmt|;
name|QSet
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|visited
decl_stmt|;
comment|// Get root vertex
name|AnchorVertex
modifier|*
name|root
init|=
name|layoutFirstVertex
index|[
name|orientation
index|]
decl_stmt|;
name|root
operator|->
name|distance
operator|=
literal|0
expr_stmt|;
name|visited
operator|.
name|insert
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|// Add initial edges to the queue
foreach|foreach
control|(
name|AnchorVertex
modifier|*
name|v
decl|,
name|graph
index|[
name|orientation
index|]
operator|.
name|adjacentVertices
argument_list|(
name|root
argument_list|)
control|)
block|{
name|queue
operator|.
name|enqueue
argument_list|(
name|qMakePair
argument_list|(
name|root
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Do initial calculation required by "interpolateEdge()"
name|setupEdgesInterpolation
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
comment|// Traverse the graph and calculate vertex positions
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPair
argument_list|<
name|AnchorVertex
modifier|*
argument_list|,
name|AnchorVertex
modifier|*
argument_list|>
name|pair
init|=
name|queue
operator|.
name|dequeue
argument_list|()
decl_stmt|;
name|AnchorData
modifier|*
name|edge
init|=
name|graph
index|[
name|orientation
index|]
operator|.
name|edgeData
argument_list|(
name|pair
operator|.
name|first
argument_list|,
name|pair
operator|.
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|visited
operator|.
name|contains
argument_list|(
name|pair
operator|.
name|second
argument_list|)
condition|)
continue|continue;
name|visited
operator|.
name|insert
argument_list|(
name|pair
operator|.
name|second
argument_list|)
expr_stmt|;
name|interpolateEdge
argument_list|(
name|pair
operator|.
name|first
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|AnchorVertex
modifier|*
argument_list|>
name|adjacents
init|=
name|graph
index|[
name|orientation
index|]
operator|.
name|adjacentVertices
argument_list|(
name|pair
operator|.
name|second
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adjacents
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|adjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|queue
operator|.
name|enqueue
argument_list|(
name|qMakePair
argument_list|(
name|pair
operator|.
name|second
argument_list|,
name|adjacents
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!   \internal    Calculate interpolation parameters based on current Layout Size.   Must be called once before calling "interpolateEdgeSize()" for   the edges. */
end_comment
begin_function
DECL|function|setupEdgesInterpolation
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|setupEdgesInterpolation
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsAnchorLayout
argument_list|)
expr_stmt|;
name|qreal
name|current
decl_stmt|;
name|current
operator|=
operator|(
name|orientation
operator|==
name|Horizontal
operator|)
condition|?
name|q
operator|->
name|contentsRect
argument_list|()
operator|.
name|width
argument_list|()
else|:
name|q
operator|->
name|contentsRect
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
name|QPair
argument_list|<
name|Interval
argument_list|,
name|qreal
argument_list|>
name|result
decl_stmt|;
name|result
operator|=
name|getFactor
argument_list|(
name|current
argument_list|,
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MinimumSize
index|]
argument_list|,
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|PreferredSize
index|]
argument_list|,
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|PreferredSize
index|]
argument_list|,
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|PreferredSize
index|]
argument_list|,
name|sizeHints
index|[
name|orientation
index|]
index|[
name|Qt
operator|::
name|MaximumSize
index|]
argument_list|)
expr_stmt|;
name|interpolationInterval
index|[
name|orientation
index|]
operator|=
name|result
operator|.
name|first
expr_stmt|;
name|interpolationProgress
index|[
name|orientation
index|]
operator|=
name|result
operator|.
name|second
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Calculate the current Edge size based on the current Layout size and the     size the edge is supposed to have when the layout is at its:      - minimum size,     - preferred size,     - maximum size.      These three key values are calculated in advance using linear     programming (more expensive) or the simplification algorithm, then     subsequential resizes of the parent layout require a simple     interpolation. */
end_comment
begin_function
DECL|function|interpolateEdge
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|interpolateEdge
parameter_list|(
name|AnchorVertex
modifier|*
name|base
parameter_list|,
name|AnchorData
modifier|*
name|edge
parameter_list|)
block|{
specifier|const
name|Orientation
name|orientation
init|=
name|Orientation
argument_list|(
name|edge
operator|->
name|orientation
argument_list|)
decl_stmt|;
specifier|const
name|QPair
argument_list|<
name|Interval
argument_list|,
name|qreal
argument_list|>
name|factor
argument_list|(
name|interpolationInterval
index|[
name|orientation
index|]
argument_list|,
name|interpolationProgress
index|[
name|orientation
index|]
argument_list|)
decl_stmt|;
name|qreal
name|edgeDistance
init|=
name|interpolate
argument_list|(
name|factor
argument_list|,
name|edge
operator|->
name|sizeAtMinimum
argument_list|,
name|edge
operator|->
name|sizeAtPreferred
argument_list|,
name|edge
operator|->
name|sizeAtPreferred
argument_list|,
name|edge
operator|->
name|sizeAtPreferred
argument_list|,
name|edge
operator|->
name|sizeAtMaximum
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|edge
operator|->
name|from
operator|==
name|base
operator|||
name|edge
operator|->
name|to
operator|==
name|base
argument_list|)
expr_stmt|;
comment|// Calculate the distance for the vertex opposite to the base
if|if
condition|(
name|edge
operator|->
name|from
operator|==
name|base
condition|)
block|{
name|edge
operator|->
name|to
operator|->
name|distance
operator|=
name|base
operator|->
name|distance
operator|+
name|edgeDistance
expr_stmt|;
block|}
else|else
block|{
name|edge
operator|->
name|from
operator|->
name|distance
operator|=
name|base
operator|->
name|distance
operator|-
name|edgeDistance
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|solveMinMax
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|solveMinMax
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
parameter_list|,
name|GraphPath
name|path
parameter_list|,
name|qreal
modifier|*
name|min
parameter_list|,
name|qreal
modifier|*
name|max
parameter_list|)
block|{
name|QSimplex
name|simplex
decl_stmt|;
name|bool
name|feasible
init|=
name|simplex
operator|.
name|setConstraints
argument_list|(
name|constraints
argument_list|)
decl_stmt|;
if|if
condition|(
name|feasible
condition|)
block|{
comment|// Obtain the objective constraint
name|QSimplexConstraint
name|objective
decl_stmt|;
name|QSet
argument_list|<
name|AnchorData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|iter
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|path
operator|.
name|positives
operator|.
name|constBegin
argument_list|()
init|;
name|iter
operator|!=
name|path
operator|.
name|positives
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|iter
control|)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
operator|*
name|iter
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|path
operator|.
name|negatives
operator|.
name|constBegin
argument_list|()
init|;
name|iter
operator|!=
name|path
operator|.
name|negatives
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|iter
control|)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
operator|*
name|iter
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
specifier|const
name|qreal
name|objectiveOffset
init|=
operator|(
name|path
operator|.
name|positives
operator|.
name|count
argument_list|()
operator|-
name|path
operator|.
name|negatives
operator|.
name|count
argument_list|()
operator|)
operator|*
name|g_offset
decl_stmt|;
name|simplex
operator|.
name|setObjective
argument_list|(
operator|&
name|objective
argument_list|)
expr_stmt|;
comment|// Calculate minimum values
operator|*
name|min
operator|=
name|simplex
operator|.
name|solveMin
argument_list|()
operator|-
name|objectiveOffset
expr_stmt|;
comment|// Save sizeAtMinimum results
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
name|variables
init|=
name|getVariables
argument_list|(
name|constraints
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|variables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
cast|static_cast
argument_list|<
name|AnchorData
operator|*
argument_list|>
argument_list|(
name|variables
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|ad
operator|->
name|sizeAtMinimum
operator|=
name|ad
operator|->
name|result
operator|-
name|g_offset
expr_stmt|;
block|}
comment|// Calculate maximum values
operator|*
name|max
operator|=
name|simplex
operator|.
name|solveMax
argument_list|()
operator|-
name|objectiveOffset
expr_stmt|;
comment|// Save sizeAtMaximum results
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|variables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
cast|static_cast
argument_list|<
name|AnchorData
operator|*
argument_list|>
argument_list|(
name|variables
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|ad
operator|->
name|sizeAtMaximum
operator|=
name|ad
operator|->
name|result
operator|-
name|g_offset
expr_stmt|;
block|}
block|}
return|return
name|feasible
return|;
block|}
end_function
begin_enum
DECL|enum|slackType
DECL|enumerator|Grower
DECL|enumerator|Shrinker
enum|enum
name|slackType
block|{
name|Grower
init|=
operator|-
literal|1
block|,
name|Shrinker
init|=
literal|1
block|}
enum|;
end_enum
begin_function
DECL|function|createSlack
specifier|static
name|QPair
argument_list|<
name|QSimplexVariable
modifier|*
argument_list|,
name|QSimplexConstraint
modifier|*
argument_list|>
name|createSlack
parameter_list|(
name|QSimplexConstraint
modifier|*
name|sizeConstraint
parameter_list|,
name|qreal
name|interval
parameter_list|,
name|slackType
name|type
parameter_list|)
block|{
name|QSimplexVariable
modifier|*
name|slack
init|=
operator|new
name|QSimplexVariable
decl_stmt|;
name|sizeConstraint
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|slack
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|QSimplexConstraint
modifier|*
name|limit
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|limit
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|slack
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|limit
operator|->
name|ratio
operator|=
name|QSimplexConstraint
operator|::
name|LessOrEqual
expr_stmt|;
name|limit
operator|->
name|constant
operator|=
name|interval
expr_stmt|;
return|return
name|qMakePair
argument_list|(
name|slack
argument_list|,
name|limit
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|solvePreferred
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|solvePreferred
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
modifier|&
name|constraints
parameter_list|,
specifier|const
name|QList
argument_list|<
name|AnchorData
modifier|*
argument_list|>
modifier|&
name|variables
parameter_list|)
block|{
name|QList
argument_list|<
name|QSimplexConstraint
modifier|*
argument_list|>
name|preferredConstraints
decl_stmt|;
name|QList
argument_list|<
name|QSimplexVariable
modifier|*
argument_list|>
name|preferredVariables
decl_stmt|;
name|QSimplexConstraint
name|objective
decl_stmt|;
comment|// Fill the objective coefficients for this variable. In the
comment|// end the objective function will be
comment|//
comment|//     z = n * (A_shrinker_hard + A_grower_hard + B_shrinker_hard + B_grower_hard + ...) +
comment|//             (A_shrinker_soft + A_grower_soft + B_shrinker_soft + B_grower_soft + ...)
comment|//
comment|// where n is the number of variables that have
comment|// slacks. Note that here we use the number of variables
comment|// as coefficient, this is to mark the "shrinker slack
comment|// variable" less likely to get value than the "grower
comment|// slack variable".
comment|// This will fill the values for the structural constraints
comment|// and we now fill the values for the slack constraints (one per variable),
comment|// which have this form (the constant A_pref was set when creating the slacks):
comment|//
comment|//      A + A_shrinker_hard + A_shrinker_soft - A_grower_hard - A_grower_soft = A_pref
comment|//
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|variables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|variables
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// The layout original structure anchors are not relevant in preferred size calculation
if|if
condition|(
name|ad
operator|->
name|isLayoutAnchor
condition|)
continue|continue;
comment|// By default, all variables are equal to their preferred size. If they have room to
comment|// grow or shrink, such flexibility will be added by the additional variables below.
name|QSimplexConstraint
modifier|*
name|sizeConstraint
init|=
operator|new
name|QSimplexConstraint
decl_stmt|;
name|preferredConstraints
operator|+=
name|sizeConstraint
expr_stmt|;
name|sizeConstraint
operator|->
name|variables
operator|.
name|insert
argument_list|(
name|ad
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|sizeConstraint
operator|->
name|constant
operator|=
name|ad
operator|->
name|prefSize
operator|+
name|g_offset
expr_stmt|;
comment|// Can easily shrink
name|QPair
argument_list|<
name|QSimplexVariable
modifier|*
argument_list|,
name|QSimplexConstraint
modifier|*
argument_list|>
name|slack
decl_stmt|;
specifier|const
name|qreal
name|softShrinkInterval
init|=
name|ad
operator|->
name|prefSize
operator|-
name|ad
operator|->
name|minPrefSize
decl_stmt|;
if|if
condition|(
name|softShrinkInterval
condition|)
block|{
name|slack
operator|=
name|createSlack
argument_list|(
name|sizeConstraint
argument_list|,
name|softShrinkInterval
argument_list|,
name|Shrinker
argument_list|)
expr_stmt|;
name|preferredVariables
operator|+=
name|slack
operator|.
name|first
expr_stmt|;
name|preferredConstraints
operator|+=
name|slack
operator|.
name|second
expr_stmt|;
comment|// Add to objective with ratio == 1 (soft)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
name|slack
operator|.
name|first
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
comment|// Can easily grow
specifier|const
name|qreal
name|softGrowInterval
init|=
name|ad
operator|->
name|maxPrefSize
operator|-
name|ad
operator|->
name|prefSize
decl_stmt|;
if|if
condition|(
name|softGrowInterval
condition|)
block|{
name|slack
operator|=
name|createSlack
argument_list|(
name|sizeConstraint
argument_list|,
name|softGrowInterval
argument_list|,
name|Grower
argument_list|)
expr_stmt|;
name|preferredVariables
operator|+=
name|slack
operator|.
name|first
expr_stmt|;
name|preferredConstraints
operator|+=
name|slack
operator|.
name|second
expr_stmt|;
comment|// Add to objective with ratio == 1 (soft)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
name|slack
operator|.
name|first
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
comment|// Can shrink if really necessary
specifier|const
name|qreal
name|hardShrinkInterval
init|=
name|ad
operator|->
name|minPrefSize
operator|-
name|ad
operator|->
name|minSize
decl_stmt|;
if|if
condition|(
name|hardShrinkInterval
condition|)
block|{
name|slack
operator|=
name|createSlack
argument_list|(
name|sizeConstraint
argument_list|,
name|hardShrinkInterval
argument_list|,
name|Shrinker
argument_list|)
expr_stmt|;
name|preferredVariables
operator|+=
name|slack
operator|.
name|first
expr_stmt|;
name|preferredConstraints
operator|+=
name|slack
operator|.
name|second
expr_stmt|;
comment|// Add to objective with ratio == N (hard)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
name|slack
operator|.
name|first
argument_list|,
name|variables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Can grow if really necessary
specifier|const
name|qreal
name|hardGrowInterval
init|=
name|ad
operator|->
name|maxSize
operator|-
name|ad
operator|->
name|maxPrefSize
decl_stmt|;
if|if
condition|(
name|hardGrowInterval
condition|)
block|{
name|slack
operator|=
name|createSlack
argument_list|(
name|sizeConstraint
argument_list|,
name|hardGrowInterval
argument_list|,
name|Grower
argument_list|)
expr_stmt|;
name|preferredVariables
operator|+=
name|slack
operator|.
name|first
expr_stmt|;
name|preferredConstraints
operator|+=
name|slack
operator|.
name|second
expr_stmt|;
comment|// Add to objective with ratio == N (hard)
name|objective
operator|.
name|variables
operator|.
name|insert
argument_list|(
name|slack
operator|.
name|first
argument_list|,
name|variables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|QSimplex
modifier|*
name|simplex
init|=
operator|new
name|QSimplex
decl_stmt|;
name|bool
name|feasible
init|=
name|simplex
operator|->
name|setConstraints
argument_list|(
name|constraints
operator|+
name|preferredConstraints
argument_list|)
decl_stmt|;
if|if
condition|(
name|feasible
condition|)
block|{
name|simplex
operator|->
name|setObjective
argument_list|(
operator|&
name|objective
argument_list|)
expr_stmt|;
comment|// Calculate minimum values
name|simplex
operator|->
name|solveMin
argument_list|()
expr_stmt|;
comment|// Save sizeAtPreferred results
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|variables
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|AnchorData
modifier|*
name|ad
init|=
name|variables
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ad
operator|->
name|sizeAtPreferred
operator|=
name|ad
operator|->
name|result
operator|-
name|g_offset
expr_stmt|;
block|}
block|}
comment|// Make sure we delete the simplex solver -before- we delete the
comment|// constraints used by it.
operator|delete
name|simplex
expr_stmt|;
comment|// Delete constraints and variables we created.
name|qDeleteAll
argument_list|(
name|preferredConstraints
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|preferredVariables
argument_list|)
expr_stmt|;
return|return
name|feasible
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns true if there are no arrangement that satisfies all constraints.     Otherwise returns false.      \sa addAnchor() */
end_comment
begin_function
DECL|function|hasConflicts
name|bool
name|QGraphicsAnchorLayoutPrivate
operator|::
name|hasConflicts
parameter_list|()
specifier|const
block|{
name|QGraphicsAnchorLayoutPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QGraphicsAnchorLayoutPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|calculateGraphs
argument_list|()
expr_stmt|;
name|bool
name|floatConflict
init|=
operator|!
name|m_floatItems
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|m_floatItems
index|[
literal|1
index|]
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
return|return
name|graphHasConflicts
index|[
literal|0
index|]
operator|||
name|graphHasConflicts
index|[
literal|1
index|]
operator|||
name|floatConflict
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEBUG
end_ifdef
begin_function
DECL|function|dumpGraph
name|void
name|QGraphicsAnchorLayoutPrivate
operator|::
name|dumpGraph
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"anchorlayout.%1.dot"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Text
operator||
name|QIODevice
operator|::
name|Truncate
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"Could not write to %s"
argument_list|,
name|file
operator|.
name|fileName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QString
name|str
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"digraph anchorlayout {\nnode [shape=\"rect\"]\n%1}"
argument_list|)
decl_stmt|;
name|QString
name|dotContents
init|=
name|graph
index|[
literal|0
index|]
operator|.
name|serializeToDot
argument_list|()
decl_stmt|;
name|dotContents
operator|+=
name|graph
index|[
literal|1
index|]
operator|.
name|serializeToDot
argument_list|()
expr_stmt|;
name|file
operator|.
name|write
argument_list|(
name|str
operator|.
name|arg
argument_list|(
name|dotContents
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSVIEW
end_comment
end_unit
