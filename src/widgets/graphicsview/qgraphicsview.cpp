begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|QGRAPHICSVIEW_REGION_RECT_THRESHOLD
specifier|static
specifier|const
name|int
name|QGRAPHICSVIEW_REGION_RECT_THRESHOLD
init|=
literal|50
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QGRAPHICSVIEW_PREALLOC_STYLE_OPTIONS
specifier|static
specifier|const
name|int
name|QGRAPHICSVIEW_PREALLOC_STYLE_OPTIONS
init|=
literal|503
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|QGRAPHICSVIEW_PREALLOC_STYLE_OPTIONS
comment|// largest prime< 2^9
end_comment
begin_comment
comment|/*!     \class QGraphicsView     \brief The QGraphicsView class provides a widget for displaying the     contents of a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable     viewport. To create a scene with geometrical items, see QGraphicsScene's     documentation. QGraphicsView is part of the \l{Graphics View Framework}.      To visualize a scene, you start by constructing a QGraphicsView object,     passing the address of the scene you want to visualize to QGraphicsView's     constructor. Alternatively, you can call setScene() to set the scene at a     later point. After you call show(), the view will by default scroll to the     center of the scene and display any items that are visible at this     point. For example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 0      You can explicitly scroll to any position on the scene by using the     scroll bars, or by calling centerOn(). By passing a point to centerOn(),     QGraphicsView will scroll its viewport to ensure that the point is     centered in the view. An overload is provided for scrolling to a     QGraphicsItem, in which case QGraphicsView will see to that the center of     the item is centered in the view. If all you want is to ensure that a     certain area is visible, (but not necessarily centered,) you can call     ensureVisible() instead.      QGraphicsView can be used to visualize a whole scene, or only parts of it.     The visualized area is by default detected automatically when the view is     displayed for the first time (by calling     QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle     yourself, you can call setSceneRect(). This will adjust the scroll bars'     ranges appropriately. Note that although the scene supports a virtually     unlimited size, the range of the scroll bars will never exceed the range of     an integer (INT_MIN, INT_MAX).      QGraphicsView visualizes the scene by calling render(). By default, the     items are drawn onto the viewport by using a regular QPainter, and using     default render hints. To change the default render hints that     QGraphicsView passes to QPainter when painting items, you can call     setRenderHints().      By default, QGraphicsView provides a regular QWidget for the viewport     widget. You can access this widget by calling viewport(), or you can     replace it by calling setViewport(). To render using OpenGL, simply call     setViewport(new QGLWidget). QGraphicsView takes ownership of the viewport     widget.      QGraphicsView supports affine transformations, using QTransform. You can     either pass a matrix to setTransform(), or you can call one of the     convenience functions rotate(), scale(), translate() or shear(). The most     two common transformations are scaling, which is used to implement     zooming, and rotation. QGraphicsView keeps the center of the view fixed     during a transformation. Because of the scene alignment (setAligment()),     translating the view will have no visual impact.      You can interact with the items on the scene by using the mouse and     keyboard. QGraphicsView translates the mouse and key events into \e scene     events, (events that inherit QGraphicsSceneEvent,), and forward them to     the visualized scene. In the end, it's the individual item that handles     the events and reacts to them. For example, if you click on a selectable     item, the item will typically let the scene know that it has been     selected, and it will also redraw itself to display a selection     rectangle. Similiary, if you click and drag the mouse to move a movable     item, it's the item that handles the mouse moves and moves itself.  Item     interaction is enabled by default, and you can toggle it by calling     setInteractive().      You can also provide your own custom scene interaction, by creating a     subclass of QGraphicsView, and reimplementing the mouse and key event     handlers. To simplify how you programmatically interact with items in the     view, QGraphicsView provides the mapping functions mapToScene() and     mapFromScene(), and the item accessors items() and itemAt(). These     functions allow you to map points, rectangles, polygons and paths between     view coordinates and scene coordinates, and to find items on the scene     using view coordinates.      \image graphicsview-view.png      \sa QGraphicsScene, QGraphicsItem, QGraphicsSceneEvent */
end_comment
begin_comment
comment|/*!     \enum QGraphicsView::ViewportAnchor      This enums describe the possible anchors that QGraphicsView can     use when the user resizes the view or when the view is     transformed.      \value NoAnchor No anchor, i.e. the view leaves the scene's                     position unchanged.     \value AnchorViewCenter The scene point at the center of the view                             is used as the anchor.     \value AnchorUnderMouse The point under the mouse is used as the anchor.      \sa resizeAnchor, transformationAnchor */
end_comment
begin_comment
comment|/*!     \enum QGraphicsView::ViewportUpdateMode      \since 4.3      This enum describes how QGraphicsView updates its viewport when the scene     contents change or are exposed.      \value FullViewportUpdate When any visible part of the scene changes or is     reexposed, QGraphicsView will update the entire viewport. This approach is     fastest when QGraphicsView spends more time figuring out what to draw than     it would spend drawing (e.g., when very many small items are repeatedly     updated). This is the preferred update mode for viewports that do not     support partial updates, such as QGLWidget, and for viewports that need to     disable scroll optimization.      \value MinimalViewportUpdate QGraphicsView will determine the minimal     viewport region that requires a redraw, minimizing the time spent drawing     by avoiding a redraw of areas that have not changed. This is     QGraphicsView's default mode. Although this approach provides the best     performance in general, if there are many small visible changes on the     scene, QGraphicsView might end up spending more time finding the minimal     approach than it will spend drawing.      \value SmartViewportUpdate QGraphicsView will attempt to find an optimal     update mode by analyzing the areas that require a redraw.      \value BoundingRectViewportUpdate The bounding rectangle of all changes in     the viewport will be redrawn. This mode has the advantage that     QGraphicsView searches only one region for changes, minimizing time spent     determining what needs redrawing. The disadvantage is that areas that have     not changed also need to be redrawn.      \value NoViewportUpdate QGraphicsView will never update its viewport when     the scene changes; the user is expected to control all updates. This mode     disables all (potentially slow) item visibility testing in QGraphicsView,     and is suitable for scenes that either require a fixed frame rate, or where     the viewport is otherwise updated externally.      \sa viewportUpdateMode */
end_comment
begin_comment
comment|/*!     \enum QGraphicsView::OptimizationFlag      \since 4.3      This enum describes flags that you can enable to improve rendering     performance in QGraphicsView. By default, none of these flags are set.     Note that setting a flag usually imposes a side effect, and this effect     can vary between paint devices and platforms.      \value DontClipPainter This value is obsolete and has no effect.      \value DontSavePainterState When rendering, QGraphicsView protects the     painter state (see QPainter::save()) when rendering the background or     foreground, and when rendering each item. This allows you to leave the     painter in an altered state (i.e., you can call QPainter::setPen() or     QPainter::setBrush() without restoring the state after painting). However,     if the items consistently do restore the state, you should enable this     flag to prevent QGraphicsView from doing the same.      \value DontAdjustForAntialiasing Disables QGraphicsView's antialiasing     auto-adjustment of exposed areas. Items that render antialiased lines on     the boundaries of their QGraphicsItem::boundingRect() can end up rendering     parts of the line outside. To prevent rendering artifacts, QGraphicsView     expands all exposed regions by 2 pixels in all directions. If you enable     this flag, QGraphicsView will no longer perform these adjustments,     minimizing the areas that require redrawing, which improves performance. A     common side effect is that items that do draw with antialiasing can leave     painting traces behind on the scene as they are moved.      \value IndirectPainting Since Qt 4.6, restore the old painting algorithm     that calls QGraphicsView::drawItems() and QGraphicsScene::drawItems().     To be used only for compatibility with old code. */
end_comment
begin_comment
comment|/*!     \enum QGraphicsView::CacheModeFlag      This enum describes the flags that you can set for a QGraphicsView's cache     mode.      \value CacheNone All painting is done directly onto the viewport.      \value CacheBackground The background is cached. This affects both custom     backgrounds, and backgrounds based on the backgroundBrush property. When     this flag is enabled, QGraphicsView will allocate one pixmap with the full     size of the viewport.      \sa cacheMode */
end_comment
begin_comment
comment|/*!     \enum QGraphicsView::DragMode      This enum describes the default action for the view when pressing and     dragging the mouse over the viewport.      \value NoDrag Nothing happens; the mouse event is ignored.      \value ScrollHandDrag The cursor changes into a pointing hand, and     dragging the mouse around will scroll the scrolbars. This mode works both     in \l{QGraphicsView::interactive}{interactive} and non-interactive mode.      \value RubberBandDrag A rubber band will appear. Dragging the mouse will     set the rubber band geometry, and all items covered by the rubber band are     selected. This mode is disabled for non-interactive views.      \sa dragMode, QGraphicsScene::setSelectionArea() */
end_comment
begin_include
include|#
directive|include
file|"qgraphicsview.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsview_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|"qgraphicsitem.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsitem_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qscopedvaluerollback.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qevent.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qlayout.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qtransform.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qmatrix.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainter.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qscrollbar.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<private/qevent_p.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|q_round_bound
specifier|inline
name|int
name|q_round_bound
parameter_list|(
name|qreal
name|d
parameter_list|)
comment|//### (int)(qreal) INT_MAX != INT_MAX for single precision
block|{
if|if
condition|(
name|d
operator|<=
operator|(
name|qreal
operator|)
name|INT_MIN
condition|)
return|return
name|INT_MIN
return|;
elseif|else
if|if
condition|(
name|d
operator|>=
operator|(
name|qreal
operator|)
name|INT_MAX
condition|)
return|return
name|INT_MAX
return|;
return|return
name|d
operator|>=
literal|0.0
condition|?
name|int
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|translateTouchEvent
name|void
name|QGraphicsViewPrivate
operator|::
name|translateTouchEvent
parameter_list|(
name|QGraphicsViewPrivate
modifier|*
name|d
parameter_list|,
name|QTouchEvent
modifier|*
name|touchEvent
parameter_list|)
block|{
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchPoints
index|[
name|i
index|]
decl_stmt|;
comment|// the scene will set the item local pos, startPos, lastPos, and rect before delivering to
comment|// an item, but for now those functions are returning the view's local coordinates
name|touchPoint
operator|.
name|setSceneRect
argument_list|(
name|d
operator|->
name|mapToScene
argument_list|(
name|touchPoint
operator|.
name|rect
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setStartScenePos
argument_list|(
name|d
operator|->
name|mapToScene
argument_list|(
name|touchPoint
operator|.
name|startPos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setLastScenePos
argument_list|(
name|d
operator|->
name|mapToScene
argument_list|(
name|touchPoint
operator|.
name|lastPos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// screenPos, startScreenPos, lastScreenPos, and screenRect are already set
block|}
name|touchEvent
operator|->
name|setTouchPoints
argument_list|(
name|touchPoints
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGraphicsViewPrivate
name|QGraphicsViewPrivate
operator|::
name|QGraphicsViewPrivate
parameter_list|()
member_init_list|:
name|renderHints
argument_list|(
name|QPainter
operator|::
name|TextAntialiasing
argument_list|)
member_init_list|,
name|dragMode
argument_list|(
name|QGraphicsView
operator|::
name|NoDrag
argument_list|)
member_init_list|,
name|sceneInteractionAllowed
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|hasSceneRect
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|connectedToScene
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|useLastMouseEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|identityMatrix
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|dirtyScroll
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|accelerateScrolling
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|keepLastCenterPoint
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|transforming
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|handScrolling
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mustAllocateStyleOptions
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mustResizeBackgroundPixmap
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|fullUpdatePending
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|hasUpdateClip
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mousePressButton
argument_list|(
name|Qt
operator|::
name|NoButton
argument_list|)
member_init_list|,
name|leftIndent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|topIndent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastMouseEvent
argument_list|(
name|QEvent
operator|::
name|None
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|QPointF
argument_list|()
argument_list|,
name|Qt
operator|::
name|NoButton
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|alignment
argument_list|(
name|Qt
operator|::
name|AlignCenter
argument_list|)
member_init_list|,
name|transformationAnchor
argument_list|(
name|QGraphicsView
operator|::
name|AnchorViewCenter
argument_list|)
member_init_list|,
name|resizeAnchor
argument_list|(
name|QGraphicsView
operator|::
name|NoAnchor
argument_list|)
member_init_list|,
name|viewportUpdateMode
argument_list|(
name|QGraphicsView
operator|::
name|MinimalViewportUpdate
argument_list|)
member_init_list|,
name|optimizationFlags
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|scene
argument_list|(
literal|0
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
name|rubberBanding
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|rubberBandSelectionMode
argument_list|(
name|Qt
operator|::
name|IntersectsItemShape
argument_list|)
member_init_list|,
endif|#
directive|endif
name|handScrollMotions
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cacheMode
argument_list|(
literal|0
argument_list|)
member_init_list|,
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|hasStoredOriginalCursor
argument_list|(
literal|false
argument_list|)
member_init_list|,
endif|#
directive|endif
name|lastDragDropEvent
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|updateSceneSlotReimplementedChecked
argument_list|(
literal|false
argument_list|)
block|{
name|styleOptions
operator|.
name|reserve
argument_list|(
name|QGRAPHICSVIEW_PREALLOC_STYLE_OPTIONS
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|recalculateContentSize
name|void
name|QGraphicsViewPrivate
operator|::
name|recalculateContentSize
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QSize
name|maxSize
init|=
name|q
operator|->
name|maximumViewportSize
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|maxSize
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|maxSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|QRectF
name|viewRect
init|=
name|matrix
operator|.
name|mapRect
argument_list|(
name|q
operator|->
name|sceneRect
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|frameOnlyAround
init|=
operator|(
name|q
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_ScrollView_FrameOnlyAroundContents
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|frameOnlyAround
condition|)
block|{
if|if
condition|(
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|height
operator|-=
name|frameWidth
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAlwaysOn
condition|)
name|width
operator|-=
name|frameWidth
operator|*
literal|2
expr_stmt|;
block|}
comment|// Adjust the maximum width and height of the viewport based on the width
comment|// of visible scroll bars.
name|int
name|scrollBarExtent
init|=
name|q
operator|->
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_ScrollBarExtent
argument_list|,
literal|0
argument_list|,
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|frameOnlyAround
condition|)
name|scrollBarExtent
operator|+=
name|frameWidth
operator|*
literal|2
expr_stmt|;
comment|// We do not need to subtract the width scrollbars whose policy is
comment|// Qt::ScrollBarAlwaysOn, this was already done by maximumViewportSize().
name|bool
name|useHorizontalScrollBar
init|=
operator|(
name|viewRect
operator|.
name|width
argument_list|()
operator|>
name|width
operator|)
operator|&&
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
decl_stmt|;
name|bool
name|useVerticalScrollBar
init|=
operator|(
name|viewRect
operator|.
name|height
argument_list|()
operator|>
name|height
operator|)
operator|&&
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
decl_stmt|;
if|if
condition|(
name|useHorizontalScrollBar
operator|&&
name|vbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
condition|)
block|{
if|if
condition|(
name|viewRect
operator|.
name|height
argument_list|()
operator|>
name|height
operator|-
name|scrollBarExtent
condition|)
name|useVerticalScrollBar
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|useVerticalScrollBar
operator|&&
name|hbarpolicy
operator|==
name|Qt
operator|::
name|ScrollBarAsNeeded
condition|)
block|{
if|if
condition|(
name|viewRect
operator|.
name|width
argument_list|()
operator|>
name|width
operator|-
name|scrollBarExtent
condition|)
name|useHorizontalScrollBar
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|useHorizontalScrollBar
condition|)
name|height
operator|-=
name|scrollBarExtent
expr_stmt|;
if|if
condition|(
name|useVerticalScrollBar
condition|)
name|width
operator|-=
name|scrollBarExtent
expr_stmt|;
comment|// Setting the ranges of these scroll bars can/will cause the values to
comment|// change, and scrollContentsBy() will be called correspondingly. This
comment|// will reset the last center point.
name|QPointF
name|savedLastCenterPoint
init|=
name|lastCenterPoint
decl_stmt|;
comment|// Remember the former indent settings
name|qreal
name|oldLeftIndent
init|=
name|leftIndent
decl_stmt|;
name|qreal
name|oldTopIndent
init|=
name|topIndent
decl_stmt|;
comment|// If the whole scene fits horizontally, we center the scene horizontally,
comment|// and ignore the horizontal scroll bars.
name|int
name|left
init|=
name|q_round_bound
argument_list|(
name|viewRect
operator|.
name|left
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|right
init|=
name|q_round_bound
argument_list|(
name|viewRect
operator|.
name|right
argument_list|()
operator|-
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|>=
name|right
condition|)
block|{
name|hbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignHorizontal_Mask
condition|)
block|{
case|case
name|Qt
operator|::
name|AlignLeft
case|:
name|leftIndent
operator|=
operator|-
name|viewRect
operator|.
name|left
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignRight
case|:
name|leftIndent
operator|=
name|width
operator|-
name|viewRect
operator|.
name|width
argument_list|()
operator|-
name|viewRect
operator|.
name|left
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignHCenter
case|:
default|default:
name|leftIndent
operator|=
name|width
operator|/
literal|2
operator|-
operator|(
name|viewRect
operator|.
name|left
argument_list|()
operator|+
name|viewRect
operator|.
name|right
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|hbar
operator|->
name|setRange
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setPageStep
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|hbar
operator|->
name|setSingleStep
argument_list|(
name|width
operator|/
literal|20
argument_list|)
expr_stmt|;
name|leftIndent
operator|=
literal|0
expr_stmt|;
block|}
comment|// If the whole scene fits vertically, we center the scene vertically, and
comment|// ignore the vertical scroll bars.
name|int
name|top
init|=
name|q_round_bound
argument_list|(
name|viewRect
operator|.
name|top
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bottom
init|=
name|q_round_bound
argument_list|(
name|viewRect
operator|.
name|bottom
argument_list|()
operator|-
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|top
operator|>=
name|bottom
condition|)
block|{
name|vbar
operator|->
name|setRange
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignVertical_Mask
condition|)
block|{
case|case
name|Qt
operator|::
name|AlignTop
case|:
name|topIndent
operator|=
operator|-
name|viewRect
operator|.
name|top
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignBottom
case|:
name|topIndent
operator|=
name|height
operator|-
name|viewRect
operator|.
name|height
argument_list|()
operator|-
name|viewRect
operator|.
name|top
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|AlignVCenter
case|:
default|default:
name|topIndent
operator|=
name|height
operator|/
literal|2
operator|-
operator|(
name|viewRect
operator|.
name|top
argument_list|()
operator|+
name|viewRect
operator|.
name|bottom
argument_list|()
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|vbar
operator|->
name|setRange
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setPageStep
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|vbar
operator|->
name|setSingleStep
argument_list|(
name|height
operator|/
literal|20
argument_list|)
expr_stmt|;
name|topIndent
operator|=
literal|0
expr_stmt|;
block|}
comment|// Restorethe center point from before the ranges changed.
name|lastCenterPoint
operator|=
name|savedLastCenterPoint
expr_stmt|;
comment|// Issue a full update if the indents change.
comment|// ### If the transform is still the same, we can get away with just a
comment|// scroll instead.
if|if
condition|(
name|oldLeftIndent
operator|!=
name|leftIndent
operator|||
name|oldTopIndent
operator|!=
name|topIndent
condition|)
block|{
name|dirtyScroll
operator|=
literal|true
expr_stmt|;
name|updateAll
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
operator|&&
operator|!
name|leftIndent
condition|)
block|{
comment|// In reverse mode, the horizontal scroll always changes after the content
comment|// size has changed, as the scroll is calculated by summing the min and
comment|// max values of the range and subtracting the current value. In normal
comment|// mode the scroll remains unchanged unless the indent has changed.
name|dirtyScroll
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cacheMode
operator|&
name|QGraphicsView
operator|::
name|CacheBackground
condition|)
block|{
comment|// Invalidate the background pixmap
name|mustResizeBackgroundPixmap
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|centerView
name|void
name|QGraphicsViewPrivate
operator|::
name|centerView
parameter_list|(
name|QGraphicsView
operator|::
name|ViewportAnchor
name|anchor
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|anchor
condition|)
block|{
case|case
name|QGraphicsView
operator|::
name|AnchorUnderMouse
case|:
block|{
if|if
condition|(
name|q
operator|->
name|underMouse
argument_list|()
condition|)
block|{
comment|// Last scene pos: lastMouseMoveScenePoint
comment|// Current mouse pos:
name|QPointF
name|transformationDiff
init|=
name|q
operator|->
name|mapToScene
argument_list|(
name|viewport
operator|->
name|rect
argument_list|()
operator|.
name|center
argument_list|()
argument_list|)
operator|-
name|q
operator|->
name|mapToScene
argument_list|(
name|viewport
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|q
operator|->
name|centerOn
argument_list|(
name|lastMouseMoveScenePoint
operator|+
name|transformationDiff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|centerOn
argument_list|(
name|lastCenterPoint
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QGraphicsView
operator|::
name|AnchorViewCenter
case|:
name|q
operator|->
name|centerOn
argument_list|(
name|lastCenterPoint
argument_list|)
expr_stmt|;
break|break;
case|case
name|QGraphicsView
operator|::
name|NoAnchor
case|:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateLastCenterPoint
name|void
name|QGraphicsViewPrivate
operator|::
name|updateLastCenterPoint
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|lastCenterPoint
operator|=
name|q
operator|->
name|mapToScene
argument_list|(
name|viewport
operator|->
name|rect
argument_list|()
operator|.
name|center
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the horizontal scroll value (the X value of the left edge of the     viewport). */
end_comment
begin_function
DECL|function|horizontalScroll
name|qint64
name|QGraphicsViewPrivate
operator|::
name|horizontalScroll
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
return|return
name|scrollX
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the vertical scroll value (the X value of the top edge of the     viewport). */
end_comment
begin_function
DECL|function|verticalScroll
name|qint64
name|QGraphicsViewPrivate
operator|::
name|verticalScroll
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
return|return
name|scrollY
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Maps the given rectangle to the scene using QTransform::mapRect() */
end_comment
begin_function
DECL|function|mapRectToScene
name|QRectF
name|QGraphicsViewPrivate
operator|::
name|mapRectToScene
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
name|QRectF
name|scrolled
init|=
name|QRectF
argument_list|(
name|rect
operator|.
name|translated
argument_list|(
name|scrollX
argument_list|,
name|scrollY
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|identityMatrix
condition|?
name|scrolled
else|:
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|scrolled
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Maps the given rectangle from the scene using QTransform::mapRect() */
end_comment
begin_function
DECL|function|mapRectFromScene
name|QRectF
name|QGraphicsViewPrivate
operator|::
name|mapRectFromScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
return|return
operator|(
name|identityMatrix
condition|?
name|rect
else|:
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|)
operator|.
name|translated
argument_list|(
operator|-
name|scrollX
argument_list|,
operator|-
name|scrollY
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|updateScroll
name|void
name|QGraphicsViewPrivate
operator|::
name|updateScroll
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|scrollX
operator|=
name|qint64
argument_list|(
operator|-
name|leftIndent
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isRightToLeft
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|leftIndent
condition|)
block|{
name|scrollX
operator|+=
name|hbar
operator|->
name|minimum
argument_list|()
expr_stmt|;
name|scrollX
operator|+=
name|hbar
operator|->
name|maximum
argument_list|()
expr_stmt|;
name|scrollX
operator|-=
name|hbar
operator|->
name|value
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|scrollX
operator|+=
name|hbar
operator|->
name|value
argument_list|()
expr_stmt|;
block|}
name|scrollY
operator|=
name|qint64
argument_list|(
name|vbar
operator|->
name|value
argument_list|()
operator|-
name|topIndent
argument_list|)
expr_stmt|;
name|dirtyScroll
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|replayLastMouseEvent
name|void
name|QGraphicsViewPrivate
operator|::
name|replayLastMouseEvent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|useLastMouseEvent
operator|||
operator|!
name|scene
condition|)
return|return;
name|mouseMoveEventHandler
argument_list|(
operator|&
name|lastMouseEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|storeMouseEvent
name|void
name|QGraphicsViewPrivate
operator|::
name|storeMouseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|useLastMouseEvent
operator|=
literal|true
expr_stmt|;
name|lastMouseEvent
operator|=
name|QMouseEvent
argument_list|(
name|QEvent
operator|::
name|MouseMove
argument_list|,
name|event
operator|->
name|localPos
argument_list|()
argument_list|,
name|event
operator|->
name|windowPos
argument_list|()
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|,
name|event
operator|->
name|button
argument_list|()
argument_list|,
name|event
operator|->
name|buttons
argument_list|()
argument_list|,
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mouseMoveEventHandler
name|void
name|QGraphicsViewPrivate
operator|::
name|mouseMoveEventHandler
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|storeMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|lastMouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sceneInteractionAllowed
condition|)
return|return;
if|if
condition|(
name|handScrolling
condition|)
return|return;
if|if
condition|(
operator|!
name|scene
condition|)
return|return;
name|QGraphicsSceneMouseEvent
name|mouseEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneMouseMove
argument_list|)
decl_stmt|;
name|mouseEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScenePos
argument_list|(
name|mousePressButton
argument_list|,
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScreenPos
argument_list|(
name|mousePressButton
argument_list|,
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScenePos
argument_list|(
name|q
operator|->
name|mapToScene
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScreenPos
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScenePos
argument_list|(
name|lastMouseMoveScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScreenPos
argument_list|(
name|lastMouseMoveScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButton
argument_list|(
name|event
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|lastMouseMoveScenePoint
operator|=
name|mouseEvent
operator|.
name|scenePos
argument_list|()
expr_stmt|;
name|lastMouseMoveScreenPoint
operator|=
name|mouseEvent
operator|.
name|screenPos
argument_list|()
expr_stmt|;
name|mouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
name|qt_sendSpontaneousEvent
argument_list|(
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
comment|// Remember whether the last event was accepted or not.
name|lastMouseEvent
operator|.
name|setAccepted
argument_list|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
operator|&&
name|mouseEvent
operator|.
name|buttons
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// The event was delivered to a mouse grabber; the press is likely to
comment|// have set a cursor, and we must not change it.
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|// If all the items ignore hover events, we don't look-up any items
comment|// in QGraphicsScenePrivate::dispatchHoverEvent, hence the
comment|// cachedItemsUnderMouse list will be empty. We therefore do the look-up
comment|// for cursor items here if not all items use the default cursor.
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|&&
operator|!
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsUseDefaultCursor
operator|&&
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|cachedItemsUnderMouse
operator|=
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|itemsAtPosition
argument_list|(
name|mouseEvent
operator|.
name|screenPos
argument_list|()
argument_list|,
name|mouseEvent
operator|.
name|scenePos
argument_list|()
argument_list|,
name|mouseEvent
operator|.
name|widget
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Find the topmost item under the mouse with a cursor.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|cachedItemsUnderMouse
control|)
block|{
if|if
condition|(
name|item
operator|->
name|hasCursor
argument_list|()
condition|)
block|{
name|_q_setViewportCursor
argument_list|(
name|item
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// No items with cursors found; revert to the view cursor.
if|if
condition|(
name|hasStoredOriginalCursor
condition|)
block|{
comment|// Restore the original viewport cursor.
name|hasStoredOriginalCursor
operator|=
literal|false
expr_stmt|;
name|viewport
operator|->
name|setCursor
argument_list|(
name|originalCursor
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
end_ifndef
begin_function
DECL|function|rubberBandRegion
name|QRegion
name|QGraphicsViewPrivate
operator|::
name|rubberBandRegion
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QStyleHintReturnMask
name|mask
decl_stmt|;
name|QStyleOptionRubberBand
name|option
decl_stmt|;
name|option
operator|.
name|initFrom
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|option
operator|.
name|rect
operator|=
name|rect
expr_stmt|;
name|option
operator|.
name|opaque
operator|=
literal|false
expr_stmt|;
name|option
operator|.
name|shape
operator|=
name|QRubberBand
operator|::
name|Rectangle
expr_stmt|;
name|QRegion
name|tmp
decl_stmt|;
name|tmp
operator|+=
name|rect
expr_stmt|;
if|if
condition|(
name|widget
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_RubberBand_Mask
argument_list|,
operator|&
name|option
argument_list|,
name|widget
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
name|tmp
operator|&=
name|mask
operator|.
name|region
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|_q_setViewportCursor
name|void
name|QGraphicsViewPrivate
operator|::
name|_q_setViewportCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasStoredOriginalCursor
condition|)
block|{
name|hasStoredOriginalCursor
operator|=
literal|true
expr_stmt|;
name|originalCursor
operator|=
name|viewport
operator|->
name|cursor
argument_list|()
expr_stmt|;
block|}
name|viewport
operator|->
name|setCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_function
DECL|function|_q_unsetViewportCursor
name|void
name|QGraphicsViewPrivate
operator|::
name|_q_unsetViewportCursor
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|q
operator|->
name|items
argument_list|(
name|lastMouseEvent
operator|.
name|pos
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|item
operator|->
name|hasCursor
argument_list|()
condition|)
block|{
name|_q_setViewportCursor
argument_list|(
name|item
operator|->
name|cursor
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Restore the original viewport cursor.
if|if
condition|(
name|hasStoredOriginalCursor
condition|)
block|{
name|hasStoredOriginalCursor
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|ScrollHandDrag
condition|)
name|viewport
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|OpenHandCursor
argument_list|)
expr_stmt|;
else|else
name|viewport
operator|->
name|setCursor
argument_list|(
name|originalCursor
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|storeDragDropEvent
name|void
name|QGraphicsViewPrivate
operator|::
name|storeDragDropEvent
parameter_list|(
specifier|const
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
operator|delete
name|lastDragDropEvent
expr_stmt|;
name|lastDragDropEvent
operator|=
operator|new
name|QGraphicsSceneDragDropEvent
argument_list|(
name|event
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setScenePos
argument_list|(
name|event
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setScreenPos
argument_list|(
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setPossibleActions
argument_list|(
name|event
operator|->
name|possibleActions
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setProposedAction
argument_list|(
name|event
operator|->
name|proposedAction
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setDropAction
argument_list|(
name|event
operator|->
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setMimeData
argument_list|(
name|event
operator|->
name|mimeData
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setWidget
argument_list|(
name|event
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|lastDragDropEvent
operator|->
name|setSource
argument_list|(
name|event
operator|->
name|source
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|populateSceneDragDropEvent
name|void
name|QGraphicsViewPrivate
operator|::
name|populateSceneDragDropEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|dest
parameter_list|,
name|QDropEvent
modifier|*
name|source
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setScenePos
argument_list|(
name|q
operator|->
name|mapToScene
argument_list|(
name|source
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setScreenPos
argument_list|(
name|q
operator|->
name|mapToGlobal
argument_list|(
name|source
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setButtons
argument_list|(
name|source
operator|->
name|mouseButtons
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setModifiers
argument_list|(
name|source
operator|->
name|keyboardModifiers
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setPossibleActions
argument_list|(
name|source
operator|->
name|possibleActions
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setProposedAction
argument_list|(
name|source
operator|->
name|proposedAction
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setDropAction
argument_list|(
name|source
operator|->
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setMimeData
argument_list|(
name|source
operator|->
name|mimeData
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setWidget
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setSource
argument_list|(
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|source
operator|->
name|source
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|dest
argument_list|)
name|Q_UNUSED
argument_list|(
argument|source
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mapToViewRect
name|QRect
name|QGraphicsViewPrivate
operator|::
name|mapToViewRect
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|QTransform
name|itv
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|q
operator|->
name|viewportTransform
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|itv
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
comment|// Translate-only
comment|// COMBINE
name|QPointF
name|offset
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|parentItem
init|=
name|item
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
decl_stmt|;
do|do
block|{
name|itemd
operator|=
name|parentItem
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|itemd
operator|->
name|transformData
condition|)
break|break;
name|offset
operator|+=
name|itemd
operator|->
name|pos
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|parentItem
operator|=
name|itemd
operator|->
name|parent
operator|)
condition|)
do|;
name|QRectF
name|baseRect
init|=
name|rect
operator|.
name|translated
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|,
name|offset
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentItem
condition|)
block|{
if|if
condition|(
name|identityMatrix
condition|)
block|{
name|baseRect
operator|.
name|translate
argument_list|(
operator|-
name|scrollX
argument_list|,
operator|-
name|scrollY
argument_list|)
expr_stmt|;
return|return
name|baseRect
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
return|return
name|matrix
operator|.
name|mapRect
argument_list|(
name|baseRect
argument_list|)
operator|.
name|translated
argument_list|(
operator|-
name|scrollX
argument_list|,
operator|-
name|scrollY
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
name|QTransform
name|tr
init|=
name|parentItem
operator|->
name|sceneTransform
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|identityMatrix
condition|)
name|tr
operator|*=
name|matrix
expr_stmt|;
name|QRectF
name|r
init|=
name|tr
operator|.
name|mapRect
argument_list|(
name|baseRect
argument_list|)
decl_stmt|;
name|r
operator|.
name|translate
argument_list|(
operator|-
name|scrollX
argument_list|,
operator|-
name|scrollY
argument_list|)
expr_stmt|;
return|return
name|r
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mapToViewRegion
name|QRegion
name|QGraphicsViewPrivate
operator|::
name|mapToViewRegion
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirtyScroll
condition|)
cast|const_cast
argument_list|<
name|QGraphicsViewPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|updateScroll
argument_list|()
expr_stmt|;
comment|// Accurate bounding region
name|QTransform
name|itv
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|q
operator|->
name|viewportTransform
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|item
operator|->
name|boundingRegion
argument_list|(
name|itv
argument_list|)
operator|&
name|itv
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|processPendingUpdates
name|void
name|QGraphicsViewPrivate
operator|::
name|processPendingUpdates
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scene
condition|)
return|return;
if|if
condition|(
name|fullUpdatePending
condition|)
block|{
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|BoundingRectViewportUpdate
condition|)
block|{
name|viewport
operator|->
name|update
argument_list|(
name|dirtyBoundingRect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|viewport
operator|->
name|update
argument_list|(
name|dirtyRegion
argument_list|)
expr_stmt|;
comment|// Already adjusted in updateRect/Region.
block|}
name|dirtyBoundingRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|dirtyRegion
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|intersectsViewport
specifier|static
specifier|inline
name|bool
name|intersectsViewport
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
return|return
operator|!
operator|(
name|r
operator|.
name|left
argument_list|()
operator|>
name|width
operator|)
operator|&&
operator|!
operator|(
name|r
operator|.
name|right
argument_list|()
operator|<
literal|0
operator|)
operator|&&
operator|!
operator|(
name|r
operator|.
name|top
argument_list|()
operator|>=
name|height
operator|)
operator|&&
operator|!
operator|(
name|r
operator|.
name|bottom
argument_list|()
operator|<
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|containsViewport
specifier|static
specifier|inline
name|bool
name|containsViewport
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
return|return
name|r
operator|.
name|left
argument_list|()
operator|<=
literal|0
operator|&&
name|r
operator|.
name|top
argument_list|()
operator|<=
literal|0
operator|&&
name|r
operator|.
name|right
argument_list|()
operator|>=
name|width
operator|-
literal|1
operator|&&
name|r
operator|.
name|bottom
argument_list|()
operator|>=
name|height
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|QRect_unite
specifier|static
specifier|inline
name|void
name|QRect_unite
parameter_list|(
name|QRect
modifier|*
name|rect
parameter_list|,
specifier|const
name|QRect
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|rect
operator|=
name|other
expr_stmt|;
block|}
else|else
block|{
name|rect
operator|->
name|setCoords
argument_list|(
name|qMin
argument_list|(
name|rect
operator|->
name|left
argument_list|()
argument_list|,
name|other
operator|.
name|left
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|rect
operator|->
name|top
argument_list|()
argument_list|,
name|other
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|rect
operator|->
name|right
argument_list|()
argument_list|,
name|other
operator|.
name|right
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|rect
operator|->
name|bottom
argument_list|()
argument_list|,
name|other
operator|.
name|bottom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*    Calling this function results in update rects being clipped to the item's    bounding rect. Note that updates prior to this function call is not clipped.    The clip is removed by passing 0. */
end_comment
begin_function
DECL|function|setUpdateClip
name|void
name|QGraphicsViewPrivate
operator|::
name|setUpdateClip
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
comment|// We simply ignore the request if the update mode is either FullViewportUpdate
comment|// or NoViewportUpdate; in that case there's no point in clipping anything.
if|if
condition|(
operator|!
name|item
operator|||
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|NoViewportUpdate
operator|||
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|FullViewportUpdate
condition|)
block|{
name|hasUpdateClip
operator|=
literal|false
expr_stmt|;
return|return;
block|}
comment|// Calculate the clip (item's bounding rect in view coordinates).
comment|// Optimized version of:
comment|// QRect clip = item->deviceTransform(q->viewportTransform())
comment|//              .mapRect(item->boundingRect()).toAlignedRect();
name|QRect
name|clip
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|QTransform
name|xform
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|q
operator|->
name|viewportTransform
argument_list|()
argument_list|)
decl_stmt|;
name|clip
operator|=
name|xform
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
operator|&&
name|identityMatrix
condition|)
block|{
name|QRectF
name|r
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
operator|-
name|horizontalScroll
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
operator|-
name|verticalScroll
argument_list|()
argument_list|)
expr_stmt|;
name|clip
operator|=
name|r
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|q
operator|->
name|isTransformed
argument_list|()
condition|)
block|{
name|clip
operator|=
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QTransform
name|xform
init|=
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
decl_stmt|;
name|xform
operator|*=
name|q
operator|->
name|viewportTransform
argument_list|()
expr_stmt|;
name|clip
operator|=
name|xform
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hasUpdateClip
condition|)
block|{
comment|// Intersect with old clip.
name|updateClip
operator|&=
name|clip
expr_stmt|;
block|}
else|else
block|{
name|updateClip
operator|=
name|clip
expr_stmt|;
name|hasUpdateClip
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateRegion
name|bool
name|QGraphicsViewPrivate
operator|::
name|updateRegion
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|xform
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|MinimalViewportUpdate
operator|&&
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|SmartViewportUpdate
condition|)
block|{
comment|// No point in updating with QRegion granularity; use the rect instead.
return|return
name|updateRectF
argument_list|(
name|xform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
argument_list|)
return|;
block|}
comment|// Update mode is either Minimal or Smart, so we have to do a potentially slow operation,
comment|// which is clearly documented here: QGraphicsItem::setBoundingRegionGranularity.
specifier|const
name|QRegion
name|region
init|=
name|xform
operator|.
name|map
argument_list|(
name|QRegion
argument_list|(
name|rect
operator|.
name|toAlignedRect
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QRect
name|viewRect
init|=
name|region
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|dontAdjustForAntialiasing
init|=
name|optimizationFlags
operator|&
name|QGraphicsView
operator|::
name|DontAdjustForAntialiasing
decl_stmt|;
if|if
condition|(
name|dontAdjustForAntialiasing
condition|)
name|viewRect
operator|.
name|adjust
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|viewRect
operator|.
name|adjust
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intersectsViewport
argument_list|(
name|viewRect
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// Update region for sure outside viewport.
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
modifier|&
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|viewRect
operator|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontAdjustForAntialiasing
condition|)
name|viewRect
operator|.
name|adjust
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|viewRect
operator|.
name|adjust
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasUpdateClip
condition|)
name|viewRect
operator|&=
name|updateClip
expr_stmt|;
name|dirtyRegion
operator|+=
name|viewRect
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// NB! Assumes the rect 'r' is already aligned and adjusted for antialiasing.
end_comment
begin_comment
comment|// For QRectF use updateRectF(const QRectF&) to ensure proper adjustments.
end_comment
begin_function
DECL|function|updateRect
name|bool
name|QGraphicsViewPrivate
operator|::
name|updateRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
if|if
condition|(
name|fullUpdatePending
operator|||
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|NoViewportUpdate
operator|||
operator|!
name|intersectsViewport
argument_list|(
name|r
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|viewportUpdateMode
condition|)
block|{
case|case
name|QGraphicsView
operator|::
name|FullViewportUpdate
case|:
name|fullUpdatePending
operator|=
literal|true
expr_stmt|;
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsView
operator|::
name|BoundingRectViewportUpdate
case|:
if|if
condition|(
name|hasUpdateClip
condition|)
name|QRect_unite
argument_list|(
operator|&
name|dirtyBoundingRect
argument_list|,
name|r
operator|&
name|updateClip
argument_list|)
expr_stmt|;
else|else
name|QRect_unite
argument_list|(
operator|&
name|dirtyBoundingRect
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsViewport
argument_list|(
name|dirtyBoundingRect
argument_list|,
name|viewport
operator|->
name|width
argument_list|()
argument_list|,
name|viewport
operator|->
name|height
argument_list|()
argument_list|)
condition|)
block|{
name|fullUpdatePending
operator|=
literal|true
expr_stmt|;
name|viewport
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QGraphicsView
operator|::
name|SmartViewportUpdate
case|:
comment|// ### DEPRECATE
case|case
name|QGraphicsView
operator|::
name|MinimalViewportUpdate
case|:
if|if
condition|(
name|hasUpdateClip
condition|)
name|dirtyRegion
operator|+=
name|r
operator|&
name|updateClip
expr_stmt|;
else|else
name|dirtyRegion
operator|+=
name|r
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|allocStyleOptionsArray
name|QStyleOptionGraphicsItem
modifier|*
name|QGraphicsViewPrivate
operator|::
name|allocStyleOptionsArray
parameter_list|(
name|int
name|numItems
parameter_list|)
block|{
if|if
condition|(
name|mustAllocateStyleOptions
operator|||
operator|(
name|numItems
operator|>
name|styleOptions
operator|.
name|capacity
argument_list|()
operator|)
condition|)
comment|// too many items, let's allocate on-the-fly
return|return
operator|new
name|QStyleOptionGraphicsItem
index|[
name|numItems
index|]
return|;
comment|// expand only whenever necessary
if|if
condition|(
name|numItems
operator|>
name|styleOptions
operator|.
name|size
argument_list|()
condition|)
name|styleOptions
operator|.
name|resize
argument_list|(
name|numItems
argument_list|)
expr_stmt|;
name|mustAllocateStyleOptions
operator|=
literal|true
expr_stmt|;
return|return
name|styleOptions
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|freeStyleOptionsArray
name|void
name|QGraphicsViewPrivate
operator|::
name|freeStyleOptionsArray
parameter_list|(
name|QStyleOptionGraphicsItem
modifier|*
name|array
parameter_list|)
block|{
name|mustAllocateStyleOptions
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|array
operator|!=
name|styleOptions
operator|.
name|data
argument_list|()
condition|)
operator|delete
index|[]
name|array
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     ### Adjustments in findItems: mapToScene(QRect) forces us to adjust the     input rectangle by (0, 0, 1, 1), because it uses QRect::bottomRight()     (etc) when mapping the rectangle to a polygon (which is _wrong_). In     addition, as QGraphicsItem::boundingRect() is defined in logical space,     but the default pen for QPainter is cosmetic with a width of 0, QPainter     is at risk of painting 1 pixel outside the bounding rect. Therefore we     must search for items with an adjustment of (-1, -1, 1, 1). */
end_comment
begin_function
DECL|function|findItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsViewPrivate
operator|::
name|findItems
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|exposedRegion
parameter_list|,
name|bool
modifier|*
name|allItems
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|viewTransform
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
comment|// Step 1) If all items are contained within the expose region, then
comment|// return a list of all visible items. ### the scene's growing bounding
comment|// rect does not take into account untransformable items.
specifier|const
name|QRectF
name|exposedRegionSceneBounds
init|=
name|q
operator|->
name|mapToScene
argument_list|(
name|exposedRegion
operator|.
name|boundingRect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|exposedRegionSceneBounds
operator|.
name|contains
argument_list|(
name|scene
operator|->
name|sceneRect
argument_list|()
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|allItems
argument_list|)
expr_stmt|;
operator|*
name|allItems
operator|=
literal|true
expr_stmt|;
comment|// All items are guaranteed within the exposed region.
return|return
name|scene
operator|->
name|items
argument_list|(
name|Qt
operator|::
name|AscendingOrder
argument_list|)
return|;
block|}
comment|// Step 2) If the expose region is a simple rect and the view is only
comment|// translated or scaled, search for items using
comment|// QGraphicsScene::items(QRectF).
name|bool
name|simpleRectLookup
init|=
name|exposedRegion
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
operator|&&
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
decl_stmt|;
if|if
condition|(
name|simpleRectLookup
condition|)
block|{
return|return
name|scene
operator|->
name|items
argument_list|(
name|exposedRegionSceneBounds
argument_list|,
name|Qt
operator|::
name|IntersectsItemBoundingRect
argument_list|,
name|Qt
operator|::
name|AscendingOrder
argument_list|,
name|viewTransform
argument_list|)
return|;
block|}
comment|// If the region is complex or the view has a complex transform, adjust
comment|// the expose region, convert it to a path, and then search for items
comment|// using QGraphicsScene::items(QPainterPath);
name|QRegion
name|adjustedRegion
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|r
decl|,
name|exposedRegion
operator|.
name|rects
argument_list|()
control|)
name|adjustedRegion
operator|+=
name|r
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QPainterPath
name|exposedScenePath
argument_list|(
name|q
operator|->
name|mapToScene
argument_list|(
name|qt_regionToPath
argument_list|(
name|adjustedRegion
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|scene
operator|->
name|items
argument_list|(
name|exposedScenePath
argument_list|,
name|Qt
operator|::
name|IntersectsItemBoundingRect
argument_list|,
name|Qt
operator|::
name|AscendingOrder
argument_list|,
name|viewTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Enables input methods for the view if and only if the current focus item of     the scene accepts input methods. Call function whenever that condition has     potentially changed. */
end_comment
begin_function
DECL|function|updateInputMethodSensitivity
name|void
name|QGraphicsViewPrivate
operator|::
name|updateInputMethodSensitivity
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|focusItem
init|=
literal|0
decl_stmt|;
name|bool
name|enabled
init|=
name|scene
operator|&&
operator|(
name|focusItem
operator|=
name|scene
operator|->
name|focusItem
argument_list|()
operator|)
operator|&&
operator|(
name|focusItem
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
operator|)
decl_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|q
operator|->
name|viewport
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
name|q
operator|->
name|setInputMethodHints
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|focusItem
operator|->
name|d_ptr
operator|->
name|isWidget
operator|&&
name|focusItem
operator|->
name|d_ptr
operator|->
name|isProxyWidget
argument_list|()
condition|?
cast|static_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|focusItem
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|proxy
condition|)
block|{
name|q
operator|->
name|setInputMethodHints
argument_list|(
name|focusItem
operator|->
name|inputMethodHints
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QWidget
modifier|*
name|widget
init|=
name|proxy
operator|->
name|widget
argument_list|()
condition|)
block|{
if|if
condition|(
name|QWidget
modifier|*
name|fw
init|=
name|widget
operator|->
name|focusWidget
argument_list|()
condition|)
name|widget
operator|=
name|fw
expr_stmt|;
name|q
operator|->
name|setInputMethodHints
argument_list|(
name|widget
operator|->
name|inputMethodHints
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|setInputMethodHints
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a QGraphicsView. \a parent is passed to QWidget's constructor. */
end_comment
begin_constructor
DECL|function|QGraphicsView
name|QGraphicsView
operator|::
name|QGraphicsView
parameter_list|(
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|new
name|QGraphicsViewPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|setViewport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
comment|// Investigate leaving these disabled by default.
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsView and sets the visualized scene to \a     scene. \a parent is passed to QWidget's constructor. */
end_comment
begin_constructor
DECL|function|QGraphicsView
name|QGraphicsView
operator|::
name|QGraphicsView
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
operator|*
operator|new
name|QGraphicsViewPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|setScene
argument_list|(
name|scene
argument_list|)
expr_stmt|;
name|setViewport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
comment|// Investigate leaving these disabled by default.
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal  */
end_comment
begin_constructor
DECL|function|QGraphicsView
name|QGraphicsView
operator|::
name|QGraphicsView
parameter_list|(
name|QGraphicsViewPrivate
modifier|&
name|dd
parameter_list|,
name|QWidget
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractScrollArea
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|setViewport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setBackgroundRole
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
comment|// Investigate leaving these disabled by default.
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_InputMethodEnabled
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QGraphicsView object. */
end_comment
begin_destructor
DECL|function|~QGraphicsView
name|QGraphicsView
operator|::
name|~
name|QGraphicsView
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|views
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|lastDragDropEvent
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSize
name|QGraphicsView
operator|::
name|sizeHint
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
name|QSizeF
name|baseSize
init|=
name|d
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|sceneRect
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|baseSize
operator|+=
name|QSizeF
argument_list|(
name|d
operator|->
name|frameWidth
operator|*
literal|2
argument_list|,
name|d
operator|->
name|frameWidth
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|baseSize
operator|.
name|boundedTo
argument_list|(
operator|(
literal|3
operator|*
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|size
argument_list|()
operator|)
operator|/
literal|4
argument_list|)
operator|.
name|toSize
argument_list|()
return|;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|sizeHint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::renderHints     \brief the default render hints for the view      These hints are     used to initialize QPainter before each visible item is drawn. QPainter     uses render hints to toggle rendering features such as antialiasing and     smooth pixmap transformation.      QPainter::TextAntialiasing is enabled by default.      Example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 1 */
end_comment
begin_function
DECL|function|renderHints
name|QPainter
operator|::
name|RenderHints
name|QGraphicsView
operator|::
name|renderHints
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|renderHints
return|;
block|}
end_function
begin_function
DECL|function|setRenderHints
name|void
name|QGraphicsView
operator|::
name|setRenderHints
parameter_list|(
name|QPainter
operator|::
name|RenderHints
name|hints
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|==
name|d
operator|->
name|renderHints
condition|)
return|return;
name|d
operator|->
name|renderHints
operator|=
name|hints
expr_stmt|;
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, the render hint \a hint is enabled; otherwise it     is disabled.      \sa renderHints */
end_comment
begin_function
DECL|function|setRenderHint
name|void
name|QGraphicsView
operator|::
name|setRenderHint
parameter_list|(
name|QPainter
operator|::
name|RenderHint
name|hint
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QPainter
operator|::
name|RenderHints
name|oldHints
init|=
name|d
operator|->
name|renderHints
decl_stmt|;
if|if
condition|(
name|enabled
condition|)
name|d
operator|->
name|renderHints
operator||=
name|hint
expr_stmt|;
else|else
name|d
operator|->
name|renderHints
operator|&=
operator|~
name|hint
expr_stmt|;
if|if
condition|(
name|oldHints
operator|!=
name|d
operator|->
name|renderHints
condition|)
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::alignment     \brief the alignment of the scene in the view when the whole     scene is visible.      If the whole scene is visible in the view, (i.e., there are no visible     scroll bars,) the view's alignment will decide where the scene will be     rendered in the view. For example, if the alignment is Qt::AlignCenter,     which is default, the scene will be centered in the view, and if the     alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in     the top-left corner of the view. */
end_comment
begin_function
DECL|function|alignment
name|Qt
operator|::
name|Alignment
name|QGraphicsView
operator|::
name|alignment
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|alignment
return|;
block|}
end_function
begin_function
DECL|function|setAlignment
name|void
name|QGraphicsView
operator|::
name|setAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|alignment
operator|!=
name|alignment
condition|)
block|{
name|d
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::transformationAnchor     \brief how the view should position the scene during transformations.      QGraphicsView uses this property to decide how to position the scene in     the viewport when the transformation matrix changes, and the coordinate     system of the view is transformed. The default behavior, AnchorViewCenter,     ensures that the scene point at the center of the view remains unchanged     during transformations (e.g., when rotating, the scene will appear to     rotate around the center of the view).      Note that the effect of this property is noticeable when only a part of the     scene is visible (i.e., when there are scroll bars). Otherwise, if the     whole scene fits in the view, QGraphicsScene uses the view \l alignment to     position the scene in the view.      \sa alignment, resizeAnchor */
end_comment
begin_function
DECL|function|transformationAnchor
name|QGraphicsView
operator|::
name|ViewportAnchor
name|QGraphicsView
operator|::
name|transformationAnchor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|transformationAnchor
return|;
block|}
end_function
begin_function
DECL|function|setTransformationAnchor
name|void
name|QGraphicsView
operator|::
name|setTransformationAnchor
parameter_list|(
name|ViewportAnchor
name|anchor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|transformationAnchor
operator|=
name|anchor
expr_stmt|;
comment|// Ensure mouse tracking is enabled in the case we are using AnchorUnderMouse
comment|// in order to have up-to-date information for centering the view.
if|if
condition|(
name|d
operator|->
name|transformationAnchor
operator|==
name|AnchorUnderMouse
condition|)
name|d
operator|->
name|viewport
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::resizeAnchor     \brief how the view should position the scene when the view is resized.      QGraphicsView uses this property to decide how to position the scene in     the viewport when the viewport widget's size changes. The default     behavior, NoAnchor, leaves the scene's position unchanged during a resize;     the top-left corner of the view will appear to be anchored while resizing.      Note that the effect of this property is noticeable when only a part of the     scene is visible (i.e., when there are scroll bars). Otherwise, if the     whole scene fits in the view, QGraphicsScene uses the view \l alignment to     position the scene in the view.      \sa alignment, transformationAnchor */
end_comment
begin_function
DECL|function|resizeAnchor
name|QGraphicsView
operator|::
name|ViewportAnchor
name|QGraphicsView
operator|::
name|resizeAnchor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|resizeAnchor
return|;
block|}
end_function
begin_function
DECL|function|setResizeAnchor
name|void
name|QGraphicsView
operator|::
name|setResizeAnchor
parameter_list|(
name|ViewportAnchor
name|anchor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|resizeAnchor
operator|=
name|anchor
expr_stmt|;
comment|// Ensure mouse tracking is enabled in the case we are using AnchorUnderMouse
comment|// in order to have up-to-date information for centering the view.
if|if
condition|(
name|d
operator|->
name|resizeAnchor
operator|==
name|AnchorUnderMouse
condition|)
name|d
operator|->
name|viewport
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::viewportUpdateMode     \brief how the viewport should update its contents.      \since 4.3      QGraphicsView uses this property to decide how to update areas of the     scene that have been reexposed or changed. Usually you do not need to     modify this property, but there are some cases where doing so can improve     rendering performance. See the ViewportUpdateMode documentation for     specific details.      The default value is MinimalViewportUpdate, where QGraphicsView will     update as small an area of the viewport as possible when the contents     change.      \sa ViewportUpdateMode, cacheMode */
end_comment
begin_function
DECL|function|viewportUpdateMode
name|QGraphicsView
operator|::
name|ViewportUpdateMode
name|QGraphicsView
operator|::
name|viewportUpdateMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|viewportUpdateMode
return|;
block|}
end_function
begin_function
DECL|function|setViewportUpdateMode
name|void
name|QGraphicsView
operator|::
name|setViewportUpdateMode
parameter_list|(
name|ViewportUpdateMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|viewportUpdateMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::optimizationFlags     \brief flags that can be used to tune QGraphicsView's performance.      \since 4.3      QGraphicsView uses clipping, extra bounding rect adjustments, and certain     other aids to improve rendering quality and performance for the common     case graphics scene. However, depending on the target platform, the scene,     and the viewport in use, some of these operations can degrade performance.      The effect varies from flag to flag; see the OptimizationFlags     documentation for details.      By default, no optimization flags are enabled.      \sa setOptimizationFlag() */
end_comment
begin_function
DECL|function|optimizationFlags
name|QGraphicsView
operator|::
name|OptimizationFlags
name|QGraphicsView
operator|::
name|optimizationFlags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|optimizationFlags
return|;
block|}
end_function
begin_function
DECL|function|setOptimizationFlags
name|void
name|QGraphicsView
operator|::
name|setOptimizationFlags
parameter_list|(
name|OptimizationFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|optimizationFlags
operator|=
name|flags
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Enables \a flag if \a enabled is true; otherwise disables \a flag.      \sa optimizationFlags */
end_comment
begin_function
DECL|function|setOptimizationFlag
name|void
name|QGraphicsView
operator|::
name|setOptimizationFlag
parameter_list|(
name|OptimizationFlag
name|flag
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|d
operator|->
name|optimizationFlags
operator||=
name|flag
expr_stmt|;
else|else
name|d
operator|->
name|optimizationFlags
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::dragMode     \brief the behavior for dragging the mouse over the scene while     the left mouse button is pressed.      This property defines what should happen when the user clicks on the scene     background and drags the mouse (e.g., scrolling the viewport contents     using a pointing hand cursor, or selecting multiple items with a rubber     band). The default value, NoDrag, does nothing.      This behavior only affects mouse clicks that are not handled by any item.     You can define a custom behavior by creating a subclass of QGraphicsView     and reimplementing mouseMoveEvent(). */
end_comment
begin_function
DECL|function|dragMode
name|QGraphicsView
operator|::
name|DragMode
name|QGraphicsView
operator|::
name|dragMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dragMode
return|;
block|}
end_function
begin_function
DECL|function|setDragMode
name|void
name|QGraphicsView
operator|::
name|setDragMode
parameter_list|(
name|DragMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|mode
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|ScrollHandDrag
condition|)
name|viewport
argument_list|()
operator|->
name|unsetCursor
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// If dragMode is unset while dragging, e.g. via a keyEvent, we
comment|// don't unset the handScrolling state. When enabling scrolling
comment|// again the mouseMoveEvent will automatically start scrolling,
comment|// without a mousePress
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|ScrollHandDrag
operator|&&
name|mode
operator|==
name|NoDrag
operator|&&
name|d
operator|->
name|handScrolling
condition|)
name|d
operator|->
name|handScrolling
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|dragMode
operator|=
name|mode
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|ScrollHandDrag
condition|)
block|{
comment|// Forget the stored viewport cursor when we enter scroll hand drag mode.
name|d
operator|->
name|hasStoredOriginalCursor
operator|=
literal|false
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|OpenHandCursor
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
end_ifndef
begin_comment
comment|/*!     \property QGraphicsView::rubberBandSelectionMode     \brief the behavior for selecting items with a rubber band selection rectangle.     \since 4.3      This property defines how items are selected when using the RubberBandDrag     drag mode.      The default value is Qt::IntersectsItemShape; all items whose shape     intersects with or is contained by the rubber band are selected.      \sa dragMode, items() */
end_comment
begin_function
DECL|function|rubberBandSelectionMode
name|Qt
operator|::
name|ItemSelectionMode
name|QGraphicsView
operator|::
name|rubberBandSelectionMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rubberBandSelectionMode
return|;
block|}
end_function
begin_function
DECL|function|setRubberBandSelectionMode
name|void
name|QGraphicsView
operator|::
name|setRubberBandSelectionMode
parameter_list|(
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|rubberBandSelectionMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \property QGraphicsView::cacheMode     \brief which parts of the view are cached      QGraphicsView can cache pre-rendered content in a QPixmap, which is then     drawn onto the viewport. The purpose of such caching is to speed up the     total rendering time for areas that are slow to render.  Texture, gradient     and alpha blended backgrounds, for example, can be notibly slow to render;     especially with a transformed view. The CacheBackground flag enables     caching of the view's background. For example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 2      The cache is invalidated every time the view is transformed. However, when     scrolling, only partial invalidation is required.      By default, nothing is cached.      \sa resetCachedContent(), QPixmapCache */
end_comment
begin_function
DECL|function|cacheMode
name|QGraphicsView
operator|::
name|CacheMode
name|QGraphicsView
operator|::
name|cacheMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cacheMode
return|;
block|}
end_function
begin_function
DECL|function|setCacheMode
name|void
name|QGraphicsView
operator|::
name|setCacheMode
parameter_list|(
name|CacheMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|d
operator|->
name|cacheMode
condition|)
return|return;
name|d
operator|->
name|cacheMode
operator|=
name|mode
expr_stmt|;
name|resetCachedContent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets any cached content. Calling this function will clear     QGraphicsView's cache. If the current cache mode is \l CacheNone, this     function does nothing.      This function is called automatically for you when the backgroundBrush or     QGraphicsScene::backgroundBrush properties change; you only need to call     this function if you have reimplemented QGraphicsScene::drawBackground()     or QGraphicsView::drawBackground() to draw a custom background, and need     to trigger a full redraw.      \sa cacheMode() */
end_comment
begin_function
DECL|function|resetCachedContent
name|void
name|QGraphicsView
operator|::
name|resetCachedContent
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cacheMode
operator|==
name|CacheNone
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|cacheMode
operator|&
name|CacheBackground
condition|)
block|{
comment|// Background caching is enabled.
name|d
operator|->
name|mustResizeBackgroundPixmap
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|mustResizeBackgroundPixmap
condition|)
block|{
comment|// Background caching is disabled.
comment|// Cleanup, free some resources.
name|d
operator|->
name|mustResizeBackgroundPixmap
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|backgroundPixmap
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
name|d
operator|->
name|backgroundPixmapExposed
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Invalidates and schedules a redraw of \a layers inside \a rect. \a rect is     in scene coordinates. Any cached content for \a layers inside \a rect is     unconditionally invalidated and redrawn.      You can call this function to notify QGraphicsView of changes to the     background or the foreground of the scene. It is commonly used for scenes     with tile-based backgrounds to notify changes when QGraphicsView has     enabled background caching.      Note that QGraphicsView currently supports background caching only (see     QGraphicsView::CacheBackground). This function is equivalent to calling update() if any     layer but QGraphicsScene::BackgroundLayer is passed.      \sa QGraphicsScene::invalidate(), update() */
end_comment
begin_function
DECL|function|invalidateScene
name|void
name|QGraphicsView
operator|::
name|invalidateScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|QGraphicsScene
operator|::
name|SceneLayers
name|layers
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|layers
operator|&
name|QGraphicsScene
operator|::
name|BackgroundLayer
operator|)
operator|&&
operator|!
name|d
operator|->
name|mustResizeBackgroundPixmap
condition|)
block|{
name|QRect
name|viewRect
init|=
name|mapFromScene
argument_list|(
name|rect
argument_list|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|intersects
argument_list|(
name|viewRect
argument_list|)
condition|)
block|{
comment|// The updated background area is exposed; schedule this area for
comment|// redrawing.
name|d
operator|->
name|backgroundPixmapExposed
operator|+=
name|viewRect
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|d
operator|->
name|scene
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::interactive     \brief whether the view allowed scene interaction.      If enabled, this view is set to allow scene interaction. Otherwise, this     view will not allow interaction, and any mouse or key events are ignored     (i.e., it will act as a read-only view).      By default, this property is true. */
end_comment
begin_function
DECL|function|isInteractive
name|bool
name|QGraphicsView
operator|::
name|isInteractive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sceneInteractionAllowed
return|;
block|}
end_function
begin_function
DECL|function|setInteractive
name|void
name|QGraphicsView
operator|::
name|setInteractive
parameter_list|(
name|bool
name|allowed
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|sceneInteractionAllowed
operator|=
name|allowed
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the scene that is currently visualized in the     view. If no scene is currently visualized, 0 is returned.      \sa setScene() */
end_comment
begin_function
DECL|function|scene
name|QGraphicsScene
modifier|*
name|QGraphicsView
operator|::
name|scene
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|scene
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current scene to \a scene. If \a scene is already being     viewed, this function does nothing.      When a scene is set on a view, the QGraphicsScene::changed() signal     is automatically connected to this view's updateScene() slot, and the     view's scroll bars are adjusted to fit the size of the scene.      The view does not take ownership of \a scene. */
end_comment
begin_function
DECL|function|setScene
name|void
name|QGraphicsView
operator|::
name|setScene
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|==
name|scene
condition|)
return|return;
comment|// Always update the viewport when the scene changes.
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
comment|// Remove the previously assigned scene.
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
name|disconnect
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|SIGNAL
argument_list|(
name|changed
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateScene
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|disconnect
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|SIGNAL
argument_list|(
name|sceneRectChanged
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateSceneRect
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removeView
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|connectedToScene
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|isActiveWindow
argument_list|()
operator|&&
name|isVisible
argument_list|()
condition|)
block|{
name|QEvent
name|windowDeactivate
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|windowDeactivate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
name|d
operator|->
name|scene
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
block|}
comment|// Assign the new scene and update the contents (scrollbars, etc.)).
if|if
condition|(
operator|(
name|d
operator|->
name|scene
operator|=
name|scene
operator|)
condition|)
block|{
name|connect
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|SIGNAL
argument_list|(
name|sceneRectChanged
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateSceneRect
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateSceneSlotReimplementedChecked
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|addView
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastCenterPoint
operator|=
name|sceneRect
argument_list|()
operator|.
name|center
argument_list|()
expr_stmt|;
name|d
operator|->
name|keepLastCenterPoint
operator|=
literal|true
expr_stmt|;
comment|// We are only interested in mouse tracking if items accept
comment|// hover events or use non-default cursors.
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|||
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsUseDefaultCursor
condition|)
block|{
name|d
operator|->
name|viewport
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// enable touch events if any items is interested in them
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreTouchEvents
condition|)
name|d
operator|->
name|viewport
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
expr_stmt|;
if|if
condition|(
name|isActiveWindow
argument_list|()
operator|&&
name|isVisible
argument_list|()
condition|)
block|{
name|QEvent
name|windowActivate
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|windowActivate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|updateInputMethodSensitivity
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|hasFocus
argument_list|()
condition|)
name|d
operator|->
name|scene
operator|->
name|setFocus
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::sceneRect     \brief the area of the scene visualized by this view.      The scene rectangle defines the extent of the scene, and in the view's case,     this means the area of the scene that you can navigate using the scroll     bars.      If unset, or if a null QRectF is set, this property has the same value as     QGraphicsScene::sceneRect, and it changes with     QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected     by the scene.      Note that, although the scene supports a virtually unlimited size, the     range of the scroll bars will never exceed the range of an integer     (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values,     you can choose to use translate() to navigate the scene instead.      By default, this property contains a rectangle at the origin with zero     width and height.      \sa QGraphicsScene::sceneRect */
end_comment
begin_function
DECL|function|sceneRect
name|QRectF
name|QGraphicsView
operator|::
name|sceneRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSceneRect
condition|)
return|return
name|d
operator|->
name|sceneRect
return|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
return|return
name|d
operator|->
name|scene
operator|->
name|sceneRect
argument_list|()
return|;
return|return
name|QRectF
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setSceneRect
name|void
name|QGraphicsView
operator|::
name|setSceneRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSceneRect
operator|=
operator|!
name|rect
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|d
operator|->
name|sceneRect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current transformation matrix for the view. If no current     transformation is set, the identity matrix is returned.      \sa setMatrix(), transform(), rotate(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|matrix
name|QMatrix
name|QGraphicsView
operator|::
name|matrix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|matrix
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the view's current transformation matrix to \a matrix.      If \a combine is true, then \a matrix is combined with the current matrix;     otherwise, \a matrix \e replaces the current matrix. \a combine is false     by default.      The transformation matrix tranforms the scene into view coordinates. Using     the default transformation, provided by the identity matrix, one pixel in     the view represents one unit in the scene (e.g., a 10x10 rectangular item     is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is     applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is     then drawn using 20x20 pixels in the view).      Example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 3      To simplify interation with items using a transformed view, QGraphicsView     provides mapTo... and mapFrom... functions that can translate between     scene and view coordinates. For example, you can call mapToScene() to map     a view coordinate to a floating point scene coordinate, or mapFromScene()     to map from floating point scene coordinates to view coordinates.      \sa matrix(), setTransform(), rotate(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QGraphicsView
operator|::
name|setMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|combine
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets the view transformation matrix to the identity matrix.      \sa resetTransform() */
end_comment
begin_function
DECL|function|resetMatrix
name|void
name|QGraphicsView
operator|::
name|resetMatrix
parameter_list|()
block|{
name|resetTransform
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Rotates the current view transformation \a angle degrees clockwise.      \sa setTransform(), transform(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|rotate
name|void
name|QGraphicsView
operator|::
name|rotate
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|.
name|rotate
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Scales the current view transformation by (\a sx, \a sy).      \sa setTransform(), transform(), rotate(), shear(), translate() */
end_comment
begin_function
DECL|function|scale
name|void
name|QGraphicsView
operator|::
name|scale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|.
name|scale
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Shears the current view transformation by (\a sh, \a sv).      \sa setTransform(), transform(), rotate(), scale(), translate() */
end_comment
begin_function
DECL|function|shear
name|void
name|QGraphicsView
operator|::
name|shear
parameter_list|(
name|qreal
name|sh
parameter_list|,
name|qreal
name|sv
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|.
name|shear
argument_list|(
name|sh
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Translates the current view transformation by (\a dx, \a dy).      \sa setTransform(), transform(), rotate(), shear() */
end_comment
begin_function
DECL|function|translate
name|void
name|QGraphicsView
operator|::
name|translate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Scrolls the contents of the viewport to ensure that the scene     coordinate \a pos, is centered in the view.      Because \a pos is a floating point coordinate, and the scroll bars operate     on integer coordinates, the centering is only an approximation.      \note If the item is close to or outside the border, it will be visible     in the view, but not centered.      \sa ensureVisible() */
end_comment
begin_function
DECL|function|centerOn
name|void
name|QGraphicsView
operator|::
name|centerOn
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|qreal
name|width
init|=
name|viewport
argument_list|()
operator|->
name|width
argument_list|()
decl_stmt|;
name|qreal
name|height
init|=
name|viewport
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
name|QPointF
name|viewPoint
init|=
name|d
operator|->
name|matrix
operator|.
name|map
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|QPointF
name|oldCenterPoint
init|=
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|leftIndent
condition|)
block|{
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
block|{
name|qint64
name|horizontal
init|=
literal|0
decl_stmt|;
name|horizontal
operator|+=
name|horizontalScrollBar
argument_list|()
operator|->
name|minimum
argument_list|()
expr_stmt|;
name|horizontal
operator|+=
name|horizontalScrollBar
argument_list|()
operator|->
name|maximum
argument_list|()
expr_stmt|;
name|horizontal
operator|-=
name|int
argument_list|(
name|viewPoint
operator|.
name|x
argument_list|()
operator|-
name|width
operator|/
literal|2.0
argument_list|)
expr_stmt|;
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|horizontal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewPoint
operator|.
name|x
argument_list|()
operator|-
name|width
operator|/
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|topIndent
condition|)
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewPoint
operator|.
name|y
argument_list|()
operator|-
name|height
operator|/
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastCenterPoint
operator|=
name|oldCenterPoint
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::centerOn(qreal x, qreal y)     \overload      This function is provided for convenience. It's equivalent to calling     centerOn(QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     \overload      Scrolls the contents of the viewport to ensure that \a item     is centered in the view.      \sa ensureVisible() */
end_comment
begin_function
DECL|function|centerOn
name|void
name|QGraphicsView
operator|::
name|centerOn
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|centerOn
argument_list|(
name|item
operator|->
name|sceneBoundingRect
argument_list|()
operator|.
name|center
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Scrolls the contents of the viewport so that the scene rectangle \a rect     is visible, with margins specified in pixels by \a xmargin and \a     ymargin. If the specified rect cannot be reached, the contents are     scrolled to the nearest valid position. The default value for both margins     is 50 pixels.      \sa centerOn() */
end_comment
begin_function
DECL|function|ensureVisible
name|void
name|QGraphicsView
operator|::
name|ensureVisible
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|int
name|xmargin
parameter_list|,
name|int
name|ymargin
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|qreal
name|width
init|=
name|viewport
argument_list|()
operator|->
name|width
argument_list|()
decl_stmt|;
name|qreal
name|height
init|=
name|viewport
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
name|QRectF
name|viewRect
init|=
name|d
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|qreal
name|left
init|=
name|d
operator|->
name|horizontalScroll
argument_list|()
decl_stmt|;
name|qreal
name|right
init|=
name|left
operator|+
name|width
decl_stmt|;
name|qreal
name|top
init|=
name|d
operator|->
name|verticalScroll
argument_list|()
decl_stmt|;
name|qreal
name|bottom
init|=
name|top
operator|+
name|height
decl_stmt|;
if|if
condition|(
name|viewRect
operator|.
name|left
argument_list|()
operator|<=
name|left
operator|+
name|xmargin
condition|)
block|{
comment|// need to scroll from the left
if|if
condition|(
operator|!
name|d
operator|->
name|leftIndent
condition|)
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewRect
operator|.
name|left
argument_list|()
operator|-
name|xmargin
operator|-
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|viewRect
operator|.
name|right
argument_list|()
operator|>=
name|right
operator|-
name|xmargin
condition|)
block|{
comment|// need to scroll from the right
if|if
condition|(
operator|!
name|d
operator|->
name|leftIndent
condition|)
name|horizontalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewRect
operator|.
name|right
argument_list|()
operator|-
name|width
operator|+
name|xmargin
operator|+
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|viewRect
operator|.
name|top
argument_list|()
operator|<=
name|top
operator|+
name|ymargin
condition|)
block|{
comment|// need to scroll from the top
if|if
condition|(
operator|!
name|d
operator|->
name|topIndent
condition|)
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewRect
operator|.
name|top
argument_list|()
operator|-
name|ymargin
operator|-
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|viewRect
operator|.
name|bottom
argument_list|()
operator|>=
name|bottom
operator|-
name|ymargin
condition|)
block|{
comment|// need to scroll from the bottom
if|if
condition|(
operator|!
name|d
operator|->
name|topIndent
condition|)
name|verticalScrollBar
argument_list|()
operator|->
name|setValue
argument_list|(
name|int
argument_list|(
name|viewRect
operator|.
name|bottom
argument_list|()
operator|-
name|height
operator|+
name|ymargin
operator|+
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::ensureVisible(qreal x, qreal y, qreal w, qreal h,     int xmargin, int ymargin)     \overload      This function is provided for convenience. It's equivalent to calling     ensureVisible(QRectF(\a x, \a y, \a w, \a h), \a xmargin, \a ymargin). */
end_comment
begin_comment
comment|/*!     \overload      Scrolls the contents of the viewport so that the center of item \a item is     visible, with margins specified in pixels by \a xmargin and \a ymargin. If     the specified point cannot be reached, the contents are scrolled to the     nearest valid position. The default value for both margins is 50 pixels.      \sa centerOn() */
end_comment
begin_function
DECL|function|ensureVisible
name|void
name|QGraphicsView
operator|::
name|ensureVisible
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|int
name|xmargin
parameter_list|,
name|int
name|ymargin
parameter_list|)
block|{
name|ensureVisible
argument_list|(
name|item
operator|->
name|sceneBoundingRect
argument_list|()
argument_list|,
name|xmargin
argument_list|,
name|ymargin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Scales the view matrix and scrolls the scroll bars to ensure that the     scene rectangle \a rect fits inside the viewport. \a rect must be inside     the scene rect; otherwise, fitInView() cannot guarantee that the whole     rect is visible.      This function keeps the view's rotation, translation, or shear. The view     is scaled according to \a aspectRatioMode. \a rect will be centered in the     view if it does not fit tightly.      It's common to call fitInView() from inside a reimplementation of     resizeEvent(), to ensure that the whole scene, or parts of the scene,     scales automatically to fit the new size of the viewport as the view is     resized. Note though, that calling fitInView() from inside resizeEvent()     can lead to unwanted resize recursion, if the new transformation toggles     the automatic state of the scrollbars. You can toggle the scrollbar     policies to always on or always off to prevent this (see     horizontalScrollBarPolicy() and verticalScrollBarPolicy()).      If \a rect is empty, or if the viewport is too small, this     function will do nothing.      \sa setTransform(), ensureVisible(), centerOn() */
end_comment
begin_function
DECL|function|fitInView
name|void
name|QGraphicsView
operator|::
name|fitInView
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectRatioMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
comment|// Reset the view scale to 1:1.
name|QRectF
name|unity
init|=
name|d
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unity
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|scale
argument_list|(
literal|1
operator|/
name|unity
operator|.
name|width
argument_list|()
argument_list|,
literal|1
operator|/
name|unity
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
comment|// Find the ideal x / y scaling ratio to fit \a rect in the view.
name|int
name|margin
init|=
literal|2
decl_stmt|;
name|QRectF
name|viewRect
init|=
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|adjusted
argument_list|(
name|margin
argument_list|,
name|margin
argument_list|,
operator|-
name|margin
argument_list|,
operator|-
name|margin
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QRectF
name|sceneRect
init|=
name|d
operator|->
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
name|sceneRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|qreal
name|xratio
init|=
name|viewRect
operator|.
name|width
argument_list|()
operator|/
name|sceneRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|yratio
init|=
name|viewRect
operator|.
name|height
argument_list|()
operator|/
name|sceneRect
operator|.
name|height
argument_list|()
decl_stmt|;
comment|// Respect the aspect ratio mode.
switch|switch
condition|(
name|aspectRatioMode
condition|)
block|{
case|case
name|Qt
operator|::
name|KeepAspectRatio
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMin
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|KeepAspectRatioByExpanding
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMax
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|IgnoreAspectRatio
case|:
break|break;
block|}
comment|// Scale and center on the center of \a rect.
name|scale
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
name|centerOn
argument_list|(
name|rect
operator|.
name|center
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsView::fitInView(qreal x, qreal y, qreal w, qreal h,     Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio)      \overload      This convenience function is equivalent to calling     fitInView(QRectF(\a x, \a y, \a w, \a h), \a aspectRatioMode).      \sa ensureVisible(), centerOn() */
end_comment
begin_comment
comment|/*!     \overload      Ensures that \a item fits tightly inside the view, scaling the view     according to \a aspectRatioMode.      \sa ensureVisible(), centerOn() */
end_comment
begin_function
DECL|function|fitInView
name|void
name|QGraphicsView
operator|::
name|fitInView
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectRatioMode
parameter_list|)
block|{
name|QPainterPath
name|path
init|=
name|item
operator|->
name|isClipped
argument_list|()
condition|?
name|item
operator|->
name|clipPath
argument_list|()
else|:
name|item
operator|->
name|shape
argument_list|()
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
block|{
name|path
operator|.
name|translate
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
name|fitInView
argument_list|(
name|path
operator|.
name|boundingRect
argument_list|()
argument_list|,
name|aspectRatioMode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fitInView
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|path
argument_list|)
operator|.
name|boundingRect
argument_list|()
argument_list|,
name|aspectRatioMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Renders the \a source rect, which is in view coordinates, from the scene     into \a target, which is in paint device coordinates, using \a     painter. This function is useful for capturing the contents of the view     onto a paint device, such as a QImage (e.g., to take a screenshot), or for     printing to QPrinter. For example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 4      If \a source is a null rect, this function will use viewport()->rect() to     determine what to draw. If \a target is a null rect, the full dimensions     of \a painter's paint device (e.g., for a QPrinter, the page size) will be     used.      The source rect contents will be transformed according to \a     aspectRatioMode to fit into the target rect. By default, the aspect ratio     is kept, and \a source is scaled to fit in \a target.      \sa QGraphicsScene::render() */
end_comment
begin_function
DECL|function|render
name|void
name|QGraphicsView
operator|::
name|render
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
specifier|const
name|QRect
modifier|&
name|source
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectRatioMode
parameter_list|)
block|{
comment|// ### Switch to using the recursive rendering algorithm instead.
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
operator|(
name|painter
operator|&&
name|painter
operator|->
name|isActive
argument_list|()
operator|)
condition|)
return|return;
comment|// Default source rect = viewport rect
name|QRect
name|sourceRect
init|=
name|source
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|isNull
argument_list|()
condition|)
name|sourceRect
operator|=
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
expr_stmt|;
comment|// Default target rect = device rect
name|QRectF
name|targetRect
init|=
name|target
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|painter
operator|->
name|device
argument_list|()
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Picture
condition|)
name|targetRect
operator|=
name|sourceRect
expr_stmt|;
else|else
name|targetRect
operator|.
name|setRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Find the ideal x / y scaling ratio to fit \a source into \a target.
name|qreal
name|xratio
init|=
name|targetRect
operator|.
name|width
argument_list|()
operator|/
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|yratio
init|=
name|targetRect
operator|.
name|height
argument_list|()
operator|/
name|sourceRect
operator|.
name|height
argument_list|()
decl_stmt|;
comment|// Scale according to the aspect ratio mode.
switch|switch
condition|(
name|aspectRatioMode
condition|)
block|{
case|case
name|Qt
operator|::
name|KeepAspectRatio
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMin
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|KeepAspectRatioByExpanding
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMax
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|IgnoreAspectRatio
case|:
break|break;
block|}
comment|// Find all items to draw, and reverse the list (we want to draw
comment|// in reverse order).
name|QPolygonF
name|sourceScenePoly
init|=
name|mapToScene
argument_list|(
name|sourceRect
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
init|=
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|sourceScenePoly
argument_list|,
name|Qt
operator|::
name|IntersectsItemBoundingRect
argument_list|)
decl_stmt|;
name|QGraphicsItem
modifier|*
modifier|*
name|itemArray
init|=
operator|new
name|QGraphicsItem
operator|*
index|[
name|itemList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|numItems
init|=
name|itemList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|itemArray
index|[
name|numItems
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|itemList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|itemList
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Setup painter matrix.
name|QTransform
name|moveMatrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
name|QTransform
name|painterMatrix
init|=
name|d
operator|->
name|matrix
operator|*
name|moveMatrix
decl_stmt|;
name|painterMatrix
operator|*=
name|QTransform
argument_list|()
operator|.
name|translate
argument_list|(
name|targetRect
operator|.
name|left
argument_list|()
argument_list|,
name|targetRect
operator|.
name|top
argument_list|()
argument_list|)
operator|.
name|scale
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
operator|.
name|translate
argument_list|(
operator|-
name|sourceRect
operator|.
name|left
argument_list|()
argument_list|,
operator|-
name|sourceRect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
comment|// Generate the style options
name|QStyleOptionGraphicsItem
modifier|*
name|styleOptionArray
init|=
name|d
operator|->
name|allocStyleOptionsArray
argument_list|(
name|numItems
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|itemArray
index|[
name|i
index|]
operator|->
name|d_ptr
operator|->
name|initStyleOption
argument_list|(
operator|&
name|styleOptionArray
index|[
name|i
index|]
argument_list|,
name|painterMatrix
argument_list|,
name|targetRect
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
comment|// Clip in device coordinates to avoid QRegion transformations.
name|painter
operator|->
name|setClipRect
argument_list|(
name|targetRect
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addPolygon
argument_list|(
name|sourceScenePoly
argument_list|)
expr_stmt|;
name|path
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setClipPath
argument_list|(
name|painterMatrix
operator|.
name|map
argument_list|(
name|path
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
comment|// Transform the painter.
name|painter
operator|->
name|setTransform
argument_list|(
name|painterMatrix
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Render the scene.
name|QRectF
name|sourceSceneRect
init|=
name|sourceScenePoly
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|drawBackground
argument_list|(
name|painter
argument_list|,
name|sourceSceneRect
argument_list|)
expr_stmt|;
name|drawItems
argument_list|(
name|painter
argument_list|,
name|numItems
argument_list|,
name|itemArray
argument_list|,
name|styleOptionArray
argument_list|)
expr_stmt|;
name|drawForeground
argument_list|(
name|painter
argument_list|,
name|sourceSceneRect
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|itemArray
expr_stmt|;
name|d
operator|->
name|freeStyleOptionsArray
argument_list|(
name|styleOptionArray
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the items in the associated scene, in descending     stacking order (i.e., the first item in the returned list is the uppermost     item).      \sa QGraphicsScene::items(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsView
operator|::
name|items
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all the items at the position \a pos in the view. The     items are listed in descending stacking order (i.e., the first item in the     list is the uppermost item, and the last item is the lowermost item). \a     pos is in viewport coordinates.      This function is most commonly called from within mouse event handlers in     a subclass in QGraphicsView. \a pos is in untransformed viewport     coordinates, just like QMouseEvent::pos().      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 5      \sa QGraphicsScene::items(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsView
operator|::
name|items
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
comment|// ### Unify these two, and use the items(QPointF) version in
comment|// QGraphicsScene instead. The scene items function could use the viewport
comment|// transform to map the point to a rect/polygon.
if|if
condition|(
operator|(
name|d
operator|->
name|identityMatrix
operator|||
name|d
operator|->
name|matrix
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
operator|)
condition|)
block|{
comment|// Use the rect version
name|QTransform
name|xinv
init|=
name|viewportTransform
argument_list|()
operator|.
name|inverted
argument_list|()
decl_stmt|;
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|xinv
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
return|;
block|}
comment|// Use the polygon version
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|mapToScene
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::items(int x, int y) const      This function is provided for convenience. It's equivalent to calling     items(QPoint(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     \overload      Returns a list of all the items that, depending on \a mode, are either     contained by or intersect with \a rect. \a rect is in viewport     coordinates.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a rect are returned.      The items are sorted in descending stacking order (i.e., the first item in     the returned list is the uppermost item).      \sa itemAt(), items(), mapToScene(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsView
operator|::
name|items
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|mapToScene
argument_list|(
name|rect
argument_list|)
argument_list|,
name|mode
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsView::items(int x, int y, int w, int h, Qt::ItemSelectionMode mode) const     \since 4.3      This convenience function is equivalent to calling items(QRectF(\a x, \a     y, \a w, \a h), \a mode). */
end_comment
begin_comment
comment|/*!     \overload      Returns a list of all the items that, depending on \a mode, are either     contained by or intersect with \a polygon. \a polygon is in viewport     coordinates.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a polygon are returned.      The items are sorted by descending stacking order (i.e., the first item in     the returned list is the uppermost item).      \sa itemAt(), items(), mapToScene(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsView
operator|::
name|items
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|polygon
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|mapToScene
argument_list|(
name|polygon
argument_list|)
argument_list|,
name|mode
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a list of all the items that, depending on \a mode, are either     contained by or intersect with \a path. \a path is in viewport     coordinates.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a path are returned.      \sa itemAt(), items(), mapToScene(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsView
operator|::
name|items
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|mapToScene
argument_list|(
name|path
argument_list|)
argument_list|,
name|mode
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item at position \a pos, which is in viewport coordinates.     If there are several items at this position, this function returns     the topmost item.      Example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 6      \sa items(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|itemAt
name|QGraphicsItem
modifier|*
name|QGraphicsView
operator|::
name|itemAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
literal|0
return|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemsAtPos
init|=
name|items
argument_list|(
name|pos
argument_list|)
decl_stmt|;
return|return
name|itemsAtPos
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|itemsAtPos
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \fn QGraphicsItem *QGraphicsView::itemAt(int x, int y) const      This function is provided for convenience. It's equivalent to     calling itemAt(QPoint(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Returns the viewport coordinate \a point mapped to scene coordinates.      Note: It can be useful to map the whole rectangle covered by the pixel at     \a point instead of the point itself. To do this, you can call     mapToScene(QRect(\a point, QSize(2, 2))).      \sa mapFromScene() */
end_comment
begin_function
DECL|function|mapToScene
name|QPointF
name|QGraphicsView
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QPointF
name|p
init|=
name|point
decl_stmt|;
name|p
operator|.
name|rx
argument_list|()
operator|+=
name|d
operator|->
name|horizontalScroll
argument_list|()
expr_stmt|;
name|p
operator|.
name|ry
argument_list|()
operator|+=
name|d
operator|->
name|verticalScroll
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|identityMatrix
condition|?
name|p
else|:
name|d
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::mapToScene(int x, int y) const      This function is provided for convenience. It's equivalent to calling     mapToScene(QPoint(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Returns the viewport rectangle \a rect mapped to a scene coordinate     polygon.      \sa mapFromScene() */
end_comment
begin_function
DECL|function|mapToScene
name|QPolygonF
name|QGraphicsView
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QPolygonF
argument_list|()
return|;
name|QPointF
name|scrollOffset
argument_list|(
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
name|QRect
name|r
init|=
name|rect
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|QPointF
name|tl
init|=
name|scrollOffset
operator|+
name|r
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QPointF
name|tr
init|=
name|scrollOffset
operator|+
name|r
operator|.
name|topRight
argument_list|()
decl_stmt|;
name|QPointF
name|br
init|=
name|scrollOffset
operator|+
name|r
operator|.
name|bottomRight
argument_list|()
decl_stmt|;
name|QPointF
name|bl
init|=
name|scrollOffset
operator|+
name|r
operator|.
name|bottomLeft
argument_list|()
decl_stmt|;
name|QPolygonF
name|poly
argument_list|(
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|identityMatrix
condition|)
block|{
name|QTransform
name|x
init|=
name|d
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|poly
index|[
literal|0
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|poly
index|[
literal|1
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|poly
index|[
literal|2
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|poly
index|[
literal|3
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|poly
index|[
literal|0
index|]
operator|=
name|tl
expr_stmt|;
name|poly
index|[
literal|1
index|]
operator|=
name|tr
expr_stmt|;
name|poly
index|[
literal|2
index|]
operator|=
name|br
expr_stmt|;
name|poly
index|[
literal|3
index|]
operator|=
name|bl
expr_stmt|;
block|}
return|return
name|poly
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::mapToScene(int x, int y, int w, int h) const      This function is provided for convenience. It's equivalent to calling     mapToScene(QRect(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Returns the viewport polygon \a polygon mapped to a scene coordinate     polygon.      \sa mapFromScene() */
end_comment
begin_function
DECL|function|mapToScene
name|QPolygonF
name|QGraphicsView
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPolygon
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
name|QPolygonF
name|poly
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QPoint
modifier|&
name|point
decl|,
name|polygon
control|)
name|poly
operator|<<
name|mapToScene
argument_list|(
name|point
argument_list|)
expr_stmt|;
return|return
name|poly
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the viewport painter path \a path mapped to a scene coordinate     painter path.      \sa mapFromScene() */
end_comment
begin_function
DECL|function|mapToScene
name|QPainterPath
name|QGraphicsView
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
name|matrix
operator|*=
name|d
operator|->
name|matrix
operator|.
name|inverted
argument_list|()
expr_stmt|;
return|return
name|matrix
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the scene coordinate \a point to viewport coordinates.      \sa mapToScene() */
end_comment
begin_function
DECL|function|mapFromScene
name|QPoint
name|QGraphicsView
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QPointF
name|p
init|=
name|d
operator|->
name|identityMatrix
condition|?
name|point
else|:
name|d
operator|->
name|matrix
operator|.
name|map
argument_list|(
name|point
argument_list|)
decl_stmt|;
name|p
operator|.
name|rx
argument_list|()
operator|-=
name|d
operator|->
name|horizontalScroll
argument_list|()
expr_stmt|;
name|p
operator|.
name|ry
argument_list|()
operator|-=
name|d
operator|->
name|verticalScroll
argument_list|()
expr_stmt|;
return|return
name|p
operator|.
name|toPoint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::mapFromScene(qreal x, qreal y) const      This function is provided for convenience. It's equivalent to     calling mapFromScene(QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Returns the scene rectangle \a rect to a viewport coordinate     polygon.      \sa mapToScene() */
end_comment
begin_function
DECL|function|mapFromScene
name|QPolygon
name|QGraphicsView
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QPointF
name|tl
decl_stmt|;
name|QPointF
name|tr
decl_stmt|;
name|QPointF
name|br
decl_stmt|;
name|QPointF
name|bl
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|identityMatrix
condition|)
block|{
specifier|const
name|QTransform
modifier|&
name|x
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|tl
operator|=
name|x
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|tr
operator|=
name|x
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
expr_stmt|;
name|br
operator|=
name|x
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
expr_stmt|;
name|bl
operator|=
name|x
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tl
operator|=
name|rect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|tr
operator|=
name|rect
operator|.
name|topRight
argument_list|()
expr_stmt|;
name|br
operator|=
name|rect
operator|.
name|bottomRight
argument_list|()
expr_stmt|;
name|bl
operator|=
name|rect
operator|.
name|bottomLeft
argument_list|()
expr_stmt|;
block|}
name|QPointF
name|scrollOffset
argument_list|(
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
name|tl
operator|-=
name|scrollOffset
expr_stmt|;
name|tr
operator|-=
name|scrollOffset
expr_stmt|;
name|br
operator|-=
name|scrollOffset
expr_stmt|;
name|bl
operator|-=
name|scrollOffset
expr_stmt|;
name|QPolygon
name|poly
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|poly
index|[
literal|0
index|]
operator|=
name|tl
operator|.
name|toPoint
argument_list|()
expr_stmt|;
name|poly
index|[
literal|1
index|]
operator|=
name|tr
operator|.
name|toPoint
argument_list|()
expr_stmt|;
name|poly
index|[
literal|2
index|]
operator|=
name|br
operator|.
name|toPoint
argument_list|()
expr_stmt|;
name|poly
index|[
literal|3
index|]
operator|=
name|bl
operator|.
name|toPoint
argument_list|()
expr_stmt|;
return|return
name|poly
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsView::mapFromScene(qreal x, qreal y, qreal w, qreal h) const      This function is provided for convenience. It's equivalent to     calling mapFromScene(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Returns the scene coordinate polygon \a polygon to a viewport coordinate     polygon.      \sa mapToScene() */
end_comment
begin_function
DECL|function|mapFromScene
name|QPolygon
name|QGraphicsView
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
name|QPolygon
name|poly
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QPointF
modifier|&
name|point
decl|,
name|polygon
control|)
name|poly
operator|<<
name|mapFromScene
argument_list|(
name|point
argument_list|)
expr_stmt|;
return|return
name|poly
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the scene coordinate painter path \a path to a viewport coordinate     painter path.      \sa mapToScene() */
end_comment
begin_function
DECL|function|mapFromScene
name|QPainterPath
name|QGraphicsView
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|matrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
name|matrix
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|matrix
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QGraphicsView
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QVariant
argument_list|()
return|;
name|QVariant
name|value
init|=
name|d
operator|->
name|scene
operator|->
name|inputMethodQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|RectF
condition|)
name|value
operator|=
name|d
operator|->
name|mapRectFromScene
argument_list|(
name|value
operator|.
name|toRectF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|PointF
condition|)
name|value
operator|=
name|mapFromScene
argument_list|(
name|value
operator|.
name|toPointF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Rect
condition|)
name|value
operator|=
name|d
operator|->
name|mapRectFromScene
argument_list|(
name|value
operator|.
name|toRect
argument_list|()
argument_list|)
operator|.
name|toRect
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Point
condition|)
name|value
operator|=
name|mapFromScene
argument_list|(
name|value
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::backgroundBrush     \brief the background brush of the scene.      This property sets the background brush for the scene in this view. It is     used to override the scene's own background, and defines the behavior of     drawBackground(). To provide custom background drawing for this view, you     can reimplement drawBackground() instead.      By default, this property contains a brush with the Qt::NoBrush pattern.      \sa QGraphicsScene::backgroundBrush, foregroundBrush */
end_comment
begin_function
DECL|function|backgroundBrush
name|QBrush
name|QGraphicsView
operator|::
name|backgroundBrush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|backgroundBrush
return|;
block|}
end_function
begin_function
DECL|function|setBackgroundBrush
name|void
name|QGraphicsView
operator|::
name|setBackgroundBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|backgroundBrush
operator|=
name|brush
expr_stmt|;
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cacheMode
operator|&
name|CacheBackground
condition|)
block|{
comment|// Invalidate the background pixmap
name|d
operator|->
name|mustResizeBackgroundPixmap
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsView::foregroundBrush     \brief the foreground brush of the scene.      This property sets the foreground brush for the scene in this view. It is     used to override the scene's own foreground, and defines the behavior of     drawForeground(). To provide custom foreground drawing for this view, you     can reimplement drawForeground() instead.      By default, this property contains a brush with the Qt::NoBrush pattern.      \sa QGraphicsScene::foregroundBrush, backgroundBrush */
end_comment
begin_function
DECL|function|foregroundBrush
name|QBrush
name|QGraphicsView
operator|::
name|foregroundBrush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|foregroundBrush
return|;
block|}
end_function
begin_function
DECL|function|setForegroundBrush
name|void
name|QGraphicsView
operator|::
name|setForegroundBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|foregroundBrush
operator|=
name|brush
expr_stmt|;
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Schedules an update of the scene rectangles \a rects.      \sa QGraphicsScene::changed() */
end_comment
begin_function
DECL|function|updateScene
name|void
name|QGraphicsView
operator|::
name|updateScene
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QRectF
argument_list|>
modifier|&
name|rects
parameter_list|)
block|{
comment|// ### Note: Since 4.5, this slot is only called if the user explicitly
comment|// establishes a connection between the scene and the view, as the scene
comment|// and view are no longer connected. We need to keep it working (basically
comment|// leave it as it is), but the new delivery path is through
comment|// QGraphicsScenePrivate::itemUpdate().
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fullUpdatePending
operator|||
name|d
operator|->
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|NoViewportUpdate
condition|)
return|return;
comment|// Extract and reset dirty scene rect info.
name|QVector
argument_list|<
name|QRect
argument_list|>
name|dirtyViewportRects
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
modifier|&
name|dirtyRects
init|=
name|d
operator|->
name|dirtyRegion
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirtyRects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|dirtyViewportRects
operator|+=
name|dirtyRects
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirtyRegion
operator|=
name|QRegion
argument_list|()
expr_stmt|;
name|d
operator|->
name|dirtyBoundingRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|bool
name|fullUpdate
init|=
operator|!
name|d
operator|->
name|accelerateScrolling
operator|||
name|d
operator|->
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|FullViewportUpdate
decl_stmt|;
name|bool
name|boundingRectUpdate
init|=
operator|(
name|d
operator|->
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|BoundingRectViewportUpdate
operator|)
operator|||
operator|(
name|d
operator|->
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|SmartViewportUpdate
operator|&&
operator|(
operator|(
name|dirtyViewportRects
operator|.
name|size
argument_list|()
operator|+
name|rects
operator|.
name|size
argument_list|()
operator|)
operator|>=
name|QGRAPHICSVIEW_REGION_RECT_THRESHOLD
operator|)
operator|)
decl_stmt|;
name|QRegion
name|updateRegion
decl_stmt|;
name|QRect
name|boundingRect
decl_stmt|;
name|QRect
name|viewportRect
init|=
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
decl_stmt|;
name|bool
name|redraw
init|=
literal|false
decl_stmt|;
name|QTransform
name|transform
init|=
name|viewportTransform
argument_list|()
decl_stmt|;
comment|// Convert scene rects to viewport rects.
foreach|foreach
control|(
specifier|const
name|QRectF
modifier|&
name|rect
decl|,
name|rects
control|)
block|{
name|QRect
name|xrect
init|=
name|transform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|optimizationFlags
operator|&
name|DontAdjustForAntialiasing
operator|)
condition|)
name|xrect
operator|.
name|adjust
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|xrect
operator|.
name|adjust
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|viewportRect
operator|.
name|intersects
argument_list|(
name|xrect
argument_list|)
condition|)
continue|continue;
name|dirtyViewportRects
operator|<<
name|xrect
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|dirtyViewportRects
control|)
block|{
comment|// Add the exposed rect to the update region. In rect update
comment|// mode, we only count the bounding rect of items.
if|if
condition|(
operator|!
name|boundingRectUpdate
condition|)
block|{
name|updateRegion
operator|+=
name|rect
expr_stmt|;
block|}
else|else
block|{
name|boundingRect
operator||=
name|rect
expr_stmt|;
block|}
name|redraw
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|fullUpdate
condition|)
block|{
comment|// If fullUpdate is true and we found a visible dirty rect,
comment|// we're done.
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|redraw
condition|)
return|return;
if|if
condition|(
name|fullUpdate
condition|)
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|boundingRectUpdate
condition|)
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|boundingRect
argument_list|)
expr_stmt|;
else|else
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|updateRegion
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Notifies QGraphicsView that the scene's scene rect has changed.  \a rect     is the new scene rect. If the view already has an explicitly set scene     rect, this function does nothing.      \sa sceneRect, QGraphicsScene::sceneRectChanged() */
end_comment
begin_function
DECL|function|updateSceneRect
name|void
name|QGraphicsView
operator|::
name|updateSceneRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|hasSceneRect
condition|)
block|{
name|d
operator|->
name|sceneRect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This slot is called by QAbstractScrollArea after setViewport() has been     called. Reimplement this function in a subclass of QGraphicsView to     initialize the new viewport \a widget before it is used.      \sa setViewport() */
end_comment
begin_function
DECL|function|setupViewport
name|void
name|QGraphicsView
operator|::
name|setupViewport
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsView::setupViewport: cannot initialize null widget"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|bool
name|isGLWidget
init|=
name|widget
operator|->
name|inherits
argument_list|(
literal|"QGLWidget"
argument_list|)
decl_stmt|;
name|d
operator|->
name|accelerateScrolling
operator|=
operator|!
operator|(
name|isGLWidget
operator|)
expr_stmt|;
name|widget
operator|->
name|setFocusPolicy
argument_list|(
name|Qt
operator|::
name|StrongFocus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isGLWidget
condition|)
block|{
comment|// autoFillBackground enables scroll acceleration.
name|widget
operator|->
name|setAutoFillBackground
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// We are only interested in mouse tracking if items
comment|// accept hover events or use non-default cursors or if
comment|// AnchorUnderMouse is used as transformation or resize anchor.
if|if
condition|(
operator|(
name|d
operator|->
name|scene
operator|&&
operator|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|||
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsUseDefaultCursor
operator|)
operator|)
operator|||
name|d
operator|->
name|transformationAnchor
operator|==
name|AnchorUnderMouse
operator|||
name|d
operator|->
name|resizeAnchor
operator|==
name|AnchorUnderMouse
condition|)
block|{
name|widget
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// enable touch events if any items is interested in them
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreTouchEvents
condition|)
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|gesture
decl|,
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|grabbedGestures
operator|.
name|keys
argument_list|()
control|)
name|widget
operator|->
name|grabGesture
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|widget
operator|->
name|setAcceptDrops
argument_list|(
name|acceptDrops
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QGraphicsView
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
if|if
condition|(
name|d
operator|->
name|scene
condition|)
return|return
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
return|;
break|break;
case|case
name|QEvent
operator|::
name|KeyPress
case|:
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
name|QKeyEvent
modifier|*
name|k
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
condition|)
block|{
comment|// Send the key events to the scene. This will invoke the
comment|// scene's tab focus handling, and if the event is
comment|// accepted, we return (prevent further event delivery),
comment|// and the base implementation will call QGraphicsView's
comment|// focusNextPrevChild() function. If the event is ignored,
comment|// we fall back to standard tab focus handling.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
return|return
literal|true
return|;
comment|// Ensure the event doesn't propagate just because the
comment|// scene ignored it. If the event propagates, then tab
comment|// handling will be called twice (this and parent).
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|QAbstractScrollArea
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|viewportEvent
name|bool
name|QGraphicsView
operator|::
name|viewportEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
name|QAbstractScrollArea
operator|::
name|viewportEvent
argument_list|(
name|event
argument_list|)
return|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Enter
case|:
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
comment|// ### This is a temporary fix for until we get proper mouse
comment|// grab events. mouseGrabberItem should be set to 0 if we lose
comment|// the mouse grab.
comment|// Remove all popups when the scene loses focus.
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removePopup
argument_list|(
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|popupWidgets
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|isActiveWindow
argument_list|()
condition|)
block|{
name|QEvent
name|windowActivate
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|windowActivate
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
comment|// spontaneous event will generate a WindowDeactivate.
if|if
condition|(
operator|!
name|event
operator|->
name|spontaneous
argument_list|()
operator|&&
name|d
operator|->
name|scene
operator|&&
name|isActiveWindow
argument_list|()
condition|)
block|{
name|QEvent
name|windowDeactivate
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|windowDeactivate
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|Leave
case|:
block|{
comment|// ### This is a temporary fix for until we get proper mouse grab
comment|// events. activeMouseGrabberItem should be set to 0 if we lose the
comment|// mouse grab.
if|if
condition|(
operator|(
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|&&
name|QApplication
operator|::
name|activePopupWidget
argument_list|()
operator|!=
name|window
argument_list|()
operator|)
operator|||
operator|(
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|&&
name|QApplication
operator|::
name|activeModalWidget
argument_list|()
operator|!=
name|window
argument_list|()
operator|)
operator|||
operator|(
name|QApplication
operator|::
name|activeWindow
argument_list|()
operator|!=
name|window
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removePopup
argument_list|(
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|popupWidgets
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|useLastMouseEvent
operator|=
literal|false
expr_stmt|;
comment|// a hack to pass a viewport pointer to the scene inside the leave event
name|Q_ASSERT
argument_list|(
name|event
operator|->
name|d
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QScopedValueRollback
argument_list|<
name|QEventPrivate
modifier|*
argument_list|>
name|rb
argument_list|(
name|event
operator|->
name|d
argument_list|)
decl_stmt|;
name|event
operator|->
name|d
operator|=
cast|reinterpret_cast
argument_list|<
name|QEventPrivate
operator|*
argument_list|>
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TOOLTIP
case|case
name|QEvent
operator|::
name|ToolTip
case|:
block|{
name|QHelpEvent
modifier|*
name|toolTip
init|=
cast|static_cast
argument_list|<
name|QHelpEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QGraphicsSceneHelpEvent
name|helpEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneHelp
argument_list|)
decl_stmt|;
name|helpEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|helpEvent
operator|.
name|setScreenPos
argument_list|(
name|toolTip
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|helpEvent
operator|.
name|setScenePos
argument_list|(
name|mapToScene
argument_list|(
name|toolTip
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|helpEvent
argument_list|)
expr_stmt|;
name|toolTip
operator|->
name|setAccepted
argument_list|(
name|helpEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
case|case
name|QEvent
operator|::
name|Paint
case|:
comment|// Reset full update
name|d
operator|->
name|fullUpdatePending
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|dirtyScrollOffset
operator|=
name|QPoint
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
comment|// Check if this view reimplements the updateScene slot; if it
comment|// does, we can't do direct update delivery and have to fall back
comment|// to connecting the changed signal.
if|if
condition|(
operator|!
name|d
operator|->
name|updateSceneSlotReimplementedChecked
condition|)
block|{
name|d
operator|->
name|updateSceneSlotReimplementedChecked
operator|=
literal|true
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|metaObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|mo
operator|!=
operator|&
name|QGraphicsView
operator|::
name|staticMetaObject
condition|)
block|{
if|if
condition|(
name|mo
operator|->
name|indexOfSlot
argument_list|(
literal|"updateScene(QList<QRectF>)"
argument_list|)
operator|!=
name|QGraphicsView
operator|::
name|staticMetaObject
operator|.
name|indexOfSlot
argument_list|(
literal|"updateScene(QList<QRectF>)"
argument_list|)
condition|)
block|{
name|connect
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|SIGNAL
argument_list|(
name|changed
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|updateScene
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
comment|// Convert and deliver the touch event to the scene.
name|QTouchEvent
modifier|*
name|touchEvent
init|=
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|touchEvent
operator|->
name|setTarget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|QGraphicsViewPrivate
operator|::
name|translateTouchEvent
argument_list|(
name|d
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|Gesture
case|:
case|case
name|QEvent
operator|::
name|GestureOverride
case|:
block|{
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
name|QGestureEvent
modifier|*
name|gestureEvent
init|=
cast|static_cast
argument_list|<
name|QGestureEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|gestureEvent
operator|->
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|gestureEvent
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
default|default:
break|break;
block|}
return|return
name|QAbstractScrollArea
operator|::
name|viewportEvent
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONTEXTMENU
end_ifndef
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QGraphicsView
operator|::
name|contextMenuEvent
parameter_list|(
name|QContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
name|d
operator|->
name|mousePressViewPoint
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
name|d
operator|->
name|mousePressScenePoint
operator|=
name|mapToScene
argument_list|(
name|d
operator|->
name|mousePressViewPoint
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressScreenPoint
operator|=
name|event
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScenePoint
operator|=
name|d
operator|->
name|mousePressScenePoint
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScreenPoint
operator|=
name|d
operator|->
name|mousePressScreenPoint
expr_stmt|;
name|QGraphicsSceneContextMenuEvent
name|contextEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneContextMenu
argument_list|)
decl_stmt|;
name|contextEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|contextEvent
operator|.
name|setScenePos
argument_list|(
name|d
operator|->
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|contextEvent
operator|.
name|setScreenPos
argument_list|(
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|contextEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|contextEvent
operator|.
name|setReason
argument_list|(
call|(
name|QGraphicsSceneContextMenuEvent
operator|::
name|Reason
call|)
argument_list|(
name|event
operator|->
name|reason
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|contextEvent
operator|.
name|setAccepted
argument_list|(
name|event
operator|->
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|contextEvent
argument_list|)
expr_stmt|;
name|event
operator|->
name|setAccepted
argument_list|(
name|contextEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONTEXTMENU
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QGraphicsView
operator|::
name|dropEvent
parameter_list|(
name|QDropEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
comment|// Generate a scene event.
name|QGraphicsSceneDragDropEvent
name|sceneEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDrop
argument_list|)
decl_stmt|;
name|d
operator|->
name|populateSceneDragDropEvent
argument_list|(
operator|&
name|sceneEvent
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|// Send it to the scene.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Accept the originating event if the scene accepted the scene event.
name|event
operator|->
name|setAccepted
argument_list|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
condition|)
name|event
operator|->
name|setDropAction
argument_list|(
name|sceneEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|lastDragDropEvent
expr_stmt|;
name|d
operator|->
name|lastDragDropEvent
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|event
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QGraphicsView
operator|::
name|dragEnterEvent
parameter_list|(
name|QDragEnterEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
comment|// Disable replaying of mouse move events.
name|d
operator|->
name|useLastMouseEvent
operator|=
literal|false
expr_stmt|;
comment|// Generate a scene event.
name|QGraphicsSceneDragDropEvent
name|sceneEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragEnter
argument_list|)
decl_stmt|;
name|d
operator|->
name|populateSceneDragDropEvent
argument_list|(
operator|&
name|sceneEvent
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|// Store it for later use.
name|d
operator|->
name|storeDragDropEvent
argument_list|(
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Send it to the scene.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Accept the originating event if the scene accepted the scene event.
if|if
condition|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|event
operator|->
name|setAccepted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|event
operator|->
name|setDropAction
argument_list|(
name|sceneEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|event
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QGraphicsView
operator|::
name|dragLeaveEvent
parameter_list|(
name|QDragLeaveEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|lastDragDropEvent
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsView::dragLeaveEvent: drag leave received before drag enter"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Generate a scene event.
name|QGraphicsSceneDragDropEvent
name|sceneEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragLeave
argument_list|)
decl_stmt|;
name|sceneEvent
operator|.
name|setScenePos
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setScreenPos
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setButtons
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setModifiers
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setPossibleActions
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|possibleActions
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setProposedAction
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|proposedAction
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setDropAction
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setMimeData
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|mimeData
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setWidget
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|sceneEvent
operator|.
name|setSource
argument_list|(
name|d
operator|->
name|lastDragDropEvent
operator|->
name|source
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|lastDragDropEvent
expr_stmt|;
name|d
operator|->
name|lastDragDropEvent
operator|=
literal|0
expr_stmt|;
comment|// Send it to the scene.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Accept the originating event if the scene accepted the scene event.
if|if
condition|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
condition|)
name|event
operator|->
name|setAccepted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|event
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QGraphicsView
operator|::
name|dragMoveEvent
parameter_list|(
name|QDragMoveEvent
modifier|*
name|event
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
comment|// Generate a scene event.
name|QGraphicsSceneDragDropEvent
name|sceneEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragMove
argument_list|)
decl_stmt|;
name|d
operator|->
name|populateSceneDragDropEvent
argument_list|(
operator|&
name|sceneEvent
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|// Store it for later use.
name|d
operator|->
name|storeDragDropEvent
argument_list|(
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Send it to the scene.
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|sceneEvent
argument_list|)
expr_stmt|;
comment|// Ignore the originating event if the scene ignored the scene event.
name|event
operator|->
name|setAccepted
argument_list|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sceneEvent
operator|.
name|isAccepted
argument_list|()
condition|)
name|event
operator|->
name|setDropAction
argument_list|(
name|sceneEvent
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|event
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QGraphicsView
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateInputMethodSensitivity
argument_list|()
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|focusInEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|// Pass focus on if the scene cannot accept focus.
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|QAbstractScrollArea
operator|::
name|focusInEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QGraphicsView
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
return|return
name|QAbstractScrollArea
operator|::
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QGraphicsView
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|focusOutEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QGraphicsView
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
name|QAbstractScrollArea
operator|::
name|keyPressEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|QAbstractScrollArea
operator|::
name|keyPressEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QGraphicsView
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|QAbstractScrollArea
operator|::
name|keyReleaseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QGraphicsView
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
name|d
operator|->
name|storeMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressViewPoint
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
name|d
operator|->
name|mousePressScenePoint
operator|=
name|mapToScene
argument_list|(
name|d
operator|->
name|mousePressViewPoint
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressScreenPoint
operator|=
name|event
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScenePoint
operator|=
name|d
operator|->
name|mousePressScenePoint
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScreenPoint
operator|=
name|d
operator|->
name|mousePressScreenPoint
expr_stmt|;
name|d
operator|->
name|mousePressButton
operator|=
name|event
operator|->
name|button
argument_list|()
expr_stmt|;
name|QGraphicsSceneMouseEvent
name|mouseEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
argument_list|)
decl_stmt|;
name|mouseEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScenePos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScreenPos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScenePos
argument_list|(
name|mapToScene
argument_list|(
name|d
operator|->
name|mousePressViewPoint
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScreenPos
argument_list|(
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScenePos
argument_list|(
name|d
operator|->
name|lastMouseMoveScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScreenPos
argument_list|(
name|d
operator|->
name|lastMouseMoveScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButton
argument_list|(
name|event
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
name|qt_sendSpontaneousEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QGraphicsView
operator|::
name|mousePressEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
comment|// Store this event for replaying, finding deltas, and for
comment|// scroll-dragging; even in non-interactive mode, scroll hand dragging is
comment|// allowed, so we store the event at the very top of this function.
name|d
operator|->
name|storeMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastMouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
comment|// Store some of the event's button-down data.
name|d
operator|->
name|mousePressViewPoint
operator|=
name|event
operator|->
name|pos
argument_list|()
expr_stmt|;
name|d
operator|->
name|mousePressScenePoint
operator|=
name|mapToScene
argument_list|(
name|d
operator|->
name|mousePressViewPoint
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressScreenPoint
operator|=
name|event
operator|->
name|globalPos
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScenePoint
operator|=
name|d
operator|->
name|mousePressScenePoint
expr_stmt|;
name|d
operator|->
name|lastMouseMoveScreenPoint
operator|=
name|d
operator|->
name|mousePressScreenPoint
expr_stmt|;
name|d
operator|->
name|mousePressButton
operator|=
name|event
operator|->
name|button
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
comment|// Convert and deliver the mouse event to the scene.
name|QGraphicsSceneMouseEvent
name|mouseEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneMousePress
argument_list|)
decl_stmt|;
name|mouseEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScenePos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScreenPos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScenePos
argument_list|(
name|d
operator|->
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScreenPos
argument_list|(
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScenePos
argument_list|(
name|d
operator|->
name|lastMouseMoveScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScreenPos
argument_list|(
name|d
operator|->
name|lastMouseMoveScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButton
argument_list|(
name|event
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
name|qt_sendSpontaneousEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
comment|// Update the original mouse event accepted state.
name|bool
name|isAccepted
init|=
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
decl_stmt|;
name|event
operator|->
name|setAccepted
argument_list|(
name|isAccepted
argument_list|)
expr_stmt|;
comment|// Update the last mouse event accepted state.
name|d
operator|->
name|lastMouseEvent
operator|.
name|setAccepted
argument_list|(
name|isAccepted
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAccepted
condition|)
return|return;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|RubberBandDrag
operator|&&
operator|!
name|d
operator|->
name|rubberBanding
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
comment|// Rubberbanding is only allowed in interactive mode.
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|rubberBanding
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|rubberBandRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
comment|// Initiating a rubber band always clears the selection.
name|d
operator|->
name|scene
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|ScrollHandDrag
operator|&&
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
comment|// Left-button press in scroll hand mode initiates hand scrolling.
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|handScrolling
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|handScrollMotions
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
name|viewport
argument_list|()
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|ClosedHandCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QGraphicsView
operator|::
name|mouseMoveEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|RubberBandDrag
operator|&&
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
name|d
operator|->
name|storeMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rubberBanding
condition|)
block|{
comment|// Check for enough drag distance
if|if
condition|(
operator|(
name|d
operator|->
name|mousePressViewPoint
operator|-
name|event
operator|->
name|pos
argument_list|()
operator|)
operator|.
name|manhattanLength
argument_list|()
operator|<
name|QApplication
operator|::
name|startDragDistance
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Update old rubberband
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|NoViewportUpdate
operator|&&
operator|!
name|d
operator|->
name|rubberBandRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|FullViewportUpdate
condition|)
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|d
operator|->
name|rubberBandRegion
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|d
operator|->
name|rubberBandRect
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
comment|// Stop rubber banding if the user has let go of all buttons (even
comment|// if we didn't get the release events).
if|if
condition|(
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
block|{
name|d
operator|->
name|rubberBanding
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|rubberBandRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Update rubberband position
specifier|const
name|QPoint
name|mp
init|=
name|mapFromScene
argument_list|(
name|d
operator|->
name|mousePressScenePoint
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|ep
init|=
name|event
operator|->
name|pos
argument_list|()
decl_stmt|;
name|d
operator|->
name|rubberBandRect
operator|=
name|QRect
argument_list|(
name|qMin
argument_list|(
name|mp
operator|.
name|x
argument_list|()
argument_list|,
name|ep
operator|.
name|x
argument_list|()
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|mp
operator|.
name|y
argument_list|()
argument_list|,
name|ep
operator|.
name|y
argument_list|()
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|mp
operator|.
name|x
argument_list|()
operator|-
name|ep
operator|.
name|x
argument_list|()
argument_list|)
operator|+
literal|1
argument_list|,
name|qAbs
argument_list|(
name|mp
operator|.
name|y
argument_list|()
operator|-
name|ep
operator|.
name|y
argument_list|()
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Update new rubberband
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|NoViewportUpdate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|FullViewportUpdate
condition|)
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|d
operator|->
name|rubberBandRegion
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|d
operator|->
name|rubberBandRect
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
comment|// Set the new selection area
name|QPainterPath
name|selectionArea
decl_stmt|;
name|selectionArea
operator|.
name|addPolygon
argument_list|(
name|mapToScene
argument_list|(
name|d
operator|->
name|rubberBandRect
argument_list|)
argument_list|)
expr_stmt|;
name|selectionArea
operator|.
name|closeSubpath
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|d
operator|->
name|scene
operator|->
name|setSelectionArea
argument_list|(
name|selectionArea
argument_list|,
name|d
operator|->
name|rubberBandSelectionMode
argument_list|,
name|viewportTransform
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|// QT_NO_RUBBERBAND
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|ScrollHandDrag
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|handScrolling
condition|)
block|{
name|QScrollBar
modifier|*
name|hBar
init|=
name|horizontalScrollBar
argument_list|()
decl_stmt|;
name|QScrollBar
modifier|*
name|vBar
init|=
name|verticalScrollBar
argument_list|()
decl_stmt|;
name|QPoint
name|delta
init|=
name|event
operator|->
name|pos
argument_list|()
operator|-
name|d
operator|->
name|lastMouseEvent
operator|.
name|pos
argument_list|()
decl_stmt|;
name|hBar
operator|->
name|setValue
argument_list|(
name|hBar
operator|->
name|value
argument_list|()
operator|+
operator|(
name|isRightToLeft
argument_list|()
condition|?
name|delta
operator|.
name|x
argument_list|()
else|:
operator|-
name|delta
operator|.
name|x
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|vBar
operator|->
name|setValue
argument_list|(
name|vBar
operator|->
name|value
argument_list|()
operator|-
name|delta
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Detect how much we've scrolled to disambiguate scrolling from
comment|// clicking.
operator|++
name|d
operator|->
name|handScrollMotions
expr_stmt|;
block|}
block|}
name|d
operator|->
name|mouseMoveEventHandler
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QGraphicsView
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|RubberBandDrag
operator|&&
name|d
operator|->
name|sceneInteractionAllowed
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|rubberBanding
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|NoViewportUpdate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|FullViewportUpdate
condition|)
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|d
operator|->
name|rubberBandRegion
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|d
operator|->
name|rubberBandRect
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|rubberBanding
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|rubberBandRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|dragMode
operator|==
name|QGraphicsView
operator|::
name|ScrollHandDrag
operator|&&
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
comment|// Restore the open hand cursor. ### There might be items
comment|// under the mouse that have a valid cursor at this time, so
comment|// we could repeat the steps from mouseMoveEvent().
name|viewport
argument_list|()
operator|->
name|setCursor
argument_list|(
name|Qt
operator|::
name|OpenHandCursor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|handScrolling
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|sceneInteractionAllowed
operator|&&
operator|!
name|d
operator|->
name|lastMouseEvent
operator|.
name|isAccepted
argument_list|()
operator|&&
name|d
operator|->
name|handScrollMotions
operator|<=
literal|6
condition|)
block|{
comment|// If we've detected very little motion during the hand drag, and
comment|// no item accepted the last event, we'll interpret that as a
comment|// click to the scene, and reset the selection.
name|d
operator|->
name|scene
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|storeMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return;
name|QGraphicsSceneMouseEvent
name|mouseEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
argument_list|)
decl_stmt|;
name|mouseEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScenePos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtonDownScreenPos
argument_list|(
name|d
operator|->
name|mousePressButton
argument_list|,
name|d
operator|->
name|mousePressScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScenePos
argument_list|(
name|mapToScene
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setScreenPos
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScenePos
argument_list|(
name|d
operator|->
name|lastMouseMoveScenePoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setLastScreenPos
argument_list|(
name|d
operator|->
name|lastMouseMoveScreenPoint
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setButton
argument_list|(
name|event
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|mouseEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|spontaneous
argument_list|()
condition|)
name|qt_sendSpontaneousEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
else|else
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|mouseEvent
argument_list|)
expr_stmt|;
comment|// Update the last mouse event selected state.
name|d
operator|->
name|lastMouseEvent
operator|.
name|setAccepted
argument_list|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|mouseEvent
operator|.
name|isAccepted
argument_list|()
operator|&&
name|mouseEvent
operator|.
name|buttons
argument_list|()
operator|==
literal|0
operator|&&
name|viewport
argument_list|()
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetCursor
argument_list|)
condition|)
block|{
comment|// The last mouse release on the viewport will trigger clearing the cursor.
name|d
operator|->
name|_q_unsetViewportCursor
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_WHEELEVENT
end_ifndef
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|wheelEvent
name|void
name|QGraphicsView
operator|::
name|wheelEvent
parameter_list|(
name|QWheelEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|||
operator|!
name|d
operator|->
name|sceneInteractionAllowed
condition|)
block|{
name|QAbstractScrollArea
operator|::
name|wheelEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
name|QGraphicsSceneWheelEvent
name|wheelEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneWheel
argument_list|)
decl_stmt|;
name|wheelEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setScenePos
argument_list|(
name|mapToScene
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setScreenPos
argument_list|(
name|event
operator|->
name|globalPos
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setButtons
argument_list|(
name|event
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setModifiers
argument_list|(
name|event
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setDelta
argument_list|(
name|event
operator|->
name|delta
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setOrientation
argument_list|(
name|event
operator|->
name|orientation
argument_list|()
argument_list|)
expr_stmt|;
name|wheelEvent
operator|.
name|setAccepted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
operator|&
name|wheelEvent
argument_list|)
expr_stmt|;
name|event
operator|->
name|setAccepted
argument_list|(
name|wheelEvent
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|QAbstractScrollArea
operator|::
name|wheelEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_WHEELEVENT
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paintEvent
name|void
name|QGraphicsView
operator|::
name|paintEvent
parameter_list|(
name|QPaintEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
block|{
name|QAbstractScrollArea
operator|::
name|paintEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set up painter state protection.
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|painterStateProtection
operator|=
operator|!
operator|(
name|d
operator|->
name|optimizationFlags
operator|&
name|DontSavePainterState
operator|)
expr_stmt|;
comment|// Determine the exposed region
name|d
operator|->
name|exposedRegion
operator|=
name|event
operator|->
name|region
argument_list|()
expr_stmt|;
name|QRectF
name|exposedSceneRect
init|=
name|mapToScene
argument_list|(
name|d
operator|->
name|exposedRegion
operator|.
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
comment|// Set up the painter
name|QPainter
name|painter
argument_list|(
name|viewport
argument_list|()
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|d
operator|->
name|rubberBanding
operator|&&
operator|!
name|d
operator|->
name|rubberBandRect
operator|.
name|isEmpty
argument_list|()
condition|)
name|painter
operator|.
name|save
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Set up render hints
name|painter
operator|.
name|setRenderHints
argument_list|(
name|painter
operator|.
name|renderHints
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setRenderHints
argument_list|(
name|d
operator|->
name|renderHints
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Set up viewport transform
specifier|const
name|bool
name|viewTransformed
init|=
name|isTransformed
argument_list|()
decl_stmt|;
if|if
condition|(
name|viewTransformed
condition|)
name|painter
operator|.
name|setWorldTransform
argument_list|(
name|viewportTransform
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QTransform
name|viewTransform
init|=
name|painter
operator|.
name|worldTransform
argument_list|()
decl_stmt|;
comment|// Draw background
if|if
condition|(
operator|(
name|d
operator|->
name|cacheMode
operator|&
name|CacheBackground
operator|)
ifdef|#
directive|ifdef
name|Q_WS_X11
operator|&&
name|X11
operator|->
name|use_xrender
endif|#
directive|endif
condition|)
block|{
comment|// Recreate the background pixmap, and flag the whole background as
comment|// exposed.
if|if
condition|(
name|d
operator|->
name|mustResizeBackgroundPixmap
condition|)
block|{
name|d
operator|->
name|backgroundPixmap
operator|=
name|QPixmap
argument_list|(
name|viewport
argument_list|()
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QBrush
name|bgBrush
init|=
name|viewport
argument_list|()
operator|->
name|palette
argument_list|()
operator|.
name|brush
argument_list|(
name|viewport
argument_list|()
operator|->
name|backgroundRole
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bgBrush
operator|.
name|isOpaque
argument_list|()
condition|)
name|d
operator|->
name|backgroundPixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|d
operator|->
name|backgroundPixmap
argument_list|)
decl_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|backgroundPixmap
operator|.
name|width
argument_list|()
argument_list|,
name|d
operator|->
name|backgroundPixmap
operator|.
name|height
argument_list|()
argument_list|,
name|bgBrush
argument_list|)
expr_stmt|;
name|d
operator|->
name|backgroundPixmapExposed
operator|=
name|QRegion
argument_list|(
name|viewport
argument_list|()
operator|->
name|rect
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|mustResizeBackgroundPixmap
operator|=
literal|false
expr_stmt|;
block|}
comment|// Redraw exposed areas
if|if
condition|(
operator|!
name|d
operator|->
name|backgroundPixmapExposed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QPainter
name|backgroundPainter
argument_list|(
operator|&
name|d
operator|->
name|backgroundPixmap
argument_list|)
decl_stmt|;
name|backgroundPainter
operator|.
name|setClipRegion
argument_list|(
name|d
operator|->
name|backgroundPixmapExposed
argument_list|,
name|Qt
operator|::
name|ReplaceClip
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewTransformed
condition|)
name|backgroundPainter
operator|.
name|setTransform
argument_list|(
name|viewTransform
argument_list|)
expr_stmt|;
name|QRectF
name|backgroundExposedSceneRect
init|=
name|mapToScene
argument_list|(
name|d
operator|->
name|backgroundPixmapExposed
operator|.
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|drawBackground
argument_list|(
operator|&
name|backgroundPainter
argument_list|,
name|backgroundExposedSceneRect
argument_list|)
expr_stmt|;
name|d
operator|->
name|backgroundPixmapExposed
operator|=
name|QRegion
argument_list|()
expr_stmt|;
block|}
comment|// Blit the background from the background pixmap
if|if
condition|(
name|viewTransformed
condition|)
block|{
name|painter
operator|.
name|setWorldTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawPixmap
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|d
operator|->
name|backgroundPixmap
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setWorldTransform
argument_list|(
name|viewTransform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|painter
operator|.
name|drawPixmap
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|d
operator|->
name|backgroundPixmap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|optimizationFlags
operator|&
name|DontSavePainterState
operator|)
condition|)
name|painter
operator|.
name|save
argument_list|()
expr_stmt|;
name|drawBackground
argument_list|(
operator|&
name|painter
argument_list|,
name|exposedSceneRect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|optimizationFlags
operator|&
name|DontSavePainterState
operator|)
condition|)
name|painter
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
comment|// Items
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|optimizationFlags
operator|&
name|IndirectPainting
operator|)
condition|)
block|{
specifier|const
name|quint32
name|oldRectAdjust
init|=
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|rectAdjust
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|optimizationFlags
operator|&
name|QGraphicsView
operator|::
name|DontAdjustForAntialiasing
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|rectAdjust
operator|=
literal|1
expr_stmt|;
else|else
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|rectAdjust
operator|=
literal|2
expr_stmt|;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|drawItems
argument_list|(
operator|&
name|painter
argument_list|,
name|viewTransformed
condition|?
operator|&
name|viewTransform
else|:
literal|0
argument_list|,
operator|&
name|d
operator|->
name|exposedRegion
argument_list|,
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|rectAdjust
operator|=
name|oldRectAdjust
expr_stmt|;
comment|// Make sure the painter's world transform is restored correctly when
comment|// drawing without painter state protection (DontSavePainterState).
comment|// We only change the worldTransform() so there's no need to do a full-blown
comment|// save() and restore(). Also note that we don't have to do this in case of
comment|// IndirectPainting (the else branch), because in that case we always save()
comment|// and restore() in QGraphicsScene::drawItems().
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|painterStateProtection
condition|)
name|painter
operator|.
name|setOpacity
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setWorldTransform
argument_list|(
name|viewTransform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Make sure we don't have unpolished items before we draw
if|if
condition|(
operator|!
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|unpolishedItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|_q_polishItems
argument_list|()
expr_stmt|;
comment|// We reset updateAll here (after we've issued polish events)
comment|// so that we can discard update requests coming from polishEvent().
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|updateAll
operator|=
literal|false
expr_stmt|;
comment|// Find all exposed items
name|bool
name|allItems
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
init|=
name|d
operator|->
name|findItems
argument_list|(
name|d
operator|->
name|exposedRegion
argument_list|,
operator|&
name|allItems
argument_list|,
name|viewTransform
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|itemList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Generate the style options.
specifier|const
name|int
name|numItems
init|=
name|itemList
operator|.
name|size
argument_list|()
decl_stmt|;
name|QGraphicsItem
modifier|*
modifier|*
name|itemArray
init|=
operator|&
name|itemList
index|[
literal|0
index|]
decl_stmt|;
comment|// Relies on QList internals, but is perfectly valid.
name|QStyleOptionGraphicsItem
modifier|*
name|styleOptionArray
init|=
name|d
operator|->
name|allocStyleOptionsArray
argument_list|(
name|numItems
argument_list|)
decl_stmt|;
name|QTransform
name|transform
argument_list|(
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|itemArray
index|[
name|i
index|]
decl_stmt|;
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
name|item
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|itemd
operator|->
name|initStyleOption
argument_list|(
operator|&
name|styleOptionArray
index|[
name|i
index|]
argument_list|,
name|viewTransform
argument_list|,
name|d
operator|->
name|exposedRegion
argument_list|,
name|allItems
argument_list|)
expr_stmt|;
comment|// Cache the item's area in view coordinates.
comment|// Note that we have to do this here in case the base class implementation
comment|// (QGraphicsScene::drawItems) is not called. If it is, we'll do this
comment|// operation twice, but that's the price one has to pay for using indirect
comment|// painting :-/.
specifier|const
name|QRectF
name|brect
init|=
name|adjustedItemEffectiveBoundingRect
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|itemd
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|transform
operator|=
name|item
operator|->
name|sceneTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|viewTransformed
condition|)
name|transform
operator|*=
name|viewTransform
expr_stmt|;
block|}
else|else
block|{
name|transform
operator|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|viewTransform
argument_list|)
expr_stmt|;
block|}
name|itemd
operator|->
name|paintedViewBoundingRects
operator|.
name|insert
argument_list|(
name|d
operator|->
name|viewport
argument_list|,
name|transform
operator|.
name|mapRect
argument_list|(
name|brect
argument_list|)
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Draw the items.
name|drawItems
argument_list|(
operator|&
name|painter
argument_list|,
name|numItems
argument_list|,
name|itemArray
argument_list|,
name|styleOptionArray
argument_list|)
expr_stmt|;
name|d
operator|->
name|freeStyleOptionsArray
argument_list|(
name|styleOptionArray
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Foreground
name|drawForeground
argument_list|(
operator|&
name|painter
argument_list|,
name|exposedSceneRect
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
comment|// Rubberband
if|if
condition|(
name|d
operator|->
name|rubberBanding
operator|&&
operator|!
name|d
operator|->
name|rubberBandRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|painter
operator|.
name|restore
argument_list|()
expr_stmt|;
name|QStyleOptionRubberBand
name|option
decl_stmt|;
name|option
operator|.
name|initFrom
argument_list|(
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
name|option
operator|.
name|rect
operator|=
name|d
operator|->
name|rubberBandRect
expr_stmt|;
name|option
operator|.
name|shape
operator|=
name|QRubberBand
operator|::
name|Rectangle
expr_stmt|;
name|QStyleHintReturnMask
name|mask
decl_stmt|;
if|if
condition|(
name|viewport
argument_list|()
operator|->
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_RubberBand_Mask
argument_list|,
operator|&
name|option
argument_list|,
name|viewport
argument_list|()
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
comment|// painter clipping for masked rubberbands
name|painter
operator|.
name|setClipRegion
argument_list|(
name|mask
operator|.
name|region
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
block|}
name|viewport
argument_list|()
operator|->
name|style
argument_list|()
operator|->
name|drawControl
argument_list|(
name|QStyle
operator|::
name|CE_RubberBand
argument_list|,
operator|&
name|option
argument_list|,
operator|&
name|painter
argument_list|,
name|viewport
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|painter
operator|.
name|end
argument_list|()
expr_stmt|;
comment|// Restore painter state protection.
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|painterStateProtection
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QGraphicsView
operator|::
name|resizeEvent
parameter_list|(
name|QResizeEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
comment|// Save the last center point - the resize may scroll the view, which
comment|// changes the center point.
name|QPointF
name|oldLastCenterPoint
init|=
name|d
operator|->
name|lastCenterPoint
decl_stmt|;
name|QAbstractScrollArea
operator|::
name|resizeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
comment|// Restore the center point again.
if|if
condition|(
name|d
operator|->
name|resizeAnchor
operator|==
name|NoAnchor
operator|&&
operator|!
name|d
operator|->
name|keepLastCenterPoint
condition|)
block|{
name|d
operator|->
name|updateLastCenterPoint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|lastCenterPoint
operator|=
name|oldLastCenterPoint
expr_stmt|;
block|}
name|d
operator|->
name|centerView
argument_list|(
name|d
operator|->
name|resizeAnchor
argument_list|)
expr_stmt|;
name|d
operator|->
name|keepLastCenterPoint
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cacheMode
operator|&
name|CacheBackground
condition|)
block|{
comment|// Invalidate the background pixmap
name|d
operator|->
name|mustResizeBackgroundPixmap
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|scrollContentsBy
name|void
name|QGraphicsView
operator|::
name|scrollContentsBy
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirtyScroll
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|transforming
condition|)
return|return;
if|if
condition|(
name|isRightToLeft
argument_list|()
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|NoViewportUpdate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|viewportUpdateMode
operator|!=
name|QGraphicsView
operator|::
name|FullViewportUpdate
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|accelerateScrolling
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
comment|// Update new and old rubberband regions
if|if
condition|(
operator|!
name|d
operator|->
name|rubberBandRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QRegion
name|rubberBandRegion
argument_list|(
name|d
operator|->
name|rubberBandRegion
argument_list|(
name|viewport
argument_list|()
argument_list|,
name|d
operator|->
name|rubberBandRect
argument_list|)
argument_list|)
decl_stmt|;
name|rubberBandRegion
operator|+=
name|rubberBandRegion
operator|.
name|translated
argument_list|(
operator|-
name|dx
argument_list|,
operator|-
name|dy
argument_list|)
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|update
argument_list|(
name|rubberBandRegion
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|dirtyScrollOffset
operator|.
name|rx
argument_list|()
operator|+=
name|dx
expr_stmt|;
name|d
operator|->
name|dirtyScrollOffset
operator|.
name|ry
argument_list|()
operator|+=
name|dy
expr_stmt|;
name|d
operator|->
name|dirtyRegion
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|viewport
argument_list|()
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
block|}
name|d
operator|->
name|updateLastCenterPoint
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|cacheMode
operator|&
name|CacheBackground
operator|)
ifdef|#
directive|ifdef
name|Q_WS_X11
operator|&&
name|X11
operator|->
name|use_xrender
endif|#
directive|endif
condition|)
block|{
comment|// Scroll the background pixmap
name|QRegion
name|exposed
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|backgroundPixmap
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|backgroundPixmap
operator|.
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|d
operator|->
name|backgroundPixmap
operator|.
name|rect
argument_list|()
argument_list|,
operator|&
name|exposed
argument_list|)
expr_stmt|;
comment|// Invalidate the background pixmap
name|d
operator|->
name|backgroundPixmapExposed
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|d
operator|->
name|backgroundPixmapExposed
operator|+=
name|exposed
expr_stmt|;
block|}
comment|// Always replay on scroll.
if|if
condition|(
name|d
operator|->
name|sceneInteractionAllowed
condition|)
name|d
operator|->
name|replayLastMouseEvent
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QGraphicsView
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
name|d
operator|->
name|centerView
argument_list|(
name|d
operator|->
name|transformationAnchor
argument_list|)
expr_stmt|;
name|QAbstractScrollArea
operator|::
name|showEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QGraphicsView
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|d
operator|->
name|scene
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the background of the scene using \a painter, before any items and     the foreground are drawn. Reimplement this function to provide a custom     background for this view.      If all you want is to define a color, texture or gradient for the     background, you can call setBackgroundBrush() instead.      All painting is done in \e scene coordinates. \a rect is the exposed     rectangle.      The default implementation fills \a rect using the view's backgroundBrush.     If no such brush is defined (the default), the scene's drawBackground()     function is called instead.      \sa drawForeground(), QGraphicsScene::drawBackground() */
end_comment
begin_function
DECL|function|drawBackground
name|void
name|QGraphicsView
operator|::
name|drawBackground
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|backgroundBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|d
operator|->
name|scene
operator|->
name|drawBackground
argument_list|(
name|painter
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|painter
operator|->
name|fillRect
argument_list|(
name|rect
argument_list|,
name|d
operator|->
name|backgroundBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the foreground of the scene using \a painter, after the background     and all items are drawn. Reimplement this function to provide a custom     foreground for this view.      If all you want is to define a color, texture or gradient for the     foreground, you can call setForegroundBrush() instead.      All painting is done in \e scene coordinates. \a rect is the exposed     rectangle.      The default implementation fills \a rect using the view's foregroundBrush.     If no such brush is defined (the default), the scene's drawForeground()     function is called instead.      \sa drawBackground(), QGraphicsScene::drawForeground() */
end_comment
begin_function
DECL|function|drawForeground
name|void
name|QGraphicsView
operator|::
name|drawForeground
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|foregroundBrush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|d
operator|->
name|scene
operator|->
name|drawForeground
argument_list|(
name|painter
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|painter
operator|->
name|fillRect
argument_list|(
name|rect
argument_list|,
name|d
operator|->
name|foregroundBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Draws the items \a items in the scene using \a painter, after the     background and before the foreground are drawn. \a numItems is the number     of items in \a items and options in \a options. \a options is a list of     styleoptions; one for each item. Reimplement this function to provide     custom item drawing for this view.      The default implementation calls the scene's drawItems() function.      Since Qt 4.6, this function is not called anymore unless     the QGraphicsView::IndirectPainting flag is given as an Optimization     flag.      \sa drawForeground(), drawBackground(), QGraphicsScene::drawItems() */
end_comment
begin_function
DECL|function|drawItems
name|void
name|QGraphicsView
operator|::
name|drawItems
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
name|int
name|numItems
parameter_list|,
name|QGraphicsItem
modifier|*
name|items
index|[]
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
name|options
index|[]
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|painter
operator|->
name|device
argument_list|()
operator|==
name|viewport
argument_list|()
condition|?
name|viewport
argument_list|()
else|:
literal|0
decl_stmt|;
name|d
operator|->
name|scene
operator|->
name|drawItems
argument_list|(
name|painter
argument_list|,
name|numItems
argument_list|,
name|items
argument_list|,
name|options
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the current transformation matrix for the view. If no current     transformation is set, the identity matrix is returned.      \sa setTransform(), rotate(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|transform
name|QTransform
name|QGraphicsView
operator|::
name|transform
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|matrix
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a matrix that maps viewport coordinates to scene coordinates.      \sa mapToScene(), mapFromScene() */
end_comment
begin_function
DECL|function|viewportTransform
name|QTransform
name|QGraphicsView
operator|::
name|viewportTransform
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|moveMatrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|d
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
operator|-
name|d
operator|->
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|identityMatrix
condition|?
name|moveMatrix
else|:
name|d
operator|->
name|matrix
operator|*
name|moveMatrix
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns true if the view is transformed (i.e., a non-identity transform     has been assigned, or the scrollbars are adjusted).      \sa setTransform(), horizontalScrollBar(), verticalScrollBar() */
end_comment
begin_function
DECL|function|isTransformed
name|bool
name|QGraphicsView
operator|::
name|isTransformed
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsView
argument_list|)
expr_stmt|;
return|return
operator|!
name|d
operator|->
name|identityMatrix
operator|||
name|d
operator|->
name|horizontalScroll
argument_list|()
operator|||
name|d
operator|->
name|verticalScroll
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the view's current transformation matrix to \a matrix.      If \a combine is true, then \a matrix is combined with the current matrix;     otherwise, \a matrix \e replaces the current matrix. \a combine is false     by default.      The transformation matrix tranforms the scene into view coordinates. Using     the default transformation, provided by the identity matrix, one pixel in     the view represents one unit in the scene (e.g., a 10x10 rectangular item     is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is     applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is     then drawn using 20x20 pixels in the view).      Example:      \snippet code/src_gui_graphicsview_qgraphicsview.cpp 7      To simplify interation with items using a transformed view, QGraphicsView     provides mapTo... and mapFrom... functions that can translate between     scene and view coordinates. For example, you can call mapToScene() to map     a view coordiate to a floating point scene coordinate, or mapFromScene()     to map from floating point scene coordinates to view coordinates.      \sa transform(), rotate(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|setTransform
name|void
name|QGraphicsView
operator|::
name|setTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsView
argument_list|)
expr_stmt|;
name|QTransform
name|oldMatrix
init|=
name|d
operator|->
name|matrix
decl_stmt|;
if|if
condition|(
operator|!
name|combine
condition|)
name|d
operator|->
name|matrix
operator|=
name|matrix
expr_stmt|;
else|else
name|d
operator|->
name|matrix
operator|=
name|matrix
operator|*
name|d
operator|->
name|matrix
expr_stmt|;
if|if
condition|(
name|oldMatrix
operator|==
name|d
operator|->
name|matrix
condition|)
return|return;
name|d
operator|->
name|identityMatrix
operator|=
name|d
operator|->
name|matrix
operator|.
name|isIdentity
argument_list|()
expr_stmt|;
name|d
operator|->
name|transforming
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
condition|)
block|{
name|d
operator|->
name|recalculateContentSize
argument_list|()
expr_stmt|;
name|d
operator|->
name|centerView
argument_list|(
name|d
operator|->
name|transformationAnchor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|updateLastCenterPoint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|sceneInteractionAllowed
condition|)
name|d
operator|->
name|replayLastMouseEvent
argument_list|()
expr_stmt|;
name|d
operator|->
name|transforming
operator|=
literal|false
expr_stmt|;
comment|// Any matrix operation requires a full update.
name|d
operator|->
name|updateAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets the view transformation to the identity matrix.      \sa transform(), setTransform() */
end_comment
begin_function
DECL|function|resetTransform
name|void
name|QGraphicsView
operator|::
name|resetTransform
parameter_list|()
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mapToScene
name|QPointF
name|QGraphicsViewPrivate
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|QPointF
name|p
init|=
name|point
decl_stmt|;
name|p
operator|.
name|rx
argument_list|()
operator|+=
name|horizontalScroll
argument_list|()
expr_stmt|;
name|p
operator|.
name|ry
argument_list|()
operator|+=
name|verticalScroll
argument_list|()
expr_stmt|;
return|return
name|identityMatrix
condition|?
name|p
else|:
name|matrix
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mapToScene
name|QRectF
name|QGraphicsViewPrivate
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|QPointF
name|scrollOffset
argument_list|(
name|horizontalScroll
argument_list|()
argument_list|,
name|verticalScroll
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|tl
init|=
name|scrollOffset
operator|+
name|rect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QPointF
name|tr
init|=
name|scrollOffset
operator|+
name|rect
operator|.
name|topRight
argument_list|()
decl_stmt|;
name|QPointF
name|br
init|=
name|scrollOffset
operator|+
name|rect
operator|.
name|bottomRight
argument_list|()
decl_stmt|;
name|QPointF
name|bl
init|=
name|scrollOffset
operator|+
name|rect
operator|.
name|bottomLeft
argument_list|()
decl_stmt|;
name|QPolygonF
name|poly
argument_list|(
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|identityMatrix
condition|)
block|{
name|QTransform
name|x
init|=
name|matrix
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|poly
index|[
literal|0
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|poly
index|[
literal|1
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|poly
index|[
literal|2
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|poly
index|[
literal|3
index|]
operator|=
name|x
operator|.
name|map
argument_list|(
name|bl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|poly
index|[
literal|0
index|]
operator|=
name|tl
expr_stmt|;
name|poly
index|[
literal|1
index|]
operator|=
name|tr
expr_stmt|;
name|poly
index|[
literal|2
index|]
operator|=
name|br
expr_stmt|;
name|poly
index|[
literal|3
index|]
operator|=
name|bl
expr_stmt|;
block|}
return|return
name|poly
operator|.
name|boundingRect
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qgraphicsview.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GRAPHICSVIEW
end_comment
end_unit
