begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGraphicsScene     \brief The QGraphicsScene class provides a surface for managing a large     number of 2D graphical items.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      The class serves as a container for QGraphicsItems. It is used together     with QGraphicsView for visualizing graphical items, such as lines,     rectangles, text, or even custom items, on a 2D surface. QGraphicsScene is     part of the \l{Graphics View Framework}.      QGraphicsScene also provides functionality that lets you efficiently     determine both the location of items, and for determining what items are     visible within an arbitrary area on the scene. With the QGraphicsView     widget, you can either visualize the whole scene, or zoom in and view only     parts of the scene.      Example:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 0      Note that QGraphicsScene has no visual appearance of its own; it only     manages the items. You need to create a QGraphicsView widget to visualize     the scene.      To add items to a scene, you start off by constructing a QGraphicsScene     object. Then, you have two options: either add your existing QGraphicsItem     objects by calling addItem(), or you can call one of the convenience     functions addEllipse(), addLine(), addPath(), addPixmap(), addPolygon(),     addRect(), or addText(), which all return a pointer to the newly added item.     The dimensions of the items added with these functions are relative to the     item's coordinate system, and the items position is initialized to (0,     0) in the scene.      You can then visualize the scene using QGraphicsView. When the scene     changes, (e.g., when an item moves or is transformed) QGraphicsScene     emits the changed() signal. To remove an item, call removeItem().      QGraphicsScene uses an indexing algorithm to manage the location of items     efficiently. By default, a BSP (Binary Space Partitioning) tree is used; an     algorithm suitable for large scenes where most items remain static (i.e.,     do not move around). You can choose to disable this index by calling     setItemIndexMethod(). For more information about the available indexing     algorithms, see the itemIndexMethod property.      The scene's bounding rect is set by calling setSceneRect(). Items can be     placed at any position on the scene, and the size of the scene is by     default unlimited. The scene rect is used only for internal bookkeeping,     maintaining the scene's item index. If the scene rect is unset,     QGraphicsScene will use the bounding area of all items, as returned by     itemsBoundingRect(), as the scene rect. However, itemsBoundingRect() is a     relatively time consuming function, as it operates by collecting     positional information for every item on the scene. Because of this, you     should always set the scene rect when operating on large scenes.      One of QGraphicsScene's greatest strengths is its ability to efficiently     determine the location of items. Even with millions of items on the scene,     the items() functions can determine the location of an item within a few     milliseconds. There are several overloads to items(): one that finds items     at a certain position, one that finds items inside or intersecting with a     polygon or a rectangle, and more. The list of returned items is sorted by     stacking order, with the topmost item being the first item in the list.     For convenience, there is also an itemAt() function that returns the     topmost item at a given position.      QGraphicsScene maintains selection information for the scene. To select     items, call setSelectionArea(), and to clear the current selection, call     clearSelection(). Call selectedItems() to get the list of all selected     items.      \section1 Event Handling and Propagation      Another responsibility that QGraphicsScene has, is to propagate events     from QGraphicsView. To send an event to a scene, you construct an event     that inherits QEvent, and then send it using, for example,     QApplication::sendEvent(). event() is responsible for dispatching     the event to the individual items. Some common events are handled by     convenience event handlers. For example, key press events are handled by     keyPressEvent(), and mouse press events are handled by mousePressEvent().      Key events are delivered to the \e {focus item}. To set the focus item,     you can either call setFocusItem(), passing an item that accepts focus, or     the item itself can call QGraphicsItem::setFocus().  Call focusItem() to     get the current focus item. For compatibility with widgets, the scene also     maintains its own focus information. By default, the scene does not have     focus, and all key events are discarded. If setFocus() is called, or if an     item on the scene gains focus, the scene automatically gains focus. If the     scene has focus, hasFocus() will return true, and key events will be     forwarded to the focus item, if any. If the scene loses focus, (i.e.,     someone calls clearFocus()) while an item has focus, the scene will     maintain its item focus information, and once the scene regains focus, it     will make sure the last focus item regains focus.      For mouse-over effects, QGraphicsScene dispatches \e {hover     events}. If an item accepts hover events (see     QGraphicsItem::acceptHoverEvents()), it will receive a \l     {QEvent::}{GraphicsSceneHoverEnter} event when the mouse enters     its area. As the mouse continues moving inside the item's area,     QGraphicsScene will send it \l {QEvent::}{GraphicsSceneHoverMove}     events. When the mouse leaves the item's area, the item will     receive a \l {QEvent::}{GraphicsSceneHoverLeave} event.      All mouse events are delivered to the current \e {mouse grabber}     item. An item becomes the scene's mouse grabber if it accepts     mouse events (see QGraphicsItem::acceptedMouseButtons()) and it     receives a mouse press. It stays the mouse grabber until it     receives a mouse release when no other mouse buttons are     pressed. You can call mouseGrabberItem() to determine what item is     currently grabbing the mouse.      \sa QGraphicsItem, QGraphicsView */
end_comment
begin_comment
comment|/*!     \enum QGraphicsScene::SceneLayer     \since 4.3      This enum describes the rendering layers in a QGraphicsScene. When     QGraphicsScene draws the scene contents, it renders each of these layers     separately, in order.      Each layer represents a flag that can be OR'ed together when calling     functions such as invalidate() or QGraphicsView::invalidateScene().      \value ItemLayer The item layer. QGraphicsScene renders all items are in     this layer by calling the virtual function drawItems(). The item layer is     drawn after the background layer, but before the foreground layer.      \value BackgroundLayer The background layer. QGraphicsScene renders the     scene's background in this layer by calling the virtual function     drawBackground(). The background layer is drawn first of all layers.      \value ForegroundLayer The foreground layer. QGraphicsScene renders the     scene's foreground in this layer by calling the virtual function     drawForeground().  The foreground layer is drawn last of all layers.      \value AllLayers All layers; this value represents a combination of all     three layers.      \sa invalidate(), QGraphicsView::invalidateScene() */
end_comment
begin_comment
comment|/*!     \enum QGraphicsScene::ItemIndexMethod      This enum describes the indexing algorithms QGraphicsScene provides for     managing positional information about items on the scene.      \value BspTreeIndex A Binary Space Partitioning tree is applied. All     QGraphicsScene's item location algorithms are of an order close to     logarithmic complexity, by making use of binary search. Adding, moving and     removing items is logarithmic. This approach is best for static scenes     (i.e., scenes where most items do not move).      \value NoIndex No index is applied. Item location is of linear complexity,     as all items on the scene are searched. Adding, moving and removing items,     however, is done in constant time. This approach is ideal for dynamic     scenes, where many items are added, moved or removed continuously.      \sa setItemIndexMethod(), bspTreeDepth */
end_comment
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|"qgraphicsitem.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsitem_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicslayout.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsview.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsview_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneindex_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscenebsptreeindex_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscenelinearindex_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qrect.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qset.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstack.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QMetaMethod>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qevent.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicslayout.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicsproxywidget.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicswidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qmatrix.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpaintengine.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainter.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpolygon.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qtooltip.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qtransform.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicseffect.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicseffect_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgesturemanager_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpathclipper_p.h>
end_include
begin_comment
comment|// #define GESTURE_DEBUG
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|GESTURE_DEBUG
end_ifndef
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|if (0) qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|bool
name|qt_sendSpontaneousEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|_q_hoverFromMouseEvent
specifier|static
name|void
name|_q_hoverFromMouseEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|hover
parameter_list|,
specifier|const
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|hover
operator|->
name|setWidget
argument_list|(
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setPos
argument_list|(
name|mouseEvent
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setScenePos
argument_list|(
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setScreenPos
argument_list|(
name|mouseEvent
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setLastPos
argument_list|(
name|mouseEvent
operator|->
name|lastPos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setLastScenePos
argument_list|(
name|mouseEvent
operator|->
name|lastScenePos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setLastScreenPos
argument_list|(
name|mouseEvent
operator|->
name|lastScreenPos
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setModifiers
argument_list|(
name|mouseEvent
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|hover
operator|->
name|setAccepted
argument_list|(
name|mouseEvent
operator|->
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGraphicsScenePrivate
name|QGraphicsScenePrivate
operator|::
name|QGraphicsScenePrivate
parameter_list|()
member_init_list|:
name|indexMethod
argument_list|(
name|QGraphicsScene
operator|::
name|BspTreeIndex
argument_list|)
member_init_list|,
name|index
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastItemCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hasSceneRect
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dirtyGrowingItemsBoundingRect
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|updateAll
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|calledEmitUpdated
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|processDirtyItemsEmitted
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|needSortTopLevelItems
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|holesInTopLevelSiblingIndex
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|topLevelSequentialOrdering
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|scenePosDescendantsUpdatePending
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|stickyFocus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|hasFocus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|lastMouseGrabberItemHasImplicitMouseGrab
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|allItemsIgnoreHoverEvents
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|allItemsUseDefaultCursor
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|painterStateProtection
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|sortCacheEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|allItemsIgnoreTouchEvents
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|selectionChanging
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|rectAdjust
argument_list|(
literal|2
argument_list|)
member_init_list|,
name|focusItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastFocusItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|passiveFocusItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|tabFocusFirst
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|activePanel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastActivePanel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|activationRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|childExplicitActivation
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastMouseGrabberItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dragDropItem
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|enterWidget
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastDropAction
argument_list|(
name|Qt
operator|::
name|IgnoreAction
argument_list|)
member_init_list|,
name|style
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|init
name|void
name|QGraphicsScenePrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|index
operator|=
operator|new
name|QGraphicsSceneBspTreeIndex
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|// Keep this index so we can check for connected slots later on.
name|changedSignalIndex
operator|=
name|signalIndex
argument_list|(
literal|"changed(QList<QRectF>)"
argument_list|)
expr_stmt|;
name|processDirtyItemsIndex
operator|=
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfSlot
argument_list|(
literal|"_q_processDirtyItems()"
argument_list|)
expr_stmt|;
name|polishItemsIndex
operator|=
name|q
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfSlot
argument_list|(
literal|"_q_polishItems()"
argument_list|)
expr_stmt|;
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
operator|.
name|append
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|get
name|QGraphicsScenePrivate
modifier|*
name|QGraphicsScenePrivate
operator|::
name|get
parameter_list|(
name|QGraphicsScene
modifier|*
name|q
parameter_list|)
block|{
return|return
name|q
operator|->
name|d_func
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|_q_emitUpdated
name|void
name|QGraphicsScenePrivate
operator|::
name|_q_emitUpdated
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|calledEmitUpdated
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dirtyGrowingItemsBoundingRect
condition|)
block|{
if|if
condition|(
operator|!
name|hasSceneRect
condition|)
block|{
specifier|const
name|QRectF
name|oldGrowingItemsBoundingRect
init|=
name|growingItemsBoundingRect
decl_stmt|;
name|growingItemsBoundingRect
operator||=
name|q
operator|->
name|itemsBoundingRect
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldGrowingItemsBoundingRect
operator|!=
name|growingItemsBoundingRect
condition|)
emit|emit
name|q
operator|->
name|sceneRectChanged
argument_list|(
name|growingItemsBoundingRect
argument_list|)
emit|;
block|}
name|dirtyGrowingItemsBoundingRect
operator|=
literal|false
expr_stmt|;
block|}
comment|// Ensure all views are connected if anything is connected. This disables
comment|// the optimization that items send updates directly to the views, but it
comment|// needs to happen in order to keep compatibility with the behavior from
comment|// Qt 4.4 and backward.
if|if
condition|(
name|isSignalConnected
argument_list|(
name|changedSignalIndex
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsView
modifier|*
name|view
init|=
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|connectedToScene
condition|)
block|{
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|connectedToScene
operator|=
literal|true
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|changed
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|updateScene
argument_list|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|views
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|updateAll
operator|=
literal|false
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|processPendingUpdates
argument_list|()
expr_stmt|;
comment|// It's important that we update all views before we dispatch, hence two for-loops.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|dispatchPendingUpdateRequests
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Notify the changes to anybody interested.
name|QList
argument_list|<
name|QRectF
argument_list|>
name|oldUpdatedRects
decl_stmt|;
name|oldUpdatedRects
operator|=
name|updateAll
condition|?
operator|(
name|QList
argument_list|<
name|QRectF
argument_list|>
argument_list|()
operator|<<
name|q
operator|->
name|sceneRect
argument_list|()
operator|)
else|:
name|updatedRects
expr_stmt|;
name|updateAll
operator|=
literal|false
expr_stmt|;
name|updatedRects
operator|.
name|clear
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|changed
argument_list|(
name|oldUpdatedRects
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      ### This function is almost identical to QGraphicsItemPrivate::addChild(). */
end_comment
begin_function
DECL|function|registerTopLevelItem
name|void
name|QGraphicsScenePrivate
operator|::
name|registerTopLevelItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|ensureSequentialSiblingIndex
argument_list|()
expr_stmt|;
name|needSortTopLevelItems
operator|=
literal|true
expr_stmt|;
comment|// ### maybe false
name|item
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
name|topLevelItems
operator|.
name|size
argument_list|()
expr_stmt|;
name|topLevelItems
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      ### This function is almost identical to QGraphicsItemPrivate::removeChild(). */
end_comment
begin_function
DECL|function|unregisterTopLevelItem
name|void
name|QGraphicsScenePrivate
operator|::
name|unregisterTopLevelItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
operator|!
name|holesInTopLevelSiblingIndex
condition|)
name|holesInTopLevelSiblingIndex
operator|=
name|item
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|!=
name|topLevelItems
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|topLevelSequentialOrdering
operator|&&
operator|!
name|holesInTopLevelSiblingIndex
condition|)
name|topLevelItems
operator|.
name|removeAt
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|siblingIndex
argument_list|)
expr_stmt|;
else|else
name|topLevelItems
operator|.
name|removeOne
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// NB! Do not use topLevelItems.removeAt(item->d_ptr->siblingIndex) because
comment|// the item is not guaranteed to be at the index after the list is sorted
comment|// (see ensureSortedTopLevelItems()).
name|item
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|topLevelSequentialOrdering
condition|)
name|topLevelSequentialOrdering
operator|=
operator|!
name|holesInTopLevelSiblingIndex
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_polishItems
name|void
name|QGraphicsScenePrivate
operator|::
name|_q_polishItems
parameter_list|()
block|{
if|if
condition|(
name|unpolishedItems
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|QVariant
name|booleanTrueVariant
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|QGraphicsItem
modifier|*
name|item
init|=
literal|0
decl_stmt|;
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|oldUnpolishedCount
init|=
name|unpolishedItems
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldUnpolishedCount
condition|;
operator|++
name|i
control|)
block|{
name|item
operator|=
name|unpolishedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|itemd
operator|=
name|item
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
expr_stmt|;
name|itemd
operator|->
name|pendingPolish
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|itemd
operator|->
name|explicitlyHidden
condition|)
block|{
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemVisibleChange
argument_list|,
name|booleanTrueVariant
argument_list|)
expr_stmt|;
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemVisibleHasChanged
argument_list|,
name|booleanTrueVariant
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemd
operator|->
name|isWidget
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|Polish
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
operator|(
name|QGraphicsWidget
operator|*
operator|)
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unpolishedItems
operator|.
name|count
argument_list|()
operator|==
name|oldUnpolishedCount
condition|)
block|{
comment|// No new items were added to the vector.
name|unpolishedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// New items were appended; keep them and remove the old ones.
name|unpolishedItems
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|oldUnpolishedCount
argument_list|)
expr_stmt|;
name|unpolishedItems
operator|.
name|squeeze
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q_ptr
argument_list|,
literal|"_q_polishItems"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_processDirtyItems
name|void
name|QGraphicsScenePrivate
operator|::
name|_q_processDirtyItems
parameter_list|()
block|{
name|processDirtyItemsEmitted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|updateAll
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|calledEmitUpdated
argument_list|)
expr_stmt|;
comment|// No need for further processing (except resetting the dirty states).
comment|// The growingItemsBoundingRect is updated in _q_emitUpdated.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topLevelItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|resetDirtyItem
argument_list|(
name|topLevelItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
comment|/*recursive=*/
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|bool
name|wasPendingSceneUpdate
init|=
name|calledEmitUpdated
decl_stmt|;
specifier|const
name|QRectF
name|oldGrowingItemsBoundingRect
init|=
name|growingItemsBoundingRect
decl_stmt|;
comment|// Process items recursively.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topLevelItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|processDirtyItemsRecursive
argument_list|(
name|topLevelItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|dirtyGrowingItemsBoundingRect
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|hasSceneRect
operator|&&
name|oldGrowingItemsBoundingRect
operator|!=
name|growingItemsBoundingRect
condition|)
emit|emit
name|q_func
argument_list|()
operator|->
name|sceneRectChanged
argument_list|(
name|growingItemsBoundingRect
argument_list|)
emit|;
if|if
condition|(
name|wasPendingSceneUpdate
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|processPendingUpdates
argument_list|()
expr_stmt|;
if|if
condition|(
name|calledEmitUpdated
condition|)
block|{
comment|// We did a compatibility QGraphicsScene::update in processDirtyItemsRecursive
comment|// and we cannot wait for the control to reach the eventloop before the
comment|// changed signal is emitted, so we emit it now.
name|_q_emitUpdated
argument_list|()
expr_stmt|;
block|}
comment|// Immediately dispatch all pending update requests on the views.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|dispatchPendingUpdateRequests
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setScenePosItemEnabled
name|void
name|QGraphicsScenePrivate
operator|::
name|setScenePosItemEnabled
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|item
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|d_ptr
operator|->
name|scenePosDescendants
operator|=
name|enabled
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enabled
operator|&&
operator|!
name|scenePosDescendantsUpdatePending
condition|)
block|{
name|scenePosDescendantsUpdatePending
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q_func
argument_list|()
argument_list|,
literal|"_q_updateScenePosDescendants"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|registerScenePosItem
name|void
name|QGraphicsScenePrivate
operator|::
name|registerScenePosItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|scenePosItems
operator|.
name|insert
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|setScenePosItemEnabled
argument_list|(
name|item
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|unregisterScenePosItem
name|void
name|QGraphicsScenePrivate
operator|::
name|unregisterScenePosItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|scenePosItems
operator|.
name|remove
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|setScenePosItemEnabled
argument_list|(
name|item
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_updateScenePosDescendants
name|void
name|QGraphicsScenePrivate
operator|::
name|_q_updateScenePosDescendants
parameter_list|()
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|scenePosItems
control|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|item
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|d_ptr
operator|->
name|scenePosDescendants
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
block|}
name|scenePosDescendantsUpdatePending
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Schedules an item for removal. This function leaves some stale indexes     around in the BSP tree if called from the item's destructor; these will     be cleaned up the next time someone triggers purgeRemovedItems().      Note: This function might get called from QGraphicsItem's destructor. \a item is     being destroyed, so we cannot call any pure virtual functions on it (such     as boundingRect()). Also, it is unnecessary to update the item's own state     in any way. */
end_comment
begin_function
DECL|function|removeItemHelper
name|void
name|QGraphicsScenePrivate
operator|::
name|removeItemHelper
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Clear focus on the item to remove any reference in the focusWidget chain.
name|item
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
name|markDirty
argument_list|(
name|item
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|false
argument_list|,
comment|/*force=*/
literal|false
argument_list|,
comment|/*ignoreOpacity=*/
literal|false
argument_list|,
comment|/*removingItemFromScene=*/
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
condition|)
block|{
comment|// The item is actually in its destructor, we call the special method in the index.
name|index
operator|->
name|deleteItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Can potentially call item->boundingRect() (virtual function), that's why
comment|// we only can call this function if the item is not in its destructor.
name|index
operator|->
name|removeItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|d_ptr
operator|->
name|clearSubFocus
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
condition|)
name|unregisterScenePosItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|QGraphicsScene
modifier|*
name|oldScene
init|=
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|scene
decl_stmt|;
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|=
literal|0
expr_stmt|;
comment|//We need to remove all children first because they might use their parent
comment|//attributes (e.g. sceneTransform).
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
condition|)
block|{
comment|// Remove all children recursively
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|q
operator|->
name|removeItem
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
operator|&&
operator|!
name|item
operator|->
name|parentItem
argument_list|()
operator|&&
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|fixFocusChainBeforeReparenting
argument_list|(
literal|0
argument_list|,
name|oldScene
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Unregister focus proxy.
name|item
operator|->
name|d_ptr
operator|->
name|resetFocusProxy
argument_list|()
expr_stmt|;
comment|// Remove from parent, or unregister from toplevels.
if|if
condition|(
name|QGraphicsItem
modifier|*
name|parentItem
init|=
name|item
operator|->
name|parentItem
argument_list|()
condition|)
block|{
if|if
condition|(
name|parentItem
operator|->
name|scene
argument_list|()
condition|)
block|{
name|Q_ASSERT_X
argument_list|(
name|parentItem
operator|->
name|scene
argument_list|()
operator|==
name|q
argument_list|,
literal|"QGraphicsScene::removeItem"
argument_list|,
literal|"Parent item's scene is different from this item's scene"
argument_list|)
expr_stmt|;
name|item
operator|->
name|setParentItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unregisterTopLevelItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
comment|// Reset the mouse grabber and focus item data.
if|if
condition|(
name|item
operator|==
name|focusItem
condition|)
name|focusItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|lastFocusItem
condition|)
name|lastFocusItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|passiveFocusItem
condition|)
name|passiveFocusItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|activePanel
condition|)
block|{
comment|// ### deactivate...
name|activePanel
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|==
name|lastActivePanel
condition|)
name|lastActivePanel
operator|=
literal|0
expr_stmt|;
comment|// Change tabFocusFirst to the next widget in focus chain if removing the current one.
if|if
condition|(
name|item
operator|==
name|tabFocusFirst
condition|)
block|{
name|QGraphicsWidgetPrivate
modifier|*
name|wd
init|=
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
operator|->
name|focusNext
operator|&&
name|wd
operator|->
name|focusNext
operator|!=
name|tabFocusFirst
operator|&&
name|wd
operator|->
name|focusNext
operator|->
name|scene
argument_list|()
operator|==
name|q
condition|)
name|tabFocusFirst
operator|=
name|wd
operator|->
name|focusNext
expr_stmt|;
else|else
name|tabFocusFirst
operator|=
literal|0
expr_stmt|;
block|}
comment|// Cancel active touches
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|itemForTouchPointId
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|itemForTouchPointId
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|item
condition|)
block|{
name|sceneCurrentTouchPoints
operator|.
name|remove
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|itemForTouchPointId
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|it
expr_stmt|;
block|}
block|}
block|}
comment|// Disable selectionChanged() for individual items
operator|++
name|selectionChanging
expr_stmt|;
name|int
name|oldSelectedItemsSize
init|=
name|selectedItems
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Update selected& hovered item bookkeeping
name|selectedItems
operator|.
name|remove
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|hoverItems
operator|.
name|removeAll
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|cachedItemsUnderMouse
operator|.
name|removeAll
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|pendingPolish
condition|)
block|{
specifier|const
name|int
name|unpolishedIndex
init|=
name|unpolishedItems
operator|.
name|indexOf
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|unpolishedIndex
operator|!=
operator|-
literal|1
condition|)
name|unpolishedItems
index|[
name|unpolishedIndex
index|]
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|pendingPolish
operator|=
literal|false
expr_stmt|;
block|}
name|resetDirtyItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|//We remove all references of item from the sceneEventFilter arrays
name|QMultiMap
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|iterator
name|iterator
init|=
name|sceneEventFilters
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|!=
name|sceneEventFilters
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|iterator
operator|.
name|value
argument_list|()
operator|==
name|item
operator|||
name|iterator
operator|.
name|key
argument_list|()
operator|==
name|item
condition|)
name|iterator
operator|=
name|sceneEventFilters
operator|.
name|erase
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
else|else
operator|++
name|iterator
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
name|item
operator|->
name|panelModality
argument_list|()
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
name|leaveModal
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Reset the mouse grabber and focus item data.
if|if
condition|(
name|mouseGrabberItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
name|ungrabMouse
argument_list|(
name|item
argument_list|,
comment|/* item is dying */
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
argument_list|)
expr_stmt|;
comment|// Reset the keyboard grabber
if|if
condition|(
name|keyboardGrabberItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
name|ungrabKeyboard
argument_list|(
name|item
argument_list|,
comment|/* item is dying */
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
argument_list|)
expr_stmt|;
comment|// Reset the last mouse grabber item
if|if
condition|(
name|item
operator|==
name|lastMouseGrabberItem
condition|)
name|lastMouseGrabberItem
operator|=
literal|0
expr_stmt|;
comment|// Reset the current drop item
if|if
condition|(
name|item
operator|==
name|dragDropItem
condition|)
name|dragDropItem
operator|=
literal|0
expr_stmt|;
comment|// Reenable selectionChanged() for individual items
operator|--
name|selectionChanging
expr_stmt|;
if|if
condition|(
operator|!
name|selectionChanging
operator|&&
name|selectedItems
operator|.
name|size
argument_list|()
operator|!=
name|oldSelectedItemsSize
condition|)
emit|emit
name|q
operator|->
name|selectionChanged
argument_list|()
emit|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|QHash
argument_list|<
name|QGesture
modifier|*
argument_list|,
name|QGraphicsObject
modifier|*
argument_list|>
operator|::
name|iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|gestureTargets
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|gestureTargets
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|item
condition|)
name|it
operator|=
name|gestureTargets
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
name|QGraphicsObject
modifier|*
name|dummy
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|cachedTargetItems
operator|.
name|removeOne
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|cachedItemGestures
operator|.
name|remove
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|cachedAlreadyDeliveredGestures
operator|.
name|remove
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|gesture
decl|,
name|item
operator|->
name|d_ptr
operator|->
name|gestureContext
operator|.
name|keys
argument_list|()
control|)
name|ungrabGesture
argument_list|(
name|item
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_GESTURES
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setActivePanelHelper
name|void
name|QGraphicsScenePrivate
operator|::
name|setActivePanelHelper
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|duringActivationEvent
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|&&
name|item
operator|->
name|scene
argument_list|()
operator|!=
name|q
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::setActivePanel: item %p must be part of this scene"
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Ensure the scene has focus when we change panel activation.
name|q
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
expr_stmt|;
comment|// Find the item's panel.
name|QGraphicsItem
modifier|*
name|panel
init|=
name|item
condition|?
name|item
operator|->
name|panel
argument_list|()
else|:
literal|0
decl_stmt|;
name|lastActivePanel
operator|=
name|panel
condition|?
name|activePanel
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|panel
operator|==
name|activePanel
operator|||
operator|(
operator|!
name|q
operator|->
name|isActive
argument_list|()
operator|&&
operator|!
name|duringActivationEvent
operator|)
condition|)
return|return;
name|QGraphicsItem
modifier|*
name|oldFocusItem
init|=
name|focusItem
decl_stmt|;
comment|// Deactivate the last active panel.
if|if
condition|(
name|activePanel
condition|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|fi
init|=
name|activePanel
operator|->
name|focusItem
argument_list|()
condition|)
block|{
comment|// Remove focus from the current focus item.
if|if
condition|(
name|fi
operator|==
name|q
operator|->
name|focusItem
argument_list|()
condition|)
name|setFocusItemHelper
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|,
comment|/* emitFocusChanged = */
literal|false
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
name|q
operator|->
name|sendEvent
argument_list|(
name|activePanel
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|panel
operator|&&
operator|!
name|duringActivationEvent
condition|)
block|{
comment|// Deactivate the scene if changing activation to a panel.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|q
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
name|q
operator|->
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Update activate state.
name|activePanel
operator|=
name|panel
expr_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|ActivationChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
comment|// Activate
if|if
condition|(
name|panel
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
name|q
operator|->
name|sendEvent
argument_list|(
name|panel
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
comment|// Set focus on the panel's focus item, or itself if it's
comment|// focusable, or on the first focusable item in the panel's
comment|// focus chain as a last resort.
if|if
condition|(
name|QGraphicsItem
modifier|*
name|focusItem
init|=
name|panel
operator|->
name|focusItem
argument_list|()
condition|)
block|{
name|setFocusItemHelper
argument_list|(
name|focusItem
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|,
comment|/* emitFocusChanged = */
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|panel
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
condition|)
block|{
name|setFocusItemHelper
argument_list|(
name|panel
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|,
comment|/* emitFocusChanged = */
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|panel
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|fw
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|panel
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
decl_stmt|;
do|do
block|{
if|if
condition|(
name|fw
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|TabFocus
condition|)
block|{
name|setFocusItemHelper
argument_list|(
name|fw
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|,
comment|/* emitFocusChanged = */
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
name|fw
operator|=
name|fw
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
expr_stmt|;
block|}
do|while
condition|(
name|fw
operator|!=
name|panel
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|isActive
argument_list|()
condition|)
block|{
comment|// Activate the scene
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|q
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
name|q
operator|->
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
emit|emit
name|q
operator|->
name|focusItemChanged
argument_list|(
name|focusItem
argument_list|,
name|oldFocusItem
argument_list|,
name|Qt
operator|::
name|ActiveWindowFocusReason
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      \a emitFocusChanged needs to be false when focus passes from one     item to another through setActivePanel(); i.e. when activation     passes from one panel to another, to avoid getting two focusChanged()     emissions; one focusChanged(0, lastFocus), then one     focusChanged(newFocus, 0). Instead setActivePanel() emits the signal     once itself: focusChanged(newFocus, oldFocus). */
end_comment
begin_function
DECL|function|setFocusItemHelper
name|void
name|QGraphicsScenePrivate
operator|::
name|setFocusItemHelper
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|,
name|bool
name|emitFocusChanged
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|focusItem
condition|)
return|return;
comment|// Clear focus if asked to set focus on something that can't
comment|// accept input focus.
if|if
condition|(
name|item
operator|&&
operator|(
operator|!
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|)
operator|||
operator|!
name|item
operator|->
name|isVisible
argument_list|()
operator|||
operator|!
name|item
operator|->
name|isEnabled
argument_list|()
operator|)
condition|)
block|{
name|item
operator|=
literal|0
expr_stmt|;
block|}
comment|// Set focus on the scene if an item requests focus.
if|if
condition|(
name|item
condition|)
block|{
name|q
operator|->
name|setFocus
argument_list|(
name|focusReason
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|focusItem
condition|)
block|{
if|if
condition|(
name|emitFocusChanged
condition|)
emit|emit
name|q
operator|->
name|focusItemChanged
argument_list|(
name|focusItem
argument_list|,
operator|(
name|QGraphicsItem
operator|*
operator|)
literal|0
argument_list|,
name|focusReason
argument_list|)
emit|;
return|return;
block|}
block|}
name|QGraphicsItem
modifier|*
name|oldFocusItem
init|=
name|focusItem
decl_stmt|;
if|if
condition|(
name|focusItem
condition|)
block|{
name|lastFocusItem
operator|=
name|focusItem
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_IM
if|if
condition|(
name|lastFocusItem
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
condition|)
block|{
comment|// Close any external input method panel. This happens
comment|// automatically by removing WA_InputMethodEnabled on
comment|// the views, but if we are changing focus, we have to
comment|// do it ourselves.
if|if
condition|(
name|qApp
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|commit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_IM
name|focusItem
operator|=
literal|0
expr_stmt|;
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|focusReason
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|lastFocusItem
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|// This handles the case that the item has been removed from the
comment|// scene in response to the FocusOut event.
if|if
condition|(
name|item
operator|&&
name|item
operator|->
name|scene
argument_list|()
operator|!=
name|q
condition|)
name|item
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item
condition|)
name|focusItem
operator|=
name|item
expr_stmt|;
name|updateInputMethodSensitivityInViews
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|focusReason
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emitFocusChanged
condition|)
emit|emit
name|q
operator|->
name|focusItemChanged
argument_list|(
name|focusItem
argument_list|,
name|oldFocusItem
argument_list|,
name|focusReason
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|addPopup
name|void
name|QGraphicsScenePrivate
operator|::
name|addPopup
parameter_list|(
name|QGraphicsWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|popupWidgets
operator|.
name|contains
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
name|popupWidgets
operator|<<
name|widget
expr_stmt|;
if|if
condition|(
name|QGraphicsWidget
modifier|*
name|focusWidget
init|=
name|widget
operator|->
name|focusWidget
argument_list|()
condition|)
block|{
name|focusWidget
operator|->
name|setFocus
argument_list|(
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|grabKeyboard
argument_list|(
operator|(
name|QGraphicsItem
operator|*
operator|)
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|focusItem
operator|&&
name|popupWidgets
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusOut
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|focusItem
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
name|grabMouse
argument_list|(
operator|(
name|QGraphicsItem
operator|*
operator|)
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Remove \a widget from the popup list. Important notes:      \a widget is guaranteed to be in the list of popups, but it might not be     the last entry; you can hide any item in the pop list before the others,     and this must cause all later mouse grabbers to lose the grab. */
end_comment
begin_function
DECL|function|removePopup
name|void
name|QGraphicsScenePrivate
operator|::
name|removePopup
parameter_list|(
name|QGraphicsWidget
modifier|*
name|widget
parameter_list|,
name|bool
name|itemIsDying
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|popupWidgets
operator|.
name|indexOf
argument_list|(
name|widget
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|popupWidgets
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|index
condition|;
operator|--
name|i
control|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
name|popupWidgets
operator|.
name|takeLast
argument_list|()
decl_stmt|;
name|ungrabMouse
argument_list|(
name|widget
argument_list|,
name|itemIsDying
argument_list|)
expr_stmt|;
if|if
condition|(
name|focusItem
operator|&&
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|Qt
operator|::
name|PopupFocusReason
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|focusItem
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyboardGrabberItems
operator|.
name|contains
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
argument_list|)
condition|)
block|{
name|ungrabKeyboard
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
argument_list|,
name|itemIsDying
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|itemIsDying
operator|&&
name|widget
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|widget
operator|->
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|setVisibleHelper
argument_list|(
literal|false
argument_list|,
comment|/* explicit = */
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|grabMouse
name|void
name|QGraphicsScenePrivate
operator|::
name|grabMouse
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|implicit
parameter_list|)
block|{
comment|// Append to list of mouse grabber items, and send a mouse grab event.
if|if
condition|(
name|mouseGrabberItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
if|if
condition|(
name|mouseGrabberItems
operator|.
name|last
argument_list|()
operator|==
name|item
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|implicit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabMouse: already a mouse grabber"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Upgrade to an explicit mouse grab
name|lastMouseGrabberItemHasImplicitMouseGrab
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabMouse: already blocked by mouse grabber: %p"
argument_list|,
name|mouseGrabberItems
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Send ungrab event to the last grabber.
if|if
condition|(
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|last
init|=
name|mouseGrabberItems
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
block|{
comment|// Implicit mouse grab is immediately lost.
name|last
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Just send ungrab event to current grabber.
name|QEvent
name|ungrabEvent
argument_list|(
name|QEvent
operator|::
name|UngrabMouse
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|last
argument_list|,
operator|&
name|ungrabEvent
argument_list|)
expr_stmt|;
block|}
block|}
name|mouseGrabberItems
operator|<<
name|item
expr_stmt|;
name|lastMouseGrabberItemHasImplicitMouseGrab
operator|=
name|implicit
expr_stmt|;
comment|// Send grab event to current grabber.
name|QEvent
name|grabEvent
argument_list|(
name|QEvent
operator|::
name|GrabMouse
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|grabEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|ungrabMouse
name|void
name|QGraphicsScenePrivate
operator|::
name|ungrabMouse
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|itemIsDying
parameter_list|)
block|{
name|int
name|index
init|=
name|mouseGrabberItems
operator|.
name|indexOf
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::ungrabMouse: not a mouse grabber"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
operator|!=
name|mouseGrabberItems
operator|.
name|last
argument_list|()
condition|)
block|{
comment|// Recursively ungrab the next mouse grabber until we reach this item
comment|// to ensure state consistency.
name|ungrabMouse
argument_list|(
name|mouseGrabberItems
operator|.
name|at
argument_list|(
name|index
operator|+
literal|1
argument_list|)
argument_list|,
name|itemIsDying
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
operator|&&
name|item
operator|==
name|popupWidgets
operator|.
name|last
argument_list|()
condition|)
block|{
comment|// If the item is a popup, go via removePopup to ensure state
comment|// consistency and that it gets hidden correctly - beware that
comment|// removePopup() reenters this function to continue removing the grab.
name|removePopup
argument_list|(
operator|(
name|QGraphicsWidget
operator|*
operator|)
name|item
argument_list|,
name|itemIsDying
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Send notification about mouse ungrab.
if|if
condition|(
operator|!
name|itemIsDying
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|UngrabMouse
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|// Remove the item from the list of grabbers. Whenever this happens, we
comment|// reset the implicitGrab (there can be only ever be one implicit grabber
comment|// in a scene, and it is always the latest grabber; if the implicit grab
comment|// is lost, it is not automatically regained.
name|mouseGrabberItems
operator|.
name|takeLast
argument_list|()
expr_stmt|;
name|lastMouseGrabberItemHasImplicitMouseGrab
operator|=
literal|false
expr_stmt|;
comment|// Send notification about mouse regrab. ### It's unfortunate that all the
comment|// items get a GrabMouse event, but this is a rare case with a simple
comment|// implementation and it does ensure a consistent state.
if|if
condition|(
operator|!
name|itemIsDying
operator|&&
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|last
init|=
name|mouseGrabberItems
operator|.
name|last
argument_list|()
decl_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|GrabMouse
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|last
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|clearMouseGrabber
name|void
name|QGraphicsScenePrivate
operator|::
name|clearMouseGrabber
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|mouseGrabberItems
operator|.
name|first
argument_list|()
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
name|lastMouseGrabberItem
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|grabKeyboard
name|void
name|QGraphicsScenePrivate
operator|::
name|grabKeyboard
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
name|keyboardGrabberItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
block|{
if|if
condition|(
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
operator|==
name|item
condition|)
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabKeyboard: already a keyboard grabber"
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabKeyboard: already blocked by keyboard grabber: %p"
argument_list|,
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Send ungrab event to the last grabber.
if|if
condition|(
operator|!
name|keyboardGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Just send ungrab event to current grabber.
name|QEvent
name|ungrabEvent
argument_list|(
name|QEvent
operator|::
name|UngrabKeyboard
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
argument_list|,
operator|&
name|ungrabEvent
argument_list|)
expr_stmt|;
block|}
name|keyboardGrabberItems
operator|<<
name|item
expr_stmt|;
comment|// Send grab event to current grabber.
name|QEvent
name|grabEvent
argument_list|(
name|QEvent
operator|::
name|GrabKeyboard
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|grabEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|ungrabKeyboard
name|void
name|QGraphicsScenePrivate
operator|::
name|ungrabKeyboard
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|itemIsDying
parameter_list|)
block|{
name|int
name|index
init|=
name|keyboardGrabberItems
operator|.
name|lastIndexOf
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::ungrabKeyboard: not a keyboard grabber"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
operator|!=
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
condition|)
block|{
comment|// Recursively ungrab the topmost keyboard grabber until we reach this
comment|// item to ensure state consistency.
name|ungrabKeyboard
argument_list|(
name|keyboardGrabberItems
operator|.
name|at
argument_list|(
name|index
operator|+
literal|1
argument_list|)
argument_list|,
name|itemIsDying
argument_list|)
expr_stmt|;
block|}
comment|// Send notification about keyboard ungrab.
if|if
condition|(
operator|!
name|itemIsDying
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|UngrabKeyboard
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|// Remove the item from the list of grabbers.
name|keyboardGrabberItems
operator|.
name|takeLast
argument_list|()
expr_stmt|;
comment|// Send notification about mouse regrab.
if|if
condition|(
operator|!
name|itemIsDying
operator|&&
operator|!
name|keyboardGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|last
init|=
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
decl_stmt|;
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|GrabKeyboard
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|last
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|clearKeyboardGrabber
name|void
name|QGraphicsScenePrivate
operator|::
name|clearKeyboardGrabber
parameter_list|()
block|{
if|if
condition|(
operator|!
name|keyboardGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|ungrabKeyboard
argument_list|(
name|keyboardGrabberItems
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|enableMouseTrackingOnViews
name|void
name|QGraphicsScenePrivate
operator|::
name|enableMouseTrackingOnViews
parameter_list|()
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns all items for the screen position in \a event. */
end_comment
begin_function
DECL|function|itemsAtPosition
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScenePrivate
operator|::
name|itemsAtPosition
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|screenPos
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|scenePos
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QGraphicsView
modifier|*
name|view
init|=
name|widget
condition|?
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|parentWidget
argument_list|()
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|view
condition|)
return|return
name|q
operator|->
name|items
argument_list|(
name|scenePos
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|QTransform
argument_list|()
argument_list|)
return|;
specifier|const
name|QRectF
name|pointRect
argument_list|(
name|QPointF
argument_list|(
name|widget
operator|->
name|mapFromGlobal
argument_list|(
name|screenPos
argument_list|)
argument_list|)
argument_list|,
name|QSizeF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|view
operator|->
name|isTransformed
argument_list|()
condition|)
return|return
name|q
operator|->
name|items
argument_list|(
name|pointRect
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|)
return|;
specifier|const
name|QTransform
name|viewTransform
init|=
name|view
operator|->
name|viewportTransform
argument_list|()
decl_stmt|;
if|if
condition|(
name|viewTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
return|return
name|q
operator|->
name|items
argument_list|(
name|viewTransform
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|pointRect
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewTransform
argument_list|)
return|;
block|}
return|return
name|q
operator|->
name|items
argument_list|(
name|viewTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|pointRect
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|viewTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|storeMouseButtonsForMouseGrabber
name|void
name|QGraphicsScenePrivate
operator|::
name|storeMouseButtonsForMouseGrabber
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0x1
init|;
name|i
operator|<=
literal|0x10
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|i
condition|)
block|{
name|mouseGrabberButtonDownPos
operator|.
name|insert
argument_list|(
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
argument_list|,
name|mouseGrabberItems
operator|.
name|last
argument_list|()
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|event
operator|->
name|scenePos
argument_list|()
argument_list|,
name|event
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseGrabberButtonDownScenePos
operator|.
name|insert
argument_list|(
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
argument_list|,
name|event
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|mouseGrabberButtonDownScreenPos
operator|.
name|insert
argument_list|(
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
argument_list|,
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|installSceneEventFilter
name|void
name|QGraphicsScenePrivate
operator|::
name|installSceneEventFilter
parameter_list|(
name|QGraphicsItem
modifier|*
name|watched
parameter_list|,
name|QGraphicsItem
modifier|*
name|filter
parameter_list|)
block|{
name|sceneEventFilters
operator|.
name|insert
argument_list|(
name|watched
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|removeSceneEventFilter
name|void
name|QGraphicsScenePrivate
operator|::
name|removeSceneEventFilter
parameter_list|(
name|QGraphicsItem
modifier|*
name|watched
parameter_list|,
name|QGraphicsItem
modifier|*
name|filter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sceneEventFilters
operator|.
name|contains
argument_list|(
name|watched
argument_list|)
condition|)
return|return;
name|QMultiMap
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|sceneEventFilters
operator|.
name|lowerBound
argument_list|(
name|watched
argument_list|)
decl_stmt|;
name|QMultiMap
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|Iterator
name|end
init|=
name|sceneEventFilters
operator|.
name|upperBound
argument_list|(
name|watched
argument_list|)
decl_stmt|;
do|do
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|filter
condition|)
name|it
operator|=
name|sceneEventFilters
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
do|while
condition|(
name|it
operator|!=
name|end
condition|)
do|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|filterDescendantEvent
name|bool
name|QGraphicsScenePrivate
operator|::
name|filterDescendantEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|item
operator|&&
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorFiltersChildEvents
operator|)
condition|)
block|{
name|QGraphicsItem
modifier|*
name|parent
init|=
name|item
operator|->
name|parentItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|filtersDescendantEvents
operator|&&
name|parent
operator|->
name|sceneEventFilter
argument_list|(
name|item
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorFiltersChildEvents
operator|)
condition|)
return|return
literal|false
return|;
name|parent
operator|=
name|parent
operator|->
name|parentItem
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|filterEvent
name|bool
name|QGraphicsScenePrivate
operator|::
name|filterEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|item
operator|&&
operator|!
name|sceneEventFilters
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
return|return
literal|false
return|;
name|QMultiMap
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|sceneEventFilters
operator|.
name|lowerBound
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|QMultiMap
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QGraphicsItem
modifier|*
argument_list|>
operator|::
name|Iterator
name|end
init|=
name|sceneEventFilters
operator|.
name|upperBound
argument_list|(
name|item
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
comment|// ### The filterer and filteree might both be deleted.
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|->
name|sceneEventFilter
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
operator|++
name|it
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      This is the final dispatch point for any events from the scene to the     item. It filters the event first - if the filter returns true, the event     is considered to have been eaten by the filter, and is therefore stopped     (the default filter returns false). Then/otherwise, if the item is     enabled, the event is sent; otherwise it is stopped. */
end_comment
begin_function
DECL|function|sendEvent
name|bool
name|QGraphicsScenePrivate
operator|::
name|sendEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|QGraphicsObject
modifier|*
name|object
init|=
name|item
operator|->
name|toGraphicsObject
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
name|QGestureManager
modifier|*
name|gestureManager
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|gestureManager
decl_stmt|;
if|if
condition|(
name|gestureManager
condition|)
block|{
if|if
condition|(
name|gestureManager
operator|->
name|filterEvent
argument_list|(
name|object
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_GESTURES
block|}
if|if
condition|(
name|filterEvent
argument_list|(
name|item
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|filterDescendantEvent
argument_list|(
name|item
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|item
operator|||
operator|!
name|item
operator|->
name|isEnabled
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QGraphicsObject
modifier|*
name|o
init|=
name|item
operator|->
name|toGraphicsObject
argument_list|()
condition|)
block|{
name|bool
name|spont
init|=
name|event
operator|->
name|spontaneous
argument_list|()
decl_stmt|;
if|if
condition|(
name|spont
condition|?
name|qt_sendSpontaneousEvent
argument_list|(
name|o
argument_list|,
name|event
argument_list|)
else|:
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|o
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
name|event
operator|->
name|spont
operator|=
name|spont
expr_stmt|;
block|}
return|return
name|item
operator|->
name|sceneEvent
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|cloneDragDropEvent
name|void
name|QGraphicsScenePrivate
operator|::
name|cloneDragDropEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|dest
parameter_list|,
name|QGraphicsSceneDragDropEvent
modifier|*
name|source
parameter_list|)
block|{
name|dest
operator|->
name|setWidget
argument_list|(
name|source
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setPos
argument_list|(
name|source
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setScenePos
argument_list|(
name|source
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setScreenPos
argument_list|(
name|source
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setButtons
argument_list|(
name|source
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setModifiers
argument_list|(
name|source
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setPossibleActions
argument_list|(
name|source
operator|->
name|possibleActions
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setProposedAction
argument_list|(
name|source
operator|->
name|proposedAction
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setDropAction
argument_list|(
name|source
operator|->
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setSource
argument_list|(
name|source
operator|->
name|source
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|->
name|setMimeData
argument_list|(
name|source
operator|->
name|mimeData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sendDragDropEvent
name|void
name|QGraphicsScenePrivate
operator|::
name|sendDragDropEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QGraphicsSceneDragDropEvent
modifier|*
name|dragDropEvent
parameter_list|)
block|{
name|dragDropEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|dragDropEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|dragDropEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
name|dragDropEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sendHoverEvent
name|void
name|QGraphicsScenePrivate
operator|::
name|sendHoverEvent
parameter_list|(
name|QEvent
operator|::
name|Type
name|type
parameter_list|,
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QGraphicsSceneHoverEvent
modifier|*
name|hoverEvent
parameter_list|)
block|{
name|QGraphicsSceneHoverEvent
name|event
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|event
operator|.
name|setWidget
argument_list|(
name|hoverEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|hoverEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|hoverEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|setScenePos
argument_list|(
name|hoverEvent
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setScreenPos
argument_list|(
name|hoverEvent
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setLastPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|hoverEvent
operator|->
name|lastScenePos
argument_list|()
argument_list|,
name|hoverEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|setLastScenePos
argument_list|(
name|hoverEvent
operator|->
name|lastScenePos
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setLastScreenPos
argument_list|(
name|hoverEvent
operator|->
name|lastScreenPos
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setModifiers
argument_list|(
name|hoverEvent
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sendMouseEvent
name|void
name|QGraphicsScenePrivate
operator|::
name|sendMouseEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
if|if
condition|(
name|mouseEvent
operator|->
name|button
argument_list|()
operator|==
literal|0
operator|&&
name|mouseEvent
operator|->
name|buttons
argument_list|()
operator|==
literal|0
operator|&&
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
block|{
comment|// ### This is a temporary fix for until we get proper mouse
comment|// grab events.
name|clearMouseGrabber
argument_list|()
expr_stmt|;
return|return;
block|}
name|QGraphicsItem
modifier|*
name|item
init|=
name|mouseGrabberItems
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0x1
init|;
name|i
operator|<=
literal|0x10
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|mouseEvent
operator|->
name|setButtonDownPos
argument_list|(
name|button
argument_list|,
name|mouseGrabberButtonDownPos
operator|.
name|value
argument_list|(
name|button
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setButtonDownScenePos
argument_list|(
name|button
argument_list|,
name|mouseGrabberButtonDownScenePos
operator|.
name|value
argument_list|(
name|button
argument_list|,
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setButtonDownScreenPos
argument_list|(
name|button
argument_list|,
name|mouseGrabberButtonDownScreenPos
operator|.
name|value
argument_list|(
name|button
argument_list|,
name|mouseEvent
operator|->
name|screenPos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mouseEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setLastPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|mouseEvent
operator|->
name|lastScenePos
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
name|mouseEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mousePressEventHandler
name|void
name|QGraphicsScenePrivate
operator|::
name|mousePressEventHandler
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Ignore by default, unless we find a mouse grabber that accepts it.
name|mouseEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
comment|// Deliver to any existing mouse grabber.
if|if
condition|(
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|mouseGrabberItems
operator|.
name|last
argument_list|()
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
return|return;
comment|// The event is ignored by default, but we disregard the event's
comment|// accepted state after delivery; the mouse is grabbed, after all.
name|sendMouseEvent
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Start by determining the number of items at the current position.
comment|// Reuse value from earlier calculations if possible.
if|if
condition|(
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cachedItemsUnderMouse
operator|=
name|itemsAtPosition
argument_list|(
name|mouseEvent
operator|->
name|screenPos
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Update window activation.
name|QGraphicsItem
modifier|*
name|topItem
init|=
name|cachedItemsUnderMouse
operator|.
name|value
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QGraphicsWidget
modifier|*
name|newActiveWindow
init|=
name|topItem
condition|?
name|topItem
operator|->
name|window
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|newActiveWindow
operator|&&
name|newActiveWindow
operator|->
name|isBlockedByModalPanel
argument_list|(
operator|&
name|topItem
argument_list|)
condition|)
block|{
comment|// pass activation to the blocking modal window
name|newActiveWindow
operator|=
name|topItem
condition|?
name|topItem
operator|->
name|window
argument_list|()
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|newActiveWindow
operator|!=
name|q
operator|->
name|activeWindow
argument_list|()
condition|)
name|q
operator|->
name|setActiveWindow
argument_list|(
name|newActiveWindow
argument_list|)
expr_stmt|;
comment|// Set focus on the topmost enabled item that can take focus.
name|bool
name|setFocus
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|cachedItemsUnderMouse
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
operator|||
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStopsFocusHandling
operator|)
condition|)
block|{
comment|// Make sure we don't clear focus.
name|setFocus
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|item
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isWidget
argument_list|()
operator|||
operator|(
operator|(
name|QGraphicsWidget
operator|*
operator|)
name|item
operator|)
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|ClickFocus
condition|)
block|{
name|setFocus
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|q
operator|->
name|focusItem
argument_list|()
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|mouseSetsFocus
condition|)
name|q
operator|->
name|setFocusItem
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
condition|)
break|break;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStopsClickFocusPropagation
condition|)
break|break;
block|}
comment|// Check for scene modality.
name|bool
name|sceneModality
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modalPanels
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|modalPanels
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|panelModality
argument_list|()
operator|==
name|QGraphicsItem
operator|::
name|SceneModal
condition|)
block|{
name|sceneModality
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If nobody could take focus, clear it.
if|if
condition|(
operator|!
name|stickyFocus
operator|&&
operator|!
name|setFocus
operator|&&
operator|!
name|sceneModality
condition|)
name|q
operator|->
name|setFocusItem
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
comment|// Any item will do.
if|if
condition|(
name|sceneModality
operator|&&
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
condition|)
name|cachedItemsUnderMouse
operator|<<
name|modalPanels
operator|.
name|first
argument_list|()
expr_stmt|;
comment|// Find a mouse grabber by sending mouse press events to all mouse grabber
comment|// candidates one at a time, until the event is accepted. It's accepted by
comment|// default, so the receiver has to explicitly ignore it for it to pass
comment|// through.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|cachedItemsUnderMouse
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|acceptedMouseButtons
argument_list|()
operator|&
name|mouseEvent
operator|->
name|button
argument_list|()
operator|)
condition|)
block|{
comment|// Skip items that don't accept the event's mouse button.
continue|continue;
block|}
comment|// Check if this item is blocked by a modal panel and deliver the mouse event to the
comment|// blocking panel instead of this item if blocked.
operator|(
name|void
operator|)
name|item
operator|->
name|isBlockedByModalPanel
argument_list|(
operator|&
name|item
argument_list|)
expr_stmt|;
name|grabMouse
argument_list|(
name|item
argument_list|,
comment|/* implicit = */
literal|true
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// check if the item we are sending to are disabled (before we send the event)
name|bool
name|disabled
init|=
operator|!
name|item
operator|->
name|isEnabled
argument_list|()
decl_stmt|;
name|bool
name|isPanel
init|=
name|item
operator|->
name|isPanel
argument_list|()
decl_stmt|;
if|if
condition|(
name|mouseEvent
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
operator|&&
name|item
operator|!=
name|lastMouseGrabberItem
operator|&&
name|lastMouseGrabberItem
condition|)
block|{
comment|// If this item is different from the item that received the last
comment|// mouse event, and mouseEvent is a doubleclick event, then the
comment|// event is converted to a press. Known limitation:
comment|// Triple-clicking will not generate a doubleclick, though.
name|QGraphicsSceneMouseEvent
name|mousePress
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneMousePress
argument_list|)
decl_stmt|;
name|mousePress
operator|.
name|spont
operator|=
name|mouseEvent
operator|->
name|spont
expr_stmt|;
name|mousePress
operator|.
name|accept
argument_list|()
expr_stmt|;
name|mousePress
operator|.
name|setButton
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setButtons
argument_list|(
name|mouseEvent
operator|->
name|buttons
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setScreenPos
argument_list|(
name|mouseEvent
operator|->
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setScenePos
argument_list|(
name|mouseEvent
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setModifiers
argument_list|(
name|mouseEvent
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setWidget
argument_list|(
name|mouseEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setButtonDownPos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|buttonDownPos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setButtonDownScenePos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|buttonDownScenePos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mousePress
operator|.
name|setButtonDownScreenPos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|,
name|mouseEvent
operator|->
name|buttonDownScreenPos
argument_list|(
name|mouseEvent
operator|->
name|button
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sendMouseEvent
argument_list|(
operator|&
name|mousePress
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setAccepted
argument_list|(
name|mousePress
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sendMouseEvent
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
block|}
name|bool
name|dontSendUngrabEvents
init|=
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
operator|||
name|mouseGrabberItems
operator|.
name|last
argument_list|()
operator|!=
name|item
decl_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
name|ungrabMouse
argument_list|(
name|item
argument_list|,
comment|/* itemIsDying = */
name|dontSendUngrabEvents
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mouseEvent
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|storeMouseButtonsForMouseGrabber
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
name|lastMouseGrabberItem
operator|=
name|item
expr_stmt|;
return|return;
block|}
name|ungrabMouse
argument_list|(
name|item
argument_list|,
comment|/* itemIsDying = */
name|dontSendUngrabEvents
argument_list|)
expr_stmt|;
comment|// Don't propagate through panels.
if|if
condition|(
name|isPanel
condition|)
break|break;
block|}
comment|// Is the event still ignored? Then the mouse press goes to the scene.
comment|// Reset the mouse grabber, clear the selection, clear focus, and leave
comment|// the event ignored so that it can propagate through the originating
comment|// view.
if|if
condition|(
operator|!
name|mouseEvent
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
name|clearMouseGrabber
argument_list|()
expr_stmt|;
name|QGraphicsView
modifier|*
name|view
init|=
name|mouseEvent
operator|->
name|widget
argument_list|()
condition|?
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|mouseEvent
operator|->
name|widget
argument_list|()
operator|->
name|parentWidget
argument_list|()
argument_list|)
else|:
literal|0
decl_stmt|;
name|bool
name|dontClearSelection
init|=
name|view
operator|&&
name|view
operator|->
name|dragMode
argument_list|()
operator|==
name|QGraphicsView
operator|::
name|ScrollHandDrag
decl_stmt|;
if|if
condition|(
operator|!
name|dontClearSelection
condition|)
block|{
comment|// Clear the selection if the originating view isn't in scroll
comment|// hand drag mode. The view will clear the selection if no drag
comment|// happened.
name|q
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Ensures that the list of toplevels is sorted by insertion order, and that     the siblingIndexes are packed (no gaps), and start at 0.      ### This function is almost identical to     QGraphicsItemPrivate::ensureSequentialSiblingIndex(). */
end_comment
begin_function
DECL|function|ensureSequentialTopLevelSiblingIndexes
name|void
name|QGraphicsScenePrivate
operator|::
name|ensureSequentialTopLevelSiblingIndexes
parameter_list|()
block|{
if|if
condition|(
operator|!
name|topLevelSequentialOrdering
condition|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|topLevelItems
operator|.
name|begin
argument_list|()
argument_list|,
name|topLevelItems
operator|.
name|end
argument_list|()
argument_list|,
name|QGraphicsItemPrivate
operator|::
name|insertionOrder
argument_list|)
expr_stmt|;
name|topLevelSequentialOrdering
operator|=
literal|true
expr_stmt|;
name|needSortTopLevelItems
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|holesInTopLevelSiblingIndex
condition|)
block|{
name|holesInTopLevelSiblingIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topLevelItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|topLevelItems
index|[
name|i
index|]
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Set the font and propagate the changes if the font is different from the     current font. */
end_comment
begin_function
DECL|function|setFont_helper
name|void
name|QGraphicsScenePrivate
operator|::
name|setFont_helper
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|font
operator|==
name|font
operator|&&
name|this
operator|->
name|font
operator|.
name|resolve
argument_list|()
operator|==
name|font
operator|.
name|resolve
argument_list|()
condition|)
return|return;
name|updateFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Resolve the scene's font against the application font, and propagate the     changes too all items in the scene. */
end_comment
begin_function
DECL|function|resolveFont
name|void
name|QGraphicsScenePrivate
operator|::
name|resolveFont
parameter_list|()
block|{
name|QFont
name|naturalFont
init|=
name|QApplication
operator|::
name|font
argument_list|()
decl_stmt|;
name|naturalFont
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QFont
name|resolvedFont
init|=
name|font
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
decl_stmt|;
name|updateFont
argument_list|(
name|resolvedFont
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Update the font, and whether or not it has changed, reresolve all fonts in     the scene. */
end_comment
begin_function
DECL|function|updateFont
name|void
name|QGraphicsScenePrivate
operator|::
name|updateFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Update local font setting.
name|this
operator|->
name|font
operator|=
name|font
expr_stmt|;
comment|// Resolve the fonts of all top-level widget items, or widget items
comment|// whose parent is not a widget.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|q
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
block|{
comment|// Resolvefont for an item is a noop operation, but
comment|// every item can be a widget, or can have a widget
comment|// childre.
name|item
operator|->
name|d_ptr
operator|->
name|resolveFont
argument_list|(
name|font
operator|.
name|resolve
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send the scene a FontChange event.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FontChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Set the palette and propagate the changes if the palette is different from     the current palette. */
end_comment
begin_function
DECL|function|setPalette_helper
name|void
name|QGraphicsScenePrivate
operator|::
name|setPalette_helper
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
if|if
condition|(
name|this
operator|->
name|palette
operator|==
name|palette
operator|&&
name|this
operator|->
name|palette
operator|.
name|resolve
argument_list|()
operator|==
name|palette
operator|.
name|resolve
argument_list|()
condition|)
return|return;
name|updatePalette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Resolve the scene's palette against the application palette, and propagate     the changes too all items in the scene. */
end_comment
begin_function
DECL|function|resolvePalette
name|void
name|QGraphicsScenePrivate
operator|::
name|resolvePalette
parameter_list|()
block|{
name|QPalette
name|naturalPalette
init|=
name|QApplication
operator|::
name|palette
argument_list|()
decl_stmt|;
name|naturalPalette
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPalette
name|resolvedPalette
init|=
name|palette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
decl_stmt|;
name|updatePalette
argument_list|(
name|resolvedPalette
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Update the palette, and whether or not it has changed, reresolve all     palettes in the scene. */
end_comment
begin_function
DECL|function|updatePalette
name|void
name|QGraphicsScenePrivate
operator|::
name|updatePalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Update local palette setting.
name|this
operator|->
name|palette
operator|=
name|palette
expr_stmt|;
comment|// Resolve the palettes of all top-level widget items, or widget items
comment|// whose parent is not a widget.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|q
operator|->
name|items
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
block|{
comment|// Resolvefont for an item is a noop operation, but
comment|// every item can be a widget, or can have a widget
comment|// childre.
name|item
operator|->
name|d_ptr
operator|->
name|resolvePalette
argument_list|(
name|palette
operator|.
name|resolve
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Send the scene a PaletteChange event.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|PaletteChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QGraphicsScene object. The \a parent parameter is     passed to QObject's constructor. */
end_comment
begin_constructor
DECL|function|QGraphicsScene
name|QGraphicsScene
operator|::
name|QGraphicsScene
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QGraphicsScenePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsScene object, using \a sceneRect for its     scene rectangle. The \a parent parameter is passed to QObject's     constructor.      \sa sceneRect */
end_comment
begin_constructor
DECL|function|QGraphicsScene
name|QGraphicsScene
operator|::
name|QGraphicsScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|sceneRect
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QGraphicsScenePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
name|setSceneRect
argument_list|(
name|sceneRect
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsScene object, using the rectangle specified     by (\a x, \a y), and the given \a width and \a height for its     scene rectangle. The \a parent parameter is passed to QObject's     constructor.      \sa sceneRect */
end_comment
begin_constructor
DECL|function|QGraphicsScene
name|QGraphicsScene
operator|::
name|QGraphicsScene
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
name|width
parameter_list|,
name|qreal
name|height
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QGraphicsScenePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
name|setSceneRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Removes and deletes all items from the scene object   before destroying the scene object. The scene object   is removed from the application's global scene list,   and it is removed from all associated views. */
end_comment
begin_destructor
DECL|function|~QGraphicsScene
name|QGraphicsScene
operator|::
name|~
name|QGraphicsScene
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Remove this scene from qApp's global scene list.
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|is_app_closing
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|scene_list
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
comment|// Remove this scene from all associated views.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
name|d
operator|->
name|views
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|->
name|setScene
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \property QGraphicsScene::sceneRect     \brief the scene rectangle; the bounding rectangle of the scene      The scene rectangle defines the extent of the scene. It is     primarily used by QGraphicsView to determine the view's default     scrollable area, and by QGraphicsScene to manage item indexing.      If unset, or if set to a null QRectF, sceneRect() will return the largest     bounding rect of all items on the scene since the scene was created (i.e.,     a rectangle that grows when items are added to or moved in the scene, but     never shrinks).      \sa width(), height(), QGraphicsView::sceneRect */
end_comment
begin_function
DECL|function|sceneRect
name|QRectF
name|QGraphicsScene
operator|::
name|sceneRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasSceneRect
condition|)
return|return
name|d
operator|->
name|sceneRect
return|;
if|if
condition|(
name|d
operator|->
name|dirtyGrowingItemsBoundingRect
condition|)
block|{
comment|// Lazily update the growing items bounding rect
name|QGraphicsScenePrivate
modifier|*
name|thatd
init|=
cast|const_cast
argument_list|<
name|QGraphicsScenePrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|QRectF
name|oldGrowingBoundingRect
init|=
name|thatd
operator|->
name|growingItemsBoundingRect
decl_stmt|;
name|thatd
operator|->
name|growingItemsBoundingRect
operator||=
name|itemsBoundingRect
argument_list|()
expr_stmt|;
name|thatd
operator|->
name|dirtyGrowingItemsBoundingRect
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|oldGrowingBoundingRect
operator|!=
name|thatd
operator|->
name|growingItemsBoundingRect
condition|)
emit|emit
cast|const_cast
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|sceneRectChanged
argument_list|(
name|thatd
operator|->
name|growingItemsBoundingRect
argument_list|)
emit|;
block|}
return|return
name|d
operator|->
name|growingItemsBoundingRect
return|;
block|}
end_function
begin_function
DECL|function|setSceneRect
name|void
name|QGraphicsScene
operator|::
name|setSceneRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|rect
operator|!=
name|d
operator|->
name|sceneRect
condition|)
block|{
name|d
operator|->
name|hasSceneRect
operator|=
operator|!
name|rect
operator|.
name|isNull
argument_list|()
expr_stmt|;
name|d
operator|->
name|sceneRect
operator|=
name|rect
expr_stmt|;
emit|emit
name|sceneRectChanged
argument_list|(
name|d
operator|->
name|hasSceneRect
condition|?
name|rect
else|:
name|d
operator|->
name|growingItemsBoundingRect
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!      \fn qreal QGraphicsScene::width() const       This convenience function is equivalent to calling sceneRect().width().       \sa height() */
end_comment
begin_comment
comment|/*!      \fn qreal QGraphicsScene::height() const       This convenience function is equivalent to calling \c sceneRect().height().       \sa width() */
end_comment
begin_comment
comment|/*!     Renders the \a source rect from scene into \a target, using \a painter. This     function is useful for capturing the contents of the scene onto a paint     device, such as a QImage (e.g., to take a screenshot), or for printing     with QPrinter. For example:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 1      If \a source is a null rect, this function will use sceneRect() to     determine what to render. If \a target is a null rect, the dimensions of \a     painter's paint device will be used.      The source rect contents will be transformed according to \a     aspectRatioMode to fit into the target rect. By default, the aspect ratio     is kept, and \a source is scaled to fit in \a target.      \sa QGraphicsView::render() */
end_comment
begin_function
DECL|function|render
name|void
name|QGraphicsScene
operator|::
name|render
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|target
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|source
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectRatioMode
parameter_list|)
block|{
comment|// ### Switch to using the recursive rendering algorithm instead.
comment|// Default source rect = scene rect
name|QRectF
name|sourceRect
init|=
name|source
decl_stmt|;
if|if
condition|(
name|sourceRect
operator|.
name|isNull
argument_list|()
condition|)
name|sourceRect
operator|=
name|sceneRect
argument_list|()
expr_stmt|;
comment|// Default target rect = device rect
name|QRectF
name|targetRect
init|=
name|target
decl_stmt|;
if|if
condition|(
name|targetRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|painter
operator|->
name|device
argument_list|()
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Picture
condition|)
name|targetRect
operator|=
name|sourceRect
expr_stmt|;
else|else
name|targetRect
operator|.
name|setRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|width
argument_list|()
argument_list|,
name|painter
operator|->
name|device
argument_list|()
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Find the ideal x / y scaling ratio to fit \a source into \a target.
name|qreal
name|xratio
init|=
name|targetRect
operator|.
name|width
argument_list|()
operator|/
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|yratio
init|=
name|targetRect
operator|.
name|height
argument_list|()
operator|/
name|sourceRect
operator|.
name|height
argument_list|()
decl_stmt|;
comment|// Scale according to the aspect ratio mode.
switch|switch
condition|(
name|aspectRatioMode
condition|)
block|{
case|case
name|Qt
operator|::
name|KeepAspectRatio
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMin
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|KeepAspectRatioByExpanding
case|:
name|xratio
operator|=
name|yratio
operator|=
name|qMax
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|IgnoreAspectRatio
case|:
break|break;
block|}
comment|// Find all items to draw, and reverse the list (we want to draw
comment|// in reverse order).
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
init|=
name|items
argument_list|(
name|sourceRect
argument_list|,
name|Qt
operator|::
name|IntersectsItemBoundingRect
argument_list|)
decl_stmt|;
name|QGraphicsItem
modifier|*
modifier|*
name|itemArray
init|=
operator|new
name|QGraphicsItem
operator|*
index|[
name|itemList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|numItems
init|=
name|itemList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|itemArray
index|[
name|numItems
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|itemList
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|itemList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
comment|// Transform the painter.
name|painter
operator|->
name|setClipRect
argument_list|(
name|targetRect
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
name|QTransform
name|painterTransform
decl_stmt|;
name|painterTransform
operator|*=
name|QTransform
argument_list|()
operator|.
name|translate
argument_list|(
name|targetRect
operator|.
name|left
argument_list|()
argument_list|,
name|targetRect
operator|.
name|top
argument_list|()
argument_list|)
operator|.
name|scale
argument_list|(
name|xratio
argument_list|,
name|yratio
argument_list|)
operator|.
name|translate
argument_list|(
operator|-
name|sourceRect
operator|.
name|left
argument_list|()
argument_list|,
operator|-
name|sourceRect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setWorldTransform
argument_list|(
name|painterTransform
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Generate the style options
name|QStyleOptionGraphicsItem
modifier|*
name|styleOptionArray
init|=
operator|new
name|QStyleOptionGraphicsItem
index|[
name|numItems
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|itemArray
index|[
name|i
index|]
operator|->
name|d_ptr
operator|->
name|initStyleOption
argument_list|(
operator|&
name|styleOptionArray
index|[
name|i
index|]
argument_list|,
name|painterTransform
argument_list|,
name|targetRect
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
comment|// Render the scene.
name|drawBackground
argument_list|(
name|painter
argument_list|,
name|sourceRect
argument_list|)
expr_stmt|;
name|drawItems
argument_list|(
name|painter
argument_list|,
name|numItems
argument_list|,
name|itemArray
argument_list|,
name|styleOptionArray
argument_list|)
expr_stmt|;
name|drawForeground
argument_list|(
name|painter
argument_list|,
name|sourceRect
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|itemArray
expr_stmt|;
operator|delete
index|[]
name|styleOptionArray
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::itemIndexMethod     \brief the item indexing method.      QGraphicsScene applies an indexing algorithm to the scene, to speed up     item discovery functions like items() and itemAt(). Indexing is most     efficient for static scenes (i.e., where items don't move around). For     dynamic scenes, or scenes with many animated items, the index bookkeeping     can outweight the fast lookup speeds.      For the common case, the default index method BspTreeIndex works fine.  If     your scene uses many animations and you are experiencing slowness, you can     disable indexing by calling \c setItemIndexMethod(NoIndex).      \sa bspTreeDepth */
end_comment
begin_function
DECL|function|itemIndexMethod
name|QGraphicsScene
operator|::
name|ItemIndexMethod
name|QGraphicsScene
operator|::
name|itemIndexMethod
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|indexMethod
return|;
block|}
end_function
begin_function
DECL|function|setItemIndexMethod
name|void
name|QGraphicsScene
operator|::
name|setItemIndexMethod
parameter_list|(
name|ItemIndexMethod
name|method
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|indexMethod
operator|==
name|method
condition|)
return|return;
name|d
operator|->
name|indexMethod
operator|=
name|method
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|oldItems
init|=
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|Qt
operator|::
name|DescendingOrder
argument_list|)
decl_stmt|;
operator|delete
name|d
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|BspTreeIndex
condition|)
name|d
operator|->
name|index
operator|=
operator|new
name|QGraphicsSceneBspTreeIndex
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|index
operator|=
operator|new
name|QGraphicsSceneLinearIndex
argument_list|(
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|oldItems
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|d
operator|->
name|index
operator|->
name|addItem
argument_list|(
name|oldItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::bspTreeDepth     \brief the depth of QGraphicsScene's BSP index tree     \since 4.3      This property has no effect when NoIndex is used.      This value determines the depth of QGraphicsScene's BSP tree. The depth     directly affects QGraphicsScene's performance and memory usage; the latter     growing exponentially with the depth of the tree. With an optimal tree     depth, QGraphicsScene can instantly determine the locality of items, even     for scenes with thousands or millions of items. This also greatly improves     rendering performance.      By default, the value is 0, in which case Qt will guess a reasonable     default depth based on the size, location and number of items in the     scene. If these parameters change frequently, however, you may experience     slowdowns as QGraphicsScene retunes the depth internally. You can avoid     potential slowdowns by fixating the tree depth through setting this     property.      The depth of the tree and the size of the scene rectangle decide the     granularity of the scene's partitioning. The size of each scene segment is     determined by the following algorithm:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 2      The BSP tree has an optimal size when each segment contains between 0 and     10 items.      \sa itemIndexMethod */
end_comment
begin_function
DECL|function|bspTreeDepth
name|int
name|QGraphicsScene
operator|::
name|bspTreeDepth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QGraphicsSceneBspTreeIndex
modifier|*
name|bspTree
init|=
name|qobject_cast
argument_list|<
name|QGraphicsSceneBspTreeIndex
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|index
argument_list|)
decl_stmt|;
return|return
name|bspTree
condition|?
name|bspTree
operator|->
name|bspTreeDepth
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setBspTreeDepth
name|void
name|QGraphicsScene
operator|::
name|setBspTreeDepth
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::setBspTreeDepth: invalid depth %d ignored; must be>= 0"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsSceneBspTreeIndex
modifier|*
name|bspTree
init|=
name|qobject_cast
argument_list|<
name|QGraphicsSceneBspTreeIndex
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bspTree
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::setBspTreeDepth: can not apply if indexing method is not BSP"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bspTree
operator|->
name|setBspTreeDepth
argument_list|(
name|depth
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::sortCacheEnabled     \brief whether sort caching is enabled     \since 4.5     \obsolete      Since Qt 4.6, this property has no effect. */
end_comment
begin_function
DECL|function|isSortCacheEnabled
name|bool
name|QGraphicsScene
operator|::
name|isSortCacheEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sortCacheEnabled
return|;
block|}
end_function
begin_function
DECL|function|setSortCacheEnabled
name|void
name|QGraphicsScene
operator|::
name|setSortCacheEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sortCacheEnabled
operator|==
name|enabled
condition|)
return|return;
name|d
operator|->
name|sortCacheEnabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Calculates and returns the bounding rect of all items on the scene. This     function works by iterating over all items, and because of this, it can     be slow for large scenes.      \sa sceneRect() */
end_comment
begin_function
DECL|function|itemsBoundingRect
name|QRectF
name|QGraphicsScene
operator|::
name|itemsBoundingRect
parameter_list|()
specifier|const
block|{
comment|// Does not take untransformable items into account.
name|QRectF
name|boundingRect
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|()
control|)
name|boundingRect
operator||=
name|item
operator|->
name|sceneBoundingRect
argument_list|()
expr_stmt|;
return|return
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an ordered list of all items on the scene. \a order decides the     stacking order.      \sa addItem(), removeItem(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|items
parameter_list|(
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|order
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode) const     \obsolete     \since 4.3      This convenience function is equivalent to calling items(QRectF(\a x, \a y, \a w, \a h), \a mode).      This function is deprecated and returns incorrect results if the scene     contains items that ignore transformations. Use the overload that takes     a QTransform instead. */
end_comment
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const     \overload     \since 4.6      \brief Returns all visible items that, depending on \a mode, are     either inside or intersect with the rectangle defined by \a x, \a y,     \a w and \a h, in a list sorted using \a order. In this case, "visible" defines items for which:     isVisible() returns true, effectiveOpacity() returns a value greater than 0.0     (which is fully transparent) and the parent item does not clip it.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations. */
end_comment
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPointF&pos, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const     \since 4.6      \brief Returns all visible items that, depending on \a mode, are at     the specified \a pos in a list sorted using \a order. In this case, "visible" defines items for which:     isVisible() returns true, effectiveOpacity() returns a value greater than 0.0     (which is fully transparent) and the parent item does not clip it.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with \a pos are returned.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      \sa itemAt(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|items
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|pos
argument_list|,
name|mode
argument_list|,
name|order
argument_list|,
name|deviceTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(const QRectF&rect, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const     \overload     \since 4.6      \brief Returns all visible items that, depending on \a mode, are     either inside or intersect with the specified \a rect, in a     list sorted using \a order. In this case, "visible" defines items for which:     isVisible() returns true, effectiveOpacity() returns a value greater than 0.0     (which is fully transparent) and the parent item does not clip it.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a rect are returned.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      \sa itemAt(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|items
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|rect
argument_list|,
name|mode
argument_list|,
name|order
argument_list|,
name|deviceTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPolygonF&polygon, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const     \overload     \since 4.6      \brief Returns all visible items that, depending on \a mode, are     either inside or intersect with the specified \a polygon, in     a list sorted using \a order. In this case, "visible" defines items for which:     isVisible() returns true, effectiveOpacity() returns a value greater than 0.0     (which is fully transparent) and the parent item does not clip it.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a polygon are returned.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      \sa itemAt(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|items
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|polygon
argument_list|,
name|mode
argument_list|,
name|order
argument_list|,
name|deviceTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPainterPath&path, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const     \overload     \since 4.6      \brief Returns all visible items that, depending on \a mode, are     either inside or intersect with the specified \a path, in a     list sorted using \a order. In this case, "visible" defines items for which:     isVisible() returns true, effectiveOpacity() returns a value greater than 0.0     (which is fully transparent) and the parent item does not clip it.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a path are returned.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      \sa itemAt(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|items
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|index
operator|->
name|items
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|order
argument_list|,
name|deviceTransform
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all items that collide with \a item. Collisions are     determined by calling QGraphicsItem::collidesWithItem(); the collision     detection is determined by \a mode. By default, all items whose shape     intersects \a item or is contained inside \a item's shape are returned.      The items are returned in descending stacking order (i.e., the first item     in the list is the uppermost item, and the last item is the lowermost     item).      \sa items(), itemAt(), QGraphicsItem::collidesWithItem(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|collidingItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|collidingItems
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::collidingItems: cannot find collisions for null item"
argument_list|)
expr_stmt|;
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
block|}
comment|// Does not support ItemIgnoresTransformations.
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|tmp
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|itemInVicinity
decl|,
name|d
operator|->
name|index
operator|->
name|estimateItems
argument_list|(
name|item
operator|->
name|sceneBoundingRect
argument_list|()
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|)
control|)
block|{
if|if
condition|(
name|item
operator|!=
name|itemInVicinity
operator|&&
name|item
operator|->
name|collidesWithItem
argument_list|(
name|itemInVicinity
argument_list|,
name|mode
argument_list|)
condition|)
name|tmp
operator|<<
name|itemInVicinity
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsItem *QGraphicsScene::itemAt(const QPointF&position) const     \overload     \obsolete      Returns the topmost visible item at the specified \a position, or 0 if     there are no items at this position.      This function is deprecated and returns incorrect results if the scene     contains items that ignore transformations. Use the overload that takes     a QTransform instead.      Note: See items() for a definition of which items are considered visible by this function.      \sa items(), collidingItems(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_comment
comment|/*!     \since 4.6      Returns the topmost visible item at the specified \a position, or 0     if there are no items at this position.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      Note: See items() for a definition of which items are considered visible by this function.      \sa items(), collidingItems(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|itemAt
name|QGraphicsItem
modifier|*
name|QGraphicsScene
operator|::
name|itemAt
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|position
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemsAtPoint
init|=
name|items
argument_list|(
name|position
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|deviceTransform
argument_list|)
decl_stmt|;
return|return
name|itemsAtPoint
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|itemsAtPoint
operator|.
name|first
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsScene::itemAt(qreal x, qreal y, const QTransform&deviceTransform) const     \overload     \since 4.6      Returns the topmost visible item at the position specified by (\a x, \a     y), or 0 if there are no items at this position.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      This convenience function is equivalent to calling \c     {itemAt(QPointF(x, y), deviceTransform)}.      Note: See items() for a definition of which items are considered visible by this function. */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScene::itemAt(qreal x, qreal y) const     \overload     \obsolete      Returns the topmost visible item at the position specified by (\a x, \a     y), or 0 if there are no items at this position.      This convenience function is equivalent to calling \c     {itemAt(QPointF(x, y))}.      This function is deprecated and returns incorrect results if the scene     contains items that ignore transformations. Use the overload that takes     a QTransform instead.      Note: See items() for a definition of which items are considered visible by this function. */
end_comment
begin_comment
comment|/*!     Returns a list of all currently selected items. The items are     returned in no particular order.      \sa setSelectionArea() */
end_comment
begin_function
DECL|function|selectedItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|selectedItems
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Optimization: Lazily removes items that are not selected.
name|QGraphicsScene
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|actuallySelectedSet
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|that
operator|->
name|d_func
argument_list|()
operator|->
name|selectedItems
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isSelected
argument_list|()
condition|)
name|actuallySelectedSet
operator|<<
name|item
expr_stmt|;
block|}
name|that
operator|->
name|d_func
argument_list|()
operator|->
name|selectedItems
operator|=
name|actuallySelectedSet
expr_stmt|;
return|return
name|d
operator|->
name|selectedItems
operator|.
name|values
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the selection area that was previously set with     setSelectionArea(), or an empty QPainterPath if no selection area has been     set.      \sa setSelectionArea() */
end_comment
begin_function
DECL|function|selectionArea
name|QPainterPath
name|QGraphicsScene
operator|::
name|selectionArea
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|selectionArea
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the selection area to \a path. All items within this area are     immediately selected, and all items outside are unselected. You can get     the list of all selected items by calling selectedItems().      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      For an item to be selected, it must be marked as \e selectable     (QGraphicsItem::ItemIsSelectable).      \sa clearSelection(), selectionArea() */
end_comment
begin_function
DECL|function|setSelectionArea
name|void
name|QGraphicsScene
operator|::
name|setSelectionArea
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
block|{
name|setSelectionArea
argument_list|(
name|path
argument_list|,
name|Qt
operator|::
name|IntersectsItemShape
argument_list|,
name|deviceTransform
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Sets the selection area to \a path using \a mode to determine if items are     included in the selection area.      \a deviceTransform is the transformation that applies to the view, and needs to     be provided if the scene contains items that ignore transformations.      \sa clearSelection(), selectionArea() */
end_comment
begin_function
DECL|function|setSelectionArea
name|void
name|QGraphicsScene
operator|::
name|setSelectionArea
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Note: with boolean path operations, we can improve performance here
comment|// quite a lot by "growing" the old path instead of replacing it. That
comment|// allows us to only check the intersect area for changes, instead of
comment|// reevaluating the whole path over again.
name|d
operator|->
name|selectionArea
operator|=
name|path
expr_stmt|;
name|QSet
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|unselectItems
init|=
name|d
operator|->
name|selectedItems
decl_stmt|;
comment|// Disable emitting selectionChanged() for individual items.
operator|++
name|d
operator|->
name|selectionChanging
expr_stmt|;
name|bool
name|changed
init|=
literal|false
decl_stmt|;
comment|// Set all items in path to selected.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|Qt
operator|::
name|DescendingOrder
argument_list|,
name|deviceTransform
argument_list|)
control|)
block|{
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsSelectable
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isSelected
argument_list|()
condition|)
name|changed
operator|=
literal|true
expr_stmt|;
name|unselectItems
operator|.
name|remove
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Unselect all items outside path.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|unselectItems
control|)
block|{
name|item
operator|->
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
comment|// Reenable emitting selectionChanged() for individual items.
operator|--
name|d
operator|->
name|selectionChanging
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|selectionChanging
operator|&&
name|changed
condition|)
emit|emit
name|selectionChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!    Clears the current selection.     \sa setSelectionArea(), selectedItems() */
end_comment
begin_function
DECL|function|clearSelection
name|void
name|QGraphicsScene
operator|::
name|clearSelection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Disable emitting selectionChanged
operator|++
name|d
operator|->
name|selectionChanging
expr_stmt|;
name|bool
name|changed
init|=
operator|!
name|d
operator|->
name|selectedItems
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|d
operator|->
name|selectedItems
control|)
name|item
operator|->
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|selectedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Reenable emitting selectionChanged() for individual items.
operator|--
name|d
operator|->
name|selectionChanging
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|selectionChanging
operator|&&
name|changed
condition|)
emit|emit
name|selectionChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Removes and deletes all items from the scene, but otherwise leaves the     state of the scene unchanged.      \sa addItem() */
end_comment
begin_function
DECL|function|clear
name|void
name|QGraphicsScene
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// NB! We have to clear the index before deleting items; otherwise the
comment|// index might try to access dangling item pointers.
name|d
operator|->
name|index
operator|->
name|clear
argument_list|()
expr_stmt|;
comment|// NB! QGraphicsScenePrivate::unregisterTopLevelItem() removes items
while|while
condition|(
operator|!
name|d
operator|->
name|topLevelItems
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|d
operator|->
name|topLevelItems
operator|.
name|first
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|topLevelItems
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastItemCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|allItemsIgnoreHoverEvents
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|allItemsUseDefaultCursor
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|allItemsIgnoreTouchEvents
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Groups all items in \a items into a new QGraphicsItemGroup, and returns a     pointer to the group. The group is created with the common ancestor of \a     items as its parent, and with position (0, 0). The items are all     reparented to the group, and their positions and transformations are     mapped to the group. If \a items is empty, this function will return an     empty top-level QGraphicsItemGroup.      QGraphicsScene has ownership of the group item; you do not need to delete     it. To dismantle (ungroup) a group, call destroyItemGroup().      \sa destroyItemGroup(), QGraphicsItemGroup::addToGroup() */
end_comment
begin_function
DECL|function|createItemGroup
name|QGraphicsItemGroup
modifier|*
name|QGraphicsScene
operator|::
name|createItemGroup
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
modifier|&
name|items
parameter_list|)
block|{
comment|// Build a list of the first item's ancestors
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|ancestors
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|items
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|parent
init|=
name|items
operator|.
name|at
argument_list|(
name|n
operator|++
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
name|parent
operator|->
name|parentItem
argument_list|()
operator|)
condition|)
name|ancestors
operator|.
name|append
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// Find the common ancestor for all items
name|QGraphicsItem
modifier|*
name|commonAncestor
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ancestors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
while|while
condition|(
name|n
operator|<
name|items
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|commonIndex
init|=
operator|-
literal|1
decl_stmt|;
name|QGraphicsItem
modifier|*
name|parent
init|=
name|items
operator|.
name|at
argument_list|(
name|n
operator|++
argument_list|)
decl_stmt|;
do|do
block|{
name|int
name|index
init|=
name|ancestors
operator|.
name|indexOf
argument_list|(
name|parent
argument_list|,
name|qMax
argument_list|(
literal|0
argument_list|,
name|commonIndex
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|commonIndex
operator|=
name|index
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|parent
operator|=
name|parent
operator|->
name|parentItem
argument_list|()
operator|)
condition|)
do|;
if|if
condition|(
name|commonIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|commonAncestor
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|commonAncestor
operator|=
name|ancestors
operator|.
name|at
argument_list|(
name|commonIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create a new group at that level
name|QGraphicsItemGroup
modifier|*
name|group
init|=
operator|new
name|QGraphicsItemGroup
argument_list|(
name|commonAncestor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commonAncestor
condition|)
name|addItem
argument_list|(
name|group
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
control|)
name|group
operator|->
name|addToGroup
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|group
return|;
block|}
end_function
begin_comment
comment|/*!     Reparents all items in \a group to \a group's parent item, then removes \a     group from the scene, and finally deletes it. The items' positions and     transformations are mapped from the group to the group's parent.      \sa createItemGroup(), QGraphicsItemGroup::removeFromGroup() */
end_comment
begin_function
DECL|function|destroyItemGroup
name|void
name|QGraphicsScene
operator|::
name|destroyItemGroup
parameter_list|(
name|QGraphicsItemGroup
modifier|*
name|group
parameter_list|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|group
operator|->
name|childItems
argument_list|()
control|)
name|group
operator|->
name|removeFromGroup
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|removeItem
argument_list|(
name|group
argument_list|)
expr_stmt|;
operator|delete
name|group
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds or moves the \a item and all its childen to this scene.     This scene takes ownership of the \a item.      If the item is visible (i.e., QGraphicsItem::isVisible() returns     true), QGraphicsScene will emit changed() once control goes back     to the event loop.      If the item is already in a different scene, it will first be     removed from its old scene, and then added to this scene as a     top-level.      QGraphicsScene will send ItemSceneChange notifications to \a item     while it is added to the scene. If item does not currently belong     to a scene, only one notification is sent. If it does belong to     scene already (i.e., it is moved to this scene), QGraphicsScene     will send an addition notification as the item is removed from its     previous scene.      If the item is a panel, the scene is active, and there is no     active panel in the scene, then the item will be activated.      \sa removeItem(), addEllipse(), addLine(), addPath(), addPixmap(),     addRect(), addText(), addWidget(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|addItem
name|void
name|QGraphicsScene
operator|::
name|addItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::addItem: cannot add null item"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|scene
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::addItem: item has already been added to this scene"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Remove this item from its existing scene
if|if
condition|(
name|QGraphicsScene
modifier|*
name|oldScene
init|=
name|item
operator|->
name|d_ptr
operator|->
name|scene
condition|)
name|oldScene
operator|->
name|removeItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Notify the item that its scene is changing, and allow the item to
comment|// react.
specifier|const
name|QVariant
name|newSceneVariant
argument_list|(
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemSceneChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QGraphicsScene
modifier|*
name|targetScene
init|=
name|qvariant_cast
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
name|newSceneVariant
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetScene
operator|!=
name|this
condition|)
block|{
if|if
condition|(
name|targetScene
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|scene
operator|!=
name|targetScene
condition|)
name|targetScene
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// QDeclarativeItems do not rely on initial itemChanged message, as the componentComplete
comment|// function allows far more opportunity for delayed-construction optimization.
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|isDeclarativeItem
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|unpolishedItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMetaMethod
name|method
init|=
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|d
operator|->
name|polishItemsIndex
argument_list|)
decl_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|this
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|unpolishedItems
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|pendingPolish
operator|=
literal|true
expr_stmt|;
block|}
comment|// Detach this item from its parent if the parent's scene is different
comment|// from this scene.
if|if
condition|(
name|QGraphicsItem
modifier|*
name|itemParent
init|=
name|item
operator|->
name|d_ptr
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|itemParent
operator|->
name|d_ptr
operator|->
name|scene
operator|!=
name|this
condition|)
name|item
operator|->
name|setParentItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Add the item to this scene
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|=
name|targetScene
expr_stmt|;
comment|// Add the item in the index
name|d
operator|->
name|index
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Add to list of toplevels if this item is a toplevel.
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|parent
condition|)
name|d
operator|->
name|registerTopLevelItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Add to list of items that require an update. We cannot assume that the
comment|// item is fully constructed, so calling item->update() can lead to a pure
comment|// virtual function call to boundingRect().
name|d
operator|->
name|markDirty
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirtyGrowingItemsBoundingRect
operator|=
literal|true
expr_stmt|;
comment|// Disable selectionChanged() for individual items
operator|++
name|d
operator|->
name|selectionChanging
expr_stmt|;
name|int
name|oldSelectedItemSize
init|=
name|d
operator|->
name|selectedItems
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Enable mouse tracking if the item accepts hover events or has a cursor set.
if|if
condition|(
name|d
operator|->
name|allItemsIgnoreHoverEvents
operator|&&
name|d
operator|->
name|itemAcceptsHoverEvents_helper
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|d
operator|->
name|allItemsIgnoreHoverEvents
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|enableMouseTrackingOnViews
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
if|if
condition|(
name|d
operator|->
name|allItemsUseDefaultCursor
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|hasCursor
condition|)
block|{
name|d
operator|->
name|allItemsUseDefaultCursor
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|allItemsIgnoreHoverEvents
condition|)
comment|// already enabled otherwise
name|d
operator|->
name|enableMouseTrackingOnViews
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_CURSOR
comment|// Enable touch events if the item accepts touch events.
if|if
condition|(
name|d
operator|->
name|allItemsIgnoreTouchEvents
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|acceptTouchEvents
condition|)
block|{
name|d
operator|->
name|allItemsIgnoreTouchEvents
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|enableTouchEventsOnViews
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|gesture
decl|,
name|item
operator|->
name|d_ptr
operator|->
name|gestureContext
operator|.
name|keys
argument_list|()
control|)
name|d
operator|->
name|grabGesture
argument_list|(
name|item
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Update selection lists
if|if
condition|(
name|item
operator|->
name|isSelected
argument_list|()
condition|)
name|d
operator|->
name|selectedItems
operator|<<
name|item
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
operator|&&
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|d
operator|->
name|addPopup
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
name|item
operator|->
name|panelModality
argument_list|()
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
name|d
operator|->
name|enterModal
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Update creation order focus chain. Make sure to leave the widget's
comment|// internal tab order intact.
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|tabFocusFirst
condition|)
block|{
comment|// No first tab focus widget - make this the first tab focus
comment|// widget.
name|d
operator|->
name|tabFocusFirst
operator|=
name|widget
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|widget
operator|->
name|parentWidget
argument_list|()
operator|&&
operator|!
name|widget
operator|->
name|isPanel
argument_list|()
condition|)
block|{
comment|// Adding a widget that is not part of a tab focus chain.
name|QGraphicsWidget
modifier|*
name|myNewPrev
init|=
name|d
operator|->
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
decl_stmt|;
name|myNewPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|widget
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|d
operator|->
name|tabFocusFirst
expr_stmt|;
name|d
operator|->
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|myNewPrev
expr_stmt|;
block|}
block|}
comment|// Add all children recursively
name|item
operator|->
name|d_ptr
operator|->
name|ensureSortedChildren
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|addItem
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Resolve font and palette.
name|item
operator|->
name|d_ptr
operator|->
name|resolveFont
argument_list|(
name|d
operator|->
name|font
operator|.
name|resolve
argument_list|()
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|resolvePalette
argument_list|(
name|d
operator|->
name|palette
operator|.
name|resolve
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reenable selectionChanged() for individual items
operator|--
name|d
operator|->
name|selectionChanging
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|selectionChanging
operator|&&
name|d
operator|->
name|selectedItems
operator|.
name|size
argument_list|()
operator|!=
name|oldSelectedItemSize
condition|)
emit|emit
name|selectionChanged
argument_list|()
emit|;
comment|// Deliver post-change notification
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemSceneHasChanged
argument_list|,
name|newSceneVariant
argument_list|)
expr_stmt|;
comment|// Update explicit activation
name|bool
name|autoActivate
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|childExplicitActivation
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|explicitActivate
condition|)
name|d
operator|->
name|childExplicitActivation
operator|=
name|item
operator|->
name|d_ptr
operator|->
name|wantsActive
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|childExplicitActivation
operator|&&
name|item
operator|->
name|isPanel
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|childExplicitActivation
operator|==
literal|1
condition|)
name|setActivePanel
argument_list|(
name|item
argument_list|)
expr_stmt|;
else|else
name|autoActivate
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|childExplicitActivation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|parent
condition|)
block|{
name|d
operator|->
name|childExplicitActivation
operator|=
literal|0
expr_stmt|;
block|}
comment|// Auto-activate this item's panel if nothing else has been activated
if|if
condition|(
name|autoActivate
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|lastActivePanel
operator|&&
operator|!
name|d
operator|->
name|activePanel
operator|&&
name|item
operator|->
name|isPanel
argument_list|()
condition|)
block|{
if|if
condition|(
name|isActive
argument_list|()
condition|)
name|setActivePanel
argument_list|(
name|item
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|lastActivePanel
operator|=
name|item
expr_stmt|;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
condition|)
name|d
operator|->
name|registerScenePosItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Ensure that newly added items that have subfocus set, gain
comment|// focus automatically if there isn't a focus item already.
if|if
condition|(
operator|!
name|d
operator|->
name|focusItem
operator|&&
name|item
operator|!=
name|d
operator|->
name|lastFocusItem
operator|&&
name|item
operator|->
name|focusItem
argument_list|()
operator|==
name|item
condition|)
name|item
operator|->
name|focusItem
argument_list|()
operator|->
name|setFocus
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateInputMethodSensitivityInViews
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Creates and adds an ellipse item to the scene, and returns the item     pointer. The geometry of the ellipse is defined by \a rect, and its pen     and brush are initialized to \a pen and \a brush.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addLine(), addPath(), addPixmap(), addRect(), addText(), addItem(),     addWidget() */
end_comment
begin_function
DECL|function|addEllipse
name|QGraphicsEllipseItem
modifier|*
name|QGraphicsScene
operator|::
name|addEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|QGraphicsEllipseItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsEllipseItem
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|item
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsEllipseItem *QGraphicsScene::addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen&pen, const QBrush&brush)     \since 4.3      This convenience function is equivalent to calling addEllipse(QRectF(\a x,     \a y, \a w, \a h), \a pen, \a brush). */
end_comment
begin_comment
comment|/*!     Creates and adds a line item to the scene, and returns the item     pointer. The geometry of the line is defined by \a line, and its pen     is initialized to \a pen.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addPath(), addPixmap(), addRect(), addText(), addItem(),     addWidget() */
end_comment
begin_function
DECL|function|addLine
name|QGraphicsLineItem
modifier|*
name|QGraphicsScene
operator|::
name|addLine
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|QGraphicsLineItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsLineItem
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsLineItem *QGraphicsScene::addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen&pen)     \since 4.3      This convenience function is equivalent to calling addLine(QLineF(\a x1,     \a y1, \a x2, \a y2), \a pen). */
end_comment
begin_comment
comment|/*!     Creates and adds a path item to the scene, and returns the item     pointer. The geometry of the path is defined by \a path, and its pen and     brush are initialized to \a pen and \a brush.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPixmap(), addRect(), addText(), addItem(),     addWidget() */
end_comment
begin_function
DECL|function|addPath
name|QGraphicsPathItem
modifier|*
name|QGraphicsScene
operator|::
name|addPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|QGraphicsPathItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsPathItem
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|item
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and adds a pixmap item to the scene, and returns the item     pointer. The pixmap is defined by \a pixmap.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPath(), addRect(), addText(), addItem(),     addWidget() */
end_comment
begin_function
DECL|function|addPixmap
name|QGraphicsPixmapItem
modifier|*
name|QGraphicsScene
operator|::
name|addPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|QGraphicsPixmapItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsPixmapItem
argument_list|(
name|pixmap
argument_list|)
decl_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and adds a polygon item to the scene, and returns the item     pointer. The polygon is defined by \a polygon, and its pen and     brush are initialized to \a pen and \a brush.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPath(), addRect(), addText(), addItem(),     addWidget() */
end_comment
begin_function
DECL|function|addPolygon
name|QGraphicsPolygonItem
modifier|*
name|QGraphicsScene
operator|::
name|addPolygon
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|QGraphicsPolygonItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsPolygonItem
argument_list|(
name|polygon
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|item
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and adds a rectangle item to the scene, and returns the item     pointer. The geometry of the rectangle is defined by \a rect, and its pen     and brush are initialized to \a pen and \a brush.      Note that the item's geometry is provided in item coordinates, and its     position is initialized to (0, 0). For example, if a QRect(50, 50, 100,     100) is added, its top-left corner will be at (50, 50) relative to the     origin in the items coordinate system.      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addText(),     addItem(), addWidget() */
end_comment
begin_function
DECL|function|addRect
name|QGraphicsRectItem
modifier|*
name|QGraphicsScene
operator|::
name|addRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|QGraphicsRectItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsRectItem
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|item
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsRectItem *QGraphicsScene::addRect(qreal x, qreal y, qreal w, qreal h, const QPen&pen, const QBrush&brush)     \since 4.3      This convenience function is equivalent to calling addRect(QRectF(\a x,     \a y, \a w, \a h), \a pen, \a brush). */
end_comment
begin_comment
comment|/*!     Creates and adds a text item to the scene, and returns the item     pointer. The text string is initialized to \a text, and its font     is initialized to \a font.      The item's position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),     addItem(), addWidget() */
end_comment
begin_function
DECL|function|addText
name|QGraphicsTextItem
modifier|*
name|QGraphicsScene
operator|::
name|addText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|QGraphicsTextItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsTextItem
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|item
operator|->
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and adds a QGraphicsSimpleTextItem to the scene, and returns the     item pointer. The text string is initialized to \a text, and its font is     initialized to \a font.      The item's position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),     addItem(), addWidget() */
end_comment
begin_function
DECL|function|addSimpleText
name|QGraphicsSimpleTextItem
modifier|*
name|QGraphicsScene
operator|::
name|addSimpleText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|QGraphicsSimpleTextItem
modifier|*
name|item
init|=
operator|new
name|QGraphicsSimpleTextItem
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|item
operator|->
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a new QGraphicsProxyWidget for \a widget, adds it to the scene,     and returns a pointer to the proxy. \a wFlags set the default window flags     for the embedding proxy widget.      The item's position is initialized to (0, 0).      If the item is visible (i.e., QGraphicsItem::isVisible() returns true),     QGraphicsScene will emit changed() once control goes back to the event     loop.      Note that widgets with the Qt::WA_PaintOnScreen widget attribute     set and widgets that wrap an external application or controller     are not supported. Examples are QGLWidget and QAxWidget.      \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),     addText(), addSimpleText(), addItem() */
end_comment
begin_function
DECL|function|addWidget
name|QGraphicsProxyWidget
modifier|*
name|QGraphicsScene
operator|::
name|addWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|wFlags
parameter_list|)
block|{
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
operator|new
name|QGraphicsProxyWidget
argument_list|(
literal|0
argument_list|,
name|wFlags
argument_list|)
decl_stmt|;
name|proxy
operator|->
name|setWidget
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|addItem
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
return|return
name|proxy
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the item \a item and all its children from the scene.  The     ownership of \a item is passed on to the caller (i.e.,     QGraphicsScene will no longer delete \a item when destroyed).      \sa addItem() */
end_comment
begin_function
DECL|function|removeItem
name|void
name|QGraphicsScene
operator|::
name|removeItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
comment|// ### Refactoring: This function shares much functionality with _q_removeItemLater()
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::removeItem: cannot remove 0-item"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
operator|->
name|scene
argument_list|()
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::removeItem: item %p's scene (%p)"
literal|" is different from this scene (%p)"
argument_list|,
name|item
argument_list|,
name|item
operator|->
name|scene
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Notify the item that it's scene is changing to 0, allowing the item to
comment|// react.
specifier|const
name|QVariant
name|newSceneVariant
argument_list|(
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemSceneChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QGraphicsScene
modifier|*
name|targetScene
init|=
name|qvariant_cast
argument_list|<
name|QGraphicsScene
operator|*
argument_list|>
argument_list|(
name|newSceneVariant
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetScene
operator|!=
literal|0
operator|&&
name|targetScene
operator|!=
name|this
condition|)
block|{
name|targetScene
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|removeItemHelper
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Deliver post-change notification
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemSceneHasChanged
argument_list|,
name|newSceneVariant
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateInputMethodSensitivityInViews
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     When the scene is active, this functions returns the scene's current focus     item, or 0 if no item currently has focus. When the scene is inactive, this     functions returns the item that will gain input focus when the scene becomes     active.      The focus item receives keyboard input when the scene receives a     key event.      \sa setFocusItem(), QGraphicsItem::hasFocus(), isActive() */
end_comment
begin_function
DECL|function|focusItem
name|QGraphicsItem
modifier|*
name|QGraphicsScene
operator|::
name|focusItem
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|isActive
argument_list|()
condition|?
name|d
operator|->
name|focusItem
else|:
name|d
operator|->
name|passiveFocusItem
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the scene's focus item to \a item, with the focus reason \a     focusReason, after removing focus from any previous item that may have had     focus.      If \a item is 0, or if it either does not accept focus (i.e., it does not     have the QGraphicsItem::ItemIsFocusable flag enabled), or is not visible     or not enabled, this function only removes focus from any previous     focusitem.      If item is not 0, and the scene does not currently have focus (i.e.,     hasFocus() returns false), this function will call setFocus()     automatically.      \sa focusItem(), hasFocus(), setFocus() */
end_comment
begin_function
DECL|function|setFocusItem
name|void
name|QGraphicsScene
operator|::
name|setFocusItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
condition|)
name|item
operator|->
name|setFocus
argument_list|(
name|focusReason
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|setFocusItemHelper
argument_list|(
name|item
argument_list|,
name|focusReason
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the scene has focus; otherwise returns false. If the scene     has focus, it will will forward key events from QKeyEvent to any item that     has focus.      \sa setFocus(), setFocusItem() */
end_comment
begin_function
DECL|function|hasFocus
name|bool
name|QGraphicsScene
operator|::
name|hasFocus
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hasFocus
return|;
block|}
end_function
begin_comment
comment|/*!     Sets focus on the scene by sending a QFocusEvent to the scene, passing \a     focusReason as the reason. If the scene regains focus after having     previously lost it while an item had focus, the last focus item will     receive focus with \a focusReason as the reason.      If the scene already has focus, this function does nothing.      \sa hasFocus(), clearFocus(), setFocusItem() */
end_comment
begin_function
DECL|function|setFocus
name|void
name|QGraphicsScene
operator|::
name|setFocus
parameter_list|(
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasFocus
operator|||
operator|!
name|isActive
argument_list|()
condition|)
return|return;
name|QFocusEvent
name|event
argument_list|(
name|QEvent
operator|::
name|FocusIn
argument_list|,
name|focusReason
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears focus from the scene. If any item has focus when this function is     called, it will lose focus, and regain focus again once the scene regains     focus.      A scene that does not have focus ignores key events.      \sa hasFocus(), setFocus(), setFocusItem() */
end_comment
begin_function
DECL|function|clearFocus
name|void
name|QGraphicsScene
operator|::
name|clearFocus
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasFocus
condition|)
block|{
name|d
operator|->
name|hasFocus
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|passiveFocusItem
operator|=
name|d
operator|->
name|focusItem
expr_stmt|;
name|setFocusItem
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|OtherFocusReason
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::stickyFocus     \brief whether clicking into the scene background will clear focus      \since 4.6      In a QGraphicsScene with stickyFocus set to true, focus will remain     unchanged when the user clicks into the scene background or on an item     that does not accept focus. Otherwise, focus will be cleared.      By default, this property is false.      Focus changes in response to a mouse press. You can reimplement     mousePressEvent() in a subclass of QGraphicsScene to toggle this property     based on where the user has clicked.      \sa clearFocus(), setFocusItem() */
end_comment
begin_function
DECL|function|setStickyFocus
name|void
name|QGraphicsScene
operator|::
name|setStickyFocus
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|stickyFocus
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stickyFocus
name|bool
name|QGraphicsScene
operator|::
name|stickyFocus
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|stickyFocus
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current mouse grabber item, or 0 if no item is currently     grabbing the mouse. The mouse grabber item is the item that receives all     mouse events sent to the scene.      An item becomes a mouse grabber when it receives and accepts a     mouse press event, and it stays the mouse grabber until either of     the following events occur:      \list     \li If the item receives a mouse release event when there are no other     buttons pressed, it loses the mouse grab.     \li If the item becomes invisible (i.e., someone calls \c {item->setVisible(false)}),     or if it becomes disabled (i.e., someone calls \c {item->setEnabled(false)}),     it loses the mouse grab.     \li If the item is removed from the scene, it loses the mouse grab.     \endlist      If the item loses its mouse grab, the scene will ignore all mouse events     until a new item grabs the mouse (i.e., until a new item receives a mouse     press event). */
end_comment
begin_function
DECL|function|mouseGrabberItem
name|QGraphicsItem
modifier|*
name|QGraphicsScene
operator|::
name|mouseGrabberItem
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
operator|!
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|mouseGrabberItems
operator|.
name|last
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::backgroundBrush     \brief the background brush of the scene.      Set this property to changes the scene's background to a different color,     gradient or texture. The default background brush is Qt::NoBrush. The     background is drawn before (behind) the items.      Example:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 3      QGraphicsScene::render() calls drawBackground() to draw the scene     background. For more detailed control over how the background is drawn,     you can reimplement drawBackground() in a subclass of QGraphicsScene. */
end_comment
begin_function
DECL|function|backgroundBrush
name|QBrush
name|QGraphicsScene
operator|::
name|backgroundBrush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|backgroundBrush
return|;
block|}
end_function
begin_function
DECL|function|setBackgroundBrush
name|void
name|QGraphicsScene
operator|::
name|setBackgroundBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|backgroundBrush
operator|=
name|brush
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|d
operator|->
name|views
control|)
block|{
name|view
operator|->
name|resetCachedContent
argument_list|()
expr_stmt|;
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::foregroundBrush     \brief the foreground brush of the scene.      Change this property to set the scene's foreground to a different     color, gradient or texture.      The foreground is drawn after (on top of) the items. The default     foreground brush is Qt::NoBrush ( i.e. the foreground is not     drawn).      Example:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 4      QGraphicsScene::render() calls drawForeground() to draw the scene     foreground. For more detailed control over how the foreground is     drawn, you can reimplement the drawForeground() function in a     QGraphicsScene subclass. */
end_comment
begin_function
DECL|function|foregroundBrush
name|QBrush
name|QGraphicsScene
operator|::
name|foregroundBrush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|foregroundBrush
return|;
block|}
end_function
begin_function
DECL|function|setForegroundBrush
name|void
name|QGraphicsScene
operator|::
name|setForegroundBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|foregroundBrush
operator|=
name|brush
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
argument_list|()
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This method is used by input methods to query a set of properties of     the scene to be able to support complex input method operations as support     for surrounding text and reconversions.      The \a query parameter specifies which property is queried.      \sa QWidget::inputMethodQuery() */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QGraphicsScene
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|focusItem
operator|||
operator|!
operator|(
name|d
operator|->
name|focusItem
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
operator|)
condition|)
return|return
name|QVariant
argument_list|()
return|;
specifier|const
name|QTransform
name|matrix
init|=
name|d
operator|->
name|focusItem
operator|->
name|sceneTransform
argument_list|()
decl_stmt|;
name|QVariant
name|value
init|=
name|d
operator|->
name|focusItem
operator|->
name|inputMethodQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|RectF
condition|)
name|value
operator|=
name|matrix
operator|.
name|mapRect
argument_list|(
name|value
operator|.
name|toRectF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|PointF
condition|)
name|value
operator|=
name|matrix
operator|.
name|map
argument_list|(
name|value
operator|.
name|toPointF
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Rect
condition|)
name|value
operator|=
name|matrix
operator|.
name|mapRect
argument_list|(
name|value
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Point
condition|)
name|value
operator|=
name|matrix
operator|.
name|map
argument_list|(
name|value
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsScene::update(const QRectF&rect)     Schedules a redraw of the area \a rect on the scene.      \sa sceneRect(), changed() */
end_comment
begin_function
DECL|function|update
name|void
name|QGraphicsScene
operator|::
name|update
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|updateAll
operator|||
operator|(
name|rect
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|rect
operator|.
name|isNull
argument_list|()
operator|)
condition|)
return|return;
comment|// Check if anyone's connected; if not, we can send updates directly to
comment|// the views. Otherwise or if there are no views, use old behavior.
name|bool
name|directUpdates
init|=
operator|!
operator|(
name|d
operator|->
name|isSignalConnected
argument_list|(
name|d
operator|->
name|changedSignalIndex
argument_list|)
operator|)
operator|&&
operator|!
name|d
operator|->
name|views
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|->
name|updateAll
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|updatedRects
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|directUpdates
condition|)
block|{
comment|// Update all views.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|fullUpdatePending
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|directUpdates
condition|)
block|{
comment|// Update all views.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsView
modifier|*
name|view
init|=
name|d
operator|->
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|view
operator|->
name|isTransformed
argument_list|()
condition|)
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|updateRectF
argument_list|(
name|view
operator|->
name|viewportTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|updateRectF
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|updatedRects
operator|<<
name|rect
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|calledEmitUpdated
condition|)
block|{
name|d
operator|->
name|calledEmitUpdated
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_emitUpdated"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsScene::update(qreal x, qreal y, qreal w, qreal h)     \overload     \since 4.3      This function is equivalent to calling update(QRectF(\a x, \a y, \a w,     \a h)); */
end_comment
begin_comment
comment|/*!     Invalidates and schedules a redraw of the \a layers in \a rect on the     scene. Any cached content in \a layers is unconditionally invalidated and     redrawn.      You can use this function overload to notify QGraphicsScene of changes to     the background or the foreground of the scene. This function is commonly     used for scenes with tile-based backgrounds to notify changes when     QGraphicsView has enabled     \l{QGraphicsView::CacheBackground}{CacheBackground}.      Example:      \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 5      Note that QGraphicsView currently supports background caching only (see     QGraphicsView::CacheBackground). This function is equivalent to calling     update() if any layer but BackgroundLayer is passed.      \sa QGraphicsView::resetCachedContent() */
end_comment
begin_function
DECL|function|invalidate
name|void
name|QGraphicsScene
operator|::
name|invalidate
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|SceneLayers
name|layers
parameter_list|)
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
argument_list|()
control|)
name|view
operator|->
name|invalidateScene
argument_list|(
name|rect
argument_list|,
name|layers
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsScene::invalidate(qreal x, qreal y, qreal w, qreal h, SceneLayers layers)     \overload     \since 4.3      This convenience function is equivalent to calling invalidate(QRectF(\a x, \a     y, \a w, \a h), \a layers); */
end_comment
begin_comment
comment|/*!     Returns a list of all the views that display this scene.      \sa QGraphicsView::scene() */
end_comment
begin_function
DECL|function|views
name|QList
argument_list|<
name|QGraphicsView
modifier|*
argument_list|>
name|QGraphicsScene
operator|::
name|views
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|views
return|;
block|}
end_function
begin_comment
comment|/*!     This slot \e advances the scene by one step, by calling     QGraphicsItem::advance() for all items on the scene. This is done in two     phases: in the first phase, all items are notified that the scene is about     to change, and in the second phase all items are notified that they can     move. In the first phase, QGraphicsItem::advance() is called passing a     value of 0 as an argument, and 1 is passed in the second phase.      Note that you can also use the \l{The Animation Framework}{Animation     Framework} for animations.      \sa QGraphicsItem::advance(), QTimeLine */
end_comment
begin_function
DECL|function|advance
name|void
name|QGraphicsScene
operator|::
name|advance
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|()
control|)
name|item
operator|->
name|advance
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Processes the event \a event, and dispatches it to the respective     event handlers.      In addition to calling the convenience event handlers, this     function is responsible for converting mouse move events to hover     events for when there is no mouse grabber item. Hover events are     delivered directly to items; there is no convenience function for     them.      Unlike QWidget, QGraphicsScene does not have the convenience functions     \l{QWidget::}{enterEvent()} and \l{QWidget::}{leaveEvent()}. Use this     function to obtain those events instead.      \sa contextMenuEvent(), keyPressEvent(), keyReleaseEvent(),     mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(),     mouseDoubleClickEvent(), focusInEvent(), focusOutEvent() */
end_comment
begin_function
DECL|function|event
name|bool
name|QGraphicsScene
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
comment|// Reset the under-mouse list to ensure that this event gets fresh
comment|// item-under-mouse data. Be careful about this list; if people delete
comment|// items from inside event handlers, this list can quickly end up
comment|// having stale pointers in it. We need to clear it before dispatching
comment|// events that use it.
comment|// ### this should only be cleared if we received a new mouse move event,
comment|// which relies on us fixing the replay mechanism in QGraphicsView.
name|d
operator|->
name|cachedItemsUnderMouse
operator|.
name|clear
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|GraphicsSceneDragEnter
case|:
name|dragEnterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDragMove
case|:
name|dragMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDragLeave
case|:
name|dragLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDrop
case|:
name|dropEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneContextMenu
case|:
name|contextMenuEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|KeyPress
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|focusItem
condition|)
block|{
name|QKeyEvent
modifier|*
name|k
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator|)
operator|)
condition|)
block|{
comment|//### Add MetaModifier?
name|bool
name|res
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
operator|||
operator|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|&&
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|)
condition|)
block|{
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
condition|)
block|{
name|res
operator|=
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|res
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
name|keyPressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|keyReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
block|{
name|QGraphicsItem
modifier|*
name|parent
init|=
name|focusItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|d
operator|->
name|sendEvent
argument_list|(
name|parent
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
return|return
literal|true
return|;
name|parent
operator|=
name|parent
operator|->
name|parentItem
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
block|{
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|d
operator|->
name|lastSceneMousePos
operator|=
name|mouseEvent
operator|->
name|scenePos
argument_list|()
expr_stmt|;
name|mouseMoveEvent
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
name|mousePressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
name|mouseReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
name|mouseDoubleClickEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneWheel
case|:
name|wheelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneWheelEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusIn
case|:
name|focusInEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|FocusOut
case|:
name|focusOutEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
block|{
name|QGraphicsSceneHoverEvent
modifier|*
name|hoverEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|d
operator|->
name|lastSceneMousePos
operator|=
name|hoverEvent
operator|->
name|scenePos
argument_list|()
expr_stmt|;
name|d
operator|->
name|dispatchHoverEvent
argument_list|(
name|hoverEvent
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|Leave
case|:
comment|// hackieshly unpacking the viewport pointer from the leave event.
name|d
operator|->
name|leaveScene
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|event
operator|->
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHelp
case|:
name|helpEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHelpEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|InputMethod
case|:
name|inputMethodEvent
argument_list|(
cast|static_cast
argument_list|<
name|QInputMethodEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|activationRefCount
operator|++
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|lastActivePanel
condition|)
block|{
comment|// Activate the last panel.
name|d
operator|->
name|setActivePanelHelper
argument_list|(
name|d
operator|->
name|lastActivePanel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|tabFocusFirst
operator|&&
name|d
operator|->
name|tabFocusFirst
operator|->
name|isPanel
argument_list|()
condition|)
block|{
comment|// Activate the panel of the first item in the tab focus
comment|// chain.
name|d
operator|->
name|setActivePanelHelper
argument_list|(
name|d
operator|->
name|tabFocusFirst
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Activate all toplevel items.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowActivate
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
if|if
condition|(
operator|!
operator|--
name|d
operator|->
name|activationRefCount
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|activePanel
condition|)
block|{
comment|// Deactivate the active panel (but keep it so we can
comment|// reactivate it later).
name|QGraphicsItem
modifier|*
name|lastActivePanel
init|=
name|d
operator|->
name|activePanel
decl_stmt|;
name|d
operator|->
name|setActivePanelHelper
argument_list|(
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastActivePanel
operator|=
name|lastActivePanel
expr_stmt|;
block|}
else|else
block|{
comment|// Activate all toplevel items.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WindowDeactivate
argument_list|)
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
operator|!
name|item
operator|->
name|parentItem
argument_list|()
condition|)
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QEvent
operator|::
name|ApplicationFontChange
case|:
block|{
comment|// Resolve the existing scene font.
name|d
operator|->
name|resolveFont
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|FontChange
case|:
comment|// Update the entire scene when the font changes.
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ApplicationPaletteChange
case|:
block|{
comment|// Resolve the existing scene palette.
name|d
operator|->
name|resolvePalette
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|PaletteChange
case|:
comment|// Update the entire scene when the palette changes.
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleChange
case|:
comment|// Reresolve all widgets' styles. Update all top-level widgets'
comment|// geometries that do not have an explicit style set.
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleAnimationUpdate
case|:
comment|// Because QGraphicsItem is not a QObject, QStyle driven
comment|// animations are forced to update the whole scene
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
case|case
name|QEvent
operator|::
name|TouchUpdate
case|:
case|case
name|QEvent
operator|::
name|TouchEnd
case|:
name|d
operator|->
name|touchEventHandler
argument_list|(
cast|static_cast
argument_list|<
name|QTouchEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
case|case
name|QEvent
operator|::
name|Gesture
case|:
case|case
name|QEvent
operator|::
name|GestureOverride
case|:
name|d
operator|->
name|gestureEventHandler
argument_list|(
cast|static_cast
argument_list|<
name|QGestureEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_GESTURES
default|default:
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      QGraphicsScene filters QApplication's events to detect palette and font     changes. */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QGraphicsScene
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
name|watched
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|watched
operator|!=
name|qApp
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ApplicationPaletteChange
case|:
name|QApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|ApplicationPaletteChange
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ApplicationFontChange
case|:
name|QApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|ApplicationFontChange
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a contextMenuEvent, can be reimplemented in     a subclass to receive context menu events. The default implementation     forwards the event to the topmost visible item that accepts context menu events at     the position of the event. If no items accept context menu events at this     position, the event is ignored.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::contextMenuEvent() */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QGraphicsScene
operator|::
name|contextMenuEvent
parameter_list|(
name|QGraphicsSceneContextMenuEvent
modifier|*
name|contextMenuEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Ignore by default.
name|contextMenuEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
comment|// Send the event to all items at this position until one item accepts the
comment|// event.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|d
operator|->
name|itemsAtPosition
argument_list|(
name|contextMenuEvent
operator|->
name|screenPos
argument_list|()
argument_list|,
name|contextMenuEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|contextMenuEvent
operator|->
name|widget
argument_list|()
argument_list|)
control|)
block|{
name|contextMenuEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|contextMenuEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|contextMenuEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|contextMenuEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|sendEvent
argument_list|(
name|item
argument_list|,
name|contextMenuEvent
argument_list|)
condition|)
break|break;
if|if
condition|(
name|contextMenuEvent
operator|->
name|isAccepted
argument_list|()
condition|)
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented in a subclass     to receive drag enter events for the scene.      The default implementation accepts the event and prepares the scene to     accept drag move events.      \sa QGraphicsItem::dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(),     dropEvent() */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QGraphicsScene
operator|::
name|dragEnterEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragDropItem
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|lastDropAction
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented in a subclass     to receive drag move events for the scene.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::dragMoveEvent(), dragEnterEvent(), dragLeaveEvent(),     dropEvent() */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QGraphicsScene
operator|::
name|dragMoveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Mouse grabbers that start drag events lose the mouse grab.
name|d
operator|->
name|clearMouseGrabber
argument_list|()
expr_stmt|;
name|d
operator|->
name|mouseGrabberButtonDownPos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|mouseGrabberButtonDownScenePos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|mouseGrabberButtonDownScreenPos
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|bool
name|eventDelivered
init|=
literal|false
decl_stmt|;
comment|// Find the topmost enabled items under the cursor. They are all
comment|// candidates for accepting drag& drop events.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|d
operator|->
name|itemsAtPosition
argument_list|(
name|event
operator|->
name|screenPos
argument_list|()
argument_list|,
name|event
operator|->
name|scenePos
argument_list|()
argument_list|,
name|event
operator|->
name|widget
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isEnabled
argument_list|()
operator|||
operator|!
name|item
operator|->
name|acceptDrops
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|item
operator|!=
name|d
operator|->
name|dragDropItem
condition|)
block|{
comment|// Enter the new drag drop item. If it accepts the event, we send
comment|// the leave to the parent item.
name|QGraphicsSceneDragDropEvent
name|dragEnter
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragEnter
argument_list|)
decl_stmt|;
name|d
operator|->
name|cloneDragDropEvent
argument_list|(
operator|&
name|dragEnter
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|dragEnter
operator|.
name|setDropAction
argument_list|(
name|event
operator|->
name|proposedAction
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|item
argument_list|,
operator|&
name|dragEnter
argument_list|)
expr_stmt|;
name|event
operator|->
name|setAccepted
argument_list|(
name|dragEnter
operator|.
name|isAccepted
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|->
name|setDropAction
argument_list|(
name|dragEnter
operator|.
name|dropAction
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
block|{
comment|// Propagate to the item under
continue|continue;
block|}
name|d
operator|->
name|lastDropAction
operator|=
name|event
operator|->
name|dropAction
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dragDropItem
condition|)
block|{
comment|// Leave the last drag drop item. A perfect implementation
comment|// would set the position of this event to the point where
comment|// this event and the last event intersect with the item's
comment|// shape, but that's not easy to do. :-)
name|QGraphicsSceneDragDropEvent
name|dragLeave
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragLeave
argument_list|)
decl_stmt|;
name|d
operator|->
name|cloneDragDropEvent
argument_list|(
operator|&
name|dragLeave
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|d
operator|->
name|dragDropItem
argument_list|,
operator|&
name|dragLeave
argument_list|)
expr_stmt|;
block|}
comment|// We've got a new drag& drop item
name|d
operator|->
name|dragDropItem
operator|=
name|item
expr_stmt|;
block|}
comment|// Send the move event.
name|event
operator|->
name|setDropAction
argument_list|(
name|d
operator|->
name|lastDropAction
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|item
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|d
operator|->
name|lastDropAction
operator|=
name|event
operator|->
name|dropAction
argument_list|()
expr_stmt|;
name|eventDelivered
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|eventDelivered
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|dragDropItem
condition|)
block|{
comment|// Leave the last drag drop item
name|QGraphicsSceneDragDropEvent
name|dragLeave
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneDragLeave
argument_list|)
decl_stmt|;
name|d
operator|->
name|cloneDragDropEvent
argument_list|(
operator|&
name|dragLeave
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|d
operator|->
name|dragDropItem
argument_list|,
operator|&
name|dragLeave
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragDropItem
operator|=
literal|0
expr_stmt|;
block|}
comment|// Propagate
name|event
operator|->
name|setDropAction
argument_list|(
name|Qt
operator|::
name|IgnoreAction
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented in a subclass     to receive drag leave events for the scene.      \sa QGraphicsItem::dragLeaveEvent(), dragEnterEvent(), dragMoveEvent(),     dropEvent() */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QGraphicsScene
operator|::
name|dragLeaveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dragDropItem
condition|)
block|{
comment|// Leave the last drag drop item
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|d
operator|->
name|dragDropItem
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragDropItem
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented in a subclass     to receive drop events for the scene.      \sa QGraphicsItem::dropEvent(), dragEnterEvent(), dragMoveEvent(),     dragLeaveEvent() */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QGraphicsScene
operator|::
name|dropEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dragDropItem
condition|)
block|{
comment|// Drop on the last drag drop item
name|d
operator|->
name|sendDragDropEvent
argument_list|(
name|d
operator|->
name|dragDropItem
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|d
operator|->
name|dragDropItem
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a focusEvent, can be reimplemented in a     subclass to receive focus in events.      The default implementation sets focus on the scene, and then on the last     focus item.      \sa QGraphicsItem::focusOutEvent() */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QGraphicsScene
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|focusEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasFocus
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|focusEvent
operator|->
name|reason
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|TabFocusReason
case|:
if|if
condition|(
operator|!
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
condition|)
name|focusEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|BacktabFocusReason
case|:
if|if
condition|(
operator|!
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
condition|)
name|focusEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|d
operator|->
name|passiveFocusItem
condition|)
block|{
comment|// Set focus on the last focus item
name|setFocusItem
argument_list|(
name|d
operator|->
name|passiveFocusItem
argument_list|,
name|focusEvent
operator|->
name|reason
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a focusEvent, can be reimplemented in a     subclass to receive focus out events.      The default implementation removes focus from any focus item, then removes     focus from the scene.      \sa QGraphicsItem::focusInEvent() */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QGraphicsScene
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|focusEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasFocus
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|passiveFocusItem
operator|=
name|d
operator|->
name|focusItem
expr_stmt|;
name|setFocusItem
argument_list|(
literal|0
argument_list|,
name|focusEvent
operator|->
name|reason
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove all popups when the scene loses focus.
if|if
condition|(
operator|!
name|d
operator|->
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|removePopup
argument_list|(
name|d
operator|->
name|popupWidgets
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a helpEvent, can be     reimplemented in a subclass to receive help events. The events     are of type QEvent::ToolTip, which are created when a tooltip is     requested.      The default implementation shows the tooltip of the topmost     visible item, i.e., the item with the highest z-value, at the mouse     cursor position. If no item has a tooltip set, this function     does nothing.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::toolTip(), QGraphicsSceneHelpEvent */
end_comment
begin_function
DECL|function|helpEvent
name|void
name|QGraphicsScene
operator|::
name|helpEvent
parameter_list|(
name|QGraphicsSceneHelpEvent
modifier|*
name|helpEvent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TOOLTIP
name|Q_UNUSED
argument_list|(
name|helpEvent
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Find the first item that does tooltips
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemsAtPos
init|=
name|d
operator|->
name|itemsAtPosition
argument_list|(
name|helpEvent
operator|->
name|screenPos
argument_list|()
argument_list|,
name|helpEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|helpEvent
operator|->
name|widget
argument_list|()
argument_list|)
decl_stmt|;
name|QGraphicsItem
modifier|*
name|toolTipItem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|itemsAtPos
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|tmp
init|=
name|itemsAtPos
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|->
name|d_func
argument_list|()
operator|->
name|isProxyWidget
argument_list|()
condition|)
block|{
comment|// if the item is a proxy widget, the event is forwarded to it
name|sendEvent
argument_list|(
name|tmp
argument_list|,
name|helpEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|helpEvent
operator|->
name|isAccepted
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|tmp
operator|->
name|toolTip
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|toolTipItem
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
comment|// Show or hide the tooltip
name|QString
name|text
decl_stmt|;
name|QPoint
name|point
decl_stmt|;
if|if
condition|(
name|toolTipItem
operator|&&
operator|!
name|toolTipItem
operator|->
name|toolTip
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|text
operator|=
name|toolTipItem
operator|->
name|toolTip
argument_list|()
expr_stmt|;
name|point
operator|=
name|helpEvent
operator|->
name|screenPos
argument_list|()
expr_stmt|;
block|}
name|QToolTip
operator|::
name|showText
argument_list|(
name|point
argument_list|,
name|text
argument_list|,
name|helpEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|helpEvent
operator|->
name|setAccepted
argument_list|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|itemAcceptsHoverEvents_helper
name|bool
name|QGraphicsScenePrivate
operator|::
name|itemAcceptsHoverEvents_helper
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|acceptsHover
operator|||
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|isWidget
operator|&&
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|hasDecoration
argument_list|()
operator|)
operator|)
operator|&&
operator|!
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a hoverEvent, can be reimplemented in a     subclass to receive hover enter events. The default implementation     forwards the event to the topmost visible item that accepts hover events at the     scene position from the event.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::hoverEvent(), QGraphicsItem::setAcceptHoverEvents() */
end_comment
begin_function
DECL|function|dispatchHoverEvent
name|bool
name|QGraphicsScenePrivate
operator|::
name|dispatchHoverEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|hoverEvent
parameter_list|)
block|{
if|if
condition|(
name|allItemsIgnoreHoverEvents
condition|)
return|return
literal|false
return|;
comment|// Find the first item that accepts hover events, reusing earlier
comment|// calculated data is possible.
if|if
condition|(
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cachedItemsUnderMouse
operator|=
name|itemsAtPosition
argument_list|(
name|hoverEvent
operator|->
name|screenPos
argument_list|()
argument_list|,
name|hoverEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|hoverEvent
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QGraphicsItem
modifier|*
name|item
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cachedItemsUnderMouse
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|tmp
init|=
name|cachedItemsUnderMouse
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemAcceptsHoverEvents_helper
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|item
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
comment|// Find the common ancestor item for the new topmost hoverItem and the
comment|// last item in the hoverItem list.
name|QGraphicsItem
modifier|*
name|commonAncestorItem
init|=
operator|(
name|item
operator|&&
operator|!
name|hoverItems
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|item
operator|->
name|commonAncestorItem
argument_list|(
name|hoverItems
operator|.
name|last
argument_list|()
argument_list|)
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|commonAncestorItem
operator|&&
operator|!
name|itemAcceptsHoverEvents_helper
argument_list|(
name|commonAncestorItem
argument_list|)
condition|)
name|commonAncestorItem
operator|=
name|commonAncestorItem
operator|->
name|parentItem
argument_list|()
expr_stmt|;
if|if
condition|(
name|commonAncestorItem
operator|&&
name|commonAncestorItem
operator|->
name|panel
argument_list|()
operator|!=
name|item
operator|->
name|panel
argument_list|()
condition|)
block|{
comment|// The common ancestor isn't in the same panel as the two hovered
comment|// items.
name|commonAncestorItem
operator|=
literal|0
expr_stmt|;
block|}
comment|// Check if the common ancestor item is known.
name|int
name|index
init|=
name|commonAncestorItem
condition|?
name|hoverItems
operator|.
name|indexOf
argument_list|(
name|commonAncestorItem
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
comment|// Send hover leaves to any existing hovered children of the common
comment|// ancestor item.
for|for
control|(
name|int
name|i
init|=
name|hoverItems
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
name|index
condition|;
operator|--
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|lastItem
init|=
name|hoverItems
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|itemAcceptsHoverEvents_helper
argument_list|(
name|lastItem
argument_list|)
condition|)
name|sendHoverEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
argument_list|,
name|lastItem
argument_list|,
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
comment|// Item is a child of a known item. Generate enter events for the
comment|// missing links.
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|parents
decl_stmt|;
name|QGraphicsItem
modifier|*
name|parent
init|=
name|item
decl_stmt|;
while|while
condition|(
name|parent
operator|&&
name|parent
operator|!=
name|commonAncestorItem
condition|)
block|{
name|parents
operator|.
name|prepend
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|isPanel
argument_list|()
condition|)
block|{
comment|// Stop at the panel - we don't deliver beyond this point.
break|break;
block|}
name|parent
operator|=
name|parent
operator|->
name|parentItem
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|parent
operator|=
name|parents
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|hoverItems
operator|<<
name|parent
expr_stmt|;
if|if
condition|(
name|itemAcceptsHoverEvents_helper
argument_list|(
name|parent
argument_list|)
condition|)
name|sendHoverEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
argument_list|,
name|parent
argument_list|,
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
comment|// Generate a move event for the item itself
if|if
condition|(
name|item
operator|&&
operator|!
name|hoverItems
operator|.
name|isEmpty
argument_list|()
operator|&&
name|item
operator|==
name|hoverItems
operator|.
name|last
argument_list|()
condition|)
block|{
name|sendHoverEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneHoverMove
argument_list|,
name|item
argument_list|,
name|hoverEvent
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Handles all actions necessary to clean up the scene when the mouse leaves     the view. */
end_comment
begin_function
DECL|function|leaveScene
name|void
name|QGraphicsScenePrivate
operator|::
name|leaveScene
parameter_list|(
name|QWidget
modifier|*
name|viewport
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TOOLTIP
name|QToolTip
operator|::
name|hideText
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QGraphicsView
modifier|*
name|view
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|viewport
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
comment|// Send HoverLeave events to all existing hover items, topmost first.
name|QGraphicsSceneHoverEvent
name|hoverEvent
decl_stmt|;
name|hoverEvent
operator|.
name|setWidget
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
if|if
condition|(
name|view
condition|)
block|{
name|QPoint
name|cursorPos
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
name|hoverEvent
operator|.
name|setScenePos
argument_list|(
name|view
operator|->
name|mapToScene
argument_list|(
name|viewport
operator|->
name|mapFromGlobal
argument_list|(
name|cursorPos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hoverEvent
operator|.
name|setLastScenePos
argument_list|(
name|hoverEvent
operator|.
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
name|hoverEvent
operator|.
name|setScreenPos
argument_list|(
name|cursorPos
argument_list|)
expr_stmt|;
name|hoverEvent
operator|.
name|setLastScreenPos
argument_list|(
name|hoverEvent
operator|.
name|screenPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|hoverItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|lastItem
init|=
name|hoverItems
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
name|itemAcceptsHoverEvents_helper
argument_list|(
name|lastItem
argument_list|)
condition|)
name|sendHoverEvent
argument_list|(
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
argument_list|,
name|lastItem
argument_list|,
operator|&
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a keyEvent, can be reimplemented in a     subclass to receive keypress events. The default implementation forwards     the event to current focus item.      \sa QGraphicsItem::keyPressEvent(), focusItem() */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QGraphicsScene
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|keyEvent
parameter_list|)
block|{
comment|// ### Merge this function with keyReleaseEvent; they are identical
comment|// ### (except this comment).
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|item
init|=
operator|!
name|d
operator|->
name|keyboardGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|item
operator|=
name|focusItem
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|item
decl_stmt|;
do|do
block|{
comment|// Accept the event by default
name|keyEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// Send it; QGraphicsItem::keyPressEvent ignores it.  If the event
comment|// is filtered out, stop propagating it.
if|if
condition|(
name|p
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
name|d
operator|->
name|sendEvent
argument_list|(
name|p
argument_list|,
name|keyEvent
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|keyEvent
operator|->
name|isAccepted
argument_list|()
operator|&&
operator|!
name|p
operator|->
name|isPanel
argument_list|()
operator|&&
operator|(
name|p
operator|=
name|p
operator|->
name|parentItem
argument_list|()
operator|)
condition|)
do|;
block|}
else|else
block|{
name|keyEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a keyEvent, can be reimplemented in a     subclass to receive key release events. The default implementation     forwards the event to current focus item.      \sa QGraphicsItem::keyReleaseEvent(), focusItem() */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QGraphicsScene
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|keyEvent
parameter_list|)
block|{
comment|// ### Merge this function with keyPressEvent; they are identical (except
comment|// ### this comment).
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|item
init|=
operator|!
name|d
operator|->
name|keyboardGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|keyboardGrabberItems
operator|.
name|last
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|item
operator|=
name|focusItem
argument_list|()
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|item
decl_stmt|;
do|do
block|{
comment|// Accept the event by default
name|keyEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// Send it; QGraphicsItem::keyPressEvent ignores it.  If the event
comment|// is filtered out, stop propagating it.
if|if
condition|(
name|p
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
name|d
operator|->
name|sendEvent
argument_list|(
name|p
argument_list|,
name|keyEvent
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|keyEvent
operator|->
name|isAccepted
argument_list|()
operator|&&
operator|!
name|p
operator|->
name|isPanel
argument_list|()
operator|&&
operator|(
name|p
operator|=
name|p
operator|->
name|parentItem
argument_list|()
operator|)
condition|)
do|;
block|}
else|else
block|{
name|keyEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a mouseEvent, can be reimplemented     in a subclass to receive mouse press events for the scene.      The default implementation depends on the state of the scene. If     there is a mouse grabber item, then the event is sent to the mouse     grabber. Otherwise, it is forwarded to the topmost visible item that     accepts mouse events at the scene position from the event, and     that item promptly becomes the mouse grabber item.      If there is no item at the given position on the scene, the     selection area is reset, any focus item loses its input focus, and     the event is then ignored.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::mousePressEvent(),     QGraphicsItem::setAcceptedMouseButtons() */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QGraphicsScene
operator|::
name|mousePressEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Dispatch hover events
name|QGraphicsSceneHoverEvent
name|hover
decl_stmt|;
name|_q_hoverFromMouseEvent
argument_list|(
operator|&
name|hover
argument_list|,
name|mouseEvent
argument_list|)
expr_stmt|;
name|d
operator|->
name|dispatchHoverEvent
argument_list|(
operator|&
name|hover
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|mousePressEventHandler
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a mouseEvent, can be reimplemented     in a subclass to receive mouse move events for the scene.      The default implementation depends on the mouse grabber state. If there is     a mouse grabber item, the event is sent to the mouse grabber.  If there     are any items that accept hover events at the current position, the event     is translated into a hover event and accepted; otherwise it's ignored.      \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseReleaseEvent(),     QGraphicsItem::mouseDoubleClickEvent(), QGraphicsItem::setAcceptedMouseButtons() */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QGraphicsScene
operator|::
name|mouseMoveEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|mouseEvent
operator|->
name|buttons
argument_list|()
condition|)
return|return;
name|QGraphicsSceneHoverEvent
name|hover
decl_stmt|;
name|_q_hoverFromMouseEvent
argument_list|(
operator|&
name|hover
argument_list|,
name|mouseEvent
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setAccepted
argument_list|(
name|d
operator|->
name|dispatchHoverEvent
argument_list|(
operator|&
name|hover
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Forward the event to the mouse grabber
name|d
operator|->
name|sendMouseEvent
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a mouseEvent, can be reimplemented     in a subclass to receive mouse release events for the scene.      The default implementation depends on the mouse grabber state.  If     there is no mouse grabber, the event is ignored.  Otherwise, if     there is a mouse grabber item, the event is sent to the mouse     grabber. If this mouse release represents the last pressed button     on the mouse, the mouse grabber item then loses the mouse grab.      \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseMoveEvent(),     QGraphicsItem::mouseDoubleClickEvent(), QGraphicsItem::setAcceptedMouseButtons() */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QGraphicsScene
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mouseEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Forward the event to the mouse grabber
name|d
operator|->
name|sendMouseEvent
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
comment|// Reset the mouse grabber when the last mouse button has been released.
if|if
condition|(
operator|!
name|mouseEvent
operator|->
name|buttons
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|lastMouseGrabberItem
operator|=
name|d
operator|->
name|mouseGrabberItems
operator|.
name|last
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
name|d
operator|->
name|mouseGrabberItems
operator|.
name|last
argument_list|()
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|lastMouseGrabberItem
operator|=
literal|0
expr_stmt|;
block|}
comment|// Generate a hoverevent
name|QGraphicsSceneHoverEvent
name|hoverEvent
decl_stmt|;
name|_q_hoverFromMouseEvent
argument_list|(
operator|&
name|hoverEvent
argument_list|,
name|mouseEvent
argument_list|)
expr_stmt|;
name|d
operator|->
name|dispatchHoverEvent
argument_list|(
operator|&
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a mouseEvent, can be reimplemented     in a subclass to receive mouse doubleclick events for the scene.      If someone doubleclicks on the scene, the scene will first receive     a mouse press event, followed by a release event (i.e., a click),     then a doubleclick event, and finally a release event. If the     doubleclick event is delivered to a different item than the one     that received the first press and release, it will be delivered as     a press event. However, tripleclick events are not delivered as     doubleclick events in this case.      The default implementation is similar to mousePressEvent().      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseMoveEvent(),     QGraphicsItem::mouseReleaseEvent(), QGraphicsItem::setAcceptedMouseButtons() */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QGraphicsScene
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|mousePressEventHandler
argument_list|(
name|mouseEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a wheelEvent, can be reimplemented in a     subclass to receive mouse wheel events for the scene.      By default, the event is delivered to the topmost visible item under the     cursor. If ignored, the event propagates to the item beneath, and again     until the event is accepted, or it reaches the scene. If no items accept     the event, it is ignored.      Note: See items() for a definition of which items are considered visible by this function.      \sa QGraphicsItem::wheelEvent() */
end_comment
begin_function
DECL|function|wheelEvent
name|void
name|QGraphicsScene
operator|::
name|wheelEvent
parameter_list|(
name|QGraphicsSceneWheelEvent
modifier|*
name|wheelEvent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|wheelCandidates
init|=
name|d
operator|->
name|itemsAtPosition
argument_list|(
name|wheelEvent
operator|->
name|screenPos
argument_list|()
argument_list|,
name|wheelEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|wheelEvent
operator|->
name|widget
argument_list|()
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// On Mac, ignore the event if the first item under the mouse is not the last opened
comment|// popup (or one of its descendant)
if|if
condition|(
operator|!
name|d
operator|->
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|wheelCandidates
operator|.
name|isEmpty
argument_list|()
operator|&&
name|wheelCandidates
operator|.
name|first
argument_list|()
operator|!=
name|d
operator|->
name|popupWidgets
operator|.
name|back
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|popupWidgets
operator|.
name|back
argument_list|()
operator|->
name|isAncestorOf
argument_list|(
name|wheelCandidates
operator|.
name|first
argument_list|()
argument_list|)
condition|)
block|{
name|wheelEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|// Find the first popup under the mouse (including the popup's descendants) starting from the last.
comment|// Remove all popups after the one found, or all or them if no popup is under the mouse.
comment|// Then continue with the event.
name|QList
argument_list|<
name|QGraphicsWidget
modifier|*
argument_list|>
operator|::
name|const_iterator
name|iter
init|=
name|d
operator|->
name|popupWidgets
operator|.
name|constEnd
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|iter
operator|>=
name|d
operator|->
name|popupWidgets
operator|.
name|constBegin
argument_list|()
operator|&&
operator|!
name|wheelCandidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|wheelCandidates
operator|.
name|first
argument_list|()
operator|==
operator|*
name|iter
operator|||
operator|(
operator|*
name|iter
operator|)
operator|->
name|isAncestorOf
argument_list|(
name|wheelCandidates
operator|.
name|first
argument_list|()
argument_list|)
condition|)
break|break;
name|d
operator|->
name|removePopup
argument_list|(
operator|*
name|iter
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bool
name|hasSetFocus
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|wheelCandidates
control|)
block|{
if|if
condition|(
operator|!
name|hasSetFocus
operator|&&
name|item
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|)
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|mouseSetsFocus
operator|)
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
operator|&&
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|focusPolicy
argument_list|()
operator|==
name|Qt
operator|::
name|WheelFocus
condition|)
block|{
name|hasSetFocus
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|focusItem
argument_list|()
condition|)
name|setFocusItem
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
block|}
block|}
name|wheelEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|wheelEvent
operator|->
name|scenePos
argument_list|()
argument_list|,
name|wheelEvent
operator|->
name|widget
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|wheelEvent
operator|->
name|accept
argument_list|()
expr_stmt|;
name|bool
name|isPanel
init|=
name|item
operator|->
name|isPanel
argument_list|()
decl_stmt|;
name|d
operator|->
name|sendEvent
argument_list|(
name|item
argument_list|,
name|wheelEvent
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPanel
operator|||
name|wheelEvent
operator|->
name|isAccepted
argument_list|()
condition|)
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented in a     subclass to receive input method events for the scene.      The default implementation forwards the event to the focusItem().     If no item currently has focus or the current focus item does not     accept input methods, this function does nothing.      \sa QGraphicsItem::inputMethodEvent() */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QGraphicsScene
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|focusItem
operator|&&
operator|(
name|d
operator|->
name|focusItem
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
operator|)
condition|)
name|d
operator|->
name|sendEvent
argument_list|(
name|d
operator|->
name|focusItem
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Draws the background of the scene using \a painter, before any items and     the foreground are drawn. Reimplement this function to provide a custom     background for the scene.      All painting is done in \e scene coordinates. The \a rect     parameter is the exposed rectangle.      If all you want is to define a color, texture, or gradient for the     background, you can call setBackgroundBrush() instead.      \sa drawForeground(), drawItems() */
end_comment
begin_function
DECL|function|drawBackground
name|void
name|QGraphicsScene
operator|::
name|drawBackground
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|backgroundBrush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|painterStateProtection
condition|)
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|painter
operator|->
name|fillRect
argument_list|(
name|rect
argument_list|,
name|backgroundBrush
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|painterStateProtection
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Draws the foreground of the scene using \a painter, after the background     and all items have been drawn. Reimplement this function to provide a     custom foreground for the scene.      All painting is done in \e scene coordinates. The \a rect     parameter is the exposed rectangle.      If all you want is to define a color, texture or gradient for the     foreground, you can call setForegroundBrush() instead.      \sa drawBackground(), drawItems() */
end_comment
begin_function
DECL|function|drawForeground
name|void
name|QGraphicsScene
operator|::
name|drawForeground
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|foregroundBrush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|painterStateProtection
condition|)
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|painter
operator|->
name|fillRect
argument_list|(
name|rect
argument_list|,
name|foregroundBrush
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|painterStateProtection
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_paintItem
specifier|static
name|void
name|_q_paintItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|,
name|bool
name|useWindowOpacity
parameter_list|,
name|bool
name|painterStateProtection
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|item
operator|->
name|paint
argument_list|(
name|painter
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsWidget
modifier|*
name|widgetItem
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|widgetItem
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|windowOpacity
init|=
operator|(
name|proxy
operator|&&
name|proxy
operator|->
name|widget
argument_list|()
operator|&&
name|useWindowOpacity
operator|)
condition|?
name|proxy
operator|->
name|widget
argument_list|()
operator|->
name|windowOpacity
argument_list|()
else|:
literal|1.0
decl_stmt|;
specifier|const
name|qreal
name|oldPainterOpacity
init|=
name|painter
operator|->
name|opacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|windowOpacity
argument_list|)
condition|)
return|return;
comment|// Set new painter opacity.
if|if
condition|(
name|windowOpacity
operator|<
literal|1.0
condition|)
name|painter
operator|->
name|setOpacity
argument_list|(
name|oldPainterOpacity
operator|*
name|windowOpacity
argument_list|)
expr_stmt|;
comment|// set layoutdirection on the painter
name|Qt
operator|::
name|LayoutDirection
name|oldLayoutDirection
init|=
name|painter
operator|->
name|layoutDirection
argument_list|()
decl_stmt|;
name|painter
operator|->
name|setLayoutDirection
argument_list|(
name|widgetItem
operator|->
name|layoutDirection
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|widgetItem
operator|->
name|isWindow
argument_list|()
operator|&&
name|widgetItem
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Popup
operator|&&
name|widgetItem
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|ToolTip
operator|&&
operator|!
operator|(
name|widgetItem
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|FramelessWindowHint
operator|)
condition|)
block|{
if|if
condition|(
name|painterStateProtection
condition|)
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|widgetItem
operator|->
name|paintWindowFrame
argument_list|(
name|painter
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|painterStateProtection
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|widgetItem
operator|->
name|autoFillBackground
argument_list|()
condition|)
block|{
name|painter
operator|->
name|fillRect
argument_list|(
name|option
operator|->
name|exposedRect
argument_list|,
name|widgetItem
operator|->
name|palette
argument_list|()
operator|.
name|window
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|widgetItem
operator|->
name|paint
argument_list|(
name|painter
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
comment|// Restore layoutdirection on the painter.
name|painter
operator|->
name|setLayoutDirection
argument_list|(
name|oldLayoutDirection
argument_list|)
expr_stmt|;
comment|// Restore painter opacity.
if|if
condition|(
name|windowOpacity
operator|<
literal|1.0
condition|)
name|painter
operator|->
name|setOpacity
argument_list|(
name|oldPainterOpacity
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_paintIntoCache
specifier|static
name|void
name|_q_paintIntoCache
parameter_list|(
name|QPixmap
modifier|*
name|pix
parameter_list|,
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|pixmapExposed
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|itemToPixmap
parameter_list|,
name|QPainter
operator|::
name|RenderHints
name|renderHints
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|bool
name|painterStateProtection
parameter_list|)
block|{
name|QPixmap
name|subPix
decl_stmt|;
name|QPainter
name|pixmapPainter
decl_stmt|;
name|QRect
name|br
init|=
name|pixmapExposed
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
comment|// Don't use subpixmap if we get a full update.
if|if
condition|(
name|pixmapExposed
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|pixmapExposed
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
operator|&&
name|br
operator|.
name|contains
argument_list|(
name|pix
operator|->
name|rect
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|pix
operator|->
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|begin
argument_list|(
name|pix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subPix
operator|=
name|QPixmap
argument_list|(
name|br
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|subPix
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|begin
argument_list|(
operator|&
name|subPix
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|translate
argument_list|(
operator|-
name|br
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pixmapExposed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Applied to subPix; paint is adjusted to the coordinate space is
comment|// correct.
name|pixmapPainter
operator|.
name|setClipRegion
argument_list|(
name|pixmapExposed
argument_list|)
expr_stmt|;
block|}
block|}
name|pixmapPainter
operator|.
name|setRenderHints
argument_list|(
name|pixmapPainter
operator|.
name|renderHints
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|setRenderHints
argument_list|(
name|renderHints
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|setWorldTransform
argument_list|(
name|itemToPixmap
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Render.
name|_q_paintItem
argument_list|(
name|item
argument_list|,
operator|&
name|pixmapPainter
argument_list|,
name|option
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|end
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|subPix
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Blit the subpixmap into the main pixmap.
name|pixmapPainter
operator|.
name|begin
argument_list|(
name|pix
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|setClipRegion
argument_list|(
name|pixmapExposed
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|drawPixmap
argument_list|(
name|br
operator|.
name|topLeft
argument_list|()
argument_list|,
name|subPix
argument_list|)
expr_stmt|;
name|pixmapPainter
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Copied from qpaintengine_vg.cpp
end_comment
begin_comment
comment|// Returns true for 90, 180, and 270 degree rotations.
end_comment
begin_function
DECL|function|transformIsSimple
specifier|static
specifier|inline
name|bool
name|transformIsSimple
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
name|QTransform
operator|::
name|TransformationType
name|type
init|=
name|transform
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QTransform
operator|::
name|TxRotate
condition|)
block|{
comment|// Check for 90, and 270 degree rotations.
name|qreal
name|m11
init|=
name|transform
operator|.
name|m11
argument_list|()
decl_stmt|;
name|qreal
name|m12
init|=
name|transform
operator|.
name|m12
argument_list|()
decl_stmt|;
name|qreal
name|m21
init|=
name|transform
operator|.
name|m21
argument_list|()
decl_stmt|;
name|qreal
name|m22
init|=
name|transform
operator|.
name|m22
argument_list|()
decl_stmt|;
if|if
condition|(
name|m11
operator|==
literal|0.0f
operator|&&
name|m22
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|m12
operator|==
literal|1.0f
operator|&&
name|m21
operator|==
operator|-
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 90 degrees.
elseif|else
if|if
condition|(
name|m12
operator|==
operator|-
literal|1.0f
operator|&&
name|m21
operator|==
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 270 degrees.
elseif|else
if|if
condition|(
name|m12
operator|==
operator|-
literal|1.0f
operator|&&
name|m21
operator|==
operator|-
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 90 degrees inverted y.
elseif|else
if|if
condition|(
name|m12
operator|==
literal|1.0f
operator|&&
name|m21
operator|==
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 270 degrees inverted y.
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Draws items directly, or using cache. */
end_comment
begin_function
DECL|function|drawItemHelper
name|void
name|QGraphicsScenePrivate
operator|::
name|drawItemHelper
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|,
name|bool
name|painterStateProtection
parameter_list|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
name|item
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|QGraphicsItem
operator|::
name|CacheMode
name|cacheMode
init|=
name|QGraphicsItem
operator|::
name|CacheMode
argument_list|(
name|itemd
operator|->
name|cacheMode
argument_list|)
decl_stmt|;
comment|// Render directly, using no cache.
if|if
condition|(
name|cacheMode
operator|==
name|QGraphicsItem
operator|::
name|NoCache
ifdef|#
directive|ifdef
name|Q_WS_X11
operator|||
operator|!
name|X11
operator|->
name|use_xrender
endif|#
directive|endif
condition|)
block|{
name|_q_paintItem
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
argument_list|,
name|painter
argument_list|,
name|option
argument_list|,
name|widget
argument_list|,
literal|true
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|qreal
name|oldPainterOpacity
init|=
name|painter
operator|->
name|opacity
argument_list|()
decl_stmt|;
name|qreal
name|newPainterOpacity
init|=
name|oldPainterOpacity
decl_stmt|;
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|item
operator|->
name|isWidget
argument_list|()
condition|?
name|qobject_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|proxy
operator|&&
name|proxy
operator|->
name|widget
argument_list|()
condition|)
block|{
specifier|const
name|qreal
name|windowOpacity
init|=
name|proxy
operator|->
name|widget
argument_list|()
operator|->
name|windowOpacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowOpacity
operator|<
literal|1.0
condition|)
name|newPainterOpacity
operator|*=
name|windowOpacity
expr_stmt|;
block|}
comment|// Item's (local) bounding rect
name|QRectF
name|brect
init|=
name|item
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|QRectF
name|adjustedBrect
argument_list|(
name|brect
argument_list|)
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|adjustedBrect
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustedBrect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Fetch the off-screen transparent buffer and exposed area info.
name|QPixmapCache
operator|::
name|Key
name|pixmapKey
decl_stmt|;
name|QPixmap
name|pix
decl_stmt|;
name|bool
name|pixmapFound
decl_stmt|;
name|QGraphicsItemCache
modifier|*
name|itemCache
init|=
name|itemd
operator|->
name|extraItemCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|cacheMode
operator|==
name|QGraphicsItem
operator|::
name|ItemCoordinateCache
condition|)
block|{
name|pixmapKey
operator|=
name|itemCache
operator|->
name|key
expr_stmt|;
block|}
else|else
block|{
name|pixmapKey
operator|=
name|itemCache
operator|->
name|deviceData
operator|.
name|value
argument_list|(
name|widget
argument_list|)
operator|.
name|key
expr_stmt|;
block|}
comment|// Find pixmap in cache.
name|pixmapFound
operator|=
name|QPixmapCache
operator|::
name|find
argument_list|(
name|pixmapKey
argument_list|,
operator|&
name|pix
argument_list|)
expr_stmt|;
comment|// Render using item coordinate cache mode.
if|if
condition|(
name|cacheMode
operator|==
name|QGraphicsItem
operator|::
name|ItemCoordinateCache
condition|)
block|{
name|QSize
name|pixmapSize
decl_stmt|;
name|bool
name|fixedCacheSize
init|=
literal|false
decl_stmt|;
name|QRect
name|br
init|=
name|brect
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|fixedCacheSize
operator|=
name|itemCache
operator|->
name|fixedSize
operator|.
name|isValid
argument_list|()
operator|)
condition|)
block|{
name|pixmapSize
operator|=
name|itemCache
operator|->
name|fixedSize
expr_stmt|;
block|}
else|else
block|{
name|pixmapSize
operator|=
name|br
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Create or recreate the pixmap.
name|int
name|adjust
init|=
name|itemCache
operator|->
name|fixedSize
operator|.
name|isValid
argument_list|()
condition|?
literal|0
else|:
literal|2
decl_stmt|;
name|QSize
name|adjustSize
argument_list|(
name|adjust
operator|*
literal|2
argument_list|,
name|adjust
operator|*
literal|2
argument_list|)
decl_stmt|;
name|br
operator|.
name|adjust
argument_list|(
operator|-
name|adjust
argument_list|,
operator|-
name|adjust
argument_list|,
name|adjust
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix
operator|.
name|isNull
argument_list|()
operator|||
operator|(
operator|!
name|fixedCacheSize
operator|&&
operator|(
name|pixmapSize
operator|+
name|adjustSize
operator|)
operator|!=
name|pix
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|pix
operator|=
name|QPixmap
argument_list|(
name|pixmapSize
operator|+
name|adjustSize
argument_list|)
expr_stmt|;
name|itemCache
operator|->
name|boundingRect
operator|=
name|br
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|itemCache
operator|->
name|boundingRect
operator|!=
name|br
condition|)
block|{
name|itemCache
operator|->
name|boundingRect
operator|=
name|br
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
block|}
comment|// Redraw any newly exposed areas.
if|if
condition|(
name|itemCache
operator|->
name|allExposed
operator|||
operator|!
name|itemCache
operator|->
name|exposed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//We know that we will modify the pixmap, removing it from the cache
comment|//will detach the one we have and avoid a deep copy
if|if
condition|(
name|pixmapFound
condition|)
name|QPixmapCache
operator|::
name|remove
argument_list|(
name|pixmapKey
argument_list|)
expr_stmt|;
comment|// Fit the item's bounding rect into the pixmap's coordinates.
name|QTransform
name|itemToPixmap
decl_stmt|;
if|if
condition|(
name|fixedCacheSize
condition|)
block|{
specifier|const
name|QPointF
name|scale
argument_list|(
name|pixmapSize
operator|.
name|width
argument_list|()
operator|/
name|brect
operator|.
name|width
argument_list|()
argument_list|,
name|pixmapSize
operator|.
name|height
argument_list|()
operator|/
name|brect
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|itemToPixmap
operator|.
name|scale
argument_list|(
name|scale
operator|.
name|x
argument_list|()
argument_list|,
name|scale
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|itemToPixmap
operator|.
name|translate
argument_list|(
operator|-
name|br
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|br
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Generate the item's exposedRect and map its list of expose
comment|// rects to device coordinates.
name|styleOptionTmp
operator|=
operator|*
name|option
expr_stmt|;
name|QRegion
name|pixmapExposed
decl_stmt|;
name|QRectF
name|exposedRect
decl_stmt|;
if|if
condition|(
operator|!
name|itemCache
operator|->
name|allExposed
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|itemCache
operator|->
name|exposed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
name|r
init|=
name|itemCache
operator|->
name|exposed
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exposedRect
operator||=
name|r
expr_stmt|;
name|pixmapExposed
operator|+=
name|itemToPixmap
operator|.
name|mapRect
argument_list|(
name|r
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|exposedRect
operator|=
name|brect
expr_stmt|;
block|}
name|styleOptionTmp
operator|.
name|exposedRect
operator|=
name|exposedRect
expr_stmt|;
comment|// Render.
name|_q_paintIntoCache
argument_list|(
operator|&
name|pix
argument_list|,
name|item
argument_list|,
name|pixmapExposed
argument_list|,
name|itemToPixmap
argument_list|,
name|painter
operator|->
name|renderHints
argument_list|()
argument_list|,
operator|&
name|styleOptionTmp
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
comment|// insert this pixmap into the cache.
name|itemCache
operator|->
name|key
operator|=
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|pix
argument_list|)
expr_stmt|;
comment|// Reset expose data.
name|itemCache
operator|->
name|allExposed
operator|=
literal|false
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Redraw the exposed area using the transformed painter. Depending on
comment|// the hardware, this may be a server-side operation, or an expensive
comment|// qpixmap-image-transform-pixmap roundtrip.
if|if
condition|(
name|newPainterOpacity
operator|!=
name|oldPainterOpacity
condition|)
block|{
name|painter
operator|->
name|setOpacity
argument_list|(
name|newPainterOpacity
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|br
operator|.
name|topLeft
argument_list|()
argument_list|,
name|pix
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|oldPainterOpacity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|painter
operator|->
name|drawPixmap
argument_list|(
name|br
operator|.
name|topLeft
argument_list|()
argument_list|,
name|pix
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Render using device coordinate cache mode.
if|if
condition|(
name|cacheMode
operator|==
name|QGraphicsItem
operator|::
name|DeviceCoordinateCache
condition|)
block|{
comment|// Find the item's bounds in device coordinates.
name|QRectF
name|deviceBounds
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|brect
argument_list|)
decl_stmt|;
name|QRect
name|deviceRect
init|=
name|deviceBounds
operator|.
name|toRect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|deviceRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QRect
name|viewRect
init|=
name|widget
condition|?
name|widget
operator|->
name|rect
argument_list|()
else|:
name|QRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
operator|&&
operator|!
name|viewRect
operator|.
name|intersects
argument_list|(
name|deviceRect
argument_list|)
condition|)
return|return;
comment|// Resort to direct rendering if the device rect exceeds the
comment|// (optional) maximum bounds. (QGraphicsSvgItem uses this).
name|QSize
name|maximumCacheSize
init|=
name|itemd
operator|->
name|extra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraMaxDeviceCoordCacheSize
argument_list|)
operator|.
name|toSize
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|maximumCacheSize
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|deviceRect
operator|.
name|width
argument_list|()
operator|>
name|maximumCacheSize
operator|.
name|width
argument_list|()
operator|||
name|deviceRect
operator|.
name|height
argument_list|()
operator|>
name|maximumCacheSize
operator|.
name|height
argument_list|()
operator|)
condition|)
block|{
name|_q_paintItem
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
argument_list|,
name|painter
argument_list|,
name|option
argument_list|,
name|widget
argument_list|,
name|oldPainterOpacity
operator|!=
name|newPainterOpacity
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Create or reuse offscreen pixmap, possibly scroll/blit from the old one.
comment|// If the world transform is rotated we always recreate the cache to avoid
comment|// wrong blending.
name|bool
name|pixModified
init|=
literal|false
decl_stmt|;
name|QGraphicsItemCache
operator|::
name|DeviceData
modifier|*
name|deviceData
init|=
operator|&
name|itemCache
operator|->
name|deviceData
index|[
name|widget
index|]
decl_stmt|;
name|bool
name|invertable
init|=
literal|true
decl_stmt|;
name|QTransform
name|diff
init|=
name|deviceData
operator|->
name|lastTransform
operator|.
name|inverted
argument_list|(
operator|&
name|invertable
argument_list|)
decl_stmt|;
if|if
condition|(
name|invertable
condition|)
name|diff
operator|*=
name|painter
operator|->
name|worldTransform
argument_list|()
expr_stmt|;
name|deviceData
operator|->
name|lastTransform
operator|=
name|painter
operator|->
name|worldTransform
argument_list|()
expr_stmt|;
name|bool
name|allowPartialCacheExposure
init|=
literal|false
decl_stmt|;
name|bool
name|simpleTransform
init|=
name|invertable
operator|&&
name|diff
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|&&
name|transformIsSimple
argument_list|(
name|painter
operator|->
name|worldTransform
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|simpleTransform
condition|)
block|{
name|pixModified
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
name|deviceData
operator|->
name|cacheIndent
operator|=
name|QPoint
argument_list|()
expr_stmt|;
name|pix
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|viewRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|allowPartialCacheExposure
operator|=
name|deviceData
operator|->
name|cacheIndent
operator|!=
name|QPoint
argument_list|()
expr_stmt|;
block|}
comment|// Allow partial cache exposure if the device rect isn't fully contained and
comment|// deviceRect is 20% taller or wider than the viewRect.
if|if
condition|(
operator|!
name|allowPartialCacheExposure
operator|&&
operator|!
name|viewRect
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|viewRect
operator|.
name|contains
argument_list|(
name|deviceRect
argument_list|)
condition|)
block|{
name|allowPartialCacheExposure
operator|=
operator|(
name|viewRect
operator|.
name|width
argument_list|()
operator|*
literal|1.2
operator|<
name|deviceRect
operator|.
name|width
argument_list|()
operator|)
operator|||
operator|(
name|viewRect
operator|.
name|height
argument_list|()
operator|*
literal|1.2
operator|<
name|deviceRect
operator|.
name|height
argument_list|()
operator|)
expr_stmt|;
block|}
name|QRegion
name|scrollExposure
decl_stmt|;
if|if
condition|(
name|allowPartialCacheExposure
condition|)
block|{
comment|// Part of pixmap is drawn. Either device contains viewrect (big
comment|// item covers whole screen) or parts of device are outside the
comment|// viewport. In either case the device rect must be the intersect
comment|// between the two.
name|int
name|dx
init|=
name|deviceRect
operator|.
name|left
argument_list|()
operator|<
name|viewRect
operator|.
name|left
argument_list|()
condition|?
name|viewRect
operator|.
name|left
argument_list|()
operator|-
name|deviceRect
operator|.
name|left
argument_list|()
else|:
literal|0
decl_stmt|;
name|int
name|dy
init|=
name|deviceRect
operator|.
name|top
argument_list|()
operator|<
name|viewRect
operator|.
name|top
argument_list|()
condition|?
name|viewRect
operator|.
name|top
argument_list|()
operator|-
name|deviceRect
operator|.
name|top
argument_list|()
else|:
literal|0
decl_stmt|;
name|QPoint
name|newCacheIndent
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
decl_stmt|;
name|deviceRect
operator|&=
name|viewRect
expr_stmt|;
if|if
condition|(
name|pix
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|deviceData
operator|->
name|cacheIndent
operator|=
name|QPoint
argument_list|()
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pixModified
operator|=
literal|true
expr_stmt|;
block|}
comment|// Copy / "scroll" the old pixmap onto the new ole and calculate
comment|// scrolled exposure.
if|if
condition|(
name|newCacheIndent
operator|!=
name|deviceData
operator|->
name|cacheIndent
operator|||
name|deviceRect
operator|.
name|size
argument_list|()
operator|!=
name|pix
operator|.
name|size
argument_list|()
condition|)
block|{
name|QPoint
name|diff
init|=
name|newCacheIndent
operator|-
name|deviceData
operator|->
name|cacheIndent
decl_stmt|;
name|QPixmap
name|newPix
argument_list|(
name|deviceRect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// ### Investigate removing this fill (test with Plasma and
comment|// graphicssystem raster).
name|newPix
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pix
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QPainter
name|newPixPainter
argument_list|(
operator|&
name|newPix
argument_list|)
decl_stmt|;
name|newPixPainter
operator|.
name|drawPixmap
argument_list|(
operator|-
name|diff
argument_list|,
name|pix
argument_list|)
expr_stmt|;
name|newPixPainter
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
name|QRegion
name|exposed
decl_stmt|;
name|exposed
operator|+=
name|newPix
operator|.
name|rect
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pix
operator|.
name|isNull
argument_list|()
condition|)
name|exposed
operator|-=
name|QRect
argument_list|(
operator|-
name|diff
argument_list|,
name|pix
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|scrollExposure
operator|=
name|exposed
expr_stmt|;
name|pix
operator|=
name|newPix
expr_stmt|;
name|pixModified
operator|=
literal|true
expr_stmt|;
block|}
name|deviceData
operator|->
name|cacheIndent
operator|=
name|newCacheIndent
expr_stmt|;
block|}
else|else
block|{
comment|// Full pixmap is drawn.
name|deviceData
operator|->
name|cacheIndent
operator|=
name|QPoint
argument_list|()
expr_stmt|;
comment|// Auto-adjust the pixmap size.
if|if
condition|(
name|deviceRect
operator|.
name|size
argument_list|()
operator|!=
name|pix
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// exposed needs to cover the whole pixmap
name|pix
operator|=
name|QPixmap
argument_list|(
name|deviceRect
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|pixModified
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Check for newly invalidated areas.
if|if
condition|(
name|itemCache
operator|->
name|allExposed
operator|||
operator|!
name|itemCache
operator|->
name|exposed
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|scrollExposure
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//We know that we will modify the pixmap, removing it from the cache
comment|//will detach the one we have and avoid a deep copy
if|if
condition|(
name|pixmapFound
condition|)
name|QPixmapCache
operator|::
name|remove
argument_list|(
name|pixmapKey
argument_list|)
expr_stmt|;
comment|// Construct an item-to-pixmap transform.
name|QPointF
name|p
init|=
name|deviceRect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|QTransform
name|itemToPixmap
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|isNull
argument_list|()
condition|)
name|itemToPixmap
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|p
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Map the item's logical expose to pixmap coordinates.
name|QRegion
name|pixmapExposed
init|=
name|scrollExposure
decl_stmt|;
if|if
condition|(
operator|!
name|itemCache
operator|->
name|allExposed
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|QRectF
argument_list|>
modifier|&
name|exposed
init|=
name|itemCache
operator|->
name|exposed
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exposed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|pixmapExposed
operator|+=
name|itemToPixmap
operator|.
name|mapRect
argument_list|(
name|exposed
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|toRect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Calculate the style option's exposedRect.
name|QRectF
name|br
decl_stmt|;
if|if
condition|(
name|itemCache
operator|->
name|allExposed
condition|)
block|{
name|br
operator|=
name|item
operator|->
name|boundingRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRectF
argument_list|>
modifier|&
name|exposed
init|=
name|itemCache
operator|->
name|exposed
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exposed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|br
operator||=
name|exposed
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|QTransform
name|pixmapToItem
init|=
name|itemToPixmap
operator|.
name|inverted
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|r
decl|,
name|scrollExposure
operator|.
name|rects
argument_list|()
control|)
name|br
operator||=
name|pixmapToItem
operator|.
name|mapRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|styleOptionTmp
operator|=
operator|*
name|option
expr_stmt|;
name|styleOptionTmp
operator|.
name|exposedRect
operator|=
name|br
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Render the exposed areas.
name|_q_paintIntoCache
argument_list|(
operator|&
name|pix
argument_list|,
name|item
argument_list|,
name|pixmapExposed
argument_list|,
name|itemToPixmap
argument_list|,
name|painter
operator|->
name|renderHints
argument_list|()
argument_list|,
operator|&
name|styleOptionTmp
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
comment|// Reset expose data.
name|pixModified
operator|=
literal|true
expr_stmt|;
name|itemCache
operator|->
name|allExposed
operator|=
literal|false
expr_stmt|;
name|itemCache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pixModified
condition|)
block|{
comment|// Insert this pixmap into the cache.
name|deviceData
operator|->
name|key
operator|=
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|pix
argument_list|)
expr_stmt|;
block|}
comment|// Redraw the exposed area using an untransformed painter. This
comment|// effectively becomes a bitblit that does not transform the cache.
name|QTransform
name|restoreTransform
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
name|painter
operator|->
name|setWorldTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newPainterOpacity
operator|!=
name|oldPainterOpacity
condition|)
block|{
name|painter
operator|->
name|setOpacity
argument_list|(
name|newPainterOpacity
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|deviceRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|pix
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|oldPainterOpacity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|painter
operator|->
name|drawPixmap
argument_list|(
name|deviceRect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|pix
argument_list|)
expr_stmt|;
block|}
name|painter
operator|->
name|setWorldTransform
argument_list|(
name|restoreTransform
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_function
DECL|function|drawItems
name|void
name|QGraphicsScenePrivate
operator|::
name|drawItems
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|viewTransform
parameter_list|,
name|QRegion
modifier|*
name|exposedRegion
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
comment|// Make sure we don't have unpolished items before we draw.
if|if
condition|(
operator|!
name|unpolishedItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|_q_polishItems
argument_list|()
expr_stmt|;
name|updateAll
operator|=
literal|false
expr_stmt|;
name|QRectF
name|exposedSceneRect
decl_stmt|;
if|if
condition|(
name|exposedRegion
operator|&&
name|indexMethod
operator|!=
name|QGraphicsScene
operator|::
name|NoIndex
condition|)
block|{
name|exposedSceneRect
operator|=
name|exposedRegion
operator|->
name|boundingRect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|viewTransform
condition|)
name|exposedSceneRect
operator|=
name|viewTransform
operator|->
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|exposedSceneRect
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|tli
init|=
name|index
operator|->
name|estimateTopLevelItems
argument_list|(
name|exposedSceneRect
argument_list|,
name|Qt
operator|::
name|AscendingOrder
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tli
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|drawSubtreeRecursive
argument_list|(
name|tli
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|painter
argument_list|,
name|viewTransform
argument_list|,
name|exposedRegion
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawSubtreeRecursive
name|void
name|QGraphicsScenePrivate
operator|::
name|drawSubtreeRecursive
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|viewTransform
parameter_list|,
name|QRegion
modifier|*
name|exposedRegion
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|,
name|qreal
name|parentOpacity
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|effectTransform
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|visible
condition|)
return|return;
specifier|const
name|bool
name|itemHasContents
init|=
operator|!
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemHasNoContents
operator|)
decl_stmt|;
specifier|const
name|bool
name|itemHasChildren
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|itemHasContents
operator|&&
operator|!
name|itemHasChildren
condition|)
return|return;
comment|// Item has neither contents nor children!(?)
specifier|const
name|qreal
name|opacity
init|=
name|item
operator|->
name|d_ptr
operator|->
name|combineOpacityFromParent
argument_list|(
name|parentOpacity
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|itemIsFullyTransparent
init|=
name|QGraphicsItemPrivate
operator|::
name|isOpacityNull
argument_list|(
name|opacity
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|(
operator|!
name|itemHasChildren
operator|||
name|item
operator|->
name|d_ptr
operator|->
name|childrenCombineOpacity
argument_list|()
operator|)
condition|)
return|return;
name|QTransform
name|transform
argument_list|(
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|QTransform
modifier|*
name|transformPtr
init|=
literal|0
decl_stmt|;
name|bool
name|translateOnlyTransform
init|=
literal|false
decl_stmt|;
DECL|macro|ENSURE_TRANSFORM_PTR
define|#
directive|define
name|ENSURE_TRANSFORM_PTR
define|\
value|if (!transformPtr) { \         Q_ASSERT(!itemIsUntransformable); \         if (viewTransform) { \             transform = item->d_ptr->sceneTransform; \             transform *= *viewTransform; \             transformPtr =&transform; \         } else { \             transformPtr =&item->d_ptr->sceneTransform; \             translateOnlyTransform = item->d_ptr->sceneTransformTranslateOnly; \         } \     }
comment|// Update the item's scene transform if the item is transformable;
comment|// otherwise calculate the full transform,
name|bool
name|wasDirtyParentSceneTransform
init|=
literal|false
decl_stmt|;
specifier|const
name|bool
name|itemIsUntransformable
init|=
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
decl_stmt|;
if|if
condition|(
name|itemIsUntransformable
condition|)
block|{
name|transform
operator|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|viewTransform
condition|?
operator|*
name|viewTransform
else|:
name|QTransform
argument_list|()
argument_list|)
expr_stmt|;
name|transformPtr
operator|=
operator|&
name|transform
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|updateSceneTransformFromParent
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
name|wasDirtyParentSceneTransform
operator|=
literal|true
expr_stmt|;
block|}
specifier|const
name|bool
name|itemClipsChildrenToShape
init|=
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
operator|)
decl_stmt|;
name|bool
name|drawItem
init|=
name|itemHasContents
operator|&&
operator|!
name|itemIsFullyTransparent
decl_stmt|;
if|if
condition|(
name|drawItem
condition|)
block|{
specifier|const
name|QRectF
name|brect
init|=
name|adjustedItemEffectiveBoundingRect
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|ENSURE_TRANSFORM_PTR
name|QRect
name|viewBoundingRect
init|=
name|translateOnlyTransform
condition|?
name|brect
operator|.
name|translated
argument_list|(
name|transformPtr
operator|->
name|dx
argument_list|()
argument_list|,
name|transformPtr
operator|->
name|dy
argument_list|()
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
else|:
name|transformPtr
operator|->
name|mapRect
argument_list|(
name|brect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|viewBoundingRect
operator|.
name|adjust
argument_list|(
operator|-
name|int
argument_list|(
name|rectAdjust
argument_list|)
argument_list|,
operator|-
name|int
argument_list|(
name|rectAdjust
argument_list|)
argument_list|,
name|rectAdjust
argument_list|,
name|rectAdjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|widget
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRects
operator|.
name|insert
argument_list|(
name|widget
argument_list|,
name|viewBoundingRect
argument_list|)
expr_stmt|;
name|drawItem
operator|=
name|exposedRegion
condition|?
name|exposedRegion
operator|->
name|intersects
argument_list|(
name|viewBoundingRect
argument_list|)
else|:
operator|!
name|viewBoundingRect
operator|.
name|normalized
argument_list|()
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|drawItem
condition|)
block|{
if|if
condition|(
operator|!
name|itemHasChildren
condition|)
return|return;
if|if
condition|(
name|itemClipsChildrenToShape
condition|)
block|{
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|invalidateChildrenSceneTransform
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// else we know for sure this item has children we must process.
if|if
condition|(
name|itemHasChildren
operator|&&
name|itemClipsChildrenToShape
condition|)
name|ENSURE_TRANSFORM_PTR
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
name|ENSURE_TRANSFORM_PTR
expr_stmt|;
name|QGraphicsItemPaintInfo
name|info
argument_list|(
name|viewTransform
argument_list|,
name|transformPtr
argument_list|,
name|effectTransform
argument_list|,
name|exposedRegion
argument_list|,
name|widget
argument_list|,
operator|&
name|styleOptionTmp
argument_list|,
name|painter
argument_list|,
name|opacity
argument_list|,
name|wasDirtyParentSceneTransform
argument_list|,
name|itemHasContents
operator|&&
operator|!
name|itemIsFullyTransparent
argument_list|)
decl_stmt|;
name|QGraphicsEffectSource
modifier|*
name|source
init|=
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
operator|->
name|d_func
argument_list|()
operator|->
name|source
decl_stmt|;
name|QGraphicsItemEffectSourcePrivate
modifier|*
name|sourced
init|=
cast|static_cast
argument_list|<
name|QGraphicsItemEffectSourcePrivate
operator|*
argument_list|>
argument_list|(
name|source
operator|->
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
name|sourced
operator|->
name|info
operator|=
operator|&
name|info
expr_stmt|;
specifier|const
name|QTransform
name|restoreTransform
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
if|if
condition|(
name|effectTransform
condition|)
name|painter
operator|->
name|setWorldTransform
argument_list|(
operator|*
name|transformPtr
operator|*
operator|*
name|effectTransform
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|setWorldTransform
argument_list|(
operator|*
name|transformPtr
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourced
operator|->
name|currentCachedSystem
argument_list|()
operator|!=
name|Qt
operator|::
name|LogicalCoordinates
operator|&&
name|sourced
operator|->
name|lastEffectTransform
operator|!=
name|painter
operator|->
name|worldTransform
argument_list|()
condition|)
block|{
if|if
condition|(
name|sourced
operator|->
name|lastEffectTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|&&
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
name|QRectF
name|sourceRect
init|=
name|sourced
operator|->
name|boundingRect
argument_list|(
name|Qt
operator|::
name|DeviceCoordinates
argument_list|)
decl_stmt|;
name|QRect
name|effectRect
init|=
name|sourced
operator|->
name|paddedEffectRect
argument_list|(
name|Qt
operator|::
name|DeviceCoordinates
argument_list|,
name|sourced
operator|->
name|currentCachedMode
argument_list|()
argument_list|,
name|sourceRect
argument_list|)
decl_stmt|;
name|sourced
operator|->
name|setCachedOffset
argument_list|(
name|effectRect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sourced
operator|->
name|invalidateCache
argument_list|(
name|QGraphicsEffectSourcePrivate
operator|::
name|TransformChanged
argument_list|)
expr_stmt|;
block|}
name|sourced
operator|->
name|lastEffectTransform
operator|=
name|painter
operator|->
name|worldTransform
argument_list|()
expr_stmt|;
block|}
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
operator|->
name|draw
argument_list|(
name|painter
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setWorldTransform
argument_list|(
name|restoreTransform
argument_list|)
expr_stmt|;
name|sourced
operator|->
name|info
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
block|{
name|draw
argument_list|(
name|item
argument_list|,
name|painter
argument_list|,
name|viewTransform
argument_list|,
name|transformPtr
argument_list|,
name|exposedRegion
argument_list|,
name|widget
argument_list|,
name|opacity
argument_list|,
name|effectTransform
argument_list|,
name|wasDirtyParentSceneTransform
argument_list|,
name|drawItem
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setClip
specifier|static
specifier|inline
name|void
name|setClip
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|QRectF
name|clipRect
decl_stmt|;
specifier|const
name|QPainterPath
name|clipPath
argument_list|(
name|item
operator|->
name|shape
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|QPathClipper
operator|::
name|pathToRect
argument_list|(
name|clipPath
argument_list|,
operator|&
name|clipRect
argument_list|)
condition|)
name|painter
operator|->
name|setClipRect
argument_list|(
name|clipRect
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|setClipPath
argument_list|(
name|clipPath
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setWorldTransform
specifier|static
specifier|inline
name|void
name|setWorldTransform
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|transformPtr
parameter_list|,
specifier|const
name|QTransform
modifier|*
name|effectTransform
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|transformPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|effectTransform
condition|)
name|painter
operator|->
name|setWorldTransform
argument_list|(
operator|*
name|transformPtr
operator|*
operator|*
name|effectTransform
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|setWorldTransform
argument_list|(
operator|*
name|transformPtr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|draw
name|void
name|QGraphicsScenePrivate
operator|::
name|draw
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|viewTransform
parameter_list|,
specifier|const
name|QTransform
modifier|*
specifier|const
name|transformPtr
parameter_list|,
name|QRegion
modifier|*
name|exposedRegion
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|,
name|qreal
name|opacity
parameter_list|,
specifier|const
name|QTransform
modifier|*
name|effectTransform
parameter_list|,
name|bool
name|wasDirtyParentSceneTransform
parameter_list|,
name|bool
name|drawItem
parameter_list|)
block|{
specifier|const
name|bool
name|itemIsFullyTransparent
init|=
name|QGraphicsItemPrivate
operator|::
name|isOpacityNull
argument_list|(
name|opacity
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|itemClipsChildrenToShape
init|=
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
operator|)
decl_stmt|;
specifier|const
name|bool
name|itemHasChildren
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|setChildClip
init|=
name|itemClipsChildrenToShape
decl_stmt|;
name|bool
name|itemHasChildrenStackedBehind
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|itemHasChildren
condition|)
block|{
if|if
condition|(
name|itemClipsChildrenToShape
condition|)
name|setWorldTransform
argument_list|(
name|painter
argument_list|,
name|transformPtr
argument_list|,
name|effectTransform
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|ensureSortedChildren
argument_list|()
expr_stmt|;
comment|// Items with the 'ItemStacksBehindParent' flag are put in front of the list
comment|// so all we have to do is to check the first item.
name|itemHasChildrenStackedBehind
operator|=
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
operator|)
expr_stmt|;
if|if
condition|(
name|itemHasChildrenStackedBehind
condition|)
block|{
if|if
condition|(
name|itemClipsChildrenToShape
condition|)
block|{
name|setClip
argument_list|(
name|painter
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|setChildClip
operator|=
literal|false
expr_stmt|;
block|}
comment|// Draw children behind
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
operator|)
condition|)
break|break;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
operator|)
condition|)
continue|continue;
name|drawSubtreeRecursive
argument_list|(
name|child
argument_list|,
name|painter
argument_list|,
name|viewTransform
argument_list|,
name|exposedRegion
argument_list|,
name|widget
argument_list|,
name|opacity
argument_list|,
name|effectTransform
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Draw item
if|if
condition|(
name|drawItem
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|itemIsFullyTransparent
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemHasNoContents
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|transformPtr
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|initStyleOption
argument_list|(
operator|&
name|styleOptionTmp
argument_list|,
operator|*
name|transformPtr
argument_list|,
name|exposedRegion
condition|?
operator|*
name|exposedRegion
else|:
name|QRegion
argument_list|()
argument_list|,
name|exposedRegion
operator|==
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|itemClipsToShape
init|=
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsToShape
decl_stmt|;
name|bool
name|restorePainterClip
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|itemHasChildren
operator|||
operator|!
name|itemClipsChildrenToShape
condition|)
block|{
comment|// Item does not have children or clip children to shape.
name|setWorldTransform
argument_list|(
name|painter
argument_list|,
name|transformPtr
argument_list|,
name|effectTransform
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|restorePainterClip
operator|=
name|itemClipsToShape
operator|)
condition|)
name|setClip
argument_list|(
name|painter
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|itemHasChildrenStackedBehind
condition|)
block|{
comment|// Item clips children to shape and has children stacked behind, which means
comment|// the painter is already clipped to the item's shape.
if|if
condition|(
name|itemClipsToShape
condition|)
block|{
comment|// The clip is already correct. Ensure correct world transform.
name|setWorldTransform
argument_list|(
name|painter
argument_list|,
name|transformPtr
argument_list|,
name|effectTransform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Remove clip (this also ensures correct world transform).
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
name|setChildClip
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|itemClipsToShape
condition|)
block|{
comment|// Item clips children and itself to shape. It does not have hildren stacked
comment|// behind, which means the clip has not yet been set. We set it now and re-use it
comment|// for the children.
name|setClip
argument_list|(
name|painter
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|setChildClip
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|painterStateProtection
operator|&&
operator|!
name|restorePainterClip
condition|)
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|cacheMode
operator|&&
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|isWidget
condition|)
name|item
operator|->
name|paint
argument_list|(
name|painter
argument_list|,
operator|&
name|styleOptionTmp
argument_list|,
name|widget
argument_list|)
expr_stmt|;
else|else
name|drawItemHelper
argument_list|(
name|item
argument_list|,
name|painter
argument_list|,
operator|&
name|styleOptionTmp
argument_list|,
name|widget
argument_list|,
name|painterStateProtection
argument_list|)
expr_stmt|;
if|if
condition|(
name|painterStateProtection
operator|||
name|restorePainterClip
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
specifier|static
name|int
name|drawRect
init|=
name|qgetenv
argument_list|(
literal|"QT_DRAW_SCENE_ITEM_RECTS"
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|drawRect
condition|)
block|{
name|QPen
name|oldPen
init|=
name|painter
operator|->
name|pen
argument_list|()
decl_stmt|;
name|QBrush
name|oldBrush
init|=
name|painter
operator|->
name|brush
argument_list|()
decl_stmt|;
name|quintptr
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|quintptr
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
specifier|const
name|QColor
name|color
init|=
name|QColor
operator|::
name|fromHsv
argument_list|(
name|ptr
operator|%
literal|255
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|)
decl_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|adjustedItemBoundingRect
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Draw children in front
if|if
condition|(
name|itemHasChildren
condition|)
block|{
if|if
condition|(
name|setChildClip
condition|)
name|setClip
argument_list|(
name|painter
argument_list|,
name|item
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
operator|)
condition|)
continue|continue;
name|drawSubtreeRecursive
argument_list|(
name|child
argument_list|,
name|painter
argument_list|,
name|viewTransform
argument_list|,
name|exposedRegion
argument_list|,
name|widget
argument_list|,
name|opacity
argument_list|,
name|effectTransform
argument_list|)
expr_stmt|;
block|}
comment|// Restore child clip
if|if
condition|(
name|itemClipsChildrenToShape
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|markDirty
name|void
name|QGraphicsScenePrivate
operator|::
name|markDirty
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|bool
name|invalidateChildren
parameter_list|,
name|bool
name|force
parameter_list|,
name|bool
name|ignoreOpacity
parameter_list|,
name|bool
name|removingItemFromScene
parameter_list|,
name|bool
name|updateBoundingRect
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateAll
condition|)
return|return;
if|if
condition|(
name|removingItemFromScene
operator|&&
operator|!
name|ignoreOpacity
operator|&&
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
condition|)
block|{
comment|// If any of the item's ancestors ignore opacity, it means that the opacity
comment|// was set to 0 (and the update request has not yet been processed). That
comment|// also means that we have to ignore the opacity for the item itself; otherwise
comment|// things like: parent->setOpacity(0); scene->removeItem(child) won't work.
comment|// Note that we only do this when removing items from the scene. In all other
comment|// cases the ignoreOpacity bit propagates properly in processDirtyItems, but
comment|// since the item is removed immediately it won't be processed there.
name|QGraphicsItem
modifier|*
name|p
init|=
name|item
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|discardUpdateRequest
argument_list|(
comment|/*ignoreVisibleBit=*/
name|force
argument_list|,
comment|/*ignoreDirtyBit=*/
name|removingItemFromScene
operator|||
name|invalidateChildren
argument_list|,
comment|/*ignoreOpacity=*/
name|ignoreOpacity
argument_list|)
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|dirty
condition|)
block|{
comment|// The item is already marked as dirty and will be processed later. However,
comment|// we have to make sure ignoreVisible and ignoreOpacity are set properly;
comment|// otherwise things like: item->update(); item->hide() (force is now true)
comment|// won't work as expected.
if|if
condition|(
name|force
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|ignoreVisible
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ignoreOpacity
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
specifier|const
name|bool
name|fullItemUpdate
init|=
name|rect
operator|.
name|isNull
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fullItemUpdate
operator|&&
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|processDirtyItemsEmitted
condition|)
block|{
name|QMetaMethod
name|method
init|=
name|q_ptr
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|processDirtyItemsIndex
argument_list|)
decl_stmt|;
name|method
operator|.
name|invoke
argument_list|(
name|q_ptr
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|//        QMetaObject::invokeMethod(q_ptr, "_q_processDirtyItems", Qt::QueuedConnection);
name|processDirtyItemsEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|removingItemFromScene
condition|)
block|{
comment|// Note that this function can be called from the item's destructor, so
comment|// do NOT call any virtual functions on it within this block.
if|if
condition|(
name|isSignalConnected
argument_list|(
name|changedSignalIndex
argument_list|)
operator|||
name|views
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This block of code is kept for compatibility. Since 4.5, by default
comment|// QGraphicsView does not connect the signal and we use the below
comment|// method of delivering updates.
name|q_func
argument_list|()
operator|->
name|update
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsViewPrivate
modifier|*
name|viewPrivate
init|=
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QRect
name|rect
init|=
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRects
operator|.
name|value
argument_list|(
name|viewPrivate
operator|->
name|viewport
argument_list|)
decl_stmt|;
name|rect
operator|.
name|translate
argument_list|(
name|viewPrivate
operator|->
name|dirtyScrollOffset
argument_list|)
expr_stmt|;
name|viewPrivate
operator|->
name|updateRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|bool
name|hasNoContents
init|=
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemHasNoContents
decl_stmt|;
if|if
condition|(
operator|!
name|hasNoContents
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fullItemUpdate
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|needsRepaint
operator||=
name|rect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
condition|)
block|{
name|invalidateChildren
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|invalidateChildren
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|allChildrenDirty
operator|=
literal|1
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|dirtyChildren
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|ignoreVisible
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ignoreOpacity
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|updateBoundingRect
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|markParentDirty
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateHelper
specifier|static
specifier|inline
name|bool
name|updateHelper
parameter_list|(
name|QGraphicsViewPrivate
modifier|*
name|view
parameter_list|,
name|QGraphicsItemPrivate
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|bool
name|itemIsUntransformable
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|view
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|itemq
init|=
cast|static_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|item
operator|->
name|q_ptr
argument_list|)
decl_stmt|;
name|QGraphicsView
modifier|*
name|viewq
init|=
cast|static_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|view
operator|->
name|q_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemIsUntransformable
condition|)
block|{
specifier|const
name|QTransform
name|xform
init|=
name|itemq
operator|->
name|deviceTransform
argument_list|(
name|viewq
operator|->
name|viewportTransform
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|hasBoundingRegionGranularity
condition|)
return|return
name|view
operator|->
name|updateRectF
argument_list|(
name|xform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
argument_list|)
return|;
return|return
name|view
operator|->
name|updateRegion
argument_list|(
name|rect
argument_list|,
name|xform
argument_list|)
return|;
block|}
if|if
condition|(
name|item
operator|->
name|sceneTransformTranslateOnly
operator|&&
name|view
operator|->
name|identityMatrix
condition|)
block|{
specifier|const
name|qreal
name|dx
init|=
name|item
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|dy
init|=
name|item
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
decl_stmt|;
name|QRectF
name|r
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|dx
operator|-
name|view
operator|->
name|horizontalScroll
argument_list|()
argument_list|,
name|dy
operator|-
name|view
operator|->
name|verticalScroll
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|view
operator|->
name|updateRectF
argument_list|(
name|r
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|viewq
operator|->
name|isTransformed
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|hasBoundingRegionGranularity
condition|)
return|return
name|view
operator|->
name|updateRectF
argument_list|(
name|item
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
argument_list|)
return|;
return|return
name|view
operator|->
name|updateRegion
argument_list|(
name|rect
argument_list|,
name|item
operator|->
name|sceneTransform
argument_list|)
return|;
block|}
name|QTransform
name|xform
init|=
name|item
operator|->
name|sceneTransform
decl_stmt|;
name|xform
operator|*=
name|viewq
operator|->
name|viewportTransform
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|hasBoundingRegionGranularity
condition|)
return|return
name|view
operator|->
name|updateRectF
argument_list|(
name|xform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
argument_list|)
return|;
return|return
name|view
operator|->
name|updateRegion
argument_list|(
name|rect
argument_list|,
name|xform
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|processDirtyItemsRecursive
name|void
name|QGraphicsScenePrivate
operator|::
name|processDirtyItemsRecursive
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|dirtyAncestorContainsChildren
parameter_list|,
name|qreal
name|parentOpacity
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|updateAll
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirty
operator|&&
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirtyChildren
condition|)
block|{
name|resetDirtyItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|bool
name|itemIsHidden
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|ignoreVisible
operator|&&
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|visible
decl_stmt|;
if|if
condition|(
name|itemIsHidden
condition|)
block|{
name|resetDirtyItem
argument_list|(
name|item
argument_list|,
comment|/*recursive=*/
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|itemHasContents
init|=
operator|!
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemHasNoContents
operator|)
decl_stmt|;
specifier|const
name|bool
name|itemHasChildren
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|itemHasContents
condition|)
block|{
if|if
condition|(
operator|!
name|itemHasChildren
condition|)
block|{
name|resetDirtyItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return;
comment|// Item has neither contents nor children!(?)
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|graphicsEffect
condition|)
name|itemHasContents
operator|=
literal|true
expr_stmt|;
block|}
specifier|const
name|qreal
name|opacity
init|=
name|item
operator|->
name|d_ptr
operator|->
name|combineOpacityFromParent
argument_list|(
name|parentOpacity
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|itemIsFullyTransparent
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
operator|&&
name|QGraphicsItemPrivate
operator|::
name|isOpacityNull
argument_list|(
name|opacity
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|(
operator|!
name|itemHasChildren
operator|||
name|item
operator|->
name|d_ptr
operator|->
name|childrenCombineOpacity
argument_list|()
operator|)
condition|)
block|{
name|resetDirtyItem
argument_list|(
name|item
argument_list|,
comment|/*recursive=*/
name|itemHasChildren
argument_list|)
expr_stmt|;
return|return;
block|}
name|bool
name|wasDirtyParentSceneTransform
init|=
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
decl_stmt|;
specifier|const
name|bool
name|itemIsUntransformable
init|=
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
operator|&&
operator|!
name|itemIsUntransformable
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|updateSceneTransformFromParent
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
block|}
specifier|const
name|bool
name|wasDirtyParentViewBoundingRects
init|=
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
decl_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|||
operator|!
name|itemHasContents
operator|||
name|dirtyAncestorContainsChildren
condition|)
block|{
comment|// Make sure we don't process invisible items or items with no content.
name|item
operator|->
name|d_ptr
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
operator|=
literal|0
expr_stmt|;
comment|// Might have a dirty view bounding rect otherwise.
if|if
condition|(
name|itemIsFullyTransparent
operator|||
operator|!
name|itemHasContents
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasSceneRect
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|geometryChanged
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|visible
condition|)
block|{
comment|// Update growingItemsBoundingRect.
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
condition|)
block|{
name|growingItemsBoundingRect
operator||=
name|item
operator|->
name|boundingRect
argument_list|()
operator|.
name|translated
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|growingItemsBoundingRect
operator||=
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Process item.
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|dirty
operator|||
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
condition|)
block|{
specifier|const
name|bool
name|useCompatUpdate
init|=
name|views
operator|.
name|isEmpty
argument_list|()
operator|||
name|isSignalConnected
argument_list|(
name|changedSignalIndex
argument_list|)
decl_stmt|;
specifier|const
name|QRectF
name|itemBoundingRect
init|=
name|adjustedItemEffectiveBoundingRect
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|useCompatUpdate
operator|&&
operator|!
name|itemIsUntransformable
operator|&&
name|qFuzzyIsNull
argument_list|(
name|item
operator|->
name|boundingRegionGranularity
argument_list|()
argument_list|)
condition|)
block|{
comment|// This block of code is kept for compatibility. Since 4.5, by default
comment|// QGraphicsView does not connect the signal and we use the below
comment|// method of delivering updates.
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
condition|)
block|{
name|q
operator|->
name|update
argument_list|(
name|itemBoundingRect
operator|.
name|translated
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRectF
name|rect
init|=
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|itemBoundingRect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QRectF
name|dirtyRect
decl_stmt|;
name|bool
name|uninitializedDirtyRect
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QGraphicsView
modifier|*
name|view
init|=
name|views
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QGraphicsViewPrivate
modifier|*
name|viewPrivate
init|=
name|view
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QRect
modifier|&
name|paintedViewBoundingRect
init|=
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRects
index|[
name|viewPrivate
operator|->
name|viewport
index|]
decl_stmt|;
if|if
condition|(
name|viewPrivate
operator|->
name|fullUpdatePending
operator|||
name|viewPrivate
operator|->
name|viewportUpdateMode
operator|==
name|QGraphicsView
operator|::
name|NoViewportUpdate
condition|)
block|{
comment|// Okay, if we have a full update pending or no viewport update, this item's
comment|// paintedViewBoundingRect  will be updated correctly in the next paintEvent if
comment|// it is inside the viewport, but for now we can pretend that it is outside.
name|paintedViewBoundingRect
operator|=
name|QRect
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
condition|)
block|{
name|paintedViewBoundingRect
operator|.
name|translate
argument_list|(
name|viewPrivate
operator|->
name|dirtyScrollOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|viewPrivate
operator|->
name|updateRect
argument_list|(
name|paintedViewBoundingRect
argument_list|)
condition|)
name|paintedViewBoundingRect
operator|=
name|QRect
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Outside viewport.
block|}
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirty
condition|)
continue|continue;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
operator|&&
name|paintedViewBoundingRect
operator|.
name|x
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|paintedViewBoundingRect
operator|.
name|y
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|paintedViewBoundingRect
operator|.
name|width
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|paintedViewBoundingRect
operator|.
name|height
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
comment|// Outside viewport.
block|}
if|if
condition|(
name|uninitializedDirtyRect
condition|)
block|{
name|dirtyRect
operator|=
name|itemBoundingRect
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
condition|)
block|{
name|_q_adjustRect
argument_list|(
operator|&
name|item
operator|->
name|d_ptr
operator|->
name|needsRepaint
argument_list|)
expr_stmt|;
name|dirtyRect
operator|&=
name|item
operator|->
name|d_ptr
operator|->
name|needsRepaint
expr_stmt|;
block|}
name|uninitializedDirtyRect
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|dirtyRect
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|// Discard updates outside the bounding rect.
if|if
condition|(
operator|!
name|updateHelper
argument_list|(
name|viewPrivate
argument_list|,
name|item
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|,
name|dirtyRect
argument_list|,
name|itemIsUntransformable
argument_list|)
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
condition|)
block|{
name|paintedViewBoundingRect
operator|=
name|QRect
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Outside viewport.
block|}
block|}
block|}
block|}
comment|// Process children.
if|if
condition|(
name|itemHasChildren
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|dirtyChildren
condition|)
block|{
specifier|const
name|bool
name|itemClipsChildrenToShape
init|=
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
decl_stmt|;
comment|// Items with no content are threated as 'dummy' items which means they are never drawn and
comment|// 'processed', so the painted view bounding rect is never up-to-date. This means that whenever
comment|// such an item changes geometry, its children have to take care of the update regardless
comment|// of whether the item clips children to shape or not.
specifier|const
name|bool
name|bypassUpdateClip
init|=
operator|!
name|itemHasContents
operator|&&
name|wasDirtyParentViewBoundingRects
decl_stmt|;
if|if
condition|(
name|itemClipsChildrenToShape
operator|&&
operator|!
name|bypassUpdateClip
condition|)
block|{
comment|// Make sure child updates are clipped to the item's bounding rect.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|setUpdateClip
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dirtyAncestorContainsChildren
condition|)
block|{
name|dirtyAncestorContainsChildren
operator|=
name|item
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
operator|&&
name|itemClipsChildrenToShape
expr_stmt|;
block|}
specifier|const
name|bool
name|allChildrenDirty
init|=
name|item
operator|->
name|d_ptr
operator|->
name|allChildrenDirty
decl_stmt|;
specifier|const
name|bool
name|parentIgnoresVisible
init|=
name|item
operator|->
name|d_ptr
operator|->
name|ignoreVisible
decl_stmt|;
specifier|const
name|bool
name|parentIgnoresOpacity
init|=
name|item
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wasDirtyParentViewBoundingRects
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parentIgnoresVisible
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|ignoreVisible
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parentIgnoresOpacity
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|ignoreOpacity
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allChildrenDirty
condition|)
block|{
name|child
operator|->
name|d_ptr
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|d_ptr
operator|->
name|fullUpdatePending
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|d_ptr
operator|->
name|dirtyChildren
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|d_ptr
operator|->
name|allChildrenDirty
operator|=
literal|1
expr_stmt|;
block|}
name|processDirtyItemsRecursive
argument_list|(
name|child
argument_list|,
name|dirtyAncestorContainsChildren
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemClipsChildrenToShape
condition|)
block|{
comment|// Reset updateClip.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|setUpdateClip
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|invalidateChildrenSceneTransform
argument_list|()
expr_stmt|;
block|}
name|resetDirtyItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Paints the given \a items using the provided \a painter, after the     background has been drawn, and before the foreground has been     drawn.  All painting is done in \e scene coordinates. Before     drawing each item, the painter must be transformed using     QGraphicsItem::sceneTransform().      The \a options parameter is the list of style option objects for     each item in \a items. The \a numItems parameter is the number of     items in \a items and options in \a options. The \a widget     parameter is optional; if specified, it should point to the widget     that is being painted on.      The default implementation prepares the painter matrix, and calls     QGraphicsItem::paint() on all items. Reimplement this function to     provide custom painting of all items for the scene; gaining     complete control over how each item is drawn. In some cases this     can increase drawing performance significantly.      Example:      \snippet graphicssceneadditemsnippet.cpp 0      Since Qt 4.6, this function is not called anymore unless     the QGraphicsView::IndirectPainting flag is given as an Optimization     flag.      \sa drawBackground(), drawForeground() */
end_comment
begin_function
DECL|function|drawItems
name|void
name|QGraphicsScene
operator|::
name|drawItems
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
name|int
name|numItems
parameter_list|,
name|QGraphicsItem
modifier|*
name|items
index|[]
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
name|options
index|[]
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// Make sure we don't have unpolished items before we draw.
if|if
condition|(
operator|!
name|d
operator|->
name|unpolishedItems
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|_q_polishItems
argument_list|()
expr_stmt|;
specifier|const
name|qreal
name|opacity
init|=
name|painter
operator|->
name|opacity
argument_list|()
decl_stmt|;
name|QTransform
name|viewTransform
init|=
name|painter
operator|->
name|worldTransform
argument_list|()
decl_stmt|;
name|Q_UNUSED
argument_list|(
name|options
argument_list|)
expr_stmt|;
comment|// Determine view, expose and flags.
name|QGraphicsView
modifier|*
name|view
init|=
name|widget
condition|?
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|parentWidget
argument_list|()
argument_list|)
else|:
literal|0
decl_stmt|;
name|QRegion
modifier|*
name|expose
init|=
literal|0
decl_stmt|;
specifier|const
name|quint32
name|oldRectAdjust
init|=
name|d
operator|->
name|rectAdjust
decl_stmt|;
if|if
condition|(
name|view
condition|)
block|{
name|d
operator|->
name|updateAll
operator|=
literal|false
expr_stmt|;
name|expose
operator|=
operator|&
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|exposedRegion
expr_stmt|;
if|if
condition|(
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|optimizationFlags
operator|&
name|QGraphicsView
operator|::
name|DontAdjustForAntialiasing
condition|)
name|d
operator|->
name|rectAdjust
operator|=
literal|1
expr_stmt|;
else|else
name|d
operator|->
name|rectAdjust
operator|=
literal|2
expr_stmt|;
block|}
comment|// Find all toplevels, they are already sorted.
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|topLevelItems
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
index|[
name|i
index|]
operator|->
name|topLevelItem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
condition|)
block|{
name|topLevelItems
operator|<<
name|item
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|drawSubtreeRecursive
argument_list|(
name|item
argument_list|,
name|painter
argument_list|,
operator|&
name|viewTransform
argument_list|,
name|expose
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|rectAdjust
operator|=
name|oldRectAdjust
expr_stmt|;
comment|// Reset discovery bits.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topLevelItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|topLevelItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|itemDiscovered
operator|=
literal|0
expr_stmt|;
name|painter
operator|->
name|setWorldTransform
argument_list|(
name|viewTransform
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Finds a new widget to give the keyboard focus to, as appropriate for Tab     and Shift+Tab, and returns true if it can find a new widget, or false if     it cannot. If \a next is true, this function searches forward; if \a next     is false, it searches backward.      You can reimplement this function in a subclass of QGraphicsScene to     provide fine-grained control over how tab focus passes inside your     scene. The default implementation is based on the tab focus chain defined     by QGraphicsWidget::setTabOrder(). */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QGraphicsScene
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|item
init|=
name|focusItem
argument_list|()
decl_stmt|;
if|if
condition|(
name|item
operator|&&
operator|!
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
comment|// Tab out of the scene.
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|item
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|lastFocusItem
operator|&&
operator|!
name|d
operator|->
name|lastFocusItem
operator|->
name|isWidget
argument_list|()
condition|)
block|{
comment|// Restore focus to the last focusable non-widget item that had
comment|// focus.
name|setFocusItem
argument_list|(
name|d
operator|->
name|lastFocusItem
argument_list|,
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|d
operator|->
name|activePanel
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|activePanel
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
condition|)
block|{
name|setFocusItem
argument_list|(
name|d
operator|->
name|activePanel
argument_list|,
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|d
operator|->
name|activePanel
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|fw
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|activePanel
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
decl_stmt|;
do|do
block|{
if|if
condition|(
name|fw
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|TabFocus
condition|)
block|{
name|setFocusItem
argument_list|(
name|fw
argument_list|,
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
do|while
condition|(
name|fw
operator|!=
name|d
operator|->
name|activePanel
condition|)
do|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|item
operator|&&
operator|!
name|d
operator|->
name|tabFocusFirst
condition|)
block|{
comment|// No widgets...
return|return
literal|false
return|;
block|}
comment|// The item must be a widget.
name|QGraphicsWidget
modifier|*
name|widget
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|widget
operator|=
name|next
condition|?
name|d
operator|->
name|tabFocusFirst
else|:
name|d
operator|->
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
expr_stmt|;
block|}
else|else
block|{
name|QGraphicsWidget
modifier|*
name|test
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|widget
operator|=
name|next
condition|?
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
else|:
name|test
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
expr_stmt|;
if|if
condition|(
operator|!
name|widget
operator|->
name|panel
argument_list|()
operator|&&
operator|(
operator|(
name|next
operator|&&
name|widget
operator|==
name|d
operator|->
name|tabFocusFirst
operator|)
operator|||
operator|(
operator|!
name|next
operator|&&
name|widget
operator|==
name|d
operator|->
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|)
operator|)
condition|)
block|{
comment|// Tab out of the scene.
return|return
literal|false
return|;
block|}
block|}
name|QGraphicsWidget
modifier|*
name|widgetThatHadFocus
init|=
name|widget
decl_stmt|;
comment|// Run around the focus chain until we find a widget that can take tab focus.
do|do
block|{
if|if
condition|(
name|widget
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|&&
name|widget
operator|->
name|isEnabled
argument_list|()
operator|&&
name|widget
operator|->
name|isVisibleTo
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|widget
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|TabFocus
operator|)
operator|&&
operator|(
operator|!
name|item
operator|||
operator|!
name|item
operator|->
name|isPanel
argument_list|()
operator|||
name|item
operator|->
name|isAncestorOf
argument_list|(
name|widget
argument_list|)
operator|)
condition|)
block|{
name|setFocusItem
argument_list|(
name|widget
argument_list|,
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|widget
operator|=
name|next
condition|?
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
else|:
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|&&
name|widget
operator|==
name|d
operator|->
name|tabFocusFirst
operator|)
operator|||
operator|(
operator|!
name|next
operator|&&
name|widget
operator|==
name|d
operator|->
name|tabFocusFirst
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|)
condition|)
return|return
literal|false
return|;
block|}
do|while
condition|(
name|widget
operator|!=
name|widgetThatHadFocus
condition|)
do|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsScene::changed(const QList<QRectF>&region)      This signal is emitted by QGraphicsScene when control reaches the     event loop, if the scene content changes. The \a region parameter     contains a list of scene rectangles that indicate the area that     has been changed.      \sa QGraphicsView::updateScene() */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScene::sceneRectChanged(const QRectF&rect)      This signal is emitted by QGraphicsScene whenever the scene rect changes.     The \a rect parameter is the new scene rectangle.      \sa QGraphicsView::updateSceneRect() */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScene::selectionChanged()     \since 4.3      This signal is emitted by QGraphicsScene whenever the selection     changes. You can call selectedItems() to get the new list of selected     items.      The selection changes whenever an item is selected or unselected, a     selection area is set, cleared or otherwise changed, if a preselected item     is added to the scene, or if a selected item is removed from the scene.      QGraphicsScene emits this signal only once for group selection operations.     For example, if you set a selection area, select or unselect a     QGraphicsItemGroup, or if you add or remove from the scene a parent item     that contains several selected items, selectionChanged() is emitted only     once after the operation has completed (instead of once for each item).      \sa setSelectionArea(), selectedItems(), QGraphicsItem::setSelected() */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScene::focusChanged(QGraphicsItem *newFocusItem, QGraphicsItem *oldFocusItem, Qt::FocusReason reason)      This signal is emitted by QGraphicsScene whenever focus changes in the     scene (i.e., when an item gains or loses input focus, or when focus     passes from one item to another). You can connect to this signal if you     need to keep track of when other items gain input focus. It is     particularily useful for implementing virtual keyboards, input methods,     and cursor items.      \a oldFocusItem is a pointer to the item that previously had focus, or     0 if no item had focus before the signal was emitted. \a newFocusItem     is a pointer to the item that gained input focus, or 0 if focus was lost.     \a reason is the reason for the focus change (e.g., if the scene was     deactivated while an input field had focus, \a oldFocusItem would point     to the input field item, \a newFocusItem would be 0, and \a reason would be     Qt::ActiveWindowFocusReason. */
end_comment
begin_comment
comment|/*!     \since 4.4      Returns the scene's style, or the same as QApplication::style() if the     scene has not been explicitly assigned a style.      \sa setStyle() */
end_comment
begin_function
DECL|function|style
name|QStyle
modifier|*
name|QGraphicsScene
operator|::
name|style
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// ### This function, and the use of styles in general, is non-reentrant.
return|return
name|d
operator|->
name|style
condition|?
name|d
operator|->
name|style
else|:
name|QApplication
operator|::
name|style
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets or replaces the style of the scene to \a style, and reparents the     style to this scene. Any previously assigned style is deleted. The scene's     style defaults to QApplication::style(), and serves as the default for all     QGraphicsWidget items in the scene.      Changing the style, either directly by calling this function, or     indirectly by calling QApplication::setStyle(), will automatically update     the style for all widgets in the scene that do not have a style explicitly     assigned to them.      If \a style is 0, QGraphicsScene will revert to QApplication::style().      \sa style() */
end_comment
begin_function
DECL|function|setStyle
name|void
name|QGraphicsScene
operator|::
name|setStyle
parameter_list|(
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
comment|// ### This function, and the use of styles in general, is non-reentrant.
if|if
condition|(
name|style
operator|==
name|d
operator|->
name|style
condition|)
return|return;
comment|// Delete the old style,
operator|delete
name|d
operator|->
name|style
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|style
operator|=
name|style
operator|)
condition|)
name|d
operator|->
name|style
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Notify the scene.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
comment|// Notify all widgets that don't have a style explicitly set.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|)
condition|)
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|widget
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::font     \since 4.4     \brief the scene's default font      This property provides the scene's font. The scene font defaults to,     and resolves all its entries from, QApplication::font.      If the scene's font changes, either directly through setFont() or     indirectly when the application font changes, QGraphicsScene first     sends itself a \l{QEvent::FontChange}{FontChange} event, and it then     sends \l{QEvent::FontChange}{FontChange} events to all top-level     widget items in the scene. These items respond by resolving their own     fonts to the scene, and they then notify their children, who again     notify their children, and so on, until all widget items have updated     their fonts.      Changing the scene font, (directly or indirectly through     QApplication::setFont(),) automatically schedules a redraw the entire     scene.      \sa QWidget::font, QApplication::setFont(), palette, style() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGraphicsScene
operator|::
name|font
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|font
return|;
block|}
end_function
begin_function
DECL|function|setFont
name|void
name|QGraphicsScene
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QFont
name|naturalFont
init|=
name|QApplication
operator|::
name|font
argument_list|()
decl_stmt|;
name|naturalFont
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QFont
name|resolvedFont
init|=
name|font
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
decl_stmt|;
name|d
operator|->
name|setFont_helper
argument_list|(
name|resolvedFont
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScene::palette     \since 4.4     \brief the scene's default palette      This property provides the scene's palette. The scene palette defaults to,     and resolves all its entries from, QApplication::palette.      If the scene's palette changes, either directly through setPalette() or     indirectly when the application palette changes, QGraphicsScene first     sends itself a \l{QEvent::PaletteChange}{PaletteChange} event, and it then     sends \l{QEvent::PaletteChange}{PaletteChange} events to all top-level     widget items in the scene. These items respond by resolving their own     palettes to the scene, and they then notify their children, who again     notify their children, and so on, until all widget items have updated     their palettes.      Changing the scene palette, (directly or indirectly through     QApplication::setPalette(),) automatically schedules a redraw the entire     scene.      \sa QWidget::palette, QApplication::setPalette(), font, style() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QGraphicsScene
operator|::
name|palette
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|palette
return|;
block|}
end_function
begin_function
DECL|function|setPalette
name|void
name|QGraphicsScene
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|QPalette
name|naturalPalette
init|=
name|QApplication
operator|::
name|palette
argument_list|()
decl_stmt|;
name|naturalPalette
operator|.
name|resolve
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPalette
name|resolvedPalette
init|=
name|palette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
decl_stmt|;
name|d
operator|->
name|setPalette_helper
argument_list|(
name|resolvedPalette
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns true if the scene is active (e.g., it's viewed by     at least one QGraphicsView that is active); otherwise returns false.      \sa QGraphicsItem::isActive(), QWidget::isActiveWindow() */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QGraphicsScene
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|activationRefCount
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the current active panel, or 0 if no panel is currently active.      \sa QGraphicsScene::setActivePanel() */
end_comment
begin_function
DECL|function|activePanel
name|QGraphicsItem
modifier|*
name|QGraphicsScene
operator|::
name|activePanel
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|activePanel
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Activates \a item, which must be an item in this scene. You     can also pass 0 for \a item, in which case QGraphicsScene will     deactivate any currently active panel.      If the scene is currently inactive, \a item remains inactive until the     scene becomes active (or, ir \a item is 0, no item will be activated).      \sa activePanel(), isActive(), QGraphicsItem::isActive() */
end_comment
begin_function
DECL|function|setActivePanel
name|void
name|QGraphicsScene
operator|::
name|setActivePanel
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|d
operator|->
name|setActivePanelHelper
argument_list|(
name|item
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the current active window, or 0 if no window is currently     active.      \sa QGraphicsScene::setActiveWindow() */
end_comment
begin_function
DECL|function|activeWindow
name|QGraphicsWidget
modifier|*
name|QGraphicsScene
operator|::
name|activeWindow
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|activePanel
operator|&&
name|d
operator|->
name|activePanel
operator|->
name|isWindow
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|activePanel
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Activates \a widget, which must be a widget in this scene. You can also     pass 0 for \a widget, in which case QGraphicsScene will deactivate any     currently active window.      \sa activeWindow(), QGraphicsWidget::isActiveWindow() */
end_comment
begin_function
DECL|function|setActiveWindow
name|void
name|QGraphicsScene
operator|::
name|setActiveWindow
parameter_list|(
name|QGraphicsWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|scene
argument_list|()
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::setActiveWindow: widget %p must be part of this scene"
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Activate the widget's panel (all windows are panels).
name|QGraphicsItem
modifier|*
name|panel
init|=
name|widget
condition|?
name|widget
operator|->
name|panel
argument_list|()
else|:
literal|0
decl_stmt|;
name|setActivePanel
argument_list|(
name|panel
argument_list|)
expr_stmt|;
comment|// Raise
if|if
condition|(
name|panel
condition|)
block|{
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|siblingWindows
decl_stmt|;
name|QGraphicsItem
modifier|*
name|parent
init|=
name|panel
operator|->
name|parentItem
argument_list|()
decl_stmt|;
comment|// Raise ### inefficient for toplevels
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|sibling
decl|,
name|parent
condition|?
name|parent
operator|->
name|childItems
argument_list|()
else|:
name|items
argument_list|()
control|)
block|{
if|if
condition|(
name|sibling
operator|!=
name|panel
operator|&&
name|sibling
operator|->
name|isWindow
argument_list|()
condition|)
name|siblingWindows
operator|<<
name|sibling
expr_stmt|;
block|}
comment|// Find the highest z value.
name|qreal
name|z
init|=
name|panel
operator|->
name|zValue
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|siblingWindows
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|z
operator|=
name|qMax
argument_list|(
name|z
argument_list|,
name|siblingWindows
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|zValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// This will probably never overflow.
specifier|const
name|qreal
name|litt
init|=
name|qreal
argument_list|(
literal|0.001
argument_list|)
decl_stmt|;
name|panel
operator|->
name|setZValue
argument_list|(
name|z
operator|+
name|litt
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sends event \a event to item \a item through possible event filters.      The event is sent only if the item is enabled.      Returns \c false if the event was filtered or if the item is disabled.     Otherwise returns the value that was returned from the event handler.      \sa QGraphicsItem::sceneEvent(), QGraphicsItem::sceneEventFilter() */
end_comment
begin_function
DECL|function|sendEvent
name|bool
name|QGraphicsScene
operator|::
name|sendEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::sendEvent: cannot send event to a null item"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|item
operator|->
name|scene
argument_list|()
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsScene::sendEvent: item %p's scene (%p)"
literal|" is different from this scene (%p)"
argument_list|,
name|item
argument_list|,
name|item
operator|->
name|scene
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|sendEvent
argument_list|(
name|item
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addView
name|void
name|QGraphicsScenePrivate
operator|::
name|addView
parameter_list|(
name|QGraphicsView
modifier|*
name|view
parameter_list|)
block|{
name|views
operator|<<
name|view
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|gesture
decl|,
name|grabbedGestures
operator|.
name|keys
argument_list|()
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|grabGesture
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|removeView
name|void
name|QGraphicsScenePrivate
operator|::
name|removeView
parameter_list|(
name|QGraphicsView
modifier|*
name|view
parameter_list|)
block|{
name|views
operator|.
name|removeAll
argument_list|(
name|view
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateTouchPointsForItem
name|void
name|QGraphicsScenePrivate
operator|::
name|updateTouchPointsForItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QTouchEvent
modifier|*
name|touchEvent
parameter_list|)
block|{
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
name|touchPoints
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchPoints
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchPoints
index|[
name|i
index|]
decl_stmt|;
name|touchPoint
operator|.
name|setRect
argument_list|(
name|item
operator|->
name|mapFromScene
argument_list|(
name|touchPoint
operator|.
name|sceneRect
argument_list|()
argument_list|)
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setStartPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|touchPoint
operator|.
name|startScenePos
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|touchEvent
operator|->
name|target
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|setLastPos
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|genericMapFromScene
argument_list|(
name|touchPoint
operator|.
name|lastScenePos
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|touchEvent
operator|->
name|target
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|touchEvent
operator|->
name|setTouchPoints
argument_list|(
name|touchPoints
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findClosestTouchPointId
name|int
name|QGraphicsScenePrivate
operator|::
name|findClosestTouchPointId
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|scenePos
parameter_list|)
block|{
name|int
name|closestTouchPointId
init|=
operator|-
literal|1
decl_stmt|;
name|qreal
name|closestDistance
init|=
name|qreal
argument_list|(
literal|0.
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
decl|,
name|sceneCurrentTouchPoints
control|)
block|{
name|qreal
name|distance
init|=
name|QLineF
argument_list|(
name|scenePos
argument_list|,
name|touchPoint
operator|.
name|scenePos
argument_list|()
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|closestTouchPointId
operator|==
operator|-
literal|1
operator|||
name|distance
operator|<
name|closestDistance
condition|)
block|{
name|closestTouchPointId
operator|=
name|touchPoint
operator|.
name|id
argument_list|()
expr_stmt|;
name|closestDistance
operator|=
name|distance
expr_stmt|;
block|}
block|}
return|return
name|closestTouchPointId
return|;
block|}
end_function
begin_function
DECL|function|touchEventHandler
name|void
name|QGraphicsScenePrivate
operator|::
name|touchEventHandler
parameter_list|(
name|QTouchEvent
modifier|*
name|sceneTouchEvent
parameter_list|)
block|{
typedef|typedef
name|QPair
argument_list|<
name|Qt
operator|::
name|TouchPointStates
argument_list|,
name|QList
argument_list|<
name|QTouchEvent
operator|::
name|TouchPoint
argument_list|>
argument_list|>
name|StatesAndTouchPoints
typedef|;
name|QHash
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
name|itemsNeedingEvents
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sceneTouchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|sceneTouchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// update state
name|QGraphicsItem
modifier|*
name|item
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointPressed
condition|)
block|{
if|if
condition|(
name|sceneTouchEvent
operator|->
name|device
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
comment|// on touch-pad devices, send all touch points to the same item
name|item
operator|=
name|itemForTouchPointId
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|itemForTouchPointId
operator|.
name|constBegin
argument_list|()
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|item
condition|)
block|{
comment|// determine which item this touch point will go to
name|cachedItemsUnderMouse
operator|=
name|itemsAtPosition
argument_list|(
name|touchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|,
name|touchPoint
operator|.
name|scenePos
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|sceneTouchEvent
operator|->
name|target
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
name|cachedItemsUnderMouse
operator|.
name|first
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sceneTouchEvent
operator|->
name|device
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchScreen
condition|)
block|{
comment|// on touch-screens, combine this touch point with the closest one we find
name|int
name|closestTouchPointId
init|=
name|findClosestTouchPointId
argument_list|(
name|touchPoint
operator|.
name|scenePos
argument_list|()
argument_list|)
decl_stmt|;
name|QGraphicsItem
modifier|*
name|closestItem
init|=
name|itemForTouchPointId
operator|.
name|value
argument_list|(
name|closestTouchPointId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|||
operator|(
name|closestItem
operator|&&
name|cachedItemsUnderMouse
operator|.
name|contains
argument_list|(
name|closestItem
argument_list|)
operator|)
condition|)
name|item
operator|=
name|closestItem
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|itemForTouchPointId
operator|.
name|insert
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|sceneCurrentTouchPoints
operator|.
name|insert
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|,
name|touchPoint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|touchPoint
operator|.
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
block|{
name|item
operator|=
name|itemForTouchPointId
operator|.
name|take
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|sceneCurrentTouchPoints
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|itemForTouchPointId
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
name|sceneCurrentTouchPoints
operator|.
name|contains
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sceneCurrentTouchPoints
index|[
name|touchPoint
operator|.
name|id
argument_list|()
index|]
operator|=
name|touchPoint
expr_stmt|;
block|}
name|StatesAndTouchPoints
modifier|&
name|statesAndTouchPoints
init|=
name|itemsNeedingEvents
index|[
name|item
index|]
decl_stmt|;
name|statesAndTouchPoints
operator|.
name|first
operator||=
name|touchPoint
operator|.
name|state
argument_list|()
expr_stmt|;
name|statesAndTouchPoints
operator|.
name|second
operator|.
name|append
argument_list|(
name|touchPoint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itemsNeedingEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sceneTouchEvent
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|bool
name|ignoreSceneTouchEvent
init|=
literal|true
decl_stmt|;
name|QHash
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|itemsNeedingEvents
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|StatesAndTouchPoints
argument_list|>
operator|::
name|ConstIterator
name|end
init|=
name|itemsNeedingEvents
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
operator|(
name|void
operator|)
name|item
operator|->
name|isBlockedByModalPanel
argument_list|(
operator|&
name|item
argument_list|)
expr_stmt|;
comment|// determine event type from the state mask
name|QEvent
operator|::
name|Type
name|eventType
decl_stmt|;
switch|switch
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
condition|)
block|{
case|case
name|Qt
operator|::
name|TouchPointPressed
case|:
comment|// all touch points have pressed state
name|eventType
operator|=
name|QEvent
operator|::
name|TouchBegin
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointReleased
case|:
comment|// all touch points have released state
name|eventType
operator|=
name|QEvent
operator|::
name|TouchEnd
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|TouchPointStationary
case|:
comment|// don't send the event if nothing changed
continue|continue;
default|default:
comment|// all other combinations
name|eventType
operator|=
name|QEvent
operator|::
name|TouchUpdate
expr_stmt|;
break|break;
block|}
name|QTouchEvent
name|touchEvent
argument_list|(
name|eventType
argument_list|)
decl_stmt|;
name|touchEvent
operator|.
name|setWindow
argument_list|(
name|sceneTouchEvent
operator|->
name|window
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTarget
argument_list|(
name|sceneTouchEvent
operator|->
name|target
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setDevice
argument_list|(
name|sceneTouchEvent
operator|->
name|device
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setModifiers
argument_list|(
name|sceneTouchEvent
operator|->
name|modifiers
argument_list|()
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTouchPointStates
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|first
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTouchPoints
argument_list|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|second
argument_list|)
expr_stmt|;
name|touchEvent
operator|.
name|setTimestamp
argument_list|(
name|sceneTouchEvent
operator|->
name|timestamp
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|touchEvent
operator|.
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|TouchBegin
case|:
block|{
comment|// if the TouchBegin handler recurses, we assume that means the event
comment|// has been implicitly accepted and continue to send touch events
name|item
operator|->
name|d_ptr
operator|->
name|acceptedTouchBeginEvent
operator|=
literal|true
expr_stmt|;
name|bool
name|res
init|=
name|sendTouchBeginEvent
argument_list|(
name|item
argument_list|,
operator|&
name|touchEvent
argument_list|)
operator|&&
name|touchEvent
operator|.
name|isAccepted
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
comment|// forget about these touch points, we didn't handle them
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|.
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|.
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|itemForTouchPointId
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
name|sceneCurrentTouchPoints
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ignoreSceneTouchEvent
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
default|default:
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|acceptedTouchBeginEvent
condition|)
block|{
name|updateTouchPointsForItem
argument_list|(
name|item
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|touchEvent
argument_list|)
expr_stmt|;
name|ignoreSceneTouchEvent
operator|=
literal|false
expr_stmt|;
block|}
break|break;
block|}
block|}
name|sceneTouchEvent
operator|->
name|setAccepted
argument_list|(
name|ignoreSceneTouchEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendTouchBeginEvent
name|bool
name|QGraphicsScenePrivate
operator|::
name|sendTouchBeginEvent
parameter_list|(
name|QGraphicsItem
modifier|*
name|origin
parameter_list|,
name|QTouchEvent
modifier|*
name|touchEvent
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachedItemsUnderMouse
operator|.
name|isEmpty
argument_list|()
operator|||
name|cachedItemsUnderMouse
operator|.
name|first
argument_list|()
operator|!=
name|origin
condition|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|firstTouchPoint
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|cachedItemsUnderMouse
operator|=
name|itemsAtPosition
argument_list|(
name|firstTouchPoint
operator|.
name|screenPos
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|,
name|firstTouchPoint
operator|.
name|scenePos
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|touchEvent
operator|->
name|target
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Set focus on the topmost enabled item that can take focus.
name|bool
name|setFocus
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|cachedItemsUnderMouse
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|)
operator|&&
name|item
operator|->
name|d_ptr
operator|->
name|mouseSetsFocus
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|isWidget
argument_list|()
operator|||
operator|(
operator|(
name|QGraphicsWidget
operator|*
operator|)
name|item
operator|)
operator|->
name|focusPolicy
argument_list|()
operator|&
name|Qt
operator|::
name|ClickFocus
condition|)
block|{
name|setFocus
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|q
operator|->
name|focusItem
argument_list|()
condition|)
name|q
operator|->
name|setFocusItem
argument_list|(
name|item
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
condition|)
break|break;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStopsClickFocusPropagation
condition|)
break|break;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStopsFocusHandling
condition|)
block|{
comment|// Make sure we don't clear focus.
name|setFocus
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If nobody could take focus, clear it.
if|if
condition|(
operator|!
name|stickyFocus
operator|&&
operator|!
name|setFocus
condition|)
name|q
operator|->
name|setFocusItem
argument_list|(
literal|0
argument_list|,
name|Qt
operator|::
name|MouseFocusReason
argument_list|)
expr_stmt|;
name|bool
name|res
init|=
literal|false
decl_stmt|;
name|bool
name|eventAccepted
init|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|cachedItemsUnderMouse
control|)
block|{
comment|// first, try to deliver the touch event
name|updateTouchPointsForItem
argument_list|(
name|item
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
name|bool
name|acceptTouchEvents
init|=
name|item
operator|->
name|acceptTouchEvents
argument_list|()
decl_stmt|;
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|acceptTouchEvents
argument_list|)
expr_stmt|;
name|res
operator|=
name|acceptTouchEvents
operator|&&
name|sendEvent
argument_list|(
name|item
argument_list|,
name|touchEvent
argument_list|)
expr_stmt|;
name|eventAccepted
operator|=
name|touchEvent
operator|->
name|isAccepted
argument_list|()
expr_stmt|;
if|if
condition|(
name|itemForTouchPointId
operator|.
name|value
argument_list|(
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|first
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// item was deleted
name|item
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|d_ptr
operator|->
name|acceptedTouchBeginEvent
operator|=
operator|(
name|res
operator|&&
name|eventAccepted
operator|)
expr_stmt|;
block|}
name|touchEvent
operator|->
name|spont
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|res
operator|&&
name|eventAccepted
condition|)
block|{
comment|// the first item to accept the TouchBegin gets an implicit grab.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTouchEvent
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|touchEvent
operator|->
name|touchPoints
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|itemForTouchPointId
index|[
name|touchPoint
operator|.
name|id
argument_list|()
index|]
operator|=
name|item
expr_stmt|;
comment|// can be zero
block|}
break|break;
block|}
if|if
condition|(
name|item
operator|&&
name|item
operator|->
name|isPanel
argument_list|()
condition|)
break|break;
block|}
name|touchEvent
operator|->
name|setAccepted
argument_list|(
name|eventAccepted
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|enableTouchEventsOnViews
name|void
name|QGraphicsScenePrivate
operator|::
name|enableTouchEventsOnViews
parameter_list|()
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_AcceptTouchEvents
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateInputMethodSensitivityInViews
name|void
name|QGraphicsScenePrivate
operator|::
name|updateInputMethodSensitivityInViews
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|updateInputMethodSensitivity
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|enterModal
name|void
name|QGraphicsScenePrivate
operator|::
name|enterModal
parameter_list|(
name|QGraphicsItem
modifier|*
name|panel
parameter_list|,
name|QGraphicsItem
operator|::
name|PanelModality
name|previousModality
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|panel
operator|&&
name|panel
operator|->
name|isPanel
argument_list|()
argument_list|)
expr_stmt|;
name|QGraphicsItem
operator|::
name|PanelModality
name|panelModality
init|=
name|panel
operator|->
name|d_ptr
operator|->
name|panelModality
decl_stmt|;
if|if
condition|(
name|previousModality
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
block|{
comment|// the panel is changing from one modality type to another... temporarily set it back so
comment|// that blockedPanels is populated correctly
name|panel
operator|->
name|d_ptr
operator|->
name|panelModality
operator|=
name|previousModality
expr_stmt|;
block|}
name|QSet
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|blockedPanels
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|items
init|=
name|q
operator|->
name|items
argument_list|()
decl_stmt|;
comment|// ### store panels separately
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
name|blockedPanels
operator|.
name|insert
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
comment|// blockedPanels contains all currently blocked panels
if|if
condition|(
name|previousModality
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
block|{
comment|// reset the modality to the proper value, since we changed it above
name|panel
operator|->
name|d_ptr
operator|->
name|panelModality
operator|=
name|panelModality
expr_stmt|;
comment|// remove this panel so that it will be reinserted at the front of the stack
name|modalPanels
operator|.
name|removeAll
argument_list|(
name|panel
argument_list|)
expr_stmt|;
block|}
name|modalPanels
operator|.
name|prepend
argument_list|(
name|panel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hoverItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// send GraphicsSceneHoverLeave events to newly blocked hoverItems
name|QGraphicsSceneHoverEvent
name|hoverEvent
decl_stmt|;
name|hoverEvent
operator|.
name|setScenePos
argument_list|(
name|lastSceneMousePos
argument_list|)
expr_stmt|;
name|dispatchHoverEvent
argument_list|(
operator|&
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mouseGrabberItems
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|mouseGrabberItems
operator|.
name|last
argument_list|()
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
name|ungrabMouse
argument_list|(
name|item
argument_list|,
comment|/*itemIsDying =*/
literal|false
argument_list|)
expr_stmt|;
block|}
name|QEvent
name|windowBlockedEvent
argument_list|(
name|QEvent
operator|::
name|WindowBlocked
argument_list|)
decl_stmt|;
name|QEvent
name|windowUnblockedEvent
argument_list|(
name|QEvent
operator|::
name|WindowUnblocked
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|blockedPanels
operator|.
name|contains
argument_list|(
name|item
argument_list|)
operator|&&
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
block|{
comment|// send QEvent::WindowBlocked to newly blocked panels
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|windowBlockedEvent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blockedPanels
operator|.
name|contains
argument_list|(
name|item
argument_list|)
operator|&&
operator|!
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
block|{
comment|// send QEvent::WindowUnblocked to unblocked panels when downgrading
comment|// a panel from SceneModal to PanelModal
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|windowUnblockedEvent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|leaveModal
name|void
name|QGraphicsScenePrivate
operator|::
name|leaveModal
parameter_list|(
name|QGraphicsItem
modifier|*
name|panel
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsScene
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|panel
operator|&&
name|panel
operator|->
name|isPanel
argument_list|()
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|blockedPanels
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|items
init|=
name|q
operator|->
name|items
argument_list|()
decl_stmt|;
comment|// ### same as above
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
name|blockedPanels
operator|.
name|insert
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|modalPanels
operator|.
name|removeAll
argument_list|(
name|panel
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|WindowUnblocked
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
operator|&&
name|blockedPanels
operator|.
name|contains
argument_list|(
name|item
argument_list|)
operator|&&
operator|!
name|item
operator|->
name|isBlockedByModalPanel
argument_list|()
condition|)
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
comment|// send GraphicsSceneHoverEnter events to newly unblocked items
name|QGraphicsSceneHoverEvent
name|hoverEvent
decl_stmt|;
name|hoverEvent
operator|.
name|setScenePos
argument_list|(
name|lastSceneMousePos
argument_list|)
expr_stmt|;
name|dispatchHoverEvent
argument_list|(
operator|&
name|hoverEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_function
DECL|function|gestureTargetsAtHotSpots
name|void
name|QGraphicsScenePrivate
operator|::
name|gestureTargetsAtHotSpots
parameter_list|(
specifier|const
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
modifier|&
name|gestures
parameter_list|,
name|Qt
operator|::
name|GestureFlag
name|flag
parameter_list|,
name|QHash
argument_list|<
name|QGraphicsObject
modifier|*
argument_list|,
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
argument_list|>
modifier|*
name|targets
parameter_list|,
name|QSet
argument_list|<
name|QGraphicsObject
modifier|*
argument_list|>
modifier|*
name|itemsSet
parameter_list|,
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
modifier|*
name|normal
parameter_list|,
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
modifier|*
name|conflicts
parameter_list|)
block|{
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|normalGestures
decl_stmt|;
comment|// that are not in conflicted state.
foreach|foreach
control|(
name|QGesture
modifier|*
name|gesture
decl|,
name|gestures
control|)
block|{
if|if
condition|(
operator|!
name|gesture
operator|->
name|hasHotSpot
argument_list|()
condition|)
continue|continue;
specifier|const
name|Qt
operator|::
name|GestureType
name|gestureType
init|=
name|gesture
operator|->
name|gestureType
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|items
init|=
name|itemsAtPosition
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|gesture
operator|->
name|d_func
argument_list|()
operator|->
name|sceneHotSpot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|items
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// Check if the item is blocked by a modal panel and use it as
comment|// a target instead of this item.
operator|(
name|void
operator|)
name|item
operator|->
name|isBlockedByModalPanel
argument_list|(
operator|&
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|QGraphicsObject
modifier|*
name|itemobj
init|=
name|item
operator|->
name|toGraphicsObject
argument_list|()
condition|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|item
operator|->
name|QGraphicsItem
operator|::
name|d_func
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|Qt
operator|::
name|GestureType
argument_list|,
name|Qt
operator|::
name|GestureFlags
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|gestureContext
operator|.
name|constFind
argument_list|(
name|gestureType
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|gestureContext
operator|.
name|constEnd
argument_list|()
operator|&&
operator|(
operator|!
name|flag
operator|||
operator|(
name|it
operator|.
name|value
argument_list|()
operator|&
name|flag
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|normalGestures
operator|.
name|contains
argument_list|(
name|gesture
argument_list|)
condition|)
block|{
name|normalGestures
operator|.
name|remove
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts
condition|)
name|conflicts
operator|->
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|normalGestures
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targets
condition|)
operator|(
operator|*
name|targets
operator|)
index|[
name|itemobj
index|]
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemsSet
condition|)
operator|(
operator|*
name|itemsSet
operator|)
operator|.
name|insert
argument_list|(
name|itemobj
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Don't propagate through panels.
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|normal
condition|)
operator|*
name|normal
operator|=
name|normalGestures
expr_stmt|;
block|}
end_function
begin_function
DECL|function|gestureEventHandler
name|void
name|QGraphicsScenePrivate
operator|::
name|gestureEventHandler
parameter_list|(
name|QGestureEvent
modifier|*
name|event
parameter_list|)
block|{
name|QWidget
modifier|*
name|viewport
init|=
name|event
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|viewport
condition|)
return|return;
name|QGraphicsView
modifier|*
name|graphicsView
init|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|viewport
operator|->
name|parent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|graphicsView
condition|)
return|return;
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|allGestures
init|=
name|event
operator|->
name|gestures
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"Gestures:"
operator|<<
name|allGestures
expr_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|startedGestures
decl_stmt|;
name|QPoint
name|delta
init|=
name|viewport
operator|->
name|mapFromGlobal
argument_list|(
name|QPoint
argument_list|()
argument_list|)
decl_stmt|;
name|QTransform
name|toScene
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|delta
operator|.
name|x
argument_list|()
argument_list|,
name|delta
operator|.
name|y
argument_list|()
argument_list|)
operator|*
name|graphicsView
operator|->
name|viewportTransform
argument_list|()
operator|.
name|inverted
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QGesture
modifier|*
name|gesture
decl|,
name|allGestures
control|)
block|{
comment|// cache scene coordinates of the hot spot
if|if
condition|(
name|gesture
operator|->
name|hasHotSpot
argument_list|()
condition|)
block|{
name|gesture
operator|->
name|d_func
argument_list|()
operator|->
name|sceneHotSpot
operator|=
name|toScene
operator|.
name|map
argument_list|(
name|gesture
operator|->
name|hotSpot
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gesture
operator|->
name|d_func
argument_list|()
operator|->
name|sceneHotSpot
operator|=
name|QPointF
argument_list|()
expr_stmt|;
block|}
name|QGraphicsObject
modifier|*
name|target
init|=
name|gestureTargets
operator|.
name|value
argument_list|(
name|gesture
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
comment|// when we are not in started mode but don't have a target
comment|// then the only one interested in gesture is the view/scene
if|if
condition|(
name|gesture
operator|->
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|GestureStarted
condition|)
name|startedGestures
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|startedGestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|normalGestures
decl_stmt|;
comment|// that have just one target
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|conflictedGestures
decl_stmt|;
comment|// that have multiple possible targets
name|gestureTargetsAtHotSpots
argument_list|(
name|startedGestures
argument_list|,
name|Qt
operator|::
name|GestureFlag
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|cachedItemGestures
argument_list|,
literal|0
argument_list|,
operator|&
name|normalGestures
argument_list|,
operator|&
name|conflictedGestures
argument_list|)
expr_stmt|;
name|cachedTargetItems
operator|=
name|cachedItemGestures
operator|.
name|keys
argument_list|()
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|cachedTargetItems
operator|.
name|begin
argument_list|()
argument_list|,
name|cachedTargetItems
operator|.
name|end
argument_list|()
argument_list|,
name|qt_closestItemFirst
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"Normal gestures:"
operator|<<
name|normalGestures
operator|<<
literal|"Conflicting gestures:"
operator|<<
name|conflictedGestures
expr_stmt|;
comment|// deliver conflicted gestures as override events AND remember
comment|// initial gesture targets
if|if
condition|(
operator|!
name|conflictedGestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cachedTargetItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPointer
argument_list|<
name|QGraphicsObject
argument_list|>
name|item
init|=
name|cachedTargetItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// get gestures to deliver to the current item
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|gestures
init|=
name|conflictedGestures
operator|&
name|cachedItemGestures
operator|.
name|value
argument_list|(
name|item
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|gestures
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"delivering override to"
operator|<<
name|item
operator|.
name|data
argument_list|()
operator|<<
name|gestures
expr_stmt|;
comment|// send gesture override
name|QGestureEvent
name|ev
argument_list|(
name|gestures
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|ev
operator|.
name|t
operator|=
name|QEvent
operator|::
name|GestureOverride
expr_stmt|;
name|ev
operator|.
name|setWidget
argument_list|(
name|event
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
comment|// mark event and individual gestures as ignored
name|ev
operator|.
name|ignore
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|gestures
control|)
name|ev
operator|.
name|setAccepted
argument_list|(
name|g
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|item
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
comment|// mark all accepted gestures to deliver them as normal gesture events
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|gestures
control|)
block|{
if|if
condition|(
name|ev
operator|.
name|isAccepted
argument_list|()
operator|||
name|ev
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
block|{
name|conflictedGestures
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|// mark the item as a gesture target
if|if
condition|(
name|item
condition|)
block|{
name|gestureTargets
operator|.
name|insert
argument_list|(
name|g
argument_list|,
name|item
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|QHash
argument_list|<
name|QGraphicsObject
modifier|*
argument_list|,
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
argument_list|>
operator|::
name|iterator
name|it
decl_stmt|,
name|e
decl_stmt|;
name|it
operator|=
name|cachedItemGestures
operator|.
name|begin
argument_list|()
expr_stmt|;
name|e
operator|=
name|cachedItemGestures
operator|.
name|end
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|e
condition|;
operator|++
name|it
control|)
name|it
operator|.
name|value
argument_list|()
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|cachedItemGestures
index|[
name|item
operator|.
name|data
argument_list|()
index|]
operator|.
name|insert
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"override was accepted:"
operator|<<
name|g
operator|<<
name|item
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
comment|// remember the first item that received the override event
comment|// as it most likely become a target if no one else accepts
comment|// the override event
if|if
condition|(
operator|!
name|gestureTargets
operator|.
name|contains
argument_list|(
name|g
argument_list|)
operator|&&
name|item
condition|)
name|gestureTargets
operator|.
name|insert
argument_list|(
name|g
argument_list|,
name|item
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conflictedGestures
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
block|}
block|}
comment|// remember the initial target item for each gesture that was not in
comment|// the conflicted state.
if|if
condition|(
operator|!
name|normalGestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cachedTargetItems
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|normalGestures
operator|.
name|isEmpty
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsObject
modifier|*
name|item
init|=
name|cachedTargetItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// get gestures to deliver to the current item
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|cachedItemGestures
operator|.
name|value
argument_list|(
name|item
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|gestureTargets
operator|.
name|contains
argument_list|(
name|g
argument_list|)
condition|)
block|{
name|gestureTargets
operator|.
name|insert
argument_list|(
name|g
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|normalGestures
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// deliver all gesture events
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|undeliveredGestures
decl_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|parentPropagatedGestures
decl_stmt|;
foreach|foreach
control|(
name|QGesture
modifier|*
name|gesture
decl|,
name|allGestures
control|)
block|{
if|if
condition|(
name|QGraphicsObject
modifier|*
name|target
init|=
name|gestureTargets
operator|.
name|value
argument_list|(
name|gesture
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|cachedItemGestures
index|[
name|target
index|]
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
name|cachedTargetItems
operator|.
name|append
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|undeliveredGestures
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|target
operator|->
name|QGraphicsItem
operator|::
name|d_func
argument_list|()
decl_stmt|;
specifier|const
name|Qt
operator|::
name|GestureFlags
name|flags
init|=
name|d
operator|->
name|gestureContext
operator|.
name|value
argument_list|(
name|gesture
operator|->
name|gestureType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|IgnoredGesturesPropagateToParent
condition|)
name|parentPropagatedGestures
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"no target for"
operator|<<
name|gesture
operator|<<
literal|"at"
operator|<<
name|gesture
operator|->
name|hotSpot
argument_list|()
operator|<<
name|gesture
operator|->
name|d_func
argument_list|()
operator|->
name|sceneHotSpot
expr_stmt|;
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|cachedTargetItems
operator|.
name|begin
argument_list|()
argument_list|,
name|cachedTargetItems
operator|.
name|end
argument_list|()
argument_list|,
name|qt_closestItemFirst
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cachedTargetItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPointer
argument_list|<
name|QGraphicsObject
argument_list|>
name|receiver
init|=
name|cachedTargetItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|gestures
init|=
name|undeliveredGestures
operator|&
name|cachedItemGestures
operator|.
name|value
argument_list|(
name|receiver
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|gestures
operator|-=
name|cachedAlreadyDeliveredGestures
operator|.
name|value
argument_list|(
name|receiver
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gestures
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|cachedAlreadyDeliveredGestures
index|[
name|receiver
operator|.
name|data
argument_list|()
index|]
operator|+=
name|gestures
expr_stmt|;
specifier|const
name|bool
name|isPanel
init|=
name|receiver
operator|.
name|data
argument_list|()
operator|->
name|isPanel
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"delivering to"
operator|<<
name|receiver
operator|.
name|data
argument_list|()
operator|<<
name|gestures
expr_stmt|;
name|QGestureEvent
name|ev
argument_list|(
name|gestures
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|ev
operator|.
name|setWidget
argument_list|(
name|event
operator|->
name|widget
argument_list|()
argument_list|)
expr_stmt|;
name|sendEvent
argument_list|(
name|receiver
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|ignoredGestures
decl_stmt|;
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|gestures
control|)
block|{
if|if
condition|(
operator|!
name|ev
operator|.
name|isAccepted
argument_list|()
operator|&&
operator|!
name|ev
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|// if the gesture was ignored by its target, we will update the
comment|// targetItems list with a possible target items (items that
comment|// want to receive partial gestures).
comment|// ### won't work if the target was destroyed in the event
comment|//     we will just stop delivering it.
if|if
condition|(
name|receiver
operator|&&
name|receiver
operator|.
name|data
argument_list|()
operator|==
name|gestureTargets
operator|.
name|value
argument_list|(
name|g
argument_list|,
literal|0
argument_list|)
condition|)
name|ignoredGestures
operator|.
name|insert
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|receiver
operator|&&
name|g
operator|->
name|state
argument_list|()
operator|==
name|Qt
operator|::
name|GestureStarted
condition|)
block|{
comment|// someone accepted the propagated initial GestureStarted
comment|// event, let it be the new target for all following events.
name|gestureTargets
index|[
name|g
index|]
operator|=
name|receiver
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
name|undeliveredGestures
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|undeliveredGestures
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
comment|// ignoredGestures list is only filled when delivering to the gesture
comment|// target item, so it is safe to assume item == target.
if|if
condition|(
operator|!
name|ignoredGestures
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|isPanel
condition|)
block|{
comment|// look for new potential targets for gestures that were ignored
comment|// and should be propagated.
name|QSet
argument_list|<
name|QGraphicsObject
modifier|*
argument_list|>
name|targetsSet
init|=
name|cachedTargetItems
operator|.
name|toSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|receiver
condition|)
block|{
comment|// first if the gesture should be propagated to parents only
for|for
control|(
name|QSet
argument_list|<
name|QGesture
operator|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|ignoredGestures
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|ignoredGestures
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|parentPropagatedGestures
operator|.
name|contains
argument_list|(
operator|*
name|it
argument_list|)
condition|)
block|{
name|QGesture
modifier|*
name|gesture
init|=
operator|*
name|it
decl_stmt|;
specifier|const
name|Qt
operator|::
name|GestureType
name|gestureType
init|=
name|gesture
operator|->
name|gestureType
argument_list|()
decl_stmt|;
name|QGraphicsItem
modifier|*
name|item
init|=
name|receiver
operator|.
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|QGraphicsObject
modifier|*
name|obj
init|=
name|item
operator|->
name|toGraphicsObject
argument_list|()
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|gestureContext
operator|.
name|contains
argument_list|(
name|gestureType
argument_list|)
condition|)
block|{
name|targetsSet
operator|.
name|insert
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cachedItemGestures
index|[
name|obj
index|]
operator|.
name|insert
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|isPanel
argument_list|()
condition|)
break|break;
name|item
operator|=
name|item
operator|->
name|parentItem
argument_list|()
expr_stmt|;
block|}
name|it
operator|=
name|ignoredGestures
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
name|gestureTargetsAtHotSpots
argument_list|(
name|ignoredGestures
argument_list|,
name|Qt
operator|::
name|ReceivePartialGestures
argument_list|,
operator|&
name|cachedItemGestures
argument_list|,
operator|&
name|targetsSet
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cachedTargetItems
operator|=
name|targetsSet
operator|.
name|toList
argument_list|()
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|cachedTargetItems
operator|.
name|begin
argument_list|()
argument_list|,
name|cachedTargetItems
operator|.
name|end
argument_list|()
argument_list|,
name|qt_closestItemFirst
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"QGraphicsScenePrivate::gestureEventHandler:"
operator|<<
literal|"new targets:"
operator|<<
name|cachedTargetItems
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
comment|// start delivery again
continue|continue;
block|}
block|}
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|startedGestures
control|)
block|{
if|if
condition|(
name|g
operator|->
name|gestureCancelPolicy
argument_list|()
operator|==
name|QGesture
operator|::
name|CancelAllInContext
condition|)
block|{
name|DEBUG
argument_list|()
operator|<<
literal|"lets try to cancel some"
expr_stmt|;
comment|// find gestures in context in Qt::GestureStarted or Qt::GestureUpdated state and cancel them
name|cancelGesturesForChildren
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
comment|// forget about targets for gestures that have ended
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|allGestures
control|)
block|{
switch|switch
condition|(
name|g
operator|->
name|state
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|GestureFinished
case|:
case|case
name|Qt
operator|::
name|GestureCanceled
case|:
name|gestureTargets
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|cachedTargetItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cachedItemGestures
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cachedAlreadyDeliveredGestures
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cancelGesturesForChildren
name|void
name|QGraphicsScenePrivate
operator|::
name|cancelGesturesForChildren
parameter_list|(
name|QGesture
modifier|*
name|original
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|original
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|originalItem
init|=
name|gestureTargets
operator|.
name|value
argument_list|(
name|original
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalItem
operator|==
literal|0
condition|)
comment|// we only act on accepted gestures, which implies it has a target.
return|return;
comment|// iterate over all active gestures and for each find the owner
comment|// if the owner is part of our sub-hierarchy, cancel it.
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|canceledGestures
decl_stmt|;
name|QHash
argument_list|<
name|QGesture
modifier|*
argument_list|,
name|QGraphicsObject
modifier|*
argument_list|>
operator|::
name|Iterator
name|iter
init|=
name|gestureTargets
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|!=
name|gestureTargets
operator|.
name|end
argument_list|()
condition|)
block|{
name|QGraphicsObject
modifier|*
name|item
init|=
name|iter
operator|.
name|value
argument_list|()
decl_stmt|;
comment|// note that we don't touch the gestures for our originalItem
if|if
condition|(
name|item
operator|!=
name|originalItem
operator|&&
name|originalItem
operator|->
name|isAncestorOf
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|()
operator|<<
literal|"  found a gesture to cancel"
operator|<<
name|iter
operator|.
name|key
argument_list|()
expr_stmt|;
name|iter
operator|.
name|key
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|=
name|Qt
operator|::
name|GestureCanceled
expr_stmt|;
name|canceledGestures
operator|<<
name|iter
operator|.
name|key
argument_list|()
expr_stmt|;
block|}
operator|++
name|iter
expr_stmt|;
block|}
comment|// sort them per target item by cherry picking from almostCanceledGestures and delivering
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|almostCanceledGestures
init|=
name|canceledGestures
decl_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
operator|::
name|Iterator
name|setIter
decl_stmt|;
while|while
condition|(
operator|!
name|almostCanceledGestures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsObject
modifier|*
name|target
init|=
literal|0
decl_stmt|;
name|QSet
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|gestures
decl_stmt|;
name|setIter
operator|=
name|almostCanceledGestures
operator|.
name|begin
argument_list|()
expr_stmt|;
comment|// sort per target item
while|while
condition|(
name|setIter
operator|!=
name|almostCanceledGestures
operator|.
name|end
argument_list|()
condition|)
block|{
name|QGraphicsObject
modifier|*
name|item
init|=
name|gestureTargets
operator|.
name|value
argument_list|(
operator|*
name|setIter
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|item
condition|)
block|{
name|gestures
operator|<<
operator|*
name|setIter
expr_stmt|;
name|setIter
operator|=
name|almostCanceledGestures
operator|.
name|erase
argument_list|(
name|setIter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|setIter
expr_stmt|;
block|}
block|}
name|Q_ASSERT
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|list
init|=
name|gestures
operator|.
name|toList
argument_list|()
decl_stmt|;
name|QGestureEvent
name|ev
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|list
control|)
block|{
if|if
condition|(
name|ev
operator|.
name|isAccepted
argument_list|()
operator|||
name|ev
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
name|gestures
operator|.
name|remove
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
name|QGesture
modifier|*
name|g
decl|,
name|gestures
control|)
block|{
if|if
condition|(
operator|!
name|g
operator|->
name|hasHotSpot
argument_list|()
condition|)
continue|continue;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|items
init|=
name|itemsAtPosition
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|g
operator|->
name|d_func
argument_list|()
operator|->
name|sceneHotSpot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|items
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|QGraphicsObject
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|->
name|toGraphicsObject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|item
operator|->
name|QGraphicsItem
operator|::
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|gestureContext
operator|.
name|contains
argument_list|(
name|g
operator|->
name|gestureType
argument_list|()
argument_list|)
condition|)
block|{
name|QList
argument_list|<
name|QGesture
modifier|*
argument_list|>
name|list
decl_stmt|;
name|list
operator|<<
name|g
expr_stmt|;
name|QGestureEvent
name|ev
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|sendEvent
argument_list|(
name|item
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|isAccepted
argument_list|()
operator|||
name|ev
operator|.
name|isAccepted
argument_list|(
name|g
argument_list|)
condition|)
break|break;
comment|// successfully delivered
block|}
block|}
block|}
block|}
name|QGestureManager
modifier|*
name|gestureManager
init|=
name|QApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|gestureManager
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|gestureManager
argument_list|)
expr_stmt|;
comment|// it would be very odd if we got called without a manager.
for|for
control|(
name|setIter
operator|=
name|canceledGestures
operator|.
name|begin
argument_list|()
init|;
name|setIter
operator|!=
name|canceledGestures
operator|.
name|end
argument_list|()
condition|;
operator|++
name|setIter
control|)
block|{
name|gestureManager
operator|->
name|recycle
argument_list|(
operator|*
name|setIter
argument_list|)
expr_stmt|;
name|gestureTargets
operator|.
name|remove
argument_list|(
operator|*
name|setIter
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|grabGesture
name|void
name|QGraphicsScenePrivate
operator|::
name|grabGesture
parameter_list|(
name|QGraphicsItem
modifier|*
parameter_list|,
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|)
block|{
operator|(
name|void
operator|)
name|QGestureManager
operator|::
name|instance
argument_list|()
expr_stmt|;
comment|// create a gesture manager
if|if
condition|(
operator|!
name|grabbedGestures
index|[
name|gesture
index|]
operator|++
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|grabGesture
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ungrabGesture
name|void
name|QGraphicsScenePrivate
operator|::
name|ungrabGesture
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|)
block|{
comment|// we know this can only be an object
name|Q_ASSERT
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|isObject
argument_list|)
expr_stmt|;
name|QGraphicsObject
modifier|*
name|obj
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|QGestureManager
operator|::
name|instance
argument_list|()
operator|->
name|cleanupCachedGestures
argument_list|(
name|obj
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|grabbedGestures
index|[
name|gesture
index|]
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|views
control|)
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|ungrabGesture
argument_list|(
name|gesture
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qgraphicsscene.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GRAPHICSVIEW
end_comment
end_unit
