begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qglobal.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|"qgraphicswidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicslayout.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicslayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACTION
end_ifndef
begin_include
include|#
directive|include
file|<private/qaction_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicsscene_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_include
include|#
directive|include
file|<private/qshortcutmap_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicsview.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicsproxywidget.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpalette.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QGraphicsWidget     \brief The QGraphicsWidget class is the base class for all widget     items in a QGraphicsScene.     \since 4.4     \ingroup graphicsview-api     \inmodule QtWidgets      QGraphicsWidget is an extended base item that provides extra functionality     over QGraphicsItem. It is similar to QWidget in many ways:      \list         \li Provides a \l palette, a \l font and a \l style().         \li Has a defined geometry().         \li Supports layouts with setLayout() and layout().         \li Supports shortcuts and actions with grabShortcut() and insertAction()     \endlist      Unlike QGraphicsItem, QGraphicsWidget is not an abstract class; you can     create instances of a QGraphicsWidget without having to subclass it.     This approach is useful for widgets that only serve the purpose of     organizing child widgets into a layout.      QGraphicsWidget can be used as a base item for your own custom item if     you require advanced input focus handling, e.g., tab focus and activation, or     layouts.      Since QGraphicsWidget resembles QWidget and has similar API, it is     easier to port a widget from QWidget to QGraphicsWidget, instead of     QGraphicsItem.      \note QWidget-based widgets can be directly embedded into a     QGraphicsScene using QGraphicsProxyWidget.      Noticeable differences between QGraphicsWidget and QWidget are:      \table     \header \li QGraphicsWidget                 \li QWidget     \row      \li Coordinates and geometry are defined with qreals (doubles or                     floats, depending on the platform).                 \li QWidget uses integer geometry (QPoint, QRect).     \row      \li The widget is already visible by default; you do not have to                     call show() to display the widget.                 \li QWidget is hidden by default until you call show().     \row      \li A subset of widget attributes are supported.                 \li All widget attributes are supported.     \row      \li A top-level item's style defaults to QGraphicsScene::style                 \li A top-level widget's style defaults to QApplication::style     \row      \li Graphics View provides a custom drag and drop framework, different                     from QWidget.                 \li Standard drag and drop framework.     \row      \li Widget items do not support modality.                 \li Full modality support.     \endtable      QGraphicsWidget supports a subset of Qt's widget attributes,     (Qt::WidgetAttribute), as shown in the table below. Any attributes not     listed in this table are unsupported, or otherwise unused.      \table     \header \li Widget Attribute                         \li Usage     \row    \li Qt::WA_SetLayoutDirection                     \li Set by setLayoutDirection(), cleared by                         unsetLayoutDirection(). You can test this attribute to                         check if the widget has been explicitly assigned a                         \l{QGraphicsWidget::layoutDirection()}                         {layoutDirection}. If the attribute is not set, the                         \l{QGraphicsWidget::layoutDirection()}                         {layoutDirection()} is inherited.     \row    \li Qt::WA_RightToLeft                     \li Toggled by setLayoutDirection(). Inherited from the                         parent/scene. If set, the widget's layout will order                         horizontally arranged widgets from right to left.     \row    \li Qt::WA_SetStyle                     \li Set and cleared by setStyle(). If this attribute is                         set, the widget has been explicitly assigned a style.                         If it is unset, the widget will use the scene's or the                         application's style.     \row    \li Qt::WA_Resized                     \li Set by setGeometry() and resize().     \row    \li Qt::WA_SetPalette                     \li Set by setPalette().     \row    \li Qt::WA_SetFont                     \li Set by setFont().     \row    \li Qt::WA_WindowPropagation                     \li Enables propagation to window widgets.     \endtable      Although QGraphicsWidget inherits from both QObject and QGraphicsItem,     you should use the functions provided by QGraphicsItem, \e not QObject, to     manage the relationships between parent and child items. These functions     control the stacking order of items as well as their ownership.      \note The QObject::parent() should always return 0 for QGraphicsWidgets,     but this policy is not strictly defined.      \sa QGraphicsProxyWidget, QGraphicsItem, {Widgets and Layouts} */
end_comment
begin_comment
comment|/*!     Constructs a QGraphicsWidget instance. The optional \a parent argument is     passed to QGraphicsItem's constructor. The optional \a wFlags argument     specifies the widget's window flags (e.g., whether the widget should be a     window, a tool, a popup, etc). */
end_comment
begin_constructor
DECL|function|QGraphicsWidget
name|QGraphicsWidget
operator|::
name|QGraphicsWidget
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|wFlags
parameter_list|)
member_init_list|:
name|QGraphicsObject
argument_list|(
operator|*
operator|new
name|QGraphicsWidgetPrivate
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|QGraphicsLayoutItem
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|parent
argument_list|,
name|wFlags
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal      Constructs a new QGraphicsWidget, using \a dd as parent. */
end_comment
begin_constructor
DECL|function|QGraphicsWidget
name|QGraphicsWidget
operator|::
name|QGraphicsWidget
parameter_list|(
name|QGraphicsWidgetPrivate
modifier|&
name|dd
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
parameter_list|,
name|Qt
operator|::
name|WindowFlags
name|wFlags
parameter_list|)
member_init_list|:
name|QGraphicsObject
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|QGraphicsLayoutItem
argument_list|(
literal|0
argument_list|,
literal|false
argument_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|parent
argument_list|,
name|wFlags
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*     \internal     \class QGraphicsWidgetStyles      We use this thread-safe class to maintain a hash of styles for widgets     styles. Note that QApplication::style() itself isn't thread-safe, QStyle     isn't thread-safe, and we don't have a thread-safe factory for creating     the default style, nor cloning a style. */
end_comment
begin_class
DECL|class|QGraphicsWidgetStyles
class|class
name|QGraphicsWidgetStyles
block|{
public|public:
DECL|function|styleForWidget
name|QStyle
modifier|*
name|styleForWidget
parameter_list|(
specifier|const
name|QGraphicsWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
return|return
name|styles
operator|.
name|value
argument_list|(
name|widget
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|setStyleForWidget
name|void
name|setStyleForWidget
parameter_list|(
name|QGraphicsWidget
modifier|*
name|widget
parameter_list|,
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
condition|)
name|styles
index|[
name|widget
index|]
operator|=
name|style
expr_stmt|;
else|else
name|styles
operator|.
name|remove
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|member|styles
name|QHash
argument_list|<
specifier|const
name|QGraphicsWidget
modifier|*
argument_list|,
name|QStyle
modifier|*
argument_list|>
name|styles
decl_stmt|;
DECL|member|mutex
specifier|mutable
name|QMutex
name|mutex
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGraphicsWidgetStyles
argument_list|,
argument|widgetStyles
argument_list|)
end_macro
begin_comment
comment|/*!     Destroys the QGraphicsWidget instance. */
end_comment
begin_destructor
DECL|function|~QGraphicsWidget
name|QGraphicsWidget
operator|::
name|~
name|QGraphicsWidget
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACTION
comment|// Remove all actions from this widget
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|actions
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QActionPrivate
modifier|*
name|apriv
init|=
name|d
operator|->
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|graphicsWidgets
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|actions
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scn
init|=
name|scene
argument_list|()
condition|)
block|{
name|QGraphicsScenePrivate
modifier|*
name|sceneD
init|=
name|scn
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|sceneD
operator|->
name|tabFocusFirst
operator|==
name|this
condition|)
name|sceneD
operator|->
name|tabFocusFirst
operator|=
operator|(
name|d
operator|->
name|focusNext
operator|==
name|this
condition|?
literal|0
else|:
name|d
operator|->
name|focusNext
operator|)
expr_stmt|;
block|}
name|d
operator|->
name|focusPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|d
operator|->
name|focusNext
expr_stmt|;
name|d
operator|->
name|focusNext
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|d
operator|->
name|focusPrev
expr_stmt|;
comment|// Play it really safe
name|d
operator|->
name|focusNext
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|focusPrev
operator|=
name|this
expr_stmt|;
name|clearFocus
argument_list|()
expr_stmt|;
comment|//we check if we have a layout previously
if|if
condition|(
name|d
operator|->
name|layout
condition|)
block|{
name|QGraphicsLayout
modifier|*
name|temp
init|=
name|d
operator|->
name|layout
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|childItems
argument_list|()
control|)
block|{
comment|// In case of a custom layout which doesn't remove and delete items, we ensure that
comment|// the parent layout item does not point to the deleted layout. This code is here to
comment|// avoid regression from 4.4 to 4.5, because according to 4.5 docs it is not really needed.
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|parentLayoutItem
argument_list|()
operator|==
name|d
operator|->
name|layout
condition|)
name|widget
operator|->
name|setParentLayoutItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|layout
operator|=
literal|0
expr_stmt|;
operator|delete
name|temp
expr_stmt|;
block|}
comment|// Remove this graphics widget from widgetStyles
name|widgetStyles
argument_list|()
operator|->
name|setStyleForWidget
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \property QGraphicsWidget::size     \brief the size of the widget      Calling resize() resizes the widget to a \a size bounded by minimumSize()     and maximumSize(). This property only affects the widget's width and     height (e.g., its right and bottom edges); the widget's position and     top-left corner remains unaffected.      Resizing a widget triggers the widget to immediately receive a     \l{QEvent::GraphicsSceneResize}{GraphicsSceneResize} event with the     widget's old and new size.  If the widget has a layout assigned when this     event arrives, the layout will be activated and it will automatically     update any child widgets's geometry.      This property does not affect any layout of the parent widget. If the     widget itself is managed by a parent layout; e.g., it has a parent widget     with a layout assigned, that layout will not activate.      By default, this property contains a size with zero width and height.      \sa setGeometry(), QGraphicsSceneResizeEvent, QGraphicsLayout */
end_comment
begin_function
DECL|function|size
name|QSizeF
name|QGraphicsWidget
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|QGraphicsLayoutItem
operator|::
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|resize
name|void
name|QGraphicsWidget
operator|::
name|resize
parameter_list|(
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|setGeometry
argument_list|(
name|QRectF
argument_list|(
name|pos
argument_list|()
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsWidget::resize(qreal w, qreal h)      This convenience function is equivalent to calling resize(QSizeF(w, h)).      \sa setGeometry(), setTransform() */
end_comment
begin_comment
comment|/*!     \property QGraphicsWidget::sizePolicy     \brief the size policy for the widget     \sa sizePolicy(), setSizePolicy(), QWidget::sizePolicy() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsWidget::geometryChanged()    This signal gets emitted whenever the geometry is changed in setGeometry(). */
end_comment
begin_comment
comment|/*!     \property QGraphicsWidget::geometry     \brief the geometry of the widget      Sets the item's geometry to \a rect. The item's position and size are     modified as a result of calling this function. The item is first moved,     then resized.      A side effect of calling this function is that the widget will receive     a move event and a resize event. Also, if the widget has a layout     assigned, the layout will activate.      \sa geometry(), resize() */
end_comment
begin_function
DECL|function|setGeometry
name|void
name|QGraphicsWidget
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|QGraphicsWidgetPrivate
modifier|*
name|wd
init|=
name|QGraphicsWidget
operator|::
name|d_func
argument_list|()
decl_stmt|;
name|QGraphicsLayoutItemPrivate
modifier|*
name|d
init|=
name|QGraphicsLayoutItem
operator|::
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|QRectF
name|newGeom
decl_stmt|;
name|QPointF
name|oldPos
init|=
name|d
operator|->
name|geom
operator|.
name|topLeft
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wd
operator|->
name|inSetPos
condition|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
expr_stmt|;
name|newGeom
operator|=
name|rect
expr_stmt|;
name|newGeom
operator|.
name|setSize
argument_list|(
name|rect
operator|.
name|size
argument_list|()
operator|.
name|expandedTo
argument_list|(
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MinimumSize
argument_list|)
argument_list|)
operator|.
name|boundedTo
argument_list|(
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|MaximumSize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newGeom
operator|==
name|d
operator|->
name|geom
condition|)
block|{
goto|goto
name|relayoutChildrenAndReturn
goto|;
block|}
comment|// setPos triggers ItemPositionChange, which can adjust position
name|wd
operator|->
name|inSetGeometry
operator|=
literal|1
expr_stmt|;
name|setPos
argument_list|(
name|newGeom
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|wd
operator|->
name|inSetGeometry
operator|=
literal|0
expr_stmt|;
name|newGeom
operator|.
name|moveTopLeft
argument_list|(
name|pos
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newGeom
operator|==
name|d
operator|->
name|geom
condition|)
block|{
goto|goto
name|relayoutChildrenAndReturn
goto|;
block|}
comment|// Update and prepare to change the geometry (remove from index) if the size has changed.
if|if
condition|(
name|wd
operator|->
name|scene
condition|)
block|{
if|if
condition|(
name|rect
operator|.
name|topLeft
argument_list|()
operator|==
name|d
operator|->
name|geom
operator|.
name|topLeft
argument_list|()
condition|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Update the layout item geometry
block|{
name|bool
name|moved
init|=
name|oldPos
operator|!=
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
name|moved
condition|)
block|{
comment|// Send move event.
name|QGraphicsSceneMoveEvent
name|event
decl_stmt|;
name|event
operator|.
name|setOldPos
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
name|event
operator|.
name|setNewPos
argument_list|(
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|wd
operator|->
name|inSetPos
condition|)
block|{
comment|//set the new pos
name|d
operator|->
name|geom
operator|.
name|moveTopLeft
argument_list|(
name|pos
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|geometryChanged
argument_list|()
emit|;
goto|goto
name|relayoutChildrenAndReturn
goto|;
block|}
block|}
name|QSizeF
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
name|QGraphicsLayoutItem
operator|::
name|setGeometry
argument_list|(
name|newGeom
argument_list|)
expr_stmt|;
comment|// Send resize event
name|bool
name|resized
init|=
name|newGeom
operator|.
name|size
argument_list|()
operator|!=
name|oldSize
decl_stmt|;
if|if
condition|(
name|resized
condition|)
block|{
name|QGraphicsSceneResizeEvent
name|re
decl_stmt|;
name|re
operator|.
name|setOldSize
argument_list|(
name|oldSize
argument_list|)
expr_stmt|;
name|re
operator|.
name|setNewSize
argument_list|(
name|newGeom
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldSize
operator|.
name|width
argument_list|()
operator|!=
name|newGeom
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
condition|)
emit|emit
name|widthChanged
argument_list|()
emit|;
if|if
condition|(
name|oldSize
operator|.
name|height
argument_list|()
operator|!=
name|newGeom
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
condition|)
emit|emit
name|heightChanged
argument_list|()
emit|;
name|QGraphicsLayout
modifier|*
name|lay
init|=
name|wd
operator|->
name|layout
decl_stmt|;
if|if
condition|(
name|QGraphicsLayout
operator|::
name|instantInvalidatePropagation
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|lay
operator|||
name|lay
operator|->
name|isActivated
argument_list|()
condition|)
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|re
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|re
argument_list|)
expr_stmt|;
block|}
block|}
block|}
emit|emit
name|geometryChanged
argument_list|()
emit|;
name|relayoutChildrenAndReturn
label|:
if|if
condition|(
name|QGraphicsLayout
operator|::
name|instantInvalidatePropagation
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsLayout
modifier|*
name|lay
init|=
name|wd
operator|->
name|layout
condition|)
block|{
if|if
condition|(
operator|!
name|lay
operator|->
name|isActivated
argument_list|()
condition|)
block|{
name|QEvent
name|layoutRequest
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|layoutRequest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsWidget::rect() const      Returns the item's local rect as a QRectF. This function is equivalent     to QRectF(QPointF(), size()).      \sa setGeometry(), resize() */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsWidget::setGeometry(qreal x, qreal y, qreal w, qreal h)      This convenience function is equivalent to calling setGeometry(QRectF(     \a x, \a y, \a w, \a h)).      \sa geometry(), resize() */
end_comment
begin_comment
comment|/*!     \property QGraphicsWidget::minimumSize     \brief the minimum size of the widget      \sa setMinimumSize(), minimumSize(), preferredSize, maximumSize */
end_comment
begin_comment
comment|/*!     \property QGraphicsWidget::preferredSize     \brief the preferred size of the widget      \sa setPreferredSize(), preferredSize(), minimumSize, maximumSize */
end_comment
begin_comment
comment|/*!     \property QGraphicsWidget::maximumSize     \brief the maximum size of the widget      \sa setMaximumSize(), maximumSize(), minimumSize, preferredSize */
end_comment
begin_comment
comment|/*!     Sets the widget's contents margins to \a left, \a top, \a right and \a     bottom.      Contents margins are used by the assigned layout to define the placement     of subwidgets and layouts. Margins are particularly useful for widgets     that constrain subwidgets to only a section of its own geometry. For     example, a group box with a layout will place subwidgets inside its frame,     but below the title.      Changing a widget's contents margins will always trigger an update(), and     any assigned layout will be activated automatically. The widget will then     receive a \l{QEvent::ContentsRectChange}{ContentsRectChange} event.      \sa getContentsMargins(), setGeometry() */
end_comment
begin_function
DECL|function|setContentsMargins
name|void
name|QGraphicsWidget
operator|::
name|setContentsMargins
parameter_list|(
name|qreal
name|left
parameter_list|,
name|qreal
name|top
parameter_list|,
name|qreal
name|right
parameter_list|,
name|qreal
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|margins
operator|&&
name|left
operator|==
literal|0
operator|&&
name|top
operator|==
literal|0
operator|&&
name|right
operator|==
literal|0
operator|&&
name|bottom
operator|==
literal|0
condition|)
return|return;
name|d
operator|->
name|ensureMargins
argument_list|()
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Left
index|]
operator|&&
name|top
operator|==
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Top
index|]
operator|&&
name|right
operator|==
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Right
index|]
operator|&&
name|bottom
operator|==
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Bottom
index|]
condition|)
return|return;
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Left
index|]
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Top
index|]
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Right
index|]
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Bottom
index|]
operator|=
name|bottom
expr_stmt|;
if|if
condition|(
name|QGraphicsLayout
modifier|*
name|l
init|=
name|d
operator|->
name|layout
condition|)
name|l
operator|->
name|invalidate
argument_list|()
expr_stmt|;
else|else
name|updateGeometry
argument_list|()
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ContentsRectChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Gets the widget's contents margins. The margins are stored in \a left, \a     top, \a right and \a bottom, as pointers to qreals. Each argument can     be \e {omitted} by passing 0.      \sa setContentsMargins() */
end_comment
begin_function
DECL|function|getContentsMargins
name|void
name|QGraphicsWidget
operator|::
name|getContentsMargins
parameter_list|(
name|qreal
modifier|*
name|left
parameter_list|,
name|qreal
modifier|*
name|top
parameter_list|,
name|qreal
modifier|*
name|right
parameter_list|,
name|qreal
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|||
name|top
operator|||
name|right
operator|||
name|bottom
condition|)
name|d
operator|->
name|ensureMargins
argument_list|()
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Left
index|]
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Top
index|]
expr_stmt|;
if|if
condition|(
name|right
condition|)
operator|*
name|right
operator|=
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Right
index|]
expr_stmt|;
if|if
condition|(
name|bottom
condition|)
operator|*
name|bottom
operator|=
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Bottom
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the widget's window frame margins to \a left, \a top, \a right and     \a bottom. The default frame margins are provided by the style, and they     depend on the current window flags.      If you would like to draw your own window decoration, you can set your     own frame margins to override the default margins.      \sa unsetWindowFrameMargins(), getWindowFrameMargins(), windowFrameRect() */
end_comment
begin_function
DECL|function|setWindowFrameMargins
name|void
name|QGraphicsWidget
operator|::
name|setWindowFrameMargins
parameter_list|(
name|qreal
name|left
parameter_list|,
name|qreal
name|top
parameter_list|,
name|qreal
name|right
parameter_list|,
name|qreal
name|bottom
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|windowFrameMargins
operator|&&
name|left
operator|==
literal|0
operator|&&
name|top
operator|==
literal|0
operator|&&
name|right
operator|==
literal|0
operator|&&
name|bottom
operator|==
literal|0
condition|)
return|return;
name|d
operator|->
name|ensureWindowFrameMargins
argument_list|()
expr_stmt|;
name|bool
name|unchanged
init|=
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
operator|==
name|left
operator|&&
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
operator|==
name|top
operator|&&
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Right
index|]
operator|==
name|right
operator|&&
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Bottom
index|]
operator|==
name|bottom
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|setWindowFrameMargins
operator|&&
name|unchanged
condition|)
return|return;
if|if
condition|(
operator|!
name|unchanged
condition|)
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
operator|=
name|left
expr_stmt|;
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
operator|=
name|top
expr_stmt|;
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Right
index|]
operator|=
name|right
expr_stmt|;
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Bottom
index|]
operator|=
name|bottom
expr_stmt|;
name|d
operator|->
name|setWindowFrameMargins
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Gets the widget's window frame margins. The margins are stored in \a left,     \a top, \a right and \a bottom as pointers to qreals. Each argument can     be \e {omitted} by passing 0.      \sa setWindowFrameMargins(), windowFrameRect() */
end_comment
begin_function
DECL|function|getWindowFrameMargins
name|void
name|QGraphicsWidget
operator|::
name|getWindowFrameMargins
parameter_list|(
name|qreal
modifier|*
name|left
parameter_list|,
name|qreal
modifier|*
name|top
parameter_list|,
name|qreal
modifier|*
name|right
parameter_list|,
name|qreal
modifier|*
name|bottom
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|||
name|top
operator|||
name|right
operator|||
name|bottom
condition|)
name|d
operator|->
name|ensureWindowFrameMargins
argument_list|()
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
expr_stmt|;
if|if
condition|(
name|right
condition|)
operator|*
name|right
operator|=
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Right
index|]
expr_stmt|;
if|if
condition|(
name|bottom
condition|)
operator|*
name|bottom
operator|=
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Bottom
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resets the window frame margins to the default value, provided by the style.      \sa setWindowFrameMargins(), getWindowFrameMargins(), windowFrameRect() */
end_comment
begin_function
DECL|function|unsetWindowFrameMargins
name|void
name|QGraphicsWidget
operator|::
name|unsetWindowFrameMargins
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|Window
operator|)
operator|&&
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|!=
name|Qt
operator|::
name|Popup
operator|&&
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|!=
name|Qt
operator|::
name|ToolTip
operator|&&
operator|!
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|FramelessWindowHint
operator|)
condition|)
block|{
name|QStyleOptionTitleBar
name|bar
decl_stmt|;
name|d
operator|->
name|initStyleOptionTitleBar
argument_list|(
operator|&
name|bar
argument_list|)
expr_stmt|;
name|QStyle
modifier|*
name|style
init|=
name|this
operator|->
name|style
argument_list|()
decl_stmt|;
name|qreal
name|margin
init|=
name|style
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_MdiSubWindowFrameWidth
argument_list|)
decl_stmt|;
name|qreal
name|titleBarHeight
init|=
name|d
operator|->
name|titleBarHeight
argument_list|(
name|bar
argument_list|)
decl_stmt|;
name|setWindowFrameMargins
argument_list|(
name|margin
argument_list|,
name|titleBarHeight
argument_list|,
name|margin
argument_list|,
name|margin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setWindowFrameMargins
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setWindowFrameMargins
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget's geometry in parent coordinates including any window     frame.      \sa windowFrameRect(), getWindowFrameMargins(), setWindowFrameMargins() */
end_comment
begin_function
DECL|function|windowFrameGeometry
name|QRectF
name|QGraphicsWidget
operator|::
name|windowFrameGeometry
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowFrameMargins
condition|?
name|geometry
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
argument_list|,
operator|-
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
argument_list|,
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Right
index|]
argument_list|,
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Bottom
index|]
argument_list|)
else|:
name|geometry
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the widget's local rect including any window frame.      \sa windowFrameGeometry(), getWindowFrameMargins(), setWindowFrameMargins() */
end_comment
begin_function
DECL|function|windowFrameRect
name|QRectF
name|QGraphicsWidget
operator|::
name|windowFrameRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowFrameMargins
condition|?
name|rect
argument_list|()
operator|.
name|adjusted
argument_list|(
operator|-
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
argument_list|,
operator|-
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
argument_list|,
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Right
index|]
argument_list|,
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Bottom
index|]
argument_list|)
else|:
name|rect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Populates a style option object for this widget based on its current     state, and stores the output in \a option. The default implementation     populates \a option with the following properties.      \table       \header         \li Style Option Property         \li Value       \row         \li state& QStyle::State_Enabled         \li Corresponds to QGraphicsItem::isEnabled().       \row         \li state& QStyle::State_HasFocus         \li Corresponds to QGraphicsItem::hasFocus().       \row         \li state& QStyle::State_MouseOver         \li Corresponds to QGraphicsItem::isUnderMouse().       \row         \li direction         \li Corresponds to QGraphicsWidget::layoutDirection().       \row         \li rect         \li Corresponds to QGraphicsWidget::rect().toRect().       \row         \li palette         \li Corresponds to QGraphicsWidget::palette().       \row         \li fontMetrics         \li Corresponds to QFontMetrics(QGraphicsWidget::font()).     \endtable      Subclasses of QGraphicsWidget should call the base implementation, and     then test the type of \a option using qstyleoption_cast<>() or test     QStyleOption::Type before storing widget-specific options.      For example:      \snippet code/src_gui_graphicsview_qgraphicswidget.cpp 0      \sa QStyleOption::initFrom() */
end_comment
begin_function
DECL|function|initStyleOption
name|void
name|QGraphicsWidget
operator|::
name|initStyleOption
parameter_list|(
name|QStyleOption
modifier|*
name|option
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|option
operator|->
name|state
operator|=
name|QStyle
operator|::
name|State_None
expr_stmt|;
if|if
condition|(
name|isEnabled
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Enabled
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
comment|// if (window->testAttribute(Qt::WA_KeyboardFocusChange)) // ### Window
comment|//     option->state |= QStyle::State_KeyboardFocusChange;
if|if
condition|(
name|isUnderMouse
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
if|if
condition|(
name|QGraphicsWidget
modifier|*
name|w
init|=
name|window
argument_list|()
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|isActiveWindow
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Active
expr_stmt|;
block|}
if|if
condition|(
name|isWindow
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Window
expr_stmt|;
comment|/*       ### #ifdef Q_WS_MAC     extern bool qt_mac_can_clickThrough(const QGraphicsWidget *w); //qwidget_mac.cpp     if (!(option->state& QStyle::State_Active)&& !qt_mac_can_clickThrough(widget))         option->state&= ~QStyle::State_Enabled;      switch (QMacStyle::widgetSizePolicy(widget)) {     case QMacStyle::SizeSmall:         option->state |= QStyle::State_Small;         break;     case QMacStyle::SizeMini:         option->state |= QStyle::State_Mini;         break;     default:         ;     } #endif #ifdef QT_KEYPAD_NAVIGATION     if (widget->hasEditFocus())         state |= QStyle::State_HasEditFocus; #endif     */
name|option
operator|->
name|direction
operator|=
name|layoutDirection
argument_list|()
expr_stmt|;
name|option
operator|->
name|rect
operator|=
name|rect
argument_list|()
operator|.
name|toRect
argument_list|()
expr_stmt|;
comment|// ### truncation!
name|option
operator|->
name|palette
operator|=
name|palette
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isEnabled
argument_list|()
condition|)
block|{
name|option
operator|->
name|palette
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Disabled
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isActiveWindow
argument_list|()
condition|)
block|{
name|option
operator|->
name|palette
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Active
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|option
operator|->
name|palette
operator|.
name|setCurrentColorGroup
argument_list|(
name|QPalette
operator|::
name|Inactive
argument_list|)
expr_stmt|;
block|}
name|option
operator|->
name|fontMetrics
operator|=
name|QFontMetrics
argument_list|(
name|font
argument_list|()
argument_list|)
expr_stmt|;
name|option
operator|->
name|styleObject
operator|=
cast|const_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sizeHint
name|QSizeF
name|QGraphicsWidget
operator|::
name|sizeHint
parameter_list|(
name|Qt
operator|::
name|SizeHint
name|which
parameter_list|,
specifier|const
name|QSizeF
modifier|&
name|constraint
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|QSizeF
name|sh
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
block|{
name|QSizeF
name|marginSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|margins
condition|)
block|{
name|marginSize
operator|=
name|QSizeF
argument_list|(
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Left
index|]
operator|+
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Right
index|]
argument_list|,
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Top
index|]
operator|+
name|d
operator|->
name|margins
index|[
name|d
operator|->
name|Bottom
index|]
argument_list|)
expr_stmt|;
block|}
name|sh
operator|=
name|d
operator|->
name|layout
operator|->
name|effectiveSizeHint
argument_list|(
name|which
argument_list|,
name|constraint
operator|-
name|marginSize
argument_list|)
expr_stmt|;
name|sh
operator|+=
name|marginSize
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|Qt
operator|::
name|MinimumSize
case|:
name|sh
operator|=
name|QSizeF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|PreferredSize
case|:
name|sh
operator|=
name|QSizeF
argument_list|(
literal|50
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|//rather arbitrary
break|break;
case|case
name|Qt
operator|::
name|MaximumSize
case|:
name|sh
operator|=
name|QSizeF
argument_list|(
name|QWIDGETSIZE_MAX
argument_list|,
name|QWIDGETSIZE_MAX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QGraphicsWidget::sizeHint(): Don't know how to handle the value of 'which'"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|sh
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::layout     \brief The layout of the widget      Any existing layout manager is deleted before the new layout is assigned. If      \a layout is 0, the widget is left without a layout. Existing subwidgets'     geometries will remain unaffected.      QGraphicsWidget takes ownership of \a layout.      All widgets that are currently managed by \a layout or all of its     sublayouts, are automatically reparented to this item. The layout is then     invalidated, and the child widget geometries are adjusted according to     this item's geometry() and contentsMargins(). Children who are not     explicitly managed by \a layout remain unaffected by the layout after     it has been assigned to this widget.      If no layout is currently managing this widget, layout() will return 0.  */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsWidget::layoutChanged()     This signal gets emitted whenever the layout of the item changes     \internal */
end_comment
begin_comment
comment|/*!     Returns this widget's layout, or 0 if no layout is currently managing this     widget.      \sa setLayout() */
end_comment
begin_function
DECL|function|layout
name|QGraphicsLayout
modifier|*
name|QGraphicsWidget
operator|::
name|layout
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layout
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsWidget::setLayout(QGraphicsLayout *layout)      Sets the layout for this widget to \a layout. Any existing layout manager     is deleted before the new layout is assigned. If \a layout is 0, the     widget is left without a layout. Existing subwidgets' geometries will     remain unaffected.      All widgets that are currently managed by \a layout or all of its     sublayouts, are automatically reparented to this item. The layout is then     invalidated, and the child widget geometries are adjusted according to     this item's geometry() and contentsMargins(). Children who are not     explicitly managed by \a layout remain unaffected by the layout after     it has been assigned to this widget.      QGraphicsWidget takes ownership of \a layout.      \sa layout(), QGraphicsLinearLayout::addItem(), QGraphicsLayout::invalidate() */
end_comment
begin_function
DECL|function|setLayout
name|void
name|QGraphicsWidget
operator|::
name|setLayout
parameter_list|(
name|QGraphicsLayout
modifier|*
name|l
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
operator|==
name|l
condition|)
return|return;
name|d
operator|->
name|setLayout_helper
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return;
comment|// Prevent assigning a layout that is already assigned to another widget.
name|QGraphicsLayoutItem
modifier|*
name|oldParent
init|=
name|l
operator|->
name|parentLayoutItem
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldParent
operator|&&
name|oldParent
operator|!=
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsWidget::setLayout: Attempting to set a layout on %s"
literal|" \"%s\", when the layout already has a parent"
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|qPrintable
argument_list|(
name|objectName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Install and activate the layout.
name|l
operator|->
name|setParentLayoutItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|l
operator|->
name|d_func
argument_list|()
operator|->
name|reparentChildItems
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|l
operator|->
name|invalidate
argument_list|()
expr_stmt|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Adjusts the size of the widget to its effective preferred size hint.      This function is called implicitly when the item is shown for the first     time.      \sa effectiveSizeHint(), Qt::MinimumSize */
end_comment
begin_function
DECL|function|adjustSize
name|void
name|QGraphicsWidget
operator|::
name|adjustSize
parameter_list|()
block|{
name|QSizeF
name|sz
init|=
name|effectiveSizeHint
argument_list|(
name|Qt
operator|::
name|PreferredSize
argument_list|)
decl_stmt|;
comment|// What if sz is not valid?!
if|if
condition|(
name|sz
operator|.
name|isValid
argument_list|()
condition|)
name|resize
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::layoutDirection     \brief the layout direction for this widget.      This property modifies this widget's and all of its descendants'     Qt::WA_RightToLeft attribute. It also sets this widget's     Qt::WA_SetLayoutDirection attribute.      The widget's layout direction determines the order in which the layout     manager horizontally arranges subwidgets of this widget. The default     value depends on the language and locale of the application, and is     typically in the same direction as words are read and written. With     Qt::LeftToRight, the layout starts placing subwidgets from the left     side of this widget towards the right. Qt::RightToLeft does the opposite -     the layout will place widgets starting from the right edge moving towards     the left.      Subwidgets inherit their layout direction from the parent. Top-level     widget items inherit their layout direction from     QGraphicsScene::layoutDirection. If you change a widget's layout direction     by calling setLayoutDirection(), the widget will send itself a     \l{QEvent::LayoutDirectionChange}{LayoutDirectionChange} event, and then     propagate the new layout direction to all its descendants.      \sa QWidget::layoutDirection, QApplication::layoutDirection */
end_comment
begin_function
DECL|function|layoutDirection
name|Qt
operator|::
name|LayoutDirection
name|QGraphicsWidget
operator|::
name|layoutDirection
parameter_list|()
specifier|const
block|{
return|return
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_RightToLeft
argument_list|)
condition|?
name|Qt
operator|::
name|RightToLeft
else|:
name|Qt
operator|::
name|LeftToRight
return|;
block|}
end_function
begin_function
DECL|function|setLayoutDirection
name|void
name|QGraphicsWidget
operator|::
name|setLayoutDirection
parameter_list|(
name|Qt
operator|::
name|LayoutDirection
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLayoutDirection_helper
argument_list|(
name|direction
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unsetLayoutDirection
name|void
name|QGraphicsWidget
operator|::
name|unsetLayoutDirection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetLayoutDirection
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|resolveLayoutDirection
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the widget's style. If this widget does not have any     explicitly assigned style, the scene's style is returned instead. In turn,     if the scene does not have any assigned style, this function returns     QApplication::style().      \sa setStyle() */
end_comment
begin_function
DECL|function|style
name|QStyle
modifier|*
name|QGraphicsWidget
operator|::
name|style
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QStyle
modifier|*
name|style
init|=
name|widgetStyles
argument_list|()
operator|->
name|styleForWidget
argument_list|(
name|this
argument_list|)
condition|)
return|return
name|style
return|;
comment|// ### This is not thread-safe. QApplication::style() is not thread-safe.
return|return
name|scene
argument_list|()
condition|?
name|scene
argument_list|()
operator|->
name|style
argument_list|()
else|:
name|QApplication
operator|::
name|style
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the widget's style to \a style. QGraphicsWidget does \e not take     ownership of \a style.      If no style is assigned, or \a style is 0, the widget will use     QGraphicsScene::style() (if this has been set). Otherwise the widget will     use QApplication::style().      This function sets the Qt::WA_SetStyle attribute if \a style is not 0;     otherwise it clears the attribute.      \sa style() */
end_comment
begin_function
DECL|function|setStyle
name|void
name|QGraphicsWidget
operator|::
name|setStyle
parameter_list|(
name|QStyle
modifier|*
name|style
parameter_list|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetStyle
argument_list|,
name|style
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|widgetStyles
argument_list|()
operator|->
name|setStyleForWidget
argument_list|(
name|this
argument_list|,
name|style
argument_list|)
expr_stmt|;
comment|// Deliver StyleChange to the widget itself (doesn't propagate).
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|StyleChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::font     \brief the widgets' font      This property provides the widget's font.      QFont consists of font properties that have been explicitly defined and     properties implicitly inherited from the widget's parent. Hence, font()     can return a different font compared to the one set with setFont().     This scheme allows you to define single entries in a font without     affecting the font's inherited entries.      When a widget's font changes, it resolves its entries against its     parent widget. If the widget does not have a parent widget, it resolves     its entries against the scene. The widget then sends itself a     \l{QEvent::FontChange}{FontChange} event and notifies all its     descendants so that they can resolve their fonts as well.      By default, this property contains the application's default font.      \sa QApplication::font(), QGraphicsScene::font, QFont::resolve() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGraphicsWidget
operator|::
name|font
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|QFont
name|fnt
init|=
name|d
operator|->
name|font
decl_stmt|;
name|fnt
operator|.
name|resolve
argument_list|(
name|fnt
operator|.
name|resolve
argument_list|()
operator||
name|d
operator|->
name|inheritedFontResolveMask
argument_list|)
expr_stmt|;
return|return
name|fnt
return|;
block|}
end_function
begin_function
DECL|function|setFont
name|void
name|QGraphicsWidget
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetFont
argument_list|,
name|font
operator|.
name|resolve
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QFont
name|naturalFont
init|=
name|d
operator|->
name|naturalWidgetFont
argument_list|()
decl_stmt|;
name|QFont
name|resolvedFont
init|=
name|font
operator|.
name|resolve
argument_list|(
name|naturalFont
argument_list|)
decl_stmt|;
name|d
operator|->
name|setFont_helper
argument_list|(
name|resolvedFont
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::palette     \brief the widget's palette      This property provides the widget's palette. The palette provides colors     and brushes for color groups (e.g., QPalette::Button) and states (e.g.,     QPalette::Inactive), loosely defining the general look of the widget and     its children.      QPalette consists of color groups that have been explicitly defined, and     groups that are implicitly inherited from the widget's parent. Because of     this, palette() can return a different palette than what has been set with     setPalette(). This scheme allows you to define single entries in a palette     without affecting the palette's inherited entries.      When a widget's palette changes, it resolves its entries against its     parent widget, or if it doesn't have a parent widget, it resolves against     the scene. It then sends itself a \l{QEvent::PaletteChange}{PaletteChange}     event, and notifies all its descendants so they can resolve their palettes     as well.      By default, this property contains the application's default palette.      \sa QApplication::palette(), QGraphicsScene::palette, QPalette::resolve() */
end_comment
begin_function
DECL|function|palette
name|QPalette
name|QGraphicsWidget
operator|::
name|palette
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|palette
return|;
block|}
end_function
begin_function
DECL|function|setPalette
name|void
name|QGraphicsWidget
operator|::
name|setPalette
parameter_list|(
specifier|const
name|QPalette
modifier|&
name|palette
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_SetPalette
argument_list|,
name|palette
operator|.
name|resolve
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QPalette
name|naturalPalette
init|=
name|d
operator|->
name|naturalWidgetPalette
argument_list|()
decl_stmt|;
name|QPalette
name|resolvedPalette
init|=
name|palette
operator|.
name|resolve
argument_list|(
name|naturalPalette
argument_list|)
decl_stmt|;
name|d
operator|->
name|setPalette_helper
argument_list|(
name|resolvedPalette
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::autoFillBackground     \brief whether the widget background is filled automatically     \since 4.7      If enabled, this property will cause Qt to fill the background of the     widget before invoking the paint() method. The color used is defined by the     QPalette::Window color role from the widget's \l{QPalette}{palette}.      In addition, Windows are always filled with QPalette::Window, unless the     WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.      By default, this property is \c false.      \sa Qt::WA_OpaquePaintEvent, Qt::WA_NoSystemBackground, */
end_comment
begin_function
DECL|function|autoFillBackground
name|bool
name|QGraphicsWidget
operator|::
name|autoFillBackground
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoFillBackground
return|;
block|}
end_function
begin_function
DECL|function|setAutoFillBackground
name|void
name|QGraphicsWidget
operator|::
name|setAutoFillBackground
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoFillBackground
operator|!=
name|enabled
condition|)
block|{
name|d
operator|->
name|autoFillBackground
operator|=
name|enabled
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     If this widget is currently managed by a layout, this function notifies     the layout that the widget's size hints have changed and the layout     may need to resize and reposition the widget accordingly.      Call this function if the widget's sizeHint() has changed.      \sa QGraphicsLayout::invalidate() */
end_comment
begin_function
DECL|function|updateGeometry
name|void
name|QGraphicsWidget
operator|::
name|updateGeometry
parameter_list|()
block|{
name|QGraphicsLayoutItem
operator|::
name|updateGeometry
argument_list|()
expr_stmt|;
name|QGraphicsLayoutItem
modifier|*
name|parentItem
init|=
name|parentLayoutItem
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentItem
operator|&&
name|parentItem
operator|->
name|isLayout
argument_list|()
condition|)
block|{
if|if
condition|(
name|QGraphicsLayout
operator|::
name|instantInvalidatePropagation
argument_list|()
condition|)
block|{
cast|static_cast
argument_list|<
name|QGraphicsLayout
operator|*
argument_list|>
argument_list|(
name|parentItem
argument_list|)
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|parentItem
operator|->
name|updateGeometry
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentItem
condition|)
block|{
comment|// This is for custom layouting
name|QGraphicsWidget
modifier|*
name|parentWid
init|=
name|parentWidget
argument_list|()
decl_stmt|;
comment|//###
if|if
condition|(
name|parentWid
operator|->
name|isVisible
argument_list|()
condition|)
name|QApplication
operator|::
name|postEvent
argument_list|(
name|parentWid
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/**              * If this is the topmost widget, post a LayoutRequest event to the widget.              * When the event is received, it will start flowing all the way down to the leaf              * widgets in one go. This will make a relayout flicker-free.              */
if|if
condition|(
name|QGraphicsLayout
operator|::
name|instantInvalidatePropagation
argument_list|()
condition|)
name|QApplication
operator|::
name|postEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LayoutRequest
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QGraphicsLayout
operator|::
name|instantInvalidatePropagation
argument_list|()
condition|)
block|{
name|bool
name|wasResized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
name|resize
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// this will restrict the size
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
name|wasResized
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp      QGraphicsWidget uses the base implementation of this function to catch and     deliver events related to state changes in the item. Because of this, it is     very important that subclasses call the base implementation.      \a change specifies the type of change, and \a value is the new value.      For example, QGraphicsWidget uses ItemVisibleChange to deliver     \l{QEvent::Show} {Show} and \l{QEvent::Hide}{Hide} events,     ItemPositionHasChanged to deliver \l{QEvent::Move}{Move} events,     and ItemParentChange both to deliver \l{QEvent::ParentChange}     {ParentChange} events, and for managing the focus chain.      QGraphicsWidget enables the ItemSendsGeometryChanges flag by default in     order to track position changes.      \sa QGraphicsItem::itemChange() */
end_comment
begin_function
DECL|function|itemChange
name|QVariant
name|QGraphicsWidget
operator|::
name|itemChange
parameter_list|(
name|GraphicsItemChange
name|change
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|ItemEnabledHasChanged
case|:
block|{
comment|// Send EnabledChange after the enabled state has changed.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|EnabledChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ItemVisibleChange
case|:
if|if
condition|(
name|value
operator|.
name|toBool
argument_list|()
condition|)
block|{
comment|// Send Show event before the item has been shown.
name|QShowEvent
name|event
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|bool
name|resized
init|=
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resized
condition|)
block|{
name|adjustSize
argument_list|()
expr_stmt|;
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Resized
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ItemVisibleHasChanged
case|:
if|if
condition|(
operator|!
name|value
operator|.
name|toBool
argument_list|()
condition|)
block|{
comment|// Send Hide event after the item has been hidden.
name|QHideEvent
name|event
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ItemPositionHasChanged
case|:
name|d
operator|->
name|setGeometryFromSetPos
argument_list|()
expr_stmt|;
break|break;
case|case
name|ItemParentChange
case|:
block|{
comment|// Deliver ParentAboutToChange.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|ParentAboutToChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ItemParentHasChanged
case|:
block|{
comment|// Deliver ParentChange.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|ParentChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ItemCursorHasChanged
case|:
block|{
comment|// Deliver CursorChange.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|CursorChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ItemToolTipHasChanged
case|:
block|{
comment|// Deliver ToolTipChange.
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|ToolTipChange
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
return|return
name|QGraphicsItem
operator|::
name|itemChange
argument_list|(
name|change
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      This virtual function is used to notify changes to any property (both     dynamic properties, and registered with Q_PROPERTY) in the     widget. Depending on the property itself, the notification can be     delivered before or after the value has changed.      \a propertyName is the name of the property (e.g., "size" or "font"), and     \a value is the (proposed) new value of the property. The function returns     the new value, which may be different from \a value if the notification     supports adjusting the property value. The base implementation simply     returns \a value for any \a propertyName.      QGraphicsWidget delivers notifications for the following properties:      \table     \header    \li propertyName        \li Property     \row       \li layoutDirection     \li QGraphicsWidget::layoutDirection     \row       \li size                \li QGraphicsWidget::size     \row       \li font                \li QGraphicsWidget::font     \row       \li palette             \li QGraphicsWidget::palette     \endtable      \sa itemChange() */
end_comment
begin_function
DECL|function|propertyChange
name|QVariant
name|QGraphicsWidget
operator|::
name|propertyChange
parameter_list|(
specifier|const
name|QString
modifier|&
name|propertyName
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     QGraphicsWidget's implementation of sceneEvent() simply passes \a event to     QGraphicsWidget::event(). You can handle all events for your widget in     event() or in any of the convenience functions; you should not have to     reimplement this function in a subclass of QGraphicsWidget.      \sa QGraphicsItem::sceneEvent() */
end_comment
begin_function
DECL|function|sceneEvent
name|bool
name|QGraphicsWidget
operator|::
name|sceneEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|QGraphicsItem
operator|::
name|sceneEvent
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, receives events for the window frame if     this widget is a window. Its base implementation provides support for     default window frame interaction such as moving, resizing, etc.      You can reimplement this handler in a subclass of QGraphicsWidget to     provide your own custom window frame interaction support.      Returns \c true if \a event has been recognized and processed; otherwise,     returns \c false.      \sa event() */
end_comment
begin_function
DECL|function|windowFrameEvent
name|bool
name|QGraphicsWidget
operator|::
name|windowFrameEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
name|d
operator|->
name|windowFrameMousePressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
name|d
operator|->
name|ensureWindowData
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|windowData
operator|->
name|grabbedSection
operator|!=
name|Qt
operator|::
name|NoSection
condition|)
block|{
name|d
operator|->
name|windowFrameMouseMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
name|d
operator|->
name|windowFrameMouseReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
name|d
operator|->
name|windowFrameHoverMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
name|d
operator|->
name|windowFrameHoverLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|event
operator|->
name|isAccepted
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the window frame section at position \a pos, or     Qt::NoSection if there is no window frame section at this     position.      This function is used in QGraphicsWidget's base implementation for window     frame interaction.      You can reimplement this function if you want to customize how a window     can be interactively moved or resized.  For instance, if you only want to     allow a window to be resized by the bottom right corner, you can     reimplement this function to return Qt::NoSection for all sections except     Qt::BottomRightSection.      \sa windowFrameEvent(), paintWindowFrame(), windowFrameGeometry() */
end_comment
begin_function
DECL|function|windowFrameSectionAt
name|Qt
operator|::
name|WindowFrameSection
name|QGraphicsWidget
operator|::
name|windowFrameSectionAt
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
specifier|const
name|QRectF
name|r
init|=
name|windowFrameRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
return|return
name|Qt
operator|::
name|NoSection
return|;
specifier|const
name|qreal
name|left
init|=
name|r
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|top
init|=
name|r
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|right
init|=
name|r
operator|.
name|right
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|bottom
init|=
name|r
operator|.
name|bottom
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|x
init|=
name|pos
operator|.
name|x
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|y
init|=
name|pos
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|cornerMargin
init|=
literal|20
decl_stmt|;
comment|//### Not sure of this one, it should be the same value for all edges.
specifier|const
name|qreal
name|windowFrameWidth
init|=
name|d
operator|->
name|windowFrameMargins
condition|?
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Left
index|]
else|:
literal|0
decl_stmt|;
name|Qt
operator|::
name|WindowFrameSection
name|s
init|=
name|Qt
operator|::
name|NoSection
decl_stmt|;
if|if
condition|(
name|x
operator|<=
name|left
operator|+
name|cornerMargin
condition|)
block|{
if|if
condition|(
name|y
operator|<=
name|top
operator|+
name|windowFrameWidth
operator|||
operator|(
name|x
operator|<=
name|left
operator|+
name|windowFrameWidth
operator|&&
name|y
operator|<=
name|top
operator|+
name|cornerMargin
operator|)
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|TopLeftSection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>=
name|bottom
operator|-
name|windowFrameWidth
operator|||
operator|(
name|x
operator|<=
name|left
operator|+
name|windowFrameWidth
operator|&&
name|y
operator|>=
name|bottom
operator|-
name|windowFrameWidth
operator|)
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|BottomLeftSection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
name|left
operator|+
name|windowFrameWidth
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|LeftSection
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
name|right
operator|-
name|cornerMargin
condition|)
block|{
if|if
condition|(
name|y
operator|<=
name|top
operator|+
name|windowFrameWidth
operator|||
operator|(
name|x
operator|>=
name|right
operator|-
name|windowFrameWidth
operator|&&
name|y
operator|<=
name|top
operator|+
name|cornerMargin
operator|)
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|TopRightSection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>=
name|bottom
operator|-
name|windowFrameWidth
operator|||
operator|(
name|x
operator|>=
name|right
operator|-
name|windowFrameWidth
operator|&&
name|y
operator|>=
name|bottom
operator|-
name|windowFrameWidth
operator|)
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|BottomRightSection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
name|right
operator|-
name|windowFrameWidth
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|RightSection
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|y
operator|<=
name|top
operator|+
name|windowFrameWidth
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|TopSection
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>=
name|bottom
operator|-
name|windowFrameWidth
condition|)
block|{
name|s
operator|=
name|Qt
operator|::
name|BottomSection
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|Qt
operator|::
name|NoSection
condition|)
block|{
name|QRectF
name|r1
init|=
name|r
decl_stmt|;
name|r1
operator|.
name|setHeight
argument_list|(
name|d
operator|->
name|windowFrameMargins
condition|?
name|d
operator|->
name|windowFrameMargins
index|[
name|d
operator|->
name|Top
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
name|s
operator|=
name|Qt
operator|::
name|TitleBarArea
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Handles the \a event.  QGraphicsWidget handles the following     events:      \table     \header  \li Event                 \li Usage     \row     \li Polish                     \li Delivered to the widget some time after it has been                         shown.     \row     \li GraphicsSceneMove                     \li Delivered to the widget after its local position has                         changed.     \row     \li GraphicsSceneResize                     \li Delivered to the widget after its size has changed.     \row     \li Show                     \li Delivered to the widget before it has been shown.     \row     \li Hide                     \li Delivered to the widget after it has been hidden.     \row     \li PaletteChange                     \li Delivered to the widget after its palette has changed.     \row     \li FontChange                     \li Delivered to the widget after its font has changed.     \row     \li EnabledChange                     \li Delivered to the widget after its enabled state has                         changed.     \row     \li StyleChange                     \li Delivered to the widget after its style has changed.     \row     \li LayoutDirectionChange                     \li Delivered to the widget after its layout direction has                         changed.     \row     \li ContentsRectChange                     \li Delivered to the widget after its contents margins/                         contents rect has changed.     \endtable */
end_comment
begin_function
DECL|function|event
name|bool
name|QGraphicsWidget
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
comment|// Forward the event to the layout first.
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|widgetEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// Handle the event itself.
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|GraphicsSceneMove
case|:
name|moveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMoveEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneResize
case|:
name|resizeEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneResizeEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Show
case|:
name|showEvent
argument_list|(
cast|static_cast
argument_list|<
name|QShowEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Hide
case|:
name|hideEvent
argument_list|(
cast|static_cast
argument_list|<
name|QHideEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Polish
case|:
name|polishEvent
argument_list|()
expr_stmt|;
name|d
operator|->
name|polished
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|font
operator|.
name|isCopyOf
argument_list|(
name|QApplication
operator|::
name|font
argument_list|()
argument_list|)
condition|)
name|d
operator|->
name|updateFont
argument_list|(
name|d
operator|->
name|font
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|StyleAnimationUpdate
case|:
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
break|break;
comment|// Taken from QWidget::event
case|case
name|QEvent
operator|::
name|ActivationChange
case|:
case|case
name|QEvent
operator|::
name|EnabledChange
case|:
case|case
name|QEvent
operator|::
name|FontChange
case|:
case|case
name|QEvent
operator|::
name|StyleChange
case|:
case|case
name|QEvent
operator|::
name|PaletteChange
case|:
case|case
name|QEvent
operator|::
name|ParentChange
case|:
case|case
name|QEvent
operator|::
name|ContentsRectChange
case|:
case|case
name|QEvent
operator|::
name|LayoutDirectionChange
case|:
name|changeEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|Close
case|:
name|closeEvent
argument_list|(
operator|(
name|QCloseEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GrabMouse
case|:
name|grabMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|UngrabMouse
case|:
name|ungrabMouseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GrabKeyboard
case|:
name|grabKeyboardEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|UngrabKeyboard
case|:
name|ungrabKeyboardEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
if|if
condition|(
name|d
operator|->
name|hasDecoration
argument_list|()
operator|&&
name|windowFrameEvent
argument_list|(
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
name|d
operator|->
name|ensureWindowData
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hasDecoration
argument_list|()
operator|&&
name|d
operator|->
name|windowData
operator|->
name|grabbedSection
operator|!=
name|Qt
operator|::
name|NoSection
condition|)
return|return
name|windowFrameEvent
argument_list|(
name|event
argument_list|)
return|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
if|if
condition|(
name|d
operator|->
name|hasDecoration
argument_list|()
condition|)
block|{
name|windowFrameEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// Filter out hover events if they were sent to us only because of the
comment|// decoration (special case in QGraphicsScenePrivate::dispatchHoverEvent).
if|if
condition|(
operator|!
name|acceptHoverEvents
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    This event handler can be reimplemented to handle state changes.     The state being changed in this event can be retrieved through \a event.     Change events include: QEvent::ActivationChange, QEvent::EnabledChange,    QEvent::FontChange, QEvent::StyleChange, QEvent::PaletteChange,    QEvent::ParentChange, QEvent::LayoutDirectionChange, and    QEvent::ContentsRectChange. */
end_comment
begin_function
DECL|function|changeEvent
name|void
name|QGraphicsWidget
operator|::
name|changeEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|StyleChange
case|:
comment|// ### Don't unset if the margins are explicitly set.
name|unsetWindowFrameMargins
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|layout
condition|)
name|d
operator|->
name|layout
operator|->
name|invalidate
argument_list|()
expr_stmt|;
case|case
name|QEvent
operator|::
name|FontChange
case|:
name|update
argument_list|()
expr_stmt|;
name|updateGeometry
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|PaletteChange
case|:
name|update
argument_list|()
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ParentChange
case|:
name|d
operator|->
name|resolveFont
argument_list|(
name|d
operator|->
name|inheritedFontResolveMask
argument_list|)
expr_stmt|;
name|d
operator|->
name|resolvePalette
argument_list|(
name|d
operator|->
name|inheritedPaletteResolveMask
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, can be reimplemented in a subclass to     receive widget close events.  The default implementation accepts the     event.      \sa close(), QCloseEvent */
end_comment
begin_function
DECL|function|closeEvent
name|void
name|QGraphicsWidget
operator|::
name|closeEvent
parameter_list|(
name|QCloseEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QGraphicsWidget
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Finds a new widget to give the keyboard focus to, as appropriate for Tab     and Shift+Tab, and returns \c true if it can find a new widget; returns \c false     otherwise. If \a next is true, this function searches forward; if \a next     is false, it searches backward.      Sometimes, you will want to reimplement this function to provide special     focus handling for your widget and its subwidgets. For example, a web     browser might reimplement it to move its current active link forward or     backward, and call the base implementation only when it reaches the last     or first link on the page.      Child widgets call focusNextPrevChild() on their parent widgets, but only     the window that contains the child widgets decides where to redirect     focus. By reimplementing this function for an object, you gain control of     focus traversal for all child widgets.      \sa focusPolicy() */
end_comment
begin_function
DECL|function|focusNextPrevChild
name|bool
name|QGraphicsWidget
operator|::
name|focusNextPrevChild
parameter_list|(
name|bool
name|next
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
comment|// Let the parent's focusNextPrevChild implementation decide what to do.
name|QGraphicsWidget
modifier|*
name|parent
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isWindow
argument_list|()
operator|&&
operator|(
name|parent
operator|=
name|parentWidget
argument_list|()
operator|)
condition|)
return|return
name|parent
operator|->
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|scene
operator|->
name|focusNextPrevChild
argument_list|(
name|next
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|isWindow
argument_list|()
condition|)
block|{
name|setFocus
argument_list|(
name|next
condition|?
name|Qt
operator|::
name|TabFocusReason
else|:
name|Qt
operator|::
name|BacktabFocusReason
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QGraphicsWidget
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|focusPolicy
argument_list|()
operator|!=
name|Qt
operator|::
name|NoFocus
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \l{QEvent::Hide}{Hide} events, is delivered after     the widget has been hidden, for example, setVisible(false) has been called     for the widget or one of its ancestors when the widget was previously     shown.      You can reimplement this event handler to detect when your widget is     hidden. Calling QEvent::accept() or QEvent::ignore() on \a event has no     effect.      \sa showEvent(), QWidget::hideEvent(), ItemVisibleChange */
end_comment
begin_function
DECL|function|hideEvent
name|void
name|QGraphicsWidget
operator|::
name|hideEvent
parameter_list|(
name|QHideEvent
modifier|*
name|event
parameter_list|)
block|{
comment|///### focusNextPrevChild(true), don't lose focus when the focus widget
comment|// is hidden.
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \l{QEvent::GraphicsSceneMove}{GraphicsSceneMove}     events, is delivered after the widget has moved (e.g., its local position     has changed).      This event is only delivered when the item is moved locally. Calling     setTransform() or moving any of the item's ancestors does not affect the     item's local position.      You can reimplement this event handler to detect when your widget has     moved. Calling QEvent::accept() or QEvent::ignore() on \a event has no     effect.      \sa ItemPositionChange, ItemPositionHasChanged */
end_comment
begin_function
DECL|function|moveEvent
name|void
name|QGraphicsWidget
operator|::
name|moveEvent
parameter_list|(
name|QGraphicsSceneMoveEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// ### Last position is always == current position
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event is delivered to the item by the scene at some point after it     has been constructed, but before it is shown or otherwise accessed through     the scene. You can use this event handler to do last-minute initializations     of the widget which require the item to be fully constructed.      The base implementation does nothing. */
end_comment
begin_function
DECL|function|polishEvent
name|void
name|QGraphicsWidget
operator|::
name|polishEvent
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     This event handler, for     \l{QEvent::GraphicsSceneResize}{GraphicsSceneResize} events, is     delivered after the widget has been resized (i.e., its local size has     changed). \a event contains both the old and the new size.      This event is only delivered when the widget is resized locally; calling     setTransform() on the widget or any of its ancestors or view, does not     affect the widget's local size.      You can reimplement this event handler to detect when your widget has been     resized. Calling QEvent::accept() or QEvent::ignore() on \a event has no     effect.      \sa geometry(), setGeometry() */
end_comment
begin_function
DECL|function|resizeEvent
name|void
name|QGraphicsWidget
operator|::
name|resizeEvent
parameter_list|(
name|QGraphicsSceneResizeEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \l{QEvent::Show}{Show} events, is delivered before     the widget has been shown, for example, setVisible(true) has been called     for the widget or one of its ancestors when the widget was previously     hidden.      You can reimplement this event handler to detect when your widget is     shown. Calling QEvent::accept() or QEvent::ignore() on \a event has no     effect.      \sa hideEvent(), QWidget::showEvent(), ItemVisibleChange */
end_comment
begin_function
DECL|function|showEvent
name|void
name|QGraphicsWidget
operator|::
name|showEvent
parameter_list|(
name|QShowEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hoverMoveEvent
name|void
name|QGraphicsWidget
operator|::
name|hoverMoveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hoverLeaveEvent
name|void
name|QGraphicsWidget
operator|::
name|hoverLeaveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|QGraphicsObject
operator|::
name|hoverLeaveEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, can be reimplemented in a subclass to     receive notifications for QEvent::GrabMouse events.      \sa grabMouse(), grabKeyboard() */
end_comment
begin_function
DECL|function|grabMouseEvent
name|void
name|QGraphicsWidget
operator|::
name|grabMouseEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, can be reimplemented in a subclass to     receive notifications for QEvent::UngrabMouse events.      \sa ungrabMouse(), ungrabKeyboard() */
end_comment
begin_function
DECL|function|ungrabMouseEvent
name|void
name|QGraphicsWidget
operator|::
name|ungrabMouseEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, can be reimplemented in a subclass to     receive notifications for QEvent::GrabKeyboard events.      \sa grabKeyboard(), grabMouse() */
end_comment
begin_function
DECL|function|grabKeyboardEvent
name|void
name|QGraphicsWidget
operator|::
name|grabKeyboardEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for \a event, can be reimplemented in a subclass to     receive notifications for QEvent::UngrabKeyboard events.      \sa ungrabKeyboard(), ungrabMouse() */
end_comment
begin_function
DECL|function|ungrabKeyboardEvent
name|void
name|QGraphicsWidget
operator|::
name|ungrabKeyboardEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the widgets window type.      \sa windowFlags(), isWindow(), isPanel() */
end_comment
begin_function
DECL|function|windowType
name|Qt
operator|::
name|WindowType
name|QGraphicsWidget
operator|::
name|windowType
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|WindowType
argument_list|(
name|int
argument_list|(
name|windowFlags
argument_list|()
argument_list|)
operator|&
name|Qt
operator|::
name|WindowType_Mask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::windowFlags     \brief the widget's window flags      Window flags are a combination of a window type (e.g., Qt::Dialog) and     several flags giving hints on the behavior of the window. The behavior     is platform-dependent.      By default, this property contains no window flags.      Windows are panels. If you set the Qt::Window flag, the ItemIsPanel flag     will be set automatically. If you clear the Qt::Window flag, the     ItemIsPanel flag is also cleared. Note that the ItemIsPanel flag can be     set independently of Qt::Window.      \sa isWindow(), isPanel() */
end_comment
begin_function
DECL|function|windowFlags
name|Qt
operator|::
name|WindowFlags
name|QGraphicsWidget
operator|::
name|windowFlags
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowFlags
return|;
block|}
end_function
begin_function
DECL|function|setWindowFlags
name|void
name|QGraphicsWidget
operator|::
name|setWindowFlags
parameter_list|(
name|Qt
operator|::
name|WindowFlags
name|wFlags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|windowFlags
operator|==
name|wFlags
condition|)
return|return;
name|bool
name|wasPopup
init|=
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|==
name|Qt
operator|::
name|Popup
decl_stmt|;
name|d
operator|->
name|adjustWindowFlags
argument_list|(
operator|&
name|wFlags
argument_list|)
expr_stmt|;
name|d
operator|->
name|windowFlags
operator|=
name|wFlags
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|setWindowFrameMargins
condition|)
name|unsetWindowFrameMargins
argument_list|()
expr_stmt|;
name|setFlag
argument_list|(
name|ItemIsPanel
argument_list|,
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|Window
argument_list|)
expr_stmt|;
name|bool
name|isPopup
init|=
operator|(
name|d
operator|->
name|windowFlags
operator|&
name|Qt
operator|::
name|WindowType_Mask
operator|)
operator|==
name|Qt
operator|::
name|Popup
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|isVisible
argument_list|()
operator|&&
name|wasPopup
operator|!=
name|isPopup
condition|)
block|{
comment|// Popup state changed; update implicit mouse grab.
if|if
condition|(
operator|!
name|isPopup
condition|)
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removePopup
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|addPopup
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|scene
operator|&&
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|&&
name|d
operator|->
name|hasDecoration
argument_list|()
condition|)
block|{
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enableMouseTrackingOnViews
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this widget's window is in the active window, or if the     widget does not have a window but is in an active scene (i.e., a scene     that currently has focus).      The active window is the window that either contains a child widget that     currently has input focus, or that itself has input focus.      \sa QGraphicsScene::activeWindow(), QGraphicsScene::setActiveWindow(), isActive() */
end_comment
begin_function
DECL|function|isActiveWindow
name|bool
name|QGraphicsWidget
operator|::
name|isActiveWindow
parameter_list|()
specifier|const
block|{
return|return
name|isActive
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::windowTitle     \brief This property holds the window title (caption).      This property is only used for windows.      By default, if no title has been set, this property contains an     empty string. */
end_comment
begin_function
DECL|function|setWindowTitle
name|void
name|QGraphicsWidget
operator|::
name|setWindowTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|ensureWindowData
argument_list|()
expr_stmt|;
name|d
operator|->
name|windowData
operator|->
name|windowTitle
operator|=
name|title
expr_stmt|;
block|}
end_function
begin_function
DECL|function|windowTitle
name|QString
name|QGraphicsWidget
operator|::
name|windowTitle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|windowData
condition|?
name|d
operator|->
name|windowData
operator|->
name|windowTitle
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsWidget::focusPolicy     \brief the way the widget accepts keyboard focus      The focus policy is Qt::TabFocus if the widget accepts keyboard focus by     tabbing, Qt::ClickFocus if the widget accepts focus by clicking,     Qt::StrongFocus if it accepts both, and Qt::NoFocus (the default) if it     does not accept focus at all.      You must enable keyboard focus for a widget if it processes keyboard     events. This is normally done from the widget's constructor. For instance,     the QLineEdit constructor calls setFocusPolicy(Qt::StrongFocus).      If you enable a focus policy (i.e., not Qt::NoFocus), QGraphicsWidget will     automatically enable the ItemIsFocusable flag.  Setting Qt::NoFocus on a     widget will clear the ItemIsFocusable flag. If the widget currently has     keyboard focus, the widget will automatically lose focus.      \sa focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), enabled */
end_comment
begin_function
DECL|function|focusPolicy
name|Qt
operator|::
name|FocusPolicy
name|QGraphicsWidget
operator|::
name|focusPolicy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|focusPolicy
return|;
block|}
end_function
begin_function
DECL|function|setFocusPolicy
name|void
name|QGraphicsWidget
operator|::
name|setFocusPolicy
parameter_list|(
name|Qt
operator|::
name|FocusPolicy
name|policy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|focusPolicy
operator|==
name|policy
condition|)
return|return;
name|d
operator|->
name|focusPolicy
operator|=
name|policy
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
operator|&&
name|policy
operator|==
name|Qt
operator|::
name|NoFocus
condition|)
name|clearFocus
argument_list|()
expr_stmt|;
name|setFlag
argument_list|(
name|ItemIsFocusable
argument_list|,
name|policy
operator|!=
name|Qt
operator|::
name|NoFocus
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If this widget, a child or descendant of this widget currently has input     focus, this function will return a pointer to that widget. If     no descendant widget has input focus, 0 is returned.      \sa QGraphicsItem::focusItem(), QWidget::focusWidget() */
end_comment
begin_function
DECL|function|focusWidget
name|QGraphicsWidget
modifier|*
name|QGraphicsWidget
operator|::
name|focusWidget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|subFocusItem
operator|&&
name|d
operator|->
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|isWidget
condition|)
return|return
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|subFocusItem
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
end_ifndef
begin_comment
comment|/*!     \since 4.5      Adds a shortcut to Qt's shortcut system that watches for the given key \a     sequence in the given \a context. If the \a context is     Qt::ApplicationShortcut, the shortcut applies to the application as a     whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut,     or to the window itself, Qt::WindowShortcut. For widgets that are not part     of a window (i.e., top-level widgets and their children),     Qt::WindowShortcut shortcuts apply to the scene.      If the same key \a sequence has been grabbed by several widgets,     when the key \a sequence occurs a QEvent::Shortcut event is sent     to all the widgets to which it applies in a non-deterministic     order, but with the ``ambiguous'' flag set to true.      \warning You should not normally need to use this function;     instead create \l{QAction}s with the shortcut key sequences you     require (if you also want equivalent menu options and toolbar     buttons), or create \l{QShortcut}s if you just need key sequences.     Both QAction and QShortcut handle all the event filtering for you,     and provide signals which are triggered when the user triggers the     key sequence, so are much easier to use than this low-level     function.      \sa releaseShortcut(), setShortcutEnabled(), QWidget::grabShortcut() */
end_comment
begin_function
DECL|function|grabShortcut
name|int
name|QGraphicsWidget
operator|::
name|grabShortcut
parameter_list|(
specifier|const
name|QKeySequence
modifier|&
name|sequence
parameter_list|,
name|Qt
operator|::
name|ShortcutContext
name|context
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequence
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// ### setAttribute(Qt::WA_GrabbedShortcut);
return|return
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|addShortcut
argument_list|(
name|this
argument_list|,
name|sequence
argument_list|,
name|context
argument_list|,
name|qWidgetShortcutContextMatcher
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Removes the shortcut with the given \a id from Qt's shortcut     system. The widget will no longer receive QEvent::Shortcut events     for the shortcut's key sequence (unless it has other shortcuts     with the same key sequence).      \warning You should not normally need to use this function since     Qt's shortcut system removes shortcuts automatically when their     parent widget is destroyed. It is best to use QAction or     QShortcut to handle shortcuts, since they are easier to use than     this low-level function. Note also that this is an expensive     operation.      \sa grabShortcut(), setShortcutEnabled(), QWidget::releaseShortcut() */
end_comment
begin_function
DECL|function|releaseShortcut
name|void
name|QGraphicsWidget
operator|::
name|releaseShortcut
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|removeShortcut
argument_list|(
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      If \a enabled is true, the shortcut with the given \a id is     enabled; otherwise the shortcut is disabled.      \warning You should not normally need to use this function since     Qt's shortcut system enables/disables shortcuts automatically as     widgets become hidden/visible and gain or lose focus. It is best     to use QAction or QShortcut to handle shortcuts, since they are     easier to use than this low-level function.      \sa grabShortcut(), releaseShortcut(), QWidget::setShortcutEnabled() */
end_comment
begin_function
DECL|function|setShortcutEnabled
name|void
name|QGraphicsWidget
operator|::
name|setShortcutEnabled
parameter_list|(
name|int
name|id
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|setShortcutEnabled
argument_list|(
name|enabled
argument_list|,
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      If \a enabled is true, auto repeat of the shortcut with the     given \a id is enabled; otherwise it is disabled.      \sa grabShortcut(), releaseShortcut(), QWidget::setShortcutAutoRepeat() */
end_comment
begin_function
DECL|function|setShortcutAutoRepeat
name|void
name|QGraphicsWidget
operator|::
name|setShortcutAutoRepeat
parameter_list|(
name|int
name|id
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qApp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|qApp
operator|->
name|d_func
argument_list|()
operator|->
name|shortcutMap
operator|.
name|setShortcutAutoRepeat
argument_list|(
name|enabled
argument_list|,
name|id
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACTION
end_ifndef
begin_comment
comment|/*!     \since 4.5      Appends the action \a action to this widget's list of actions.      All QGraphicsWidgets have a list of \l{QAction}s, however they can be     represented graphically in many different ways. The default use of the     QAction list (as returned by actions()) is to create a context QMenu.      A QGraphicsWidget should only have one of each action and adding an action     it already has will not cause the same action to be in the widget twice.      \sa removeAction(), insertAction(), actions(), QWidget::addAction() */
end_comment
begin_function
DECL|function|addAction
name|void
name|QGraphicsWidget
operator|::
name|addAction
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
block|{
name|insertAction
argument_list|(
literal|0
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Appends the actions \a actions to this widget's list of actions.      \sa removeAction(), QMenu, addAction(), QWidget::addActions() */
end_comment
begin_function
DECL|function|addActions
name|void
name|QGraphicsWidget
operator|::
name|addActions
parameter_list|(
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|actions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|actions
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|insertAction
argument_list|(
literal|0
argument_list|,
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Inserts the action \a action to this widget's list of actions,     before the action \a before. It appends the action if \a before is 0 or     \a before is not a valid action for this widget.      A QGraphicsWidget should only have one of each action.      \sa removeAction(), addAction(), QMenu, actions(),     QWidget::insertActions() */
end_comment
begin_function
DECL|function|insertAction
name|void
name|QGraphicsWidget
operator|::
name|insertAction
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|,
name|QAction
modifier|*
name|action
parameter_list|)
block|{
if|if
condition|(
operator|!
name|action
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWidget::insertAction: Attempt to insert null action"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|d
operator|->
name|actions
operator|.
name|indexOf
argument_list|(
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|actions
operator|.
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|d
operator|->
name|actions
operator|.
name|indexOf
argument_list|(
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|before
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|d
operator|->
name|actions
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|actions
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|QActionPrivate
modifier|*
name|apriv
init|=
name|action
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|graphicsWidgets
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|QActionEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ActionAdded
argument_list|,
name|action
argument_list|,
name|before
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Inserts the actions \a actions to this widget's list of actions,     before the action \a before. It appends the action if \a before is 0 or     \a before is not a valid action for this widget.      A QGraphicsWidget can have at most one of each action.      \sa removeAction(), QMenu, insertAction(), QWidget::insertActions() */
end_comment
begin_function
DECL|function|insertActions
name|void
name|QGraphicsWidget
operator|::
name|insertActions
parameter_list|(
name|QAction
modifier|*
name|before
parameter_list|,
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|actions
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|actions
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|insertAction
argument_list|(
name|before
argument_list|,
name|actions
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Removes the action \a action from this widget's list of actions.      \sa insertAction(), actions(), insertAction(), QWidget::removeAction() */
end_comment
begin_function
DECL|function|removeAction
name|void
name|QGraphicsWidget
operator|::
name|removeAction
parameter_list|(
name|QAction
modifier|*
name|action
parameter_list|)
block|{
if|if
condition|(
operator|!
name|action
condition|)
return|return;
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|QActionPrivate
modifier|*
name|apriv
init|=
name|action
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|apriv
operator|->
name|graphicsWidgets
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|actions
operator|.
name|removeAll
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|QActionEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ActionRemoved
argument_list|,
name|action
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the (possibly empty) list of this widget's actions.      \sa insertAction(), removeAction(), QWidget::actions(),     QAction::associatedWidgets(), QAction::associatedGraphicsWidgets() */
end_comment
begin_function
DECL|function|actions
name|QList
argument_list|<
name|QAction
modifier|*
argument_list|>
name|QGraphicsWidget
operator|::
name|actions
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|actions
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Moves the \a second widget around the ring of focus widgets so that     keyboard focus moves from the \a first widget to the \a second widget when     the Tab key is pressed.      Note that since the tab order of the \a second widget is changed, you     should order a chain like this:      \snippet code/src_gui_graphicsview_qgraphicswidget.cpp 1      \e not like this:      \snippet code/src_gui_graphicsview_qgraphicswidget.cpp 2      If \a first is 0, this indicates that \a second should be the first widget     to receive input focus should the scene gain Tab focus (i.e., the user     hits Tab so that focus passes into the scene). If \a second is 0, this     indicates that \a first should be the first widget to gain focus if the     scene gained BackTab focus.      By default, tab order is defined implicitly using widget creation order.      \sa focusPolicy, {Keyboard Focus in Widgets} */
end_comment
begin_function
DECL|function|setTabOrder
name|void
name|QGraphicsWidget
operator|::
name|setTabOrder
parameter_list|(
name|QGraphicsWidget
modifier|*
name|first
parameter_list|,
name|QGraphicsWidget
modifier|*
name|second
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first
operator|&&
operator|!
name|second
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsWidget::setTabOrder(0, 0) is undefined"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|first
operator|&&
name|second
operator|)
operator|&&
name|first
operator|->
name|scene
argument_list|()
operator|!=
name|second
operator|->
name|scene
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsWidget::setTabOrder: scenes %p and %p are different"
argument_list|,
name|first
operator|->
name|scene
argument_list|()
argument_list|,
name|second
operator|->
name|scene
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsScene
modifier|*
name|scene
init|=
name|first
condition|?
name|first
operator|->
name|scene
argument_list|()
else|:
name|second
operator|->
name|scene
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scene
operator|&&
operator|(
operator|!
name|first
operator|||
operator|!
name|second
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsWidget::setTabOrder: assigning tab order from/to the"
literal|" scene requires the item to be in a scene."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If either first or second are 0, the scene's tabFocusFirst is updated
comment|// to point to the first item in the scene's focus chain. Then first or
comment|// second are set to point to tabFocusFirst.
name|QGraphicsScenePrivate
modifier|*
name|sceneD
init|=
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sceneD
operator|->
name|tabFocusFirst
operator|=
name|second
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|second
condition|)
block|{
name|sceneD
operator|->
name|tabFocusFirst
operator|=
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
expr_stmt|;
return|return;
block|}
comment|// Both first and second are != 0.
name|QGraphicsWidget
modifier|*
name|firstFocusNext
init|=
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
decl_stmt|;
if|if
condition|(
name|firstFocusNext
operator|==
name|second
condition|)
block|{
comment|// Nothing to do.
return|return;
block|}
comment|// Update the focus chain.
name|QGraphicsWidget
modifier|*
name|secondFocusPrev
init|=
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
decl_stmt|;
name|QGraphicsWidget
modifier|*
name|secondFocusNext
init|=
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
decl_stmt|;
name|firstFocusNext
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|second
expr_stmt|;
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|second
expr_stmt|;
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|firstFocusNext
expr_stmt|;
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|first
expr_stmt|;
name|secondFocusPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|=
name|secondFocusNext
expr_stmt|;
name|secondFocusNext
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|=
name|secondFocusPrev
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|==
name|first
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|first
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|==
name|first
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|==
name|second
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|focusPrev
operator|->
name|d_func
argument_list|()
operator|->
name|focusNext
operator|==
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a on is true, this function enables \a attribute; otherwise     \a attribute is disabled.      See the class documentation for QGraphicsWidget for a complete list of     which attributes are supported, and what they are for.      \sa testAttribute(), QWidget::setAttribute() */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QGraphicsWidget
operator|::
name|setAttribute
parameter_list|(
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
comment|// ### most flags require some immediate action
comment|// ### we might want to qWarn use of unsupported attributes
comment|// ### we might want to not use Qt::WidgetAttribute, but roll our own instead
name|d
operator|->
name|setAttribute
argument_list|(
name|attribute
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if \a attribute is enabled for this widget; otherwise,     returns \c false.      \sa setAttribute() */
end_comment
begin_function
DECL|function|testAttribute
name|bool
name|QGraphicsWidget
operator|::
name|testAttribute
parameter_list|(
name|Qt
operator|::
name|WidgetAttribute
name|attribute
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsWidget
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|testAttribute
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsWidget
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsWidget
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|painter
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This virtual function is called by QGraphicsScene to draw the window frame     for windows using \a painter, \a option, and \a widget, in local     coordinates. The base implementation uses the current style to render the     frame and title bar.      You can reimplement this function in a subclass of QGraphicsWidget to     provide custom rendering of the widget's window frame.      \sa QGraphicsItem::paint() */
end_comment
begin_function
DECL|function|paintWindowFrame
name|void
name|QGraphicsWidget
operator|::
name|paintWindowFrame
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
specifier|const
name|bool
name|fillBackground
init|=
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_OpaquePaintEvent
argument_list|)
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_NoSystemBackground
argument_list|)
decl_stmt|;
name|QGraphicsProxyWidget
modifier|*
name|proxy
init|=
name|qobject_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|embeddedWidgetFillsOwnBackground
init|=
name|proxy
operator|&&
name|proxy
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|option
operator|->
name|exposedRect
argument_list|)
condition|)
block|{
if|if
condition|(
name|fillBackground
operator|&&
operator|!
name|embeddedWidgetFillsOwnBackground
condition|)
name|painter
operator|->
name|fillRect
argument_list|(
name|option
operator|->
name|exposedRect
argument_list|,
name|palette
argument_list|()
operator|.
name|window
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QGraphicsWidget
argument_list|)
expr_stmt|;
name|QRect
name|windowFrameRect
init|=
name|QRect
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|windowFrameGeometry
argument_list|()
operator|.
name|size
argument_list|()
operator|.
name|toSize
argument_list|()
argument_list|)
decl_stmt|;
name|QStyleOptionTitleBar
name|bar
decl_stmt|;
name|bar
operator|.
name|QStyleOption
operator|::
name|operator
name|=
argument_list|(
operator|*
name|option
argument_list|)
expr_stmt|;
name|d
operator|->
name|initStyleOptionTitleBar
argument_list|(
operator|&
name|bar
argument_list|)
expr_stmt|;
comment|// this clear flags in bar.state
name|d
operator|->
name|ensureWindowData
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|windowData
operator|->
name|buttonMouseOver
condition|)
name|bar
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
else|else
name|bar
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|windowData
operator|->
name|buttonSunken
condition|)
name|bar
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
else|else
name|bar
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
name|bar
operator|.
name|rect
operator|=
name|windowFrameRect
expr_stmt|;
comment|// translate painter to make the style happy
specifier|const
name|QPointF
name|styleOrigin
init|=
name|this
operator|->
name|windowFrameRect
argument_list|()
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|painter
operator|->
name|translate
argument_list|(
name|styleOrigin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
specifier|const
name|QSize
name|pixmapSize
init|=
name|windowFrameRect
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixmapSize
operator|.
name|width
argument_list|()
operator|<=
literal|0
operator|||
name|pixmapSize
operator|.
name|height
argument_list|()
operator|<=
literal|0
condition|)
return|return;
name|QPainter
modifier|*
name|realPainter
init|=
name|painter
decl_stmt|;
name|QPixmap
name|pm
argument_list|(
name|pixmapSize
argument_list|)
decl_stmt|;
name|painter
operator|=
operator|new
name|QPainter
argument_list|(
operator|&
name|pm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Fill background
name|QStyleHintReturnMask
name|mask
decl_stmt|;
name|bool
name|setMask
init|=
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_WindowFrame_Mask
argument_list|,
operator|&
name|bar
argument_list|,
name|widget
argument_list|,
operator|&
name|mask
argument_list|)
operator|&&
operator|!
name|mask
operator|.
name|region
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|bool
name|hasBorder
init|=
operator|!
name|style
argument_list|()
operator|->
name|styleHint
argument_list|(
name|QStyle
operator|::
name|SH_TitleBar_NoBorder
argument_list|,
operator|&
name|bar
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|int
name|frameWidth
init|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_MDIFrameWidth
argument_list|,
operator|&
name|bar
argument_list|,
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|setMask
condition|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setClipRegion
argument_list|(
name|mask
operator|.
name|region
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fillBackground
condition|)
block|{
if|if
condition|(
name|embeddedWidgetFillsOwnBackground
condition|)
block|{
comment|// Don't fill the background twice.
name|QPainterPath
name|windowFrameBackground
decl_stmt|;
name|windowFrameBackground
operator|.
name|addRect
argument_list|(
name|windowFrameRect
argument_list|)
expr_stmt|;
comment|// Adjust with 0.5 to avoid border artifacts between
comment|// widget background and frame background.
name|windowFrameBackground
operator|.
name|addRect
argument_list|(
name|rect
argument_list|()
operator|.
name|translated
argument_list|(
operator|-
name|styleOrigin
argument_list|)
operator|.
name|adjusted
argument_list|(
literal|0.5
argument_list|,
literal|0.5
argument_list|,
operator|-
literal|0.5
argument_list|,
operator|-
literal|0.5
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|fillPath
argument_list|(
name|windowFrameBackground
argument_list|,
name|palette
argument_list|()
operator|.
name|window
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|painter
operator|->
name|fillRect
argument_list|(
name|windowFrameRect
argument_list|,
name|palette
argument_list|()
operator|.
name|window
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Draw title
name|int
name|height
init|=
operator|(
name|int
operator|)
name|d
operator|->
name|titleBarHeight
argument_list|(
name|bar
argument_list|)
decl_stmt|;
name|bar
operator|.
name|rect
operator|.
name|setHeight
argument_list|(
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasBorder
condition|)
comment|// Frame is painted by PE_FrameWindow
name|bar
operator|.
name|rect
operator|.
name|adjust
argument_list|(
name|frameWidth
argument_list|,
name|frameWidth
argument_list|,
operator|-
name|frameWidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setFont
argument_list|(
name|QApplication
operator|::
name|font
argument_list|(
literal|"QMdiSubWindowTitleBar"
argument_list|)
argument_list|)
expr_stmt|;
name|style
argument_list|()
operator|->
name|drawComplexControl
argument_list|(
name|QStyle
operator|::
name|CC_TitleBar
argument_list|,
operator|&
name|bar
argument_list|,
name|painter
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
if|if
condition|(
name|setMask
condition|)
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
comment|// Draw window frame
name|QStyleOptionFrame
name|frameOptions
decl_stmt|;
name|frameOptions
operator|.
name|QStyleOption
operator|::
name|operator
name|=
argument_list|(
operator|*
name|option
argument_list|)
expr_stmt|;
name|initStyleOption
argument_list|(
operator|&
name|frameOptions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasBorder
condition|)
name|painter
operator|->
name|setClipRect
argument_list|(
name|windowFrameRect
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
operator|+
name|height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasFocus
argument_list|()
condition|)
block|{
name|frameOptions
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
block|}
else|else
block|{
name|frameOptions
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
block|}
name|bool
name|isActive
init|=
name|isActiveWindow
argument_list|()
decl_stmt|;
if|if
condition|(
name|isActive
condition|)
block|{
name|frameOptions
operator|.
name|state
operator||=
name|QStyle
operator|::
name|State_Active
expr_stmt|;
block|}
else|else
block|{
name|frameOptions
operator|.
name|state
operator|&=
operator|~
name|QStyle
operator|::
name|State_Active
expr_stmt|;
block|}
name|frameOptions
operator|.
name|palette
operator|.
name|setCurrentColorGroup
argument_list|(
name|isActive
condition|?
name|QPalette
operator|::
name|Active
else|:
name|QPalette
operator|::
name|Normal
argument_list|)
expr_stmt|;
name|frameOptions
operator|.
name|rect
operator|=
name|windowFrameRect
expr_stmt|;
name|frameOptions
operator|.
name|lineWidth
operator|=
name|style
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|QStyle
operator|::
name|PM_MdiSubWindowFrameWidth
argument_list|,
literal|0
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|frameOptions
operator|.
name|midLineWidth
operator|=
literal|1
expr_stmt|;
name|style
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|QStyle
operator|::
name|PE_FrameWindow
argument_list|,
operator|&
name|frameOptions
argument_list|,
name|painter
argument_list|,
name|widget
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|realPainter
operator|->
name|drawPixmap
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|pm
argument_list|)
expr_stmt|;
operator|delete
name|painter
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsWidget
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
return|return
name|windowFrameRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsWidget
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|rect
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Call this function to close the widget.      Returns \c true if the widget was closed; otherwise returns \c false.     This slot will first send a QCloseEvent to the widget, which may or may     not accept the event. If the event was ignored, nothing happens. If the     event was accepted, it will hide() the widget.      If the widget has the Qt::WA_DeleteOnClose attribute set it will be     deleted. */
end_comment
begin_function
DECL|function|close
name|bool
name|QGraphicsWidget
operator|::
name|close
parameter_list|()
block|{
name|QCloseEvent
name|closeEvent
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|closeEvent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|closeEvent
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// hide
if|if
condition|(
name|isVisible
argument_list|()
condition|)
block|{
name|hide
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_DeleteOnClose
argument_list|)
condition|)
block|{
name|deleteLater
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_NO_USING_KEYWORD
end_ifdef
begin_comment
comment|/*!     \fn const QObjectList&QGraphicsWidget::children() const     \internal      This function returns the same value as QObject::children(). It's     provided to differentiate between the obsolete member     QGraphicsItem::children() and QObject::children(). QGraphicsItem now     provides childItems() instead. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|void QGraphicsWidget::dumpFocusChain() {     qDebug()<< "=========== Dumping focus chain ==============";     int i = 0;     QGraphicsWidget *next = this;     QSet<QGraphicsWidget*> visited;     do {         if (!next) {             qWarning("Found a focus chain that is not circular, (next == 0)");             break;         }         qDebug()<< i++<< QString::number(uint(next), 16)<< next->className()<< next->data(0)<< QString::fromLatin1("focusItem:%1").arg(next->hasFocus() ? '1' : '0')<< QLatin1String("next:")<< next->d_func()->focusNext->data(0)<< QLatin1String("prev:")<< next->d_func()->focusPrev->data(0);         if (visited.contains(next)) {             qWarning("Already visited this node. However, I expected to dump until I found myself.");             break;         }         visited<< next;         next = next->d_func()->focusNext;     } while (next != this); }
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSVIEW
end_comment
end_unit
