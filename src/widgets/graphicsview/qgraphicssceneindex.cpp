begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtWidgets module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGraphicsSceneIndex     \brief The QGraphicsSceneIndex class provides a base class to implement     a custom indexing algorithm for discovering items in QGraphicsScene.     \since 4.6     \ingroup graphicsview-api      \internal      The QGraphicsSceneIndex class provides a base class to implement     a custom indexing algorithm for discovering items in QGraphicsScene. You     need to subclass it and reimplement addItem, removeItem, estimateItems     and items in order to have an functional indexing.      \sa QGraphicsScene, QGraphicsView */
end_comment
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsitem_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneindex_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscenebsptreeindex_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QGraphicsSceneIndexRectIntersector
class|class
name|QGraphicsSceneIndexRectIntersector
super|:
specifier|public
name|QGraphicsSceneIndexIntersector
block|{
public|public:
DECL|function|intersect
name|bool
name|intersect
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|exposeRect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|QRectF
name|brect
init|=
name|item
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|brect
argument_list|)
expr_stmt|;
comment|// ### Add test for this (without making things slower?)
name|Q_UNUSED
argument_list|(
name|exposeRect
argument_list|)
expr_stmt|;
name|bool
name|keep
init|=
literal|true
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemd
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
comment|// Untransformable items; map the scene rect to item coordinates.
specifier|const
name|QTransform
name|transform
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|deviceTransform
argument_list|)
decl_stmt|;
name|QRectF
name|itemRect
init|=
operator|(
name|deviceTransform
operator|*
name|transform
operator|.
name|inverted
argument_list|()
operator|)
operator|.
name|mapRect
argument_list|(
name|sceneRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemBoundingRect
condition|)
name|keep
operator|=
name|itemRect
operator|.
name|contains
argument_list|(
name|brect
argument_list|)
operator|&&
name|itemRect
operator|!=
name|brect
expr_stmt|;
else|else
name|keep
operator|=
name|itemRect
operator|.
name|intersects
argument_list|(
name|brect
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|)
condition|)
block|{
name|QPainterPath
name|itemPath
decl_stmt|;
name|itemPath
operator|.
name|addRect
argument_list|(
name|itemRect
argument_list|)
expr_stmt|;
name|keep
operator|=
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
argument_list|(
name|item
argument_list|,
name|itemPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|itemd
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
specifier|const
name|QRectF
name|itemSceneBoundingRect
init|=
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|?
name|brect
operator|.
name|translated
argument_list|(
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|itemd
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|brect
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemBoundingRect
condition|)
name|keep
operator|=
name|sceneRect
operator|!=
name|brect
operator|&&
name|sceneRect
operator|.
name|contains
argument_list|(
name|itemSceneBoundingRect
argument_list|)
expr_stmt|;
else|else
name|keep
operator|=
name|sceneRect
operator|.
name|intersects
argument_list|(
name|itemSceneBoundingRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|)
condition|)
block|{
name|QPainterPath
name|rectPath
decl_stmt|;
name|rectPath
operator|.
name|addRect
argument_list|(
name|sceneRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|)
name|rectPath
operator|.
name|translate
argument_list|(
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|rectPath
operator|=
name|itemd
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|rectPath
argument_list|)
expr_stmt|;
name|keep
operator|=
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
argument_list|(
name|item
argument_list|,
name|rectPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keep
return|;
block|}
DECL|member|sceneRect
name|QRectF
name|sceneRect
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QGraphicsSceneIndexPointIntersector
class|class
name|QGraphicsSceneIndexPointIntersector
super|:
specifier|public
name|QGraphicsSceneIndexIntersector
block|{
public|public:
DECL|function|intersect
name|bool
name|intersect
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|exposeRect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|QRectF
name|brect
init|=
name|item
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|brect
argument_list|)
expr_stmt|;
comment|// ### Add test for this (without making things slower?)
name|Q_UNUSED
argument_list|(
name|exposeRect
argument_list|)
expr_stmt|;
name|bool
name|keep
init|=
literal|false
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemd
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
comment|// Untransformable items; map the scene point to item coordinates.
specifier|const
name|QTransform
name|transform
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|deviceTransform
argument_list|)
decl_stmt|;
name|QPointF
name|itemPoint
init|=
operator|(
name|deviceTransform
operator|*
name|transform
operator|.
name|inverted
argument_list|()
operator|)
operator|.
name|map
argument_list|(
name|scenePoint
argument_list|)
decl_stmt|;
name|keep
operator|=
name|brect
operator|.
name|contains
argument_list|(
name|itemPoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|)
condition|)
block|{
name|QPainterPath
name|pointPath
decl_stmt|;
name|pointPath
operator|.
name|addRect
argument_list|(
name|QRectF
argument_list|(
name|itemPoint
argument_list|,
name|QSizeF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|keep
operator|=
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
argument_list|(
name|item
argument_list|,
name|pointPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|itemd
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
name|QRectF
name|sceneBoundingRect
init|=
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|?
name|brect
operator|.
name|translated
argument_list|(
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|itemd
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|brect
argument_list|)
decl_stmt|;
name|keep
operator|=
name|sceneBoundingRect
operator|.
name|intersects
argument_list|(
name|QRectF
argument_list|(
name|scenePoint
argument_list|,
name|QSizeF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
block|{
name|QPointF
name|p
init|=
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|?
name|QPointF
argument_list|(
name|scenePoint
operator|.
name|x
argument_list|()
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|scenePoint
operator|.
name|y
argument_list|()
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|itemd
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|scenePoint
argument_list|)
decl_stmt|;
name|keep
operator|=
name|item
operator|->
name|contains
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keep
return|;
block|}
DECL|member|scenePoint
name|QPointF
name|scenePoint
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QGraphicsSceneIndexPathIntersector
class|class
name|QGraphicsSceneIndexPathIntersector
super|:
specifier|public
name|QGraphicsSceneIndexIntersector
block|{
public|public:
DECL|function|intersect
name|bool
name|intersect
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|exposeRect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|QRectF
name|brect
init|=
name|item
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|brect
argument_list|)
expr_stmt|;
comment|// ### Add test for this (without making things slower?)
name|Q_UNUSED
argument_list|(
name|exposeRect
argument_list|)
expr_stmt|;
name|bool
name|keep
init|=
literal|true
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|itemd
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
comment|// Untransformable items; map the scene rect to item coordinates.
specifier|const
name|QTransform
name|transform
init|=
name|item
operator|->
name|deviceTransform
argument_list|(
name|deviceTransform
argument_list|)
decl_stmt|;
name|QPainterPath
name|itemPath
init|=
operator|(
name|deviceTransform
operator|*
name|transform
operator|.
name|inverted
argument_list|()
operator|)
operator|.
name|map
argument_list|(
name|scenePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemBoundingRect
condition|)
name|keep
operator|=
name|itemPath
operator|.
name|contains
argument_list|(
name|brect
argument_list|)
expr_stmt|;
else|else
name|keep
operator|=
name|itemPath
operator|.
name|intersects
argument_list|(
name|brect
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|)
condition|)
name|keep
operator|=
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
argument_list|(
name|item
argument_list|,
name|itemPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|itemd
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
specifier|const
name|QRectF
name|itemSceneBoundingRect
init|=
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|?
name|brect
operator|.
name|translated
argument_list|(
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|itemd
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|brect
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemBoundingRect
condition|)
name|keep
operator|=
name|scenePath
operator|.
name|contains
argument_list|(
name|itemSceneBoundingRect
argument_list|)
expr_stmt|;
else|else
name|keep
operator|=
name|scenePath
operator|.
name|intersects
argument_list|(
name|itemSceneBoundingRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|(
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|)
condition|)
block|{
name|QPainterPath
name|itemPath
init|=
name|itemd
operator|->
name|sceneTransformTranslateOnly
condition|?
name|scenePath
operator|.
name|translated
argument_list|(
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|itemd
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|itemd
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|scenePath
argument_list|)
decl_stmt|;
name|keep
operator|=
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
argument_list|(
name|item
argument_list|,
name|itemPath
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keep
return|;
block|}
DECL|member|scenePath
name|QPainterPath
name|scenePath
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a private scene index. */
end_comment
begin_constructor
DECL|function|QGraphicsSceneIndexPrivate
name|QGraphicsSceneIndexPrivate
operator|::
name|QGraphicsSceneIndexPrivate
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|scene
argument_list|(
name|scene
argument_list|)
block|{
name|pointIntersector
operator|=
operator|new
name|QGraphicsSceneIndexPointIntersector
expr_stmt|;
name|rectIntersector
operator|=
operator|new
name|QGraphicsSceneIndexRectIntersector
expr_stmt|;
name|pathIntersector
operator|=
operator|new
name|QGraphicsSceneIndexPathIntersector
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor of private scene index. */
end_comment
begin_destructor
DECL|function|~QGraphicsSceneIndexPrivate
name|QGraphicsSceneIndexPrivate
operator|::
name|~
name|QGraphicsSceneIndexPrivate
parameter_list|()
block|{
operator|delete
name|pointIntersector
expr_stmt|;
operator|delete
name|rectIntersector
expr_stmt|;
operator|delete
name|pathIntersector
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal      Checks if item collides with the path and mode, but also checks that if it     doesn't collide, maybe its frame rect will. */
end_comment
begin_function
DECL|function|itemCollidesWithPath
name|bool
name|QGraphicsSceneIndexPrivate
operator|::
name|itemCollidesWithPath
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|item
operator|->
name|collidesWithPath
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|item
operator|->
name|isWidget
argument_list|()
condition|)
block|{
comment|// Check if this is a window, and if its frame rect collides.
specifier|const
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|isWindow
argument_list|()
condition|)
block|{
name|QRectF
name|frameRect
init|=
name|widget
operator|->
name|windowFrameRect
argument_list|()
decl_stmt|;
name|QPainterPath
name|framePath
decl_stmt|;
name|framePath
operator|.
name|addRect
argument_list|(
name|frameRect
argument_list|)
expr_stmt|;
name|bool
name|intersects
init|=
name|path
operator|.
name|intersects
argument_list|(
name|frameRect
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemBoundingRect
condition|)
return|return
name|intersects
operator|||
name|path
operator|.
name|contains
argument_list|(
name|frameRect
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|||
name|framePath
operator|.
name|contains
argument_list|(
name|path
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
return|return
operator|!
name|intersects
operator|&&
name|path
operator|.
name|contains
argument_list|(
name|frameRect
operator|.
name|topLeft
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     This function returns the items in ascending order. */
end_comment
begin_function
DECL|function|recursive_items_helper
name|void
name|QGraphicsSceneIndexPrivate
operator|::
name|recursive_items_helper
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QRectF
name|exposeRect
parameter_list|,
name|QGraphicsSceneIndexIntersector
modifier|*
name|intersector
parameter_list|,
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
modifier|*
name|items
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|viewTransform
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|qreal
name|parentOpacity
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|visible
condition|)
return|return;
specifier|const
name|qreal
name|opacity
init|=
name|item
operator|->
name|d_ptr
operator|->
name|combineOpacityFromParent
argument_list|(
name|parentOpacity
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|itemIsFullyTransparent
init|=
name|QGraphicsItemPrivate
operator|::
name|isOpacityNull
argument_list|(
name|opacity
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|itemHasChildren
init|=
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|(
operator|!
name|itemHasChildren
operator|||
name|item
operator|->
name|d_ptr
operator|->
name|childrenCombineOpacity
argument_list|()
operator|)
condition|)
return|return;
comment|// Update the item's scene transform if dirty.
specifier|const
name|bool
name|itemIsUntransformable
init|=
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|wasDirtyParentSceneTransform
init|=
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|&&
operator|!
name|itemIsUntransformable
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|updateSceneTransformFromParent
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
block|}
specifier|const
name|bool
name|itemClipsChildrenToShape
init|=
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
operator|)
decl_stmt|;
name|bool
name|processItem
init|=
operator|!
name|itemIsFullyTransparent
decl_stmt|;
if|if
condition|(
name|processItem
condition|)
block|{
name|processItem
operator|=
name|intersector
operator|->
name|intersect
argument_list|(
name|item
argument_list|,
name|exposeRect
argument_list|,
name|mode
argument_list|,
name|viewTransform
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processItem
operator|&&
operator|(
operator|!
name|itemHasChildren
operator|||
name|itemClipsChildrenToShape
operator|)
condition|)
block|{
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|invalidateChildrenSceneTransform
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// else we know for sure this item has children we must process.
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|itemHasChildren
condition|)
block|{
comment|// Sort children.
name|item
operator|->
name|d_ptr
operator|->
name|ensureSortedChildren
argument_list|()
expr_stmt|;
comment|// Clip to shape.
if|if
condition|(
name|itemClipsChildrenToShape
operator|&&
operator|!
name|itemIsUntransformable
condition|)
block|{
name|QPainterPath
name|mappedShape
init|=
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
condition|?
name|item
operator|->
name|shape
argument_list|()
operator|.
name|translated
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
else|:
name|item
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|item
operator|->
name|shape
argument_list|()
argument_list|)
decl_stmt|;
name|exposeRect
operator|&=
name|mappedShape
operator|.
name|controlPointRect
argument_list|()
expr_stmt|;
block|}
comment|// Process children behind
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
operator|)
condition|)
break|break;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
operator|)
condition|)
continue|continue;
name|recursive_items_helper
argument_list|(
name|child
argument_list|,
name|exposeRect
argument_list|,
name|intersector
argument_list|,
name|items
argument_list|,
name|viewTransform
argument_list|,
name|mode
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Process item
if|if
condition|(
name|processItem
condition|)
name|items
operator|->
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|// Process children in front
if|if
condition|(
name|itemHasChildren
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasDirtyParentSceneTransform
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|itemIsFullyTransparent
operator|&&
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
operator|)
condition|)
continue|continue;
name|recursive_items_helper
argument_list|(
name|child
argument_list|,
name|exposeRect
argument_list|,
name|intersector
argument_list|,
name|items
argument_list|,
name|viewTransform
argument_list|,
name|mode
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|init
name|void
name|QGraphicsSceneIndexPrivate
operator|::
name|init
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scene
condition|)
return|return;
name|QObject
operator|::
name|connect
argument_list|(
name|scene
argument_list|,
name|SIGNAL
argument_list|(
name|sceneRectChanged
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|q_func
argument_list|()
argument_list|,
name|SLOT
argument_list|(
name|updateSceneRect
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs an abstract scene index for a given \a scene. */
end_comment
begin_constructor
DECL|function|QGraphicsSceneIndex
name|QGraphicsSceneIndex
operator|::
name|QGraphicsSceneIndex
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QGraphicsSceneIndexPrivate
argument_list|(
name|scene
argument_list|)
argument_list|,
name|scene
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGraphicsSceneIndex
name|QGraphicsSceneIndex
operator|::
name|QGraphicsSceneIndex
parameter_list|(
name|QGraphicsSceneIndexPrivate
modifier|&
name|dd
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|scene
argument_list|)
block|{
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the scene index. */
end_comment
begin_destructor
DECL|function|~QGraphicsSceneIndex
name|QGraphicsSceneIndex
operator|::
name|~
name|QGraphicsSceneIndex
parameter_list|()
block|{  }
end_destructor
begin_comment
comment|/*!     Returns the scene of this index. */
end_comment
begin_function
DECL|function|scene
name|QGraphicsScene
modifier|*
name|QGraphicsSceneIndex
operator|::
name|scene
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|scene
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneIndex::items(const QPointF&pos,     Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const      Returns all visible items that, depending on \a mode, are at the specified     \a pos and return a list sorted using \a order.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with \a pos are returned.      \a deviceTransform is the transformation apply to the view.      This method use the estimation of the index (estimateItems) and refine the     list to get an exact result. If you want to implement your own refinement     algorithm you can reimplement this method.      \sa estimateItems()  */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|items
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
decl_stmt|;
name|d
operator|->
name|pointIntersector
operator|->
name|scenePoint
operator|=
name|pos
expr_stmt|;
name|d
operator|->
name|items_helper
argument_list|(
name|QRectF
argument_list|(
name|pos
argument_list|,
name|QSizeF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|d
operator|->
name|pointIntersector
argument_list|,
operator|&
name|itemList
argument_list|,
name|deviceTransform
argument_list|,
name|mode
argument_list|,
name|order
argument_list|)
expr_stmt|;
return|return
name|itemList
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneIndex::items(const QRectF&rect,     Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const      \overload      Returns all visible items that, depending on \a mode, are either inside or     intersect with the specified \a rect and return a list sorted using \a order.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a rect are returned.      \a deviceTransform is the transformation apply to the view.      This method use the estimation of the index (estimateItems) and refine     the list to get an exact result. If you want to implement your own     refinement algorithm you can reimplement this method.      \sa estimateItems()  */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|items
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
name|QRectF
name|exposeRect
init|=
name|rect
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|exposeRect
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
decl_stmt|;
name|d
operator|->
name|rectIntersector
operator|->
name|sceneRect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|items_helper
argument_list|(
name|exposeRect
argument_list|,
name|d
operator|->
name|rectIntersector
argument_list|,
operator|&
name|itemList
argument_list|,
name|deviceTransform
argument_list|,
name|mode
argument_list|,
name|order
argument_list|)
expr_stmt|;
return|return
name|itemList
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneIndex::items(const QPolygonF&polygon, Qt::ItemSelectionMode mode, Qt::SortOrder order, const     QTransform&deviceTransform) const      \overload      Returns all visible items that, depending on \a mode, are either inside or     intersect with the specified \a polygon and return a list sorted using \a order.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a polygon are returned.      \a deviceTransform is the transformation apply to the view.      This method use the estimation of the index (estimateItems) and refine     the list to get an exact result. If you want to implement your own     refinement algorithm you can reimplement this method.      \sa estimateItems()  */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|items
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
decl_stmt|;
name|QRectF
name|exposeRect
init|=
name|polygon
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|exposeRect
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addPolygon
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
name|d
operator|->
name|pathIntersector
operator|->
name|scenePath
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|items_helper
argument_list|(
name|exposeRect
argument_list|,
name|d
operator|->
name|pathIntersector
argument_list|,
operator|&
name|itemList
argument_list|,
name|deviceTransform
argument_list|,
name|mode
argument_list|,
name|order
argument_list|)
expr_stmt|;
return|return
name|itemList
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneIndex::items(const QPainterPath&path, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform&deviceTransform) const      \overload      Returns all visible items that, depending on \a mode, are either inside or     intersect with the specified \a path and return a list sorted using \a order.      The default value for \a mode is Qt::IntersectsItemShape; all items whose     exact shape intersects with or is contained by \a path are returned.      \a deviceTransform is the transformation apply to the view.      This method use the estimation of the index (estimateItems) and refine     the list to get an exact result. If you want to implement your own     refinement algorithm you can reimplement this method.      \sa estimateItems()  */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|items
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|deviceTransform
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
decl_stmt|;
name|QRectF
name|exposeRect
init|=
name|path
operator|.
name|controlPointRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|exposeRect
argument_list|)
expr_stmt|;
name|d
operator|->
name|pathIntersector
operator|->
name|scenePath
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|items_helper
argument_list|(
name|exposeRect
argument_list|,
name|d
operator|->
name|pathIntersector
argument_list|,
operator|&
name|itemList
argument_list|,
name|deviceTransform
argument_list|,
name|mode
argument_list|,
name|order
argument_list|)
expr_stmt|;
return|return
name|itemList
return|;
block|}
end_function
begin_comment
comment|/*!     This virtual function return an estimation of items at position \a point.     This method return a list sorted using \a order. */
end_comment
begin_function
DECL|function|estimateItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|estimateItems
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
return|return
name|estimateItems
argument_list|(
name|QRectF
argument_list|(
name|point
argument_list|,
name|QSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|order
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|estimateTopLevelItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneIndex
operator|::
name|estimateTopLevelItems
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneIndex
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|QGraphicsScenePrivate
modifier|*
name|scened
init|=
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|scened
operator|->
name|ensureSortedTopLevelItems
argument_list|()
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
condition|)
block|{
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|sorted
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|scened
operator|->
name|topLevelItems
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|sorted
operator|<<
name|scened
operator|->
name|topLevelItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|sorted
return|;
block|}
return|return
name|scened
operator|->
name|topLevelItems
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneIndex::items(Qt::SortOrder order = Qt::DescendingOrder) const      This pure virtual function all items in the index and sort them using     \a order. */
end_comment
begin_comment
comment|/*!     Notifies the index that the scene's scene rect has changed. \a rect     is thew new scene rect.      \sa QGraphicsScene::sceneRect() */
end_comment
begin_function
DECL|function|updateSceneRect
name|void
name|QGraphicsSceneIndex
operator|::
name|updateSceneRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This virtual function removes all items in the scene index. */
end_comment
begin_function
DECL|function|clear
name|void
name|QGraphicsSceneIndex
operator|::
name|clear
parameter_list|()
block|{
specifier|const
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|allItems
init|=
name|items
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|removeItem
argument_list|(
name|allItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual void QGraphicsSceneIndex::addItem(QGraphicsItem *item) = 0      This pure virtual function inserts an \a item to the scene index.      \sa removeItem(), deleteItem() */
end_comment
begin_comment
comment|/*!     \fn virtual void QGraphicsSceneIndex::removeItem(QGraphicsItem *item) = 0      This pure virtual function removes an \a item to the scene index.      \sa addItem(), deleteItem() */
end_comment
begin_comment
comment|/*!     This method is called when an \a item has been deleted.     The default implementation call removeItem. Be carefull,     if your implementation of removeItem use pure virtual method     of QGraphicsItem like boundingRect(), then you should reimplement     this method.      \sa addItem(), removeItem() */
end_comment
begin_function
DECL|function|deleteItem
name|void
name|QGraphicsSceneIndex
operator|::
name|deleteItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|removeItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This virtual function is called by QGraphicsItem to notify the index     that some part of the \a item 's state changes. By reimplementing this     function, your can react to a change, and in some cases, (depending on \a     change,) adjustments in the index can be made.      \a change is the parameter of the item that is changing. \a value is the     value that changed; the type of the value depends on \a change.      The default implementation does nothing.      \sa QGraphicsItem::GraphicsItemChange */
end_comment
begin_function
DECL|function|itemChange
name|void
name|QGraphicsSceneIndex
operator|::
name|itemChange
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemChange
name|change
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|value
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|change
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Notify the index for a geometry change of an \a item.      \sa QGraphicsItem::prepareGeometryChange() */
end_comment
begin_function
DECL|function|prepareBoundingRectChange
name|void
name|QGraphicsSceneIndex
operator|::
name|prepareBoundingRectChange
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qgraphicssceneindex_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GRAPHICSVIEW
end_comment
end_unit
