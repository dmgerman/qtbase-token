begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGraphicsSceneBspTreeIndex     \brief The QGraphicsSceneBspTreeIndex class provides an implementation of     a BSP indexing algorithm for discovering items in QGraphicsScene.     \since 4.6     \ingroup graphicsview-api      \internal      QGraphicsSceneBspTreeIndex index use a BSP(Binary Space Partitioning)     implementation to discover items quickly. This implementation is     very efficient for static scenes. It has a depth that you can set.     The depth directly affects performance and memory usage; the latter     growing exponentially with the depth of the tree. With an optimal tree     depth, the index can instantly determine the locality of items, even     for scenes with thousands or millions of items. This also greatly improves     rendering performance.      By default, the depth value is 0, in which case Qt will guess a reasonable     default depth based on the size, location and number of items in the     scene. If these parameters change frequently, however, you may experience     slowdowns as the index retunes the depth internally. You can avoid     potential slowdowns by fixating the tree depth through setting this     property.      The depth of the tree and the size of the scene rectangle decide the     granularity of the scene's partitioning. The size of each scene segment is     determined by the following algorithm:      The BSP tree has an optimal size when each segment contains between 0 and     10 items.      \sa QGraphicsScene, QGraphicsView, QGraphicsSceneIndex */
end_comment
begin_include
include|#
directive|include
file|<QtCore/qglobal.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|<private/qgraphicsscene_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicsscenebsptreeindex_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicssceneindex_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|intmaxlog
specifier|static
specifier|inline
name|int
name|intmaxlog
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|>
literal|0
condition|?
name|qMax
argument_list|(
name|qCeil
argument_list|(
name|qLn
argument_list|(
name|qreal
argument_list|(
name|n
argument_list|)
argument_list|)
operator|/
name|qLn
argument_list|(
name|qreal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|5
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a private scene bsp index. */
end_comment
begin_constructor
DECL|function|QGraphicsSceneBspTreeIndexPrivate
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|QGraphicsSceneBspTreeIndexPrivate
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QGraphicsSceneIndexPrivate
argument_list|(
name|scene
argument_list|)
member_init_list|,
name|bspTreeDepth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|indexTimerId
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|restartIndexTimer
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|regenerateIndex
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|lastItemCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|purgePending
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|sortCacheEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|updatingSortCache
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     This method will update the BSP index by removing the items from the temporary     unindexed list and add them in the indexedItems list. This will also     update the growingItemsBoundingRect if needed. This will update the BSP     implementation as well.      \internal */
end_comment
begin_function
DECL|function|_q_updateIndex
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|_q_updateIndex
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexTimerId
condition|)
return|return;
name|q
operator|->
name|killTimer
argument_list|(
name|indexTimerId
argument_list|)
expr_stmt|;
name|indexTimerId
operator|=
literal|0
expr_stmt|;
name|purgeRemovedItems
argument_list|()
expr_stmt|;
comment|// Add unindexedItems to indexedItems
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unindexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|item
init|=
name|unindexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|freeItemIndexes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|freeIndex
init|=
name|freeItemIndexes
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|=
name|freeIndex
expr_stmt|;
name|indexedItems
index|[
name|freeIndex
index|]
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|=
name|indexedItems
operator|.
name|size
argument_list|()
expr_stmt|;
name|indexedItems
operator|<<
name|item
expr_stmt|;
block|}
block|}
block|}
comment|// Determine whether we should regenerate the BSP tree.
if|if
condition|(
name|bspTreeDepth
operator|==
literal|0
condition|)
block|{
name|int
name|oldDepth
init|=
name|intmaxlog
argument_list|(
name|lastItemCount
argument_list|)
decl_stmt|;
name|bspTreeDepth
operator|=
name|intmaxlog
argument_list|(
name|indexedItems
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|int
name|slack
init|=
literal|100
decl_stmt|;
if|if
condition|(
name|bsp
operator|.
name|leafCount
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|oldDepth
operator|!=
name|bspTreeDepth
operator|&&
name|qAbs
argument_list|(
name|lastItemCount
operator|-
name|indexedItems
operator|.
name|size
argument_list|()
argument_list|)
operator|>
name|slack
operator|)
condition|)
block|{
comment|// ### Crude algorithm.
name|regenerateIndex
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Regenerate the tree.
if|if
condition|(
name|regenerateIndex
condition|)
block|{
name|regenerateIndex
operator|=
literal|false
expr_stmt|;
name|bsp
operator|.
name|initialize
argument_list|(
name|sceneRect
argument_list|,
name|bspTreeDepth
argument_list|)
expr_stmt|;
name|unindexedItems
operator|=
name|indexedItems
expr_stmt|;
name|lastItemCount
operator|=
name|indexedItems
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// Insert all unindexed items into the tree.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unindexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|item
init|=
name|unindexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|untransformableItems
operator|<<
name|item
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
condition|)
continue|continue;
name|bsp
operator|.
name|insertItem
argument_list|(
name|item
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneEffectiveBoundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|unindexedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Removes stale pointers from all data structures. */
end_comment
begin_function
DECL|function|purgeRemovedItems
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|purgeRemovedItems
parameter_list|()
block|{
if|if
condition|(
operator|!
name|purgePending
operator|&&
name|removedItems
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Remove stale items from the BSP tree.
name|bsp
operator|.
name|removeItems
argument_list|(
name|removedItems
argument_list|)
expr_stmt|;
comment|// Purge this list.
name|removedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|freeItemIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|indexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|freeItemIndexes
operator|<<
name|i
expr_stmt|;
block|}
name|purgePending
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Starts or restarts the timer used for reindexing unindexed items. */
end_comment
begin_function
DECL|function|startIndexTimer
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|startIndexTimer
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexTimerId
condition|)
block|{
name|restartIndexTimer
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|indexTimerId
operator|=
name|q
operator|->
name|startTimer
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|resetIndex
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|resetIndex
parameter_list|()
block|{
name|purgeRemovedItems
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QGraphicsItem
modifier|*
name|item
init|=
name|indexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
argument_list|)
expr_stmt|;
name|unindexedItems
operator|<<
name|item
expr_stmt|;
block|}
block|}
name|indexedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|freeItemIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|untransformableItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|regenerateIndex
operator|=
literal|true
expr_stmt|;
name|startIndexTimer
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|climbTree
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|climbTree
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|int
modifier|*
name|stackingOrder
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|childList
init|=
name|item
operator|->
name|d_ptr
operator|->
name|children
decl_stmt|;
name|qSort
argument_list|(
name|childList
operator|.
name|begin
argument_list|()
argument_list|,
name|childList
operator|.
name|end
argument_list|()
argument_list|,
name|qt_closestLeaf
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
operator|)
condition|)
name|climbTree
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|stackingOrder
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|d_ptr
operator|->
name|globalStackingOrder
operator|=
operator|(
operator|*
name|stackingOrder
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
condition|)
name|climbTree
argument_list|(
name|childList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|stackingOrder
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|item
operator|->
name|d_ptr
operator|->
name|globalStackingOrder
operator|=
operator|(
operator|*
name|stackingOrder
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_updateSortCache
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|_q_updateSortCache
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|_q_updateIndex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sortCacheEnabled
operator|||
operator|!
name|updatingSortCache
condition|)
return|return;
name|updatingSortCache
operator|=
literal|false
expr_stmt|;
name|int
name|stackingOrder
init|=
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|topLevels
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|items
init|=
name|q
operator|->
name|items
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|items
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|&&
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|parent
condition|)
name|topLevels
operator|<<
name|item
expr_stmt|;
block|}
name|qSort
argument_list|(
name|topLevels
operator|.
name|begin
argument_list|()
argument_list|,
name|topLevels
operator|.
name|end
argument_list|()
argument_list|,
name|qt_closestLeaf
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topLevels
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|climbTree
argument_list|(
name|topLevels
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|stackingOrder
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|invalidateSortCache
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|invalidateSortCache
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sortCacheEnabled
operator|||
name|updatingSortCache
condition|)
return|return;
name|updatingSortCache
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_updateSortCache"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addItem
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|addItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|recursive
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
condition|)
return|return;
comment|// Prevent reusing a recently deleted pointer: purge all removed item from our lists.
name|purgeRemovedItems
argument_list|()
expr_stmt|;
comment|// Invalidate any sort caching; arrival of a new item means we need to resort.
comment|// Update the scene's sort cache settings.
name|item
operator|->
name|d_ptr
operator|->
name|globalStackingOrder
operator|=
operator|-
literal|1
expr_stmt|;
name|invalidateSortCache
argument_list|()
expr_stmt|;
comment|// Indexing requires sceneBoundingRect(), but because \a item might
comment|// not be completely constructed at this point, we need to store it in
comment|// a temporary list and schedule an indexing for later.
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|unindexedItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|unindexedItems
operator|<<
name|item
expr_stmt|;
name|startIndexTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|indexedItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QGraphicsSceneBspTreeIndex::addItem: item has already been added to this BSP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recursive
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|addItem
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|removeItem
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|removeItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|bool
name|recursive
parameter_list|,
name|bool
name|moveToUnindexedItems
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
condition|)
return|return;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|<
name|indexedItems
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|indexedItems
operator|.
name|at
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|index
argument_list|)
operator|==
name|item
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
argument_list|)
expr_stmt|;
name|freeItemIndexes
operator|<<
name|item
operator|->
name|d_ptr
operator|->
name|index
expr_stmt|;
name|indexedItems
index|[
name|item
operator|->
name|d_ptr
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|untransformableItems
operator|.
name|removeOne
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|inDestructor
condition|)
block|{
comment|// Avoid virtual function calls from the destructor.
name|purgePending
operator|=
literal|true
expr_stmt|;
name|removedItems
operator|<<
name|item
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
condition|)
block|{
name|bsp
operator|.
name|removeItem
argument_list|(
name|item
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|sceneEffectiveBoundingRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unindexedItems
operator|.
name|removeOne
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|invalidateSortCache
argument_list|()
expr_stmt|;
comment|// ### Only do this when removing from BSP?
name|Q_ASSERT
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|indexedItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|unindexedItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|untransformableItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|moveToUnindexedItems
condition|)
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|removeItem
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|recursive
argument_list|,
name|moveToUnindexedItems
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|estimateItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|estimateItems
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
name|bool
name|onlyTopLevelItems
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlyTopLevelItems
operator|&&
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|q
operator|->
name|QGraphicsSceneIndex
operator|::
name|estimateTopLevelItems
argument_list|(
name|rect
argument_list|,
name|order
argument_list|)
return|;
name|purgeRemovedItems
argument_list|()
expr_stmt|;
name|_q_updateSortCache
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|unindexedItems
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|rectItems
init|=
name|bsp
operator|.
name|items
argument_list|(
name|rect
argument_list|,
name|onlyTopLevelItems
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyTopLevelItems
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|untransformableItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
name|untransformableItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|parent
condition|)
block|{
name|rectItems
operator|<<
name|item
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|item
operator|->
name|topLevelItem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rectItems
operator|.
name|contains
argument_list|(
name|item
argument_list|)
condition|)
name|rectItems
operator|<<
name|item
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|rectItems
operator|+=
name|untransformableItems
expr_stmt|;
block|}
name|sortItems
argument_list|(
operator|&
name|rectItems
argument_list|,
name|order
argument_list|,
name|sortCacheEnabled
argument_list|,
name|onlyTopLevelItems
argument_list|)
expr_stmt|;
return|return
name|rectItems
return|;
block|}
end_function
begin_comment
comment|/*!     Sort a list of \a itemList in a specific \a order and use the cache if requested.      \internal */
end_comment
begin_function
DECL|function|sortItems
name|void
name|QGraphicsSceneBspTreeIndexPrivate
operator|::
name|sortItems
parameter_list|(
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
modifier|*
name|itemList
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|,
name|bool
name|sortCacheEnabled
parameter_list|,
name|bool
name|onlyTopLevelItems
parameter_list|)
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|SortOrder
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
name|onlyTopLevelItems
condition|)
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
condition|)
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|qt_closestLeaf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|qt_notclosestLeaf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sortCacheEnabled
condition|)
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
condition|)
block|{
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|closestItemFirst_withCache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
block|{
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|closestItemLast_withCache
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|DescendingOrder
condition|)
block|{
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|qt_closestItemFirst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
name|Qt
operator|::
name|AscendingOrder
condition|)
block|{
name|qSort
argument_list|(
name|itemList
operator|->
name|begin
argument_list|()
argument_list|,
name|itemList
operator|->
name|end
argument_list|()
argument_list|,
name|qt_closestItemLast
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a BSP scene index for the given \a scene. */
end_comment
begin_constructor
DECL|function|QGraphicsSceneBspTreeIndex
name|QGraphicsSceneBspTreeIndex
operator|::
name|QGraphicsSceneBspTreeIndex
parameter_list|(
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QGraphicsSceneIndex
argument_list|(
operator|*
operator|new
name|QGraphicsSceneBspTreeIndexPrivate
argument_list|(
name|scene
argument_list|)
argument_list|,
name|scene
argument_list|)
block|{  }
end_constructor
begin_destructor
DECL|function|~QGraphicsSceneBspTreeIndex
name|QGraphicsSceneBspTreeIndex
operator|::
name|~
name|QGraphicsSceneBspTreeIndex
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|indexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// Ensure item bits are reset properly.
if|if
condition|(
name|QGraphicsItem
modifier|*
name|item
init|=
name|d
operator|->
name|indexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_destructor
begin_comment
comment|/*!     \internal     Clear the all the BSP index. */
end_comment
begin_function
DECL|function|clear
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|bsp
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|lastItemCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|freeItemIndexes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|indexedItems
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// Ensure item bits are reset properly.
if|if
condition|(
name|QGraphicsItem
modifier|*
name|item
init|=
name|d
operator|->
name|indexedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|itemDiscovered
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|d
operator|->
name|indexedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|unindexedItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|untransformableItems
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|regenerateIndex
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Add the \a item into the BSP index. */
end_comment
begin_function
DECL|function|addItem
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|addItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|addItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Remove the \a item from the BSP index. */
end_comment
begin_function
DECL|function|removeItem
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|removeItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|removeItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Update the BSP when the \a item 's bounding rect has changed. */
end_comment
begin_function
DECL|function|prepareBoundingRectChange
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|prepareBoundingRectChange
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
condition|)
return|return;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|index
operator|==
operator|-
literal|1
operator|||
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
operator|||
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
condition|)
block|{
return|return;
comment|// Item is not in BSP tree; nothing to do.
block|}
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|QGraphicsItem
modifier|*
name|thatItem
init|=
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|d
operator|->
name|removeItem
argument_list|(
name|thatItem
argument_list|,
comment|/*recursive=*/
literal|false
argument_list|,
comment|/*moveToUnindexedItems=*/
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
comment|// ### Do we really need this?
name|prepareBoundingRectChange
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns an estimation visible items that are either inside or     intersect with the specified \a rect and return a list sorted using \a order.      \a deviceTransform is the transformation apply to the view.  */
end_comment
begin_function
DECL|function|estimateItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneBspTreeIndex
operator|::
name|estimateItems
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
return|return
cast|const_cast
argument_list|<
name|QGraphicsSceneBspTreeIndexPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|estimateItems
argument_list|(
name|rect
argument_list|,
name|order
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|estimateTopLevelItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneBspTreeIndex
operator|::
name|estimateTopLevelItems
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
return|return
cast|const_cast
argument_list|<
name|QGraphicsSceneBspTreeIndexPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|estimateItems
argument_list|(
name|rect
argument_list|,
name|order
argument_list|,
comment|/*onlyTopLevels=*/
literal|true
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QGraphicsItem *> QGraphicsSceneBspTreeIndex::items(Qt::SortOrder order = Qt::DescendingOrder) const;      Return all items in the BSP index and sort them using \a order. */
end_comment
begin_function
DECL|function|items
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsSceneBspTreeIndex
operator|::
name|items
parameter_list|(
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QGraphicsSceneBspTreeIndexPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|purgeRemovedItems
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|itemList
decl_stmt|;
comment|// If freeItemIndexes is empty, we know there are no holes in indexedItems and
comment|// unindexedItems.
if|if
condition|(
name|d
operator|->
name|freeItemIndexes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|unindexedItems
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|itemList
operator|=
name|d
operator|->
name|indexedItems
expr_stmt|;
block|}
else|else
block|{
name|itemList
operator|=
name|d
operator|->
name|indexedItems
operator|+
name|d
operator|->
name|unindexedItems
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Rebuild the list of items to avoid holes. ### We could also just
comment|// compress the item lists at this point.
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|d
operator|->
name|indexedItems
operator|+
name|d
operator|->
name|unindexedItems
control|)
block|{
if|if
condition|(
name|item
condition|)
name|itemList
operator|<<
name|item
expr_stmt|;
block|}
block|}
if|if
condition|(
name|order
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//We sort descending order
name|d
operator|->
name|sortItems
argument_list|(
operator|&
name|itemList
argument_list|,
name|order
argument_list|,
name|d
operator|->
name|sortCacheEnabled
argument_list|)
expr_stmt|;
block|}
return|return
name|itemList
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsSceneBspTreeIndex::bspTreeDepth     \brief the depth of the BSP index tree     \since 4.6      This value determines the depth of BSP tree. The depth     directly affects performance and memory usage; the latter     growing exponentially with the depth of the tree. With an optimal tree     depth, the index can instantly determine the locality of items, even     for scenes with thousands or millions of items. This also greatly improves     rendering performance.      By default, the value is 0, in which case Qt will guess a reasonable     default depth based on the size, location and number of items in the     scene. If these parameters change frequently, however, you may experience     slowdowns as the index retunes the depth internally. You can avoid     potential slowdowns by fixating the tree depth through setting this     property.      The depth of the tree and the size of the scene rectangle decide the     granularity of the scene's partitioning. The size of each scene segment is     determined by the following algorithm:      The BSP tree has an optimal size when each segment contains between 0 and     10 items.  */
end_comment
begin_function
DECL|function|bspTreeDepth
name|int
name|QGraphicsSceneBspTreeIndex
operator|::
name|bspTreeDepth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|bspTreeDepth
return|;
block|}
end_function
begin_function
DECL|function|setBspTreeDepth
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|setBspTreeDepth
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bspTreeDepth
operator|==
name|depth
condition|)
return|return;
name|d
operator|->
name|bspTreeDepth
operator|=
name|depth
expr_stmt|;
name|d
operator|->
name|resetIndex
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      This method react to the  \a rect change of the scene and     reset the BSP tree index. */
end_comment
begin_function
DECL|function|updateSceneRect
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|updateSceneRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|sceneRect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|resetIndex
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      This method react to the \a change of the \a item and use the \a value to     update the BSP tree if necessary. */
end_comment
begin_function
DECL|function|itemChange
name|void
name|QGraphicsSceneBspTreeIndex
operator|::
name|itemChange
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemChange
name|change
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|QGraphicsItem
operator|::
name|ItemFlagsChange
case|:
block|{
comment|// Handle ItemIgnoresTransformations
name|QGraphicsItem
operator|::
name|GraphicsItemFlags
name|newFlags
init|=
operator|*
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsItem
operator|::
name|GraphicsItemFlags
operator|*
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|bool
name|ignoredTransform
init|=
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
decl_stmt|;
name|bool
name|willIgnoreTransform
init|=
name|newFlags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
decl_stmt|;
name|bool
name|clipsChildren
init|=
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
decl_stmt|;
name|bool
name|willClipChildren
init|=
name|newFlags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
decl_stmt|;
if|if
condition|(
operator|(
name|ignoredTransform
operator|!=
name|willIgnoreTransform
operator|)
operator|||
operator|(
name|clipsChildren
operator|!=
name|willClipChildren
operator|)
condition|)
block|{
name|QGraphicsItem
modifier|*
name|thatItem
init|=
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|// Remove item and its descendants from the index and append
comment|// them to the list of unindexed items. Then, when the index
comment|// is updated, they will be put into the bsp-tree or the list
comment|// of untransformable items.
name|d
operator|->
name|removeItem
argument_list|(
name|thatItem
argument_list|,
comment|/*recursive=*/
literal|true
argument_list|,
comment|/*moveToUnidexedItems=*/
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QGraphicsItem
operator|::
name|ItemZValueChange
case|:
name|d
operator|->
name|invalidateSortCache
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemParentChange
case|:
block|{
name|d
operator|->
name|invalidateSortCache
argument_list|()
expr_stmt|;
comment|// Handle ItemIgnoresTransformations
specifier|const
name|QGraphicsItem
modifier|*
name|newParent
init|=
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|bool
name|ignoredTransform
init|=
name|item
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
decl_stmt|;
name|bool
name|willIgnoreTransform
init|=
operator|(
name|item
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
operator|)
operator|||
operator|(
name|newParent
operator|&&
name|newParent
operator|->
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
operator|)
decl_stmt|;
name|bool
name|ancestorClippedChildren
init|=
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
decl_stmt|;
name|bool
name|ancestorWillClipChildren
init|=
name|newParent
operator|&&
operator|(
operator|(
name|newParent
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
operator|)
operator|||
operator|(
name|newParent
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|ignoredTransform
operator|!=
name|willIgnoreTransform
operator|)
operator|||
operator|(
name|ancestorClippedChildren
operator|!=
name|ancestorWillClipChildren
operator|)
condition|)
block|{
name|QGraphicsItem
modifier|*
name|thatItem
init|=
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|// Remove item and its descendants from the index and append
comment|// them to the list of unindexed items. Then, when the index
comment|// is updated, they will be put into the bsp-tree or the list
comment|// of untransformable items.
name|d
operator|->
name|removeItem
argument_list|(
name|thatItem
argument_list|,
comment|/*recursive=*/
literal|true
argument_list|,
comment|/*moveToUnidexedItems=*/
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp      Used to catch the timer event.      \internal */
end_comment
begin_function
DECL|function|event
name|bool
name|QGraphicsSceneBspTreeIndex
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSceneBspTreeIndex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Timer
case|:
if|if
condition|(
name|d
operator|->
name|indexTimerId
operator|&&
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|timerId
argument_list|()
operator|==
name|d
operator|->
name|indexTimerId
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|restartIndexTimer
condition|)
block|{
name|d
operator|->
name|restartIndexTimer
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// this call will kill the timer
name|d
operator|->
name|_q_updateIndex
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Fallthrough intended - support timers in subclasses.
default|default:
return|return
name|QObject
operator|::
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qgraphicsscenebsptreeindex_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GRAPHICSVIEW
end_comment
end_unit
