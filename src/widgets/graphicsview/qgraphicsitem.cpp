begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGraphicsItem     \brief The QGraphicsItem class is the base class for all graphical     items in a QGraphicsScene.     \since 4.2      \ingroup graphicsview-api     \inmodule QtWidgets      It provides a light-weight foundation for writing your own custom items.     This includes defining the item's geometry, collision detection, its     painting implementation and item interaction through its event handlers.     QGraphicsItem is part of the \l{Graphics View Framework}      \image graphicsview-items.png      For convenience, Qt provides a set of standard graphics items for the most     common shapes. These are:      \list     \li QGraphicsEllipseItem provides an ellipse item     \li QGraphicsLineItem provides a line item     \li QGraphicsPathItem provides an arbitrary path item     \li QGraphicsPixmapItem provides a pixmap item     \li QGraphicsPolygonItem provides a polygon item     \li QGraphicsRectItem provides a rectangular item     \li QGraphicsSimpleTextItem provides a simple text label item     \li QGraphicsTextItem provides an advanced text browser item     \endlist      All of an item's geometric information is based on its local coordinate     system. The item's position, pos(), is the only function that does not     operate in local coordinates, as it returns a position in parent     coordinates. \l {The Graphics View Coordinate System} describes the coordinate     system in detail.      You can set whether an item should be visible (i.e., drawn, and accepting     events), by calling setVisible(). Hiding an item will also hide its     children. Similarly, you can enable or disable an item by calling     setEnabled(). If you disable an item, all its children will also be     disabled. By default, items are both visible and enabled. To toggle     whether an item is selected or not, first enable selection by setting     the ItemIsSelectable flag, and then call setSelected(). Normally,     selection is toggled by the scene, as a result of user interaction.      To write your own graphics item, you first create a subclass of     QGraphicsItem, and then start by implementing its two pure virtual public     functions: boundingRect(), which returns an estimate of the area painted     by the item, and paint(), which implements the actual painting. For     example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 0      The boundingRect() function has many different purposes.     QGraphicsScene bases its item index on boundingRect(), and     QGraphicsView uses it both for culling invisible items, and for     determining the area that needs to be recomposed when drawing     overlapping items. In addition, QGraphicsItem's collision     detection mechanisms use boundingRect() to provide an efficient     cut-off. The fine grained collision algorithm in     collidesWithItem() is based on calling shape(), which returns an     accurate outline of the item's shape as a QPainterPath.      QGraphicsScene expects all items boundingRect() and shape() to     remain unchanged unless it is notified. If you want to change an     item's geometry in any way, you must first call     prepareGeometryChange() to allow QGraphicsScene to update its     bookkeeping.      Collision detection can be done in two ways:      \list 1      \li Reimplement shape() to return an accurate shape for your item,     and rely on the default implementation of collidesWithItem() to do     shape-shape intersection. This can be rather expensive if the     shapes are complex.      \li Reimplement collidesWithItem() to provide your own custom item     and shape collision algorithm.      \endlist      The contains() function can be called to determine whether the item \e     contains a point or not. This function can also be reimplemented by the     item. The default behavior of contains() is based on calling shape().      Items can contain other items, and also be contained by other items. All     items can have a parent item and a list of children. Unless the item has     no parent, its position is in \e parent coordinates (i.e., the parent's     local coordinates). Parent items propagate both their position and their     transformation to all children.      \img graphicsview-parentchild.png      \target Transformations     \section1 Transformations      QGraphicsItem supports projective transformations in addition to its base     position, pos(). There are several ways to change an item's transformation.     For simple transformations, you can call either of the convenience     functions setRotation() or setScale(), or you can pass any transformation     matrix to setTransform(). For advanced transformation control you also have     the option of setting several combined transformations by calling     setTransformations().      Item transformations accumulate from parent to child, so if both a parent     and child item are rotated 90 degrees, the child's total transformation     will be 180 degrees. Similarly, if the item's parent is scaled to 2x its     original size, its children will also be twice as large. An item's     transformation does not affect its own local geometry; all geometry     functions (e.g., contains(), update(), and all the mapping functions) still     operate in local coordinates. For convenience, QGraphicsItem provides the     functions sceneTransform(), which returns the item's total transformation     matrix (including its position and all parents' positions and     transformations), and scenePos(), which returns its position in scene     coordinates. To reset an item's matrix, call resetTransform().      Certain transformation operations produce a different outcome depending on     the order in which they are applied. For example, if you scale an     transform, and then rotate it, you may get a different result than if the     transform was rotated first. However, the order you set the transformation     properties on QGraphicsItem does not affect the resulting transformation;     QGraphicsItem always applies the properties in a fixed, defined order:      \list     \li The item's base transform is applied (transform())     \li The item's transformations list is applied in order (transformations())     \li The item is rotated relative to its transform origin point (rotation(), transformOriginPoint())     \li The item is scaled relative to its transform origin point (scale(), transformOriginPoint())     \endlist      \section1 Painting      The paint() function is called by QGraphicsView to paint the item's     contents. The item has no background or default fill of its own; whatever     is behind the item will shine through all areas that are not explicitly     painted in this function.  You can call update() to schedule a repaint,     optionally passing the rectangle that needs a repaint. Depending on     whether or not the item is visible in a view, the item may or may not be     repainted; there is no equivalent to QWidget::repaint() in QGraphicsItem.      Items are painted by the view, starting with the parent items and then     drawing children, in ascending stacking order. You can set an item's     stacking order by calling setZValue(), and test it by calling     zValue(), where items with low z-values are painted before items with     high z-values. Stacking order applies to sibling items; parents are always     drawn before their children.      \section1 Sorting      All items are drawn in a defined, stable order, and this same order decides     which items will receive mouse input first when you click on the scene.     Normally you don't have to worry about sorting, as the items follow a     "natural order", following the logical structure of the scene.      An item's children are stacked on top of the parent, and sibling items are     stacked by insertion order (i.e., in the same order that they were either     added to the scene, or added to the same parent). If you add item A, and     then B, then B will be on top of A. If you then add C, the items' stacking     order will be A, then B, then C.      \image graphicsview-zorder.png      This example shows the stacking order of all limbs of the robot from the     \l{graphicsview/dragdroprobot}{Drag and Drop Robot} example. The torso is     the root item (all other items are children or descendants of the torso),     so it is drawn first. Next, the head is drawn, as it is the first item in     the torso's list of children. Then the upper left arm is drawn. As the     lower arm is a child of the upper arm, the lower arm is then drawn,     followed by the upper arm's next sibling, which is the upper right arm, and     so on.      For advanced users, there are ways to alter how your items are sorted:      \list     \li You can call setZValue() on an item to explicitly stack it on top of, or     under, other sibling items. The default Z value for an item is 0. Items     with the same Z value are stacked by insertion order.      \li You can call stackBefore() to reorder the list of children. This will     directly modify the insertion order.      \li You can set the ItemStacksBehindParent flag to stack a child item behind     its parent.     \endlist      The stacking order of two sibling items also counts for each item's     children and descendant items. So if one item is on top of another, then     all its children will also be on top of all the other item's children as     well.      \section1 Events      QGraphicsItem receives events from QGraphicsScene through the virtual     function sceneEvent(). This function distributes the most common events     to a set of convenience event handlers:      \list     \li contextMenuEvent() handles context menu events     \li focusInEvent() and focusOutEvent() handle focus in and out events     \li hoverEnterEvent(), hoverMoveEvent(), and hoverLeaveEvent() handles     hover enter, move and leave events     \li inputMethodEvent() handles input events, for accessibility support     \li keyPressEvent() and keyReleaseEvent() handle key press and release events     \li mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), and     mouseDoubleClickEvent() handles mouse press, move, release, click and     doubleclick events     \endlist      You can filter events for any other item by installing event filters. This     functionality is separate from Qt's regular event filters (see     QObject::installEventFilter()), which only work on subclasses of QObject. After     installing your item as an event filter for another item by calling     installSceneEventFilter(), the filtered events will be received by the virtual     function sceneEventFilter(). You can remove item event filters by calling     removeSceneEventFilter().      \section1 Custom Data      Sometimes it's useful to register custom data with an item, be it a custom     item, or a standard item. You can call setData() on any item to store data     in it using a key-value pair (the key being an integer, and the value is a     QVariant). To get custom data from an item, call data(). This     functionality is completely untouched by Qt itself; it is provided for the     user's convenience.      \sa QGraphicsScene, QGraphicsView, {Graphics View Framework} */
end_comment
begin_comment
comment|/*!     \variable QGraphicsItem::Type      The type value returned by the virtual type() function in standard     graphics item classes in Qt. All such standard graphics item     classes in Qt are associated with a unique value for Type,     e.g. the value returned by QGraphicsPathItem::type() is 2.      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 18 */
end_comment
begin_comment
comment|/*!     \variable QGraphicsItem::UserType      The lowest permitted type value for custom items (subclasses     of QGraphicsItem or any of the standard items). This value is     used in conjunction with a reimplementation of QGraphicsItem::type()     and declaring a Type enum value. Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 1      \note UserType = 65536 */
end_comment
begin_comment
comment|/*!     \enum QGraphicsItem::GraphicsItemFlag      This enum describes different flags that you can set on an item to     toggle different features in the item's behavior.      All flags are disabled by default.      \value ItemIsMovable The item supports interactive movement using     the mouse. By clicking on the item and then dragging, the item     will move together with the mouse cursor. If the item has     children, all children are also moved. If the item is part of a     selection, all selected items are also moved. This feature is     provided as a convenience through the base implementation of     QGraphicsItem's mouse event handlers.      \value ItemIsSelectable The item supports selection. Enabling this     feature will enable setSelected() to toggle selection for the     item. It will also let the item be selected automatically as a     result of calling QGraphicsScene::setSelectionArea(), by clicking     on an item, or by using rubber band selection in QGraphicsView.      \value ItemIsFocusable The item supports keyboard input focus (i.e., it is     an input item). Enabling this flag will allow the item to accept focus,     which again allows the delivery of key events to     QGraphicsItem::keyPressEvent() and QGraphicsItem::keyReleaseEvent().      \value ItemClipsToShape The item clips to its own shape. The item cannot     draw or receive mouse, tablet, drag and drop or hover events outside its     shape. It is disabled by default. This behavior is enforced by     QGraphicsView::drawItems() or QGraphicsScene::drawItems(). This flag was     introduced in Qt 4.3.      \value ItemClipsChildrenToShape The item clips the painting of all its     descendants to its own shape. Items that are either direct or indirect     children of this item cannot draw outside this item's shape. By default,     this flag is disabled; children can draw anywhere. This behavior is     enforced by QGraphicsView::drawItems() or     QGraphicsScene::drawItems(). This flag was introduced in Qt 4.3.      \value ItemIgnoresTransformations The item ignores inherited     transformations (i.e., its position is still anchored to its parent, but     the parent or view rotation, zoom or shear transformations are ignored).     This flag is useful for keeping text label items horizontal and unscaled,     so they will still be readable if the view is transformed.  When set, the     item's view geometry and scene geometry will be maintained separately. You     must call deviceTransform() to map coordinates and detect collisions in     the view. By default, this flag is disabled. This flag was introduced in     Qt 4.3. \note With this flag set you can still scale the item itself, and     that scale transformation will influence the item's children.      \value ItemIgnoresParentOpacity The item ignores its parent's opacity. The     item's effective opacity is the same as its own; it does not combine with     the parent's opacity. This flags allows your item to keep its absolute     opacity even if the parent is semitransparent. This flag was introduced in     Qt 4.5.      \value ItemDoesntPropagateOpacityToChildren The item doesn't propagate its     opacity to its children. This flag allows you to create a semitransparent     item that does not affect the opacity of its children. This flag was     introduced in Qt 4.5.      \value ItemStacksBehindParent The item is stacked behind its parent. By     default, child items are stacked on top of the parent item. But setting     this flag, the child will be stacked behind it. This flag is useful for     drop shadow effects and for decoration objects that follow the parent     item's geometry without drawing on top of it. This flag was introduced     in Qt 4.5.      \value ItemUsesExtendedStyleOption The item makes use of either     \l{QStyleOptionGraphicsItem::} {exposedRect} or     \l{QStyleOptionGraphicsItem::} {matrix} in     QStyleOptionGraphicsItem. By default, the     \l{QStyleOptionGraphicsItem::} {exposedRect} is initialized to the     item's boundingRect() and the     \l{QStyleOptionGraphicsItem::}{matrix} is untransformed.  You can     enable this flag for the style options to be set up with more     fine-grained values.  Note that     QStyleOptionGraphicsItem::levelOfDetail is unaffected by this flag     and always initialized to 1. Use     QStyleOptionGraphicsItem::levelOfDetailFromTransform() if you need     a higher value. This flag was introduced in Qt 4.6.      \value ItemHasNoContents The item does not paint anything (i.e., calling     paint() on the item has no effect). You should set this flag on items that     do not need to be painted to ensure that Graphics View avoids unnecessary     painting preparations. This flag was introduced in Qt 4.6.      \value ItemSendsGeometryChanges The item enables itemChange()     notifications for ItemPositionChange, ItemPositionHasChanged,     ItemMatrixChange, ItemTransformChange, ItemTransformHasChanged,     ItemRotationChange, ItemRotationHasChanged, ItemScaleChange, ItemScaleHasChanged,     ItemTransformOriginPointChange, and ItemTransformOriginPointHasChanged. For     performance reasons, these notifications are disabled by default. You must     enable this flag to receive notifications for position and transform     changes. This flag was introduced in Qt 4.6.      \value ItemAcceptsInputMethod The item supports input methods typically     used for Asian languages.     This flag was introduced in Qt 4.6.      \value ItemNegativeZStacksBehindParent The item automatically     stacks behind it's parent if it's z-value is negative. This flag     enables setZValue() to toggle ItemStacksBehindParent. This flag     was introduced in Qt 4.6.      \value ItemIsPanel The item is a panel. A panel provides activation and     contained focus handling. Only one panel can be active at a time (see     QGraphicsItem::isActive()). When no panel is active, QGraphicsScene     activates all non-panel items. Window items (i.e.,     QGraphicsItem::isWindow() returns true) are panels. This flag was     introduced in Qt 4.6.      \omitvalue ItemIsFocusScope \omit Internal only (for now). \endomit      \value ItemSendsScenePositionChanges The item enables itemChange()     notifications for ItemScenePositionHasChanged. For performance reasons,     these notifications are disabled by default. You must enable this flag     to receive notifications for scene position changes. This flag was     introduced in Qt 4.6.      \omitvalue ItemStopsClickFocusPropagation \omit The item stops propagating     click focus to items underneath when being clicked on. This flag     allows you create a non-focusable item that can be clicked on without     changing the focus. \endomit      \omitvalue ItemStopsFocusHandling \omit Same as     ItemStopsClickFocusPropagation, but also suppresses focus-out. This flag     allows you to completely take over focus handling.     This flag was introduced in Qt 4.7. \endomit */
end_comment
begin_comment
comment|/*!     \enum QGraphicsItem::GraphicsItemChange      This enum describes the state changes that are notified by     QGraphicsItem::itemChange(). The notifications are sent as the state     changes, and in some cases, adjustments can be made (see the documentation     for each change for details).      Note: Be careful with calling functions on the QGraphicsItem itself inside     itemChange(), as certain function calls can lead to unwanted     recursion. For example, you cannot call setPos() in itemChange() on an     ItemPositionChange notification, as the setPos() function will again call     itemChange(ItemPositionChange). Instead, you can return the new, adjusted     position from itemChange().      \value ItemEnabledChange The item's enabled state changes. If the item is     presently enabled, it will become disabled, and vice verca. The value     argument is the new enabled state (i.e., true or false). Do not call     setEnabled() in itemChange() as this notification is delivered. Instead,     you can return the new state from itemChange().      \value ItemEnabledHasChanged The item's enabled state has changed. The     value argument is the new enabled state (i.e., true or false). Do not call     setEnabled() in itemChange() as this notification is delivered. The return     value is ignored.      \value ItemMatrixChange The item's affine transformation matrix is     changing. This value is obsolete; you can use ItemTransformChange instead.      \value ItemPositionChange The item's position changes. This notification     is sent if the ItemSendsGeometryChanges flag is enabled, and when the     item's local position changes, relative to its parent (i.e., as a result     of calling setPos() or moveBy()). The value argument is the new position     (i.e., a QPointF).  You can call pos() to get the original position. Do     not call setPos() or moveBy() in itemChange() as this notification is     delivered; instead, you can return the new, adjusted position from     itemChange(). After this notification, QGraphicsItem immediately sends the     ItemPositionHasChanged notification if the position changed.      \value ItemPositionHasChanged The item's position has changed. This     notification is sent if the ItemSendsGeometryChanges flag is enabled, and     after the item's local position, relative to its parent, has changed. The     value argument is the new position (the same as pos()), and QGraphicsItem     ignores the return value for this notification (i.e., a read-only     notification).      \value ItemTransformChange The item's transformation matrix changes. This     notification is send if the ItemSendsGeometryChanges flag is enabled, and     when the item's local transformation matrix changes (i.e., as a result of     calling setTransform(). The value argument is the new matrix (i.e., a     QTransform); to get the old matrix, call transform(). Do not call     setTransform() or set any of the transformation properties in itemChange()     as this notification is delivered; instead, you can return the new matrix     from itemChange().  This notification is not sent if you change the     transformation properties.      \value ItemTransformHasChanged The item's transformation matrix has     changed either because setTransform is called, or one of the     transformation properties is changed. This notification is sent if the     ItemSendsGeometryChanges flag is enabled, and after the item's local     transformation matrix has changed. The value argument is the new matrix     (same as transform()), and QGraphicsItem ignores the return value for this     notification (i.e., a read-only notification).      \value ItemRotationChange The item's rotation property changes. This     notification is sent if the ItemSendsGeometryChanges flag is enabled, and     when the item's rotation property changes (i.e., as a result of calling     setRotation()). The value argument is the new rotation (i.e., a double);     to get the old rotation, call rotation(). Do not call setRotation() in     itemChange() as this notification is delivered; instead, you can return     the new rotation from itemChange().      \value ItemRotationHasChanged The item's rotation property has changed.     This notification is sent if the ItemSendsGeometryChanges flag is enabled,     and after the item's rotation property has changed. The value argument is     the new rotation (i.e., a double), and QGraphicsItem ignores the return     value for this notification (i.e., a read-only notification). Do not call     setRotation() in itemChange() as this notification is delivered.      \value ItemScaleChange The item's scale property changes. This notification     is sent if the ItemSendsGeometryChanges flag is enabled, and when the item's     scale property changes (i.e., as a result of calling setScale()). The value     argument is the new scale (i.e., a double); to get the old scale, call     scale(). Do not call setScale() in itemChange() as this notification is     delivered; instead, you can return the new scale from itemChange().      \value ItemScaleHasChanged The item's scale property has changed. This     notification is sent if the ItemSendsGeometryChanges flag is enabled, and     after the item's scale property has changed. The value argument is the new     scale (i.e., a double), and QGraphicsItem ignores the return value for this     notification (i.e., a read-only notification). Do not call setScale() in     itemChange() as this notification is delivered.      \value ItemTransformOriginPointChange The item's transform origin point     property changes. This notification is sent if the ItemSendsGeometryChanges     flag is enabled, and when the item's transform origin point property changes     (i.e., as a result of calling setTransformOriginPoint()). The value argument     is the new origin point (i.e., a QPointF); to get the old origin point, call     transformOriginPoint(). Do not call setTransformOriginPoint() in itemChange()     as this notification is delivered; instead, you can return the new transform     origin point from itemChange().      \value ItemTransformOriginPointHasChanged The item's transform origin point     property has changed. This notification is sent if the ItemSendsGeometryChanges     flag is enabled, and after the item's transform origin point property has     changed. The value argument is the new origin point (i.e., a QPointF), and     QGraphicsItem ignores the return value for this notification (i.e., a read-only     notification). Do not call setTransformOriginPoint() in itemChange() as this     notification is delivered.      \value ItemSelectedChange The item's selected state changes. If the item is     presently selected, it will become unselected, and vice verca. The value     argument is the new selected state (i.e., true or false). Do not call     setSelected() in itemChange() as this notification is delivered; instead, you     can return the new selected state from itemChange().      \value ItemSelectedHasChanged The item's selected state has changed. The     value argument is the new selected state (i.e., true or false). Do not     call setSelected() in itemChange() as this notification is delivered. The     return value is ignored.      \value ItemVisibleChange The item's visible state changes. If the item is     presently visible, it will become invisible, and vice verca. The value     argument is the new visible state (i.e., true or false). Do not call     setVisible() in itemChange() as this notification is delivered; instead,     you can return the new visible state from itemChange().      \value ItemVisibleHasChanged The item's visible state has changed. The     value argument is the new visible state (i.e., true or false). Do not call     setVisible() in itemChange() as this notification is delivered. The return     value is ignored.      \value ItemParentChange The item's parent changes. The value argument is     the new parent item (i.e., a QGraphicsItem pointer).  Do not call     setParentItem() in itemChange() as this notification is delivered;     instead, you can return the new parent from itemChange().      \value ItemParentHasChanged The item's parent has changed. The value     argument is the new parent (i.e., a pointer to a QGraphicsItem). Do not     call setParentItem() in itemChange() as this notification is     delivered. The return value is ignored.      \value ItemChildAddedChange A child is added to this item. The value     argument is the new child item (i.e., a QGraphicsItem pointer). Do not     pass this item to any item's setParentItem() function as this notification     is delivered. The return value is unused; you cannot adjust anything in     this notification. Note that the new child might not be fully constructed     when this notification is sent; calling pure virtual functions on     the child can lead to a crash.      \value ItemChildRemovedChange A child is removed from this item. The value     argument is the child item that is about to be removed (i.e., a     QGraphicsItem pointer). The return value is unused; you cannot adjust     anything in this notification.      \value ItemSceneChange The item is moved to a new scene. This notification is     also sent when the item is added to its initial scene, and when it is removed.     The item's scene() is the old scene (or 0 if the item has not been added to a     scene yet). The value argument is the new scene (i.e., a QGraphicsScene     pointer), or a null pointer if the item is removed from a scene. Do not     override this change by passing this item to QGraphicsScene::addItem() as this     notification is delivered; instead, you can return the new scene from     itemChange(). Use this feature with caution; objecting to a scene change can     quickly lead to unwanted recursion.      \value ItemSceneHasChanged The item's scene has changed. The item's scene() is     the new scene. This notification is also sent when the item is added to its     initial scene, and when it is removed.The value argument is the new scene     (i.e., a pointer to a QGraphicsScene). Do not call setScene() in itemChange()     as this notification is delivered. The return value is ignored.      \value ItemCursorChange The item's cursor changes. The value argument is     the new cursor (i.e., a QCursor). Do not call setCursor() in itemChange()     as this notification is delivered. Instead, you can return a new cursor     from itemChange().      \value ItemCursorHasChanged The item's cursor has changed. The value     argument is the new cursor (i.e., a QCursor). Do not call setCursor() as     this notification is delivered. The return value is ignored.      \value ItemToolTipChange The item's tooltip changes. The value argument is     the new tooltip (i.e., a QToolTip). Do not call setToolTip() in     itemChange() as this notification is delivered. Instead, you can return a     new tooltip from itemChange().      \value ItemToolTipHasChanged The item's tooltip has changed. The value     argument is the new tooltip (i.e., a QToolTip). Do not call setToolTip()     as this notification is delivered. The return value is ignored.      \value ItemFlagsChange The item's flags change. The value argument is the     new flags (i.e., a quint32). Do not call setFlags() in itemChange() as     this notification is delivered. Instead, you can return the new flags from     itemChange().      \value ItemFlagsHaveChanged The item's flags have changed. The value     argument is the new flags (i.e., a quint32). Do not call setFlags() in     itemChange() as this notification is delivered. The return value is     ignored.      \value ItemZValueChange The item's Z-value changes. The value argument is     the new Z-value (i.e., a double). Do not call setZValue() in itemChange()     as this notification is delivered. Instead, you can return a new Z-value     from itemChange().      \value ItemZValueHasChanged The item's Z-value has changed. The value     argument is the new Z-value (i.e., a double). Do not call setZValue() as     this notification is delivered. The return value is ignored.      \value ItemOpacityChange The item's opacity changes. The value argument is     the new opacity (i.e., a double). Do not call setOpacity() in itemChange()     as this notification is delivered. Instead, you can return a new opacity     from itemChange().      \value ItemOpacityHasChanged The item's opacity has changed. The value     argument is the new opacity (i.e., a double). Do not call setOpacity() as     this notification is delivered. The return value is ignored.      \value ItemScenePositionHasChanged The item's scene position has changed.     This notification is sent if the ItemSendsScenePositionChanges flag is     enabled, and after the item's scene position has changed (i.e., the     position or transformation of the item itself or the position or     transformation of any ancestor has changed). The value argument is the     new scene position (the same as scenePos()), and QGraphicsItem ignores     the return value for this notification (i.e., a read-only notification). */
end_comment
begin_comment
comment|/*!     \enum QGraphicsItem::CacheMode     \since 4.4      This enum describes QGraphicsItem's cache modes. Caching is used to speed     up rendering by allocating and rendering to an off-screen pixel buffer,     which can be reused when the item requires redrawing. For some paint     devices, the cache is stored directly in graphics memory, which makes     rendering very quick.      \value NoCache The default; all item caching is     disabled. QGraphicsItem::paint() is called every time the item needs     redrawing.      \value ItemCoordinateCache Caching is enabled for the item's logical     (local) coordinate system. QGraphicsItem creates an off-screen pixel     buffer with a configurable size / resolution that you can pass to     QGraphicsItem::setCacheMode(). Rendering quality will typically degrade,     depending on the resolution of the cache and the item transformation.  The     first time the item is redrawn, it will render itself into the cache, and     the cache is then reused for every subsequent expose. The cache is also     reused as the item is transformed. To adjust the resolution of the cache,     you can call setCacheMode() again.      \value DeviceCoordinateCache Caching is enabled at the paint device level,     in device coordinates. This mode is for items that can move, but are not     rotated, scaled or sheared. If the item is transformed directly or     indirectly, the cache will be regenerated automatically. Unlike     ItemCoordinateCacheMode, DeviceCoordinateCache always renders at maximum     quality.      \sa QGraphicsItem::setCacheMode() */
end_comment
begin_comment
comment|/*!     \enum QGraphicsItem::Extension     \internal      Note: This is provided as a hook to avoid future problems related     to adding virtual functions. See also extension(),     supportsExtension() and setExtension(). */
end_comment
begin_comment
comment|/*!     \enum QGraphicsItem::PanelModality     \since 4.6      This enum specifies the behavior of a modal panel. A modal panel     is one that blocks input to other panels. Note that items that     are children of a modal panel are not blocked.      The values are:      \value NonModal The panel is not modal and does not block input to     other panels. This is the default value for panels.      \value PanelModal The panel is modal to a single item hierarchy     and blocks input to its parent pane, all grandparent panels, and     all siblings of its parent and grandparent panels.      \value SceneModal The window is modal to the entire scene and     blocks input to all panels.      \sa QGraphicsItem::setPanelModality(), QGraphicsItem::panelModality(), QGraphicsItem::ItemIsPanel */
end_comment
begin_include
include|#
directive|include
file|"qgraphicsitem.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_include
include|#
directive|include
file|"qgraphicsscene.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscene_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicssceneevent.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsview.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicswidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsproxywidget.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsscenebsptreeindex_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qpoint.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstack.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvariant.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qnumeric.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qbitmap.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainter.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpainterpath.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qevent.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qinputmethod.h>
end_include
begin_include
include|#
directive|include
file|<QtWidgets/qgraphicseffect.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_include
include|#
directive|include
file|"qaccessible.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qgraphicsitem_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicswidget_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidgettextcontrol_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextdocumentlayout_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_X11
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_x11_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qgesturemanager_p.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|_q_adjustRect
specifier|static
specifier|inline
name|void
name|_q_adjustRect
parameter_list|(
name|QRect
modifier|*
name|rect
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rect
operator|->
name|width
argument_list|()
condition|)
name|rect
operator|->
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rect
operator|->
name|height
argument_list|()
condition|)
name|rect
operator|->
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     ### Move this into QGraphicsItemPrivate  */
end_comment
begin_class
DECL|class|QGraphicsItemCustomDataStore
class|class
name|QGraphicsItemCustomDataStore
block|{
public|public:
DECL|member|data
name|QHash
argument_list|<
specifier|const
name|QGraphicsItem
modifier|*
argument_list|,
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
argument_list|>
name|data
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGraphicsItemCustomDataStore
argument_list|,
argument|qt_dataStore
argument_list|)
end_macro
begin_comment
comment|/*!     \internal      Returns a QPainterPath of \a path when stroked with the \a pen.     Ignoring dash pattern. */
end_comment
begin_function
DECL|function|qt_graphicsItem_shapeFromPath
specifier|static
name|QPainterPath
name|qt_graphicsItem_shapeFromPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
comment|// We unfortunately need this hack as QPainterPathStroker will set a width of 1.0
comment|// if we pass a value of 0.0 to QPainterPathStroker::setWidth()
specifier|const
name|qreal
name|penWidthZero
init|=
name|qreal
argument_list|(
literal|0.00000001
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|QPainterPath
argument_list|()
condition|)
return|return
name|path
return|;
name|QPainterPathStroker
name|ps
decl_stmt|;
name|ps
operator|.
name|setCapStyle
argument_list|(
name|pen
operator|.
name|capStyle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pen
operator|.
name|widthF
argument_list|()
operator|<=
literal|0.0
condition|)
name|ps
operator|.
name|setWidth
argument_list|(
name|penWidthZero
argument_list|)
expr_stmt|;
else|else
name|ps
operator|.
name|setWidth
argument_list|(
name|pen
operator|.
name|widthF
argument_list|()
argument_list|)
expr_stmt|;
name|ps
operator|.
name|setJoinStyle
argument_list|(
name|pen
operator|.
name|joinStyle
argument_list|()
argument_list|)
expr_stmt|;
name|ps
operator|.
name|setMiterLimit
argument_list|(
name|pen
operator|.
name|miterLimit
argument_list|()
argument_list|)
expr_stmt|;
name|QPainterPath
name|p
init|=
name|ps
operator|.
name|createStroke
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|p
operator|.
name|addPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Propagates the ancestor flag \a flag with value \a enabled to all this     item's children. If \a root is false, the flag is also set on this item     (default is true). */
end_comment
begin_function
DECL|function|updateAncestorFlag
name|void
name|QGraphicsItemPrivate
operator|::
name|updateAncestorFlag
parameter_list|(
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
name|childFlag
parameter_list|,
name|AncestorFlag
name|flag
parameter_list|,
name|bool
name|enabled
parameter_list|,
name|bool
name|root
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
condition|)
block|{
comment|// For root items only. This is the item that has either enabled or
comment|// disabled \a childFlag, or has been reparented.
switch|switch
condition|(
name|int
argument_list|(
name|childFlag
argument_list|)
condition|)
block|{
case|case
operator|-
literal|2
case|:
name|flag
operator|=
name|AncestorFiltersChildEvents
expr_stmt|;
name|enabled
operator|=
name|q
operator|->
name|filtersChildEvents
argument_list|()
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|flag
operator|=
name|AncestorHandlesChildEvents
expr_stmt|;
name|enabled
operator|=
name|q
operator|->
name|handlesChildEvents
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
case|:
name|flag
operator|=
name|AncestorClipsChildren
expr_stmt|;
name|enabled
operator|=
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
case|:
name|flag
operator|=
name|AncestorIgnoresTransformations
expr_stmt|;
name|enabled
operator|=
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|parent
condition|)
block|{
comment|// Inherit the enabled-state from our parents.
if|if
condition|(
operator|(
name|parent
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|flag
operator|)
operator|||
operator|(
name|int
argument_list|(
name|parent
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|childFlag
argument_list|)
operator|==
name|childFlag
operator|)
operator|||
operator|(
name|childFlag
operator|==
operator|-
literal|1
operator|&&
name|parent
operator|->
name|d_ptr
operator|->
name|handlesChildEvents
operator|)
operator|||
operator|(
name|childFlag
operator|==
operator|-
literal|2
operator|&&
name|parent
operator|->
name|d_ptr
operator|->
name|filtersDescendantEvents
operator|)
condition|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
name|ancestorFlags
operator||=
name|flag
expr_stmt|;
block|}
else|else
block|{
name|ancestorFlags
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Top-level root items don't have any ancestors, so there are no
comment|// ancestor flags either.
name|ancestorFlags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Don't set or propagate the ancestor flag if it's already correct.
if|if
condition|(
operator|(
operator|(
name|ancestorFlags
operator|&
name|flag
operator|)
operator|&&
name|enabled
operator|)
operator|||
operator|(
operator|!
operator|(
name|ancestorFlags
operator|&
name|flag
operator|)
operator|&&
operator|!
name|enabled
operator|)
condition|)
return|return;
comment|// Set the flag.
if|if
condition|(
name|enabled
condition|)
name|ancestorFlags
operator||=
name|flag
expr_stmt|;
else|else
name|ancestorFlags
operator|&=
operator|~
name|flag
expr_stmt|;
comment|// Don't process children if the item has the main flag set on itself.
if|if
condition|(
operator|(
name|childFlag
operator|!=
operator|-
literal|1
operator|&&
name|int
argument_list|(
name|flags
operator|&
name|childFlag
argument_list|)
operator|==
name|childFlag
operator|)
operator|||
operator|(
name|int
argument_list|(
name|childFlag
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|handlesChildEvents
operator|)
operator|||
operator|(
name|int
argument_list|(
name|childFlag
argument_list|)
operator|==
operator|-
literal|2
operator|&&
name|filtersDescendantEvents
operator|)
condition|)
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|updateAncestorFlag
argument_list|(
name|childFlag
argument_list|,
name|flag
argument_list|,
name|enabled
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateAncestorFlags
name|void
name|QGraphicsItemPrivate
operator|::
name|updateAncestorFlags
parameter_list|()
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|// Inherit the parent's ancestor flags.
name|QGraphicsItemPrivate
modifier|*
name|pd
init|=
name|parent
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|flags
operator|=
name|pd
operator|->
name|ancestorFlags
expr_stmt|;
comment|// Add in flags from the parent.
if|if
condition|(
name|pd
operator|->
name|filtersDescendantEvents
condition|)
name|flags
operator||=
name|AncestorFiltersChildEvents
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|handlesChildEvents
condition|)
name|flags
operator||=
name|AncestorHandlesChildEvents
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
condition|)
name|flags
operator||=
name|AncestorClipsChildren
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
condition|)
name|flags
operator||=
name|AncestorIgnoresTransformations
expr_stmt|;
block|}
if|if
condition|(
name|ancestorFlags
operator|==
name|flags
condition|)
return|return;
comment|// No change; stop propagation.
name|ancestorFlags
operator|=
name|flags
expr_stmt|;
comment|// Propagate to children recursively.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|updateAncestorFlags
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Propagates item group membership. */
end_comment
begin_function
DECL|function|setIsMemberOfGroup
name|void
name|QGraphicsItemPrivate
operator|::
name|setIsMemberOfGroup
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|isMemberOfGroup
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
operator|!
name|qgraphicsitem_cast
argument_list|<
name|QGraphicsItemGroup
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|child
decl|,
name|children
control|)
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|setIsMemberOfGroup
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Maps any item pos properties of \a event to \a item's coordinate system. */
end_comment
begin_function
DECL|function|remapItemPos
name|void
name|QGraphicsItemPrivate
operator|::
name|remapItemPos
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
block|{
name|QGraphicsSceneMouseEvent
modifier|*
name|mouseEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|mouseEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|mouseEvent
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mouseEvent
operator|->
name|setLastPos
argument_list|(
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|mouseEvent
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0x1
init|;
name|i
operator|<=
literal|0x10
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|mouseEvent
operator|->
name|buttons
argument_list|()
operator|&
name|i
condition|)
block|{
name|Qt
operator|::
name|MouseButton
name|button
init|=
name|Qt
operator|::
name|MouseButton
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|mouseEvent
operator|->
name|setButtonDownPos
argument_list|(
name|button
argument_list|,
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|mouseEvent
operator|->
name|buttonDownPos
argument_list|(
name|button
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|QEvent
operator|::
name|GraphicsSceneWheel
case|:
block|{
name|QGraphicsSceneWheelEvent
modifier|*
name|wheelEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneWheelEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|wheelEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|wheelEvent
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|GraphicsSceneContextMenu
case|:
block|{
name|QGraphicsSceneContextMenuEvent
modifier|*
name|contextEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|contextEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|contextEvent
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
block|{
name|QGraphicsSceneHoverEvent
modifier|*
name|hoverEvent
init|=
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|hoverEvent
operator|->
name|setPos
argument_list|(
name|item
operator|->
name|mapFromItem
argument_list|(
name|q
argument_list|,
name|hoverEvent
operator|->
name|pos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Maps the point \a pos from scene to item coordinates. If \a view is passed and the item     is untransformable, this function will correctly map \a pos from the scene using the     view's transformation. */
end_comment
begin_function
DECL|function|genericMapFromScene
name|QPointF
name|QGraphicsItemPrivate
operator|::
name|genericMapFromScene
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QWidget
modifier|*
name|viewport
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|itemIsUntransformable
argument_list|()
condition|)
return|return
name|q
operator|->
name|mapFromScene
argument_list|(
name|pos
argument_list|)
return|;
name|QGraphicsView
modifier|*
name|view
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|viewport
condition|)
name|view
operator|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|viewport
operator|->
name|parentWidget
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|view
condition|)
return|return
name|q
operator|->
name|mapFromScene
argument_list|(
name|pos
argument_list|)
return|;
comment|// ### More ping pong than needed.
return|return
name|q
operator|->
name|deviceTransform
argument_list|(
name|view
operator|->
name|viewportTransform
argument_list|()
argument_list|)
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|view
operator|->
name|mapFromScene
argument_list|(
name|pos
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Combines this item's position and transform onto \a transform.      If you need to change this function (e.g., adding more transformation     modes / options), make sure to change all places marked with COMBINE. */
end_comment
begin_function
DECL|function|combineTransformToParent
name|void
name|QGraphicsItemPrivate
operator|::
name|combineTransformToParent
parameter_list|(
name|QTransform
modifier|*
name|x
parameter_list|,
specifier|const
name|QTransform
modifier|*
name|viewTransform
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
name|viewTransform
operator|&&
name|itemIsUntransformable
argument_list|()
condition|)
block|{
operator|*
name|x
operator|=
name|q_ptr
operator|->
name|deviceTransform
argument_list|(
operator|*
name|viewTransform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|transformData
condition|)
operator|*
name|x
operator|*=
name|transformData
operator|->
name|computedFullTransform
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pos
operator|.
name|isNull
argument_list|()
condition|)
operator|*
name|x
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Combines this item's position and transform onto \a transform.      If you need to change this function (e.g., adding more transformation     modes / options), make sure to change QGraphicsItem::deviceTransform() as     well. */
end_comment
begin_function
DECL|function|combineTransformFromParent
name|void
name|QGraphicsItemPrivate
operator|::
name|combineTransformFromParent
parameter_list|(
name|QTransform
modifier|*
name|x
parameter_list|,
specifier|const
name|QTransform
modifier|*
name|viewTransform
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
name|viewTransform
operator|&&
name|itemIsUntransformable
argument_list|()
condition|)
block|{
operator|*
name|x
operator|=
name|q_ptr
operator|->
name|deviceTransform
argument_list|(
operator|*
name|viewTransform
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|->
name|translate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|transformData
condition|)
operator|*
name|x
operator|=
name|transformData
operator|->
name|computedFullTransform
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateSceneTransformFromParent
name|void
name|QGraphicsItemPrivate
operator|::
name|updateSceneTransformFromParent
parameter_list|()
block|{
if|if
condition|(
name|parent
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|parent
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
condition|)
block|{
name|sceneTransform
operator|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|parent
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
operator|+
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|parent
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
operator|+
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sceneTransform
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|sceneTransform
expr_stmt|;
name|sceneTransform
operator|.
name|translate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transformData
condition|)
block|{
name|sceneTransform
operator|=
name|transformData
operator|->
name|computedFullTransform
argument_list|(
operator|&
name|sceneTransform
argument_list|)
expr_stmt|;
name|sceneTransformTranslateOnly
operator|=
operator|(
name|sceneTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sceneTransformTranslateOnly
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|sceneTransformTranslateOnly
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|transformData
condition|)
block|{
name|sceneTransform
operator|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|sceneTransformTranslateOnly
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|transformData
operator|->
name|onlyTransform
condition|)
block|{
name|sceneTransform
operator|=
name|transformData
operator|->
name|transform
expr_stmt|;
if|if
condition|(
operator|!
name|pos
operator|.
name|isNull
argument_list|()
condition|)
name|sceneTransform
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|sceneTransformTranslateOnly
operator|=
operator|(
name|sceneTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|sceneTransform
operator|=
name|transformData
operator|->
name|computedFullTransform
argument_list|()
expr_stmt|;
name|sceneTransformTranslateOnly
operator|=
operator|(
name|sceneTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sceneTransform
operator|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|sceneTransform
operator|=
name|transformData
operator|->
name|computedFullTransform
argument_list|(
operator|&
name|sceneTransform
argument_list|)
expr_stmt|;
name|sceneTransformTranslateOnly
operator|=
operator|(
name|sceneTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
operator|)
expr_stmt|;
block|}
name|dirtySceneTransform
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Make sure not to trigger any pure virtual function calls (e.g.,     prepareGeometryChange) if the item is in its destructor, i.e.     inDestructor is 1. */
end_comment
begin_function
DECL|function|setParentItemHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setParentItemHelper
parameter_list|(
name|QGraphicsItem
modifier|*
name|newParent
parameter_list|,
specifier|const
name|QVariant
modifier|*
name|newParentVariant
parameter_list|,
specifier|const
name|QVariant
modifier|*
name|thisPointerVariant
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|newParent
operator|==
name|parent
condition|)
return|return;
if|if
condition|(
name|isWidget
condition|)
cast|static_cast
argument_list|<
name|QGraphicsWidgetPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|fixFocusChainBeforeReparenting
argument_list|(
operator|(
name|newParent
operator|&&
name|newParent
operator|->
name|isWidget
argument_list|()
operator|)
condition|?
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|newParent
argument_list|)
else|:
literal|0
argument_list|,
name|scene
argument_list|)
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
comment|// Deliver the change to the index
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|indexMethod
operator|!=
name|QGraphicsScene
operator|::
name|NoIndex
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|->
name|itemChange
argument_list|(
name|q
argument_list|,
name|QGraphicsItem
operator|::
name|ItemParentChange
argument_list|,
name|newParent
argument_list|)
expr_stmt|;
comment|// Disable scene pos notifications for old ancestors
if|if
condition|(
name|scenePosDescendants
operator|||
operator|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
operator|)
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|setScenePosItemEnabled
argument_list|(
name|q
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subFocusItem
operator|&&
name|parent
condition|)
block|{
comment|// Make sure none of the old parents point to this guy.
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|clearSubFocus
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// We anticipate geometry changes. If the item is deleted, it will be
comment|// removed from the index at a later stage, and the whole scene will be
comment|// updated.
if|if
condition|(
operator|!
name|inDestructor
condition|)
name|q_ptr
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|// Remove from current parent
name|parent
operator|->
name|d_ptr
operator|->
name|removeChild
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisPointerVariant
condition|)
name|parent
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemChildRemovedChange
argument_list|,
operator|*
name|thisPointerVariant
argument_list|)
expr_stmt|;
block|}
comment|// Update toplevelitem list. If this item is being deleted, its parent
comment|// will be 0 but we don't want to register/unregister it in the TLI list.
if|if
condition|(
name|scene
operator|&&
operator|!
name|inDestructor
condition|)
block|{
if|if
condition|(
name|parent
operator|&&
operator|!
name|newParent
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|registerTopLevelItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parent
operator|&&
name|newParent
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|unregisterTopLevelItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Ensure any last parent focus scope does not point to this item or any of
comment|// its descendents.
name|QGraphicsItem
modifier|*
name|p
init|=
name|parent
decl_stmt|;
name|QGraphicsItem
modifier|*
name|parentFocusScopeItem
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
comment|// If this item's focus scope's focus scope item points
comment|// to this item or a descendent, then clear it.
name|QGraphicsItem
modifier|*
name|fsi
init|=
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
decl_stmt|;
if|if
condition|(
name|q_ptr
operator|==
name|fsi
operator|||
name|q_ptr
operator|->
name|isAncestorOf
argument_list|(
name|fsi
argument_list|)
condition|)
block|{
name|parentFocusScopeItem
operator|=
name|fsi
expr_stmt|;
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|=
literal|0
expr_stmt|;
name|fsi
operator|->
name|d_ptr
operator|->
name|focusScopeItemChange
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
comment|// Update graphics effect optimization flag
if|if
condition|(
name|newParent
operator|&&
operator|(
name|graphicsEffect
operator|||
name|mayHaveChildWithGraphicsEffect
operator|)
condition|)
name|newParent
operator|->
name|d_ptr
operator|->
name|updateChildWithGraphicsEffectFlagRecursively
argument_list|()
expr_stmt|;
comment|// Update focus scope item ptr in new scope.
name|QGraphicsItem
modifier|*
name|newFocusScopeItem
init|=
name|subFocusItem
condition|?
name|subFocusItem
else|:
name|parentFocusScopeItem
decl_stmt|;
if|if
condition|(
name|newFocusScopeItem
operator|&&
name|newParent
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|newParent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
if|if
condition|(
name|subFocusItem
operator|&&
name|subFocusItem
operator|!=
name|q_ptr
condition|)
block|{
comment|// Find the subFocusItem's topmost focus scope within the new parent's focusscope
name|QGraphicsItem
modifier|*
name|ancestorScope
init|=
literal|0
decl_stmt|;
name|QGraphicsItem
modifier|*
name|p2
init|=
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|p2
operator|&&
name|p2
operator|!=
name|p
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
name|ancestorScope
operator|=
name|p2
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsPanel
condition|)
break|break;
if|if
condition|(
name|p2
operator|==
name|q_ptr
condition|)
break|break;
name|p2
operator|=
name|p2
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|ancestorScope
condition|)
name|newFocusScopeItem
operator|=
name|ancestorScope
expr_stmt|;
block|}
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|=
name|newFocusScopeItem
expr_stmt|;
name|newFocusScopeItem
operator|->
name|d_ptr
operator|->
name|focusScopeItemChange
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Ensure the new item is no longer the subFocusItem. The
comment|// only way to set focus on a child of a focus scope is
comment|// by setting focus on the scope itself.
if|if
condition|(
name|subFocusItem
operator|&&
operator|!
name|p
operator|->
name|focusItem
argument_list|()
condition|)
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|clearSubFocus
argument_list|()
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
block|}
comment|// Resolve depth.
name|invalidateDepthRecursively
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|parent
operator|=
name|newParent
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|!=
name|scene
condition|)
block|{
comment|// Move this item to its new parent's scene
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|->
name|addItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|scene
operator|&&
name|scene
condition|)
block|{
comment|// Remove this item from its former scene
name|scene
operator|->
name|removeItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|parent
operator|->
name|d_ptr
operator|->
name|addChild
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisPointerVariant
condition|)
name|parent
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemChildAddedChange
argument_list|,
operator|*
name|thisPointerVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
comment|// Re-enable scene pos notifications for new ancestors
if|if
condition|(
name|scenePosDescendants
operator|||
operator|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
operator|)
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|setScenePosItemEnabled
argument_list|(
name|q
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Propagate dirty flags to the new parent
name|markParentDirty
argument_list|(
comment|/*updateBoundingRect=*/
literal|true
argument_list|)
expr_stmt|;
comment|// Inherit ancestor flags from the new parent.
name|updateAncestorFlags
argument_list|()
expr_stmt|;
comment|// Update item visible / enabled.
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|visible
operator|!=
name|visible
condition|)
block|{
if|if
condition|(
operator|!
name|parent
operator|->
name|d_ptr
operator|->
name|visible
operator|||
operator|!
name|explicitlyHidden
condition|)
name|setVisibleHelper
argument_list|(
name|parent
operator|->
name|d_ptr
operator|->
name|visible
argument_list|,
comment|/* explicit = */
literal|false
argument_list|,
comment|/* update = */
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|->
name|isEnabled
argument_list|()
operator|!=
name|enabled
condition|)
block|{
if|if
condition|(
operator|!
name|parent
operator|->
name|d_ptr
operator|->
name|enabled
operator|||
operator|!
name|explicitlyDisabled
condition|)
name|setEnabledHelper
argument_list|(
name|parent
operator|->
name|d_ptr
operator|->
name|enabled
argument_list|,
comment|/* explicit = */
literal|false
argument_list|,
comment|/* update = */
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Auto-activate if visible and the parent is active.
if|if
condition|(
name|visible
operator|&&
name|parent
operator|->
name|isActive
argument_list|()
condition|)
name|q
operator|->
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Inherit ancestor flags from the new parent.
name|updateAncestorFlags
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inDestructor
condition|)
block|{
comment|// Update item visible / enabled.
if|if
condition|(
operator|!
name|visible
operator|&&
operator|!
name|explicitlyHidden
condition|)
name|setVisibleHelper
argument_list|(
literal|true
argument_list|,
comment|/* explicit = */
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
operator|&&
operator|!
name|explicitlyDisabled
condition|)
name|setEnabledHelper
argument_list|(
literal|true
argument_list|,
comment|/* explicit = */
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|inDestructor
operator|&&
operator|(
name|transformData
operator|||
operator|(
name|newParent
operator|&&
name|newParent
operator|->
name|d_ptr
operator|->
name|transformData
operator|)
operator|)
condition|)
name|transformChanged
argument_list|()
expr_stmt|;
comment|// Restore the sub focus chain.
if|if
condition|(
name|subFocusItem
condition|)
block|{
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|setSubFocus
argument_list|(
name|newParent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|isActive
argument_list|()
condition|)
name|subFocusItem
operator|->
name|setFocus
argument_list|()
expr_stmt|;
block|}
comment|// Deliver post-change notification
if|if
condition|(
name|newParentVariant
condition|)
name|q
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemParentHasChanged
argument_list|,
operator|*
name|newParentVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
operator|->
name|parentChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the bounding rect of this item's children (excluding itself). */
end_comment
begin_function
DECL|function|childrenBoundingRectHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|childrenBoundingRectHelper
parameter_list|(
name|QTransform
modifier|*
name|x
parameter_list|,
name|QRectF
modifier|*
name|rect
parameter_list|,
name|QGraphicsItem
modifier|*
name|topMostEffectItem
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|QRectF
name|childrenRect
decl_stmt|;
name|QRectF
modifier|*
name|result
init|=
name|rect
decl_stmt|;
name|rect
operator|=
operator|&
name|childrenRect
expr_stmt|;
specifier|const
name|bool
name|setTopMostEffectItem
init|=
operator|!
name|topMostEffectItem
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QGraphicsItemPrivate
modifier|*
name|childd
init|=
name|child
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|setTopMostEffectItem
condition|)
name|topMostEffectItem
operator|=
name|child
expr_stmt|;
name|bool
name|hasPos
init|=
operator|!
name|childd
operator|->
name|pos
operator|.
name|isNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasPos
operator|||
name|childd
operator|->
name|transformData
condition|)
block|{
comment|// COMBINE
name|QTransform
name|matrix
init|=
name|childd
operator|->
name|transformToParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
condition|)
name|matrix
operator|*=
operator|*
name|x
expr_stmt|;
operator|*
name|rect
operator||=
name|matrix
operator|.
name|mapRect
argument_list|(
name|child
operator|->
name|d_ptr
operator|->
name|effectiveBoundingRect
argument_list|(
name|topMostEffectItem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|childd
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|childd
operator|->
name|childrenBoundingRectHelper
argument_list|(
operator|&
name|matrix
argument_list|,
name|rect
argument_list|,
name|topMostEffectItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
condition|)
operator|*
name|rect
operator||=
name|x
operator|->
name|mapRect
argument_list|(
name|child
operator|->
name|d_ptr
operator|->
name|effectiveBoundingRect
argument_list|(
name|topMostEffectItem
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|rect
operator||=
name|child
operator|->
name|d_ptr
operator|->
name|effectiveBoundingRect
argument_list|(
name|topMostEffectItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|childd
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|childd
operator|->
name|childrenBoundingRectHelper
argument_list|(
name|x
argument_list|,
name|rect
argument_list|,
name|topMostEffectItem
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
condition|)
block|{
if|if
condition|(
name|x
condition|)
operator|*
name|rect
operator|&=
name|x
operator|->
name|mapRect
argument_list|(
name|q
operator|->
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
else|else
operator|*
name|rect
operator|&=
name|q
operator|->
name|boundingRect
argument_list|()
expr_stmt|;
block|}
operator|*
name|result
operator||=
operator|*
name|rect
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initStyleOption
name|void
name|QGraphicsItemPrivate
operator|::
name|initStyleOption
parameter_list|(
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|worldTransform
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|exposedRegion
parameter_list|,
name|bool
name|allItems
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// Initialize standard QStyleOption values.
specifier|const
name|QRectF
name|brect
init|=
name|q
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
name|option
operator|->
name|state
operator|=
name|QStyle
operator|::
name|State_None
expr_stmt|;
name|option
operator|->
name|rect
operator|=
name|brect
operator|.
name|toRect
argument_list|()
expr_stmt|;
name|option
operator|->
name|levelOfDetail
operator|=
literal|1
expr_stmt|;
name|option
operator|->
name|exposedRect
operator|=
name|brect
expr_stmt|;
if|if
condition|(
name|selected
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Selected
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Enabled
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|hasFocus
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_HasFocus
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|hoverItems
operator|.
name|contains
argument_list|(
name|q_ptr
argument_list|)
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_MouseOver
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|scene
operator|->
name|mouseGrabberItem
argument_list|()
condition|)
name|option
operator|->
name|state
operator||=
name|QStyle
operator|::
name|State_Sunken
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemUsesExtendedStyleOption
operator|)
condition|)
return|return;
comment|// Initialize QStyleOptionGraphicsItem specific values (matrix, exposedRect).
name|option
operator|->
name|matrix
operator|=
name|worldTransform
operator|.
name|toAffine
argument_list|()
expr_stmt|;
comment|//### discards perspective
if|if
condition|(
operator|!
name|allItems
condition|)
block|{
comment|// Determine the item's exposed area
name|option
operator|->
name|exposedRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
specifier|const
name|QTransform
name|reverseMap
init|=
name|worldTransform
operator|.
name|inverted
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|exposedRects
argument_list|(
name|exposedRegion
operator|.
name|rects
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exposedRects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|option
operator|->
name|exposedRect
operator||=
name|reverseMap
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
name|exposedRects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|exposedRect
operator|.
name|contains
argument_list|(
name|brect
argument_list|)
condition|)
break|break;
block|}
name|option
operator|->
name|exposedRect
operator|&=
name|brect
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Empty all cached pixmaps from the pixmap cache. */
end_comment
begin_function
DECL|function|purge
name|void
name|QGraphicsItemCache
operator|::
name|purge
parameter_list|()
block|{
name|QPixmapCache
operator|::
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|QPixmapCache
operator|::
name|Key
argument_list|()
expr_stmt|;
name|QMutableHashIterator
argument_list|<
name|QPaintDevice
modifier|*
argument_list|,
name|DeviceData
argument_list|>
name|it
argument_list|(
name|deviceData
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DeviceData
modifier|&
name|data
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|value
argument_list|()
decl_stmt|;
name|QPixmapCache
operator|::
name|remove
argument_list|(
name|data
operator|.
name|key
argument_list|)
expr_stmt|;
name|data
operator|.
name|cacheIndent
operator|=
name|QPoint
argument_list|()
expr_stmt|;
block|}
name|deviceData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|allExposed
operator|=
literal|true
expr_stmt|;
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QGraphicsItem with the given \a parent item.     It does not modify the parent object returned by QObject::parent().      If \a parent is 0, you can add the item to a scene by calling     QGraphicsScene::addItem(). The item will then become a top-level item.      \sa QGraphicsScene::addItem(), setParentItem() */
end_comment
begin_constructor
DECL|function|QGraphicsItem
name|QGraphicsItem
operator|::
name|QGraphicsItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QGraphicsItemPrivate
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|setParentItem
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|scene
operator|&&
name|parent
operator|&&
name|parent
operator|->
name|scene
argument_list|()
operator|!=
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::QGraphicsItem: ignoring scene (%p), which is"
literal|" different from parent's scene (%p)"
argument_list|,
name|scene
argument_list|,
name|parent
operator|->
name|scene
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scene
operator|&&
operator|!
name|parent
condition|)
name|scene
operator|->
name|addItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGraphicsItem
name|QGraphicsItem
operator|::
name|QGraphicsItem
parameter_list|(
name|QGraphicsItemPrivate
modifier|&
name|dd
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|setParentItem
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|scene
operator|&&
name|parent
operator|&&
name|parent
operator|->
name|scene
argument_list|()
operator|!=
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::QGraphicsItem: ignoring scene (%p), which is"
literal|" different from parent's scene (%p)"
argument_list|,
name|scene
argument_list|,
name|parent
operator|->
name|scene
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scene
operator|&&
operator|!
name|parent
condition|)
name|scene
operator|->
name|addItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsItem and all its children. If this item is currently     associated with a scene, the item will be removed from the scene before it     is deleted.      \note It is more efficient to remove the item from the QGraphicsScene before     destroying the item. */
end_comment
begin_destructor
DECL|function|~QGraphicsItem
name|QGraphicsItem
operator|::
name|~
name|QGraphicsItem
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|isObject
condition|)
block|{
name|QGraphicsObject
modifier|*
name|o
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QObjectPrivate
modifier|*
name|p
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|p
operator|->
name|wasDeleted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|declarativeData
condition|)
block|{
name|QAbstractDeclarativeData
operator|::
name|destroyed
argument_list|(
name|p
operator|->
name|declarativeData
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|p
operator|->
name|declarativeData
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|d_ptr
operator|->
name|inDestructor
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|removeExtraItemCache
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
if|if
condition|(
name|d_ptr
operator|->
name|isObject
operator|&&
operator|!
name|d_ptr
operator|->
name|gestureContext
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QGraphicsObject
modifier|*
name|o
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|QGestureManager
modifier|*
name|manager
init|=
name|QGestureManager
operator|::
name|instance
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|Qt
operator|::
name|GestureType
name|type
decl|,
name|d_ptr
operator|->
name|gestureContext
operator|.
name|keys
argument_list|()
control|)
name|manager
operator|->
name|cleanupCachedGestures
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|clearFocus
argument_list|()
expr_stmt|;
comment|// Update focus scope item ptr.
name|QGraphicsItem
modifier|*
name|p
init|=
name|d_ptr
operator|->
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|flags
argument_list|()
operator|&
name|ItemIsFocusScope
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|==
name|this
condition|)
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
while|while
condition|(
operator|!
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|d_ptr
operator|->
name|children
operator|.
name|first
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removeItemHelper
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_ptr
operator|->
name|resetFocusProxy
argument_list|()
expr_stmt|;
name|setParentItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
operator|delete
name|d_ptr
operator|->
name|graphicsEffect
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|d_ptr
operator|->
name|transformData
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d_ptr
operator|->
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsTransform
modifier|*
name|t
init|=
name|d_ptr
operator|->
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
cast|static_cast
argument_list|<
name|QGraphicsTransformPrivate
operator|*
argument_list|>
argument_list|(
name|t
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|)
operator|->
name|item
operator|=
literal|0
expr_stmt|;
operator|delete
name|t
expr_stmt|;
block|}
block|}
operator|delete
name|d_ptr
operator|->
name|transformData
expr_stmt|;
if|if
condition|(
name|QGraphicsItemCustomDataStore
modifier|*
name|dataStore
init|=
name|qt_dataStore
argument_list|()
condition|)
name|dataStore
operator|->
name|data
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the current scene for the item, or 0 if the item is not stored in     a scene.      To add or move an item to a scene, call QGraphicsScene::addItem(). */
end_comment
begin_function
DECL|function|scene
name|QGraphicsScene
modifier|*
name|QGraphicsItem
operator|::
name|scene
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|scene
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to this item's item group, or 0 if this item is not     member of a group.      \sa QGraphicsItemGroup, QGraphicsScene::createItemGroup() */
end_comment
begin_function
DECL|function|group
name|QGraphicsItemGroup
modifier|*
name|QGraphicsItem
operator|::
name|group
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|isMemberOfGroup
condition|)
return|return
literal|0
return|;
name|QGraphicsItem
modifier|*
name|parent
init|=
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|parent
operator|)
condition|)
block|{
if|if
condition|(
name|QGraphicsItemGroup
modifier|*
name|group
init|=
name|qgraphicsitem_cast
argument_list|<
name|QGraphicsItemGroup
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|group
return|;
block|}
comment|// Unreachable; if d_ptr->isMemberOfGroup is != 0, then one parent of this
comment|// item is a group item.
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Adds this item to the item group \a group. If \a group is 0, this item is     removed from any current group and added as a child of the previous     group's parent.      \sa group(), QGraphicsScene::createItemGroup() */
end_comment
begin_function
DECL|function|setGroup
name|void
name|QGraphicsItem
operator|::
name|setGroup
parameter_list|(
name|QGraphicsItemGroup
modifier|*
name|group
parameter_list|)
block|{
if|if
condition|(
operator|!
name|group
condition|)
block|{
if|if
condition|(
name|QGraphicsItemGroup
modifier|*
name|group
init|=
name|this
operator|->
name|group
argument_list|()
condition|)
name|group
operator|->
name|removeFromGroup
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|group
operator|->
name|addToGroup
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to this item's parent item. If this item does not have a     parent, 0 is returned.      \sa setParentItem(), childItems() */
end_comment
begin_function
DECL|function|parentItem
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|parentItem
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|parent
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this item's top-level item. The top-level item is the item's     topmost ancestor item whose parent is 0. If an item has no parent, its own     pointer is returned (i.e., a top-level item is its own top-level item).      \sa parentItem() */
end_comment
begin_function
DECL|function|topLevelItem
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|topLevelItem
parameter_list|()
specifier|const
block|{
name|QGraphicsItem
modifier|*
name|parent
init|=
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|QGraphicsItem
modifier|*
name|grandPa
init|=
name|parent
operator|->
name|parentItem
argument_list|()
condition|)
name|parent
operator|=
name|grandPa
expr_stmt|;
return|return
name|parent
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns a pointer to the item's parent, cast to a QGraphicsObject. returns 0 if the parent item     is not a QGraphicsObject.      \sa parentItem(), childItems() */
end_comment
begin_function
DECL|function|parentObject
name|QGraphicsObject
modifier|*
name|QGraphicsItem
operator|::
name|parentObject
parameter_list|()
specifier|const
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|d_ptr
operator|->
name|parent
decl_stmt|;
return|return
operator|(
name|p
operator|&&
name|p
operator|->
name|d_ptr
operator|->
name|isObject
operator|)
condition|?
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a pointer to the item's parent widget. The item's parent widget is     the closest parent item that is a widget.      \sa parentItem(), childItems() */
end_comment
begin_function
DECL|function|parentWidget
name|QGraphicsWidget
modifier|*
name|QGraphicsItem
operator|::
name|parentWidget
parameter_list|()
specifier|const
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|parentItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|&&
operator|!
name|p
operator|->
name|isWidget
argument_list|()
condition|)
name|p
operator|=
name|p
operator|->
name|parentItem
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|&&
name|p
operator|->
name|isWidget
argument_list|()
operator|)
condition|?
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a pointer to the item's top level widget (i.e., the item's     ancestor whose parent is 0, or whose parent is not a widget), or 0 if this     item does not have a top level widget. If the item is its own top level     widget, this function returns a pointer to the item itself. */
end_comment
begin_function
DECL|function|topLevelWidget
name|QGraphicsWidget
modifier|*
name|QGraphicsItem
operator|::
name|topLevelWidget
parameter_list|()
specifier|const
block|{
if|if
condition|(
specifier|const
name|QGraphicsWidget
modifier|*
name|p
init|=
name|parentWidget
argument_list|()
condition|)
return|return
name|p
operator|->
name|topLevelWidget
argument_list|()
return|;
return|return
name|isWidget
argument_list|()
condition|?
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the item's window, or 0 if this item does not have a window. If     the item is a window, it will return itself.  Otherwise it will return the     closest ancestor that is a window.      \sa QGraphicsWidget::isWindow() */
end_comment
begin_function
DECL|function|window
name|QGraphicsWidget
modifier|*
name|QGraphicsItem
operator|::
name|window
parameter_list|()
specifier|const
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|panel
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|isWindow
argument_list|()
condition|)
return|return
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the item's panel, or 0 if this item does not have a panel. If the     item is a panel, it will return itself. Otherwise it will return the     closest ancestor that is a panel.      \sa isPanel(), ItemIsPanel */
end_comment
begin_function
DECL|function|panel
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|panel
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemIsPanel
condition|)
return|return
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|parent
condition|?
name|d_ptr
operator|->
name|parent
operator|->
name|panel
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Return the graphics item cast to a QGraphicsObject, if the class is actually a   graphics object, 0 otherwise. */
end_comment
begin_function
DECL|function|toGraphicsObject
name|QGraphicsObject
modifier|*
name|QGraphicsItem
operator|::
name|toGraphicsObject
parameter_list|()
block|{
return|return
name|d_ptr
operator|->
name|isObject
condition|?
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Return the graphics item cast to a QGraphicsObject, if the class is actually a   graphics object, 0 otherwise. */
end_comment
begin_function
DECL|function|toGraphicsObject
specifier|const
name|QGraphicsObject
modifier|*
name|QGraphicsItem
operator|::
name|toGraphicsObject
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|isObject
condition|?
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   Sets this item's parent item to \a newParent. If this item already   has a parent, it is first removed from the previous parent. If \a   newParent is 0, this item will become a top-level item.    Note that this implicitly adds this graphics item to the scene of   the parent. You should not \l{QGraphicsScene::addItem()}{add} the   item to the scene yourself.    Calling this function on an item that is an ancestor of \a newParent   have undefined behaviour.    \sa parentItem(), childItems() */
end_comment
begin_function
DECL|function|setParentItem
name|void
name|QGraphicsItem
operator|::
name|setParentItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|newParent
parameter_list|)
block|{
if|if
condition|(
name|newParent
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::setParentItem: cannot assign %p as a parent of itself"
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|newParent
operator|==
name|d_ptr
operator|->
name|parent
condition|)
return|return;
specifier|const
name|QVariant
name|newParentVariant
argument_list|(
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemParentChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|newParent
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|newParent
operator|=
name|qvariant_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|newParentVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|newParent
operator|==
name|d_ptr
operator|->
name|parent
condition|)
return|return;
specifier|const
name|QVariant
name|thisPointerVariant
argument_list|(
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|setParentItemHelper
argument_list|(
name|newParent
argument_list|,
operator|&
name|newParentVariant
argument_list|,
operator|&
name|thisPointerVariant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use childItems() instead.      \sa setParentItem() */
end_comment
begin_function
DECL|function|children
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsItem
operator|::
name|children
parameter_list|()
specifier|const
block|{
return|return
name|childItems
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a list of this item's children.      The items are sorted by stacking order. This takes into account both the     items' insertion order and their Z-values.      \sa setParentItem(), zValue(), {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|childItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsItem
operator|::
name|childItems
parameter_list|()
specifier|const
block|{
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_ptr
operator|->
name|ensureSortedChildren
argument_list|()
expr_stmt|;
return|return
name|d_ptr
operator|->
name|children
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns true if this item is a widget (i.e., QGraphicsWidget); otherwise,     returns false. */
end_comment
begin_function
DECL|function|isWidget
name|bool
name|QGraphicsItem
operator|::
name|isWidget
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|isWidget
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns true if the item is a QGraphicsWidget window, otherwise returns     false.      \sa QGraphicsWidget::windowFlags() */
end_comment
begin_function
DECL|function|isWindow
name|bool
name|QGraphicsItem
operator|::
name|isWindow
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|isWidget
operator|&&
operator|(
cast|static_cast
argument_list|<
specifier|const
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|windowType
argument_list|()
operator|&
name|Qt
operator|::
name|Window
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns true if the item is a panel; otherwise returns false.      \sa QGraphicsItem::panel(), ItemIsPanel */
end_comment
begin_function
DECL|function|isPanel
name|bool
name|QGraphicsItem
operator|::
name|isPanel
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|flags
operator|&
name|ItemIsPanel
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this item's flags. The flags describe what configurable features     of the item are enabled and not. For example, if the flags include     ItemIsFocusable, the item can accept input focus.      By default, no flags are enabled.      \sa setFlags(), setFlag() */
end_comment
begin_function
DECL|function|flags
name|QGraphicsItem
operator|::
name|GraphicsItemFlags
name|QGraphicsItem
operator|::
name|flags
parameter_list|()
specifier|const
block|{
return|return
name|GraphicsItemFlags
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, the item flag \a flag is enabled; otherwise, it is     disabled.      \sa flags(), setFlags() */
end_comment
begin_function
DECL|function|setFlag
name|void
name|QGraphicsItem
operator|::
name|setFlag
parameter_list|(
name|GraphicsItemFlag
name|flag
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
name|setFlags
argument_list|(
name|GraphicsItemFlags
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
operator||
name|flag
argument_list|)
expr_stmt|;
else|else
name|setFlags
argument_list|(
name|GraphicsItemFlags
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
operator|&
operator|~
name|flag
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the flag \a flag on \a item and all its children, to \a enabled. */
end_comment
begin_function
DECL|function|_q_qgraphicsItemSetFlag
specifier|static
name|void
name|_q_qgraphicsItemSetFlag
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
name|flag
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|flag
condition|)
block|{
comment|// If this item already has the correct flag set, we don't have to
comment|// propagate it.
return|return;
block|}
name|item
operator|->
name|setFlag
argument_list|(
name|flag
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|child
decl|,
name|item
operator|->
name|children
argument_list|()
control|)
name|_q_qgraphicsItemSetFlag
argument_list|(
name|child
argument_list|,
name|flag
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the item flags to \a flags. All flags in \a flags are enabled; all     flags not in \a flags are disabled.      If the item had focus and \a flags does not enable ItemIsFocusable, the     item loses focus as a result of calling this function. Similarly, if the     item was selected, and \a flags does not enabled ItemIsSelectable, the     item is automatically unselected.      By default, no flags are enabled. (QGraphicsWidget enables the     ItemSendsGeometryChanges flag by default in order to track position     changes.)      \sa flags(), setFlag() */
end_comment
begin_function
DECL|function|setFlags
name|void
name|QGraphicsItem
operator|::
name|setFlags
parameter_list|(
name|GraphicsItemFlags
name|flags
parameter_list|)
block|{
comment|// Notify change and check for adjustment.
if|if
condition|(
name|quint32
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
operator|==
name|quint32
argument_list|(
name|flags
argument_list|)
condition|)
return|return;
name|flags
operator|=
name|GraphicsItemFlags
argument_list|(
name|itemChange
argument_list|(
name|ItemFlagsChange
argument_list|,
name|quint32
argument_list|(
name|flags
argument_list|)
argument_list|)
operator|.
name|toUInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|quint32
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
operator|==
name|quint32
argument_list|(
name|flags
argument_list|)
condition|)
return|return;
if|if
condition|(
name|d_ptr
operator|->
name|scene
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|indexMethod
operator|!=
name|QGraphicsScene
operator|::
name|NoIndex
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|->
name|itemChange
argument_list|(
name|this
argument_list|,
name|ItemFlagsChange
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|// Flags that alter the geometry of the item (or its children).
specifier|const
name|quint32
name|geomChangeFlagsMask
init|=
operator|(
name|ItemClipsChildrenToShape
operator||
name|ItemClipsToShape
operator||
name|ItemIgnoresTransformations
operator||
name|ItemIsSelectable
operator|)
decl_stmt|;
name|bool
name|fullUpdate
init|=
operator|(
name|quint32
argument_list|(
name|flags
argument_list|)
operator|&
name|geomChangeFlagsMask
operator|)
operator|!=
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|geomChangeFlagsMask
operator|)
decl_stmt|;
if|if
condition|(
name|fullUpdate
condition|)
name|d_ptr
operator|->
name|updatePaintedViewBoundingRects
argument_list|(
comment|/*children=*/
literal|true
argument_list|)
expr_stmt|;
comment|// Keep the old flags to compare the diff.
name|GraphicsItemFlags
name|oldFlags
init|=
name|GraphicsItemFlags
argument_list|(
name|d_ptr
operator|->
name|flags
argument_list|)
decl_stmt|;
comment|// Update flags.
name|d_ptr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemIsFocusable
operator|)
operator|&&
name|hasFocus
argument_list|()
condition|)
block|{
comment|// Clear focus on the item if it has focus when the focusable flag
comment|// is unset.
name|clearFocus
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemIsSelectable
operator|)
operator|&&
name|isSelected
argument_list|()
condition|)
block|{
comment|// Unselect the item if it is selected when the selectable flag is
comment|// unset.
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemClipsChildrenToShape
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemClipsChildrenToShape
operator|)
condition|)
block|{
comment|// Item children clipping changes. Propagate the ancestor flag to
comment|// all children.
name|d_ptr
operator|->
name|updateAncestorFlag
argument_list|(
name|ItemClipsChildrenToShape
argument_list|)
expr_stmt|;
comment|// The childrenBoundingRect is clipped to the boundingRect in case of ItemClipsChildrenToShape,
comment|// which means we have to invalidate the cached childrenBoundingRect whenever this flag changes.
name|d_ptr
operator|->
name|dirtyChildrenBoundingRect
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|markParentDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemIgnoresTransformations
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemIgnoresTransformations
operator|)
condition|)
block|{
comment|// Item children clipping changes. Propagate the ancestor flag to
comment|// all children.
name|d_ptr
operator|->
name|updateAncestorFlag
argument_list|(
name|ItemIgnoresTransformations
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemNegativeZStacksBehindParent
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemNegativeZStacksBehindParent
operator|)
condition|)
block|{
comment|// NB! We change the flags directly here, so we must also update d_ptr->flags.
comment|// Note that this has do be done before the ItemStacksBehindParent check
comment|// below; otherwise we will loose the change.
comment|// Update stack-behind.
if|if
condition|(
name|d_ptr
operator|->
name|z
operator|<
name|qreal
argument_list|(
literal|0.0
argument_list|)
condition|)
name|flags
operator||=
name|ItemStacksBehindParent
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|ItemStacksBehindParent
expr_stmt|;
name|d_ptr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemStacksBehindParent
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemStacksBehindParent
operator|)
condition|)
block|{
comment|// NB! This check has to come after the ItemNegativeZStacksBehindParent
comment|// check above. Be careful.
comment|// Ensure child item sorting is up to date when toggling this flag.
if|if
condition|(
name|d_ptr
operator|->
name|parent
condition|)
name|d_ptr
operator|->
name|parent
operator|->
name|d_ptr
operator|->
name|needSortChildren
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|needSortTopLevelItems
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemAcceptsInputMethod
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemAcceptsInputMethod
operator|)
condition|)
block|{
comment|// Update input method sensitivity in any views.
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|updateInputMethodSensitivityInViews
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d_ptr
operator|->
name|panelModality
operator|!=
name|NonModal
operator|)
operator|&&
name|d_ptr
operator|->
name|scene
operator|&&
operator|(
name|flags
operator|&
name|ItemIsPanel
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemIsPanel
operator|)
condition|)
block|{
comment|// update the panel's modal state
if|if
condition|(
name|flags
operator|&
name|ItemIsPanel
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enterModal
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|leaveModal
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|ItemSendsScenePositionChanges
operator|)
operator|!=
operator|(
name|oldFlags
operator|&
name|ItemSendsScenePositionChanges
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ItemSendsScenePositionChanges
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|registerScenePosItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|unregisterScenePosItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Notify change.
name|itemChange
argument_list|(
name|ItemFlagsHaveChanged
argument_list|,
name|quint32
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns the cache mode for this item. The default mode is NoCache (i.e.,     cache is disabled and all painting is immediate).      \sa setCacheMode() */
end_comment
begin_function
DECL|function|cacheMode
name|QGraphicsItem
operator|::
name|CacheMode
name|QGraphicsItem
operator|::
name|cacheMode
parameter_list|()
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|CacheMode
argument_list|(
name|d_ptr
operator|->
name|cacheMode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Sets the item's cache mode to \a mode.      The optional \a logicalCacheSize argument is used only by     ItemCoordinateCache mode, and describes the resolution of the cache     buffer; if \a logicalCacheSize is (100, 100), QGraphicsItem will fit the     item into 100x100 pixels in graphics memory, regardless of the logical     size of the item itself. By default QGraphicsItem uses the size of     boundingRect(). For all other cache modes than ItemCoordinateCache, \a     logicalCacheSize is ignored.      Caching can speed up rendering if your item spends a significant time     redrawing itself. In some cases the cache can also slow down rendering, in     particular when the item spends less time redrawing than QGraphicsItem     spends redrawing from the cache. When enabled, the item's paint() function     will be called only once for each call to update(); for any subsequent     repaint requests, the Graphics View framework will redraw from the     cache. This approach works particularly well with QGLWidget, which stores     all the cache as OpenGL textures.      Be aware that QPixmapCache's cache limit may need to be changed to obtain     optimal performance.      You can read more about the different cache modes in the CacheMode     documentation.      \sa CacheMode, QPixmapCache::setCacheLimit() */
end_comment
begin_function
DECL|function|setCacheMode
name|void
name|QGraphicsItem
operator|::
name|setCacheMode
parameter_list|(
name|CacheMode
name|mode
parameter_list|,
specifier|const
name|QSize
modifier|&
name|logicalCacheSize
parameter_list|)
block|{
name|CacheMode
name|lastMode
init|=
name|CacheMode
argument_list|(
name|d_ptr
operator|->
name|cacheMode
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|cacheMode
operator|=
name|mode
expr_stmt|;
name|bool
name|noVisualChange
init|=
operator|(
name|mode
operator|==
name|NoCache
operator|&&
name|lastMode
operator|==
name|NoCache
operator|)
operator|||
operator|(
name|mode
operator|==
name|NoCache
operator|&&
name|lastMode
operator|==
name|DeviceCoordinateCache
operator|)
operator|||
operator|(
name|mode
operator|==
name|DeviceCoordinateCache
operator|&&
name|lastMode
operator|==
name|NoCache
operator|)
operator|||
operator|(
name|mode
operator|==
name|DeviceCoordinateCache
operator|&&
name|lastMode
operator|==
name|DeviceCoordinateCache
operator|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|NoCache
condition|)
block|{
name|d_ptr
operator|->
name|removeExtraItemCache
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QGraphicsItemCache
modifier|*
name|cache
init|=
name|d_ptr
operator|->
name|extraItemCache
argument_list|()
decl_stmt|;
comment|// Reset old cache
name|cache
operator|->
name|purge
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ItemCoordinateCache
condition|)
block|{
if|if
condition|(
name|lastMode
operator|==
name|mode
operator|&&
name|cache
operator|->
name|fixedSize
operator|==
name|logicalCacheSize
condition|)
name|noVisualChange
operator|=
literal|true
expr_stmt|;
name|cache
operator|->
name|fixedSize
operator|=
name|logicalCacheSize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|noVisualChange
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the modality for this item. */
end_comment
begin_function
DECL|function|panelModality
name|QGraphicsItem
operator|::
name|PanelModality
name|QGraphicsItem
operator|::
name|panelModality
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|panelModality
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the modality for this item to \a panelModality.      Changing the modality of a visible item takes effect immediately. */
end_comment
begin_function
DECL|function|setPanelModality
name|void
name|QGraphicsItem
operator|::
name|setPanelModality
parameter_list|(
name|PanelModality
name|panelModality
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|panelModality
operator|==
name|panelModality
condition|)
return|return;
name|PanelModality
name|previousModality
init|=
name|d_ptr
operator|->
name|panelModality
decl_stmt|;
name|bool
name|enterLeaveModal
init|=
operator|(
name|isPanel
argument_list|()
operator|&&
name|d_ptr
operator|->
name|scene
operator|&&
name|isVisible
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|enterLeaveModal
operator|&&
name|panelModality
operator|==
name|NonModal
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|leaveModal
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|panelModality
operator|=
name|panelModality
expr_stmt|;
if|if
condition|(
name|enterLeaveModal
operator|&&
name|d_ptr
operator|->
name|panelModality
operator|!=
name|NonModal
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enterModal
argument_list|(
name|this
argument_list|,
name|previousModality
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns true if this item is blocked by a modal panel, false otherwise. If \a blockingPanel is     non-zero, \a blockingPanel will be set to the modal panel that is blocking this item. If this     item is not blocked, \a blockingPanel will not be set by this function.      This function always returns false for items not in a scene.      \sa panelModality(), setPanelModality(), PanelModality */
end_comment
begin_function
DECL|function|isBlockedByModalPanel
name|bool
name|QGraphicsItem
operator|::
name|isBlockedByModalPanel
parameter_list|(
name|QGraphicsItem
modifier|*
modifier|*
name|blockingPanel
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
return|return
literal|false
return|;
name|QGraphicsItem
modifier|*
name|dummy
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|blockingPanel
condition|)
name|blockingPanel
operator|=
operator|&
name|dummy
expr_stmt|;
name|QGraphicsScenePrivate
modifier|*
name|scene_d
init|=
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|scene_d
operator|->
name|modalPanels
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// ###
if|if
condition|(
operator|!
name|scene_d
operator|->
name|popupWidgets
operator|.
name|isEmpty
argument_list|()
operator|&&
name|scene_d
operator|->
name|popupWidgets
operator|.
name|first
argument_list|()
operator|==
name|this
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scene_d
operator|->
name|modalPanels
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|modalPanel
init|=
name|scene_d
operator|->
name|modalPanels
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|modalPanel
operator|->
name|panelModality
argument_list|()
operator|==
name|QGraphicsItem
operator|::
name|SceneModal
condition|)
block|{
comment|// Scene modal panels block all non-descendents.
if|if
condition|(
name|modalPanel
operator|!=
name|this
operator|&&
operator|!
name|modalPanel
operator|->
name|isAncestorOf
argument_list|(
name|this
argument_list|)
condition|)
block|{
operator|*
name|blockingPanel
operator|=
name|modalPanel
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|// Window modal panels block ancestors and siblings/cousins.
if|if
condition|(
name|modalPanel
operator|!=
name|this
operator|&&
operator|!
name|modalPanel
operator|->
name|isAncestorOf
argument_list|(
name|this
argument_list|)
operator|&&
name|commonAncestorItem
argument_list|(
name|modalPanel
argument_list|)
condition|)
block|{
operator|*
name|blockingPanel
operator|=
name|modalPanel
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TOOLTIP
end_ifndef
begin_comment
comment|/*!     Returns the item's tool tip, or an empty QString if no tool tip has been     set.      \sa setToolTip(), QToolTip */
end_comment
begin_function
DECL|function|toolTip
name|QString
name|QGraphicsItem
operator|::
name|toolTip
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|extra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraToolTip
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's tool tip to \a toolTip. If \a toolTip is empty, the item's     tool tip is cleared.      \sa toolTip(), QToolTip */
end_comment
begin_function
DECL|function|setToolTip
name|void
name|QGraphicsItem
operator|::
name|setToolTip
parameter_list|(
specifier|const
name|QString
modifier|&
name|toolTip
parameter_list|)
block|{
specifier|const
name|QVariant
name|toolTipVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemToolTipChange
argument_list|,
name|toolTip
argument_list|)
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|setExtra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraToolTip
argument_list|,
name|toolTipVariant
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|itemChange
argument_list|(
name|ItemToolTipHasChanged
argument_list|,
name|toolTipVariant
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TOOLTIP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_comment
comment|/*!     Returns the current cursor shape for the item. The mouse cursor     will assume this shape when it's over this item.     See the \l{Qt::CursorShape}{list of predefined cursor objects} for a     range of useful shapes.      An editor item might want to use an I-beam cursor:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 2      If no cursor has been set, the cursor of the item beneath is used.      \sa setCursor(), hasCursor(), unsetCursor(), QWidget::cursor,     QApplication::overrideCursor() */
end_comment
begin_function
DECL|function|cursor
name|QCursor
name|QGraphicsItem
operator|::
name|cursor
parameter_list|()
specifier|const
block|{
return|return
name|qvariant_cast
argument_list|<
name|QCursor
argument_list|>
argument_list|(
name|d_ptr
operator|->
name|extra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraCursor
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current cursor shape for the item to \a cursor. The mouse cursor     will assume this shape when it's over this item.     See the \l{Qt::CursorShape}{list of predefined cursor objects} for a     range of useful shapes.      An editor item might want to use an I-beam cursor:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 3      If no cursor has been set, the cursor of the item beneath is used.      \sa cursor(), hasCursor(), unsetCursor(), QWidget::cursor,     QApplication::overrideCursor() */
end_comment
begin_function
DECL|function|setCursor
name|void
name|QGraphicsItem
operator|::
name|setCursor
parameter_list|(
specifier|const
name|QCursor
modifier|&
name|cursor
parameter_list|)
block|{
specifier|const
name|QVariant
name|cursorVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemCursorChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QCursor
argument_list|>
argument_list|(
name|cursor
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|setExtra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraCursor
argument_list|,
name|qvariant_cast
argument_list|<
name|QCursor
argument_list|>
argument_list|(
name|cursorVariant
argument_list|)
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|hasCursor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsUseDefaultCursor
operator|=
literal|false
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|d_ptr
operator|->
name|scene
operator|->
name|views
argument_list|()
control|)
block|{
name|view
operator|->
name|viewport
argument_list|()
operator|->
name|setMouseTracking
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Note: Some of this logic is duplicated in QGraphicsView's mouse events.
if|if
condition|(
name|view
operator|->
name|underMouse
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|itemUnderCursor
decl|,
name|view
operator|->
name|items
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
argument_list|)
control|)
block|{
if|if
condition|(
name|itemUnderCursor
operator|->
name|hasCursor
argument_list|()
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|view
argument_list|,
literal|"_q_setViewportCursor"
argument_list|,
name|Q_ARG
argument_list|(
name|QCursor
argument_list|,
name|itemUnderCursor
operator|->
name|cursor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
block|}
block|}
name|itemChange
argument_list|(
name|ItemCursorHasChanged
argument_list|,
name|cursorVariant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item has a cursor set; otherwise, false is returned.      By default, items don't have any cursor set. cursor() will return a     standard pointing arrow cursor.      \sa unsetCursor() */
end_comment
begin_function
DECL|function|hasCursor
name|bool
name|QGraphicsItem
operator|::
name|hasCursor
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|hasCursor
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the cursor from this item.      \sa hasCursor(), setCursor() */
end_comment
begin_function
DECL|function|unsetCursor
name|void
name|QGraphicsItem
operator|::
name|unsetCursor
parameter_list|()
block|{
name|d_ptr
operator|->
name|unsetExtra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraCursor
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|hasCursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|d_ptr
operator|->
name|scene
operator|->
name|views
argument_list|()
control|)
block|{
if|if
condition|(
name|view
operator|->
name|underMouse
argument_list|()
operator|&&
name|view
operator|->
name|itemAt
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|QCursor
operator|::
name|pos
argument_list|()
argument_list|)
argument_list|)
operator|==
name|this
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|view
argument_list|,
literal|"_q_unsetViewportCursor"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CURSOR
end_comment
begin_comment
comment|/*!    Returns true if the item is visible; otherwise, false is returned.     Note that the item's general visibility is unrelated to whether or not it    is actually being visualized by a QGraphicsView.     \sa setVisible() */
end_comment
begin_function
DECL|function|isVisible
name|bool
name|QGraphicsItem
operator|::
name|isVisible
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|visible
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns true if the item is visible to \a parent; otherwise, false is     returned. \a parent can be 0, in which case this function will return     whether the item is visible to the scene or not.      An item may not be visible to its ancestors even if isVisible() is true. It     may also be visible to its ancestors even if isVisible() is false. If     any ancestor is hidden, the item itself will be implicitly hidden, in which     case this function will return false.      \sa isVisible(), setVisible() */
end_comment
begin_function
DECL|function|isVisibleTo
name|bool
name|QGraphicsItem
operator|::
name|isVisibleTo
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|parent
parameter_list|)
specifier|const
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|p
init|=
name|this
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|explicitlyHidden
condition|)
return|return
literal|false
return|;
do|do
block|{
if|if
condition|(
name|p
operator|==
name|parent
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|explicitlyHidden
condition|)
return|return
literal|false
return|;
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
operator|)
condition|)
do|;
return|return
name|parent
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets this item's visibility to \a newVisible. If \a explicitly is true,     this item will be "explicitly" \a newVisible; otherwise, it.. will not be. */
end_comment
begin_function
DECL|function|setVisibleHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setVisibleHelper
parameter_list|(
name|bool
name|newVisible
parameter_list|,
name|bool
name|explicitly
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// Update explicit bit.
if|if
condition|(
name|explicitly
condition|)
name|explicitlyHidden
operator|=
name|newVisible
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|// Check if there's nothing to do.
if|if
condition|(
name|visible
operator|==
name|quint32
argument_list|(
name|newVisible
argument_list|)
condition|)
return|return;
comment|// Don't show child if parent is not visible
if|if
condition|(
name|parent
operator|&&
name|newVisible
operator|&&
operator|!
name|parent
operator|->
name|d_ptr
operator|->
name|visible
condition|)
return|return;
comment|// Modify the property.
specifier|const
name|QVariant
name|newVisibleVariant
argument_list|(
name|q_ptr
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemVisibleChange
argument_list|,
name|quint32
argument_list|(
name|newVisible
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|newVisible
operator|=
name|newVisibleVariant
operator|.
name|toBool
argument_list|()
expr_stmt|;
if|if
condition|(
name|visible
operator|==
name|quint32
argument_list|(
name|newVisible
argument_list|)
condition|)
return|return;
name|visible
operator|=
name|newVisible
expr_stmt|;
comment|// Schedule redrawing
if|if
condition|(
name|update
condition|)
block|{
name|QGraphicsItemCache
modifier|*
name|c
init|=
operator|(
name|QGraphicsItemCache
operator|*
operator|)
name|qvariant_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|extra
argument_list|(
name|ExtraCacheData
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
name|c
operator|->
name|purge
argument_list|()
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|invalidateParentGraphicsEffectsRecursively
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|q_ptr
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|false
argument_list|,
comment|/*force=*/
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Certain properties are dropped as an item becomes invisible.
name|bool
name|hasFocus
init|=
name|q_ptr
operator|->
name|hasFocus
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|newVisible
condition|)
block|{
if|if
condition|(
name|scene
condition|)
block|{
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|mouseGrabberItems
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
name|q
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|keyboardGrabberItems
operator|.
name|contains
argument_list|(
name|q
argument_list|)
condition|)
name|q
operator|->
name|ungrabKeyboard
argument_list|()
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|isPanel
argument_list|()
operator|&&
name|panelModality
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|leaveModal
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasFocus
operator|&&
name|scene
condition|)
block|{
comment|// Hiding the closest non-panel ancestor of the focus item
name|QGraphicsItem
modifier|*
name|focusItem
init|=
name|scene
operator|->
name|focusItem
argument_list|()
decl_stmt|;
name|bool
name|clear
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|isWidget
operator|&&
operator|!
name|focusItem
operator|->
name|isPanel
argument_list|()
condition|)
block|{
do|do
block|{
if|if
condition|(
name|focusItem
operator|==
name|q_ptr
condition|)
block|{
name|clear
operator|=
operator|!
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|focusItem
operator|=
name|focusItem
operator|->
name|parentWidget
argument_list|()
operator|)
operator|&&
operator|!
name|focusItem
operator|->
name|isPanel
argument_list|()
condition|)
do|;
block|}
if|if
condition|(
name|clear
condition|)
name|clearFocusHelper
argument_list|(
comment|/* giveFocusToParent = */
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q_ptr
operator|->
name|isSelected
argument_list|()
condition|)
name|q_ptr
operator|->
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|geometryChanged
operator|=
literal|1
expr_stmt|;
name|paintedViewBoundingRectsNeedRepaint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
if|if
condition|(
name|isWidget
condition|)
block|{
name|QGraphicsWidget
modifier|*
name|widget
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|widget
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Popup
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|addPopup
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|isPanel
argument_list|()
operator|&&
name|panelModality
operator|!=
name|QGraphicsItem
operator|::
name|NonModal
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enterModal
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Update children with explicitly = false.
specifier|const
name|bool
name|updateChildren
init|=
name|update
operator|&&
operator|!
operator|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
operator|)
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|child
decl|,
name|children
control|)
block|{
if|if
condition|(
operator|!
name|newVisible
operator|||
operator|!
name|child
operator|->
name|d_ptr
operator|->
name|explicitlyHidden
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|setVisibleHelper
argument_list|(
name|newVisible
argument_list|,
literal|false
argument_list|,
name|updateChildren
argument_list|)
expr_stmt|;
block|}
comment|// Update activation
if|if
condition|(
name|scene
operator|&&
name|q
operator|->
name|isPanel
argument_list|()
condition|)
block|{
if|if
condition|(
name|newVisible
condition|)
block|{
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|isActive
argument_list|()
condition|)
name|q
operator|->
name|setActive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|isActive
argument_list|()
condition|)
name|scene
operator|->
name|setActivePanel
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Enable subfocus
if|if
condition|(
name|scene
condition|)
block|{
if|if
condition|(
name|newVisible
condition|)
block|{
comment|// Item is shown
name|QGraphicsItem
modifier|*
name|p
init|=
name|parent
decl_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
name|QGraphicsItem
modifier|*
name|fsi
init|=
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
decl_stmt|;
if|if
condition|(
name|q_ptr
operator|==
name|fsi
operator|||
name|q_ptr
operator|->
name|isAncestorOf
argument_list|(
name|fsi
argument_list|)
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|fsi
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|&&
name|fsi
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|->
name|isVisible
argument_list|()
condition|)
name|fsi
operator|=
name|fsi
operator|->
name|d_ptr
operator|->
name|focusScopeItem
expr_stmt|;
name|fsi
operator|->
name|d_ptr
operator|->
name|setFocusHelper
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|,
comment|/* climb = */
literal|true
argument_list|,
comment|/* focusFromHide = */
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|QGraphicsItem
modifier|*
name|fi
init|=
name|subFocusItem
decl_stmt|;
if|if
condition|(
name|fi
operator|&&
name|fi
operator|!=
name|scene
operator|->
name|focusItem
argument_list|()
condition|)
block|{
name|scene
operator|->
name|setFocusItem
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
operator|&&
operator|!
name|scene
operator|->
name|focusItem
argument_list|()
operator|&&
name|q
operator|->
name|isAncestorOf
argument_list|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|lastFocusItem
argument_list|)
condition|)
block|{
name|q_ptr
operator|->
name|setFocus
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Item is hidden
if|if
condition|(
name|hasFocus
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|visible
condition|)
block|{
name|p
operator|->
name|d_ptr
operator|->
name|setFocusHelper
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|,
comment|/* climb = */
literal|true
argument_list|,
comment|/* focusFromHide = */
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Deliver post-change notification.
name|q_ptr
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemVisibleHasChanged
argument_list|,
name|newVisibleVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|visibleChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     If \a visible is true, the item is made visible. Otherwise, the item is     made invisible. Invisible items are not painted, nor do they receive any     events. In particular, mouse events pass right through invisible items,     and are delivered to any item that may be behind. Invisible items are also     unselectable, they cannot take input focus, and are not detected by     QGraphicsScene's item location functions.      If an item becomes invisible while grabbing the mouse, (i.e., while it is     receiving mouse events,) it will automatically lose the mouse grab, and     the grab is not regained by making the item visible again; it must receive     a new mouse press to regain the mouse grab.      Similarly, an invisible item cannot have focus, so if the item has focus     when it becomes invisible, it will lose focus, and the focus is not     regained by simply making the item visible again.      If you hide a parent item, all its children will also be hidden. If you     show a parent item, all children will be shown, unless they have been     explicitly hidden (i.e., if you call setVisible(false) on a child, it will     not be reshown even if its parent is hidden, and then shown again).      Items are visible by default; it is unnecessary to call     setVisible() on a new item.      \sa isVisible(), show(), hide() */
end_comment
begin_function
DECL|function|setVisible
name|void
name|QGraphicsItem
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
name|d_ptr
operator|->
name|setVisibleHelper
argument_list|(
name|visible
argument_list|,
comment|/* explicit = */
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsItem::hide()      Hides the item. (Items are visible by default.)      This convenience function is equivalent to calling \c setVisible(false).      \sa show(), setVisible() */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsItem::show()      Shows the item. (Items are visible by default.)      This convenience function is equivalent to calling \c setVisible(true).      \sa hide(), setVisible() */
end_comment
begin_comment
comment|/*!     Returns true if the item is enabled; otherwise, false is returned.      \sa setEnabled() */
end_comment
begin_function
DECL|function|isEnabled
name|bool
name|QGraphicsItem
operator|::
name|isEnabled
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|enabled
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets this item's visibility to \a newEnabled. If \a explicitly is true,     this item will be "explicitly" \a newEnabled; otherwise, it.. will not be. */
end_comment
begin_function
DECL|function|setEnabledHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setEnabledHelper
parameter_list|(
name|bool
name|newEnabled
parameter_list|,
name|bool
name|explicitly
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
comment|// Update explicit bit.
if|if
condition|(
name|explicitly
condition|)
name|explicitlyDisabled
operator|=
name|newEnabled
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|// Check if there's nothing to do.
if|if
condition|(
name|enabled
operator|==
name|quint32
argument_list|(
name|newEnabled
argument_list|)
condition|)
return|return;
comment|// Certain properties are dropped when an item is disabled.
if|if
condition|(
operator|!
name|newEnabled
condition|)
block|{
if|if
condition|(
name|scene
operator|&&
name|scene
operator|->
name|mouseGrabberItem
argument_list|()
operator|==
name|q_ptr
condition|)
name|q_ptr
operator|->
name|ungrabMouse
argument_list|()
expr_stmt|;
if|if
condition|(
name|q_ptr
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
comment|// Disabling the closest non-panel ancestor of the focus item
comment|// causes focus to pop to the next item, otherwise it's cleared.
name|QGraphicsItem
modifier|*
name|focusItem
init|=
name|scene
operator|->
name|focusItem
argument_list|()
decl_stmt|;
name|bool
name|clear
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|isWidget
operator|&&
operator|!
name|focusItem
operator|->
name|isPanel
argument_list|()
operator|&&
name|q_ptr
operator|->
name|isAncestorOf
argument_list|(
name|focusItem
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|focusItem
operator|==
name|q_ptr
condition|)
block|{
name|clear
operator|=
operator|!
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|focusItem
operator|=
name|focusItem
operator|->
name|parentWidget
argument_list|()
operator|)
operator|&&
operator|!
name|focusItem
operator|->
name|isPanel
argument_list|()
condition|)
do|;
block|}
if|if
condition|(
name|clear
condition|)
name|q_ptr
operator|->
name|clearFocus
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|q_ptr
operator|->
name|isSelected
argument_list|()
condition|)
name|q_ptr
operator|->
name|setSelected
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Modify the property.
specifier|const
name|QVariant
name|newEnabledVariant
argument_list|(
name|q_ptr
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemEnabledChange
argument_list|,
name|quint32
argument_list|(
name|newEnabled
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|enabled
operator|=
name|newEnabledVariant
operator|.
name|toBool
argument_list|()
expr_stmt|;
comment|// Schedule redraw.
if|if
condition|(
name|update
condition|)
name|q_ptr
operator|->
name|update
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|child
decl|,
name|children
control|)
block|{
if|if
condition|(
operator|!
name|newEnabled
operator|||
operator|!
name|child
operator|->
name|d_ptr
operator|->
name|explicitlyDisabled
condition|)
name|child
operator|->
name|d_ptr
operator|->
name|setEnabledHelper
argument_list|(
name|newEnabled
argument_list|,
comment|/* explicitly = */
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Deliver post-change notification.
name|q_ptr
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemEnabledHasChanged
argument_list|,
name|newEnabledVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|enabledChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, the item is enabled; otherwise, it is disabled.      Disabled items are visible, but they do not receive any events, and cannot     take focus nor be selected. Mouse events are discarded; they are not     propagated unless the item is also invisible, or if it does not accept     mouse events (see acceptedMouseButtons()). A disabled item cannot become the     mouse grabber, and as a result of this, an item loses the grab if it     becomes disabled when grabbing the mouse, just like it loses focus if it     had focus when it was disabled.      Disabled items are traditionally drawn using grayed-out colors (see \l     QPalette::Disabled).      If you disable a parent item, all its children will also be disabled. If     you enable a parent item, all children will be enabled, unless they have     been explicitly disabled (i.e., if you call setEnabled(false) on a child,     it will not be reenabled if its parent is disabled, and then enabled     again).      Items are enabled by default.      \note If you install an event filter, you can still intercept events     before they are delivered to items; this mechanism disregards the item's     enabled state.      \sa isEnabled() */
end_comment
begin_function
DECL|function|setEnabled
name|void
name|QGraphicsItem
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|d_ptr
operator|->
name|setEnabledHelper
argument_list|(
name|enabled
argument_list|,
comment|/* explicitly = */
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item is selected; otherwise, false is returned.      Items that are in a group inherit the group's selected state.      Items are not selected by default.      \sa setSelected(), QGraphicsScene::setSelectionArea() */
end_comment
begin_function
DECL|function|isSelected
name|bool
name|QGraphicsItem
operator|::
name|isSelected
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QGraphicsItemGroup
modifier|*
name|group
init|=
name|this
operator|->
name|group
argument_list|()
condition|)
return|return
name|group
operator|->
name|isSelected
argument_list|()
return|;
return|return
name|d_ptr
operator|->
name|selected
return|;
block|}
end_function
begin_comment
comment|/*!     If \a selected is true and this item is selectable, this item is selected;     otherwise, it is unselected.      If the item is in a group, the whole group's selected state is toggled by     this function. If the group is selected, all items in the group are also     selected, and if the group is not selected, no item in the group is     selected.      Only visible, enabled, selectable items can be selected.  If \a selected     is true and this item is either invisible or disabled or unselectable,     this function does nothing.      By default, items cannot be selected. To enable selection, set the     ItemIsSelectable flag.      This function is provided for convenience, allowing individual toggling of     the selected state of an item. However, a more common way of selecting     items is to call QGraphicsScene::setSelectionArea(), which will call this     function for all visible, enabled, and selectable items within a specified     area on the scene.      \sa isSelected(), QGraphicsScene::selectedItems() */
end_comment
begin_function
DECL|function|setSelected
name|void
name|QGraphicsItem
operator|::
name|setSelected
parameter_list|(
name|bool
name|selected
parameter_list|)
block|{
if|if
condition|(
name|QGraphicsItemGroup
modifier|*
name|group
init|=
name|this
operator|->
name|group
argument_list|()
condition|)
block|{
name|group
operator|->
name|setSelected
argument_list|(
name|selected
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemIsSelectable
operator|)
operator|||
operator|!
name|d_ptr
operator|->
name|enabled
operator|||
operator|!
name|d_ptr
operator|->
name|visible
condition|)
name|selected
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|selected
operator|==
name|selected
condition|)
return|return;
specifier|const
name|QVariant
name|newSelectedVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemSelectedChange
argument_list|,
name|quint32
argument_list|(
name|selected
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|newSelected
init|=
name|newSelectedVariant
operator|.
name|toBool
argument_list|()
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|selected
operator|==
name|newSelected
condition|)
return|return;
name|d_ptr
operator|->
name|selected
operator|=
name|newSelected
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|QGraphicsScenePrivate
modifier|*
name|sceneD
init|=
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|selected
condition|)
block|{
name|sceneD
operator|->
name|selectedItems
operator|<<
name|this
expr_stmt|;
block|}
else|else
block|{
comment|// QGraphicsScene::selectedItems() lazily pulls out all items that are
comment|// no longer selected.
block|}
if|if
condition|(
operator|!
name|sceneD
operator|->
name|selectionChanging
condition|)
emit|emit
name|d_ptr
operator|->
name|scene
operator|->
name|selectionChanged
argument_list|()
emit|;
block|}
comment|// Deliver post-change notification.
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemSelectedHasChanged
argument_list|,
name|newSelectedVariant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns this item's local opacity, which is between 0.0 (transparent) and     1.0 (opaque). This value is combined with parent and ancestor values into     the effectiveOpacity(). The effective opacity decides how the item is     rendered.      The opacity property decides the state of the painter passed to the     paint() function. If the item is cached, i.e., ItemCoordinateCache or     DeviceCoordinateCache, the effective property will be applied to the item's     cache as it is rendered.      The default opacity is 1.0; fully opaque.      \sa setOpacity(), paint(), ItemIgnoresParentOpacity,     ItemDoesntPropagateOpacityToChildren */
end_comment
begin_function
DECL|function|opacity
name|qreal
name|QGraphicsItem
operator|::
name|opacity
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|opacity
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns this item's \e effective opacity, which is between 0.0     (transparent) and 1.0 (opaque). This value is a combination of this item's     local opacity, and its parent and ancestors' opacities. The effective     opacity decides how the item is rendered.      \sa opacity(), setOpacity(), paint(), ItemIgnoresParentOpacity,     ItemDoesntPropagateOpacityToChildren */
end_comment
begin_function
DECL|function|effectiveOpacity
name|qreal
name|QGraphicsItem
operator|::
name|effectiveOpacity
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|effectiveOpacity
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets this item's local \a opacity, between 0.0 (transparent) and 1.0     (opaque). The item's local opacity is combined with parent and ancestor     opacities into the effectiveOpacity().      By default, opacity propagates from parent to child, so if a parent's     opacity is 0.5 and the child is also 0.5, the child's effective opacity     will be 0.25.      The opacity property decides the state of the painter passed to the     paint() function. If the item is cached, i.e., ItemCoordinateCache or     DeviceCoordinateCache, the effective property will be applied to the     item's cache as it is rendered.      There are two item flags that affect how the item's opacity is combined     with the parent: ItemIgnoresParentOpacity and     ItemDoesntPropagateOpacityToChildren.      \sa opacity(), effectiveOpacity() */
end_comment
begin_function
DECL|function|setOpacity
name|void
name|QGraphicsItem
operator|::
name|setOpacity
parameter_list|(
name|qreal
name|opacity
parameter_list|)
block|{
comment|// Notify change.
specifier|const
name|QVariant
name|newOpacityVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemOpacityChange
argument_list|,
name|opacity
argument_list|)
argument_list|)
decl_stmt|;
comment|// Normalized opacity
name|qreal
name|newOpacity
init|=
name|qBound
argument_list|(
name|qreal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|newOpacityVariant
operator|.
name|toReal
argument_list|()
argument_list|,
name|qreal
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// No change? Done.
if|if
condition|(
name|newOpacity
operator|==
name|d_ptr
operator|->
name|opacity
condition|)
return|return;
name|bool
name|wasFullyTransparent
init|=
name|d_ptr
operator|->
name|isOpacityNull
argument_list|()
decl_stmt|;
name|d_ptr
operator|->
name|opacity
operator|=
name|newOpacity
expr_stmt|;
comment|// Notify change.
name|itemChange
argument_list|(
name|ItemOpacityHasChanged
argument_list|,
name|newOpacityVariant
argument_list|)
expr_stmt|;
comment|// Update.
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|d_ptr
operator|->
name|invalidateParentGraphicsEffectsRecursively
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemDoesntPropagateOpacityToChildren
operator|)
condition|)
name|d_ptr
operator|->
name|invalidateChildGraphicsEffectsRecursively
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|OpacityChanged
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|true
argument_list|,
comment|/*force=*/
literal|false
argument_list|,
comment|/*ignoreOpacity=*/
name|d_ptr
operator|->
name|isOpacityNull
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasFullyTransparent
condition|)
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|opacityChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to this item's effect if it has one; otherwise 0.      \since 4.6 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
end_ifndef
begin_function
DECL|function|graphicsEffect
name|QGraphicsEffect
modifier|*
name|QGraphicsItem
operator|::
name|graphicsEffect
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|graphicsEffect
return|;
block|}
end_function
begin_comment
comment|/*!     Sets \a effect as the item's effect. If there already is an effect installed     on this item, QGraphicsItem will delete the existing effect before installing     the new \a effect.      If \a effect is the installed on a different item, setGraphicsEffect() will remove     the effect from the item and install it on this item.      QGraphicsItem takes ownership of \a effect.      \note This function will apply the effect on itself and all its children.      \since 4.6 */
end_comment
begin_function
DECL|function|setGraphicsEffect
name|void
name|QGraphicsItem
operator|::
name|setGraphicsEffect
parameter_list|(
name|QGraphicsEffect
modifier|*
name|effect
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|graphicsEffect
operator|==
name|effect
condition|)
return|return;
if|if
condition|(
name|d_ptr
operator|->
name|graphicsEffect
condition|)
block|{
operator|delete
name|d_ptr
operator|->
name|graphicsEffect
expr_stmt|;
name|d_ptr
operator|->
name|graphicsEffect
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|parent
condition|)
block|{
name|d_ptr
operator|->
name|parent
operator|->
name|d_ptr
operator|->
name|updateChildWithGraphicsEffectFlagRecursively
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|effect
condition|)
block|{
comment|// Set new effect.
name|QGraphicsEffectSourcePrivate
modifier|*
name|sourced
init|=
operator|new
name|QGraphicsItemEffectSourcePrivate
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QGraphicsEffectSource
modifier|*
name|source
init|=
operator|new
name|QGraphicsEffectSource
argument_list|(
operator|*
name|sourced
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|graphicsEffect
operator|=
name|effect
expr_stmt|;
name|effect
operator|->
name|d_func
argument_list|()
operator|->
name|setGraphicsEffectSource
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSEFFECT
end_comment
begin_function
DECL|function|updateChildWithGraphicsEffectFlagRecursively
name|void
name|QGraphicsItemPrivate
operator|::
name|updateChildWithGraphicsEffectFlagRecursively
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|QGraphicsItemPrivate
modifier|*
name|itemPrivate
init|=
name|this
decl_stmt|;
do|do
block|{
comment|// parent chain already notified?
if|if
condition|(
name|itemPrivate
operator|->
name|mayHaveChildWithGraphicsEffect
condition|)
return|return;
name|itemPrivate
operator|->
name|mayHaveChildWithGraphicsEffect
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|itemPrivate
operator|=
name|itemPrivate
operator|->
name|parent
condition|?
name|itemPrivate
operator|->
name|parent
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
else|:
literal|0
operator|)
condition|)
do|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.6     Returns the effective bounding rect of the given item space rect.     If the item has no effect, the rect is returned unmodified.     If the item has an effect, the effective rect can be extend beyond the     item's bounding rect, depending on the effect.      \sa boundingRect() */
end_comment
begin_function
DECL|function|effectiveBoundingRect
name|QRectF
name|QGraphicsItemPrivate
operator|::
name|effectiveBoundingRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|QGraphicsEffect
modifier|*
name|effect
init|=
name|graphicsEffect
decl_stmt|;
if|if
condition|(
name|scene
operator|&&
name|effect
operator|&&
name|effect
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|views
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|effect
operator|->
name|boundingRectFor
argument_list|(
name|rect
argument_list|)
return|;
name|QRectF
name|sceneRect
init|=
name|q
operator|->
name|mapRectToScene
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|QRectF
name|sceneEffectRect
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|scene
operator|->
name|views
argument_list|()
control|)
block|{
name|QRectF
name|deviceRect
init|=
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|mapRectFromScene
argument_list|(
name|sceneRect
argument_list|)
decl_stmt|;
name|QRect
name|deviceEffectRect
init|=
name|effect
operator|->
name|boundingRectFor
argument_list|(
name|deviceRect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|sceneEffectRect
operator||=
name|view
operator|->
name|d_func
argument_list|()
operator|->
name|mapRectToScene
argument_list|(
name|deviceEffectRect
argument_list|)
expr_stmt|;
block|}
return|return
name|q
operator|->
name|mapRectFromScene
argument_list|(
name|sceneEffectRect
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
return|return
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.6     Returns the effective bounding rect of the item.     If the item has no effect, this is the same as the item's bounding rect.     If the item has an effect, the effective rect can be larger than the item's     bouding rect, depending on the effect.      \sa boundingRect() */
end_comment
begin_function
DECL|function|effectiveBoundingRect
name|QRectF
name|QGraphicsItemPrivate
operator|::
name|effectiveBoundingRect
parameter_list|(
name|QGraphicsItem
modifier|*
name|topMostEffectItem
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|Q_Q
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|QRectF
name|brect
init|=
name|effectiveBoundingRect
argument_list|(
name|q_ptr
operator|->
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|||
name|topMostEffectItem
operator|==
name|q
condition|)
return|return
name|brect
return|;
specifier|const
name|QGraphicsItem
modifier|*
name|effectParent
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|effectParent
condition|)
block|{
name|QGraphicsEffect
modifier|*
name|effect
init|=
name|effectParent
operator|->
name|d_ptr
operator|->
name|graphicsEffect
decl_stmt|;
if|if
condition|(
name|scene
operator|&&
name|effect
operator|&&
name|effect
operator|->
name|isEnabled
argument_list|()
condition|)
block|{
specifier|const
name|QRectF
name|brectInParentSpace
init|=
name|q
operator|->
name|mapRectToItem
argument_list|(
name|effectParent
argument_list|,
name|brect
argument_list|)
decl_stmt|;
specifier|const
name|QRectF
name|effectRectInParentSpace
init|=
name|effectParent
operator|->
name|d_ptr
operator|->
name|effectiveBoundingRect
argument_list|(
name|brectInParentSpace
argument_list|)
decl_stmt|;
name|brect
operator|=
name|effectParent
operator|->
name|mapRectToItem
argument_list|(
name|q
argument_list|,
name|effectRectInParentSpace
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|effectParent
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|||
name|topMostEffectItem
operator|==
name|effectParent
condition|)
block|{
return|return
name|brect
return|;
block|}
name|effectParent
operator|=
name|effectParent
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|brect
return|;
else|#
directive|else
comment|//QT_NO_GRAPHICSEFFECT
return|return
name|q_ptr
operator|->
name|boundingRect
argument_list|()
return|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.6     Returns the effective bounding rect of this item in scene coordinates,     by combining sceneTransform() with boundingRect(), taking into account     the effect that the item might have.      If the item has no effect, this is the same as sceneBoundingRect().      \sa effectiveBoundingRect(), sceneBoundingRect() */
end_comment
begin_function
DECL|function|sceneEffectiveBoundingRect
name|QRectF
name|QGraphicsItemPrivate
operator|::
name|sceneEffectiveBoundingRect
parameter_list|()
specifier|const
block|{
comment|// Find translate-only offset
comment|// COMBINE
name|QPointF
name|offset
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|parentItem
init|=
name|q_ptr
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
decl_stmt|;
do|do
block|{
name|itemd
operator|=
name|parentItem
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|itemd
operator|->
name|transformData
condition|)
break|break;
name|offset
operator|+=
name|itemd
operator|->
name|pos
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|parentItem
operator|=
name|itemd
operator|->
name|parent
operator|)
condition|)
do|;
name|QRectF
name|br
init|=
name|effectiveBoundingRect
argument_list|()
decl_stmt|;
name|br
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
operator|!
name|parentItem
condition|?
name|br
else|:
name|parentItem
operator|->
name|sceneTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|br
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    Returns true if this item can accept drag and drop events; otherwise,    returns false. By default, items do not accept drag and drop events; items    are transparent to drag and drop.     \sa setAcceptDrops() */
end_comment
begin_function
DECL|function|acceptDrops
name|bool
name|QGraphicsItem
operator|::
name|acceptDrops
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|acceptDrops
return|;
block|}
end_function
begin_comment
comment|/*!     If \a on is true, this item will accept drag and drop events; otherwise,     it is transparent for drag and drop events. By default, items do not     accept drag and drop events.      \sa acceptDrops() */
end_comment
begin_function
DECL|function|setAcceptDrops
name|void
name|QGraphicsItem
operator|::
name|setAcceptDrops
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
name|d_ptr
operator|->
name|acceptDrops
operator|=
name|on
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the mouse buttons that this item accepts mouse events for.  By     default, all mouse buttons are accepted.      If an item accepts a mouse button, it will become the mouse     grabber item when a mouse press event is delivered for that mouse     button. However, if the item does not accept the button,     QGraphicsScene will forward the mouse events to the first item     beneath it that does.      \sa setAcceptedMouseButtons(), mousePressEvent() */
end_comment
begin_function
DECL|function|acceptedMouseButtons
name|Qt
operator|::
name|MouseButtons
name|QGraphicsItem
operator|::
name|acceptedMouseButtons
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|MouseButtons
argument_list|(
name|d_ptr
operator|->
name|acceptedMouseButtons
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the mouse \a buttons that this item accepts mouse events for.      By default, all mouse buttons are accepted. If an item accepts a     mouse button, it will become the mouse grabber item when a mouse     press event is delivered for that button. However, if the item     does not accept the mouse button, QGraphicsScene will forward the     mouse events to the first item beneath it that does.      To disable mouse events for an item (i.e., make it transparent for mouse     events), call setAcceptedMouseButtons(0).      \sa acceptedMouseButtons(), mousePressEvent() */
end_comment
begin_function
DECL|function|setAcceptedMouseButtons
name|void
name|QGraphicsItem
operator|::
name|setAcceptedMouseButtons
parameter_list|(
name|Qt
operator|::
name|MouseButtons
name|buttons
parameter_list|)
block|{
if|if
condition|(
name|Qt
operator|::
name|MouseButtons
argument_list|(
name|d_ptr
operator|->
name|acceptedMouseButtons
argument_list|)
operator|!=
name|buttons
condition|)
block|{
if|if
condition|(
name|buttons
operator|==
literal|0
operator|&&
name|d_ptr
operator|->
name|scene
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|mouseGrabberItem
argument_list|()
operator|==
name|this
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|lastMouseGrabberItemHasImplicitMouseGrab
condition|)
block|{
name|ungrabMouse
argument_list|()
expr_stmt|;
block|}
name|d_ptr
operator|->
name|acceptedMouseButtons
operator|=
name|quint32
argument_list|(
name|buttons
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns true if an item accepts hover events     (QGraphicsSceneHoverEvent); otherwise, returns false. By default,     items do not accept hover events.      \sa setAcceptedMouseButtons() */
end_comment
begin_function
DECL|function|acceptHoverEvents
name|bool
name|QGraphicsItem
operator|::
name|acceptHoverEvents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|acceptsHover
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Call acceptHoverEvents() instead. */
end_comment
begin_function
DECL|function|acceptsHoverEvents
name|bool
name|QGraphicsItem
operator|::
name|acceptsHoverEvents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|acceptsHover
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      If \a enabled is true, this item will accept hover events;     otherwise, it will ignore them. By default, items do not accept     hover events.      Hover events are delivered when there is no current mouse grabber     item.  They are sent when the mouse cursor enters an item, when it     moves around inside the item, and when the cursor leaves an     item. Hover events are commonly used to highlight an item when     it's entered, and for tracking the mouse cursor as it hovers over     the item (equivalent to QWidget::mouseTracking).      Parent items receive hover enter events before their children, and     leave events after their children. The parent does not receive a     hover leave event if the cursor enters a child, though; the parent     stays "hovered" until the cursor leaves its area, including its     children's areas.      If a parent item handles child events, it will receive hover move,     drag move, and drop events as the cursor passes through its     children, but it does not receive hover enter and hover leave, nor     drag enter and drag leave events on behalf of its children.      A QGraphicsWidget with window decorations will accept hover events     regardless of the value of acceptHoverEvents().      \sa acceptHoverEvents(), hoverEnterEvent(), hoverMoveEvent(),     hoverLeaveEvent() */
end_comment
begin_function
DECL|function|setAcceptHoverEvents
name|void
name|QGraphicsItem
operator|::
name|setAcceptHoverEvents
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|acceptsHover
operator|==
name|quint32
argument_list|(
name|enabled
argument_list|)
condition|)
return|return;
name|d_ptr
operator|->
name|acceptsHover
operator|=
name|quint32
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|acceptsHover
operator|&&
name|d_ptr
operator|->
name|scene
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreHoverEvents
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enableMouseTrackingOnViews
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setAcceptHoverEvents(\a enabled) instead. */
end_comment
begin_function
DECL|function|setAcceptsHoverEvents
name|void
name|QGraphicsItem
operator|::
name|setAcceptsHoverEvents
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|setAcceptHoverEvents
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \since 4.6      Returns true if an item accepts \l{QTouchEvent}{touch events};     otherwise, returns false. By default, items do not accept touch events.      \sa setAcceptTouchEvents() */
end_comment
begin_function
DECL|function|acceptTouchEvents
name|bool
name|QGraphicsItem
operator|::
name|acceptTouchEvents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|acceptTouchEvents
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      If \a enabled is true, this item will accept \l{QTouchEvent}{touch events};     otherwise, it will ignore them. By default, items do not accept     touch events. */
end_comment
begin_function
DECL|function|setAcceptTouchEvents
name|void
name|QGraphicsItem
operator|::
name|setAcceptTouchEvents
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|acceptTouchEvents
operator|==
name|quint32
argument_list|(
name|enabled
argument_list|)
condition|)
return|return;
name|d_ptr
operator|->
name|acceptTouchEvents
operator|=
name|quint32
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|acceptTouchEvents
operator|&&
name|d_ptr
operator|->
name|scene
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreTouchEvents
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|allItemsIgnoreTouchEvents
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|enableTouchEventsOnViews
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns true if this item filters child events (i.e., all events     intended for any of its children are instead sent to this item);     otherwise, false is returned.      The default value is false; child events are not filtered.      \sa setFiltersChildEvents() */
end_comment
begin_function
DECL|function|filtersChildEvents
name|bool
name|QGraphicsItem
operator|::
name|filtersChildEvents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|filtersDescendantEvents
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      If \a enabled is true, this item is set to filter all events for     all its children (i.e., all events intented for any of its     children are instead sent to this item); otherwise, if \a enabled     is false, this item will only handle its own events. The default     value is false.      \sa filtersChildEvents() */
end_comment
begin_function
DECL|function|setFiltersChildEvents
name|void
name|QGraphicsItem
operator|::
name|setFiltersChildEvents
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|filtersDescendantEvents
operator|==
name|enabled
condition|)
return|return;
name|d_ptr
operator|->
name|filtersDescendantEvents
operator|=
name|enabled
expr_stmt|;
name|d_ptr
operator|->
name|updateAncestorFlag
argument_list|(
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns true if this item handles child events (i.e., all events     intended for any of its children are instead sent to this item);     otherwise, false is returned.      This property is useful for item groups; it allows one item to     handle events on behalf of its children, as opposed to its     children handling their events individually.      The default is to return false; children handle their own events.     The exception for this is if the item is a QGraphicsItemGroup, then     it defaults to return true.      \sa setHandlesChildEvents() */
end_comment
begin_function
DECL|function|handlesChildEvents
name|bool
name|QGraphicsItem
operator|::
name|handlesChildEvents
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|handlesChildEvents
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      If \a enabled is true, this item is set to handle all events for     all its children (i.e., all events intented for any of its     children are instead sent to this item); otherwise, if \a enabled     is false, this item will only handle its own events. The default     value is false.      This property is useful for item groups; it allows one item to     handle events on behalf of its children, as opposed to its     children handling their events individually.      If a child item accepts hover events, its parent will receive     hover move events as the cursor passes through the child, but it     does not receive hover enter and hover leave events on behalf of     its child.      \sa handlesChildEvents() */
end_comment
begin_function
DECL|function|setHandlesChildEvents
name|void
name|QGraphicsItem
operator|::
name|setHandlesChildEvents
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|handlesChildEvents
operator|==
name|enabled
condition|)
return|return;
name|d_ptr
operator|->
name|handlesChildEvents
operator|=
name|enabled
expr_stmt|;
name|d_ptr
operator|->
name|updateAncestorFlag
argument_list|(
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns true if this item is active; otherwise returns false.      An item can only be active if the scene is active. An item is active     if it is, or is a descendent of, an active panel. Items in non-active     panels are not active.      Items that are not part of a panel follow scene activation when the     scene has no active panel.      Only active items can gain input focus.      \sa QGraphicsScene::isActive(), QGraphicsScene::activePanel(), panel(), isPanel() */
end_comment
begin_function
DECL|function|isActive
name|bool
name|QGraphicsItem
operator|::
name|isActive
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
operator|||
operator|!
name|d_ptr
operator|->
name|scene
operator|->
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|panel
argument_list|()
operator|==
name|d_ptr
operator|->
name|scene
operator|->
name|activePanel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      If \a active is true, and the scene is active, this item's panel will be     activated. Otherwise, the panel is deactivated.      If the item is not part of an active scene, \a active will decide what     happens to the panel when the scene becomes active or the item is added to     the scene. If true, the item's panel will be activated when the item is     either added to the scene or the scene is activated. Otherwise, the item     will stay inactive independent of the scene's activated state.      \sa isPanel(), QGraphicsScene::setActivePanel(), QGraphicsScene::isActive() */
end_comment
begin_function
DECL|function|setActive
name|void
name|QGraphicsItem
operator|::
name|setActive
parameter_list|(
name|bool
name|active
parameter_list|)
block|{
name|d_ptr
operator|->
name|explicitActivate
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|wantsActive
operator|=
name|active
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
if|if
condition|(
name|active
condition|)
block|{
comment|// Activate this item.
name|d_ptr
operator|->
name|scene
operator|->
name|setActivePanel
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Deactivate this item, and reactivate the last active item
comment|// (if any).
name|QGraphicsItem
modifier|*
name|lastActive
init|=
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|lastActivePanel
decl_stmt|;
name|d_ptr
operator|->
name|scene
operator|->
name|setActivePanel
argument_list|(
name|lastActive
operator|!=
name|this
condition|?
name|lastActive
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if this item is active, and it or its \l{focusProxy()}{focus     proxy} has keyboard input focus; otherwise, returns false.      \sa focusItem(), setFocus(), QGraphicsScene::setFocusItem(), isActive() */
end_comment
begin_function
DECL|function|hasFocus
name|bool
name|QGraphicsItem
operator|::
name|hasFocus
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
operator|||
operator|!
name|d_ptr
operator|->
name|scene
operator|->
name|isActive
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d_ptr
operator|->
name|focusProxy
condition|)
return|return
name|d_ptr
operator|->
name|focusProxy
operator|->
name|hasFocus
argument_list|()
return|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|focusItem
operator|!=
name|this
condition|)
return|return
literal|false
return|;
return|return
name|panel
argument_list|()
operator|==
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|activePanel
return|;
block|}
end_function
begin_comment
comment|/*!     Gives keyboard input focus to this item. The \a focusReason argument will     be passed into any \l{QFocusEvent}{focus event} generated by this function;     it is used to give an explanation of what caused the item to get focus.      Only enabled items that set the ItemIsFocusable flag can accept keyboard     focus.      If this item is not visible, not active, or not associated with a scene,     it will not gain immediate input focus. However, it will be registered as     the preferred focus item for its subtree of items, should it later become     visible.      As a result of calling this function, this item will receive a     \l{focusInEvent()}{focus in event} with \a focusReason. If another item     already has focus, that item will first receive a \l{focusOutEvent()}     {focus out event} indicating that it has lost input focus.      \sa clearFocus(), hasFocus(), focusItem(), focusProxy() */
end_comment
begin_function
DECL|function|setFocus
name|void
name|QGraphicsItem
operator|::
name|setFocus
parameter_list|(
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|)
block|{
name|d_ptr
operator|->
name|setFocusHelper
argument_list|(
name|focusReason
argument_list|,
comment|/* climb = */
literal|true
argument_list|,
comment|/* focusFromHide = */
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setFocusHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setFocusHelper
parameter_list|(
name|Qt
operator|::
name|FocusReason
name|focusReason
parameter_list|,
name|bool
name|climb
parameter_list|,
name|bool
name|focusFromHide
parameter_list|)
block|{
comment|// Disabled / unfocusable items cannot accept focus.
if|if
condition|(
operator|!
name|q_ptr
operator|->
name|isEnabled
argument_list|()
operator|||
operator|!
operator|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator|)
condition|)
return|return;
comment|// Find focus proxy.
name|QGraphicsItem
modifier|*
name|f
init|=
name|q_ptr
decl_stmt|;
while|while
condition|(
name|f
operator|->
name|d_ptr
operator|->
name|focusProxy
condition|)
name|f
operator|=
name|f
operator|->
name|d_ptr
operator|->
name|focusProxy
expr_stmt|;
comment|// Return if it already has focus.
if|if
condition|(
name|scene
operator|&&
name|scene
operator|->
name|focusItem
argument_list|()
operator|==
name|f
condition|)
return|return;
comment|// Update focus scope item ptr.
name|QGraphicsItem
modifier|*
name|p
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
name|QGraphicsItem
modifier|*
name|oldFocusScopeItem
init|=
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
decl_stmt|;
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|=
name|q_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|focusItem
argument_list|()
operator|&&
operator|!
name|focusFromHide
condition|)
block|{
if|if
condition|(
name|oldFocusScopeItem
condition|)
name|oldFocusScopeItem
operator|->
name|d_ptr
operator|->
name|focusScopeItemChange
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|focusScopeItemChange
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// If you call setFocus on a child of a focus scope that
comment|// doesn't currently have a focus item, then stop.
return|return;
block|}
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|climb
condition|)
block|{
while|while
condition|(
name|f
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|&&
name|f
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|->
name|isVisible
argument_list|()
condition|)
name|f
operator|=
name|f
operator|->
name|d_ptr
operator|->
name|focusScopeItem
expr_stmt|;
block|}
comment|// Update the child focus chain.
name|QGraphicsItem
modifier|*
name|commonAncestor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|scene
operator|&&
name|scene
operator|->
name|focusItem
argument_list|()
condition|)
block|{
name|commonAncestor
operator|=
name|scene
operator|->
name|focusItem
argument_list|()
operator|->
name|commonAncestorItem
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|scene
operator|->
name|focusItem
argument_list|()
operator|->
name|d_ptr
operator|->
name|clearSubFocus
argument_list|(
name|scene
operator|->
name|focusItem
argument_list|()
argument_list|,
name|commonAncestor
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|d_ptr
operator|->
name|setSubFocus
argument_list|(
name|f
argument_list|,
name|commonAncestor
argument_list|)
expr_stmt|;
comment|// Update the scene's focus item.
if|if
condition|(
name|scene
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|q_ptr
operator|->
name|panel
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|p
operator|&&
name|scene
operator|->
name|isActive
argument_list|()
operator|)
operator|||
operator|(
name|p
operator|&&
name|p
operator|->
name|isActive
argument_list|()
operator|)
condition|)
block|{
comment|// Visible items immediately gain focus from scene.
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|setFocusItemHelper
argument_list|(
name|f
argument_list|,
name|focusReason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Takes keyboard input focus from the item.      If it has focus, a \l{focusOutEvent()}{focus out event} is sent to this     item to tell it that it is about to lose the focus.      Only items that set the ItemIsFocusable flag, or widgets that set an     appropriate focus policy, can accept keyboard focus.      \sa setFocus(), hasFocus(), QGraphicsWidget::focusPolicy */
end_comment
begin_function
DECL|function|clearFocus
name|void
name|QGraphicsItem
operator|::
name|clearFocus
parameter_list|()
block|{
name|d_ptr
operator|->
name|clearFocusHelper
argument_list|(
comment|/* giveFocusToParent = */
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|clearFocusHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|clearFocusHelper
parameter_list|(
name|bool
name|giveFocusToParent
parameter_list|)
block|{
if|if
condition|(
name|giveFocusToParent
condition|)
block|{
comment|// Pass focus to the closest parent focus scope
if|if
condition|(
operator|!
name|inDestructor
condition|)
block|{
name|QGraphicsItem
modifier|*
name|p
init|=
name|parent
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|==
name|q_ptr
condition|)
block|{
name|p
operator|->
name|d_ptr
operator|->
name|focusScopeItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|q_ptr
operator|->
name|hasFocus
argument_list|()
condition|)
comment|//if it has focus, focusScopeItemChange is called elsewhere
name|focusScopeItemChange
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q_ptr
operator|->
name|hasFocus
argument_list|()
condition|)
name|p
operator|->
name|d_ptr
operator|->
name|setFocusHelper
argument_list|(
name|Qt
operator|::
name|OtherFocusReason
argument_list|,
comment|/* climb = */
literal|false
argument_list|,
comment|/* focusFromHide = */
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|q_ptr
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
comment|// Invisible items with focus must explicitly clear subfocus.
name|clearSubFocus
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|// If this item has the scene's input focus, clear it.
name|scene
operator|->
name|setFocusItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns this item's focus proxy, or 0 if this item has no     focus proxy.      \sa setFocusProxy(), setFocus(), hasFocus() */
end_comment
begin_function
DECL|function|focusProxy
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|focusProxy
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|focusProxy
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the item's focus proxy to \a item.      If an item has a focus proxy, the focus proxy will receive     input focus when the item gains input focus. The item itself     will still have focus (i.e., hasFocus() will return true),     but only the focus proxy will receive the keyboard input.      A focus proxy can itself have a focus proxy, and so on. In     such case, keyboard input will be handled by the outermost     focus proxy.      The focus proxy \a item must belong to the same scene as     this item.      \sa focusProxy(), setFocus(), hasFocus() */
end_comment
begin_function
DECL|function|setFocusProxy
name|void
name|QGraphicsItem
operator|::
name|setFocusProxy
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
name|item
operator|==
name|d_ptr
operator|->
name|focusProxy
condition|)
return|return;
if|if
condition|(
name|item
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::setFocusProxy: cannot assign self as focus proxy"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|scene
operator|!=
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::setFocusProxy: focus proxy must be in same scene"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|QGraphicsItem
modifier|*
name|f
init|=
name|item
operator|->
name|focusProxy
argument_list|()
init|;
name|f
operator|!=
literal|0
condition|;
name|f
operator|=
name|f
operator|->
name|focusProxy
argument_list|()
control|)
block|{
if|if
condition|(
name|f
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::setFocusProxy: %p is already in the focus proxy chain"
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|QGraphicsItem
modifier|*
name|lastFocusProxy
init|=
name|d_ptr
operator|->
name|focusProxy
decl_stmt|;
if|if
condition|(
name|lastFocusProxy
condition|)
name|lastFocusProxy
operator|->
name|d_ptr
operator|->
name|focusProxyRefs
operator|.
name|removeOne
argument_list|(
operator|&
name|d_ptr
operator|->
name|focusProxy
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|focusProxy
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|item
condition|)
name|item
operator|->
name|d_ptr
operator|->
name|focusProxyRefs
operator|<<
operator|&
name|d_ptr
operator|->
name|focusProxy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      If this item, a child or descendant of this item currently has input     focus, this function will return a pointer to that item. If     no descendant has input focus, 0 is returned.      \sa hasFocus(), setFocus(), QWidget::focusWidget() */
end_comment
begin_function
DECL|function|focusItem
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|focusItem
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|subFocusItem
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns this item's focus scope item. */
end_comment
begin_function
DECL|function|focusScopeItem
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|focusScopeItem
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|focusScopeItem
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Grabs the mouse input.      This item will receive all mouse events for the scene until any of the     following events occurs:      \list     \li The item becomes invisible     \li The item is removed from the scene     \li The item is deleted     \li The item call ungrabMouse()     \li Another item calls grabMouse(); the item will regain the mouse grab     when the other item calls ungrabMouse().     \endlist      When an item gains the mouse grab, it receives a QEvent::GrabMouse     event. When it loses the mouse grab, it receives a QEvent::UngrabMouse     event. These events can be used to detect when your item gains or loses     the mouse grab through other means than receiving mouse button events.      It is almost never necessary to explicitly grab the mouse in Qt, as Qt     grabs and releases it sensibly. In particular, Qt grabs the mouse when you     press a mouse button, and keeps the mouse grabbed until you release the     last mouse button. Also, Qt::Popup widgets implicitly call grabMouse()     when shown, and ungrabMouse() when hidden.      Note that only visible items can grab mouse input. Calling grabMouse() on     an invisible item has no effect.      Keyboard events are not affected.      \sa QGraphicsScene::mouseGrabberItem(), ungrabMouse(), grabKeyboard() */
end_comment
begin_function
DECL|function|grabMouse
name|void
name|QGraphicsItem
operator|::
name|grabMouse
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabMouse: cannot grab mouse without scene"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|visible
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabMouse: cannot grab mouse while invisible"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|grabMouse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Releases the mouse grab.      \sa grabMouse(), ungrabKeyboard() */
end_comment
begin_function
DECL|function|ungrabMouse
name|void
name|QGraphicsItem
operator|::
name|ungrabMouse
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::ungrabMouse: cannot ungrab mouse without scene"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|ungrabMouse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Grabs the keyboard input.      The item will receive all keyboard input to the scene until one of the     following events occur:      \list     \li The item becomes invisible     \li The item is removed from the scene     \li The item is deleted     \li The item calls ungrabKeyboard()     \li Another item calls grabKeyboard(); the item will regain the keyboard grab     when the other item calls ungrabKeyboard().     \endlist      When an item gains the keyboard grab, it receives a QEvent::GrabKeyboard     event. When it loses the keyboard grab, it receives a     QEvent::UngrabKeyboard event. These events can be used to detect when your     item gains or loses the keyboard grab through other means than gaining     input focus.      It is almost never necessary to explicitly grab the keyboard in Qt, as Qt     grabs and releases it sensibly. In particular, Qt grabs the keyboard when     your item gains input focus, and releases it when your item loses input     focus, or when the item is hidden.      Note that only visible items can grab keyboard input. Calling     grabKeyboard() on an invisible item has no effect.      Keyboard events are not affected.      \sa ungrabKeyboard(), grabMouse(), setFocus() */
end_comment
begin_function
DECL|function|grabKeyboard
name|void
name|QGraphicsItem
operator|::
name|grabKeyboard
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabKeyboard: cannot grab keyboard without scene"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|visible
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::grabKeyboard: cannot grab keyboard while invisible"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|grabKeyboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Releases the keyboard grab.      \sa grabKeyboard(), ungrabMouse() */
end_comment
begin_function
DECL|function|ungrabKeyboard
name|void
name|QGraphicsItem
operator|::
name|ungrabKeyboard
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::ungrabKeyboard: cannot ungrab keyboard without scene"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|ungrabKeyboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the position of the item in parent coordinates. If the item has no     parent, its position is given in scene coordinates.      The position of the item describes its origin (local coordinate     (0, 0)) in parent coordinates; this function returns the same as     mapToParent(0, 0).      For convenience, you can also call scenePos() to determine the     item's position in scene coordinates, regardless of its parent.      \sa x(), y(), setPos(), transform(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|pos
name|QPointF
name|QGraphicsItem
operator|::
name|pos
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsItem::x() const      This convenience function is equivalent to calling pos().x().      \sa y() */
end_comment
begin_comment
comment|/*!     \since 4.6      Set's the \a x coordinate of the item's position. Equivalent to     calling setPos(x, y()).      \sa x(), setPos() */
end_comment
begin_function
DECL|function|setX
name|void
name|QGraphicsItem
operator|::
name|setX
parameter_list|(
name|qreal
name|x
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|inDestructor
condition|)
return|return;
if|if
condition|(
name|qIsNaN
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|setPos
argument_list|(
name|QPointF
argument_list|(
name|x
argument_list|,
name|d_ptr
operator|->
name|pos
operator|.
name|y
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsItem::y() const      This convenience function is equivalent to calling pos().y().      \sa x() */
end_comment
begin_comment
comment|/*!     \since 4.6      Set's the \a y coordinate of the item's position. Equivalent to     calling setPos(x(), y).      \sa x(), setPos() */
end_comment
begin_function
DECL|function|setY
name|void
name|QGraphicsItem
operator|::
name|setY
parameter_list|(
name|qreal
name|y
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|inDestructor
condition|)
return|return;
if|if
condition|(
name|qIsNaN
argument_list|(
name|y
argument_list|)
condition|)
return|return;
name|setPos
argument_list|(
name|QPointF
argument_list|(
name|d_ptr
operator|->
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's position in scene coordinates. This is     equivalent to calling \c mapToScene(0, 0).      \sa pos(), sceneTransform(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|scenePos
name|QPointF
name|QGraphicsItem
operator|::
name|scenePos
parameter_list|()
specifier|const
block|{
return|return
name|mapToScene
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the position \a pos. */
end_comment
begin_function
DECL|function|setPosHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setPosHelper
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|inSetPosHelper
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scene
condition|)
name|q
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|QPointF
name|oldPos
init|=
name|this
operator|->
name|pos
decl_stmt|;
name|this
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|inSetPosHelper
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
block|{
if|if
condition|(
name|pos
operator|.
name|x
argument_list|()
operator|!=
name|oldPos
operator|.
name|x
argument_list|()
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|xChanged
argument_list|()
emit|;
if|if
condition|(
name|pos
operator|.
name|y
argument_list|()
operator|!=
name|oldPos
operator|.
name|y
argument_list|()
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|yChanged
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the transform \a transform. */
end_comment
begin_function
DECL|function|setTransformHelper
name|void
name|QGraphicsItemPrivate
operator|::
name|setTransformHelper
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
name|q_ptr
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|transformData
operator|->
name|transform
operator|=
name|transform
expr_stmt|;
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the position of the item to \a pos, which is in parent     coordinates.  For items with no parent, \a pos is in scene     coordinates.      The position of the item describes its origin (local coordinate     (0, 0)) in parent coordinates.      \sa pos(), scenePos(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|setPos
name|void
name|QGraphicsItem
operator|::
name|setPos
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|pos
operator|==
name|pos
condition|)
return|return;
if|if
condition|(
name|d_ptr
operator|->
name|inDestructor
condition|)
return|return;
comment|// Update and repositition.
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
operator|(
name|ItemSendsGeometryChanges
operator||
name|ItemSendsScenePositionChanges
operator|)
operator|)
condition|)
block|{
name|d_ptr
operator|->
name|setPosHelper
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|isWidget
condition|)
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|setGeometryFromSetPos
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scenePosDescendants
condition|)
name|d_ptr
operator|->
name|sendScenePosChange
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Notify the item that the position is changing.
specifier|const
name|QVariant
name|newPosVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemPositionChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QPointF
argument_list|>
argument_list|(
name|pos
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|newPos
init|=
name|newPosVariant
operator|.
name|toPointF
argument_list|()
decl_stmt|;
if|if
condition|(
name|newPos
operator|==
name|d_ptr
operator|->
name|pos
condition|)
return|return;
comment|// Update and repositition.
name|d_ptr
operator|->
name|setPosHelper
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
comment|// Send post-notification.
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemPositionHasChanged
argument_list|,
name|newPosVariant
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|sendScenePosChange
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsItem::setPos(qreal x, qreal y)     \overload      This convenience function is equivalent to calling setPos(QPointF(\a x, \a     y)). */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsItem::moveBy(qreal dx, qreal dy)      Moves the item by \a dx points horizontally, and \a dy point     vertically. This function is equivalent to calling setPos(pos() +     QPointF(\a dx, \a dy)). */
end_comment
begin_comment
comment|/*!     If this item is part of a scene that is viewed by a QGraphicsView, this     convenience function will attempt to scroll the view to ensure that \a     rect is visible inside the view's viewport. If \a rect is a null rect (the     default), QGraphicsItem will default to the item's bounding rect. \a xmargin     and \a ymargin are the number of pixels the view should use for margins.      If the specified rect cannot be reached, the contents are scrolled to the     nearest valid position.      If this item is not viewed by a QGraphicsView, this function does nothing.      \sa QGraphicsView::ensureVisible() */
end_comment
begin_function
DECL|function|ensureVisible
name|void
name|QGraphicsItem
operator|::
name|ensureVisible
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|int
name|xmargin
parameter_list|,
name|int
name|ymargin
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|QRectF
name|sceneRect
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isNull
argument_list|()
condition|)
name|sceneRect
operator|=
name|sceneTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
else|else
name|sceneRect
operator|=
name|sceneBoundingRect
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|views
control|)
name|view
operator|->
name|ensureVisible
argument_list|(
name|sceneRect
argument_list|,
name|xmargin
argument_list|,
name|ymargin
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsItem::ensureVisible(qreal x, qreal y, qreal w, qreal h,     int xmargin = 50, int ymargin = 50)      This convenience function is equivalent to calling     ensureVisible(QRectF(\a x, \a y, \a w, \a h), \a xmargin, \a ymargin): */
end_comment
begin_comment
comment|/*!     \obsolete      Returns the item's affine transformation matrix. This is a subset or the     item's full transformation matrix, and might not represent the item's full     transformation.      Use transform() instead.      \sa setTransform(), sceneTransform() */
end_comment
begin_function
DECL|function|matrix
name|QMatrix
name|QGraphicsItem
operator|::
name|matrix
parameter_list|()
specifier|const
block|{
return|return
name|transform
argument_list|()
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns this item's transformation matrix.      The transformation matrix is combined with the item's rotation(), scale()     and transformations() into a combined transformations for the item.      The default transformation matrix is an identity matrix.      \sa setTransform(), sceneTransform() */
end_comment
begin_function
DECL|function|transform
name|QTransform
name|QGraphicsItem
operator|::
name|transform
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|QTransform
argument_list|()
return|;
return|return
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the clockwise rotation, in degrees, around the Z axis. The default     value is 0 (i.e., the item is not rotated).      The rotation is combined with the item's scale(), transform() and     transformations() to map the item's coordinate system to the parent item.      \sa setRotation(), transformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|rotation
name|qreal
name|QGraphicsItem
operator|::
name|rotation
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
literal|0
return|;
return|return
name|d_ptr
operator|->
name|transformData
operator|->
name|rotation
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the clockwise rotation \a angle, in degrees, around the Z axis. The     default value is 0 (i.e., the item is not rotated). Assigning a negative     value will rotate the item counter-clockwise. Normally the rotation angle     is in the range (-360, 360), but it's also possible to assign values     outside of this range (e.g., a rotation of 370 degrees is the same as a     rotation of 10 degrees).      The item is rotated around its transform origin point, which by default     is (0, 0). You can select a different transformation origin by calling     setTransformOriginPoint().      The rotation is combined with the item's scale(), transform() and     transformations() to map the item's coordinate system to the parent item.      \sa rotation(), setTransformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|setRotation
name|void
name|QGraphicsItem
operator|::
name|setRotation
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|qreal
name|newRotation
init|=
name|angle
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
block|{
comment|// Notify the item that the rotation is changing.
specifier|const
name|QVariant
name|newRotationVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemRotationChange
argument_list|,
name|angle
argument_list|)
argument_list|)
decl_stmt|;
name|newRotation
operator|=
name|newRotationVariant
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|rotation
operator|==
name|newRotation
condition|)
return|return;
name|d_ptr
operator|->
name|transformData
operator|->
name|rotation
operator|=
name|newRotation
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
comment|// Send post-notification.
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
name|itemChange
argument_list|(
name|ItemRotationHasChanged
argument_list|,
name|newRotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|rotationChanged
argument_list|()
emit|;
name|d_ptr
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the scale factor of the item. The default scale factor is 1.0     (i.e., the item is not scaled).      The scale is combined with the item's rotation(), transform() and     transformations() to map the item's coordinate system to the parent item.      \sa setScale(), rotation(), {Transformations} */
end_comment
begin_function
DECL|function|scale
name|qreal
name|QGraphicsItem
operator|::
name|scale
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
literal|1.
return|;
return|return
name|d_ptr
operator|->
name|transformData
operator|->
name|scale
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the scale \a factor of the item. The default scale factor is 1.0     (i.e., the item is not scaled). A scale factor of 0.0 will collapse the     item to a single point. If you provide a negative scale factor, the     item will be flipped and mirrored (i.e., rotated 180 degrees).      The item is scaled around its transform origin point, which by default     is (0, 0). You can select a different transformation origin by calling     setTransformOriginPoint().      The scale is combined with the item's rotation(), transform() and     transformations() to map the item's coordinate system to the parent item.      \sa scale(), setTransformOriginPoint(), {Transformations Example} */
end_comment
begin_function
DECL|function|setScale
name|void
name|QGraphicsItem
operator|::
name|setScale
parameter_list|(
name|qreal
name|factor
parameter_list|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|qreal
name|newScale
init|=
name|factor
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
block|{
comment|// Notify the item that the scale is changing.
specifier|const
name|QVariant
name|newScaleVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemScaleChange
argument_list|,
name|factor
argument_list|)
argument_list|)
decl_stmt|;
name|newScale
operator|=
name|newScaleVariant
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|scale
operator|==
name|newScale
condition|)
return|return;
name|d_ptr
operator|->
name|transformData
operator|->
name|scale
operator|=
name|newScale
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
comment|// Send post-notification.
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
name|itemChange
argument_list|(
name|ItemScaleHasChanged
argument_list|,
name|newScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|scaleChanged
argument_list|()
emit|;
name|d_ptr
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns a list of graphics transforms that currently apply to this item.      QGraphicsTransform is for applying and controlling a chain of individual     transformation operations on an item. It's particularly useful in     animations, where each transform operation needs to be interpolated     independently, or differently.      The transformations are combined with the item's rotation(), scale() and     transform() to map the item's coordinate system to the parent item.      \sa scale(), rotation(), transformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|transformations
name|QList
argument_list|<
name|QGraphicsTransform
modifier|*
argument_list|>
name|QGraphicsItem
operator|::
name|transformations
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|QList
argument_list|<
name|QGraphicsTransform
operator|*
argument_list|>
argument_list|()
return|;
return|return
name|d_ptr
operator|->
name|transformData
operator|->
name|graphicsTransforms
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets a list of graphics \a transformations (QGraphicsTransform) that     currently apply to this item.      If all you want is to rotate or scale an item, you should call setRotation()     or setScale() instead. If you want to set an arbitrary transformation on     an item, you can call setTransform().      QGraphicsTransform is for applying and controlling a chain of individual     transformation operations on an item. It's particularly useful in     animations, where each transform operation needs to be interpolated     independently, or differently.      The transformations are combined with the item's rotation(), scale() and     transform() to map the item's coordinate system to the parent item.      \sa scale(), setTransformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|setTransformations
name|void
name|QGraphicsItem
operator|::
name|setTransformations
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QGraphicsTransform
modifier|*
argument_list|>
modifier|&
name|transformations
parameter_list|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|graphicsTransforms
operator|=
name|transformations
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|transformations
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|setItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|prependGraphicsTransform
name|void
name|QGraphicsItemPrivate
operator|::
name|prependGraphicsTransform
parameter_list|(
name|QGraphicsTransform
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|transformData
condition|)
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
if|if
condition|(
operator|!
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|prepend
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|t
operator|->
name|d_func
argument_list|()
operator|->
name|setItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|appendGraphicsTransform
name|void
name|QGraphicsItemPrivate
operator|::
name|appendGraphicsTransform
parameter_list|(
name|QGraphicsTransform
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|transformData
condition|)
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
if|if
condition|(
operator|!
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|t
operator|->
name|d_func
argument_list|()
operator|->
name|setItem
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|transformChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the origin point for the transformation in item coordinates.      The default is QPointF(0,0).      \sa setTransformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|transformOriginPoint
name|QPointF
name|QGraphicsItem
operator|::
name|transformOriginPoint
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|QPointF
argument_list|(
name|d_ptr
operator|->
name|transformData
operator|->
name|xOrigin
argument_list|,
name|d_ptr
operator|->
name|transformData
operator|->
name|yOrigin
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the \a origin point for the transformation in item coordinates.      \sa transformOriginPoint(), {Transformations} */
end_comment
begin_function
DECL|function|setTransformOriginPoint
name|void
name|QGraphicsItem
operator|::
name|setTransformOriginPoint
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|origin
parameter_list|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|QPointF
name|newOrigin
init|=
name|origin
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
block|{
comment|// Notify the item that the origin point is changing.
specifier|const
name|QVariant
name|newOriginVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemTransformOriginPointChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QPointF
argument_list|>
argument_list|(
name|origin
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|newOrigin
operator|=
name|newOriginVariant
operator|.
name|toPointF
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|xOrigin
operator|==
name|newOrigin
operator|.
name|x
argument_list|()
operator|&&
name|d_ptr
operator|->
name|transformData
operator|->
name|yOrigin
operator|==
name|newOrigin
operator|.
name|y
argument_list|()
condition|)
block|{
return|return;
block|}
name|d_ptr
operator|->
name|transformData
operator|->
name|xOrigin
operator|=
name|newOrigin
operator|.
name|x
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|yOrigin
operator|=
name|newOrigin
operator|.
name|y
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|onlyTransform
operator|=
literal|false
expr_stmt|;
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
comment|// Send post-notification.
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
condition|)
name|itemChange
argument_list|(
name|ItemTransformOriginPointHasChanged
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QPointF
argument_list|>
argument_list|(
name|newOrigin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsItem::setTransformOriginPoint(qreal x, qreal y)      \since 4.6     \overload      Sets the origin point for the transformation in item coordinates.     This is equivalent to calling setTransformOriginPoint(QPointF(\a x, \a y)).      \sa setTransformOriginPoint(), {Transformations} */
end_comment
begin_comment
comment|/*!     \obsolete      Use sceneTransform() instead.      \sa transform(), setTransform(), scenePos(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|sceneMatrix
name|QMatrix
name|QGraphicsItem
operator|::
name|sceneMatrix
parameter_list|()
specifier|const
block|{
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns this item's scene transformation matrix. This matrix can be used     to map coordinates and geometrical shapes from this item's local     coordinate system to the scene's coordinate system. To map coordinates     from the scene, you must first invert the returned matrix.      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 4      Unlike transform(), which returns only an item's local transformation, this     function includes the item's (and any parents') position, and all the transfomation properties.      \sa transform(), setTransform(), scenePos(), {The Graphics View Coordinate System}, {Transformations} */
end_comment
begin_function
DECL|function|sceneTransform
name|QTransform
name|QGraphicsItem
operator|::
name|sceneTransform
parameter_list|()
specifier|const
block|{
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
return|return
name|d_ptr
operator|->
name|sceneTransform
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Returns this item's device transformation matrix, using \a     viewportTransform to map from scene to device coordinates. This matrix can     be used to map coordinates and geometrical shapes from this item's local     coordinate system to the viewport's (or any device's) coordinate     system. To map coordinates from the viewport, you must first invert the     returned matrix.      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 5      This function is the same as combining this item's scene transform with     the view's viewport transform, but it also understands the     ItemIgnoresTransformations flag. The device transform can be used to do     accurate coordinate mapping (and collision detection) for untransformable     items.      \sa transform(), setTransform(), scenePos(), {The Graphics View Coordinate     System}, itemTransform() */
end_comment
begin_function
DECL|function|deviceTransform
name|QTransform
name|QGraphicsItem
operator|::
name|deviceTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|viewportTransform
parameter_list|)
specifier|const
block|{
comment|// Ensure we return the standard transform if we're not untransformable.
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|itemIsUntransformable
argument_list|()
condition|)
block|{
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|*
name|viewportTransform
return|;
block|}
comment|// Find the topmost item that ignores view transformations.
specifier|const
name|QGraphicsItem
modifier|*
name|untransformedAncestor
init|=
name|this
decl_stmt|;
name|QList
argument_list|<
specifier|const
name|QGraphicsItem
modifier|*
argument_list|>
name|parents
decl_stmt|;
while|while
condition|(
name|untransformedAncestor
operator|&&
operator|(
operator|(
name|untransformedAncestor
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorIgnoresTransformations
operator|)
operator|)
condition|)
block|{
name|parents
operator|.
name|prepend
argument_list|(
name|untransformedAncestor
argument_list|)
expr_stmt|;
name|untransformedAncestor
operator|=
name|untransformedAncestor
operator|->
name|parentItem
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|untransformedAncestor
condition|)
block|{
comment|// Assert in debug mode, continue in release.
name|Q_ASSERT_X
argument_list|(
name|untransformedAncestor
argument_list|,
literal|"QGraphicsItem::deviceTransform"
argument_list|,
literal|"Invalid object structure!"
argument_list|)
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
comment|// First translate the base untransformable item.
name|untransformedAncestor
operator|->
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
name|QPointF
name|mappedPoint
init|=
operator|(
name|untransformedAncestor
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|*
name|viewportTransform
operator|)
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// COMBINE
name|QTransform
name|matrix
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|mappedPoint
operator|.
name|x
argument_list|()
argument_list|,
name|mappedPoint
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|untransformedAncestor
operator|->
name|d_ptr
operator|->
name|transformData
condition|)
name|matrix
operator|=
name|untransformedAncestor
operator|->
name|d_ptr
operator|->
name|transformData
operator|->
name|computedFullTransform
argument_list|(
operator|&
name|matrix
argument_list|)
expr_stmt|;
comment|// Then transform and translate all children.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|parent
init|=
name|parents
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|parent
operator|->
name|d_ptr
operator|->
name|combineTransformFromParent
argument_list|(
operator|&
name|matrix
argument_list|)
expr_stmt|;
block|}
return|return
name|matrix
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns a QTransform that maps coordinates from this item to \a other. If     \a ok is not null, and if there is no such transform, the boolean pointed     to by \a ok will be set to false; otherwise it will be set to true.      This transform provides an alternative to the mapToItem() or mapFromItem()     functions, by returning the appropriate transform so that you can map     shapes and coordinates yourself. It also helps you write more efficient     code when repeatedly mapping between the same two items.      \note In rare circumstances, there is no transform that maps between two     items.      \sa mapToItem(), mapFromItem(), deviceTransform() */
end_comment
begin_function
DECL|function|itemTransform
name|QTransform
name|QGraphicsItem
operator|::
name|itemTransform
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|other
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
comment|// Catch simple cases first.
if|if
condition|(
name|other
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::itemTransform: null pointer passed"
argument_list|)
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
if|if
condition|(
name|other
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
name|QGraphicsItem
modifier|*
name|parent
init|=
name|d_ptr
operator|->
name|parent
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|otherParent
init|=
name|other
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
comment|// This is other's child
if|if
condition|(
name|parent
operator|==
name|other
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
name|QTransform
name|x
decl_stmt|;
name|d_ptr
operator|->
name|combineTransformFromParent
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|// This is other's parent
if|if
condition|(
name|otherParent
operator|==
name|this
condition|)
block|{
specifier|const
name|QPointF
modifier|&
name|otherPos
init|=
name|other
operator|->
name|d_ptr
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|other
operator|->
name|d_ptr
operator|->
name|transformData
condition|)
block|{
name|QTransform
name|otherToParent
decl_stmt|;
name|other
operator|->
name|d_ptr
operator|->
name|combineTransformFromParent
argument_list|(
operator|&
name|otherToParent
argument_list|)
expr_stmt|;
return|return
name|otherToParent
operator|.
name|inverted
argument_list|(
name|ok
argument_list|)
return|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|otherPos
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|otherPos
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
comment|// Siblings
if|if
condition|(
name|parent
operator|==
name|otherParent
condition|)
block|{
comment|// COMBINE
specifier|const
name|QPointF
modifier|&
name|itemPos
init|=
name|d_ptr
operator|->
name|pos
decl_stmt|;
specifier|const
name|QPointF
modifier|&
name|otherPos
init|=
name|other
operator|->
name|d_ptr
operator|->
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
operator|&&
operator|!
name|other
operator|->
name|d_ptr
operator|->
name|transformData
condition|)
block|{
name|QPointF
name|delta
init|=
name|itemPos
operator|-
name|otherPos
decl_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|delta
operator|.
name|x
argument_list|()
argument_list|,
name|delta
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
name|QTransform
name|itemToParent
decl_stmt|;
name|d_ptr
operator|->
name|combineTransformFromParent
argument_list|(
operator|&
name|itemToParent
argument_list|)
expr_stmt|;
name|QTransform
name|otherToParent
decl_stmt|;
name|other
operator|->
name|d_ptr
operator|->
name|combineTransformFromParent
argument_list|(
operator|&
name|otherToParent
argument_list|)
expr_stmt|;
return|return
name|itemToParent
operator|*
name|otherToParent
operator|.
name|inverted
argument_list|(
name|ok
argument_list|)
return|;
block|}
comment|// Find the closest common ancestor. If the two items don't share an
comment|// ancestor, then the only way is to combine their scene transforms.
specifier|const
name|QGraphicsItem
modifier|*
name|commonAncestor
init|=
name|commonAncestorItem
argument_list|(
name|other
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commonAncestor
condition|)
block|{
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
name|other
operator|->
name|d_ptr
operator|->
name|ensureSceneTransform
argument_list|()
expr_stmt|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|*
name|other
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|(
name|ok
argument_list|)
return|;
block|}
comment|// If the two items are cousins (in sibling branches), map both to the
comment|// common ancestor, and combine the two transforms.
name|bool
name|cousins
init|=
name|other
operator|!=
name|commonAncestor
operator|&&
name|this
operator|!=
name|commonAncestor
decl_stmt|;
if|if
condition|(
name|cousins
condition|)
block|{
name|bool
name|good
init|=
literal|false
decl_stmt|;
name|QTransform
name|thisToScene
init|=
name|itemTransform
argument_list|(
name|commonAncestor
argument_list|,
operator|&
name|good
argument_list|)
decl_stmt|;
name|QTransform
name|otherToScene
argument_list|(
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
if|if
condition|(
name|good
condition|)
name|otherToScene
operator|=
name|other
operator|->
name|itemTransform
argument_list|(
name|commonAncestor
argument_list|,
operator|&
name|good
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|good
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|QTransform
argument_list|()
return|;
block|}
return|return
name|thisToScene
operator|*
name|otherToScene
operator|.
name|inverted
argument_list|(
name|ok
argument_list|)
return|;
block|}
comment|// One is an ancestor of the other; walk the chain.
name|bool
name|parentOfOther
init|=
name|isAncestorOf
argument_list|(
name|other
argument_list|)
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|child
init|=
name|parentOfOther
condition|?
name|other
else|:
name|this
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|root
init|=
name|parentOfOther
condition|?
name|this
else|:
name|other
decl_stmt|;
name|QTransform
name|x
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|p
init|=
name|child
decl_stmt|;
do|do
block|{
name|p
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
operator|->
name|combineTransformToParent
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|d_ptr
operator|->
name|parent
operator|)
operator|&&
name|p
operator|!=
name|root
condition|)
do|;
if|if
condition|(
name|parentOfOther
condition|)
return|return
name|x
operator|.
name|inverted
argument_list|(
name|ok
argument_list|)
return|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|x
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Sets the item's affine transformation matrix. This is a subset or the     item's full transformation matrix, and might not represent the item's full     transformation.      Use setTransform() instead.      \sa transform(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|setMatrix
name|void
name|QGraphicsItem
operator|::
name|setMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
name|QTransform
name|newTransform
argument_list|(
name|combine
condition|?
name|QTransform
argument_list|(
name|matrix
argument_list|)
operator|*
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
else|:
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
operator|==
name|newTransform
condition|)
return|return;
comment|// Update and set the new transformation.
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemSendsGeometryChanges
operator|)
condition|)
block|{
name|d_ptr
operator|->
name|setTransformHelper
argument_list|(
name|newTransform
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Notify the item that the transformation matrix is changing.
specifier|const
name|QVariant
name|newMatrixVariant
init|=
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QMatrix
argument_list|>
argument_list|(
name|newTransform
operator|.
name|toAffine
argument_list|()
argument_list|)
decl_stmt|;
name|newTransform
operator|=
name|QTransform
argument_list|(
name|qvariant_cast
argument_list|<
name|QMatrix
argument_list|>
argument_list|(
name|itemChange
argument_list|(
name|ItemMatrixChange
argument_list|,
name|newMatrixVariant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
operator|==
name|newTransform
condition|)
return|return;
comment|// Update and set the new transformation.
name|d_ptr
operator|->
name|setTransformHelper
argument_list|(
name|newTransform
argument_list|)
expr_stmt|;
comment|// Send post-notification.
name|itemChange
argument_list|(
name|ItemTransformHasChanged
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QTransform
argument_list|>
argument_list|(
name|newTransform
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Sets the item's current transformation matrix to \a matrix.      If \a combine is true, then \a matrix is combined with the current matrix;     otherwise, \a matrix \e replaces the current matrix. \a combine is false     by default.      To simplify interation with items using a transformed view, QGraphicsItem     provides mapTo... and mapFrom... functions that can translate between     items' and the scene's coordinates. For example, you can call mapToScene()     to map an item coordiate to a scene coordinate, or mapFromScene() to map     from scene coordinates to item coordinates.      The transformation matrix is combined with the item's rotation(), scale()     and transformations() into a combined transformation that maps the item's     coordinate system to its parent.      \sa transform(), setRotation(), setScale(), setTransformOriginPoint(), {The Graphics View Coordinate System}, {Transformations} */
end_comment
begin_function
DECL|function|setTransform
name|void
name|QGraphicsItem
operator|::
name|setTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|bool
name|combine
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
name|d_ptr
operator|->
name|transformData
operator|=
operator|new
name|QGraphicsItemPrivate
operator|::
name|TransformData
expr_stmt|;
name|QTransform
name|newTransform
argument_list|(
name|combine
condition|?
name|matrix
operator|*
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
else|:
name|matrix
argument_list|)
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
operator|==
name|newTransform
condition|)
return|return;
comment|// Update and set the new transformation.
if|if
condition|(
operator|!
operator|(
name|d_ptr
operator|->
name|flags
operator|&
operator|(
name|ItemSendsGeometryChanges
operator||
name|ItemSendsScenePositionChanges
operator|)
operator|)
condition|)
block|{
name|d_ptr
operator|->
name|setTransformHelper
argument_list|(
name|newTransform
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scenePosDescendants
condition|)
name|d_ptr
operator|->
name|sendScenePosChange
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Notify the item that the transformation matrix is changing.
specifier|const
name|QVariant
name|newTransformVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemTransformChange
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QTransform
argument_list|>
argument_list|(
name|newTransform
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|newTransform
operator|=
name|qvariant_cast
argument_list|<
name|QTransform
argument_list|>
argument_list|(
name|newTransformVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|transformData
operator|->
name|transform
operator|==
name|newTransform
condition|)
return|return;
comment|// Update and set the new transformation.
name|d_ptr
operator|->
name|setTransformHelper
argument_list|(
name|newTransform
argument_list|)
expr_stmt|;
comment|// Send post-notification.
name|itemChange
argument_list|(
name|ItemTransformHasChanged
argument_list|,
name|newTransformVariant
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|sendScenePosChange
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use resetTransform() instead. */
end_comment
begin_function
DECL|function|resetMatrix
name|void
name|QGraphicsItem
operator|::
name|resetMatrix
parameter_list|()
block|{
name|resetTransform
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Resets this item's transformation matrix to the identity matrix or     all the transformation properties to their default values.     This is equivalent to calling \c setTransform(QTransform()).      \sa setTransform(), transform() */
end_comment
begin_function
DECL|function|resetTransform
name|void
name|QGraphicsItem
operator|::
name|resetTransform
parameter_list|()
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use      \code     setRotation(rotation() + angle);     \endcode      instead.      Rotates the current item transformation \a angle degrees clockwise around     its origin. To translate around an arbitrary point (x, y), you need to     combine translation and rotation with setTransform().      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 6      \sa setTransform(), transform(), scale(), shear(), translate() */
end_comment
begin_function
DECL|function|rotate
name|void
name|QGraphicsItem
operator|::
name|rotate
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|()
operator|.
name|rotate
argument_list|(
name|angle
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use      \code     setTransform(QTransform::fromScale(sx, sy), true);     \endcode      instead.      Scales the current item transformation by (\a sx, \a sy) around its     origin. To scale from an arbitrary point (x, y), you need to combine     translation and scaling with setTransform().      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 7      \sa setTransform(), transform() */
end_comment
begin_function
DECL|function|scale
name|void
name|QGraphicsItem
operator|::
name|scale
parameter_list|(
name|qreal
name|sx
parameter_list|,
name|qreal
name|sy
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
operator|::
name|fromScale
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use      \code     setTransform(QTransform().shear(sh, sv), true);     \endcode      instead.      Shears the current item transformation by (\a sh, \a sv).      \sa setTransform(), transform() */
end_comment
begin_function
DECL|function|shear
name|void
name|QGraphicsItem
operator|::
name|shear
parameter_list|(
name|qreal
name|sh
parameter_list|,
name|qreal
name|sv
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
argument_list|()
operator|.
name|shear
argument_list|(
name|sh
argument_list|,
name|sv
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setPos() or setTransformOriginPoint() instead. For identical     behavior, use      \code     setTransform(QTransform::fromTranslate(dx, dy), true);     \endcode      Translates the current item transformation by (\a dx, \a dy).      If all you want is to move an item, you should call moveBy() or     setPos() instead; this function changes the item's translation,     which is conceptually separate from its position.      \sa setTransform(), transform() */
end_comment
begin_function
DECL|function|translate
name|void
name|QGraphicsItem
operator|::
name|translate
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|)
block|{
name|setTransform
argument_list|(
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This virtual function is called twice for all items by the     QGraphicsScene::advance() slot. In the first phase, all items are called     with \a phase == 0, indicating that items on the scene are about to     advance, and then all items are called with \a phase == 1. Reimplement     this function to update your item if you need simple scene-controlled     animation.      The default implementation does nothing.      For individual item animation, an alternative to this function is to     either use QGraphicsItemAnimation, or to multiple-inherit from QObject and     QGraphicsItem, and animate your item using QObject::startTimer() and     QObject::timerEvent().      \sa QGraphicsItemAnimation, QTimeLine */
end_comment
begin_function
DECL|function|advance
name|void
name|QGraphicsItem
operator|::
name|advance
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the Z-value of the item. The Z-value affects the stacking order of     sibling (neighboring) items.      The default Z-value is 0.      \sa setZValue(), {QGraphicsItem#Sorting}{Sorting}, stackBefore(), ItemStacksBehindParent */
end_comment
begin_function
DECL|function|zValue
name|qreal
name|QGraphicsItem
operator|::
name|zValue
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|z
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the Z-value of the item to \a z. The Z value decides the stacking     order of sibling (neighboring) items. A sibling item of high Z value will     always be drawn on top of another sibling item with a lower Z value.      If you restore the Z value, the item's insertion order will decide its     stacking order.      The Z-value does not affect the item's size in any way.      The default Z-value is 0.      \sa zValue(), {QGraphicsItem#Sorting}{Sorting}, stackBefore(), ItemStacksBehindParent */
end_comment
begin_function
DECL|function|setZValue
name|void
name|QGraphicsItem
operator|::
name|setZValue
parameter_list|(
name|qreal
name|z
parameter_list|)
block|{
specifier|const
name|QVariant
name|newZVariant
argument_list|(
name|itemChange
argument_list|(
name|ItemZValueChange
argument_list|,
name|z
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|newZ
init|=
name|newZVariant
operator|.
name|toReal
argument_list|()
decl_stmt|;
if|if
condition|(
name|newZ
operator|==
name|d_ptr
operator|->
name|z
condition|)
return|return;
if|if
condition|(
name|d_ptr
operator|->
name|scene
operator|&&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|indexMethod
operator|!=
name|QGraphicsScene
operator|::
name|NoIndex
condition|)
block|{
comment|// Z Value has changed, we have to notify the index.
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|->
name|itemChange
argument_list|(
name|this
argument_list|,
name|ItemZValueChange
argument_list|,
operator|&
name|newZ
argument_list|)
expr_stmt|;
block|}
name|d_ptr
operator|->
name|z
operator|=
name|newZ
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|parent
condition|)
name|d_ptr
operator|->
name|parent
operator|->
name|d_ptr
operator|->
name|needSortChildren
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|needSortTopLevelItems
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|true
argument_list|)
expr_stmt|;
name|itemChange
argument_list|(
name|ItemZValueHasChanged
argument_list|,
name|newZVariant
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|flags
operator|&
name|ItemNegativeZStacksBehindParent
condition|)
name|setFlag
argument_list|(
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
argument_list|,
name|z
operator|<
name|qreal
argument_list|(
literal|0.0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|zChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      Ensures that the list of children is sorted by insertion order, and that     the siblingIndexes are packed (no gaps), and start at 0.      ### This function is almost identical to     QGraphicsScenePrivate::ensureSequentialTopLevelSiblingIndexes(). */
end_comment
begin_function
DECL|function|ensureSequentialSiblingIndex
name|void
name|QGraphicsItemPrivate
operator|::
name|ensureSequentialSiblingIndex
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sequentialOrdering
condition|)
block|{
name|qSort
argument_list|(
name|children
operator|.
name|begin
argument_list|()
argument_list|,
name|children
operator|.
name|end
argument_list|()
argument_list|,
name|insertionOrder
argument_list|)
expr_stmt|;
name|sequentialOrdering
operator|=
literal|1
expr_stmt|;
name|needSortChildren
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|holesInSiblingIndex
condition|)
block|{
name|holesInSiblingIndex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|children
index|[
name|i
index|]
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sendScenePosChange
specifier|inline
name|void
name|QGraphicsItemPrivate
operator|::
name|sendScenePosChange
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|scene
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
condition|)
name|q
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemScenePositionHasChanged
argument_list|,
name|q
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|scenePosDescendants
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|scenePosItems
control|)
block|{
if|if
condition|(
name|q
operator|->
name|isAncestorOf
argument_list|(
name|item
argument_list|)
condition|)
name|item
operator|->
name|itemChange
argument_list|(
name|QGraphicsItem
operator|::
name|ItemScenePositionHasChanged
argument_list|,
name|item
operator|->
name|scenePos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Stacks this item before \a sibling, which must be a sibling item (i.e., the     two items must share the same parent item, or must both be toplevel items).     The \a sibling must have the same Z value as this item, otherwise calling     this function will have no effect.      By default, all sibling items are stacked by insertion order (i.e., the     first item you add is drawn before the next item you add). If two items' Z     values are different, then the item with the highest Z value is drawn on     top. When the Z values are the same, the insertion order will decide the     stacking order.      \sa setZValue(), ItemStacksBehindParent, {QGraphicsItem#Sorting}{Sorting} */
end_comment
begin_function
DECL|function|stackBefore
name|void
name|QGraphicsItem
operator|::
name|stackBefore
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|sibling
parameter_list|)
block|{
if|if
condition|(
name|sibling
operator|==
name|this
condition|)
return|return;
if|if
condition|(
operator|!
name|sibling
operator|||
name|d_ptr
operator|->
name|parent
operator|!=
name|sibling
operator|->
name|parentItem
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::stackUnder: cannot stack under %p, which must be a sibling"
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
return|return;
block|}
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
modifier|*
name|siblings
init|=
name|d_ptr
operator|->
name|parent
condition|?
operator|&
name|d_ptr
operator|->
name|parent
operator|->
name|d_ptr
operator|->
name|children
else|:
operator|(
name|d_ptr
operator|->
name|scene
condition|?
operator|&
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|topLevelItems
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|siblings
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::stackUnder: cannot stack under %p, which must be a sibling"
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// First, make sure that the sibling indexes have no holes. This also
comment|// marks the children list for sorting.
if|if
condition|(
name|d_ptr
operator|->
name|parent
condition|)
name|d_ptr
operator|->
name|parent
operator|->
name|d_ptr
operator|->
name|ensureSequentialSiblingIndex
argument_list|()
expr_stmt|;
else|else
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|ensureSequentialTopLevelSiblingIndexes
argument_list|()
expr_stmt|;
comment|// Only move items with the same Z value, and that need moving.
name|int
name|siblingIndex
init|=
name|sibling
operator|->
name|d_ptr
operator|->
name|siblingIndex
decl_stmt|;
name|int
name|myIndex
init|=
name|d_ptr
operator|->
name|siblingIndex
decl_stmt|;
if|if
condition|(
name|myIndex
operator|>=
name|siblingIndex
condition|)
block|{
name|siblings
operator|->
name|move
argument_list|(
name|myIndex
argument_list|,
name|siblingIndex
argument_list|)
expr_stmt|;
comment|// Fixup the insertion ordering.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|siblings
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
modifier|&
name|index
init|=
name|siblings
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|siblingIndex
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|siblingIndex
operator|&&
name|index
operator|>=
name|siblingIndex
operator|&&
name|index
operator|<=
name|myIndex
condition|)
operator|++
name|index
expr_stmt|;
block|}
name|d_ptr
operator|->
name|siblingIndex
operator|=
name|siblingIndex
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|siblings
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
modifier|&
name|index
init|=
name|siblings
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|siblingIndex
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|siblingIndex
operator|&&
name|index
operator|>=
name|siblingIndex
operator|&&
name|index
operator|<=
name|myIndex
condition|)
name|siblings
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|siblingOrderChange
argument_list|()
expr_stmt|;
block|}
name|d_ptr
operator|->
name|siblingOrderChange
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rect of this item's descendants (i.e., its     children, their children, etc.) in local coordinates. The     rectangle will contain all descendants after they have been mapped     to local coordinates. If the item has no children, this function     returns an empty QRectF.      This does not include this item's own bounding rect; it only returns     its descendants' accumulated bounding rect. If you need to include this     item's bounding rect, you can add boundingRect() to childrenBoundingRect()     using QRectF::operator|().      This function is linear in complexity; it determines the size of the     returned bounding rect by iterating through all descendants.      \sa boundingRect(), sceneBoundingRect() */
end_comment
begin_function
DECL|function|childrenBoundingRect
name|QRectF
name|QGraphicsItem
operator|::
name|childrenBoundingRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|dirtyChildrenBoundingRect
condition|)
return|return
name|d_ptr
operator|->
name|childrenBoundingRect
return|;
name|d_ptr
operator|->
name|childrenBoundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|childrenBoundingRectHelper
argument_list|(
literal|0
argument_list|,
operator|&
name|d_ptr
operator|->
name|childrenBoundingRect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|dirtyChildrenBoundingRect
operator|=
literal|0
expr_stmt|;
return|return
name|d_ptr
operator|->
name|childrenBoundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual QRectF QGraphicsItem::boundingRect() const = 0      This pure virtual function defines the outer bounds of the item as     a rectangle; all painting must be restricted to inside an item's     bounding rect. QGraphicsView uses this to determine whether the     item requires redrawing.      Although the item's shape can be arbitrary, the bounding rect is     always rectangular, and it is unaffected by the items'     transformation.      If you want to change the item's bounding rectangle, you must first call     prepareGeometryChange(). This notifies the scene of the imminent change,     so that its can update its item geometry index; otherwise, the scene will     be unaware of the item's new geometry, and the results are undefined     (typically, rendering artifacts are left around in the view).      Reimplement this function to let QGraphicsView determine what     parts of the widget, if any, need to be redrawn.      Note: For shapes that paint an outline / stroke, it is important     to include half the pen width in the bounding rect. It is not     necessary to compensate for antialiasing, though.      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 8      \sa boundingRegion(), shape(), contains(), {The Graphics View Coordinate     System}, prepareGeometryChange() */
end_comment
begin_comment
comment|/*!     Returns the bounding rect of this item in scene coordinates, by combining     sceneTransform() with boundingRect().      \sa boundingRect(), {The Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|sceneBoundingRect
name|QRectF
name|QGraphicsItem
operator|::
name|sceneBoundingRect
parameter_list|()
specifier|const
block|{
comment|// Find translate-only offset
comment|// COMBINE
name|QPointF
name|offset
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|parentItem
init|=
name|this
decl_stmt|;
specifier|const
name|QGraphicsItemPrivate
modifier|*
name|itemd
decl_stmt|;
do|do
block|{
name|itemd
operator|=
name|parentItem
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|itemd
operator|->
name|transformData
condition|)
break|break;
name|offset
operator|+=
name|itemd
operator|->
name|pos
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|parentItem
operator|=
name|itemd
operator|->
name|parent
operator|)
condition|)
do|;
name|QRectF
name|br
init|=
name|boundingRect
argument_list|()
decl_stmt|;
name|br
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parentItem
condition|)
return|return
name|br
return|;
if|if
condition|(
name|parentItem
operator|->
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
block|{
name|br
operator|.
name|translate
argument_list|(
name|parentItem
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|parentItem
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|br
return|;
block|}
return|return
name|parentItem
operator|->
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|br
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the shape of this item as a QPainterPath in local     coordinates. The shape is used for many things, including collision     detection, hit tests, and for the QGraphicsScene::items() functions.      The default implementation calls boundingRect() to return a simple     rectangular shape, but subclasses can reimplement this function to return     a more accurate shape for non-rectangular items. For example, a round item     may choose to return an elliptic shape for better collision detection. For     example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 9      The outline of a shape can vary depending on the width and style of the     pen used when drawing. If you want to include this outline in the item's     shape, you can create a shape from the stroke using QPainterPathStroker.      This function is called by the default implementations of contains() and     collidesWithPath().      \sa boundingRect(), contains(), prepareGeometryChange(), QPainterPathStroker */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item is clipped. An item is clipped if it has either     set the \l ItemClipsToShape flag, or if it or any of its ancestors has set     the \l ItemClipsChildrenToShape flag.      Clipping affects the item's appearance (i.e., painting), as well as mouse     and hover event delivery.      \sa clipPath(), shape(), setFlags() */
end_comment
begin_function
DECL|function|isClipped
name|bool
name|QGraphicsItem
operator|::
name|isClipped
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
operator|||
operator|(
name|d
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemClipsToShape
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns this item's clip path, or an empty QPainterPath if this item is     not clipped. The clip path constrains the item's appearance and     interaction (i.e., restricts the area the item can draw, and it also     restricts the area that the item receives events).      You can enable clipping by setting the ItemClipsToShape or     ItemClipsChildrenToShape flags. The item's clip path is calculated by     intersecting all clipping ancestors' shapes. If the item sets     ItemClipsToShape, the final clip is intersected with the item's own shape.      \note Clipping introduces a performance penalty for all items involved;     you should generally avoid using clipping if you can (e.g., if your items     always draw inside boundingRect() or shape() boundaries, clipping is not     necessary).      \sa isClipped(), shape(), setFlags() */
end_comment
begin_function
DECL|function|clipPath
name|QPainterPath
name|QGraphicsItem
operator|::
name|clipPath
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isClipped
argument_list|()
condition|)
return|return
name|QPainterPath
argument_list|()
return|;
specifier|const
name|QRectF
name|thisBoundingRect
argument_list|(
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisBoundingRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPainterPath
argument_list|()
return|;
name|QPainterPath
name|clip
decl_stmt|;
comment|// Start with the item's bounding rect.
name|clip
operator|.
name|addRect
argument_list|(
name|thisBoundingRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
condition|)
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|parent
init|=
name|this
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|lastParent
init|=
name|this
decl_stmt|;
comment|// Intersect any in-between clips starting at the top and moving downwards.
while|while
condition|(
operator|(
name|parent
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|parent
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|flags
operator|&
name|ItemClipsChildrenToShape
condition|)
block|{
comment|// Map clip to the current parent and intersect with its shape/clipPath
name|clip
operator|=
name|lastParent
operator|->
name|itemTransform
argument_list|(
name|parent
argument_list|)
operator|.
name|map
argument_list|(
name|clip
argument_list|)
expr_stmt|;
name|clip
operator|=
name|clip
operator|.
name|intersected
argument_list|(
name|parent
operator|->
name|shape
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|clip
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|clip
return|;
name|lastParent
operator|=
name|parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|lastParent
operator|!=
name|this
condition|)
block|{
comment|// Map clip back to the item's transform.
comment|// ### what if itemtransform fails
name|clip
operator|=
name|lastParent
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|map
argument_list|(
name|clip
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|ItemClipsToShape
condition|)
name|clip
operator|=
name|clip
operator|.
name|intersected
argument_list|(
name|shape
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|clip
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item contains \a point, which is in local     coordinates; otherwise, false is returned. It is most often called from     QGraphicsView to determine what item is under the cursor, and for that     reason, the implementation of this function should be as light-weight as     possible.      By default, this function calls shape(), but you can reimplement it in a     subclass to provide a (perhaps more efficient) implementation.      \sa shape(), boundingRect(), collidesWithPath() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|isClipped
argument_list|()
condition|?
name|clipPath
argument_list|()
operator|.
name|contains
argument_list|(
name|point
argument_list|)
else|:
name|shape
argument_list|()
operator|.
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      Returns true if this item collides with \a other; otherwise     returns false.      The \a mode is applied to \a other, and the resulting shape or     bounding rectangle is then compared to this item's shape. The     default value for \a mode is Qt::IntersectsItemShape; \a other     collides with this item if it either intersects, contains, or is     contained by this item's shape (see Qt::ItemSelectionMode for     details).      The default implementation is based on shape intersection, and it calls     shape() on both items. Because the complexity of arbitrary shape-shape     intersection grows with an order of magnitude when the shapes are complex,     this operation can be noticably time consuming. You have the option of     reimplementing this function in a subclass of QGraphicsItem to provide a     custom algorithm. This allows you to make use of natural constraints in     the shapes of your own items, in order to improve the performance of the     collision detection. For instance, two untransformed perfectly circular     items' collision can be determined very efficiently by comparing their     positions and radii.      Keep in mind that when reimplementing this function and calling shape() or     boundingRect() on \a other, the returned coordinates must be mapped to     this item's coordinate system before any intersection can take place.      \sa contains(), shape() */
end_comment
begin_function
DECL|function|collidesWithItem
name|bool
name|QGraphicsItem
operator|::
name|collidesWithItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|other
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|other
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|other
condition|)
return|return
literal|false
return|;
comment|// The items share the same clip if their closest clipper is the same, or
comment|// if one clips the other.
name|bool
name|clips
init|=
operator|(
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
decl_stmt|;
name|bool
name|otherClips
init|=
operator|(
name|other
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
operator|)
decl_stmt|;
if|if
condition|(
name|clips
operator|||
name|otherClips
condition|)
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|closestClipper
init|=
name|isAncestorOf
argument_list|(
name|other
argument_list|)
condition|?
name|this
else|:
name|parentItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|closestClipper
operator|&&
operator|!
operator|(
name|closestClipper
operator|->
name|flags
argument_list|()
operator|&
name|ItemClipsChildrenToShape
operator|)
condition|)
name|closestClipper
operator|=
name|closestClipper
operator|->
name|parentItem
argument_list|()
expr_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|otherClosestClipper
init|=
name|other
operator|->
name|isAncestorOf
argument_list|(
name|this
argument_list|)
condition|?
name|other
else|:
name|other
operator|->
name|parentItem
argument_list|()
decl_stmt|;
while|while
condition|(
name|otherClosestClipper
operator|&&
operator|!
operator|(
name|otherClosestClipper
operator|->
name|flags
argument_list|()
operator|&
name|ItemClipsChildrenToShape
operator|)
condition|)
name|otherClosestClipper
operator|=
name|otherClosestClipper
operator|->
name|parentItem
argument_list|()
expr_stmt|;
if|if
condition|(
name|closestClipper
operator|==
name|otherClosestClipper
condition|)
block|{
name|d_ptr
operator|->
name|localCollisionHack
operator|=
literal|1
expr_stmt|;
name|bool
name|res
init|=
name|collidesWithPath
argument_list|(
name|mapFromItem
argument_list|(
name|other
argument_list|,
name|other
operator|->
name|shape
argument_list|()
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|d_ptr
operator|->
name|localCollisionHack
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
name|QPainterPath
name|otherShape
init|=
name|other
operator|->
name|isClipped
argument_list|()
condition|?
name|other
operator|->
name|clipPath
argument_list|()
else|:
name|other
operator|->
name|shape
argument_list|()
decl_stmt|;
return|return
name|collidesWithPath
argument_list|(
name|mapFromItem
argument_list|(
name|other
argument_list|,
name|otherShape
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item collides with \a path.      The collision is determined by \a mode. The default value for \a mode is     Qt::IntersectsItemShape; \a path collides with this item if it either     intersects, contains, or is contained by this item's shape.      Note that this function checks whether the item's shape or     bounding rectangle (depending on \a mode) is contained within \a     path, and not whether \a path is contained within the items shape     or bounding rectangle.      \sa collidesWithItem(), contains(), shape() */
end_comment
begin_function
DECL|function|collidesWithPath
name|bool
name|QGraphicsItem
operator|::
name|collidesWithPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No collision with empty paths.
return|return
literal|false
return|;
block|}
name|QRectF
name|rectA
argument_list|(
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|rectA
argument_list|)
expr_stmt|;
name|QRectF
name|rectB
argument_list|(
name|path
operator|.
name|controlPointRect
argument_list|()
argument_list|)
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|rectB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rectA
operator|.
name|intersects
argument_list|(
name|rectB
argument_list|)
condition|)
block|{
comment|// This we can determine efficiently. If the two rects neither
comment|// intersect nor contain eachother, then the two items do not collide.
return|return
literal|false
return|;
block|}
comment|// For further testing, we need this item's shape or bounding rect.
name|QPainterPath
name|thisShape
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|ContainsItemShape
condition|)
name|thisShape
operator|=
operator|(
name|isClipped
argument_list|()
operator|&&
operator|!
name|d_ptr
operator|->
name|localCollisionHack
operator|)
condition|?
name|clipPath
argument_list|()
else|:
name|shape
argument_list|()
expr_stmt|;
else|else
name|thisShape
operator|.
name|addRect
argument_list|(
name|rectA
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisShape
operator|==
name|QPainterPath
argument_list|()
condition|)
block|{
comment|// Empty shape? No collision.
return|return
literal|false
return|;
block|}
comment|// Use QPainterPath boolean operations to determine the collision, O(N*logN).
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemShape
operator|||
name|mode
operator|==
name|Qt
operator|::
name|IntersectsItemBoundingRect
condition|)
return|return
name|path
operator|.
name|intersects
argument_list|(
name|thisShape
argument_list|)
return|;
return|return
name|path
operator|.
name|contains
argument_list|(
name|thisShape
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all items that collide with this item.      The way collisions are detected is determined by applying \a mode     to items that are compared to this item, i.e., each item's shape     or bounding rectangle is checked against this item's shape. The     default value for \a mode is Qt::IntersectsItemShape.      \sa collidesWithItem() */
end_comment
begin_function
DECL|function|collidingItems
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|QGraphicsItem
operator|::
name|collidingItems
parameter_list|(
name|Qt
operator|::
name|ItemSelectionMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
return|return
name|d_ptr
operator|->
name|scene
operator|->
name|collidingItems
argument_list|(
name|this
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|QList
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item's bounding rect is completely obscured by the     opaque shape of any of colliding items above it (i.e., with a higher Z     value than this item).      Its implementation is based on calling isObscuredBy(), which you can     reimplement to provide a custom obscurity algorithm.    \sa opaqueArea() */
end_comment
begin_function
DECL|function|isObscured
name|bool
name|QGraphicsItem
operator|::
name|isObscured
parameter_list|()
specifier|const
block|{
return|return
name|isObscured
argument_list|(
name|QRectF
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Item obscurity helper function.      Returns true if the subrect \a rect of \a item's bounding rect is obscured     by \a other (i.e., \a other's opaque area covers \a item's \a rect     completely. \a other is assumed to already be "on top of" \a item     wrt. stacking order. */
end_comment
begin_function
DECL|function|qt_QGraphicsItem_isObscured
specifier|static
name|bool
name|qt_QGraphicsItem_isObscured
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QGraphicsItem
modifier|*
name|other
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
return|return
name|other
operator|->
name|mapToItem
argument_list|(
name|item
argument_list|,
name|other
operator|->
name|opaqueArea
argument_list|()
argument_list|)
operator|.
name|contains
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.3      Returns true if \a rect is completely obscured by the opaque shape of any     of colliding items above it (i.e., with a higher Z value than this item).      Unlike the default isObscured() function, this function does not call     isObscuredBy().      \sa opaqueArea() */
end_comment
begin_function
DECL|function|isObscured
name|bool
name|QGraphicsItem
operator|::
name|isObscured
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
literal|false
return|;
name|QRectF
name|br
init|=
name|boundingRect
argument_list|()
decl_stmt|;
name|QRectF
name|testRect
init|=
name|rect
operator|.
name|isNull
argument_list|()
condition|?
name|br
else|:
name|rect
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|d
operator|->
name|scene
operator|->
name|items
argument_list|(
name|mapToScene
argument_list|(
name|br
argument_list|)
argument_list|,
name|Qt
operator|::
name|IntersectsItemBoundingRect
argument_list|)
control|)
block|{
if|if
condition|(
name|item
operator|==
name|this
condition|)
break|break;
if|if
condition|(
name|qt_QGraphicsItem_isObscured
argument_list|(
name|this
argument_list|,
name|item
argument_list|,
name|testRect
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QGraphicsItem::isObscured(qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling isObscured(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Returns true if this item's bounding rect is completely obscured by the     opaque shape of \a item.      The base implementation maps \a item's opaqueArea() to this item's     coordinate system, and then checks if this item's boundingRect() is fully     contained within the mapped shape.      You can reimplement this function to provide a custom algorithm for     determining whether this item is obscured by \a item.      \sa opaqueArea(), isObscured() */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|item
condition|)
return|return
literal|false
return|;
return|return
name|qt_closestItemFirst
argument_list|(
name|item
argument_list|,
name|this
argument_list|)
operator|&&
name|qt_QGraphicsItem_isObscured
argument_list|(
name|this
argument_list|,
name|item
argument_list|,
name|boundingRect
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This virtual function returns a shape representing the area where this     item is opaque. An area is opaque if it is filled using an opaque brush or     color (i.e., not transparent).      This function is used by isObscuredBy(), which is called by underlying     items to determine if they are obscured by this item.      The default implementation returns an empty QPainterPath, indicating that     this item is completely transparent and does not obscure any other items.      \sa isObscuredBy(), isObscured(), shape() */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QPainterPath
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the bounding region for this item. The coordinate space of the     returned region depends on \a itemToDeviceTransform. If you pass an     identity QTransform as a parameter, this function will return a local     coordinate region.      The bounding region describes a coarse outline of the item's visual     contents. Although it's expensive to calculate, it's also more precise     than boundingRect(), and it can help to avoid unnecessary repainting when     an item is updated. This is particularly efficient for thin items (e.g.,     lines or simple polygons). You can tune the granularity for the bounding     region by calling setBoundingRegionGranularity(). The default granularity     is 0; in which the item's bounding region is the same as its bounding     rect.      \a itemToDeviceTransform is the transformation from item coordinates to     device coordinates. If you want this function to return a QRegion in scene     coordinates, you can pass sceneTransform() as an argument.      \sa boundingRegionGranularity() */
end_comment
begin_function
DECL|function|boundingRegion
name|QRegion
name|QGraphicsItem
operator|::
name|boundingRegion
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|itemToDeviceTransform
parameter_list|)
specifier|const
block|{
comment|// ### Ideally we would have a better way to generate this region,
comment|// preferably something in the lines of QPainterPath::toRegion(QTransform)
comment|// coupled with a way to generate a painter path from a set of painter
comment|// operations (e.g., QPicture::toPainterPath() or so). The current
comment|// approach generates a bitmap with the size of the item's bounding rect
comment|// in device coordinates, scaled by b.r.granularity, then paints the item
comment|// into the bitmap, converts the result to a QRegion and scales the region
comment|// back to device space with inverse granularity.
name|qreal
name|granularity
init|=
name|boundingRegionGranularity
argument_list|()
decl_stmt|;
name|QRect
name|deviceRect
init|=
name|itemToDeviceTransform
operator|.
name|mapRect
argument_list|(
name|boundingRect
argument_list|()
argument_list|)
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|_q_adjustRect
argument_list|(
operator|&
name|deviceRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|granularity
operator|==
literal|0.0
condition|)
return|return
name|QRegion
argument_list|(
name|deviceRect
argument_list|)
return|;
name|int
name|pad
init|=
literal|1
decl_stmt|;
name|QSize
name|bitmapSize
argument_list|(
name|qMax
argument_list|(
literal|1
argument_list|,
name|int
argument_list|(
name|deviceRect
operator|.
name|width
argument_list|()
operator|*
name|granularity
argument_list|)
operator|+
name|pad
operator|*
literal|2
argument_list|)
argument_list|,
name|qMax
argument_list|(
literal|1
argument_list|,
name|int
argument_list|(
name|deviceRect
operator|.
name|height
argument_list|()
operator|*
name|granularity
argument_list|)
operator|+
name|pad
operator|*
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|QImage
name|mask
argument_list|(
name|bitmapSize
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|mask
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|mask
argument_list|)
decl_stmt|;
name|p
operator|.
name|setRenderHints
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
comment|// Transform painter (### this code is from QGraphicsScene::drawItemHelper
comment|// and doesn't work properly with perspective transformations).
name|QPointF
name|viewOrigo
init|=
name|itemToDeviceTransform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|offset
init|=
name|viewOrigo
operator|-
name|deviceRect
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|p
operator|.
name|scale
argument_list|(
name|granularity
argument_list|,
name|granularity
argument_list|)
expr_stmt|;
name|p
operator|.
name|translate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p
operator|.
name|translate
argument_list|(
name|pad
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|p
operator|.
name|setWorldTransform
argument_list|(
name|itemToDeviceTransform
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|p
operator|.
name|translate
argument_list|(
name|itemToDeviceTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Render
name|QStyleOptionGraphicsItem
name|option
decl_stmt|;
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|paint
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
comment|// Transform QRegion back to device space
name|QTransform
name|unscale
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
literal|1
operator|/
name|granularity
argument_list|,
literal|1
operator|/
name|granularity
argument_list|)
decl_stmt|;
name|QRegion
name|r
decl_stmt|;
name|QBitmap
name|colorMask
init|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|mask
operator|.
name|createMaskFromColor
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|QRegion
argument_list|(
name|colorMask
argument_list|)
operator|.
name|rects
argument_list|()
control|)
block|{
name|QRect
name|xrect
init|=
name|unscale
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|translated
argument_list|(
name|deviceRect
operator|.
name|topLeft
argument_list|()
operator|-
name|QPoint
argument_list|(
name|pad
argument_list|,
name|pad
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|+=
name|xrect
operator|.
name|adjusted
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|&
name|deviceRect
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the item's bounding region granularity; a value between and     including 0 and 1. The default value is 0 (i.e., the lowest granularity,     where the bounding region corresponds to the item's bounding rectangle).  \omit ### NOTE \endomit      \sa setBoundingRegionGranularity() */
end_comment
begin_function
DECL|function|boundingRegionGranularity
name|qreal
name|QGraphicsItem
operator|::
name|boundingRegionGranularity
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|hasBoundingRegionGranularity
condition|?
name|qvariant_cast
argument_list|<
name|qreal
argument_list|>
argument_list|(
name|d_ptr
operator|->
name|extra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraBoundingRegionGranularity
argument_list|)
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Sets the bounding region granularity to \a granularity; a value between     and including 0 and 1. The default value is 0 (i.e., the lowest     granularity, where the bounding region corresponds to the item's bounding     rectangle).      The granularity is used by boundingRegion() to calculate how fine the     bounding region of the item should be. The highest achievable granularity     is 1, where boundingRegion() will return the finest outline possible for     the respective device (e.g., for a QGraphicsView viewport, this gives you     a pixel-perfect bounding region). The lowest possible granularity is     0. The value of \a granularity describes the ratio between device     resolution and the resolution of the bounding region (e.g., a value of     0.25 will provide a region where each chunk corresponds to 4x4 device     units / pixels).      \sa boundingRegionGranularity() */
end_comment
begin_function
DECL|function|setBoundingRegionGranularity
name|void
name|QGraphicsItem
operator|::
name|setBoundingRegionGranularity
parameter_list|(
name|qreal
name|granularity
parameter_list|)
block|{
if|if
condition|(
name|granularity
argument_list|<
literal|0.0
operator|||
name|granularity
argument_list|>
literal|1.0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::setBoundingRegionGranularity: invalid granularity %g"
argument_list|,
name|granularity
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|granularity
operator|==
literal|0.0
condition|)
block|{
name|d_ptr
operator|->
name|unsetExtra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraBoundingRegionGranularity
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|hasBoundingRegionGranularity
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|hasBoundingRegionGranularity
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|setExtra
argument_list|(
name|QGraphicsItemPrivate
operator|::
name|ExtraBoundingRegionGranularity
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|qreal
argument_list|>
argument_list|(
name|granularity
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn virtual void QGraphicsItem::paint(QPainter *painter, const     QStyleOptionGraphicsItem *option, QWidget *widget = 0) = 0      This function, which is usually called by QGraphicsView, paints the     contents of an item in local coordinates.      Reimplement this function in a QGraphicsItem subclass to provide the     item's painting implementation, using \a painter. The \a option parameter     provides style options for the item, such as its state, exposed area and     its level-of-detail hints. The \a widget argument is optional. If     provided, it points to the widget that is being painted on; otherwise, it     is 0. For cached painting, \a widget is always 0.      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 10      The painter's pen is 0-width by default, and its pen is initialized to the     QPalette::Text brush from the paint device's palette. The brush is     initialized to QPalette::Window.      Make sure to constrain all painting inside the boundaries of     boundingRect() to avoid rendering artifacts (as QGraphicsView does not     clip the painter for you). In particular, when QPainter renders the     outline of a shape using an assigned QPen, half of the outline will be     drawn outside, and half inside, the shape you're rendering (e.g., with a     pen width of 2 units, you must draw outlines 1 unit inside     boundingRect()). QGraphicsItem does not support use of cosmetic pens with     a non-zero width.      All painting is done in local coordinates.      \sa setCacheMode(), QPen::width(), {Item Coordinates}, ItemUsesExtendedStyleOption */
end_comment
begin_comment
comment|/*!     \internal     Returns true if we can discard an update request; otherwise false. */
end_comment
begin_function
DECL|function|discardUpdateRequest
name|bool
name|QGraphicsItemPrivate
operator|::
name|discardUpdateRequest
parameter_list|(
name|bool
name|ignoreVisibleBit
parameter_list|,
name|bool
name|ignoreDirtyBit
parameter_list|,
name|bool
name|ignoreOpacity
parameter_list|)
specifier|const
block|{
comment|// No scene, or if the scene is updating everything, means we have nothing
comment|// to do. The only exception is if the scene tracks the growing scene rect.
return|return
operator|!
name|scene
operator|||
operator|(
operator|!
name|visible
operator|&&
operator|!
name|ignoreVisibleBit
operator|&&
operator|!
name|this
operator|->
name|ignoreVisible
operator|)
operator|||
operator|(
operator|!
name|ignoreDirtyBit
operator|&&
name|fullUpdatePending
operator|)
operator|||
operator|(
operator|!
name|ignoreOpacity
operator|&&
operator|!
name|this
operator|->
name|ignoreOpacity
operator|&&
name|childrenCombineOpacity
argument_list|()
operator|&&
name|isFullyTransparent
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|depth
name|int
name|QGraphicsItemPrivate
operator|::
name|depth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|itemDepth
operator|==
operator|-
literal|1
condition|)
cast|const_cast
argument_list|<
name|QGraphicsItemPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|resolveDepth
argument_list|()
expr_stmt|;
return|return
name|itemDepth
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
end_ifndef
begin_function
DECL|function|invalidateParentGraphicsEffectsRecursively
name|void
name|QGraphicsItemPrivate
operator|::
name|invalidateParentGraphicsEffectsRecursively
parameter_list|()
block|{
name|QGraphicsItemPrivate
modifier|*
name|itemPrivate
init|=
name|this
decl_stmt|;
do|do
block|{
if|if
condition|(
name|itemPrivate
operator|->
name|graphicsEffect
condition|)
block|{
name|itemPrivate
operator|->
name|notifyInvalidated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|itemPrivate
operator|->
name|updateDueToGraphicsEffect
condition|)
cast|static_cast
argument_list|<
name|QGraphicsItemEffectSourcePrivate
operator|*
argument_list|>
argument_list|(
name|itemPrivate
operator|->
name|graphicsEffect
operator|->
name|d_func
argument_list|()
operator|->
name|source
operator|->
name|d_func
argument_list|()
argument_list|)
operator|->
name|invalidateCache
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|itemPrivate
operator|=
name|itemPrivate
operator|->
name|parent
condition|?
name|itemPrivate
operator|->
name|parent
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
else|:
literal|0
operator|)
condition|)
do|;
block|}
end_function
begin_function
DECL|function|invalidateChildGraphicsEffectsRecursively
name|void
name|QGraphicsItemPrivate
operator|::
name|invalidateChildGraphicsEffectsRecursively
parameter_list|(
name|QGraphicsItemPrivate
operator|::
name|InvalidateReason
name|reason
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mayHaveChildWithGraphicsEffect
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|childPrivate
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|OpacityChanged
operator|&&
operator|(
name|childPrivate
operator|->
name|flags
operator|&
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
operator|)
condition|)
continue|continue;
if|if
condition|(
name|childPrivate
operator|->
name|graphicsEffect
condition|)
block|{
name|childPrivate
operator|->
name|notifyInvalidated
operator|=
literal|1
expr_stmt|;
cast|static_cast
argument_list|<
name|QGraphicsItemEffectSourcePrivate
operator|*
argument_list|>
argument_list|(
name|childPrivate
operator|->
name|graphicsEffect
operator|->
name|d_func
argument_list|()
operator|->
name|source
operator|->
name|d_func
argument_list|()
argument_list|)
operator|->
name|invalidateCache
argument_list|()
expr_stmt|;
block|}
name|childPrivate
operator|->
name|invalidateChildGraphicsEffectsRecursively
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSEFFECT
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|invalidateDepthRecursively
name|void
name|QGraphicsItemPrivate
operator|::
name|invalidateDepthRecursively
parameter_list|()
block|{
if|if
condition|(
name|itemDepth
operator|==
operator|-
literal|1
condition|)
return|return;
name|itemDepth
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|invalidateDepthRecursively
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Resolves the stacking depth of this object and all its ancestors. */
end_comment
begin_function
DECL|function|resolveDepth
name|void
name|QGraphicsItemPrivate
operator|::
name|resolveDepth
parameter_list|()
block|{
if|if
condition|(
operator|!
name|parent
condition|)
name|itemDepth
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|itemDepth
operator|==
operator|-
literal|1
condition|)
name|parent
operator|->
name|d_ptr
operator|->
name|resolveDepth
argument_list|()
expr_stmt|;
name|itemDepth
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|itemDepth
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      ### This function is almost identical to     QGraphicsScenePrivate::registerTopLevelItem(). */
end_comment
begin_function
DECL|function|addChild
name|void
name|QGraphicsItemPrivate
operator|::
name|addChild
parameter_list|(
name|QGraphicsItem
modifier|*
name|child
parameter_list|)
block|{
comment|// Remove all holes from the sibling index list. Now the max index
comment|// number is equal to the size of the children list.
name|ensureSequentialSiblingIndex
argument_list|()
expr_stmt|;
name|needSortChildren
operator|=
literal|1
expr_stmt|;
comment|// ### maybe 0
name|child
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
name|children
operator|.
name|size
argument_list|()
expr_stmt|;
name|children
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|childrenChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal      ### This function is almost identical to     QGraphicsScenePrivate::unregisterTopLevelItem(). */
end_comment
begin_function
DECL|function|removeChild
name|void
name|QGraphicsItemPrivate
operator|::
name|removeChild
parameter_list|(
name|QGraphicsItem
modifier|*
name|child
parameter_list|)
block|{
comment|// When removing elements in the middle of the children list,
comment|// there will be a "gap" in the list of sibling indexes (0,1,3,4).
if|if
condition|(
operator|!
name|holesInSiblingIndex
condition|)
name|holesInSiblingIndex
operator|=
name|child
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|!=
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sequentialOrdering
operator|&&
operator|!
name|holesInSiblingIndex
condition|)
name|children
operator|.
name|removeAt
argument_list|(
name|child
operator|->
name|d_ptr
operator|->
name|siblingIndex
argument_list|)
expr_stmt|;
else|else
name|children
operator|.
name|removeOne
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// NB! Do not use children.removeAt(child->d_ptr->siblingIndex) because
comment|// the child is not guaranteed to be at the index after the list is sorted.
comment|// (see ensureSortedChildren()).
name|child
operator|->
name|d_ptr
operator|->
name|siblingIndex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
emit|emit
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q_ptr
argument_list|)
operator|->
name|childrenChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|maybeExtraItemCache
name|QGraphicsItemCache
modifier|*
name|QGraphicsItemPrivate
operator|::
name|maybeExtraItemCache
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|QGraphicsItemCache
operator|*
operator|)
name|qvariant_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|extra
argument_list|(
name|ExtraCacheData
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extraItemCache
name|QGraphicsItemCache
modifier|*
name|QGraphicsItemPrivate
operator|::
name|extraItemCache
parameter_list|()
specifier|const
block|{
name|QGraphicsItemCache
modifier|*
name|c
init|=
operator|(
name|QGraphicsItemCache
operator|*
operator|)
name|qvariant_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|extra
argument_list|(
name|ExtraCacheData
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QGraphicsItemPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|c
operator|=
operator|new
name|QGraphicsItemCache
expr_stmt|;
name|that
operator|->
name|setExtra
argument_list|(
name|ExtraCacheData
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|removeExtraItemCache
name|void
name|QGraphicsItemPrivate
operator|::
name|removeExtraItemCache
parameter_list|()
block|{
name|QGraphicsItemCache
modifier|*
name|c
init|=
operator|(
name|QGraphicsItemCache
operator|*
operator|)
name|qvariant_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|extra
argument_list|(
name|ExtraCacheData
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|->
name|purge
argument_list|()
expr_stmt|;
operator|delete
name|c
expr_stmt|;
block|}
name|unsetExtra
argument_list|(
name|ExtraCacheData
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updatePaintedViewBoundingRects
name|void
name|QGraphicsItemPrivate
operator|::
name|updatePaintedViewBoundingRects
parameter_list|(
name|bool
name|updateChildren
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scene
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|views
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsViewPrivate
modifier|*
name|viewPrivate
init|=
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|views
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QRect
name|rect
init|=
name|paintedViewBoundingRects
operator|.
name|value
argument_list|(
name|viewPrivate
operator|->
name|viewport
argument_list|)
decl_stmt|;
name|rect
operator|.
name|translate
argument_list|(
name|viewPrivate
operator|->
name|dirtyScrollOffset
argument_list|)
expr_stmt|;
name|viewPrivate
operator|->
name|updateRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateChildren
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|d_ptr
operator|->
name|updatePaintedViewBoundingRects
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Traverses all the ancestors up to the top-level and updates the pointer to
end_comment
begin_comment
comment|// always point to the top-most item that has a dirty scene transform.
end_comment
begin_comment
comment|// It then backtracks to the top-most dirty item and start calculating the
end_comment
begin_comment
comment|// scene transform by combining the item's transform (+pos) with the parent's
end_comment
begin_comment
comment|// cached scene transform (which we at this point know for sure is valid).
end_comment
begin_function
DECL|function|ensureSceneTransformRecursive
name|void
name|QGraphicsItemPrivate
operator|::
name|ensureSceneTransformRecursive
parameter_list|(
name|QGraphicsItem
modifier|*
modifier|*
name|topMostDirtyItem
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|topMostDirtyItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirtySceneTransform
condition|)
operator|*
name|topMostDirtyItem
operator|=
name|q_ptr
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|parent
operator|->
name|d_ptr
operator|->
name|ensureSceneTransformRecursive
argument_list|(
name|topMostDirtyItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|topMostDirtyItem
operator|==
name|q_ptr
condition|)
block|{
if|if
condition|(
operator|!
name|dirtySceneTransform
condition|)
return|return;
comment|// OK, neither my ancestors nor I have dirty scene transforms.
operator|*
name|topMostDirtyItem
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|topMostDirtyItem
condition|)
block|{
return|return;
comment|// Continue backtrack.
block|}
comment|// This item and all its descendants have dirty scene transforms.
comment|// We're about to validate this item's scene transform, so we have to
comment|// invalidate all the children; otherwise there's no way for the descendants
comment|// to detect that the ancestor has changed.
name|invalidateChildrenSceneTransform
argument_list|()
expr_stmt|;
comment|// COMBINE my transform with the parent's scene transform.
name|updateSceneTransformFromParent
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|dirtySceneTransform
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setSubFocus
name|void
name|QGraphicsItemPrivate
operator|::
name|setSubFocus
parameter_list|(
name|QGraphicsItem
modifier|*
name|rootItem
parameter_list|,
name|QGraphicsItem
modifier|*
name|stopItem
parameter_list|)
block|{
comment|// Update focus child chain. Stop at panels, or if this item
comment|// is hidden, stop at the first item with a visible parent.
name|QGraphicsItem
modifier|*
name|parent
init|=
name|rootItem
condition|?
name|rootItem
else|:
name|q_ptr
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|panel
argument_list|()
operator|!=
name|q_ptr
operator|->
name|panel
argument_list|()
condition|)
return|return;
do|do
block|{
comment|// Clear any existing ancestor's subFocusItem.
if|if
condition|(
name|parent
operator|!=
name|q_ptr
operator|&&
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
operator|==
name|q_ptr
condition|)
break|break;
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
operator|->
name|d_ptr
operator|->
name|clearSubFocus
argument_list|(
literal|0
argument_list|,
name|stopItem
argument_list|)
expr_stmt|;
block|}
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
operator|=
name|q_ptr
expr_stmt|;
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItemChange
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|parent
operator|->
name|isPanel
argument_list|()
operator|&&
operator|(
name|parent
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|parent
operator|)
operator|&&
operator|(
name|visible
operator|||
operator|!
name|parent
operator|->
name|d_ptr
operator|->
name|visible
operator|)
condition|)
do|;
if|if
condition|(
name|scene
operator|&&
operator|!
name|scene
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|passiveFocusItem
operator|=
name|subFocusItem
expr_stmt|;
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|lastFocusItem
operator|=
name|subFocusItem
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|clearSubFocus
name|void
name|QGraphicsItemPrivate
operator|::
name|clearSubFocus
parameter_list|(
name|QGraphicsItem
modifier|*
name|rootItem
parameter_list|,
name|QGraphicsItem
modifier|*
name|stopItem
parameter_list|)
block|{
comment|// Reset sub focus chain.
name|QGraphicsItem
modifier|*
name|parent
init|=
name|rootItem
condition|?
name|rootItem
else|:
name|q_ptr
decl_stmt|;
do|do
block|{
if|if
condition|(
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
operator|!=
name|q_ptr
condition|)
break|break;
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|stopItem
operator|&&
operator|!
name|parent
operator|->
name|isAncestorOf
argument_list|(
name|stopItem
argument_list|)
condition|)
name|parent
operator|->
name|d_ptr
operator|->
name|subFocusItemChange
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|parent
operator|->
name|isPanel
argument_list|()
operator|&&
operator|(
name|parent
operator|=
name|parent
operator|->
name|d_ptr
operator|->
name|parent
operator|)
condition|)
do|;
block|}
end_function
begin_comment
comment|/*!     \internal      Sets the focusProxy pointer to 0 for all items that have this item as their     focusProxy. ### Qt 5: Use QPointer instead. */
end_comment
begin_function
DECL|function|resetFocusProxy
name|void
name|QGraphicsItemPrivate
operator|::
name|resetFocusProxy
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|focusProxyRefs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|*
name|focusProxyRefs
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|focusProxyRefs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Subclasses can reimplement this function to be notified when subFocusItem     changes. */
end_comment
begin_function
DECL|function|subFocusItemChange
name|void
name|QGraphicsItemPrivate
operator|::
name|subFocusItemChange
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \internal      Subclasses can reimplement this function to be notified when an item     becomes a focusScopeItem (or is no longer a focusScopeItem). */
end_comment
begin_function
DECL|function|focusScopeItemChange
name|void
name|QGraphicsItemPrivate
operator|::
name|focusScopeItemChange
parameter_list|(
name|bool
name|isSubFocusItem
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|isSubFocusItem
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Subclasses can reimplement this function to be notified when its     siblingIndex order is changed. */
end_comment
begin_function
DECL|function|siblingOrderChange
name|void
name|QGraphicsItemPrivate
operator|::
name|siblingOrderChange
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \internal      Tells us if it is a proxy widget */
end_comment
begin_function
DECL|function|isProxyWidget
name|bool
name|QGraphicsItemPrivate
operator|::
name|isProxyWidget
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Schedules a redraw of the area covered by \a rect in this item. You can     call this function whenever your item needs to be redrawn, such as if it     changes appearance or size.      This function does not cause an immediate paint; instead it schedules a     paint request that is processed by QGraphicsView after control reaches the     event loop. The item will only be redrawn if it is visible in any     associated view.      As a side effect of the item being repainted, other items that overlap the     area \a rect may also be repainted.      If the item is invisible (i.e., isVisible() returns false), this function     does nothing.      \sa paint(), boundingRect() */
end_comment
begin_function
DECL|function|update
name|void
name|QGraphicsItem
operator|::
name|update
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return;
comment|// Make sure we notify effects about invalidated source.
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
name|d_ptr
operator|->
name|invalidateParentGraphicsEffectsRecursively
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_GRAPHICSEFFECT
if|if
condition|(
name|CacheMode
argument_list|(
name|d_ptr
operator|->
name|cacheMode
argument_list|)
operator|!=
name|NoCache
condition|)
block|{
comment|// Invalidate cache.
name|QGraphicsItemCache
modifier|*
name|cache
init|=
name|d_ptr
operator|->
name|extraItemCache
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|->
name|allExposed
condition|)
block|{
if|if
condition|(
name|rect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|cache
operator|->
name|allExposed
operator|=
literal|true
expr_stmt|;
name|cache
operator|->
name|exposed
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cache
operator|->
name|exposed
operator|.
name|append
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Only invalidate cache; item is already dirty.
if|if
condition|(
name|d_ptr
operator|->
name|fullUpdatePending
condition|)
return|return;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Scrolls the contents of \a rect by \a dx, \a dy. If \a rect is a null rect     (the default), the item's bounding rect is scrolled.      Scrolling provides a fast alternative to simply redrawing when the     contents of the item (or parts of the item) are shifted vertically or     horizontally. Depending on the current transformation and the capabilities     of the paint device (i.e., the viewport), this operation may consist of     simply moving pixels from one location to another using memmove(). In most     cases this is faster than rerendering the entire area.      After scrolling, the item will issue an update for the newly exposed     areas. If scrolling is not supported (e.g., you are rendering to an OpenGL     viewport, which does not benefit from scroll optimizations), this function     is equivalent to calling update(\a rect).      \b{Note:} Scrolling is only supported when QGraphicsItem::ItemCoordinateCache     is enabled; in all other cases calling this function is equivalent to calling     update(\a rect). If you for sure know that the item is opaque and not overlapped     by other items, you can map the \a rect to viewport coordinates and scroll the     viewport.      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 19      \sa boundingRect() */
end_comment
begin_function
DECL|function|scroll
name|void
name|QGraphicsItem
operator|::
name|scroll
parameter_list|(
name|qreal
name|dx
parameter_list|,
name|qreal
name|dy
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0.0
operator|&&
name|dy
operator|==
literal|0.0
condition|)
return|return;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return;
comment|// Accelerated scrolling means moving pixels from one location to another
comment|// and only redraw the newly exposed area. The following requirements must
comment|// be fulfilled in order to do that:
comment|//
comment|// 1) Item is opaque.
comment|// 2) Item is not overlapped by other items.
comment|//
comment|// There's (yet) no way to detect whether an item is opaque or not, which means
comment|// we cannot do accelerated scrolling unless the cache is enabled. In case of using
comment|// DeviceCoordinate cache we also have to take the device transform into account in
comment|// order to determine whether we can do accelerated scrolling or not. That's left out
comment|// for simplicity here, but it is definitely something we can consider in the future
comment|// as a performance improvement.
if|if
condition|(
name|d
operator|->
name|cacheMode
operator|!=
name|QGraphicsItem
operator|::
name|ItemCoordinateCache
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|dx
operator|-
name|int
argument_list|(
name|dx
argument_list|)
argument_list|)
operator|||
operator|!
name|qFuzzyIsNull
argument_list|(
name|dy
operator|-
name|int
argument_list|(
name|dy
argument_list|)
argument_list|)
condition|)
block|{
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsItemCache
modifier|*
name|cache
init|=
name|d
operator|->
name|extraItemCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|->
name|allExposed
operator|||
name|cache
operator|->
name|fixedSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// Cache is either invalidated or item is scaled (see QGraphicsItem::setCacheMode).
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Find pixmap in cache.
name|QPixmap
name|cachedPixmap
decl_stmt|;
if|if
condition|(
operator|!
name|QPixmapCache
operator|::
name|find
argument_list|(
name|cache
operator|->
name|key
argument_list|,
operator|&
name|cachedPixmap
argument_list|)
condition|)
block|{
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
return|return;
block|}
name|QRect
name|scrollRect
init|=
operator|(
name|rect
operator|.
name|isNull
argument_list|()
condition|?
name|boundingRect
argument_list|()
else|:
name|rect
operator|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scrollRect
operator|.
name|intersects
argument_list|(
name|cache
operator|->
name|boundingRect
argument_list|)
condition|)
return|return;
comment|// Nothing to scroll.
comment|// Remove from cache to avoid deep copy when modifying.
name|QPixmapCache
operator|::
name|remove
argument_list|(
name|cache
operator|->
name|key
argument_list|)
expr_stmt|;
name|QRegion
name|exposed
decl_stmt|;
name|cachedPixmap
operator|.
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|scrollRect
operator|.
name|translated
argument_list|(
operator|-
name|cache
operator|->
name|boundingRect
operator|.
name|topLeft
argument_list|()
argument_list|)
argument_list|,
operator|&
name|exposed
argument_list|)
expr_stmt|;
comment|// Reinsert into cache.
name|cache
operator|->
name|key
operator|=
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|cachedPixmap
argument_list|)
expr_stmt|;
comment|// Translate the existing expose.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|exposed
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRectF
modifier|&
name|e
init|=
name|cache
operator|->
name|exposed
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|e
operator|.
name|intersects
argument_list|(
name|rect
argument_list|)
condition|)
continue|continue;
name|e
operator|.
name|translate
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
comment|// Append newly exposed areas. Note that the exposed region is currently
comment|// in pixmap coordinates, so we have to translate it to item coordinates.
name|exposed
operator|.
name|translate
argument_list|(
name|cache
operator|->
name|boundingRect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|exposedRects
init|=
name|exposed
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exposedRects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|cache
operator|->
name|exposed
operator|+=
name|exposedRects
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// Trigger update. This will redraw the newly exposed area and make sure
comment|// the pixmap is re-blitted in case there are overlapping items.
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsItem::update(qreal x, qreal y, qreal width, qreal height)     \overload      This convenience function is equivalent to calling update(QRectF(\a x, \a     y, \a width, \a height)). */
end_comment
begin_comment
comment|/*!     Maps the point \a point, which is in this item's coordinate system, to \a     item's coordinate system, and returns the mapped coordinate.      If \a item is 0, this function returns the same as mapToScene().      \sa itemTransform(), mapToParent(), mapToScene(), transform(), mapFromItem(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapToItem
name|QPointF
name|QGraphicsItem
operator|::
name|mapToItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|itemTransform
argument_list|(
name|item
argument_list|)
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
return|return
name|mapToScene
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal x, qreal y) const     \overload      This convenience function is equivalent to calling mapToItem(\a item,     QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the point \a point, which is in this item's coordinate system, to its     parent's coordinate system, and returns the mapped coordinate. If the item     has no parent, \a point will be mapped to the scene's coordinate system.      \sa mapToItem(), mapToScene(), transform(), mapFromParent(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapToParent
name|QPointF
name|QGraphicsItem
operator|::
name|mapToParent
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|point
operator|+
name|d_ptr
operator|->
name|pos
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapToParent(qreal x, qreal y) const     \overload      This convenience function is equivalent to calling mapToParent(QPointF(\a     x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the point \a point, which is in this item's coordinate system, to the     scene's coordinate system, and returns the mapped coordinate.      \sa mapToItem(), mapToParent(), transform(), mapFromScene(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapToScene
name|QPointF
name|QGraphicsItem
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|QPointF
argument_list|(
name|point
operator|.
name|x
argument_list|()
operator|+
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|point
operator|.
name|y
argument_list|()
operator|+
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapToScene(qreal x, qreal y) const     \overload      This convenience function is equivalent to calling mapToScene(QPointF(\a     x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in this item's coordinate system, to     \a item's coordinate system, and returns the mapped rectangle as a polygon.      If \a item is 0, this function returns the same as mapToScene().      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapToItem
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|itemTransform
argument_list|(
name|item
argument_list|)
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
return|return
name|mapToScene
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapToItem(item, QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in this item's coordinate system, to     its parent's coordinate system, and returns the mapped rectangle as a     polygon. If the item has no parent, \a rect will be mapped to the scene's     coordinate system.      \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToParent
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToParent
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapToParent(qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapToParent(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in this item's coordinate system, to     the scene's coordinate system, and returns the mapped rectangle as a polygon.      \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToScene
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapToScene(qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapToScene(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in this item's coordinate system, to     \a item's coordinate system, and returns the mapped rectangle as a new     rectangle (i.e., the bounding rectangle of the resulting polygon).      If \a item is 0, this function returns the same as mapRectToScene().      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectToItem
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectToItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|itemTransform
argument_list|(
name|item
argument_list|)
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
return|return
name|mapRectToScene
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectToItem(item, QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in this item's coordinate system, to     its parent's coordinate system, and returns the mapped rectangle as a new     rectangle (i.e., the bounding rectangle of the resulting polygon).      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectToParent
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectToParent
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectToParent(qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectToParent(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in this item's coordinate system, to     the scene coordinate system, and returns the mapped rectangle as a new     rectangle (i.e., the bounding rectangle of the resulting polygon).      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectToScene
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectToScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectToScene(qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectToScene(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in \a item's coordinate system, to     this item's coordinate system, and returns the mapped rectangle as a new     rectangle (i.e., the bounding rectangle of the resulting polygon).      If \a item is 0, this function returns the same as mapRectFromScene().      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectFromItem
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectFromItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
return|return
name|mapRectFromScene
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectFromItem(item, QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in this item's parent's coordinate     system, to this item's coordinate system, and returns the mapped rectangle     as a new rectangle (i.e., the bounding rectangle of the resulting     polygon).      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectFromParent
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectFromParent
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectFromParent(qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectFromParent(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     \since 4.5      Maps the rectangle \a rect, which is in scene coordinates, to this item's     coordinate system, and returns the mapped rectangle as a new rectangle     (i.e., the bounding rectangle of the resulting polygon).      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapRectFromScene
name|QRectF
name|QGraphicsItem
operator|::
name|mapRectFromScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QGraphicsItem::mapRectFromScene(qreal x, qreal y, qreal w, qreal h) const     \since 4.5      This convenience function is equivalent to calling mapRectFromScene(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in this item's coordinate system, to     \a item's coordinate system, and returns the mapped polygon.      If \a item is 0, this function returns the same as mapToScene().      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapToItem
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|itemTransform
argument_list|(
name|item
argument_list|)
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
return|return
name|mapToScene
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in this item's coordinate system, to     its parent's coordinate system, and returns the mapped polygon. If the     item has no parent, \a polygon will be mapped to the scene's coordinate     system.      \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToParent
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToParent
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|polygon
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in this item's coordinate system, to     the scene's coordinate system, and returns the mapped polygon.      \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToScene
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|polygon
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in this item's coordinate system, to     \a item's coordinate system, and returns the mapped path.      If \a item is 0, this function returns the same as mapToScene().      \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapToItem
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapToItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|itemTransform
argument_list|(
name|item
argument_list|)
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
return|return
name|mapToScene
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in this item's coordinate system, to     its parent's coordinate system, and returns the mapped path. If the     item has no parent, \a path will be mapped to the scene's coordinate     system.      \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToParent
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapToParent
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|path
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in this item's coordinate system, to     the scene's coordinate system, and returns the mapped path.      \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapToScene
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapToScene
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|path
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the point \a point, which is in \a item's coordinate system, to this     item's coordinate system, and returns the mapped coordinate.      If \a item is 0, this function returns the same as mapFromScene().      \sa itemTransform(), mapFromParent(), mapFromScene(), transform(), mapToItem(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapFromItem
name|QPointF
name|QGraphicsItem
operator|::
name|mapFromItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
return|return
name|mapFromScene
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal x, qreal y) const     \overload      This convenience function is equivalent to calling mapFromItem(\a item,     QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the point \a point, which is in this item's parent's coordinate     system, to this item's coordinate system, and returns the mapped     coordinate.      \sa mapFromItem(), mapFromScene(), transform(), mapToParent(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapFromParent
name|QPointF
name|QGraphicsItem
operator|::
name|mapFromParent
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
return|return
name|point
operator|-
name|d_ptr
operator|->
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapFromParent(qreal x, qreal y) const     \overload      This convenience function is equivalent to calling     mapFromParent(QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the point \a point, which is in this item's scene's coordinate     system, to this item's coordinate system, and returns the mapped     coordinate.      \sa mapFromItem(), mapFromParent(), transform(), mapToScene(), {The Graphics     View Coordinate System} */
end_comment
begin_function
DECL|function|mapFromScene
name|QPointF
name|QGraphicsItem
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|QPointF
argument_list|(
name|point
operator|.
name|x
argument_list|()
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|point
operator|.
name|y
argument_list|()
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QGraphicsItem::mapFromScene(qreal x, qreal y) const     \overload      This convenience function is equivalent to calling mapFromScene(QPointF(\a     x, \a y)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in \a item's coordinate system, to     this item's coordinate system, and returns the mapped rectangle as a     polygon.      If \a item is 0, this function returns the same as mapFromScene()      \sa itemTransform(), mapToItem(), mapFromParent(), transform(), {The Graphics View Coordinate     System} */
end_comment
begin_function
DECL|function|mapFromItem
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
return|return
name|mapFromScene
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapFromItem(item, QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in this item's parent's coordinate     system, to this item's coordinate system, and returns the mapped rectangle     as a polygon.      \sa mapToParent(), mapFromItem(), transform(), {The Graphics View Coordinate     System} */
end_comment
begin_function
DECL|function|mapFromParent
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromParent
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapFromParent(qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapFromItem(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the rectangle \a rect, which is in this item's scene's coordinate     system, to this item's coordinate system, and returns the mapped rectangle     as a polygon.      \sa mapToScene(), mapFromItem(), transform(), {The Graphics View Coordinate     System} */
end_comment
begin_function
DECL|function|mapFromScene
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|rect
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPolygonF QGraphicsItem::mapFromScene(qreal x, qreal y, qreal w, qreal h) const     \since 4.3      This convenience function is equivalent to calling mapFromScene(QRectF(\a x, \a y, \a w, \a h)). */
end_comment
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in \a item's coordinate system, to     this item's coordinate system, and returns the mapped polygon.      If \a item is 0, this function returns the same as mapFromScene().      \sa itemTransform(), mapToItem(), mapFromParent(), transform(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapFromItem
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
return|return
name|mapFromScene
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in this item's parent's coordinate     system, to this item's coordinate system, and returns the mapped polygon.      \sa mapToParent(), mapToItem(), transform(), {The Graphics View Coordinate     System} */
end_comment
begin_function
DECL|function|mapFromParent
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromParent
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|polygon
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the polygon \a polygon, which is in this item's scene's coordinate     system, to this item's coordinate system, and returns the mapped polygon.      \sa mapToScene(), mapFromParent(), transform(), {The Graphics View Coordinate     System} */
end_comment
begin_function
DECL|function|mapFromScene
name|QPolygonF
name|QGraphicsItem
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|polygon
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|polygon
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in \a item's coordinate system, to     this item's coordinate system, and returns the mapped path.      If \a item is 0, this function returns the same as mapFromScene().      \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The     Graphics View Coordinate System} */
end_comment
begin_function
DECL|function|mapFromItem
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapFromItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|item
condition|)
return|return
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|)
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
return|return
name|mapFromScene
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in this item's parent's coordinate     system, to this item's coordinate system, and returns the mapped path.      \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapFromParent
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapFromParent
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
comment|// COMBINE
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|transformData
condition|)
return|return
name|path
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|pos
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|transformToParent
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Maps the path \a path, which is in this item's scene's coordinate     system, to this item's coordinate system, and returns the mapped path.      \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View     Coordinate System} */
end_comment
begin_function
DECL|function|mapFromScene
name|QPainterPath
name|QGraphicsItem
operator|::
name|mapFromScene
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
return|return
name|path
operator|.
name|translated
argument_list|(
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
operator|-
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
return|;
return|return
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|inverted
argument_list|()
operator|.
name|map
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this item is an ancestor of \a child (i.e., if this item     is \a child's parent, or one of \a child's parent's ancestors).      \sa parentItem() */
end_comment
begin_function
DECL|function|isAncestorOf
name|bool
name|QGraphicsItem
operator|::
name|isAncestorOf
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|child
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|==
name|this
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|child
operator|->
name|d_ptr
operator|->
name|depth
argument_list|()
operator|<
name|d_ptr
operator|->
name|depth
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QGraphicsItem
modifier|*
name|ancestor
init|=
name|child
decl_stmt|;
while|while
condition|(
operator|(
name|ancestor
operator|=
name|ancestor
operator|->
name|d_ptr
operator|->
name|parent
operator|)
condition|)
block|{
if|if
condition|(
name|ancestor
operator|==
name|this
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the closest common ancestor item of this item and \a other, or 0     if either \a other is 0, or there is no common ancestor.      \sa isAncestorOf() */
end_comment
begin_function
DECL|function|commonAncestorItem
name|QGraphicsItem
modifier|*
name|QGraphicsItem
operator|::
name|commonAncestorItem
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|other
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|other
operator|==
name|this
condition|)
return|return
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
specifier|const
name|QGraphicsItem
modifier|*
name|thisw
init|=
name|this
decl_stmt|;
specifier|const
name|QGraphicsItem
modifier|*
name|otherw
init|=
name|other
decl_stmt|;
name|int
name|thisDepth
init|=
name|d_ptr
operator|->
name|depth
argument_list|()
decl_stmt|;
name|int
name|otherDepth
init|=
name|other
operator|->
name|d_ptr
operator|->
name|depth
argument_list|()
decl_stmt|;
while|while
condition|(
name|thisDepth
operator|>
name|otherDepth
condition|)
block|{
name|thisw
operator|=
name|thisw
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
operator|--
name|thisDepth
expr_stmt|;
block|}
while|while
condition|(
name|otherDepth
operator|>
name|thisDepth
condition|)
block|{
name|otherw
operator|=
name|otherw
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
operator|--
name|otherDepth
expr_stmt|;
block|}
while|while
condition|(
name|thisw
operator|&&
name|thisw
operator|!=
name|otherw
condition|)
block|{
name|thisw
operator|=
name|thisw
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
name|otherw
operator|=
name|otherw
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
block|}
return|return
cast|const_cast
argument_list|<
name|QGraphicsItem
operator|*
argument_list|>
argument_list|(
name|thisw
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4,4     Returns true if this item is currently under the mouse cursor in one of     the views; otherwise, false is returned.      \sa QGraphicsScene::views(), QCursor::pos() */
end_comment
begin_function
DECL|function|isUnderMouse
name|bool
name|QGraphicsItem
operator|::
name|isUnderMouse
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scene
condition|)
return|return
literal|false
return|;
name|QPoint
name|cursorPos
init|=
name|QCursor
operator|::
name|pos
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QGraphicsView
modifier|*
name|view
decl|,
name|d
operator|->
name|scene
operator|->
name|views
argument_list|()
control|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|mapFromScene
argument_list|(
name|view
operator|->
name|mapToScene
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|cursorPos
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this item's custom data for the key \a key as a QVariant.      Custom item data is useful for storing arbitrary properties in any     item. Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 11      Qt does not use this feature for storing data; it is provided solely     for the convenience of the user.      \sa setData() */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QGraphicsItem
operator|::
name|data
parameter_list|(
name|int
name|key
parameter_list|)
specifier|const
block|{
name|QGraphicsItemCustomDataStore
modifier|*
name|store
init|=
name|qt_dataStore
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|store
operator|->
name|data
operator|.
name|contains
argument_list|(
name|this
argument_list|)
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|store
operator|->
name|data
operator|.
name|value
argument_list|(
name|this
argument_list|)
operator|.
name|value
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this item's custom data for the key \a key to \a value.      Custom item data is useful for storing arbitrary properties for any     item. Qt does not use this feature for storing data; it is provided solely     for the convenience of the user.      \sa data() */
end_comment
begin_function
DECL|function|setData
name|void
name|QGraphicsItem
operator|::
name|setData
parameter_list|(
name|int
name|key
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|qt_dataStore
argument_list|()
operator|->
name|data
index|[
name|this
index|]
index|[
name|key
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn T qgraphicsitem_cast(QGraphicsItem *item)     \relates QGraphicsItem     \since 4.2      Returns the given \a item cast to type T if \a item is of type T;     otherwise, 0 is returned.      \note To make this function work correctly with custom items, reimplement     the \l{QGraphicsItem::}{type()} function for each custom QGraphicsItem     subclass.      \sa QGraphicsItem::type(), QGraphicsItem::UserType */
end_comment
begin_comment
comment|/*!     Returns the type of an item as an int. All standard graphicsitem classes     are associated with a unique value; see QGraphicsItem::Type. This type     information is used by qgraphicsitem_cast() to distinguish between types.      The default implementation (in QGraphicsItem) returns UserType.      To enable use of qgraphicsitem_cast() with a custom item, reimplement this     function and declare a Type enum value equal to your custom item's type.     Custom items must return a value larger than or equal to UserType (65536).      For example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp QGraphicsItem type      \sa UserType */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|int
operator|)
name|UserType
return|;
block|}
end_function
begin_comment
comment|/*!     Installs an event filter for this item on \a filterItem, causing     all events for this item to first pass through \a filterItem's     sceneEventFilter() function.      To filter another item's events, install this item as an event filter     for the other item. Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 12      An item can only filter events for other items in the same     scene. Also, an item cannot filter its own events; instead, you     can reimplement sceneEvent() directly.      Items must belong to a scene for scene event filters to be installed and     used.      \sa removeSceneEventFilter(), sceneEventFilter(), sceneEvent() */
end_comment
begin_function
DECL|function|installSceneEventFilter
name|void
name|QGraphicsItem
operator|::
name|installSceneEventFilter
parameter_list|(
name|QGraphicsItem
modifier|*
name|filterItem
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::installSceneEventFilter: event filters can only be installed"
literal|" on items in a scene."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
operator|!=
name|filterItem
operator|->
name|scene
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItem::installSceneEventFilter: event filters can only be installed"
literal|" on items in the same scene."
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|installSceneEventFilter
argument_list|(
name|this
argument_list|,
name|filterItem
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes an event filter on this item from \a filterItem.      \sa installSceneEventFilter() */
end_comment
begin_function
DECL|function|removeSceneEventFilter
name|void
name|QGraphicsItem
operator|::
name|removeSceneEventFilter
parameter_list|(
name|QGraphicsItem
modifier|*
name|filterItem
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|scene
operator|||
name|d_ptr
operator|->
name|scene
operator|!=
name|filterItem
operator|->
name|scene
argument_list|()
condition|)
return|return;
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|removeSceneEventFilter
argument_list|(
name|this
argument_list|,
name|filterItem
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Filters events for the item \a watched. \a event is the filtered     event.      Reimplementing this function in a subclass makes it possible     for the item to be used as an event filter for other items,     intercepting all the events send to those items before they are     able to respond.      Reimplementations must return true to prevent further processing of     a given event, ensuring that it will not be delivered to the watched     item, or return false to indicate that the event should be propagated     further by the event system.      \sa installSceneEventFilter() */
end_comment
begin_function
DECL|function|sceneEventFilter
name|bool
name|QGraphicsItem
operator|::
name|sceneEventFilter
parameter_list|(
name|QGraphicsItem
modifier|*
name|watched
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|watched
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     This virtual function receives events to this item. Reimplement     this function to intercept events before they are dispatched to     the specialized event handlers contextMenuEvent(), focusInEvent(),     focusOutEvent(), hoverEnterEvent(), hoverMoveEvent(),     hoverLeaveEvent(), keyPressEvent(), keyReleaseEvent(),     mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), and     mouseDoubleClickEvent().      Returns true if the event was recognized and handled; otherwise, (e.g., if     the event type was not recognized,) false is returned.      \a event is the intercepted event. */
end_comment
begin_function
DECL|function|sceneEvent
name|bool
name|QGraphicsItem
operator|::
name|sceneEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorHandlesChildEvents
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|HoverEnter
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|HoverLeave
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragEnter
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DragLeave
condition|)
block|{
comment|// Hover enter and hover leave events for children are ignored;
comment|// hover move events are forwarded.
return|return
literal|true
return|;
block|}
name|QGraphicsItem
modifier|*
name|handler
init|=
name|this
decl_stmt|;
do|do
block|{
name|handler
operator|=
name|handler
operator|->
name|d_ptr
operator|->
name|parent
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|handler
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|handler
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorHandlesChildEvents
condition|)
do|;
comment|// Forward the event to the closest parent that handles child
comment|// events, mapping existing item-local coordinates to its
comment|// coordinate system.
name|d_ptr
operator|->
name|remapItemPos
argument_list|(
name|event
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|handler
operator|->
name|sceneEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FocusOut
condition|)
block|{
name|focusOutEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|visible
condition|)
block|{
comment|// Eaten
return|return
literal|true
return|;
block|}
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|FocusIn
case|:
name|focusInEvent
argument_list|(
cast|static_cast
argument_list|<
name|QFocusEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneContextMenu
case|:
name|contextMenuEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneContextMenuEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDragEnter
case|:
name|dragEnterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDragMove
case|:
name|dragMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDragLeave
case|:
name|dragLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneDrop
case|:
name|dropEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneDragDropEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
case|:
name|hoverEnterEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
name|hoverMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
name|hoverLeaveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneHoverEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
name|mouseMoveEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
name|mousePressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
name|mouseReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
name|mouseDoubleClickEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneMouseEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|GraphicsSceneWheel
case|:
name|wheelEvent
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsSceneWheelEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|KeyPress
case|:
block|{
name|QKeyEvent
modifier|*
name|k
init|=
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
operator|(
name|Qt
operator|::
name|ControlModifier
operator||
name|Qt
operator|::
name|AltModifier
operator|)
operator|)
condition|)
block|{
comment|//### Add MetaModifier?
name|bool
name|res
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Backtab
operator|||
operator|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
operator|&&
operator|(
name|k
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ShiftModifier
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|isWidget
condition|)
block|{
name|res
operator|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|res
operator|=
name|d_ptr
operator|->
name|scene
operator|->
name|focusNextPrevChild
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|key
argument_list|()
operator|==
name|Qt
operator|::
name|Key_Tab
condition|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|isWidget
condition|)
block|{
name|res
operator|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|res
operator|=
name|d_ptr
operator|->
name|scene
operator|->
name|focusNextPrevChild
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|res
condition|)
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|keyPressEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
name|keyReleaseEvent
argument_list|(
cast|static_cast
argument_list|<
name|QKeyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|InputMethod
case|:
name|inputMethodEvent
argument_list|(
cast|static_cast
argument_list|<
name|QInputMethodEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|WindowActivate
case|:
case|case
name|QEvent
operator|::
name|WindowDeactivate
case|:
comment|// Propagate panel activation.
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d_ptr
operator|->
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QGraphicsItem
modifier|*
name|child
init|=
name|d_ptr
operator|->
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|isVisible
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isPanel
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorHandlesChildEvents
operator|)
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|sendEvent
argument_list|(
name|child
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to process context     menu events. The \a event parameter contains details about the event to     be handled.      If you ignore the event, (i.e., by calling QEvent::ignore(),) \a event     will propagate to any item beneath this item. If no items accept the     event, it will be ignored by the scene, and propagate to the view.      It's common to open a QMenu in response to receiving a context menu     event. Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 13      The default implementation ignores the event.      \sa sceneEvent() */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QGraphicsItem
operator|::
name|contextMenuEvent
parameter_list|(
name|QGraphicsSceneContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     drag enter events for this item. Drag enter events are generated as the     cursor enters the item's area.      By accepting the event, (i.e., by calling QEvent::accept(),) the item will     accept drop events, in addition to receiving drag move and drag     leave. Otherwise, the event will be ignored and propagate to the item     beneath. If the event is accepted, the item will receive a drag move event     before control goes back to the event loop.      A common implementation of dragEnterEvent accepts or ignores \a event     depending on the associated mime data in \a event. Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 14      Items do not receive drag and drop events by default; to enable this     feature, call \c setAcceptDrops(true).      The default implementation does nothing.      \sa dropEvent(), dragMoveEvent(), dragLeaveEvent() */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QGraphicsItem
operator|::
name|dragEnterEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// binary compatibility workaround between 4.4 and 4.5
if|if
condition|(
name|d
operator|->
name|isProxyWidget
argument_list|()
condition|)
cast|static_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|dragEnterEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     drag leave events for this item. Drag leave events are generated as the     cursor leaves the item's area. Most often you will not need to reimplement     this function, but it can be useful for resetting state in your item     (e.g., highlighting).      Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.      Items do not receive drag and drop events by default; to enable this     feature, call \c setAcceptDrops(true).      The default implementation does nothing.      \sa dragEnterEvent(), dropEvent(), dragMoveEvent() */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QGraphicsItem
operator|::
name|dragLeaveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// binary compatibility workaround between 4.4 and 4.5
if|if
condition|(
name|d
operator|->
name|isProxyWidget
argument_list|()
condition|)
cast|static_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|dragLeaveEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     drag move events for this item. Drag move events are generated as the     cursor moves around inside the item's area. Most often you will not need     to reimplement this function; it is used to indicate that only parts of     the item can accept drops.      Calling QEvent::ignore() or QEvent::accept() on \a event toggles whether     or not the item will accept drops at the position from the event. By     default, \a event is accepted, indicating that the item allows drops at     the specified position.      Items do not receive drag and drop events by default; to enable this     feature, call \c setAcceptDrops(true).      The default implementation does nothing.      \sa dropEvent(), dragEnterEvent(), dragLeaveEvent() */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QGraphicsItem
operator|::
name|dragMoveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// binary compatibility workaround between 4.4 and 4.5
if|if
condition|(
name|d
operator|->
name|isProxyWidget
argument_list|()
condition|)
cast|static_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|dragMoveEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     drop events for this item. Items can only receive drop events if the last     drag move event was accepted.      Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.      Items do not receive drag and drop events by default; to enable this     feature, call \c setAcceptDrops(true).      The default implementation does nothing.      \sa dragEnterEvent(), dragMoveEvent(), dragLeaveEvent() */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QGraphicsItem
operator|::
name|dropEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
comment|// binary compatibility workaround between 4.4 and 4.5
if|if
condition|(
name|d
operator|->
name|isProxyWidget
argument_list|()
condition|)
cast|static_cast
argument_list|<
name|QGraphicsProxyWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|dropEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     focus in events for this item. The default implementation calls     ensureVisible().      \sa focusOutEvent(), sceneEvent(), setFocus() */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QGraphicsItem
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     focus out events for this item. The default implementation does nothing.      \sa focusInEvent(), sceneEvent(), setFocus() */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QGraphicsItem
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     hover enter events for this item. The default implementation calls     update(); otherwise it does nothing.      Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.      \sa hoverMoveEvent(), hoverLeaveEvent(), sceneEvent(), setAcceptHoverEvents() */
end_comment
begin_function
DECL|function|hoverEnterEvent
name|void
name|QGraphicsItem
operator|::
name|hoverEnterEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     hover move events for this item. The default implementation does nothing.      Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.      \sa hoverEnterEvent(), hoverLeaveEvent(), sceneEvent(), setAcceptHoverEvents() */
end_comment
begin_function
DECL|function|hoverMoveEvent
name|void
name|QGraphicsItem
operator|::
name|hoverMoveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     hover leave events for this item. The default implementation calls     update(); otherwise it does nothing.      Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.      \sa hoverEnterEvent(), hoverMoveEvent(), sceneEvent(), setAcceptHoverEvents() */
end_comment
begin_function
DECL|function|hoverLeaveEvent
name|void
name|QGraphicsItem
operator|::
name|hoverLeaveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to     receive key press events for this item. The default implementation     ignores the event. If you reimplement this handler, the event will by     default be accepted.      Note that key events are only received for items that set the     ItemIsFocusable flag, and that have keyboard input focus.      \sa keyReleaseEvent(), setFocus(), QGraphicsScene::setFocusItem(),     sceneEvent() */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QGraphicsItem
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     key release events for this item. The default implementation     ignores the event. If you reimplement this handler, the event will by     default be accepted.      Note that key events are only received for items that set the     ItemIsFocusable flag, and that have keyboard input focus.      \sa keyPressEvent(), setFocus(), QGraphicsScene::setFocusItem(),     sceneEvent() */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QGraphicsItem
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to     receive mouse press events for this item. Mouse press events are     only delivered to items that accept the mouse button that is     pressed. By default, an item accepts all mouse buttons, but you     can change this by calling setAcceptedMouseButtons().      The mouse press event decides which item should become the mouse     grabber (see QGraphicsScene::mouseGrabberItem()). If you do not     reimplement this function, the press event will propagate to any     topmost item beneath this item, and no other mouse events will be     delivered to this item.      If you do reimplement this function, \a event will by default be     accepted (see QEvent::accept()), and this item is then the mouse     grabber. This allows the item to receive future move, release and     doubleclick events. If you call QEvent::ignore() on \a event, this     item will lose the mouse grab, and \a event will propagate to any     topmost item beneath. No further mouse events will be delivered to     this item unless a new mouse press event is received.      The default implementation handles basic item interaction, such as     selection and moving. If you want to keep the base implementation     when reimplementing this function, call     QGraphicsItem::mousePressEvent() in your reimplementation.      The event is \l{QEvent::ignore()}d for items that are neither     \l{QGraphicsItem::ItemIsMovable}{movable} nor     \l{QGraphicsItem::ItemIsSelectable}{selectable}.      \sa mouseMoveEvent(), mouseReleaseEvent(),     mouseDoubleClickEvent(), sceneEvent() */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QGraphicsItem
operator|::
name|mousePressEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|button
argument_list|()
operator|==
name|Qt
operator|::
name|LeftButton
operator|&&
operator|(
name|flags
argument_list|()
operator|&
name|ItemIsSelectable
operator|)
condition|)
block|{
name|bool
name|multiSelect
init|=
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|multiSelect
condition|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|selected
condition|)
block|{
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scene
init|=
name|d_ptr
operator|->
name|scene
condition|)
block|{
operator|++
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectionChanging
expr_stmt|;
name|scene
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
operator|--
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectionChanging
expr_stmt|;
block|}
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
argument_list|()
operator|&
name|ItemIsMovable
operator|)
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|isWidget
condition|)
block|{
comment|// Qt::Popup closes when you click outside.
name|QGraphicsWidget
modifier|*
name|w
init|=
cast|static_cast
argument_list|<
name|QGraphicsWidget
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|windowFlags
argument_list|()
operator|&
name|Qt
operator|::
name|Popup
operator|)
operator|==
name|Qt
operator|::
name|Popup
condition|)
block|{
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
name|w
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     obsolete */
end_comment
begin_function
DECL|function|_qt_movableAncestorIsSelected
name|bool
name|_qt_movableAncestorIsSelected
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|parent
init|=
name|item
operator|->
name|parentItem
argument_list|()
decl_stmt|;
return|return
name|parent
operator|&&
operator|(
operator|(
operator|(
name|parent
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsMovable
operator|)
operator|&&
name|parent
operator|->
name|isSelected
argument_list|()
operator|)
operator|||
name|_qt_movableAncestorIsSelected
argument_list|(
name|parent
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|movableAncestorIsSelected
name|bool
name|QGraphicsItemPrivate
operator|::
name|movableAncestorIsSelected
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|QGraphicsItem
modifier|*
name|parent
init|=
name|item
operator|->
name|d_ptr
operator|->
name|parent
decl_stmt|;
return|return
name|parent
operator|&&
operator|(
operator|(
operator|(
name|parent
operator|->
name|flags
argument_list|()
operator|&
name|QGraphicsItem
operator|::
name|ItemIsMovable
operator|)
operator|&&
name|parent
operator|->
name|isSelected
argument_list|()
operator|)
operator|||
name|_qt_movableAncestorIsSelected
argument_list|(
name|parent
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to     receive mouse move events for this item. If you do receive this     event, you can be certain that this item also received a mouse     press event, and that this item is the current mouse grabber.      Calling QEvent::ignore() or QEvent::accept() on \a event has no     effect.      The default implementation handles basic item interaction, such as     selection and moving. If you want to keep the base implementation     when reimplementing this function, call     QGraphicsItem::mouseMoveEvent() in your reimplementation.      Please note that mousePressEvent() decides which graphics item it     is that receives mouse events. See the mousePressEvent()     description for details.      \sa mousePressEvent(), mouseReleaseEvent(),     mouseDoubleClickEvent(), sceneEvent() */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QGraphicsItem
operator|::
name|mouseMoveEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
operator|&&
operator|(
name|flags
argument_list|()
operator|&
name|ItemIsMovable
operator|)
condition|)
block|{
comment|// Determine the list of items that need to be moved.
name|QList
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|>
name|selectedItems
decl_stmt|;
name|QHash
argument_list|<
name|QGraphicsItem
modifier|*
argument_list|,
name|QPointF
argument_list|>
name|initialPositions
decl_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|selectedItems
operator|=
name|d_ptr
operator|->
name|scene
operator|->
name|selectedItems
argument_list|()
expr_stmt|;
name|initialPositions
operator|=
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|movingItemsInitialPositions
expr_stmt|;
if|if
condition|(
name|initialPositions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|selectedItems
control|)
name|initialPositions
index|[
name|item
index|]
operator|=
name|item
operator|->
name|pos
argument_list|()
expr_stmt|;
name|initialPositions
index|[
name|this
index|]
operator|=
name|pos
argument_list|()
expr_stmt|;
block|}
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|movingItemsInitialPositions
operator|=
name|initialPositions
expr_stmt|;
block|}
comment|// Find the active view.
name|QGraphicsView
modifier|*
name|view
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|widget
argument_list|()
condition|)
name|view
operator|=
name|qobject_cast
argument_list|<
name|QGraphicsView
operator|*
argument_list|>
argument_list|(
name|event
operator|->
name|widget
argument_list|()
operator|->
name|parentWidget
argument_list|()
argument_list|)
expr_stmt|;
comment|// Move all selected items
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|movedMe
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|selectedItems
operator|.
name|size
argument_list|()
condition|)
block|{
name|QGraphicsItem
modifier|*
name|item
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|selectedItems
operator|.
name|size
argument_list|()
condition|)
name|item
operator|=
name|selectedItems
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|item
operator|=
name|this
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|this
condition|)
block|{
comment|// Slightly clumsy-looking way to ensure that "this" is part
comment|// of the list of items to move, this is to avoid allocations
comment|// (appending this item to the list of selected items causes a
comment|// detach).
if|if
condition|(
name|movedMe
condition|)
break|break;
name|movedMe
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|ItemIsMovable
operator|)
operator|&&
operator|!
name|QGraphicsItemPrivate
operator|::
name|movableAncestorIsSelected
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|QPointF
name|currentParentPos
decl_stmt|;
name|QPointF
name|buttonDownParentPos
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorIgnoresTransformations
condition|)
block|{
comment|// Items whose ancestors ignore transformations need to
comment|// map screen coordinates to local coordinates, then map
comment|// those to the parent.
name|QTransform
name|viewToItemTransform
init|=
operator|(
name|item
operator|->
name|deviceTransform
argument_list|(
name|view
operator|->
name|viewportTransform
argument_list|()
argument_list|)
operator|)
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|currentParentPos
operator|=
name|mapToParent
argument_list|(
name|viewToItemTransform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buttonDownParentPos
operator|=
name|mapToParent
argument_list|(
name|viewToItemTransform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|event
operator|->
name|buttonDownScreenPos
argument_list|(
name|Qt
operator|::
name|LeftButton
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|ItemIgnoresTransformations
condition|)
block|{
comment|// Root items that ignore transformations need to
comment|// calculate their diff by mapping viewport coordinates
comment|// directly to parent coordinates.
comment|// COMBINE
name|QTransform
name|itemTransform
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|d_ptr
operator|->
name|transformData
condition|)
name|itemTransform
operator|=
name|item
operator|->
name|d_ptr
operator|->
name|transformData
operator|->
name|computedFullTransform
argument_list|()
expr_stmt|;
name|itemTransform
operator|.
name|translate
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|item
operator|->
name|d_ptr
operator|->
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|QTransform
name|viewToParentTransform
init|=
name|itemTransform
operator|*
operator|(
name|item
operator|->
name|sceneTransform
argument_list|()
operator|*
name|view
operator|->
name|viewportTransform
argument_list|()
operator|)
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|currentParentPos
operator|=
name|viewToParentTransform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|event
operator|->
name|screenPos
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buttonDownParentPos
operator|=
name|viewToParentTransform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|view
operator|->
name|mapFromGlobal
argument_list|(
name|event
operator|->
name|buttonDownScreenPos
argument_list|(
name|Qt
operator|::
name|LeftButton
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// All other items simply map from the scene.
name|currentParentPos
operator|=
name|item
operator|->
name|mapToParent
argument_list|(
name|item
operator|->
name|mapFromScene
argument_list|(
name|event
operator|->
name|scenePos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|buttonDownParentPos
operator|=
name|item
operator|->
name|mapToParent
argument_list|(
name|item
operator|->
name|mapFromScene
argument_list|(
name|event
operator|->
name|buttonDownScenePos
argument_list|(
name|Qt
operator|::
name|LeftButton
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|setPos
argument_list|(
name|initialPositions
operator|.
name|value
argument_list|(
name|item
argument_list|)
operator|+
name|currentParentPos
operator|-
name|buttonDownParentPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
argument_list|()
operator|&
name|ItemIsSelectable
condition|)
name|item
operator|->
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to     receive mouse release events for this item.      Calling QEvent::ignore() or QEvent::accept() on \a event has no     effect.      The default implementation handles basic item interaction, such as     selection and moving. If you want to keep the base implementation     when reimplementing this function, call     QGraphicsItem::mouseReleaseEvent() in your reimplementation.      Please note that mousePressEvent() decides which graphics item it     is that receives mouse events. See the mousePressEvent()     description for details.      \sa mousePressEvent(), mouseMoveEvent(), mouseDoubleClickEvent(),     sceneEvent() */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QGraphicsItem
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|flags
argument_list|()
operator|&
name|ItemIsSelectable
condition|)
block|{
name|bool
name|multiSelect
init|=
operator|(
name|event
operator|->
name|modifiers
argument_list|()
operator|&
name|Qt
operator|::
name|ControlModifier
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|scenePos
argument_list|()
operator|==
name|event
operator|->
name|buttonDownScenePos
argument_list|(
name|Qt
operator|::
name|LeftButton
argument_list|)
condition|)
block|{
comment|// The item didn't move
if|if
condition|(
name|multiSelect
condition|)
block|{
name|setSelected
argument_list|(
operator|!
name|isSelected
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|selectionChanged
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|QGraphicsScene
modifier|*
name|scene
init|=
name|d_ptr
operator|->
name|scene
condition|)
block|{
operator|++
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectionChanging
expr_stmt|;
comment|// Clear everything but this item. Bypass
comment|// QGraphicsScene::clearSelection()'s default behavior by
comment|// temporarily removing this item from the selection list.
if|if
condition|(
name|d_ptr
operator|->
name|selected
condition|)
block|{
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectedItems
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|QGraphicsItem
modifier|*
name|item
decl|,
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectedItems
control|)
block|{
if|if
condition|(
name|item
operator|->
name|isSelected
argument_list|()
condition|)
block|{
name|selectionChanged
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|scene
operator|->
name|clearSelection
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|selected
condition|)
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectedItems
operator|.
name|insert
argument_list|(
name|this
argument_list|)
expr_stmt|;
operator|--
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|selectionChanging
expr_stmt|;
if|if
condition|(
name|selectionChanged
condition|)
emit|emit
name|d_ptr
operator|->
name|scene
operator|->
name|selectionChanged
argument_list|()
emit|;
block|}
name|setSelected
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|movingItemsInitialPositions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to     receive mouse doubleclick events for this item.      When doubleclicking an item, the item will first receive a mouse     press event, followed by a release event (i.e., a click), then a     doubleclick event, and finally a release event.      Calling QEvent::ignore() or QEvent::accept() on \a event has no     effect.      The default implementation calls mousePressEvent(). If you want to     keep the base implementation when reimplementing this function,     call QGraphicsItem::mouseDoubleClickEvent() in your     reimplementation.      Note that an item will not receive double click events if it is     neither \l {QGraphicsItem::ItemIsSelectable}{selectable} nor     \l{QGraphicsItem::ItemIsMovable}{movable} (single mouse clicks are     ignored in this case, and that stops the generation of double     clicks).      \sa mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), sceneEvent() */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QGraphicsItem
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|mousePressEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     wheel events for this item. If you reimplement this function, \a event     will be accepted by default.      If you ignore the event, (i.e., by calling QEvent::ignore(),) it will     propagate to any item beneath this item. If no items accept the event, it     will be ignored by the scene, and propagate to the view (e.g., the view's     vertical scroll bar).      The default implementation ignores the event.      \sa sceneEvent() */
end_comment
begin_function
DECL|function|wheelEvent
name|void
name|QGraphicsItem
operator|::
name|wheelEvent
parameter_list|(
name|QGraphicsSceneWheelEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This event handler, for event \a event, can be reimplemented to receive     input method events for this item. The default implementation ignores the     event.      \sa inputMethodQuery(), sceneEvent() */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QGraphicsItem
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This method is only relevant for input items. It is used by the     input method to query a set of properties of the item to be able     to support complex input method operations, such as support for     surrounding text and reconversions. \a query specifies which     property is queried.      \sa inputMethodEvent(), QInputMethodEvent */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QGraphicsItem
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current input method hints of this item.      Input method hints are only relevant for input items.     The hints are used by the input method to indicate how it should operate.     For example, if the Qt::ImhNumbersOnly flag is set, the input method may change     its visual components to reflect that only numbers can be entered.      The effect may vary between input method implementations.      \since 4.6      \sa setInputMethodHints(), inputMethodQuery() */
end_comment
begin_function
DECL|function|inputMethodHints
name|Qt
operator|::
name|InputMethodHints
name|QGraphicsItem
operator|::
name|inputMethodHints
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|imHints
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the current input method hints of this item to \a hints.      \since 4.6      \sa inputMethodHints(), inputMethodQuery() */
end_comment
begin_function
DECL|function|setInputMethodHints
name|void
name|QGraphicsItem
operator|::
name|setInputMethodHints
parameter_list|(
name|Qt
operator|::
name|InputMethodHints
name|hints
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
name|d
operator|->
name|imHints
operator|=
name|hints
expr_stmt|;
if|if
condition|(
operator|!
name|hasFocus
argument_list|()
condition|)
return|return;
name|d
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|updateInputMethodSensitivityInViews
argument_list|()
expr_stmt|;
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fw
condition|)
return|return;
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImHints
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Updates the item's micro focus.      \since 4.7      \sa QInputMethod */
end_comment
begin_function
DECL|function|updateMicroFocus
name|void
name|QGraphicsItem
operator|::
name|updateMicroFocus
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_IM
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|)
if|if
condition|(
name|QWidget
modifier|*
name|fw
init|=
name|QApplication
operator|::
name|focusWidget
argument_list|()
condition|)
block|{
if|if
condition|(
name|scene
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|scene
argument_list|()
operator|->
name|views
argument_list|()
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|fw
condition|)
block|{
if|if
condition|(
name|qApp
condition|)
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImQueryAll
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
comment|// ##### is this correct
if|if
condition|(
name|toGraphicsObject
argument_list|()
condition|)
name|QAccessible
operator|::
name|updateAccessibility
argument_list|(
name|toGraphicsObject
argument_list|()
argument_list|,
literal|0
argument_list|,
name|QAccessible
operator|::
name|StateChanged
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
unit|}
comment|/*!     This virtual function is called by QGraphicsItem to notify custom items     that some part of the item's state changes. By reimplementing this     function, your can react to a change, and in some cases, (depending on \a     change,) adjustments can be made.      \a change is the parameter of the item that is changing. \a value is the     new value; the type of the value depends on \a change.      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 15      The default implementation does nothing, and returns \a value.      Note: Certain QGraphicsItem functions cannot be called in a     reimplementation of this function; see the GraphicsItemChange     documentation for details.      \sa GraphicsItemChange */
end_comment
begin_macro
unit|QVariant
DECL|function|itemChange
name|QGraphicsItem
end_macro
begin_expr_stmt
DECL|function|itemChange
operator|::
name|itemChange
operator|(
name|GraphicsItemChange
name|change
operator|,
specifier|const
name|QVariant
operator|&
name|value
operator|)
block|{
name|Q_UNUSED
argument_list|(
name|change
argument_list|)
block|;
return|return
name|value
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     \internal      Note: This is provided as a hook to avoid future problems related     to adding virtual functions. */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Note: This is provided as a hook to avoid future problems related     to adding virtual functions. */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Note: This is provided as a hook to avoid future problems related     to adding virtual functions. */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Adds this item to the scene's index. Called in conjunction with     removeFromIndex() to ensure the index bookkeeping is correct when     the item's position, transformation or shape changes. */
end_comment
begin_function
DECL|function|addToIndex
name|void
name|QGraphicsItem
operator|::
name|addToIndex
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
condition|)
block|{
comment|// ### add to child index only if applicable
return|return;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|->
name|addItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Removes this item from the scene's index. Called in conjunction     with addToIndex() to ensure the index bookkeeping is correct when     the item's position, transformation or shape changes. */
end_comment
begin_function
DECL|function|removeFromIndex
name|void
name|QGraphicsItem
operator|::
name|removeFromIndex
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|ancestorFlags
operator|&
name|QGraphicsItemPrivate
operator|::
name|AncestorClipsChildren
condition|)
block|{
comment|// ### remove from child index only if applicable
return|return;
block|}
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|index
operator|->
name|removeItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Prepares the item for a geometry change. Call this function before     changing the bounding rect of an item to keep QGraphicsScene's index up to     date.      prepareGeometryChange() will call update() if this is necessary.      Example:      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 16      \sa boundingRect() */
end_comment
begin_function
DECL|function|prepareGeometryChange
name|void
name|QGraphicsItem
operator|::
name|prepareGeometryChange
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
operator|->
name|inDestructor
condition|)
return|return;
if|if
condition|(
name|d_ptr
operator|->
name|scene
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|dirtyGrowingItemsBoundingRect
operator|=
literal|true
expr_stmt|;
name|d_ptr
operator|->
name|geometryChanged
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|paintedViewBoundingRectsNeedRepaint
operator|=
literal|1
expr_stmt|;
name|d_ptr
operator|->
name|notifyBoundingRectChanged
operator|=
operator|!
name|d_ptr
operator|->
name|inSetPosHelper
expr_stmt|;
name|QGraphicsScenePrivate
modifier|*
name|scenePrivate
init|=
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|scenePrivate
operator|->
name|index
operator|->
name|prepareBoundingRectChange
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|scenePrivate
operator|->
name|markDirty
argument_list|(
name|this
argument_list|,
name|QRectF
argument_list|()
argument_list|,
comment|/*invalidateChildren=*/
literal|true
argument_list|,
comment|/*force=*/
literal|false
argument_list|,
comment|/*ignoreOpacity=*/
literal|false
argument_list|,
comment|/*removingItemFromScene=*/
literal|false
argument_list|,
comment|/*updateBoundingRect=*/
literal|true
argument_list|)
expr_stmt|;
comment|// For compatibility reasons, we have to update the item's old geometry
comment|// if someone is connected to the changed signal or the scene has no views.
comment|// Note that this has to be done *after* markDirty to ensure that
comment|// _q_processDirtyItems is called before _q_emitUpdated.
if|if
condition|(
name|scenePrivate
operator|->
name|isSignalConnected
argument_list|(
name|scenePrivate
operator|->
name|changedSignalIndex
argument_list|)
operator|||
name|scenePrivate
operator|->
name|views
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|hasTranslateOnlySceneTransform
argument_list|()
condition|)
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|update
argument_list|(
name|boundingRect
argument_list|()
operator|.
name|translated
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|dy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d_ptr
operator|->
name|scene
operator|->
name|update
argument_list|(
name|d_ptr
operator|->
name|sceneTransform
operator|.
name|mapRect
argument_list|(
name|boundingRect
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|d_ptr
operator|->
name|markParentDirty
argument_list|(
comment|/*updateBoundingRect=*/
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Highlights \a item as selected.      NOTE: This function is a duplicate of qt_graphicsItem_highlightSelected() in           qgraphicssvgitem.cpp! */
end_comment
begin_function
DECL|function|qt_graphicsItem_highlightSelected
specifier|static
name|void
name|qt_graphicsItem_highlightSelected
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|)
block|{
specifier|const
name|QRectF
name|murect
init|=
name|painter
operator|->
name|transform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|qFuzzyIsNull
argument_list|(
name|qMax
argument_list|(
name|murect
operator|.
name|width
argument_list|()
argument_list|,
name|murect
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
condition|)
return|return;
specifier|const
name|QRectF
name|mbrect
init|=
name|painter
operator|->
name|transform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qMin
argument_list|(
name|mbrect
operator|.
name|width
argument_list|()
argument_list|,
name|mbrect
operator|.
name|height
argument_list|()
argument_list|)
operator|<
name|qreal
argument_list|(
literal|1.0
argument_list|)
condition|)
return|return;
name|qreal
name|itemPenWidth
decl_stmt|;
switch|switch
condition|(
name|item
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QGraphicsEllipseItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsEllipseItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsPathItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsPathItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsPolygonItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsPolygonItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsRectItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsRectItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsSimpleTextItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsSimpleTextItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
case|case
name|QGraphicsLineItem
operator|::
name|Type
case|:
name|itemPenWidth
operator|=
cast|static_cast
argument_list|<
name|QGraphicsLineItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
expr_stmt|;
break|break;
default|default:
name|itemPenWidth
operator|=
literal|1.0
expr_stmt|;
block|}
specifier|const
name|qreal
name|pad
init|=
name|itemPenWidth
operator|/
literal|2
decl_stmt|;
specifier|const
name|qreal
name|penWidth
init|=
literal|0
decl_stmt|;
comment|// cosmetic pen
specifier|const
name|QColor
name|fgcolor
init|=
name|option
operator|->
name|palette
operator|.
name|windowText
argument_list|()
operator|.
name|color
argument_list|()
decl_stmt|;
specifier|const
name|QColor
name|bgcolor
argument_list|(
comment|// ensure good contrast against fgcolor
name|fgcolor
operator|.
name|red
argument_list|()
operator|>
literal|127
condition|?
literal|0
else|:
literal|255
argument_list|,
name|fgcolor
operator|.
name|green
argument_list|()
operator|>
literal|127
condition|?
literal|0
else|:
literal|255
argument_list|,
name|fgcolor
operator|.
name|blue
argument_list|()
operator|>
literal|127
condition|?
literal|0
else|:
literal|255
argument_list|)
decl_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|bgcolor
argument_list|,
name|penWidth
argument_list|,
name|Qt
operator|::
name|SolidLine
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
operator|.
name|adjusted
argument_list|(
name|pad
argument_list|,
name|pad
argument_list|,
operator|-
name|pad
argument_list|,
operator|-
name|pad
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|option
operator|->
name|palette
operator|.
name|windowText
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|DashLine
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
operator|.
name|adjusted
argument_list|(
name|pad
argument_list|,
name|pad
argument_list|,
operator|-
name|pad
argument_list|,
operator|-
name|pad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsObject     \brief The QGraphicsObject class provides a base class for all graphics items that     require signals, slots and properties.     \since 4.6     \ingroup graphicsview-api     \inmodule QtWidgets      The class extends a QGraphicsItem with QObject's signal/slot and property mechanisms.     It maps many of QGraphicsItem's basic setters and getters to properties and adds notification     signals for many of them.      \section1 Parents and Children      Each graphics object can be constructed with a parent item. This ensures that the     item will be destroyed when its parent item is destroyed. Although QGraphicsObject     inherits from both QObject and QGraphicsItem, you should use the functions provided     by QGraphicsItem, \e not QObject, to manage the relationships between parent and     child items.      The relationships between items can be explored using the parentItem() and childItems()     functions. In the hierarchy of items in a scene, the parentObject() and parentWidget()     functions are the equivalent of the QWidget::parent() and QWidget::parentWidget()     functions for QWidget subclasses.      \sa QGraphicsWidget */
end_comment
begin_comment
comment|/*!     Constructs a QGraphicsObject with \a parent. */
end_comment
begin_constructor
DECL|function|QGraphicsObject
name|QGraphicsObject
operator|::
name|QGraphicsObject
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
name|parent
argument_list|)
block|{
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|isObject
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QGraphicsObject
name|QGraphicsObject
operator|::
name|QGraphicsObject
parameter_list|(
name|QGraphicsItemPrivate
modifier|&
name|dd
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|isObject
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_comment
comment|/*!     Subscribes the graphics object to the given \a gesture with specific \a flags.      \sa ungrabGesture(), QGestureEvent */
end_comment
begin_function
DECL|function|grabGesture
name|void
name|QGraphicsObject
operator|::
name|grabGesture
parameter_list|(
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|,
name|Qt
operator|::
name|GestureFlags
name|flags
parameter_list|)
block|{
name|bool
name|contains
init|=
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|gestureContext
operator|.
name|contains
argument_list|(
name|gesture
argument_list|)
decl_stmt|;
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|gestureContext
operator|.
name|insert
argument_list|(
name|gesture
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contains
operator|&&
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|scene
condition|)
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|grabGesture
argument_list|(
name|this
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Unsubscribes the graphics object from the given \a gesture.      \sa grabGesture(), QGestureEvent */
end_comment
begin_function
DECL|function|ungrabGesture
name|void
name|QGraphicsObject
operator|::
name|ungrabGesture
parameter_list|(
name|Qt
operator|::
name|GestureType
name|gesture
parameter_list|)
block|{
if|if
condition|(
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|gestureContext
operator|.
name|remove
argument_list|(
name|gesture
argument_list|)
operator|&&
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|scene
condition|)
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
operator|->
name|ungrabGesture
argument_list|(
name|this
argument_list|,
name|gesture
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_comment
comment|/*!     Updates the item's micro focus. This is slot for convenience.      \since 4.7      \sa QInputMethod */
end_comment
begin_function
DECL|function|updateMicroFocus
name|void
name|QGraphicsObject
operator|::
name|updateMicroFocus
parameter_list|()
block|{
name|QGraphicsItem
operator|::
name|updateMicroFocus
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|children_append
name|void
name|QGraphicsItemPrivate
operator|::
name|children_append
parameter_list|(
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
modifier|*
name|list
parameter_list|,
name|QGraphicsObject
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
name|item
condition|)
block|{
name|QGraphicsObject
modifier|*
name|graphicsObject
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|list
operator|->
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|graphicsObject
argument_list|)
operator|->
name|sendParentChangeNotification
condition|)
block|{
name|item
operator|->
name|setParentItem
argument_list|(
name|graphicsObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|item
argument_list|)
operator|->
name|setParentItemHelper
argument_list|(
name|graphicsObject
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|children_count
name|int
name|QGraphicsItemPrivate
operator|::
name|children_count
parameter_list|(
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
modifier|*
name|list
parameter_list|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|list
operator|->
name|object
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|children
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|children_at
name|QGraphicsObject
modifier|*
name|QGraphicsItemPrivate
operator|::
name|children_at
parameter_list|(
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
modifier|*
name|list
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|list
operator|->
name|object
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|d
operator|->
name|children
operator|.
name|count
argument_list|()
condition|)
return|return
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|->
name|toGraphicsObject
argument_list|()
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|children_clear
name|void
name|QGraphicsItemPrivate
operator|::
name|children_clear
parameter_list|(
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
modifier|*
name|list
parameter_list|)
block|{
name|QGraphicsItemPrivate
modifier|*
name|d
init|=
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|list
operator|->
name|object
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|childCount
init|=
name|d
operator|->
name|children
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|sendParentChangeNotification
condition|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|childCount
condition|;
name|index
operator|++
control|)
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|setParentItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|childCount
condition|;
name|index
operator|++
control|)
name|QGraphicsItemPrivate
operator|::
name|get
argument_list|(
name|d
operator|->
name|children
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|->
name|setParentItemHelper
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of this item's children.      The items are sorted by stacking order. This takes into account both the     items' insertion order and their Z-values.  */
end_comment
begin_function
DECL|function|childrenList
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
name|QGraphicsItemPrivate
operator|::
name|childrenList
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
block|{
name|QGraphicsObject
modifier|*
name|that
init|=
cast|static_cast
argument_list|<
name|QGraphicsObject
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
decl_stmt|;
return|return
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
argument_list|(
name|that
argument_list|,
operator|&
name|children
argument_list|,
name|children_append
argument_list|,
name|children_count
argument_list|,
name|children_at
argument_list|,
name|children_clear
argument_list|)
return|;
block|}
else|else
block|{
comment|//QGraphicsItem is not supported for this property
return|return
name|QDeclarativeListProperty
argument_list|<
name|QGraphicsObject
argument_list|>
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal   Returns the width of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|width
name|qreal
name|QGraphicsItemPrivate
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Set the width of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|setWidth
name|void
name|QGraphicsItemPrivate
operator|::
name|setWidth
parameter_list|(
name|qreal
name|w
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Reset the width of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|resetWidth
name|void
name|QGraphicsItemPrivate
operator|::
name|resetWidth
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!   \internal   Returns the height of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|height
name|qreal
name|QGraphicsItemPrivate
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Set the height of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|setHeight
name|void
name|QGraphicsItemPrivate
operator|::
name|setHeight
parameter_list|(
name|qreal
name|h
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Reset the height of the item   Reimplemented by QGraphicsWidget */
end_comment
begin_function
DECL|function|resetHeight
name|void
name|QGraphicsItemPrivate
operator|::
name|resetHeight
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \property QGraphicsObject::children     \since 4.7     \internal */
end_comment
begin_comment
comment|/*!     \property QGraphicsObject::width     \since 4.7     \internal */
end_comment
begin_comment
comment|/*!     \property QGraphicsObject::height     \since 4.7     \internal */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::parent   \brief the parent of the item    \note The item's parent is set independently of the parent object returned   by QObject::parent().    \sa QGraphicsItem::setParentItem(), QGraphicsItem::parentObject() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::opacity   \brief the opacity of the item    \sa QGraphicsItem::setOpacity(), QGraphicsItem::opacity() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::opacityChanged()    This signal gets emitted whenever the opacity of the item changes    \sa QGraphicsItem::opacity() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::parentChanged()    This signal gets emitted whenever the parent of the item changes */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::pos   \brief the position of the item    Describes the items position.    \sa QGraphicsItem::setPos(), QGraphicsItem::pos() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::x   \brief the x position of the item    Describes the items x position.    \sa QGraphicsItem::setX(), setPos(), xChanged() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::xChanged()    This signal gets emitted whenever the x position of the item changes    \sa pos() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::y   \brief the y position of the item    Describes the items y position.    \sa QGraphicsItem::setY(), setPos(), yChanged() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::yChanged()    This signal gets emitted whenever the y position of the item changes.    \sa pos() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::z   \brief the z value of the item    Describes the items z value.    \sa QGraphicsItem::setZValue(), zValue(), zChanged() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::zChanged()    This signal gets emitted whenever the z value of the item changes.    \sa pos() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::rotation   This property holds the rotation of the item in degrees.    This specifies how many degrees to rotate the item around its transformOrigin.   The default rotation is 0 degrees (i.e. not rotated at all). */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::rotationChanged()    This signal gets emitted whenever the roation of the item changes. */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::scale   This property holds the scale of the item.    A scale of less than 1 means the item will be displayed smaller than   normal, and a scale of greater than 1 means the item will be   displayed larger than normal.  A negative scale means the item will   be mirrored.    By default, items are displayed at a scale of 1 (i.e. at their   normal size).    Scaling is from the item's transformOrigin. */
end_comment
begin_comment
comment|/*!   \fn void QGraphicsObject::scaleChanged()    This signal is emitted when the scale of the item changes. */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::enabled   \brief whether the item is enabled or not    This property is declared in QGraphicsItem.    By default, this property is true.    \sa QGraphicsItem::isEnabled(), QGraphicsItem::setEnabled()   \sa QGraphicsObject::enabledChanged() */
end_comment
begin_comment
comment|/*!   \fn void QGraphicsObject::enabledChanged()    This signal gets emitted whenever the item get's enabled or disabled.    \sa isEnabled() */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::visible   \brief whether the item is visible or not    This property is declared in QGraphicsItem.    By default, this property is true.    \sa QGraphicsItem::isVisible(), QGraphicsItem::setVisible(), visibleChanged() */
end_comment
begin_comment
comment|/*!   \fn QGraphicsObject::visibleChanged()    This signal gets emitted whenever the visibility of the item changes    \sa visible */
end_comment
begin_comment
comment|/*!   \fn const QObjectList&QGraphicsObject::children() const   \internal    This function returns the same value as QObject::children(). It's   provided to differentiate between the obsolete member   QGraphicsItem::children() and QObject::children(). QGraphicsItem now   provides childItems() instead. */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::transformOriginPoint   \brief the transformation origin    This property sets a specific point in the items coordiante system as the   origin for scale and rotation.    \sa scale, rotation, QGraphicsItem::transformOriginPoint() */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsObject::widthChanged()     \internal */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsObject::heightChanged()     \internal */
end_comment
begin_comment
comment|/*!    \fn QGraphicsObject::childrenChanged()    This signal gets emitted whenever the children list changes   \internal */
end_comment
begin_comment
comment|/*!   \property QGraphicsObject::effect   \since 4.7   \brief the effect attached to this item    \sa QGraphicsItem::setGraphicsEffect(), QGraphicsItem::graphicsEffect() */
end_comment
begin_comment
comment|/*!     \class QAbstractGraphicsShapeItem     \brief The QAbstractGraphicsShapeItem class provides a common base for     all path items.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      This class does not fully implement an item by itself; in particular, it     does not implement boundingRect() and paint(), which are inherited by     QGraphicsItem.      You can subclass this item to provide a simple base implementation of     accessors for the item's pen and brush.      \sa QGraphicsRectItem, QGraphicsEllipseItem, QGraphicsPathItem,     QGraphicsPolygonItem, QGraphicsTextItem, QGraphicsLineItem,     QGraphicsPixmapItem, {Graphics View Framework} */
end_comment
begin_class
DECL|class|QAbstractGraphicsShapeItemPrivate
class|class
name|QAbstractGraphicsShapeItemPrivate
super|:
specifier|public
name|QGraphicsItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QAbstractGraphicsShapeItem
parameter_list|)
specifier|public
private|:
DECL|member|brush
name|QBrush
name|brush
decl_stmt|;
DECL|member|pen
name|QPen
name|pen
decl_stmt|;
comment|// Cached bounding rectangle
DECL|member|boundingRect
specifier|mutable
name|QRectF
name|boundingRect
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QAbstractGraphicsShapeItem. \a parent is passed to     QGraphicsItem's constructor. */
end_comment
begin_constructor
DECL|function|QAbstractGraphicsShapeItem
name|QAbstractGraphicsShapeItem
operator|::
name|QAbstractGraphicsShapeItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QAbstractGraphicsShapeItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAbstractGraphicsShapeItem
name|QAbstractGraphicsShapeItem
operator|::
name|QAbstractGraphicsShapeItem
parameter_list|(
name|QAbstractGraphicsShapeItemPrivate
modifier|&
name|dd
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys a QAbstractGraphicsShapeItem. */
end_comment
begin_destructor
DECL|function|~QAbstractGraphicsShapeItem
name|QAbstractGraphicsShapeItem
operator|::
name|~
name|QAbstractGraphicsShapeItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's pen. If no pen has been set, this function returns     QPen(), a default black solid line pen with 0 width. */
end_comment
begin_function
DECL|function|pen
name|QPen
name|QAbstractGraphicsShapeItem
operator|::
name|pen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractGraphicsShapeItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pen
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pen for this item to \a pen.      The pen is used to draw the item's outline.      \sa pen() */
end_comment
begin_function
DECL|function|setPen
name|void
name|QAbstractGraphicsShapeItem
operator|::
name|setPen
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractGraphicsShapeItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pen
operator|==
name|pen
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's brush, or an empty brush if no brush has been set.      \sa setBrush() */
end_comment
begin_function
DECL|function|brush
name|QBrush
name|QAbstractGraphicsShapeItem
operator|::
name|brush
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractGraphicsShapeItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|brush
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's brush to \a brush.      The item's brush is used to fill the item.      If you use a brush with a QGradient, the gradient     is relative to the item's coordinate system.      \sa brush() */
end_comment
begin_function
DECL|function|setBrush
name|void
name|QAbstractGraphicsShapeItem
operator|::
name|setBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractGraphicsShapeItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|brush
operator|==
name|brush
condition|)
return|return;
name|d
operator|->
name|brush
operator|=
name|brush
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractGraphicsShapeItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|brush
operator|.
name|isOpaque
argument_list|()
condition|)
return|return
name|isClipped
argument_list|()
condition|?
name|clipPath
argument_list|()
else|:
name|shape
argument_list|()
return|;
return|return
name|QGraphicsItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsPathItem     \brief The QGraphicsPathItem class provides a path item that you     can add to a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's path, pass a QPainterPath to QGraphicsPathItem's     constructor, or call the setPath() function. The path() function     returns the current path.      \image graphicsview-pathitem.png      QGraphicsPathItem uses the path to provide a reasonable     implementation of boundingRect(), shape(), and contains(). The     paint() function draws the path using the item's associated pen     and brush, which you can set by calling the setPen() and     setBrush() functions.      \sa QGraphicsRectItem, QGraphicsEllipseItem, QGraphicsPolygonItem,     QGraphicsTextItem, QGraphicsLineItem, QGraphicsPixmapItem, {Graphics     View Framework} */
end_comment
begin_class
DECL|class|QGraphicsPathItemPrivate
class|class
name|QGraphicsPathItemPrivate
super|:
specifier|public
name|QAbstractGraphicsShapeItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsPathItem
parameter_list|)
specifier|public
private|:
DECL|member|path
name|QPainterPath
name|path
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsPath item using \a path as the default path. \a     parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPathItem
name|QGraphicsPathItem
operator|::
name|QGraphicsPathItem
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsPathItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsPath. \a parent is passed to     QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPathItem
name|QGraphicsPathItem
operator|::
name|QGraphicsPathItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsPathItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsPathItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsPathItem
name|QGraphicsPathItem
operator|::
name|~
name|QGraphicsPathItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's path as a QPainterPath. If no item has been set, an     empty QPainterPath is returned.      \sa setPath() */
end_comment
begin_function
DECL|function|path
name|QPainterPath
name|QGraphicsPathItem
operator|::
name|path
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPathItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's path to be the given \a path.      \sa path() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QGraphicsPathItem
operator|::
name|setPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPathItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|path
operator|==
name|path
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsPathItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPathItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|boundingRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qreal
name|pw
init|=
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|pw
operator|==
literal|0.0
condition|)
name|d
operator|->
name|boundingRect
operator|=
name|d
operator|->
name|path
operator|.
name|controlPointRect
argument_list|()
expr_stmt|;
else|else
block|{
name|d
operator|->
name|boundingRect
operator|=
name|shape
argument_list|()
operator|.
name|controlPointRect
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|d
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsPathItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPathItem
argument_list|)
expr_stmt|;
return|return
name|qt_graphicsItem_shapeFromPath
argument_list|(
name|d
operator|->
name|path
argument_list|,
name|d
operator|->
name|pen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsPathItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsPathItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPathItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|d
operator|->
name|brush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPath
argument_list|(
name|d
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsPathItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsPathItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsPathItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsPathItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsPathItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsPathItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsRectItem     \brief The QGraphicsRectItem class provides a rectangle item that you     can add to a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's rectangle, pass a QRectF to QGraphicsRectItem's     constructor, or call the setRect() function. The rect() function     returns the current rectangle.      \image graphicsview-rectitem.png      QGraphicsRectItem uses the rectangle and the pen width to provide     a reasonable implementation of boundingRect(), shape(), and     contains(). The paint() function draws the rectangle using the     item's associated pen and brush, which you can set by calling the     setPen() and setBrush() functions.      \note The rendering of invalid rectangles, such as those with negative     widths or heights, is undefined. If you cannot be sure that you are     using valid rectangles (for example, if you are creating     rectangles using data from an unreliable source) then you should     use QRectF::normalized() to create normalized rectangles, and use     those instead.      \sa QGraphicsPathItem, QGraphicsEllipseItem, QGraphicsPolygonItem,     QGraphicsTextItem, QGraphicsLineItem, QGraphicsPixmapItem, {Graphics     View Framework} */
end_comment
begin_class
DECL|class|QGraphicsRectItemPrivate
class|class
name|QGraphicsRectItemPrivate
super|:
specifier|public
name|QAbstractGraphicsShapeItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsRectItem
parameter_list|)
specifier|public
private|:
DECL|member|rect
name|QRectF
name|rect
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsRectItem, using \a rect as the default rectangle.     \a parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsRectItem
name|QGraphicsRectItem
operator|::
name|QGraphicsRectItem
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsRectItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QGraphicsRectItem::QGraphicsRectItem(qreal x, qreal y, qreal width, qreal height,                                      QGraphicsItem *parent)      Constructs a QGraphicsRectItem with a default rectangle defined     by (\a x, \a y) and the given \a width and \a height.      \a parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsRectItem
name|QGraphicsRectItem
operator|::
name|QGraphicsRectItem
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
name|w
parameter_list|,
name|qreal
name|h
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsRectItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setRect
argument_list|(
name|QRectF
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsRectItem. \a parent is passed to     QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsRectItem
name|QGraphicsRectItem
operator|::
name|QGraphicsRectItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsRectItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsRectItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsRectItem
name|QGraphicsRectItem
operator|::
name|~
name|QGraphicsRectItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's rectangle.      \sa setRect() */
end_comment
begin_function
DECL|function|rect
name|QRectF
name|QGraphicsRectItem
operator|::
name|rect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRectItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsRectItem::setRect(const QRectF&rectangle)      Sets the item's rectangle to be the given \a rectangle.      \sa rect() */
end_comment
begin_function
DECL|function|setRect
name|void
name|QGraphicsRectItem
operator|::
name|setRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsRectItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rect
operator|==
name|rect
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsRectItem::setRect(qreal x, qreal y, qreal width, qreal height)     \fn void QGraphicsEllipseItem::setRect(qreal x, qreal y, qreal width, qreal height)      Sets the item's rectangle to the rectangle defined by (\a x, \a y)     and the given \a width and \a height.      This convenience function is equivalent to calling \c     {setRect(QRectF(x, y, width, height))}      \sa rect() */
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsRectItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRectItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|boundingRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qreal
name|halfpw
init|=
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
operator|/
literal|2
decl_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|d
operator|->
name|rect
expr_stmt|;
if|if
condition|(
name|halfpw
operator|>
literal|0.0
condition|)
name|d
operator|->
name|boundingRect
operator|.
name|adjust
argument_list|(
operator|-
name|halfpw
argument_list|,
operator|-
name|halfpw
argument_list|,
name|halfpw
argument_list|,
name|halfpw
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsRectItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRectItem
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|d
operator|->
name|rect
argument_list|)
expr_stmt|;
return|return
name|qt_graphicsItem_shapeFromPath
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|pen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsRectItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsRectItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsRectItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|d
operator|->
name|brush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|d
operator|->
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsRectItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsRectItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsRectItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsRectItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsRectItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsRectItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsEllipseItem     \brief The QGraphicsEllipseItem class provides an ellipse item that you     can add to a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      QGraphicsEllipseItem respresents an ellipse with a fill and an outline,     and you can also use it for ellipse segments (see startAngle(),     spanAngle()).      \table         \row             \li \inlineimage graphicsview-ellipseitem.png             \li \inlineimage graphicsview-ellipseitem-pie.png     \endtable      To set the item's ellipse, pass a QRectF to QGraphicsEllipseItem's     constructor, or call setRect(). The rect() function returns the     current ellipse geometry.      QGraphicsEllipseItem uses the rect and the pen width to provide a     reasonable implementation of boundingRect(), shape(), and contains(). The     paint() function draws the ellipse using the item's associated pen and     brush, which you can set by calling setPen() and setBrush().      \sa QGraphicsPathItem, QGraphicsRectItem, QGraphicsPolygonItem,     QGraphicsTextItem, QGraphicsLineItem, QGraphicsPixmapItem, {Graphics     View Framework} */
end_comment
begin_class
DECL|class|QGraphicsEllipseItemPrivate
class|class
name|QGraphicsEllipseItemPrivate
super|:
specifier|public
name|QAbstractGraphicsShapeItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsEllipseItem
parameter_list|)
specifier|public
private|:
DECL|function|QGraphicsEllipseItemPrivate
specifier|inline
name|QGraphicsEllipseItemPrivate
parameter_list|()
member_init_list|:
name|startAngle
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|spanAngle
argument_list|(
literal|360
operator|*
literal|16
argument_list|)
block|{ }
DECL|member|rect
name|QRectF
name|rect
decl_stmt|;
DECL|member|startAngle
name|int
name|startAngle
decl_stmt|;
DECL|member|spanAngle
name|int
name|spanAngle
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsEllipseItem using \a rect as the default rectangle.     \a parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsEllipseItem
name|QGraphicsEllipseItem
operator|::
name|QGraphicsEllipseItem
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsEllipseItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QGraphicsEllipseItem::QGraphicsEllipseItem(qreal x, qreal y, qreal width, qreal height, QGraphicsItem *parent)     \since 4.3      Constructs a QGraphicsEllipseItem using the rectangle defined by (\a x, \a     y) and the given \a width and \a height, as the default rectangle. \a     parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsEllipseItem
name|QGraphicsEllipseItem
operator|::
name|QGraphicsEllipseItem
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
name|y
parameter_list|,
name|qreal
name|w
parameter_list|,
name|qreal
name|h
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsEllipseItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsEllipseItem. \a parent is passed to     QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsEllipseItem
name|QGraphicsEllipseItem
operator|::
name|QGraphicsEllipseItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsEllipseItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsEllipseItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsEllipseItem
name|QGraphicsEllipseItem
operator|::
name|~
name|QGraphicsEllipseItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's ellipse geometry as a QRectF.      \sa setRect(), QPainter::drawEllipse() */
end_comment
begin_function
DECL|function|rect
name|QRectF
name|QGraphicsEllipseItem
operator|::
name|rect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's ellipse geometry to \a rect. The rectangle's left edge     defines the left edge of the ellipse, and the rectangle's top edge     describes the top of the ellipse. The height and width of the rectangle     describe the height and width of the ellipse.      \sa rect(), QPainter::drawEllipse() */
end_comment
begin_function
DECL|function|setRect
name|void
name|QGraphicsEllipseItem
operator|::
name|setRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rect
operator|==
name|rect
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|rect
operator|=
name|rect
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the start angle for an ellipse segment in 16ths of a degree. This     angle is used together with spanAngle() for representing an ellipse     segment (a pie). By default, the start angle is 0.      \sa setStartAngle(), spanAngle() */
end_comment
begin_function
DECL|function|startAngle
name|int
name|QGraphicsEllipseItem
operator|::
name|startAngle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|startAngle
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the start angle for an ellipse segment to \a angle, which is in 16ths     of a degree. This angle is used together with spanAngle() for representing     an ellipse segment (a pie). By default, the start angle is 0.      \sa startAngle(), setSpanAngle(), QPainter::drawPie() */
end_comment
begin_function
DECL|function|setStartAngle
name|void
name|QGraphicsEllipseItem
operator|::
name|setStartAngle
parameter_list|(
name|int
name|angle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle
operator|!=
name|d
operator|->
name|startAngle
condition|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|d
operator|->
name|startAngle
operator|=
name|angle
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the span angle of an ellipse segment in 16ths of a degree. This     angle is used together with startAngle() for representing an ellipse     segment (a pie). By default, this function returns 5760 (360 * 16, a full     ellipse).      \sa setSpanAngle(), startAngle() */
end_comment
begin_function
DECL|function|spanAngle
name|int
name|QGraphicsEllipseItem
operator|::
name|spanAngle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|spanAngle
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the span angle for an ellipse segment to \a angle, which is in 16ths     of a degree. This angle is used together with startAngle() to represent an     ellipse segment (a pie). By default, the span angle is 5760 (360 * 16, a     full ellipse).      \sa spanAngle(), setStartAngle(), QPainter::drawPie() */
end_comment
begin_function
DECL|function|setSpanAngle
name|void
name|QGraphicsEllipseItem
operator|::
name|setSpanAngle
parameter_list|(
name|int
name|angle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle
operator|!=
name|d
operator|->
name|spanAngle
condition|)
block|{
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|d
operator|->
name|spanAngle
operator|=
name|angle
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsEllipseItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|boundingRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qreal
name|pw
init|=
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|pw
operator|==
literal|0.0
operator|&&
name|d
operator|->
name|spanAngle
operator|==
literal|360
operator|*
literal|16
condition|)
name|d
operator|->
name|boundingRect
operator|=
name|d
operator|->
name|rect
expr_stmt|;
else|else
name|d
operator|->
name|boundingRect
operator|=
name|shape
argument_list|()
operator|.
name|controlPointRect
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsEllipseItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|rect
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|path
return|;
if|if
condition|(
name|d
operator|->
name|spanAngle
operator|!=
literal|360
operator|*
literal|16
condition|)
block|{
name|path
operator|.
name|moveTo
argument_list|(
name|d
operator|->
name|rect
operator|.
name|center
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|arcTo
argument_list|(
name|d
operator|->
name|rect
argument_list|,
name|d
operator|->
name|startAngle
operator|/
literal|16.0
argument_list|,
name|d
operator|->
name|spanAngle
operator|/
literal|16.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|addEllipse
argument_list|(
name|d
operator|->
name|rect
argument_list|)
expr_stmt|;
block|}
return|return
name|qt_graphicsItem_shapeFromPath
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|pen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsEllipseItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsEllipseItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsEllipseItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|d
operator|->
name|brush
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|spanAngle
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|qAbs
argument_list|(
name|d
operator|->
name|spanAngle
argument_list|)
operator|%
operator|(
literal|360
operator|*
literal|16
operator|)
operator|==
literal|0
operator|)
condition|)
name|painter
operator|->
name|drawEllipse
argument_list|(
name|d
operator|->
name|rect
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|drawPie
argument_list|(
name|d
operator|->
name|rect
argument_list|,
name|d
operator|->
name|startAngle
argument_list|,
name|d
operator|->
name|spanAngle
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsEllipseItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsEllipseItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsEllipseItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsEllipseItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsEllipseItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsEllipseItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsPolygonItem     \brief The QGraphicsPolygonItem class provides a polygon item that you     can add to a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's polygon, pass a QPolygonF to     QGraphicsPolygonItem's constructor, or call the setPolygon()     function. The polygon() function returns the current polygon.      \image graphicsview-polygonitem.png      QGraphicsPolygonItem uses the polygon and the pen width to provide     a reasonable implementation of boundingRect(), shape(), and     contains(). The paint() function draws the polygon using the     item's associated pen and brush, which you can set by calling the     setPen() and setBrush() functions.      \sa QGraphicsPathItem, QGraphicsRectItem, QGraphicsEllipseItem,     QGraphicsTextItem, QGraphicsLineItem, QGraphicsPixmapItem, {Graphics     View Framework} */
end_comment
begin_class
DECL|class|QGraphicsPolygonItemPrivate
class|class
name|QGraphicsPolygonItemPrivate
super|:
specifier|public
name|QAbstractGraphicsShapeItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsPolygonItem
parameter_list|)
specifier|public
private|:
DECL|function|QGraphicsPolygonItemPrivate
specifier|inline
name|QGraphicsPolygonItemPrivate
parameter_list|()
member_init_list|:
name|fillRule
argument_list|(
name|Qt
operator|::
name|OddEvenFill
argument_list|)
block|{ }
DECL|member|polygon
name|QPolygonF
name|polygon
decl_stmt|;
DECL|member|fillRule
name|Qt
operator|::
name|FillRule
name|fillRule
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsPolygonItem with \a polygon as the default     polygon. \a parent is passed to QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPolygonItem
name|QGraphicsPolygonItem
operator|::
name|QGraphicsPolygonItem
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsPolygonItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setPolygon
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsPolygonItem. \a parent is passed to     QAbstractGraphicsShapeItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPolygonItem
name|QGraphicsPolygonItem
operator|::
name|QGraphicsPolygonItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsPolygonItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsPolygonItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsPolygonItem
name|QGraphicsPolygonItem
operator|::
name|~
name|QGraphicsPolygonItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's polygon, or an empty polygon if no polygon     has been set.      \sa setPolygon() */
end_comment
begin_function
DECL|function|polygon
name|QPolygonF
name|QGraphicsPolygonItem
operator|::
name|polygon
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|polygon
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's polygon to be the given \a polygon.      \sa polygon() */
end_comment
begin_function
DECL|function|setPolygon
name|void
name|QGraphicsPolygonItem
operator|::
name|setPolygon
parameter_list|(
specifier|const
name|QPolygonF
modifier|&
name|polygon
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|polygon
operator|==
name|polygon
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|polygon
operator|=
name|polygon
expr_stmt|;
name|d
operator|->
name|boundingRect
operator|=
name|QRectF
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      Returns the fill rule of the polygon. The default fill rule is      Qt::OddEvenFill.       \sa setFillRule(), QPainterPath::fillRule(), QPainter::drawPolygon() */
end_comment
begin_function
DECL|function|fillRule
name|Qt
operator|::
name|FillRule
name|QGraphicsPolygonItem
operator|::
name|fillRule
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|fillRule
return|;
block|}
end_function
begin_comment
comment|/*!      Sets the fill rule of the polygon to \a rule. The default fill rule is      Qt::OddEvenFill.       \sa fillRule(), QPainterPath::fillRule(), QPainter::drawPolygon() */
end_comment
begin_function
DECL|function|setFillRule
name|void
name|QGraphicsPolygonItem
operator|::
name|setFillRule
parameter_list|(
name|Qt
operator|::
name|FillRule
name|rule
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|!=
name|d
operator|->
name|fillRule
condition|)
block|{
name|d
operator|->
name|fillRule
operator|=
name|rule
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsPolygonItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|boundingRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qreal
name|pw
init|=
name|pen
argument_list|()
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|pw
operator|==
literal|0.0
condition|)
name|d
operator|->
name|boundingRect
operator|=
name|d
operator|->
name|polygon
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
else|else
name|d
operator|->
name|boundingRect
operator|=
name|shape
argument_list|()
operator|.
name|controlPointRect
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsPolygonItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addPolygon
argument_list|(
name|d
operator|->
name|polygon
argument_list|)
expr_stmt|;
return|return
name|qt_graphicsItem_shapeFromPath
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|pen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsPolygonItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsPolygonItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPolygonItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|d
operator|->
name|brush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPolygon
argument_list|(
name|d
operator|->
name|polygon
argument_list|,
name|d
operator|->
name|fillRule
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsPolygonItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsPolygonItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsPolygonItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsPolygonItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsPolygonItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsPolygonItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsLineItem     \brief The QGraphicsLineItem class provides a line item that you can add to a     QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's line, pass a QLineF to QGraphicsLineItem's     constructor, or call the setLine() function. The line() function     returns the current line. By default the line is black with a     width of 0, but you can change this by calling setPen().      \img graphicsview-lineitem.png      QGraphicsLineItem uses the line and the pen width to provide a reasonable     implementation of boundingRect(), shape(), and contains(). The paint()     function draws the line using the item's associated pen.      \sa QGraphicsPathItem, QGraphicsRectItem, QGraphicsEllipseItem,     QGraphicsTextItem, QGraphicsPolygonItem, QGraphicsPixmapItem,     {Graphics View Framework} */
end_comment
begin_class
DECL|class|QGraphicsLineItemPrivate
class|class
name|QGraphicsLineItemPrivate
super|:
specifier|public
name|QGraphicsItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsLineItem
parameter_list|)
specifier|public
private|:
DECL|member|line
name|QLineF
name|line
decl_stmt|;
DECL|member|pen
name|QPen
name|pen
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsLineItem, using \a line as the default line. \a     parent is passed to QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsLineItem
name|QGraphicsLineItem
operator|::
name|QGraphicsLineItem
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsLineItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsLineItem, using the line between (\a x1, \a y1) and     (\a x2, \a y2) as the default line.  \a parent is passed to     QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsLineItem
name|QGraphicsLineItem
operator|::
name|QGraphicsLineItem
parameter_list|(
name|qreal
name|x1
parameter_list|,
name|qreal
name|y1
parameter_list|,
name|qreal
name|x2
parameter_list|,
name|qreal
name|y2
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsLineItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setLine
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsLineItem. \a parent is passed to QGraphicsItem's     constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsLineItem
name|QGraphicsLineItem
operator|::
name|QGraphicsLineItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsLineItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsLineItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsLineItem
name|QGraphicsLineItem
operator|::
name|~
name|QGraphicsLineItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the item's pen, or a black solid 0-width pen if no pen has     been set.      \sa setPen() */
end_comment
begin_function
DECL|function|pen
name|QPen
name|QGraphicsLineItem
operator|::
name|pen
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pen
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's pen to \a pen. If no pen is set, the line will be painted     using a black solid 0-width pen.      \sa pen() */
end_comment
begin_function
DECL|function|setPen
name|void
name|QGraphicsLineItem
operator|::
name|setPen
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pen
operator|==
name|pen
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|pen
operator|=
name|pen
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's line, or a null line if no line has been set.      \sa setLine() */
end_comment
begin_function
DECL|function|line
name|QLineF
name|QGraphicsLineItem
operator|::
name|line
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|line
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's line to be the given \a line.      \sa line() */
end_comment
begin_function
DECL|function|setLine
name|void
name|QGraphicsLineItem
operator|::
name|setLine
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|line
operator|==
name|line
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsLineItem::setLine(qreal x1, qreal y1, qreal x2, qreal y2)     \overload      Sets the item's line to be the line between (\a x1, \a y1) and (\a     x2, \a y2).      This is the same as calling \c {setLine(QLineF(x1, y1, x2, y2))}. */
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsLineItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pen
operator|.
name|widthF
argument_list|()
operator|==
literal|0.0
condition|)
block|{
specifier|const
name|qreal
name|x1
init|=
name|d
operator|->
name|line
operator|.
name|p1
argument_list|()
operator|.
name|x
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|x2
init|=
name|d
operator|->
name|line
operator|.
name|p2
argument_list|()
operator|.
name|x
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|y1
init|=
name|d
operator|->
name|line
operator|.
name|p1
argument_list|()
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|y2
init|=
name|d
operator|->
name|line
operator|.
name|p2
argument_list|()
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|lx
init|=
name|qMin
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
decl_stmt|;
name|qreal
name|rx
init|=
name|qMax
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
decl_stmt|;
name|qreal
name|ty
init|=
name|qMin
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
name|qreal
name|by
init|=
name|qMax
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|lx
argument_list|,
name|ty
argument_list|,
name|rx
operator|-
name|lx
argument_list|,
name|by
operator|-
name|ty
argument_list|)
return|;
block|}
return|return
name|shape
argument_list|()
operator|.
name|controlPointRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsLineItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|line
operator|==
name|QLineF
argument_list|()
condition|)
return|return
name|path
return|;
name|path
operator|.
name|moveTo
argument_list|(
name|d
operator|->
name|line
operator|.
name|p1
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
name|d
operator|->
name|line
operator|.
name|p2
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|qt_graphicsItem_shapeFromPath
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|pen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsLineItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsLineItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsLineItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawLine
argument_list|(
name|d
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsLineItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsLineItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsLineItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsLineItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsLineItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsLineItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsPixmapItem     \brief The QGraphicsPixmapItem class provides a pixmap item that you can add to     a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's pixmap, pass a QPixmap to QGraphicsPixmapItem's     constructor, or call the setPixmap() function. The pixmap()     function returns the current pixmap.      QGraphicsPixmapItem uses pixmap's optional alpha mask to provide a     reasonable implementation of boundingRect(), shape(), and contains().      \image graphicsview-pixmapitem.png      The pixmap is drawn at the item's (0, 0) coordinate, as returned by     offset(). You can change the drawing offset by calling setOffset().      You can set the pixmap's transformation mode by calling     setTransformationMode(). By default, Qt::FastTransformation is used, which     provides fast, non-smooth scaling. Qt::SmoothTransformation enables     QPainter::SmoothPixmapTransform on the painter, and the quality depends on     the platform and viewport. The result is usually not as good as calling     QPixmap::scale() directly. Call transformationMode() to get the current     transformation mode for the item.      \sa QGraphicsPathItem, QGraphicsRectItem, QGraphicsEllipseItem,     QGraphicsTextItem, QGraphicsPolygonItem, QGraphicsLineItem,     {Graphics View Framework} */
end_comment
begin_comment
comment|/*!     \enum QGraphicsPixmapItem::ShapeMode      This enum describes how QGraphicsPixmapItem calculates its shape and     opaque area.      The default value is MaskShape.      \value MaskShape The shape is determined by calling QPixmap::mask().     This shape includes only the opaque pixels of the pixmap.     Because the shape is more complex, however, it can be slower than the other modes,     and uses more memory.      \value BoundingRectShape The shape is determined by tracing the outline of     the pixmap. This is the fastest shape mode, but it does not take into account     any transparent areas on the pixmap.      \value HeuristicMaskShape The shape is determine by calling     QPixmap::createHeuristicMask().  The performance and memory consumption     is similar to MaskShape. */
end_comment
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_regionToPath
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
end_function_decl
begin_class
DECL|class|QGraphicsPixmapItemPrivate
class|class
name|QGraphicsPixmapItemPrivate
super|:
specifier|public
name|QGraphicsItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsPixmapItem
parameter_list|)
specifier|public
private|:
DECL|function|QGraphicsPixmapItemPrivate
name|QGraphicsPixmapItemPrivate
parameter_list|()
member_init_list|:
name|transformationMode
argument_list|(
name|Qt
operator|::
name|FastTransformation
argument_list|)
member_init_list|,
name|shapeMode
argument_list|(
name|QGraphicsPixmapItem
operator|::
name|MaskShape
argument_list|)
member_init_list|,
name|hasShape
argument_list|(
literal|false
argument_list|)
block|{}
DECL|member|pixmap
name|QPixmap
name|pixmap
decl_stmt|;
DECL|member|transformationMode
name|Qt
operator|::
name|TransformationMode
name|transformationMode
decl_stmt|;
DECL|member|offset
name|QPointF
name|offset
decl_stmt|;
DECL|member|shapeMode
name|QGraphicsPixmapItem
operator|::
name|ShapeMode
name|shapeMode
decl_stmt|;
DECL|member|shape
name|QPainterPath
name|shape
decl_stmt|;
DECL|member|hasShape
name|bool
name|hasShape
decl_stmt|;
DECL|function|updateShape
name|void
name|updateShape
parameter_list|()
block|{
name|shape
operator|=
name|QPainterPath
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|shapeMode
condition|)
block|{
case|case
name|QGraphicsPixmapItem
operator|::
name|MaskShape
case|:
block|{
name|QBitmap
name|mask
init|=
name|pixmap
operator|.
name|mask
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mask
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|shape
operator|=
name|qt_regionToPath
argument_list|(
name|QRegion
argument_list|(
name|mask
argument_list|)
operator|.
name|translated
argument_list|(
name|offset
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// FALL THROUGH
block|}
case|case
name|QGraphicsPixmapItem
operator|::
name|BoundingRectShape
case|:
name|shape
operator|.
name|addRect
argument_list|(
name|QRectF
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|,
name|offset
operator|.
name|y
argument_list|()
argument_list|,
name|pixmap
operator|.
name|width
argument_list|()
argument_list|,
name|pixmap
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QGraphicsPixmapItem
operator|::
name|HeuristicMaskShape
case|:
ifndef|#
directive|ifndef
name|QT_NO_IMAGE_HEURISTIC_MASK
name|shape
operator|=
name|qt_regionToPath
argument_list|(
name|QRegion
argument_list|(
name|pixmap
operator|.
name|createHeuristicMask
argument_list|()
argument_list|)
operator|.
name|translated
argument_list|(
name|offset
operator|.
name|toPoint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|shape
operator|.
name|addRect
argument_list|(
name|QRectF
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|,
name|offset
operator|.
name|y
argument_list|()
argument_list|,
name|pixmap
operator|.
name|width
argument_list|()
argument_list|,
name|pixmap
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsPixmapItem, using \a pixmap as the default pixmap.     \a parent is passed to QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPixmapItem
name|QGraphicsPixmapItem
operator|::
name|QGraphicsPixmapItem
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsPixmapItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setPixmap
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsPixmapItem. \a parent is passed to QGraphicsItem's     constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsPixmapItem
name|QGraphicsPixmapItem
operator|::
name|QGraphicsPixmapItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsPixmapItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsPixmapItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsPixmapItem
name|QGraphicsPixmapItem
operator|::
name|~
name|QGraphicsPixmapItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the item's pixmap to \a pixmap.      \sa pixmap() */
end_comment
begin_function
DECL|function|setPixmap
name|void
name|QGraphicsPixmapItem
operator|::
name|setPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|pixmap
operator|=
name|pixmap
expr_stmt|;
name|d
operator|->
name|hasShape
operator|=
literal|false
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's pixmap, or an invalid QPixmap if no pixmap has been     set.      \sa setPixmap() */
end_comment
begin_function
DECL|function|pixmap
name|QPixmap
name|QGraphicsPixmapItem
operator|::
name|pixmap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pixmap
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the transformation mode of the pixmap. The default mode is     Qt::FastTransformation, which provides quick transformation with no     smoothing.      \sa setTransformationMode() */
end_comment
begin_function
DECL|function|transformationMode
name|Qt
operator|::
name|TransformationMode
name|QGraphicsPixmapItem
operator|::
name|transformationMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|transformationMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pixmap item's transformation mode to \a mode, and toggles an     update of the item. The default mode is Qt::FastTransformation, which     provides quick transformation with no smoothing.      Qt::SmoothTransformation enables QPainter::SmoothPixmapTransform on the     painter, and the quality depends on the platform and viewport. The result     is usually not as good as calling QPixmap::scale() directly.      \sa transformationMode() */
end_comment
begin_function
DECL|function|setTransformationMode
name|void
name|QGraphicsPixmapItem
operator|::
name|setTransformationMode
parameter_list|(
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|d
operator|->
name|transformationMode
condition|)
block|{
name|d
operator|->
name|transformationMode
operator|=
name|mode
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the pixmap item's \e offset, which defines the point of the     top-left corner of the pixmap, in local coordinates.      \sa setOffset() */
end_comment
begin_function
DECL|function|offset
name|QPointF
name|QGraphicsPixmapItem
operator|::
name|offset
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pixmap item's offset to \a offset. QGraphicsPixmapItem will draw     its pixmap using \a offset for its top-left corner.      \sa offset() */
end_comment
begin_function
DECL|function|setOffset
name|void
name|QGraphicsPixmapItem
operator|::
name|setOffset
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|offset
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|offset
operator|==
name|offset
condition|)
return|return;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|d
operator|->
name|hasShape
operator|=
literal|false
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsPixmapItem::setOffset(qreal x, qreal y)     \since 4.3      This convenience function is equivalent to calling setOffset(QPointF(\a x, \a y)). */
end_comment
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsPixmapItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QRectF
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|ItemIsSelectable
condition|)
block|{
name|qreal
name|pw
init|=
literal|1.0
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|d
operator|->
name|offset
argument_list|,
name|d
operator|->
name|pixmap
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|adjusted
argument_list|(
operator|-
name|pw
operator|/
literal|2
argument_list|,
operator|-
name|pw
operator|/
literal|2
argument_list|,
name|pw
operator|/
literal|2
argument_list|,
name|pw
operator|/
literal|2
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QRectF
argument_list|(
name|d
operator|->
name|offset
argument_list|,
name|d
operator|->
name|pixmap
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsPixmapItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|hasShape
condition|)
block|{
name|QGraphicsPixmapItemPrivate
modifier|*
name|thatD
init|=
cast|const_cast
argument_list|<
name|QGraphicsPixmapItemPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|thatD
operator|->
name|updateShape
argument_list|()
expr_stmt|;
name|thatD
operator|->
name|hasShape
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|d_func
argument_list|()
operator|->
name|shape
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsPixmapItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsPixmapItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
operator|(
name|d
operator|->
name|transformationMode
operator|==
name|Qt
operator|::
name|SmoothTransformation
operator|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|d
operator|->
name|offset
argument_list|,
name|d
operator|->
name|pixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsPixmapItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsPixmapItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|shape
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsPixmapItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's shape mode. The shape mode describes how     QGraphicsPixmapItem calculates its shape. The default mode is MaskShape.      \sa setShapeMode(), ShapeMode */
end_comment
begin_function
DECL|function|shapeMode
name|QGraphicsPixmapItem
operator|::
name|ShapeMode
name|QGraphicsPixmapItem
operator|::
name|shapeMode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|shapeMode
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's shape mode to \a mode. The shape mode describes how     QGraphicsPixmapItem calculates its shape. The default mode is MaskShape.      \sa shapeMode(), ShapeMode */
end_comment
begin_function
DECL|function|setShapeMode
name|void
name|QGraphicsPixmapItem
operator|::
name|setShapeMode
parameter_list|(
name|ShapeMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsPixmapItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|shapeMode
operator|==
name|mode
condition|)
return|return;
name|d
operator|->
name|shapeMode
operator|=
name|mode
expr_stmt|;
name|d
operator|->
name|hasShape
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsPixmapItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsPixmapItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsPixmapItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsTextItem     \brief The QGraphicsTextItem class provides a text item that you can add to     a QGraphicsScene to display formatted text.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      If you only need to show plain text in an item, consider using QGraphicsSimpleTextItem     instead.      To set the item's text, pass a QString to QGraphicsTextItem's     constructor, or call setHtml()/setPlainText().      QGraphicsTextItem uses the text's formatted size and the associated font     to provide a reasonable implementation of boundingRect(), shape(),     and contains(). You can set the font by calling setFont().      It is possible to make the item editable by setting the Qt::TextEditorInteraction flag     using setTextInteractionFlags().      The item's preferred text width can be set using setTextWidth() and obtained     using textWidth().      \note In order to align HTML text in the center, the item's text width must be set.      \img graphicsview-textitem.png      \note QGraphicsTextItem accepts \l{QGraphicsItem::acceptHoverEvents()}{hover events}           by default. You can change this with \l{QGraphicsItem::}{setAcceptHoverEvents()}.      \sa QGraphicsSimpleTextItem, QGraphicsPathItem, QGraphicsRectItem,         QGraphicsEllipseItem, QGraphicsPixmapItem, QGraphicsPolygonItem,         QGraphicsLineItem, {Graphics View Framework} */
end_comment
begin_class
DECL|class|QGraphicsTextItemPrivate
class|class
name|QGraphicsTextItemPrivate
block|{
public|public:
DECL|function|QGraphicsTextItemPrivate
name|QGraphicsTextItemPrivate
parameter_list|()
member_init_list|:
name|control
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pageNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|useDefaultImpl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|tabChangesFocus
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|clickCausedFocus
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|member|control
specifier|mutable
name|QWidgetTextControl
modifier|*
name|control
decl_stmt|;
name|QWidgetTextControl
modifier|*
name|textControl
parameter_list|()
specifier|const
function_decl|;
DECL|function|controlOffset
specifier|inline
name|QPointF
name|controlOffset
parameter_list|()
specifier|const
block|{
return|return
name|QPointF
argument_list|(
literal|0.
argument_list|,
name|pageNumber
operator|*
name|control
operator|->
name|document
argument_list|()
operator|->
name|pageSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
return|;
block|}
DECL|function|sendControlEvent
specifier|inline
name|void
name|sendControlEvent
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|control
condition|)
name|control
operator|->
name|processEvent
argument_list|(
name|e
argument_list|,
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|_q_updateBoundingRect
parameter_list|(
specifier|const
name|QSizeF
modifier|&
parameter_list|)
function_decl|;
name|void
name|_q_update
parameter_list|(
name|QRectF
parameter_list|)
function_decl|;
name|void
name|_q_ensureVisible
parameter_list|(
name|QRectF
parameter_list|)
function_decl|;
name|bool
name|_q_mouseOnEdge
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
parameter_list|)
function_decl|;
DECL|member|boundingRect
name|QRectF
name|boundingRect
decl_stmt|;
DECL|member|pageNumber
name|int
name|pageNumber
decl_stmt|;
DECL|member|useDefaultImpl
name|bool
name|useDefaultImpl
decl_stmt|;
DECL|member|tabChangesFocus
name|bool
name|tabChangesFocus
decl_stmt|;
name|uint
name|clickCausedFocus
range|:
literal|1
decl_stmt|;
DECL|member|qq
name|QGraphicsTextItem
modifier|*
name|qq
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsTextItem, using \a text as the default plain     text. \a parent is passed to QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsTextItem
name|QGraphicsTextItem
operator|::
name|QGraphicsTextItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsObject
argument_list|(
operator|*
operator|new
name|QGraphicsItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
member_init_list|,
name|dd
argument_list|(
operator|new
name|QGraphicsTextItemPrivate
argument_list|)
block|{
name|dd
operator|->
name|qq
operator|=
name|this
expr_stmt|;
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setAcceptHoverEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setFlags
argument_list|(
name|ItemUsesExtendedStyleOption
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsTextItem. \a parent is passed to QGraphicsItem's     constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsTextItem
name|QGraphicsTextItem
operator|::
name|QGraphicsTextItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsObject
argument_list|(
operator|*
operator|new
name|QGraphicsItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
member_init_list|,
name|dd
argument_list|(
operator|new
name|QGraphicsTextItemPrivate
argument_list|)
block|{
name|dd
operator|->
name|qq
operator|=
name|this
expr_stmt|;
name|setAcceptDrops
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setAcceptHoverEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setFlag
argument_list|(
name|ItemUsesExtendedStyleOption
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsTextItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsTextItem
name|QGraphicsTextItem
operator|::
name|~
name|QGraphicsTextItem
parameter_list|()
block|{
operator|delete
name|dd
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the item's text converted to HTML, or an empty QString if no text has been set.      \sa setHtml() */
end_comment
begin_function
DECL|function|toHtml
name|QString
name|QGraphicsTextItem
operator|::
name|toHtml
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
if|if
condition|(
name|dd
operator|->
name|control
condition|)
return|return
name|dd
operator|->
name|control
operator|->
name|toHtml
argument_list|()
return|;
endif|#
directive|endif
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's text to \a text, assuming that text is HTML formatted. If     the item has keyboard input focus, this function will also call     ensureVisible() to ensure that the text is visible in all viewports.      \sa toHtml(), hasFocus(), QGraphicsSimpleTextItem */
end_comment
begin_function
DECL|function|setHtml
name|void
name|QGraphicsTextItem
operator|::
name|setHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setHtml
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's text converted to plain text, or an empty QString if no text has been set.      \sa setPlainText() */
end_comment
begin_function
DECL|function|toPlainText
name|QString
name|QGraphicsTextItem
operator|::
name|toPlainText
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|dd
operator|->
name|control
condition|)
return|return
name|dd
operator|->
name|control
operator|->
name|toPlainText
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the item's text to \a text. If the item has keyboard input focus,     this function will also call ensureVisible() to ensure that the text is     visible in all viewports.      \sa toHtml(), hasFocus() */
end_comment
begin_function
DECL|function|setPlainText
name|void
name|QGraphicsTextItem
operator|::
name|setPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setPlainText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's font, which is used to render the text.      \sa setFont() */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGraphicsTextItem
operator|::
name|font
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
name|QFont
argument_list|()
return|;
return|return
name|dd
operator|->
name|control
operator|->
name|document
argument_list|()
operator|->
name|defaultFont
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the font used to render the text item to \a font.      \sa font() */
end_comment
begin_function
DECL|function|setFont
name|void
name|QGraphicsTextItem
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|document
argument_list|()
operator|->
name|setDefaultFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the color for unformatted text to \a col. */
end_comment
begin_function
DECL|function|setDefaultTextColor
name|void
name|QGraphicsTextItem
operator|::
name|setDefaultTextColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|col
parameter_list|)
block|{
name|QWidgetTextControl
modifier|*
name|c
init|=
name|dd
operator|->
name|textControl
argument_list|()
decl_stmt|;
name|QPalette
name|pal
init|=
name|c
operator|->
name|palette
argument_list|()
decl_stmt|;
name|QColor
name|old
init|=
name|pal
operator|.
name|color
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|)
decl_stmt|;
name|pal
operator|.
name|setColor
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|c
operator|->
name|setPalette
argument_list|(
name|pal
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|col
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default text color that is used to for unformatted text. */
end_comment
begin_function
DECL|function|defaultTextColor
name|QColor
name|QGraphicsTextItem
operator|::
name|defaultTextColor
parameter_list|()
specifier|const
block|{
return|return
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|palette
argument_list|()
operator|.
name|color
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsTextItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
return|return
name|dd
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsTextItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
name|QPainterPath
argument_list|()
return|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|dd
operator|->
name|boundingRect
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsTextItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
return|return
name|dd
operator|->
name|boundingRect
operator|.
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsTextItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|control
condition|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|QRectF
name|r
init|=
name|option
operator|->
name|exposedRect
decl_stmt|;
name|painter
operator|->
name|translate
argument_list|(
operator|-
name|dd
operator|->
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
name|r
operator|.
name|translate
argument_list|(
name|dd
operator|->
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
name|QTextDocument
modifier|*
name|doc
init|=
name|dd
operator|->
name|control
operator|->
name|document
argument_list|()
decl_stmt|;
name|QTextDocumentLayout
modifier|*
name|layout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|doc
operator|->
name|documentLayout
argument_list|()
argument_list|)
decl_stmt|;
comment|// the layout might need to expand the root frame to
comment|// the viewport if NoWrap is set
if|if
condition|(
name|layout
condition|)
name|layout
operator|->
name|setViewport
argument_list|(
name|dd
operator|->
name|boundingRect
argument_list|)
expr_stmt|;
name|dd
operator|->
name|control
operator|->
name|drawContents
argument_list|(
name|painter
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|layout
condition|)
name|layout
operator|->
name|setViewport
argument_list|(
name|QRect
argument_list|()
argument_list|)
expr_stmt|;
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|option
operator|->
name|state
operator|&
operator|(
name|QStyle
operator|::
name|State_Selected
operator||
name|QStyle
operator|::
name|State_HasFocus
operator|)
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsTextItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsTextItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsTextItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the preferred width for the item's text. If the actual text     is wider than the specified width then it will be broken into     multiple lines.      If \a width is set to -1 then the text will not be broken into     multiple lines unless it is enforced through an explicit line     break or a new paragraph.      The default value is -1.      Note that QGraphicsTextItem keeps a QTextDocument internally,     which is used to calculate the text width.      \sa textWidth(), QTextDocument::setTextWidth() */
end_comment
begin_function
DECL|function|setTextWidth
name|void
name|QGraphicsTextItem
operator|::
name|setTextWidth
parameter_list|(
name|qreal
name|width
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setTextWidth
argument_list|(
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the text width.      The width is calculated with the QTextDocument that     QGraphicsTextItem keeps internally.      \sa setTextWidth(), QTextDocument::textWidth() */
end_comment
begin_function
DECL|function|textWidth
name|qreal
name|QGraphicsTextItem
operator|::
name|textWidth
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|dd
operator|->
name|control
operator|->
name|textWidth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Adjusts the text item to a reasonable size. */
end_comment
begin_function
DECL|function|adjustSize
name|void
name|QGraphicsTextItem
operator|::
name|adjustSize
parameter_list|()
block|{
if|if
condition|(
name|dd
operator|->
name|control
condition|)
name|dd
operator|->
name|control
operator|->
name|adjustSize
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the text document \a document on the item. */
end_comment
begin_function
DECL|function|setDocument
name|void
name|QGraphicsTextItem
operator|::
name|setDocument
parameter_list|(
name|QTextDocument
modifier|*
name|document
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|dd
operator|->
name|_q_updateBoundingRect
argument_list|(
name|dd
operator|->
name|control
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's text document. */
end_comment
begin_function
DECL|function|document
name|QTextDocument
modifier|*
name|QGraphicsTextItem
operator|::
name|document
parameter_list|()
specifier|const
block|{
return|return
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|document
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|sceneEvent
name|bool
name|QGraphicsTextItem
operator|::
name|sceneEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|QEvent
operator|::
name|Type
name|t
init|=
name|event
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dd
operator|->
name|tabChangesFocus
operator|&&
operator|(
name|t
operator|==
name|QEvent
operator|::
name|KeyPress
operator|||
name|t
operator|==
name|QEvent
operator|::
name|KeyRelease
operator|)
condition|)
block|{
name|int
name|k
init|=
operator|(
operator|(
name|QKeyEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
name|Qt
operator|::
name|Key_Tab
operator|||
name|k
operator|==
name|Qt
operator|::
name|Key_Backtab
condition|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|bool
name|result
init|=
name|QGraphicsItem
operator|::
name|sceneEvent
argument_list|(
name|event
argument_list|)
decl_stmt|;
comment|// Ensure input context is updated.
switch|switch
condition|(
name|event
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|ContextMenu
case|:
case|case
name|QEvent
operator|::
name|FocusIn
case|:
case|case
name|QEvent
operator|::
name|FocusOut
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDragMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneDrop
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverEnter
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverLeave
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneHoverMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseDoubleClick
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMousePress
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseMove
case|:
case|case
name|QEvent
operator|::
name|GraphicsSceneMouseRelease
case|:
case|case
name|QEvent
operator|::
name|KeyPress
case|:
case|case
name|QEvent
operator|::
name|KeyRelease
case|:
comment|// Reset the focus widget's input context, regardless
comment|// of how this item gained or lost focus.
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FocusIn
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|FocusOut
condition|)
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qApp
operator|->
name|inputMethod
argument_list|()
operator|->
name|update
argument_list|(
name|Qt
operator|::
name|ImQueryInput
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QEvent
operator|::
name|ShortcutOverride
case|:
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mousePressEvent
name|void
name|QGraphicsTextItem
operator|::
name|mousePressEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|(
name|QGraphicsItem
operator|::
name|d_ptr
operator|->
name|flags
operator|&
operator|(
name|ItemIsSelectable
operator||
name|ItemIsMovable
operator|)
operator|)
operator|&&
operator|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
operator|&&
name|dd
operator|->
name|_q_mouseOnEdge
argument_list|(
name|event
argument_list|)
condition|)
block|{
comment|// User left-pressed on edge of selectable/movable item, use
comment|// base impl.
name|dd
operator|->
name|useDefaultImpl
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|buttons
argument_list|()
operator|==
name|event
operator|->
name|button
argument_list|()
operator|&&
name|dd
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|==
name|Qt
operator|::
name|NoTextInteraction
condition|)
block|{
comment|// User pressed first button on non-interactive item.
name|dd
operator|->
name|useDefaultImpl
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|dd
operator|->
name|useDefaultImpl
condition|)
block|{
name|QGraphicsItem
operator|::
name|mousePressEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|event
operator|->
name|isAccepted
argument_list|()
condition|)
name|dd
operator|->
name|useDefaultImpl
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseMoveEvent
name|void
name|QGraphicsTextItem
operator|::
name|mouseMoveEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|dd
operator|->
name|useDefaultImpl
condition|)
block|{
name|QGraphicsItem
operator|::
name|mouseMoveEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseReleaseEvent
name|void
name|QGraphicsTextItem
operator|::
name|mouseReleaseEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|dd
operator|->
name|useDefaultImpl
condition|)
block|{
name|QGraphicsItem
operator|::
name|mouseReleaseEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|==
name|Qt
operator|::
name|NoTextInteraction
operator|&&
operator|!
name|event
operator|->
name|buttons
argument_list|()
condition|)
block|{
comment|// User released last button on non-interactive item.
name|dd
operator|->
name|useDefaultImpl
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|event
operator|->
name|buttons
argument_list|()
operator|&
name|Qt
operator|::
name|LeftButton
operator|)
operator|==
literal|0
condition|)
block|{
comment|// User released the left button on an interactive item.
name|dd
operator|->
name|useDefaultImpl
operator|=
literal|false
expr_stmt|;
block|}
return|return;
block|}
name|QWidget
modifier|*
name|widget
init|=
name|event
operator|->
name|widget
argument_list|()
decl_stmt|;
if|if
condition|(
name|widget
operator|&&
operator|(
name|dd
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
operator|&
name|Qt
operator|::
name|TextEditable
operator|)
operator|&&
name|boundingRect
argument_list|()
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
condition|)
block|{
name|qt_widget_private
argument_list|(
name|widget
argument_list|)
operator|->
name|handleSoftwareInputPanel
argument_list|(
name|event
operator|->
name|button
argument_list|()
argument_list|,
name|dd
operator|->
name|clickCausedFocus
argument_list|)
expr_stmt|;
block|}
name|dd
operator|->
name|clickCausedFocus
operator|=
literal|0
expr_stmt|;
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|mouseDoubleClickEvent
name|void
name|QGraphicsTextItem
operator|::
name|mouseDoubleClickEvent
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|dd
operator|->
name|useDefaultImpl
condition|)
block|{
name|QGraphicsItem
operator|::
name|mouseDoubleClickEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|hasFocus
argument_list|()
condition|)
block|{
name|QGraphicsItem
operator|::
name|mouseDoubleClickEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contextMenuEvent
name|void
name|QGraphicsTextItem
operator|::
name|contextMenuEvent
parameter_list|(
name|QGraphicsSceneContextMenuEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|keyPressEvent
name|void
name|QGraphicsTextItem
operator|::
name|keyPressEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|keyReleaseEvent
name|void
name|QGraphicsTextItem
operator|::
name|keyReleaseEvent
parameter_list|(
name|QKeyEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusInEvent
name|void
name|QGraphicsTextItem
operator|::
name|focusInEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|reason
argument_list|()
operator|==
name|Qt
operator|::
name|MouseFocusReason
condition|)
block|{
name|dd
operator|->
name|clickCausedFocus
operator|=
literal|1
expr_stmt|;
block|}
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|focusOutEvent
name|void
name|QGraphicsTextItem
operator|::
name|focusOutEvent
parameter_list|(
name|QFocusEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragEnterEvent
name|void
name|QGraphicsTextItem
operator|::
name|dragEnterEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragLeaveEvent
name|void
name|QGraphicsTextItem
operator|::
name|dragLeaveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dragMoveEvent
name|void
name|QGraphicsTextItem
operator|::
name|dragMoveEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|dropEvent
name|void
name|QGraphicsTextItem
operator|::
name|dropEvent
parameter_list|(
name|QGraphicsSceneDragDropEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodEvent
name|void
name|QGraphicsTextItem
operator|::
name|inputMethodEvent
parameter_list|(
name|QInputMethodEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hoverEnterEvent
name|void
name|QGraphicsTextItem
operator|::
name|hoverEnterEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hoverMoveEvent
name|void
name|QGraphicsTextItem
operator|::
name|hoverMoveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|hoverLeaveEvent
name|void
name|QGraphicsTextItem
operator|::
name|hoverLeaveEvent
parameter_list|(
name|QGraphicsSceneHoverEvent
modifier|*
name|event
parameter_list|)
block|{
name|dd
operator|->
name|sendControlEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|inputMethodQuery
name|QVariant
name|QGraphicsTextItem
operator|::
name|inputMethodQuery
parameter_list|(
name|Qt
operator|::
name|InputMethodQuery
name|query
parameter_list|)
specifier|const
block|{
name|QVariant
name|v
decl_stmt|;
if|if
condition|(
name|dd
operator|->
name|control
condition|)
name|v
operator|=
name|dd
operator|->
name|control
operator|->
name|inputMethodQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|RectF
condition|)
name|v
operator|=
name|v
operator|.
name|toRectF
argument_list|()
operator|.
name|translated
argument_list|(
operator|-
name|dd
operator|->
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|PointF
condition|)
name|v
operator|=
name|v
operator|.
name|toPointF
argument_list|()
operator|-
name|dd
operator|->
name|controlOffset
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Rect
condition|)
name|v
operator|=
name|v
operator|.
name|toRect
argument_list|()
operator|.
name|translated
argument_list|(
operator|-
name|dd
operator|->
name|controlOffset
argument_list|()
operator|.
name|toPoint
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Point
condition|)
name|v
operator|=
name|v
operator|.
name|toPoint
argument_list|()
operator|-
name|dd
operator|->
name|controlOffset
argument_list|()
operator|.
name|toPoint
argument_list|()
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsTextItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsTextItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsTextItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_update
name|void
name|QGraphicsTextItemPrivate
operator|::
name|_q_update
parameter_list|(
name|QRectF
name|rect
parameter_list|)
block|{
if|if
condition|(
name|rect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|rect
operator|.
name|translate
argument_list|(
operator|-
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rect
operator|=
name|boundingRect
expr_stmt|;
block|}
if|if
condition|(
name|rect
operator|.
name|intersects
argument_list|(
name|boundingRect
argument_list|)
condition|)
name|qq
operator|->
name|update
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_updateBoundingRect
name|void
name|QGraphicsTextItemPrivate
operator|::
name|_q_updateBoundingRect
parameter_list|(
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|control
condition|)
return|return;
comment|// can't happen
specifier|const
name|QSizeF
name|pageSize
init|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|pageSize
argument_list|()
decl_stmt|;
comment|// paged items have a constant (page) size
if|if
condition|(
name|size
operator|==
name|boundingRect
operator|.
name|size
argument_list|()
operator|||
name|pageSize
operator|.
name|height
argument_list|()
operator|!=
operator|-
literal|1
condition|)
return|return;
name|qq
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|boundingRect
operator|.
name|setSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|qq
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_ensureVisible
name|void
name|QGraphicsTextItemPrivate
operator|::
name|_q_ensureVisible
parameter_list|(
name|QRectF
name|rect
parameter_list|)
block|{
if|if
condition|(
name|qq
operator|->
name|hasFocus
argument_list|()
condition|)
block|{
name|rect
operator|.
name|translate
argument_list|(
operator|-
name|controlOffset
argument_list|()
argument_list|)
expr_stmt|;
name|qq
operator|->
name|ensureVisible
argument_list|(
name|rect
argument_list|,
comment|/*xmargin=*/
literal|0
argument_list|,
comment|/*ymargin=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|textControl
name|QWidgetTextControl
modifier|*
name|QGraphicsTextItemPrivate
operator|::
name|textControl
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|control
condition|)
block|{
name|QGraphicsTextItem
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QGraphicsTextItem
operator|*
argument_list|>
argument_list|(
name|qq
argument_list|)
decl_stmt|;
name|control
operator|=
operator|new
name|QWidgetTextControl
argument_list|(
name|that
argument_list|)
expr_stmt|;
name|control
operator|->
name|setTextInteractionFlags
argument_list|(
name|Qt
operator|::
name|NoTextInteraction
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|updateRequest
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|qq
argument_list|,
name|SLOT
argument_list|(
name|_q_update
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|documentSizeChanged
argument_list|(
name|QSizeF
argument_list|)
argument_list|)
argument_list|,
name|qq
argument_list|,
name|SLOT
argument_list|(
name|_q_updateBoundingRect
argument_list|(
name|QSizeF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|visibilityRequest
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|,
name|qq
argument_list|,
name|SLOT
argument_list|(
name|_q_ensureVisible
argument_list|(
name|QRectF
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkActivated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|qq
argument_list|,
name|SIGNAL
argument_list|(
name|linkActivated
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|control
argument_list|,
name|SIGNAL
argument_list|(
name|linkHovered
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|qq
argument_list|,
name|SIGNAL
argument_list|(
name|linkHovered
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QSizeF
name|pgSize
init|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|pageSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|pgSize
operator|.
name|height
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|qq
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|that
operator|->
name|dd
operator|->
name|boundingRect
operator|.
name|setSize
argument_list|(
name|pgSize
argument_list|)
expr_stmt|;
name|qq
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|that
operator|->
name|dd
operator|->
name|_q_updateBoundingRect
argument_list|(
name|control
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|control
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_mouseOnEdge
name|bool
name|QGraphicsTextItemPrivate
operator|::
name|_q_mouseOnEdge
parameter_list|(
name|QGraphicsSceneMouseEvent
modifier|*
name|event
parameter_list|)
block|{
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|qq
operator|->
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|QPainterPath
name|docPath
decl_stmt|;
specifier|const
name|QTextFrameFormat
name|format
init|=
name|control
operator|->
name|document
argument_list|()
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|docPath
operator|.
name|addRect
argument_list|(
name|qq
operator|->
name|boundingRect
argument_list|()
operator|.
name|adjusted
argument_list|(
name|format
operator|.
name|leftMargin
argument_list|()
argument_list|,
name|format
operator|.
name|topMargin
argument_list|()
argument_list|,
operator|-
name|format
operator|.
name|rightMargin
argument_list|()
argument_list|,
operator|-
name|format
operator|.
name|bottomMargin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path
operator|.
name|subtracted
argument_list|(
name|docPath
argument_list|)
operator|.
name|contains
argument_list|(
name|event
operator|->
name|pos
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsTextItem::linkActivated(const QString&link)      This signal is emitted when the user clicks on a link on a text item     that enables Qt::LinksAccessibleByMouse or Qt::LinksAccessibleByKeyboard.     \a link is the link that was clicked.      \sa setTextInteractionFlags() */
end_comment
begin_comment
comment|/*!     \fn QGraphicsTextItem::linkHovered(const QString&link)      This signal is emitted when the user hovers over a link on a text item     that enables Qt::LinksAccessibleByMouse. \a link is     the link that was hovered over.      \sa setTextInteractionFlags() */
end_comment
begin_comment
comment|/*!     Sets the flags \a flags to specify how the text item should react to user     input.      The default for a QGraphicsTextItem is Qt::NoTextInteraction. This function     also affects the ItemIsFocusable QGraphicsItem flag by setting it if \a flags     is different from Qt::NoTextInteraction and clearing it otherwise.      By default, the text is read-only. To transform the item into an editor,     set the Qt::TextEditable flag. */
end_comment
begin_function
DECL|function|setTextInteractionFlags
name|void
name|QGraphicsTextItem
operator|::
name|setTextInteractionFlags
parameter_list|(
name|Qt
operator|::
name|TextInteractionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|==
name|Qt
operator|::
name|NoTextInteraction
condition|)
name|setFlags
argument_list|(
name|this
operator|->
name|flags
argument_list|()
operator|&
operator|~
operator|(
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator||
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
operator|)
argument_list|)
expr_stmt|;
else|else
name|setFlags
argument_list|(
name|this
operator|->
name|flags
argument_list|()
operator||
name|QGraphicsItem
operator|::
name|ItemIsFocusable
operator||
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
argument_list|)
expr_stmt|;
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setTextInteractionFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current text interaction flags.      \sa setTextInteractionFlags() */
end_comment
begin_function
DECL|function|textInteractionFlags
name|Qt
operator|::
name|TextInteractionFlags
name|QGraphicsTextItem
operator|::
name|textInteractionFlags
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
name|Qt
operator|::
name|NoTextInteraction
return|;
return|return
name|dd
operator|->
name|control
operator|->
name|textInteractionFlags
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      If \a b is true, the \uicontrol Tab key will cause the widget to change focus;     otherwise, the tab key will insert a tab into the document.      In some occasions text edits should not allow the user to input tabulators     or change indentation using the \uicontrol Tab key, as this breaks the focus     chain. The default is false.      \sa tabChangesFocus(), ItemIsFocusable, textInteractionFlags() */
end_comment
begin_function
DECL|function|setTabChangesFocus
name|void
name|QGraphicsTextItem
operator|::
name|setTabChangesFocus
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|dd
operator|->
name|tabChangesFocus
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns true if the \uicontrol Tab key will cause the widget to change focus;     otherwise, false is returned.      By default, this behavior is disabled, and this function will return false.      \sa setTabChangesFocus() */
end_comment
begin_function
DECL|function|tabChangesFocus
name|bool
name|QGraphicsTextItem
operator|::
name|tabChangesFocus
parameter_list|()
specifier|const
block|{
return|return
name|dd
operator|->
name|tabChangesFocus
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsTextItem::openExternalLinks      Specifies whether QGraphicsTextItem should automatically open links using     QDesktopServices::openUrl() instead of emitting the     linkActivated signal.      The default value is false. */
end_comment
begin_function
DECL|function|setOpenExternalLinks
name|void
name|QGraphicsTextItem
operator|::
name|setOpenExternalLinks
parameter_list|(
name|bool
name|open
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setOpenExternalLinks
argument_list|(
name|open
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|openExternalLinks
name|bool
name|QGraphicsTextItem
operator|::
name|openExternalLinks
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
literal|false
return|;
return|return
name|dd
operator|->
name|control
operator|->
name|openExternalLinks
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsTextItem::textCursor      This property represents the visible text cursor in an editable     text item.      By default, if the item's text has not been set, this property     contains a null text cursor; otherwise it contains a text cursor     placed at the start of the item's document. */
end_comment
begin_function
DECL|function|setTextCursor
name|void
name|QGraphicsTextItem
operator|::
name|setTextCursor
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|dd
operator|->
name|textControl
argument_list|()
operator|->
name|setTextCursor
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textCursor
name|QTextCursor
name|QGraphicsTextItem
operator|::
name|textCursor
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|dd
operator|->
name|control
condition|)
return|return
name|QTextCursor
argument_list|()
return|;
return|return
name|dd
operator|->
name|control
operator|->
name|textCursor
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QGraphicsSimpleTextItemPrivate
class|class
name|QGraphicsSimpleTextItemPrivate
super|:
specifier|public
name|QAbstractGraphicsShapeItemPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QGraphicsSimpleTextItem
parameter_list|)
specifier|public
private|:
DECL|function|QGraphicsSimpleTextItemPrivate
specifier|inline
name|QGraphicsSimpleTextItemPrivate
parameter_list|()
block|{
name|pen
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|brush
operator|.
name|setStyle
argument_list|(
name|Qt
operator|::
name|SolidPattern
argument_list|)
expr_stmt|;
block|}
DECL|member|text
name|QString
name|text
decl_stmt|;
DECL|member|font
name|QFont
name|font
decl_stmt|;
DECL|member|boundingRect
name|QRectF
name|boundingRect
decl_stmt|;
name|void
name|updateBoundingRect
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|setupTextLayout
specifier|static
name|QRectF
name|setupTextLayout
parameter_list|(
name|QTextLayout
modifier|*
name|layout
parameter_list|)
block|{
name|layout
operator|->
name|setCacheEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|layout
operator|->
name|beginLayout
argument_list|()
expr_stmt|;
while|while
condition|(
name|layout
operator|->
name|createLine
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
empty_stmt|;
name|layout
operator|->
name|endLayout
argument_list|()
expr_stmt|;
name|qreal
name|maxWidth
init|=
literal|0
decl_stmt|;
name|qreal
name|y
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|layout
operator|->
name|lineCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextLine
name|line
init|=
name|layout
operator|->
name|lineAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxWidth
operator|=
name|qMax
argument_list|(
name|maxWidth
argument_list|,
name|line
operator|.
name|naturalTextWidth
argument_list|()
argument_list|)
expr_stmt|;
name|line
operator|.
name|setPosition
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|+=
name|line
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
return|return
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|maxWidth
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|updateBoundingRect
name|void
name|QGraphicsSimpleTextItemPrivate
operator|::
name|updateBoundingRect
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
name|QRectF
name|br
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|br
operator|=
name|QRectF
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QString
name|tmp
init|=
name|text
decl_stmt|;
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QChar
operator|::
name|LineSeparator
argument_list|)
expr_stmt|;
name|QStackTextEngine
name|engine
argument_list|(
name|tmp
argument_list|,
name|font
argument_list|)
decl_stmt|;
name|QTextLayout
name|layout
argument_list|(
operator|&
name|engine
argument_list|)
decl_stmt|;
name|br
operator|=
name|setupTextLayout
argument_list|(
operator|&
name|layout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|br
operator|!=
name|boundingRect
condition|)
block|{
name|q
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|boundingRect
operator|=
name|br
expr_stmt|;
name|q
operator|->
name|update
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsSimpleTextItem     \brief The QGraphicsSimpleTextItem class provides a simple text path item     that you can add to a QGraphicsScene.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      To set the item's text, you can either pass a QString to     QGraphicsSimpleTextItem's constructor, or call setText() to change the     text later. To set the text fill color, call setBrush().      The simple text item can have both a fill and an outline; setBrush() will     set the text fill (i.e., text color), and setPen() sets the pen that will     be used to draw the text outline. (The latter can be slow, especially for     complex pens, and items with long text content.) If all you want is to     draw a simple line of text, you should call setBrush() only, and leave the     pen unset; QGraphicsSimpleTextItem's pen is by default Qt::NoPen.      QGraphicsSimpleTextItem uses the text's formatted size and the associated     font to provide a reasonable implementation of boundingRect(), shape(),     and contains(). You can set the font by calling setFont().      QGraphicsSimpleText does not display rich text; instead, you can use     QGraphicsTextItem, which provides full text control capabilities.      \img graphicsview-simpletextitem.png      \sa QGraphicsTextItem, QGraphicsPathItem, QGraphicsRectItem,     QGraphicsEllipseItem, QGraphicsPixmapItem, QGraphicsPolygonItem,     QGraphicsLineItem, {Graphics View Framework} */
end_comment
begin_comment
comment|/*!     Constructs a QGraphicsSimpleTextItem.      \a parent is passed to QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsSimpleTextItem
name|QGraphicsSimpleTextItem
operator|::
name|QGraphicsSimpleTextItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsSimpleTextItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QGraphicsSimpleTextItem, using \a text as the default plain text.      \a parent is passed to QGraphicsItem's constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsSimpleTextItem
name|QGraphicsSimpleTextItem
operator|::
name|QGraphicsSimpleTextItem
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QAbstractGraphicsShapeItem
argument_list|(
operator|*
operator|new
name|QGraphicsSimpleTextItemPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsSimpleTextItem. */
end_comment
begin_destructor
DECL|function|~QGraphicsSimpleTextItem
name|QGraphicsSimpleTextItem
operator|::
name|~
name|QGraphicsSimpleTextItem
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the item's text to \a text. The text will be displayed as     plain text. Newline characters ('\n') as well as characters of     type QChar::LineSeparator will cause item to break the text into     multiple lines. */
end_comment
begin_function
DECL|function|setText
name|void
name|QGraphicsSimpleTextItem
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|==
name|text
condition|)
return|return;
name|d
operator|->
name|text
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|updateBoundingRect
argument_list|()
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the item's text. */
end_comment
begin_function
DECL|function|text
name|QString
name|QGraphicsSimpleTextItem
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the font that is used to draw the item's text to \a font. */
end_comment
begin_function
DECL|function|setFont
name|void
name|QGraphicsSimpleTextItem
operator|::
name|setFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
name|d
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|d
operator|->
name|updateBoundingRect
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the font that is used to draw the item's text. */
end_comment
begin_function
DECL|function|font
name|QFont
name|QGraphicsSimpleTextItem
operator|::
name|font
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|font
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsSimpleTextItem
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|boundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|shape
name|QPainterPath
name|QGraphicsSimpleTextItem
operator|::
name|shape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|path
operator|.
name|addRect
argument_list|(
name|d
operator|->
name|boundingRect
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|contains
name|bool
name|QGraphicsSimpleTextItem
operator|::
name|contains
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|point
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|boundingRect
operator|.
name|contains
argument_list|(
name|point
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsSimpleTextItem
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QGraphicsSimpleTextItem
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setFont
argument_list|(
name|d
operator|->
name|font
argument_list|)
expr_stmt|;
name|QString
name|tmp
init|=
name|d
operator|->
name|text
decl_stmt|;
name|tmp
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QChar
operator|::
name|LineSeparator
argument_list|)
expr_stmt|;
name|QStackTextEngine
name|engine
argument_list|(
name|tmp
argument_list|,
name|d
operator|->
name|font
argument_list|)
decl_stmt|;
name|QTextLayout
name|layout
argument_list|(
operator|&
name|engine
argument_list|)
decl_stmt|;
name|setupTextLayout
argument_list|(
operator|&
name|layout
argument_list|)
expr_stmt|;
name|QPen
name|p
decl_stmt|;
name|p
operator|.
name|setBrush
argument_list|(
name|d
operator|->
name|brush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setPen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
operator|&&
name|d
operator|->
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTextLayout
operator|::
name|FormatRange
name|range
decl_stmt|;
name|range
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|range
operator|.
name|length
operator|=
name|layout
operator|.
name|text
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
name|range
operator|.
name|format
operator|.
name|setTextOutline
argument_list|(
name|d
operator|->
name|pen
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QTextLayout
operator|::
name|FormatRange
argument_list|>
name|formats
decl_stmt|;
name|formats
operator|.
name|append
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|layout
operator|.
name|setAdditionalFormats
argument_list|(
name|formats
argument_list|)
expr_stmt|;
block|}
name|layout
operator|.
name|draw
argument_list|(
name|painter
argument_list|,
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
operator|(
name|QStyle
operator|::
name|State_Selected
operator||
name|QStyle
operator|::
name|State_HasFocus
operator|)
condition|)
name|qt_graphicsItem_highlightSelected
argument_list|(
name|this
argument_list|,
name|painter
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsSimpleTextItem
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsSimpleTextItem
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QAbstractGraphicsShapeItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsSimpleTextItem
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportsExtension
name|bool
name|QGraphicsSimpleTextItem
operator|::
name|supportsExtension
parameter_list|(
name|Extension
name|extension
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setExtension
name|void
name|QGraphicsSimpleTextItem
operator|::
name|setExtension
parameter_list|(
name|Extension
name|extension
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|extension
name|QVariant
name|QGraphicsSimpleTextItem
operator|::
name|extension
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QGraphicsItemGroup     \brief The QGraphicsItemGroup class provides a container that treats     a group of items as a single item.     \since 4.2     \ingroup graphicsview-api     \inmodule QtWidgets      A QGraphicsItemGroup is a special type of compound item that     treats itself and all its children as one item (i.e., all events     and geometries for all children are merged together). It's common     to use item groups in presentation tools, when the user wants to     group several smaller items into one big item in order to simplify     moving and copying of items.      If all you want is to store items inside other items, you can use     any QGraphicsItem directly by passing a suitable parent to     setParentItem().      The boundingRect() function of QGraphicsItemGroup returns the     bounding rectangle of all items in the item group.     QGraphicsItemGroup ignores the ItemIgnoresTransformations flag on     its children (i.e., with respect to the geometry of the group     item, the children are treated as if they were transformable).      There are two ways to construct an item group. The easiest and     most common approach is to pass a list of items (e.g., all     selected items) to QGraphicsScene::createItemGroup(), which     returns a new QGraphicsItemGroup item. The other approach is to     manually construct a QGraphicsItemGroup item, add it to the scene     calling QGraphicsScene::addItem(), and then add items to the group     manually, one at a time by calling addToGroup(). To dismantle     ("ungroup") an item group, you can either call     QGraphicsScene::destroyItemGroup(), or you can manually remove all     items from the group by calling removeFromGroup().      \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 17      The operation of adding and removing items preserves the items'     scene-relative position and transformation, as opposed to calling     setParentItem(), where only the child item's parent-relative     position and transformation are kept.      The addtoGroup() function reparents the target item to this item     group, keeping the item's position and transformation intact     relative to the scene. Visually, this means that items added via     addToGroup() will remain completely unchanged as a result of this     operation, regardless of the item or the group's current position     or transformation; although the item's position and matrix are     likely to change.      The removeFromGroup() function has similar semantics to     setParentItem(); it reparents the item to the parent item of the     item group. As with addToGroup(), the item's scene-relative     position and transformation remain intact.      \sa QGraphicsItem, {Graphics View Framework} */
end_comment
begin_class
DECL|class|QGraphicsItemGroupPrivate
class|class
name|QGraphicsItemGroupPrivate
super|:
specifier|public
name|QGraphicsItemPrivate
block|{
public|public:
DECL|member|itemsBoundingRect
name|QRectF
name|itemsBoundingRect
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGraphicsItemGroup. \a parent is passed to QGraphicsItem's     constructor.      \sa QGraphicsScene::addItem() */
end_comment
begin_constructor
DECL|function|QGraphicsItemGroup
name|QGraphicsItemGroup
operator|::
name|QGraphicsItemGroup
parameter_list|(
name|QGraphicsItem
modifier|*
name|parent
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// obsolete argument
parameter_list|,
name|QGraphicsScene
modifier|*
name|scene
endif|#
directive|endif
parameter_list|)
member_init_list|:
name|QGraphicsItem
argument_list|(
operator|*
operator|new
name|QGraphicsItemGroupPrivate
argument_list|,
name|parent
argument_list|,
name|scene
argument_list|)
block|{
name|setHandlesChildEvents
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QGraphicsItemGroup. */
end_comment
begin_destructor
DECL|function|~QGraphicsItemGroup
name|QGraphicsItemGroup
operator|::
name|~
name|QGraphicsItemGroup
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Adds the given \a item and item's child items to this item group.     The item and child items will be reparented to this group, but its     position and transformation relative to the scene will stay intact.      \sa removeFromGroup(), QGraphicsScene::createItemGroup() */
end_comment
begin_function
DECL|function|addToGroup
name|void
name|QGraphicsItemGroup
operator|::
name|addToGroup
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItemGroup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItemGroup::addToGroup: cannot add null item"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|item
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItemGroup::addToGroup: cannot add a group to itself"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// COMBINE
name|bool
name|ok
decl_stmt|;
name|QTransform
name|itemTransform
init|=
name|item
operator|->
name|itemTransform
argument_list|(
name|this
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItemGroup::addToGroup: could not find a valid transformation from item to group coordinates"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QTransform
name|newItemTransform
argument_list|(
name|itemTransform
argument_list|)
decl_stmt|;
name|item
operator|->
name|setPos
argument_list|(
name|mapFromItem
argument_list|(
name|item
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|setParentItem
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// removing position from translation component of the new transform
if|if
condition|(
operator|!
name|item
operator|->
name|pos
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|newItemTransform
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|item
operator|->
name|x
argument_list|()
argument_list|,
operator|-
name|item
operator|->
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// removing additional transformations properties applied with itemTransform()
name|QPointF
name|origin
init|=
name|item
operator|->
name|transformOriginPoint
argument_list|()
decl_stmt|;
name|QMatrix4x4
name|m
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsTransform
modifier|*
argument_list|>
name|transformList
init|=
name|item
operator|->
name|transformations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|transformList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|applyTo
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|newItemTransform
operator|*=
name|m
operator|.
name|toTransform
argument_list|()
operator|.
name|inverted
argument_list|()
expr_stmt|;
name|newItemTransform
operator|.
name|translate
argument_list|(
name|origin
operator|.
name|x
argument_list|()
argument_list|,
name|origin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|newItemTransform
operator|.
name|rotate
argument_list|(
operator|-
name|item
operator|->
name|rotation
argument_list|()
argument_list|)
expr_stmt|;
name|newItemTransform
operator|.
name|scale
argument_list|(
literal|1
operator|/
name|item
operator|->
name|scale
argument_list|()
argument_list|,
literal|1
operator|/
name|item
operator|->
name|scale
argument_list|()
argument_list|)
expr_stmt|;
name|newItemTransform
operator|.
name|translate
argument_list|(
operator|-
name|origin
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|origin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### Expensive, we could maybe use dirtySceneTransform bit for optimization
name|item
operator|->
name|setTransform
argument_list|(
name|newItemTransform
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|setIsMemberOfGroup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|itemsBoundingRect
operator||=
name|itemTransform
operator|.
name|mapRect
argument_list|(
name|item
operator|->
name|boundingRect
argument_list|()
operator||
name|item
operator|->
name|childrenBoundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the specified \a item from this group. The item will be     reparented to this group's parent item, or to 0 if this group has     no parent.  Its position and transformation relative to the scene     will stay intact.      \sa addToGroup(), QGraphicsScene::destroyItemGroup() */
end_comment
begin_function
DECL|function|removeFromGroup
name|void
name|QGraphicsItemGroup
operator|::
name|removeFromGroup
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItemGroup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsItemGroup::removeFromGroup: cannot remove null item"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QGraphicsItem
modifier|*
name|newParent
init|=
name|d_ptr
operator|->
name|parent
decl_stmt|;
comment|// COMBINE
name|bool
name|ok
decl_stmt|;
name|QTransform
name|itemTransform
decl_stmt|;
if|if
condition|(
name|newParent
condition|)
name|itemTransform
operator|=
name|item
operator|->
name|itemTransform
argument_list|(
name|newParent
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
else|else
name|itemTransform
operator|=
name|item
operator|->
name|sceneTransform
argument_list|()
expr_stmt|;
name|QPointF
name|oldPos
init|=
name|item
operator|->
name|mapToItem
argument_list|(
name|newParent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|item
operator|->
name|setParentItem
argument_list|(
name|newParent
argument_list|)
expr_stmt|;
name|item
operator|->
name|setPos
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
comment|// removing position from translation component of the new transform
if|if
condition|(
operator|!
name|item
operator|->
name|pos
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|itemTransform
operator|*=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|item
operator|->
name|x
argument_list|()
argument_list|,
operator|-
name|item
operator|->
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// removing additional transformations properties applied
comment|// with itemTransform() or sceneTransform()
name|QPointF
name|origin
init|=
name|item
operator|->
name|transformOriginPoint
argument_list|()
decl_stmt|;
name|QMatrix4x4
name|m
decl_stmt|;
name|QList
argument_list|<
name|QGraphicsTransform
modifier|*
argument_list|>
name|transformList
init|=
name|item
operator|->
name|transformations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|transformList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|transformList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|applyTo
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
name|itemTransform
operator|*=
name|m
operator|.
name|toTransform
argument_list|()
operator|.
name|inverted
argument_list|()
expr_stmt|;
name|itemTransform
operator|.
name|translate
argument_list|(
name|origin
operator|.
name|x
argument_list|()
argument_list|,
name|origin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|itemTransform
operator|.
name|rotate
argument_list|(
operator|-
name|item
operator|->
name|rotation
argument_list|()
argument_list|)
expr_stmt|;
name|itemTransform
operator|.
name|scale
argument_list|(
literal|1
operator|/
name|item
operator|->
name|scale
argument_list|()
argument_list|,
literal|1
operator|/
name|item
operator|->
name|scale
argument_list|()
argument_list|)
expr_stmt|;
name|itemTransform
operator|.
name|translate
argument_list|(
operator|-
name|origin
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|origin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### Expensive, we could maybe use dirtySceneTransform bit for optimization
name|item
operator|->
name|setTransform
argument_list|(
name|itemTransform
argument_list|)
expr_stmt|;
name|item
operator|->
name|d_func
argument_list|()
operator|->
name|setIsMemberOfGroup
argument_list|(
name|item
operator|->
name|group
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// ### Quite expensive. But removeFromGroup() isn't called very often.
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|d
operator|->
name|itemsBoundingRect
operator|=
name|childrenBoundingRect
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Returns the bounding rect of this group item, and all its children. */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsItemGroup
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsItemGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|itemsBoundingRect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|paint
name|void
name|QGraphicsItemGroup
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QStyleOptionGraphicsItem
modifier|*
name|option
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Selected
condition|)
block|{
name|Q_D
argument_list|(
name|QGraphicsItemGroup
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|d
operator|->
name|itemsBoundingRect
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|isObscuredBy
name|bool
name|QGraphicsItemGroup
operator|::
name|isObscuredBy
parameter_list|(
specifier|const
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|isObscuredBy
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|opaqueArea
name|QPainterPath
name|QGraphicsItemGroup
operator|::
name|opaqueArea
parameter_list|()
specifier|const
block|{
return|return
name|QGraphicsItem
operator|::
name|opaqueArea
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|type
name|int
name|QGraphicsItemGroup
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSEFFECT
end_ifndef
begin_function
DECL|function|boundingRect
name|QRectF
name|QGraphicsItemEffectSourcePrivate
operator|::
name|boundingRect
parameter_list|(
name|Qt
operator|::
name|CoordinateSystem
name|system
parameter_list|)
specifier|const
block|{
specifier|const
name|bool
name|deviceCoordinates
init|=
operator|(
name|system
operator|==
name|Qt
operator|::
name|DeviceCoordinates
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|&&
name|deviceCoordinates
condition|)
block|{
comment|// Device coordinates without info not yet supported.
name|qWarning
argument_list|(
literal|"QGraphicsEffectSource::boundingRect: Not yet implemented, lacking device context"
argument_list|)
expr_stmt|;
return|return
name|QRectF
argument_list|()
return|;
block|}
name|QRectF
name|rect
init|=
name|item
operator|->
name|boundingRect
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|rect
operator||=
name|item
operator|->
name|childrenBoundingRect
argument_list|()
expr_stmt|;
if|if
condition|(
name|deviceCoordinates
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|info
operator|->
name|painter
argument_list|)
expr_stmt|;
name|rect
operator|=
name|info
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
return|return
name|rect
return|;
block|}
end_function
begin_function
DECL|function|draw
name|void
name|QGraphicsItemEffectSourcePrivate
operator|::
name|draw
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGraphicsEffectSource::draw: Can only begin as a result of QGraphicsEffect::draw"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_ASSERT
argument_list|(
name|item
operator|->
name|d_ptr
operator|->
name|scene
argument_list|)
expr_stmt|;
name|QGraphicsScenePrivate
modifier|*
name|scened
init|=
name|item
operator|->
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|painter
operator|==
name|info
operator|->
name|painter
condition|)
block|{
name|scened
operator|->
name|draw
argument_list|(
name|item
argument_list|,
name|painter
argument_list|,
name|info
operator|->
name|viewTransform
argument_list|,
name|info
operator|->
name|transformPtr
argument_list|,
name|info
operator|->
name|exposedRegion
argument_list|,
name|info
operator|->
name|widget
argument_list|,
name|info
operator|->
name|opacity
argument_list|,
name|info
operator|->
name|effectTransform
argument_list|,
name|info
operator|->
name|wasDirtySceneTransform
argument_list|,
name|info
operator|->
name|drawItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QTransform
name|effectTransform
init|=
name|info
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|effectTransform
operator|*=
name|painter
operator|->
name|worldTransform
argument_list|()
expr_stmt|;
name|scened
operator|->
name|draw
argument_list|(
name|item
argument_list|,
name|painter
argument_list|,
name|info
operator|->
name|viewTransform
argument_list|,
name|info
operator|->
name|transformPtr
argument_list|,
name|info
operator|->
name|exposedRegion
argument_list|,
name|info
operator|->
name|widget
argument_list|,
name|info
operator|->
name|opacity
argument_list|,
operator|&
name|effectTransform
argument_list|,
name|info
operator|->
name|wasDirtySceneTransform
argument_list|,
name|info
operator|->
name|drawItem
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// sourceRect must be in the given coordinate system
end_comment
begin_function
DECL|function|paddedEffectRect
name|QRect
name|QGraphicsItemEffectSourcePrivate
operator|::
name|paddedEffectRect
parameter_list|(
name|Qt
operator|::
name|CoordinateSystem
name|system
parameter_list|,
name|QGraphicsEffect
operator|::
name|PixmapPadMode
name|mode
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sourceRect
parameter_list|,
name|bool
modifier|*
name|unpadded
parameter_list|)
specifier|const
block|{
name|QRectF
name|effectRectF
decl_stmt|;
if|if
condition|(
name|unpadded
condition|)
operator|*
name|unpadded
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QGraphicsEffect
operator|::
name|PadToEffectiveBoundingRect
condition|)
block|{
if|if
condition|(
name|info
condition|)
block|{
name|QRectF
name|deviceRect
init|=
name|system
operator|==
name|Qt
operator|::
name|DeviceCoordinates
condition|?
name|sourceRect
else|:
name|info
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|mapRect
argument_list|(
name|sourceRect
argument_list|)
decl_stmt|;
name|effectRectF
operator|=
name|item
operator|->
name|graphicsEffect
argument_list|()
operator|->
name|boundingRectFor
argument_list|(
name|deviceRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpadded
condition|)
operator|*
name|unpadded
operator|=
operator|(
name|effectRectF
operator|.
name|size
argument_list|()
operator|==
name|sourceRect
operator|.
name|size
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|&&
name|system
operator|==
name|Qt
operator|::
name|LogicalCoordinates
condition|)
name|effectRectF
operator|=
name|info
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|inverted
argument_list|()
operator|.
name|mapRect
argument_list|(
name|effectRectF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no choice but to send a logical coordinate bounding rect to boundingRectFor
name|effectRectF
operator|=
name|item
operator|->
name|graphicsEffect
argument_list|()
operator|->
name|boundingRectFor
argument_list|(
name|sourceRect
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|QGraphicsEffect
operator|::
name|PadToTransparentBorder
condition|)
block|{
comment|// adjust by 1.5 to account for cosmetic pens
name|effectRectF
operator|=
name|sourceRect
operator|.
name|adjusted
argument_list|(
operator|-
literal|1.5
argument_list|,
operator|-
literal|1.5
argument_list|,
literal|1.5
argument_list|,
literal|1.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|effectRectF
operator|=
name|sourceRect
expr_stmt|;
if|if
condition|(
name|unpadded
condition|)
operator|*
name|unpadded
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|effectRectF
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|pixmap
name|QPixmap
name|QGraphicsItemEffectSourcePrivate
operator|::
name|pixmap
parameter_list|(
name|Qt
operator|::
name|CoordinateSystem
name|system
parameter_list|,
name|QPoint
modifier|*
name|offset
parameter_list|,
name|QGraphicsEffect
operator|::
name|PixmapPadMode
name|mode
parameter_list|)
specifier|const
block|{
specifier|const
name|bool
name|deviceCoordinates
init|=
operator|(
name|system
operator|==
name|Qt
operator|::
name|DeviceCoordinates
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|&&
name|deviceCoordinates
condition|)
block|{
comment|// Device coordinates without info not yet supported.
name|qWarning
argument_list|(
literal|"QGraphicsEffectSource::pixmap: Not yet implemented, lacking device context"
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|item
operator|->
name|d_ptr
operator|->
name|scene
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QGraphicsScenePrivate
modifier|*
name|scened
init|=
name|item
operator|->
name|d_ptr
operator|->
name|scene
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|bool
name|unpadded
decl_stmt|;
specifier|const
name|QRectF
name|sourceRect
init|=
name|boundingRect
argument_list|(
name|system
argument_list|)
decl_stmt|;
name|QRect
name|effectRect
init|=
name|paddedEffectRect
argument_list|(
name|system
argument_list|,
name|mode
argument_list|,
name|sourceRect
argument_list|,
operator|&
name|unpadded
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|effectRect
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|bool
name|untransformed
init|=
operator|!
name|deviceCoordinates
operator|||
name|info
operator|->
name|painter
operator|->
name|worldTransform
argument_list|()
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
decl_stmt|;
if|if
condition|(
name|untransformed
operator|&&
name|unpadded
operator|&&
name|isPixmap
argument_list|()
condition|)
block|{
if|if
condition|(
name|offset
condition|)
operator|*
name|offset
operator|=
name|boundingRect
argument_list|(
name|system
argument_list|)
operator|.
name|topLeft
argument_list|()
operator|.
name|toPoint
argument_list|()
expr_stmt|;
return|return
cast|static_cast
argument_list|<
name|QGraphicsPixmapItem
operator|*
argument_list|>
argument_list|(
name|item
argument_list|)
operator|->
name|pixmap
argument_list|()
return|;
block|}
if|if
condition|(
name|effectRect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QPixmap
name|pixmap
argument_list|(
name|effectRect
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|QPainter
name|pixmapPainter
argument_list|(
operator|&
name|pixmap
argument_list|)
decl_stmt|;
name|pixmapPainter
operator|.
name|setRenderHints
argument_list|(
name|info
condition|?
name|info
operator|->
name|painter
operator|->
name|renderHints
argument_list|()
else|:
name|QPainter
operator|::
name|TextAntialiasing
argument_list|)
expr_stmt|;
name|QTransform
name|effectTransform
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
operator|-
name|effectRect
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|effectRect
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|deviceCoordinates
operator|&&
name|info
operator|->
name|effectTransform
condition|)
name|effectTransform
operator|*=
operator|*
name|info
operator|->
name|effectTransform
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
block|{
comment|// Logical coordinates without info.
name|QTransform
name|sceneTransform
init|=
name|item
operator|->
name|sceneTransform
argument_list|()
decl_stmt|;
name|QTransform
name|newEffectTransform
init|=
name|sceneTransform
operator|.
name|inverted
argument_list|()
decl_stmt|;
name|newEffectTransform
operator|*=
name|effectTransform
expr_stmt|;
name|scened
operator|->
name|draw
argument_list|(
name|item
argument_list|,
operator|&
name|pixmapPainter
argument_list|,
literal|0
argument_list|,
operator|&
name|sceneTransform
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
operator|&
name|newEffectTransform
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|deviceCoordinates
condition|)
block|{
comment|// Device coordinates with info.
name|scened
operator|->
name|draw
argument_list|(
name|item
argument_list|,
operator|&
name|pixmapPainter
argument_list|,
name|info
operator|->
name|viewTransform
argument_list|,
name|info
operator|->
name|transformPtr
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|widget
argument_list|,
name|info
operator|->
name|opacity
argument_list|,
operator|&
name|effectTransform
argument_list|,
name|info
operator|->
name|wasDirtySceneTransform
argument_list|,
name|info
operator|->
name|drawItem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Item coordinates with info.
name|QTransform
name|newEffectTransform
init|=
name|info
operator|->
name|transformPtr
operator|->
name|inverted
argument_list|()
decl_stmt|;
name|newEffectTransform
operator|*=
name|effectTransform
expr_stmt|;
name|scened
operator|->
name|draw
argument_list|(
name|item
argument_list|,
operator|&
name|pixmapPainter
argument_list|,
name|info
operator|->
name|viewTransform
argument_list|,
name|info
operator|->
name|transformPtr
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|widget
argument_list|,
name|info
operator|->
name|opacity
argument_list|,
operator|&
name|newEffectTransform
argument_list|,
name|info
operator|->
name|wasDirtySceneTransform
argument_list|,
name|info
operator|->
name|drawItem
argument_list|)
expr_stmt|;
block|}
name|pixmapPainter
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSEFFECT
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|debug
operator|<<
literal|"QGraphicsItem(0)"
expr_stmt|;
return|return
name|debug
return|;
block|}
if|if
condition|(
name|QGraphicsObject
modifier|*
name|o
init|=
name|item
operator|->
name|toGraphicsObject
argument_list|()
condition|)
name|debug
operator|<<
name|o
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
expr_stmt|;
else|else
name|debug
operator|<<
literal|"QGraphicsItem"
expr_stmt|;
name|debug
operator|<<
literal|"(this ="
operator|<<
operator|(
name|void
operator|*
operator|)
name|item
operator|<<
literal|", parent ="
operator|<<
operator|(
name|void
operator|*
operator|)
name|item
operator|->
name|parentItem
argument_list|()
operator|<<
literal|", pos ="
operator|<<
name|item
operator|->
name|pos
argument_list|()
operator|<<
literal|", z ="
operator|<<
name|item
operator|->
name|zValue
argument_list|()
operator|<<
literal|", flags = "
operator|<<
name|item
operator|->
name|flags
argument_list|()
operator|<<
literal|")"
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QGraphicsObject
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|debug
operator|<<
literal|"QGraphicsObject(0)"
expr_stmt|;
return|return
name|debug
return|;
block|}
name|debug
operator|.
name|nospace
argument_list|()
operator|<<
name|item
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
operator|<<
literal|'('
operator|<<
operator|(
name|void
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|debug
operator|<<
literal|", name = "
operator|<<
name|item
operator|->
name|objectName
argument_list|()
expr_stmt|;
name|debug
operator|.
name|nospace
argument_list|()
operator|<<
literal|", parent = "
operator|<<
operator|(
operator|(
name|void
operator|*
operator|)
name|item
operator|->
name|parentItem
argument_list|()
operator|)
operator|<<
literal|", pos = "
operator|<<
name|item
operator|->
name|pos
argument_list|()
operator|<<
literal|", z = "
operator|<<
name|item
operator|->
name|zValue
argument_list|()
operator|<<
literal|", flags = "
operator|<<
name|item
operator|->
name|flags
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemChange
name|change
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"UnknownChange"
decl_stmt|;
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|QGraphicsItem
operator|::
name|ItemChildAddedChange
case|:
name|str
operator|=
literal|"ItemChildAddedChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemChildRemovedChange
case|:
name|str
operator|=
literal|"ItemChildRemovedChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemCursorChange
case|:
name|str
operator|=
literal|"ItemCursorChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemCursorHasChanged
case|:
name|str
operator|=
literal|"ItemCursorHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemEnabledChange
case|:
name|str
operator|=
literal|"ItemEnabledChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemEnabledHasChanged
case|:
name|str
operator|=
literal|"ItemEnabledHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemFlagsChange
case|:
name|str
operator|=
literal|"ItemFlagsChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemFlagsHaveChanged
case|:
name|str
operator|=
literal|"ItemFlagsHaveChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemMatrixChange
case|:
name|str
operator|=
literal|"ItemMatrixChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemParentChange
case|:
name|str
operator|=
literal|"ItemParentChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemParentHasChanged
case|:
name|str
operator|=
literal|"ItemParentHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemPositionChange
case|:
name|str
operator|=
literal|"ItemPositionChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemPositionHasChanged
case|:
name|str
operator|=
literal|"ItemPositionHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSceneChange
case|:
name|str
operator|=
literal|"ItemSceneChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSceneHasChanged
case|:
name|str
operator|=
literal|"ItemSceneHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSelectedChange
case|:
name|str
operator|=
literal|"ItemSelectedChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSelectedHasChanged
case|:
name|str
operator|=
literal|"ItemSelectedHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemToolTipChange
case|:
name|str
operator|=
literal|"ItemToolTipChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemToolTipHasChanged
case|:
name|str
operator|=
literal|"ItemToolTipHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemTransformChange
case|:
name|str
operator|=
literal|"ItemTransformChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemTransformHasChanged
case|:
name|str
operator|=
literal|"ItemTransformHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemVisibleChange
case|:
name|str
operator|=
literal|"ItemVisibleChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemVisibleHasChanged
case|:
name|str
operator|=
literal|"ItemVisibleHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemZValueChange
case|:
name|str
operator|=
literal|"ItemZValueChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemZValueHasChanged
case|:
name|str
operator|=
literal|"ItemZValueHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemOpacityChange
case|:
name|str
operator|=
literal|"ItemOpacityChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemOpacityHasChanged
case|:
name|str
operator|=
literal|"ItemOpacityHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemScenePositionHasChanged
case|:
name|str
operator|=
literal|"ItemScenePositionHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemRotationChange
case|:
name|str
operator|=
literal|"ItemRotationChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemRotationHasChanged
case|:
name|str
operator|=
literal|"ItemRotationHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemScaleChange
case|:
name|str
operator|=
literal|"ItemScaleChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemScaleHasChanged
case|:
name|str
operator|=
literal|"ItemScaleHasChanged"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemTransformOriginPointChange
case|:
name|str
operator|=
literal|"ItemTransformOriginPointChange"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemTransformOriginPointHasChanged
case|:
name|str
operator|=
literal|"ItemTransformOriginPointHasChanged"
expr_stmt|;
break|break;
block|}
name|debug
operator|<<
name|str
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
name|flag
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"UnknownFlag"
decl_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|QGraphicsItem
operator|::
name|ItemIsMovable
case|:
name|str
operator|=
literal|"ItemIsMovable"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIsSelectable
case|:
name|str
operator|=
literal|"ItemIsSelectable"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIsFocusable
case|:
name|str
operator|=
literal|"ItemIsFocusable"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemClipsToShape
case|:
name|str
operator|=
literal|"ItemClipsToShape"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemClipsChildrenToShape
case|:
name|str
operator|=
literal|"ItemClipsChildrenToShape"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIgnoresTransformations
case|:
name|str
operator|=
literal|"ItemIgnoresTransformations"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIgnoresParentOpacity
case|:
name|str
operator|=
literal|"ItemIgnoresParentOpacity"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemDoesntPropagateOpacityToChildren
case|:
name|str
operator|=
literal|"ItemDoesntPropagateOpacityToChildren"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemStacksBehindParent
case|:
name|str
operator|=
literal|"ItemStacksBehindParent"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemUsesExtendedStyleOption
case|:
name|str
operator|=
literal|"ItemUsesExtendedStyleOption"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemHasNoContents
case|:
name|str
operator|=
literal|"ItemHasNoContents"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSendsGeometryChanges
case|:
name|str
operator|=
literal|"ItemSendsGeometryChanges"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemAcceptsInputMethod
case|:
name|str
operator|=
literal|"ItemAcceptsInputMethod"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemNegativeZStacksBehindParent
case|:
name|str
operator|=
literal|"ItemNegativeZStacksBehindParent"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIsPanel
case|:
name|str
operator|=
literal|"ItemIsPanel"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemIsFocusScope
case|:
name|str
operator|=
literal|"ItemIsFocusScope"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemSendsScenePositionChanges
case|:
name|str
operator|=
literal|"ItemSendsScenePositionChanges"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemStopsClickFocusPropagation
case|:
name|str
operator|=
literal|"ItemStopsClickFocusPropagation"
expr_stmt|;
break|break;
case|case
name|QGraphicsItem
operator|::
name|ItemStopsFocusHandling
case|:
name|str
operator|=
literal|"ItemStopsFocusHandling"
expr_stmt|;
break|break;
block|}
name|debug
operator|<<
name|str
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QGraphicsItem
operator|::
name|GraphicsItemFlags
name|flags
parameter_list|)
block|{
name|debug
operator|<<
literal|'('
expr_stmt|;
name|bool
name|f
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|f
condition|)
name|debug
operator|<<
literal|'|'
expr_stmt|;
name|f
operator|=
literal|true
expr_stmt|;
name|debug
operator|<<
name|QGraphicsItem
operator|::
name|GraphicsItemFlag
argument_list|(
name|int
argument_list|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qgraphicsitem.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GRAPHICSVIEW
end_comment
end_unit
