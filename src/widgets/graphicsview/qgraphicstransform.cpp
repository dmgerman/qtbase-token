begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtDeclarative module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QGraphicsTransform     \brief The QGraphicsTransform class is an abstract base class for building     advanced transformations on QGraphicsItems.     \since 4.6     \ingroup graphicsview-api     \inmodule QtWidgets      As an alternative to QGraphicsItem::transform, QGraphicsTransform lets you     create and control advanced transformations that can be configured     independently using specialized properties.      QGraphicsItem allows you to assign any number of QGraphicsTransform     instances to one QGraphicsItem. Each QGraphicsTransform is applied in     order, one at a time, to the QGraphicsItem it's assigned to.      QGraphicsTransform is particularly useful for animations. Whereas     QGraphicsItem::setTransform() lets you assign any transform directly to an     item, there is no direct way to interpolate between two different     transformations (e.g., when transitioning between two states, each for     which the item has a different arbitrary transform assigned). Using     QGraphicsTransform you can interpolate the property values of each     independent transformation. The resulting operation is then combined into a     single transform which is applied to QGraphicsItem.      Transformations are computed in true 3D space using QMatrix4x4.     When the transformation is applied to a QGraphicsItem, it will be     projected back to a 2D QTransform.  When multiple QGraphicsTransform     objects are applied to a QGraphicsItem, all of the transformations     are computed in true 3D space, with the projection back to 2D     only occurring after the last QGraphicsTransform is applied.     The exception to this is QGraphicsRotation, which projects back to     2D after each rotation to preserve the perspective effect around     the X and Y axes.      If you want to create your own configurable transformation, you can create     a subclass of QGraphicsTransform (or any or the existing subclasses), and     reimplement the pure virtual applyTo() function, which takes a pointer to a     QMatrix4x4. Each operation you would like to apply should be exposed as     properties (e.g., customTransform->setVerticalShear(2.5)). Inside you     reimplementation of applyTo(), you can modify the provided transform     respectively.      QGraphicsTransform can be used together with QGraphicsItem::setTransform(),     QGraphicsItem::setRotation(), and QGraphicsItem::setScale().      \sa QGraphicsItem::transform(), QGraphicsScale, QGraphicsRotation */
end_comment
begin_include
include|#
directive|include
file|"qgraphicstransform.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicsitem_p.h"
end_include
begin_include
include|#
directive|include
file|"qgraphicstransform_p.h"
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qnumeric.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GRAPHICSVIEW
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|setItem
name|void
name|QGraphicsTransformPrivate
operator|::
name|setItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|i
parameter_list|)
block|{
if|if
condition|(
name|item
operator|==
name|i
condition|)
return|return;
if|if
condition|(
name|item
condition|)
block|{
name|Q_Q
argument_list|(
name|QGraphicsTransform
argument_list|)
expr_stmt|;
name|QGraphicsItemPrivate
modifier|*
name|d_ptr
init|=
name|item
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
decl_stmt|;
name|item
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d_ptr
operator|->
name|transformData
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|transformData
operator|->
name|graphicsTransforms
operator|.
name|removeAll
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
name|item
operator|=
literal|0
expr_stmt|;
block|}
name|item
operator|=
name|i
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateItem
name|void
name|QGraphicsTransformPrivate
operator|::
name|updateItem
parameter_list|(
name|QGraphicsItem
modifier|*
name|item
parameter_list|)
block|{
name|item
operator|->
name|prepareGeometryChange
argument_list|()
expr_stmt|;
name|item
operator|->
name|d_ptr
operator|->
name|dirtySceneTransform
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a new QGraphicsTransform with the given \a parent. */
end_comment
begin_constructor
DECL|function|QGraphicsTransform
name|QGraphicsTransform
operator|::
name|QGraphicsTransform
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QGraphicsTransformPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the graphics transform. */
end_comment
begin_destructor
DECL|function|~QGraphicsTransform
name|QGraphicsTransform
operator|::
name|~
name|QGraphicsTransform
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsTransform
argument_list|)
expr_stmt|;
name|d
operator|->
name|setItem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QGraphicsTransform
name|QGraphicsTransform
operator|::
name|QGraphicsTransform
parameter_list|(
name|QGraphicsTransformPrivate
modifier|&
name|p
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \fn void QGraphicsTransform::applyTo(QMatrix4x4 *matrix) const      This pure virtual method has to be reimplemented in derived classes.      It applies this transformation to \a matrix.      \sa QGraphicsItem::transform(), QMatrix4x4::toTransform() */
end_comment
begin_comment
comment|/*!     Notifies that this transform operation has changed its parameters in such a     way that applyTo() will return a different result than before.      When implementing you own custom graphics transform, you must call this     function every time you change a parameter, to let QGraphicsItem know that     its transformation needs to be updated.      \sa applyTo() */
end_comment
begin_function
DECL|function|update
name|void
name|QGraphicsTransform
operator|::
name|update
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QGraphicsTransform
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|item
condition|)
name|d
operator|->
name|updateItem
argument_list|(
name|d
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class QGraphicsScale   \brief The QGraphicsScale class provides a scale transformation.   \since 4.6   \inmodule QtWidgets    QGraphicsScene provides certain parameters to help control how the scale   should be applied.    The origin is the point that the item is scaled from (i.e., it stays fixed   relative to the parent as the rest of the item grows). By default the   origin is QPointF(0, 0).    The parameters xScale, yScale, and zScale describe the scale factors to   apply in horizontal, vertical, and depth directions. They can take on any   value, including 0 (to collapse the item to a point) or negative value.   A negative xScale value will mirror the item horizontally. A negative yScale   value will flip the item vertically. A negative zScale will flip the   item end for end.    \sa QGraphicsTransform, QGraphicsItem::setScale(), QTransform::scale() */
end_comment
begin_class
DECL|class|QGraphicsScalePrivate
class|class
name|QGraphicsScalePrivate
super|:
specifier|public
name|QGraphicsTransformPrivate
block|{
public|public:
DECL|function|QGraphicsScalePrivate
name|QGraphicsScalePrivate
parameter_list|()
member_init_list|:
name|xScale
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|yScale
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|zScale
argument_list|(
literal|1
argument_list|)
block|{}
DECL|member|origin
name|QVector3D
name|origin
decl_stmt|;
DECL|member|xScale
name|qreal
name|xScale
decl_stmt|;
DECL|member|yScale
name|qreal
name|yScale
decl_stmt|;
DECL|member|zScale
name|qreal
name|zScale
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs an empty QGraphicsScale object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QGraphicsScale
name|QGraphicsScale
operator|::
name|QGraphicsScale
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QGraphicsTransform
argument_list|(
operator|*
operator|new
name|QGraphicsScalePrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the graphics scale. */
end_comment
begin_destructor
DECL|function|~QGraphicsScale
name|QGraphicsScale
operator|::
name|~
name|QGraphicsScale
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \property QGraphicsScale::origin     \brief the origin of the scale in 3D space.      All scaling will be done relative to this point (i.e., this point     will stay fixed, relative to the parent, when the item is scaled).      \sa xScale, yScale, zScale */
end_comment
begin_function
DECL|function|origin
name|QVector3D
name|QGraphicsScale
operator|::
name|origin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScale
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|origin
return|;
block|}
end_function
begin_function
DECL|function|setOrigin
name|void
name|QGraphicsScale
operator|::
name|setOrigin
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|origin
operator|==
name|point
condition|)
return|return;
name|d
operator|->
name|origin
operator|=
name|point
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|originChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScale::xScale     \brief the horizontal scale factor.      The scale factor can be any real number; the default value is 1.0. If you     set the factor to 0.0, the item will be collapsed to a single point. If you     provide a negative value, the item will be mirrored horizontally around its     origin.      \sa yScale, zScale, origin */
end_comment
begin_function
DECL|function|xScale
name|qreal
name|QGraphicsScale
operator|::
name|xScale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScale
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|xScale
return|;
block|}
end_function
begin_function
DECL|function|setXScale
name|void
name|QGraphicsScale
operator|::
name|setXScale
parameter_list|(
name|qreal
name|scale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|xScale
operator|==
name|scale
condition|)
return|return;
name|d
operator|->
name|xScale
operator|=
name|scale
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|xScaleChanged
argument_list|()
emit|;
emit|emit
name|scaleChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScale::yScale     \brief the vertical scale factor.      The scale factor can be any real number; the default value is 1.0. If you     set the factor to 0.0, the item will be collapsed to a single point. If you     provide a negative value, the item will be flipped vertically around its     origin.      \sa xScale, zScale, origin */
end_comment
begin_function
DECL|function|yScale
name|qreal
name|QGraphicsScale
operator|::
name|yScale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScale
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|yScale
return|;
block|}
end_function
begin_function
DECL|function|setYScale
name|void
name|QGraphicsScale
operator|::
name|setYScale
parameter_list|(
name|qreal
name|scale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|yScale
operator|==
name|scale
condition|)
return|return;
name|d
operator|->
name|yScale
operator|=
name|scale
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|yScaleChanged
argument_list|()
emit|;
emit|emit
name|scaleChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsScale::zScale     \brief the depth scale factor.      The scale factor can be any real number; the default value is 1.0. If you     set the factor to 0.0, the item will be collapsed to a single point. If you     provide a negative value, the item will be flipped end for end around its     origin.      \sa xScale, yScale, origin */
end_comment
begin_function
DECL|function|zScale
name|qreal
name|QGraphicsScale
operator|::
name|zScale
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScale
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|zScale
return|;
block|}
end_function
begin_function
DECL|function|setZScale
name|void
name|QGraphicsScale
operator|::
name|setZScale
parameter_list|(
name|qreal
name|scale
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|zScale
operator|==
name|scale
condition|)
return|return;
name|d
operator|->
name|zScale
operator|=
name|scale
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|zScaleChanged
argument_list|()
emit|;
emit|emit
name|scaleChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|applyTo
name|void
name|QGraphicsScale
operator|::
name|applyTo
parameter_list|(
name|QMatrix4x4
modifier|*
name|matrix
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsScale
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|translate
argument_list|(
name|d
operator|->
name|origin
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|scale
argument_list|(
name|d
operator|->
name|xScale
argument_list|,
name|d
operator|->
name|yScale
argument_list|,
name|d
operator|->
name|zScale
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|translate
argument_list|(
operator|-
name|d
operator|->
name|origin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsScale::originChanged()      QGraphicsScale emits this signal when its origin changes.      \sa QGraphicsScale::origin */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScale::xScaleChanged()     \since 4.7      This signal is emitted whenever the \l xScale property changes. */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScale::yScaleChanged()     \since 4.7      This signal is emitted whenever the \l yScale property changes. */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScale::zScaleChanged()     \since 4.7      This signal is emitted whenever the \l zScale property changes. */
end_comment
begin_comment
comment|/*!     \fn QGraphicsScale::scaleChanged()      This signal is emitted whenever the xScale, yScale, or zScale     of the object changes.      \sa QGraphicsScale::xScale, QGraphicsScale::yScale     \sa QGraphicsScale::zScale */
end_comment
begin_comment
comment|/*!     \class QGraphicsRotation     \brief The QGraphicsRotation class provides a rotation transformation around     a given axis.     \since 4.6     \inmodule QtWidgets      You can provide the desired axis by assigning a QVector3D to the axis property     or by passing a member if Qt::Axis to the setAxis convenience function.     By default the axis is (0, 0, 1) i.e., rotation around the Z axis.      The angle property, which is provided by QGraphicsRotation, now     describes the number of degrees to rotate around this axis.      QGraphicsRotation provides certain parameters to help control how the     rotation should be applied.      The origin is the point that the item is rotated around (i.e., it stays     fixed relative to the parent as the rest of the item is rotated). By     default the origin is QPointF(0, 0).      The angle property provides the number of degrees to rotate the item     clockwise around the origin. This value also be negative, indicating a     counter-clockwise rotation. For animation purposes it may also be useful to     provide rotation angles exceeding (-360, 360) degrees, for instance to     animate how an item rotates several times.      Note: the final rotation is the combined effect of a rotation in     3D space followed by a projection back to 2D.  If several rotations     are performed in succession, they will not behave as expected unless     they were all around the Z axis.      \sa QGraphicsTransform, QGraphicsItem::setRotation(), QTransform::rotate() */
end_comment
begin_class
DECL|class|QGraphicsRotationPrivate
class|class
name|QGraphicsRotationPrivate
super|:
specifier|public
name|QGraphicsTransformPrivate
block|{
public|public:
DECL|function|QGraphicsRotationPrivate
name|QGraphicsRotationPrivate
parameter_list|()
member_init_list|:
name|angle
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|axis
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|{}
DECL|member|origin
name|QVector3D
name|origin
decl_stmt|;
DECL|member|angle
name|qreal
name|angle
decl_stmt|;
DECL|member|axis
name|QVector3D
name|axis
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a new QGraphicsRotation with the given \a parent. */
end_comment
begin_constructor
DECL|function|QGraphicsRotation
name|QGraphicsRotation
operator|::
name|QGraphicsRotation
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QGraphicsTransform
argument_list|(
operator|*
operator|new
name|QGraphicsRotationPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the graphics rotation. */
end_comment
begin_destructor
DECL|function|~QGraphicsRotation
name|QGraphicsRotation
operator|::
name|~
name|QGraphicsRotation
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \property QGraphicsRotation::origin     \brief the origin of the rotation in 3D space.      All rotations will be done relative to this point (i.e., this point     will stay fixed, relative to the parent, when the item is rotated).      \sa angle */
end_comment
begin_function
DECL|function|origin
name|QVector3D
name|QGraphicsRotation
operator|::
name|origin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRotation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|origin
return|;
block|}
end_function
begin_function
DECL|function|setOrigin
name|void
name|QGraphicsRotation
operator|::
name|setOrigin
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|point
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsRotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|origin
operator|==
name|point
condition|)
return|return;
name|d
operator|->
name|origin
operator|=
name|point
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|originChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \property QGraphicsRotation::angle     \brief the angle for clockwise rotation, in degrees.      The angle can be any real number; the default value is 0.0. A value of 180     will rotate 180 degrees, clockwise. If you provide a negative number, the     item will be rotated counter-clockwise. Normally the rotation angle will be     in the range (-360, 360), but you can also provide numbers outside of this     range (e.g., a angle of 370 degrees gives the same result as 10 degrees).     Setting the angle to NaN results in no rotation.      \sa origin */
end_comment
begin_function
DECL|function|angle
name|qreal
name|QGraphicsRotation
operator|::
name|angle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRotation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|angle
return|;
block|}
end_function
begin_function
DECL|function|setAngle
name|void
name|QGraphicsRotation
operator|::
name|setAngle
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsRotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|angle
operator|==
name|angle
condition|)
return|return;
name|d
operator|->
name|angle
operator|=
name|angle
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|angleChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \fn QGraphicsRotation::originChanged()      This signal is emitted whenever the origin has changed.      \sa QGraphicsRotation::origin */
end_comment
begin_comment
comment|/*!     \fn void QGraphicsRotation::angleChanged()      This signal is emitted whenever the angle has changed.      \sa QGraphicsRotation::angle */
end_comment
begin_comment
comment|/*!     \property QGraphicsRotation::axis     \brief a rotation axis, specified by a vector in 3D space.      This can be any axis in 3D space. By default the axis is (0, 0, 1),     which is aligned with the Z axis. If you provide another axis,     QGraphicsRotation will provide a transformation that rotates     around this axis. For example, if you would like to rotate an item     around its X axis, you could pass (1, 0, 0) as the axis.      \sa QTransform, QGraphicsRotation::angle */
end_comment
begin_function
DECL|function|axis
name|QVector3D
name|QGraphicsRotation
operator|::
name|axis
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRotation
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|axis
return|;
block|}
end_function
begin_function
DECL|function|setAxis
name|void
name|QGraphicsRotation
operator|::
name|setAxis
parameter_list|(
specifier|const
name|QVector3D
modifier|&
name|axis
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QGraphicsRotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|axis
operator|==
name|axis
condition|)
return|return;
name|d
operator|->
name|axis
operator|=
name|axis
expr_stmt|;
name|update
argument_list|()
expr_stmt|;
emit|emit
name|axisChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsRotation::setAxis(Qt::Axis axis)      Convenience function to set the axis to \a axis.      Note: the Qt::YAxis rotation for QTransform is inverted from the     correct mathematical rotation in 3D space.  The QGraphicsRotation     class implements a correct mathematical rotation.  The following     two sequences of code will perform the same transformation:      \code     QTransform t;     t.rotate(45, Qt::YAxis);      QGraphicsRotation r;     r.setAxis(Qt::YAxis);     r.setAngle(-45);     \endcode */
end_comment
begin_function
DECL|function|setAxis
name|void
name|QGraphicsRotation
operator|::
name|setAxis
parameter_list|(
name|Qt
operator|::
name|Axis
name|axis
parameter_list|)
block|{
switch|switch
condition|(
name|axis
condition|)
block|{
case|case
name|Qt
operator|::
name|XAxis
case|:
name|setAxis
argument_list|(
name|QVector3D
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|YAxis
case|:
name|setAxis
argument_list|(
name|QVector3D
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|ZAxis
case|:
name|setAxis
argument_list|(
name|QVector3D
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|applyTo
name|void
name|QGraphicsRotation
operator|::
name|applyTo
parameter_list|(
name|QMatrix4x4
modifier|*
name|matrix
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QGraphicsRotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|angle
operator|==
literal|0.
operator|||
name|d
operator|->
name|axis
operator|.
name|isNull
argument_list|()
operator|||
name|qIsNaN
argument_list|(
name|d
operator|->
name|angle
argument_list|)
condition|)
return|return;
name|matrix
operator|->
name|translate
argument_list|(
name|d
operator|->
name|origin
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|projectedRotate
argument_list|(
name|d
operator|->
name|angle
argument_list|,
name|d
operator|->
name|axis
operator|.
name|x
argument_list|()
argument_list|,
name|d
operator|->
name|axis
operator|.
name|y
argument_list|()
argument_list|,
name|d
operator|->
name|axis
operator|.
name|z
argument_list|()
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|translate
argument_list|(
operator|-
name|d
operator|->
name|origin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QGraphicsRotation::axisChanged()      This signal is emitted whenever the axis of the object changes.      \sa QGraphicsRotation::axis */
end_comment
begin_include
include|#
directive|include
file|"moc_qgraphicstransform.cpp"
end_include
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_GRAPHICSVIEW
end_comment
end_unit
