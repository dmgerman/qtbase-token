begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindowsxpstyle.h"
end_include
begin_include
include|#
directive|include
file|"qwindowsxpstyle_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_STYLE_WINDOWSXP
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_PLUGIN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<qplatformnativeinterface_qpa.h>
end_include
begin_include
include|#
directive|include
file|<private/qstylehelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qsystemlibrary_p.h>
end_include
begin_include
include|#
directive|include
file|<qpainter.h>
end_include
begin_include
include|#
directive|include
file|<qpaintengine.h>
end_include
begin_include
include|#
directive|include
file|<qwidget.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qpixmapcache.h>
end_include
begin_include
include|#
directive|include
file|<qdesktopwidget.h>
end_include
begin_include
include|#
directive|include
file|<qtoolbutton.h>
end_include
begin_include
include|#
directive|include
file|<qtabbar.h>
end_include
begin_include
include|#
directive|include
file|<qcombobox.h>
end_include
begin_include
include|#
directive|include
file|<qscrollbar.h>
end_include
begin_include
include|#
directive|include
file|<qheaderview.h>
end_include
begin_include
include|#
directive|include
file|<qspinbox.h>
end_include
begin_include
include|#
directive|include
file|<qlistview.h>
end_include
begin_include
include|#
directive|include
file|<qstackedwidget.h>
end_include
begin_include
include|#
directive|include
file|<qpushbutton.h>
end_include
begin_include
include|#
directive|include
file|<qtoolbar.h>
end_include
begin_include
include|#
directive|include
file|<qlabel.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// Runtime resolved theme engine function calls
end_comment
begin_typedef
DECL|typedef|PtrIsAppThemed
typedef|typedef
name|bool
function_decl|(
name|WINAPI
modifier|*
name|PtrIsAppThemed
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrIsThemeActive
typedef|typedef
name|bool
function_decl|(
name|WINAPI
modifier|*
name|PtrIsThemeActive
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemePartSize
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemePartSize
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|OPTIONAL
name|RECT
modifier|*
name|prc
parameter_list|,
name|enum
name|THEMESIZE
name|eSize
parameter_list|,
name|OUT
name|SIZE
modifier|*
name|psz
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrOpenThemeData
typedef|typedef
name|HTHEME
function_decl|(
name|WINAPI
modifier|*
name|PtrOpenThemeData
function_decl|)
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|LPCWSTR
name|pszClassList
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrCloseThemeData
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrCloseThemeData
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrDrawThemeBackground
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrDrawThemeBackground
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
specifier|const
name|RECT
modifier|*
name|pRect
parameter_list|,
name|OPTIONAL
specifier|const
name|RECT
modifier|*
name|pClipRect
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrDrawThemeBackgroundEx
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrDrawThemeBackgroundEx
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
specifier|const
name|RECT
modifier|*
name|pRect
parameter_list|,
name|OPTIONAL
specifier|const
name|DTBGOPTS
modifier|*
name|pOptions
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetCurrentThemeName
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetCurrentThemeName
function_decl|)
parameter_list|(
name|OUT
name|LPWSTR
name|pszThemeFileName
parameter_list|,
name|int
name|cchMaxNameChars
parameter_list|,
name|OUT
name|OPTIONAL
name|LPWSTR
name|pszColorBuff
parameter_list|,
name|int
name|cchMaxColorChars
parameter_list|,
name|OUT
name|OPTIONAL
name|LPWSTR
name|pszSizeBuff
parameter_list|,
name|int
name|cchMaxSizeChars
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeDocumentationProperty
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeDocumentationProperty
function_decl|)
parameter_list|(
name|LPCWSTR
name|pszThemeName
parameter_list|,
name|LPCWSTR
name|pszPropertyName
parameter_list|,
name|OUT
name|LPWSTR
name|pszValueBuff
parameter_list|,
name|int
name|cchMaxValChars
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeBool
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeBool
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|BOOL
modifier|*
name|pfVal
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeColor
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeColor
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|COLORREF
modifier|*
name|pColor
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeEnumValue
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeEnumValue
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|int
modifier|*
name|piVal
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeFilename
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeFilename
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|LPWSTR
name|pszThemeFileName
parameter_list|,
name|int
name|cchMaxBuffChars
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeFont
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeFont
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|OPTIONAL
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|LOGFONT
modifier|*
name|pFont
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeInt
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeInt
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|int
modifier|*
name|piVal
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeIntList
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeIntList
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|INTLIST
modifier|*
name|pIntList
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeMargins
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeMargins
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|OPTIONAL
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OPTIONAL
name|RECT
modifier|*
name|prc
parameter_list|,
name|OUT
name|MARGINS
modifier|*
name|pMargins
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeMetric
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeMetric
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|OPTIONAL
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|int
modifier|*
name|piVal
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemePartSize
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemePartSize
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|OPTIONAL
name|RECT
modifier|*
name|prc
parameter_list|,
name|enum
name|THEMESIZE
name|eSize
parameter_list|,
name|OUT
name|SIZE
modifier|*
name|psz
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemePosition
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemePosition
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|POINT
modifier|*
name|pPoint
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemePropertyOrigin
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemePropertyOrigin
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|enum
name|PROPERTYORIGIN
modifier|*
name|pOrigin
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeRect
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeRect
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|RECT
modifier|*
name|pRect
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeString
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeString
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
name|int
name|iPropId
parameter_list|,
name|OUT
name|LPWSTR
name|pszBuff
parameter_list|,
name|int
name|cchMaxBuffChars
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrGetThemeBackgroundRegion
typedef|typedef
name|HRESULT
function_decl|(
name|WINAPI
modifier|*
name|PtrGetThemeBackgroundRegion
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|OPTIONAL
name|HDC
name|hdc
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|,
specifier|const
name|RECT
modifier|*
name|pRect
parameter_list|,
name|OUT
name|HRGN
modifier|*
name|pRegion
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|PtrIsThemeBackgroundPartiallyTransparent
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|PtrIsThemeBackgroundPartiallyTransparent
function_decl|)
parameter_list|(
name|HTHEME
name|hTheme
parameter_list|,
name|int
name|iPartId
parameter_list|,
name|int
name|iStateId
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|pIsAppThemed
specifier|static
name|PtrIsAppThemed
name|pIsAppThemed
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pIsThemeActive
specifier|static
name|PtrIsThemeActive
name|pIsThemeActive
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pOpenThemeData
specifier|static
name|PtrOpenThemeData
name|pOpenThemeData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pCloseThemeData
specifier|static
name|PtrCloseThemeData
name|pCloseThemeData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pDrawThemeBackground
specifier|static
name|PtrDrawThemeBackground
name|pDrawThemeBackground
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pDrawThemeBackgroundEx
specifier|static
name|PtrDrawThemeBackgroundEx
name|pDrawThemeBackgroundEx
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetCurrentThemeName
specifier|static
name|PtrGetCurrentThemeName
name|pGetCurrentThemeName
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeBool
specifier|static
name|PtrGetThemeBool
name|pGetThemeBool
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeColor
specifier|static
name|PtrGetThemeColor
name|pGetThemeColor
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeEnumValue
specifier|static
name|PtrGetThemeEnumValue
name|pGetThemeEnumValue
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeFilename
specifier|static
name|PtrGetThemeFilename
name|pGetThemeFilename
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeFont
specifier|static
name|PtrGetThemeFont
name|pGetThemeFont
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeInt
specifier|static
name|PtrGetThemeInt
name|pGetThemeInt
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeIntList
specifier|static
name|PtrGetThemeIntList
name|pGetThemeIntList
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeMargins
specifier|static
name|PtrGetThemeMargins
name|pGetThemeMargins
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeMetric
specifier|static
name|PtrGetThemeMetric
name|pGetThemeMetric
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemePartSize
specifier|static
name|PtrGetThemePartSize
name|pGetThemePartSize
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemePosition
specifier|static
name|PtrGetThemePosition
name|pGetThemePosition
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemePropertyOrigin
specifier|static
name|PtrGetThemePropertyOrigin
name|pGetThemePropertyOrigin
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeRect
specifier|static
name|PtrGetThemeRect
name|pGetThemeRect
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeString
specifier|static
name|PtrGetThemeString
name|pGetThemeString
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeBackgroundRegion
specifier|static
name|PtrGetThemeBackgroundRegion
name|pGetThemeBackgroundRegion
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pGetThemeDocumentationProperty
specifier|static
name|PtrGetThemeDocumentationProperty
name|pGetThemeDocumentationProperty
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pIsThemeBackgroundPartiallyTransparent
specifier|static
name|PtrIsThemeBackgroundPartiallyTransparent
name|pIsThemeBackgroundPartiallyTransparent
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|// General const values
end_comment
begin_decl_stmt
DECL|variable|windowsItemFrame
specifier|static
specifier|const
name|int
name|windowsItemFrame
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|windowsItemFrame
comment|// menu item frame width
end_comment
begin_decl_stmt
DECL|variable|windowsItemHMargin
specifier|static
specifier|const
name|int
name|windowsItemHMargin
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|windowsItemHMargin
comment|// menu item hor text margin
end_comment
begin_decl_stmt
DECL|variable|windowsItemVMargin
specifier|static
specifier|const
name|int
name|windowsItemVMargin
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|windowsItemVMargin
comment|// menu item ver text margin
end_comment
begin_decl_stmt
DECL|variable|windowsArrowHMargin
specifier|static
specifier|const
name|int
name|windowsArrowHMargin
init|=
literal|6
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|windowsArrowHMargin
comment|// arrow horizontal margin
end_comment
begin_decl_stmt
DECL|variable|windowsRightBorder
specifier|static
specifier|const
name|int
name|windowsRightBorder
init|=
literal|12
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|windowsRightBorder
comment|// right border on windows
end_comment
begin_comment
comment|// External function calls
end_comment
begin_function_decl
specifier|extern
name|Q_WIDGETS_EXPORT
name|HDC
name|qt_win_display_dc
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|QRegion
name|qt_region_from_HRGN
parameter_list|(
name|HRGN
name|rgn
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Theme names matching the QWindowsXPStylePrivate::Theme enumeration.
end_comment
begin_decl_stmt
DECL|variable|themeNames
specifier|static
specifier|const
name|wchar_t
modifier|*
name|themeNames
index|[
name|QWindowsXPStylePrivate
operator|::
name|NThemes
index|]
init|=
block|{
literal|L"BUTTON"
block|,
literal|L"COMBOBOX"
block|,
literal|L"EDIT"
block|,
literal|L"HEADER"
block|,
literal|L"LISTVIEW"
block|,
literal|L"MENU"
block|,
literal|L"PROGRESS"
block|,
literal|L"REBAR"
block|,
literal|L"SCROLLBAR"
block|,
literal|L"SPIN"
block|,
literal|L"TAB"
block|,
literal|L"TASKDIALOG"
block|,
literal|L"TOOLBAR"
block|,
literal|L"TOOLTIP"
block|,
literal|L"TRACKBAR"
block|,
literal|L"TREEVIEW"
block|,
literal|L"WINDOW"
block|,
literal|L"STATUS"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|backingStoreForWidget
specifier|static
specifier|inline
name|QBackingStore
modifier|*
name|backingStoreForWidget
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|QBackingStore
modifier|*
name|backingStore
init|=
name|widget
operator|->
name|backingStore
argument_list|()
condition|)
return|return
name|backingStore
return|;
if|if
condition|(
specifier|const
name|QWidget
modifier|*
name|topLevel
init|=
name|widget
operator|->
name|nativeParentWidget
argument_list|()
condition|)
if|if
condition|(
name|QBackingStore
modifier|*
name|topLevelBackingStore
init|=
name|topLevel
operator|->
name|backingStore
argument_list|()
condition|)
return|return
name|topLevelBackingStore
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|hdcForWidgetBackingStore
specifier|static
specifier|inline
name|HDC
name|hdcForWidgetBackingStore
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|QBackingStore
modifier|*
name|backingStore
init|=
name|backingStoreForWidget
argument_list|(
name|widget
argument_list|)
condition|)
block|{
name|QPlatformNativeInterface
modifier|*
name|nativeInterface
init|=
name|QGuiApplication
operator|::
name|platformNativeInterface
argument_list|()
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|HDC
argument_list|>
argument_list|(
name|nativeInterface
operator|->
name|nativeResourceForBackingStore
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"getDC"
argument_list|)
argument_list|,
name|backingStore
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Theme data helper ------------------------------------------------------------------------------
end_comment
begin_comment
comment|/* \internal     Returns true if the themedata is valid for use. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|XPThemeData
operator|::
name|isValid
parameter_list|()
block|{
return|return
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
operator|&&
name|theme
operator|>=
literal|0
operator|&&
name|handle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/* \internal     Returns the theme engine handle to the specific class.     If the handle hasn't been opened before, it opens the data, and     adds it to a static map, for caching. */
end_comment
begin_function
DECL|function|handle
name|HTHEME
name|XPThemeData
operator|::
name|handle
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|htheme
condition|)
name|htheme
operator|=
name|QWindowsXPStylePrivate
operator|::
name|createTheme
argument_list|(
name|theme
argument_list|,
name|QWindowsXPStylePrivate
operator|::
name|winId
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|htheme
return|;
block|}
end_function
begin_comment
comment|/* \internal     Converts a QRect to the native RECT structure. */
end_comment
begin_function
DECL|function|toRECT
name|RECT
name|XPThemeData
operator|::
name|toRECT
parameter_list|(
specifier|const
name|QRect
modifier|&
name|qr
parameter_list|)
block|{
name|RECT
name|r
decl_stmt|;
name|r
operator|.
name|left
operator|=
name|qr
operator|.
name|x
argument_list|()
expr_stmt|;
name|r
operator|.
name|right
operator|=
name|qr
operator|.
name|x
argument_list|()
operator|+
name|qr
operator|.
name|width
argument_list|()
expr_stmt|;
name|r
operator|.
name|top
operator|=
name|qr
operator|.
name|y
argument_list|()
expr_stmt|;
name|r
operator|.
name|bottom
operator|=
name|qr
operator|.
name|y
argument_list|()
operator|+
name|qr
operator|.
name|height
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/* \internal     Returns the native region of a part, if the part is considered     transparent. The region is scaled to the parts size (rect). */
end_comment
begin_function
DECL|function|mask
name|HRGN
name|XPThemeData
operator|::
name|mask
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pIsThemeBackgroundPartiallyTransparent
argument_list|(
name|handle
argument_list|()
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|)
condition|)
return|return
literal|0
return|;
name|HRGN
name|hrgn
decl_stmt|;
name|HDC
name|dc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|widget
condition|)
name|dc
operator|=
name|hdcForWidgetBackingStore
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|RECT
name|nativeRect
init|=
name|toRECT
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|pGetThemeBackgroundRegion
argument_list|(
name|handle
argument_list|()
argument_list|,
name|dc
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
operator|&
name|nativeRect
argument_list|,
operator|&
name|hrgn
argument_list|)
expr_stmt|;
return|return
name|hrgn
return|;
block|}
end_function
begin_comment
comment|// QWindowsXPStylePrivate -------------------------------------------------------------------------
end_comment
begin_comment
comment|// Static initializations
end_comment
begin_decl_stmt
DECL|member|tabbody
name|QPixmap
modifier|*
name|QWindowsXPStylePrivate
operator|::
name|tabbody
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|m_themes
name|HTHEME
name|QWindowsXPStylePrivate
operator|::
name|m_themes
index|[
name|NThemes
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|use_xp
name|bool
name|QWindowsXPStylePrivate
operator|::
name|use_xp
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ref
name|QBasicAtomicInt
name|QWindowsXPStylePrivate
operator|::
name|ref
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|ref
comment|// -1 based refcounting
end_comment
begin_function
DECL|function|qt_add_rect
specifier|static
name|void
name|qt_add_rect
parameter_list|(
name|HRGN
modifier|&
name|winRegion
parameter_list|,
name|QRect
name|r
parameter_list|)
block|{
name|HRGN
name|rgn
init|=
name|CreateRectRgn
argument_list|(
name|r
operator|.
name|left
argument_list|()
argument_list|,
name|r
operator|.
name|top
argument_list|()
argument_list|,
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rgn
condition|)
block|{
name|HRGN
name|dest
init|=
name|CreateRectRgn
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|CombineRgn
argument_list|(
name|dest
argument_list|,
name|winRegion
argument_list|,
name|rgn
argument_list|,
name|RGN_OR
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|DeleteObject
argument_list|(
name|winRegion
argument_list|)
expr_stmt|;
name|winRegion
operator|=
name|dest
expr_stmt|;
block|}
name|DeleteObject
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_hrgn_from_qregion
specifier|static
name|HRGN
name|qt_hrgn_from_qregion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|HRGN
name|hRegion
init|=
name|CreateRectRgn
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|qt_add_rect
argument_list|(
name|hRegion
argument_list|,
name|region
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|hRegion
return|;
block|}
foreach|foreach
control|(
specifier|const
name|QRect
modifier|&
name|rect
decl|,
name|region
operator|.
name|rects
argument_list|()
control|)
name|qt_add_rect
argument_list|(
name|hRegion
argument_list|,
name|rect
argument_list|)
expr_stmt|;
return|return
name|hRegion
return|;
block|}
end_function
begin_comment
comment|/* \internal     Checks if the theme engine can/should be used, or if we should     fall back to Windows style. */
end_comment
begin_function
DECL|function|useXP
name|bool
name|QWindowsXPStylePrivate
operator|::
name|useXP
parameter_list|(
name|bool
name|update
parameter_list|)
block|{
if|if
condition|(
operator|!
name|update
condition|)
return|return
name|use_xp
return|;
return|return
operator|(
name|use_xp
operator|=
name|resolveSymbols
argument_list|()
operator|&&
name|pIsThemeActive
argument_list|()
operator|&&
operator|(
name|pIsAppThemed
argument_list|()
operator|||
operator|!
name|QApplication
operator|::
name|instance
argument_list|()
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/* \internal     Handles refcounting, and queries the theme engine for usage. */
end_comment
begin_function
DECL|function|init
name|void
name|QWindowsXPStylePrivate
operator|::
name|init
parameter_list|(
name|bool
name|force
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|.
name|ref
argument_list|()
operator|&&
operator|!
name|force
condition|)
return|return;
if|if
condition|(
operator|!
name|force
condition|)
comment|// -1 based atomic refcounting
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|useXP
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qFill
argument_list|(
name|m_themes
argument_list|,
name|m_themes
operator|+
name|NThemes
argument_list|,
name|HTHEME
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* \internal     Cleans up all static data. */
end_comment
begin_function
DECL|function|cleanup
name|void
name|QWindowsXPStylePrivate
operator|::
name|cleanup
parameter_list|(
name|bool
name|force
parameter_list|)
block|{
if|if
condition|(
name|bufferBitmap
condition|)
block|{
if|if
condition|(
name|bufferDC
operator|&&
name|nullBitmap
condition|)
name|SelectObject
argument_list|(
name|bufferDC
argument_list|,
name|nullBitmap
argument_list|)
expr_stmt|;
name|DeleteObject
argument_list|(
name|bufferBitmap
argument_list|)
expr_stmt|;
name|bufferBitmap
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bufferDC
condition|)
name|DeleteDC
argument_list|(
name|bufferDC
argument_list|)
expr_stmt|;
name|bufferDC
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ref
operator|.
name|deref
argument_list|()
operator|&&
operator|!
name|force
condition|)
return|return;
if|if
condition|(
operator|!
name|force
condition|)
comment|// -1 based atomic refcounting
name|ref
operator|.
name|deref
argument_list|()
expr_stmt|;
name|use_xp
operator|=
literal|false
expr_stmt|;
name|cleanupHandleMap
argument_list|()
expr_stmt|;
operator|delete
name|tabbody
expr_stmt|;
name|tabbody
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* \internal     Closes all open theme data handles to ensure that we don't leak     resources, and that we don't refere to old handles when for     example the user changes the theme style. */
end_comment
begin_function
DECL|function|cleanupHandleMap
name|void
name|QWindowsXPStylePrivate
operator|::
name|cleanupHandleMap
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NThemes
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m_themes
index|[
name|i
index|]
condition|)
block|{
name|pCloseThemeData
argument_list|(
name|m_themes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|m_themes
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createTheme
name|HTHEME
name|QWindowsXPStylePrivate
operator|::
name|createTheme
parameter_list|(
name|int
name|theme
parameter_list|,
name|HWND
name|hwnd
parameter_list|)
block|{
if|if
condition|(
name|theme
operator|<
literal|0
operator|||
name|theme
operator|>=
name|NThemes
operator|||
operator|!
name|hwnd
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: Invalid parameters #%d, %p"
argument_list|,
name|Q_FUNC_INFO
argument_list|,
name|theme
argument_list|,
name|hwnd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|m_themes
index|[
name|theme
index|]
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|name
init|=
name|themeNames
index|[
name|theme
index|]
decl_stmt|;
name|m_themes
index|[
name|theme
index|]
operator|=
name|pOpenThemeData
argument_list|(
name|hwnd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_themes
index|[
name|theme
index|]
condition|)
name|qErrnoWarning
argument_list|(
literal|"%s: OpenThemeData() failed for theme %d (%s)."
argument_list|,
name|Q_FUNC_INFO
argument_list|,
name|theme
argument_list|,
name|qPrintable
argument_list|(
name|themeName
argument_list|(
name|theme
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m_themes
index|[
name|theme
index|]
return|;
block|}
end_function
begin_function
DECL|function|themeName
name|QString
name|QWindowsXPStylePrivate
operator|::
name|themeName
parameter_list|(
name|int
name|theme
parameter_list|)
block|{
return|return
name|theme
operator|>=
literal|0
operator|&&
name|theme
operator|<
name|NThemes
condition|?
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|themeNames
index|[
name|theme
index|]
argument_list|)
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \internal     This function will always return a valid window handle, and might     create a limbo widget to do so.     We often need a window handle to for example open theme data, so     this function ensures that we get one. */
end_comment
begin_function
DECL|function|winId
name|HWND
name|QWindowsXPStylePrivate
operator|::
name|winId
parameter_list|(
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
if|if
condition|(
name|widget
condition|)
if|if
condition|(
specifier|const
name|HWND
name|hwnd
init|=
name|QApplicationPrivate
operator|::
name|getHWNDForWidget
argument_list|(
cast|const_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
argument_list|)
condition|)
return|return
name|hwnd
return|;
comment|// Find top level with native window (there might be dialogs that do not have one).
foreach|foreach
control|(
specifier|const
name|QWidget
modifier|*
name|toplevel
decl|,
name|QApplication
operator|::
name|topLevelWidgets
argument_list|()
control|)
if|if
condition|(
name|toplevel
operator|->
name|windowHandle
argument_list|()
operator|&&
name|toplevel
operator|->
name|windowHandle
argument_list|()
operator|->
name|handle
argument_list|()
condition|)
if|if
condition|(
specifier|const
name|HWND
name|topLevelHwnd
init|=
name|QApplicationPrivate
operator|::
name|getHWNDForWidget
argument_list|(
name|toplevel
argument_list|)
condition|)
return|return
name|topLevelHwnd
return|;
if|if
condition|(
name|QDesktopWidget
modifier|*
name|desktop
init|=
name|qApp
operator|->
name|desktop
argument_list|()
condition|)
if|if
condition|(
specifier|const
name|HWND
name|desktopHwnd
init|=
name|QApplicationPrivate
operator|::
name|getHWNDForWidget
argument_list|(
name|desktop
argument_list|)
condition|)
return|return
name|desktopHwnd
return|;
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the pointer to a tab widgets body pixmap, scaled to the     height of the screen. This way the theme engine doesn't need to     scale the body for every time we ask for it. (Speed optimization) */
end_comment
begin_function
DECL|function|tabBody
specifier|const
name|QPixmap
modifier|*
name|QWindowsXPStylePrivate
operator|::
name|tabBody
parameter_list|(
name|QWidget
modifier|*
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tabbody
condition|)
block|{
name|SIZE
name|sz
decl_stmt|;
name|XPThemeData
name|theme
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QWindowsXPStylePrivate
operator|::
name|TabTheme
argument_list|,
name|TABP_BODY
argument_list|)
decl_stmt|;
name|pGetThemePartSize
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|qt_win_display_dc
argument_list|()
argument_list|,
name|TABP_BODY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TS_TRUE
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|tabbody
operator|=
operator|new
name|QPixmap
argument_list|(
name|sz
operator|.
name|cx
argument_list|,
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QPainter
name|painter
argument_list|(
name|tabbody
argument_list|)
decl_stmt|;
name|theme
operator|.
name|rect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|sz
operator|.
name|cx
argument_list|,
name|sz
operator|.
name|cy
argument_list|)
expr_stmt|;
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
comment|// We fill with the last line of the themedata, that
comment|// way we don't get a tiled pixmap inside big tabs
name|QPixmap
name|temp
argument_list|(
name|sz
operator|.
name|cx
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|painter
operator|.
name|drawPixmap
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|sz
operator|.
name|cy
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawTiledPixmap
argument_list|(
literal|0
argument_list|,
name|sz
operator|.
name|cy
argument_list|,
name|sz
operator|.
name|cx
argument_list|,
name|tabbody
operator|->
name|height
argument_list|()
operator|-
name|sz
operator|.
name|cy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|tabbody
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if all the necessary theme engine symbols were     resolved. */
end_comment
begin_function
DECL|function|resolveSymbols
name|bool
name|QWindowsXPStylePrivate
operator|::
name|resolveSymbols
parameter_list|()
block|{
specifier|static
name|bool
name|tried
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|tried
condition|)
block|{
name|tried
operator|=
literal|true
expr_stmt|;
name|QSystemLibrary
name|themeLib
argument_list|(
name|QLatin1String
argument_list|(
literal|"uxtheme"
argument_list|)
argument_list|)
decl_stmt|;
name|pIsAppThemed
operator|=
operator|(
name|PtrIsAppThemed
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"IsAppThemed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pIsAppThemed
condition|)
block|{
name|pIsThemeActive
operator|=
operator|(
name|PtrIsThemeActive
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"IsThemeActive"
argument_list|)
expr_stmt|;
name|pGetThemePartSize
operator|=
operator|(
name|PtrGetThemePartSize
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemePartSize"
argument_list|)
expr_stmt|;
name|pOpenThemeData
operator|=
operator|(
name|PtrOpenThemeData
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"OpenThemeData"
argument_list|)
expr_stmt|;
name|pCloseThemeData
operator|=
operator|(
name|PtrCloseThemeData
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"CloseThemeData"
argument_list|)
expr_stmt|;
name|pDrawThemeBackground
operator|=
operator|(
name|PtrDrawThemeBackground
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"DrawThemeBackground"
argument_list|)
expr_stmt|;
name|pDrawThemeBackgroundEx
operator|=
operator|(
name|PtrDrawThemeBackgroundEx
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"DrawThemeBackgroundEx"
argument_list|)
expr_stmt|;
name|pGetCurrentThemeName
operator|=
operator|(
name|PtrGetCurrentThemeName
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetCurrentThemeName"
argument_list|)
expr_stmt|;
name|pGetThemeBool
operator|=
operator|(
name|PtrGetThemeBool
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeBool"
argument_list|)
expr_stmt|;
name|pGetThemeColor
operator|=
operator|(
name|PtrGetThemeColor
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeColor"
argument_list|)
expr_stmt|;
name|pGetThemeEnumValue
operator|=
operator|(
name|PtrGetThemeEnumValue
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeEnumValue"
argument_list|)
expr_stmt|;
name|pGetThemeFilename
operator|=
operator|(
name|PtrGetThemeFilename
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeFilename"
argument_list|)
expr_stmt|;
name|pGetThemeFont
operator|=
operator|(
name|PtrGetThemeFont
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeFont"
argument_list|)
expr_stmt|;
name|pGetThemeInt
operator|=
operator|(
name|PtrGetThemeInt
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeInt"
argument_list|)
expr_stmt|;
name|pGetThemeIntList
operator|=
operator|(
name|PtrGetThemeIntList
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeIntList"
argument_list|)
expr_stmt|;
name|pGetThemeMargins
operator|=
operator|(
name|PtrGetThemeMargins
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeMargins"
argument_list|)
expr_stmt|;
name|pGetThemeMetric
operator|=
operator|(
name|PtrGetThemeMetric
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeMetric"
argument_list|)
expr_stmt|;
name|pGetThemePartSize
operator|=
operator|(
name|PtrGetThemePartSize
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemePartSize"
argument_list|)
expr_stmt|;
name|pGetThemePosition
operator|=
operator|(
name|PtrGetThemePosition
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemePosition"
argument_list|)
expr_stmt|;
name|pGetThemePropertyOrigin
operator|=
operator|(
name|PtrGetThemePropertyOrigin
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemePropertyOrigin"
argument_list|)
expr_stmt|;
name|pGetThemeRect
operator|=
operator|(
name|PtrGetThemeRect
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeRect"
argument_list|)
expr_stmt|;
name|pGetThemeString
operator|=
operator|(
name|PtrGetThemeString
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeString"
argument_list|)
expr_stmt|;
name|pGetThemeBackgroundRegion
operator|=
operator|(
name|PtrGetThemeBackgroundRegion
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeBackgroundRegion"
argument_list|)
expr_stmt|;
name|pGetThemeDocumentationProperty
operator|=
operator|(
name|PtrGetThemeDocumentationProperty
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"GetThemeDocumentationProperty"
argument_list|)
expr_stmt|;
name|pIsThemeBackgroundPartiallyTransparent
operator|=
operator|(
name|PtrIsThemeBackgroundPartiallyTransparent
operator|)
name|themeLib
operator|.
name|resolve
argument_list|(
literal|"IsThemeBackgroundPartiallyTransparent"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pIsAppThemed
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns a native buffer (DIB section) of at least the size of     ( \a x , \a y ). The buffer has a 32 bit depth, to not lose     the alpha values on proper alpha-pixmaps. */
end_comment
begin_function
DECL|function|buffer
name|HBITMAP
name|QWindowsXPStylePrivate
operator|::
name|buffer
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
comment|// If we already have a HBITMAP which is of adequate size, just return that
if|if
condition|(
name|bufferBitmap
condition|)
block|{
if|if
condition|(
name|bufferW
operator|>=
name|w
operator|&&
name|bufferH
operator|>=
name|h
condition|)
return|return
name|bufferBitmap
return|;
comment|// Not big enough, discard the old one
if|if
condition|(
name|bufferDC
operator|&&
name|nullBitmap
condition|)
name|SelectObject
argument_list|(
name|bufferDC
argument_list|,
name|nullBitmap
argument_list|)
expr_stmt|;
name|DeleteObject
argument_list|(
name|bufferBitmap
argument_list|)
expr_stmt|;
name|bufferBitmap
operator|=
literal|0
expr_stmt|;
block|}
name|w
operator|=
name|qMax
argument_list|(
name|bufferW
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|h
operator|=
name|qMax
argument_list|(
name|bufferH
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufferDC
condition|)
name|bufferDC
operator|=
name|CreateCompatibleDC
argument_list|(
name|qt_win_display_dc
argument_list|()
argument_list|)
expr_stmt|;
comment|// Define the header
name|BITMAPINFO
name|bmi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|bmi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bmi
argument_list|)
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biSize
operator|=
sizeof|sizeof
argument_list|(
name|BITMAPINFOHEADER
argument_list|)
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biWidth
operator|=
name|w
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biHeight
operator|=
operator|-
name|h
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biPlanes
operator|=
literal|1
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biBitCount
operator|=
literal|32
expr_stmt|;
name|bmi
operator|.
name|bmiHeader
operator|.
name|biCompression
operator|=
name|BI_RGB
expr_stmt|;
comment|// Create the pixmap
name|bufferPixels
operator|=
literal|0
expr_stmt|;
name|bufferBitmap
operator|=
name|CreateDIBSection
argument_list|(
name|bufferDC
argument_list|,
operator|&
name|bmi
argument_list|,
name|DIB_RGB_COLORS
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|bufferPixels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GdiFlush
argument_list|()
expr_stmt|;
name|nullBitmap
operator|=
operator|(
name|HBITMAP
operator|)
name|SelectObject
argument_list|(
name|bufferDC
argument_list|,
name|bufferBitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufferBitmap
condition|)
block|{
name|qErrnoWarning
argument_list|(
literal|"QWindowsXPStylePrivate::buffer(w,h), failed to create dibsection"
argument_list|)
expr_stmt|;
name|bufferW
operator|=
literal|0
expr_stmt|;
name|bufferH
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|bufferPixels
condition|)
block|{
name|qErrnoWarning
argument_list|(
literal|"QWindowsXPStylePrivate::buffer(w,h), did not allocate pixel data"
argument_list|)
expr_stmt|;
name|bufferW
operator|=
literal|0
expr_stmt|;
name|bufferH
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bufferW
operator|=
name|w
expr_stmt|;
name|bufferH
operator|=
name|h
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XP_STYLE
name|qDebug
argument_list|(
literal|"Creating new dib section (%d, %d)"
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bufferBitmap
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if the part contains any transparency at all. This does     not indicate what kind of transparency we're dealing with. It can be         - Alpha transparency         - Masked transparency */
end_comment
begin_function
DECL|function|isTransparent
name|bool
name|QWindowsXPStylePrivate
operator|::
name|isTransparent
parameter_list|(
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
return|return
name|pIsThemeBackgroundPartiallyTransparent
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns a QRegion of the region of the part */
end_comment
begin_function
DECL|function|region
name|QRegion
name|QWindowsXPStylePrivate
operator|::
name|region
parameter_list|(
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
name|HRGN
name|hRgn
init|=
literal|0
decl_stmt|;
name|RECT
name|rect
init|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|themeData
operator|.
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCEEDED
argument_list|(
name|pGetThemeBackgroundRegion
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|bufferHDC
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
operator|&
name|rect
argument_list|,
operator|&
name|hRgn
argument_list|)
argument_list|)
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|HRGN
name|dest
init|=
name|CreateRectRgn
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|success
init|=
name|CombineRgn
argument_list|(
name|dest
argument_list|,
name|hRgn
argument_list|,
literal|0
argument_list|,
name|RGN_COPY
argument_list|)
operator|!=
name|ERROR
decl_stmt|;
name|QRegion
name|region
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|int
name|numBytes
init|=
name|GetRegionData
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|==
literal|0
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|char
modifier|*
name|buf
init|=
operator|new
name|char
index|[
name|numBytes
index|]
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
return|return
name|QRegion
argument_list|()
return|;
name|RGNDATA
modifier|*
name|rd
init|=
cast|reinterpret_cast
argument_list|<
name|RGNDATA
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|GetRegionData
argument_list|(
name|dest
argument_list|,
name|numBytes
argument_list|,
name|rd
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|delete
index|[]
name|buf
expr_stmt|;
return|return
name|QRegion
argument_list|()
return|;
block|}
name|RECT
modifier|*
name|r
init|=
cast|reinterpret_cast
argument_list|<
name|RECT
operator|*
argument_list|>
argument_list|(
name|rd
operator|->
name|Buffer
argument_list|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rd
operator|->
name|rdh
operator|.
name|nCount
condition|;
operator|++
name|i
control|)
block|{
name|QRect
name|rect
decl_stmt|;
name|rect
operator|.
name|setCoords
argument_list|(
name|r
operator|->
name|left
argument_list|,
name|r
operator|->
name|top
argument_list|,
name|r
operator|->
name|right
operator|-
literal|1
argument_list|,
name|r
operator|->
name|bottom
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|r
expr_stmt|;
name|region
operator||=
name|rect
expr_stmt|;
block|}
operator|delete
index|[]
name|buf
expr_stmt|;
block|}
name|DeleteObject
argument_list|(
name|hRgn
argument_list|)
expr_stmt|;
name|DeleteObject
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|region
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Sets the parts region on a window. */
end_comment
begin_function
DECL|function|setTransparency
name|void
name|QWindowsXPStylePrivate
operator|::
name|setTransparency
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
name|HRGN
name|hrgn
init|=
name|themeData
operator|.
name|mask
argument_list|(
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|hrgn
operator|&&
name|widget
condition|)
name|SetWindowRgn
argument_list|(
name|winId
argument_list|(
name|widget
argument_list|)
argument_list|,
name|hrgn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if the native doublebuffer contains a pixel which     has a non-0xFF alpha value. Should only be use when its     guaranteed that data painted into the buffer wasn't a proper     alpha pixmap. */
end_comment
begin_function
DECL|function|hasAnyData
name|bool
name|QWindowsXPStylePrivate
operator|::
name|hasAnyData
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|startX
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|startY
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|startY
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|register
name|DWORD
modifier|*
name|buffer
init|=
operator|(
name|DWORD
operator|*
operator|)
name|bufferPixels
operator|+
operator|(
name|y
operator|*
name|bufferW
operator|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
name|startX
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
operator|,
operator|++
name|buffer
control|)
block|{
name|int
name|alpha
init|=
operator|(
operator|*
name|buffer
operator|)
operator|>>
literal|24
decl_stmt|;
if|if
condition|(
name|alpha
operator|!=
literal|0xFF
condition|)
comment|// buffer has been touched
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns true if the native doublebuffer contains pixels with     varying alpha value. */
end_comment
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QWindowsXPStylePrivate
operator|::
name|hasAlphaChannel
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|startX
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|startY
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|firstAlpha
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|startY
init|;
name|y
operator|<
name|h
operator|/
literal|2
condition|;
operator|++
name|y
control|)
block|{
specifier|register
name|DWORD
modifier|*
name|buffer
init|=
operator|(
name|DWORD
operator|*
operator|)
name|bufferPixels
operator|+
operator|(
name|y
operator|*
name|bufferW
operator|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
name|startX
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
operator|,
operator|++
name|buffer
control|)
block|{
name|int
name|alpha
init|=
operator|(
operator|*
name|buffer
operator|)
operator|>>
literal|24
decl_stmt|;
if|if
condition|(
name|firstAlpha
operator|==
operator|-
literal|1
condition|)
name|firstAlpha
operator|=
name|alpha
expr_stmt|;
elseif|else
if|if
condition|(
name|alpha
operator|!=
name|firstAlpha
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \internal     When the theme engine paints both a true alpha pixmap and a glyph     into our buffer, the glyph might not contain a proper alpha value.     The rule of thumb for premultiplied pixmaps is that the color     values of a pixel can never be higher than the alpha values, so     we use this to our advantage here, and fix all instances where     this occures. */
end_comment
begin_function
DECL|function|fixAlphaChannel
name|bool
name|QWindowsXPStylePrivate
operator|::
name|fixAlphaChannel
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
specifier|const
name|int
name|startX
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|startY
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|bool
name|hasFixedAlphaValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|startY
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|register
name|DWORD
modifier|*
name|buffer
init|=
operator|(
name|DWORD
operator|*
operator|)
name|bufferPixels
operator|+
operator|(
name|y
operator|*
name|bufferW
operator|)
decl_stmt|;
for|for
control|(
specifier|register
name|int
name|x
init|=
name|startX
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
operator|,
operator|++
name|buffer
control|)
block|{
name|uint
name|pixel
init|=
operator|*
name|buffer
decl_stmt|;
name|int
name|alpha
init|=
name|qAlpha
argument_list|(
name|pixel
argument_list|)
decl_stmt|;
if|if
condition|(
name|qRed
argument_list|(
name|pixel
argument_list|)
operator|>
name|alpha
operator|||
name|qGreen
argument_list|(
name|pixel
argument_list|)
operator|>
name|alpha
operator|||
name|qBlue
argument_list|(
name|pixel
argument_list|)
operator|>
name|alpha
condition|)
block|{
operator|*
name|buffer
operator||=
literal|0xff000000
expr_stmt|;
name|hasFixedAlphaValue
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|hasFixedAlphaValue
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Swaps the alpha values on certain pixels:         0xFF?????? -> 0x00??????         0x00?????? -> 0xFF??????     Used to determin the mask of a non-alpha transparent pixmap in     the native doublebuffer, and swap the alphas so we may paint     the image as a Premultiplied QImage with drawImage(), and obtain     the mask transparency. */
end_comment
begin_function
DECL|function|swapAlphaChannel
name|bool
name|QWindowsXPStylePrivate
operator|::
name|swapAlphaChannel
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|bool
name|allPixels
parameter_list|)
block|{
specifier|const
name|int
name|startX
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|startY
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
name|bool
name|valueChange
init|=
literal|false
decl_stmt|;
comment|// Flip the alphas, so that 255-alpha pixels are 0, and 0-alpha are 255.
for|for
control|(
name|int
name|y
init|=
name|startY
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|register
name|DWORD
modifier|*
name|buffer
init|=
operator|(
name|DWORD
operator|*
operator|)
name|bufferPixels
operator|+
operator|(
name|y
operator|*
name|bufferW
operator|)
decl_stmt|;
for|for
control|(
specifier|register
name|int
name|x
init|=
name|startX
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
operator|,
operator|++
name|buffer
control|)
block|{
if|if
condition|(
name|allPixels
condition|)
block|{
operator|*
name|buffer
operator||=
literal|0xFF000000
expr_stmt|;
continue|continue;
block|}
specifier|register
name|unsigned
name|int
name|alphaValue
init|=
operator|(
operator|*
name|buffer
operator|)
operator|&
literal|0xFF000000
decl_stmt|;
if|if
condition|(
name|alphaValue
operator|==
literal|0xFF000000
condition|)
block|{
operator|*
name|buffer
operator|=
literal|0
expr_stmt|;
name|valueChange
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alphaValue
operator|==
literal|0
condition|)
block|{
operator|*
name|buffer
operator||=
literal|0xFF000000
expr_stmt|;
name|valueChange
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|valueChange
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Main theme drawing function.     Determines the correct lowlevel drawing method depending on several     factors.         Use drawBackgroundThruNativeBuffer() if:             - Painter does not have an HDC             - Theme part is flipped (mirrored horizontally)         else use drawBackgroundDirectly(). */
end_comment
begin_function
DECL|function|drawBackground
name|void
name|QWindowsXPStylePrivate
operator|::
name|drawBackground
parameter_list|(
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
if|if
condition|(
name|themeData
operator|.
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QPainter
modifier|*
name|painter
init|=
name|themeData
operator|.
name|painter
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|painter
operator|!=
literal|0
argument_list|,
literal|"QWindowsXPStylePrivate::drawBackground()"
argument_list|,
literal|"Trying to draw a theme part without a painter"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|painter
operator|||
operator|!
name|painter
operator|->
name|isActive
argument_list|()
condition|)
return|return;
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|bool
name|complexXForm
init|=
name|painter
operator|->
name|deviceTransform
argument_list|()
operator|.
name|type
argument_list|()
operator|>
name|QTransform
operator|::
name|TxTranslate
decl_stmt|;
name|bool
name|translucentToplevel
init|=
literal|false
decl_stmt|;
name|QPaintDevice
modifier|*
name|pdev
init|=
name|painter
operator|->
name|device
argument_list|()
decl_stmt|;
if|if
condition|(
name|pdev
operator|->
name|devType
argument_list|()
operator|==
name|QInternal
operator|::
name|Widget
condition|)
block|{
name|QWidget
modifier|*
name|win
init|=
operator|(
operator|(
name|QWidget
operator|*
operator|)
name|pdev
operator|)
operator|->
name|window
argument_list|()
decl_stmt|;
name|translucentToplevel
operator|=
name|win
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_TranslucentBackground
argument_list|)
expr_stmt|;
block|}
comment|// Draw on backing store DC only for real widgets.
comment|// Access paintDevice via engine since the painter may
comment|// return the clip device which can still be a widget device in case of grabWidget().
specifier|const
name|bool
name|useFallback
init|=
operator|!
name|themeData
operator|.
name|widget
operator|||
name|painter
operator|->
name|paintEngine
argument_list|()
operator|->
name|paintDevice
argument_list|()
operator|->
name|devType
argument_list|()
operator|!=
name|QInternal
operator|::
name|Widget
operator|||
name|painter
operator|->
name|opacity
argument_list|()
operator|!=
literal|1.0
operator|||
name|themeData
operator|.
name|rotate
operator|||
name|complexXForm
operator|||
name|themeData
operator|.
name|mirrorVertically
operator|||
operator|(
name|themeData
operator|.
name|mirrorHorizontally
operator|&&
name|pDrawThemeBackgroundEx
operator|==
literal|0
operator|)
operator|||
name|translucentToplevel
decl_stmt|;
specifier|const
name|HDC
name|dc
init|=
name|useFallback
condition|?
name|HDC
argument_list|(
literal|0
argument_list|)
else|:
name|hdcForWidgetBackingStore
argument_list|(
name|themeData
operator|.
name|widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|dc
operator|&&
operator|!
name|useFallback
condition|)
block|{
name|drawBackgroundDirectly
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawBackgroundThruNativeBuffer
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
block|}
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     This function draws the theme parts directly to the paintengines HDC.     Do not use this if you need to perform other transformations on the     resulting data. */
end_comment
begin_function
DECL|function|drawBackgroundDirectly
name|void
name|QWindowsXPStylePrivate
operator|::
name|drawBackgroundDirectly
parameter_list|(
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
name|QPainter
modifier|*
name|painter
init|=
name|themeData
operator|.
name|painter
decl_stmt|;
name|HDC
name|dc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|themeData
operator|.
name|widget
condition|)
name|dc
operator|=
name|hdcForWidgetBackingStore
argument_list|(
name|themeData
operator|.
name|widget
argument_list|)
expr_stmt|;
name|QPoint
name|redirectionDelta
argument_list|(
name|int
argument_list|(
name|painter
operator|->
name|deviceMatrix
argument_list|()
operator|.
name|dx
argument_list|()
argument_list|)
argument_list|,
name|int
argument_list|(
name|painter
operator|->
name|deviceMatrix
argument_list|()
operator|.
name|dy
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QRect
name|area
init|=
name|themeData
operator|.
name|rect
operator|.
name|translated
argument_list|(
name|redirectionDelta
argument_list|)
decl_stmt|;
name|QRegion
name|sysRgn
init|=
name|painter
operator|->
name|paintEngine
argument_list|()
operator|->
name|systemClip
argument_list|()
decl_stmt|;
if|if
condition|(
name|sysRgn
operator|.
name|isEmpty
argument_list|()
condition|)
name|sysRgn
operator|=
name|area
expr_stmt|;
else|else
name|sysRgn
operator|&=
name|area
expr_stmt|;
if|if
condition|(
name|painter
operator|->
name|hasClipping
argument_list|()
condition|)
name|sysRgn
operator|&=
name|painter
operator|->
name|clipRegion
argument_list|()
operator|.
name|translated
argument_list|(
name|redirectionDelta
argument_list|)
expr_stmt|;
name|HRGN
name|hrgn
init|=
name|qt_hrgn_from_qregion
argument_list|(
name|sysRgn
argument_list|)
decl_stmt|;
name|SelectClipRgn
argument_list|(
name|dc
argument_list|,
name|hrgn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XP_STYLE
name|printf
argument_list|(
literal|"---[ DIRECT PAINTING ]------------------> Name(%-10s) Part(%d) State(%d)\n"
argument_list|,
name|qPrintable
argument_list|(
name|themeData
operator|.
name|name
argument_list|)
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|)
expr_stmt|;
name|showProperties
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RECT
name|drawRECT
init|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|area
argument_list|)
decl_stmt|;
name|DTBGOPTS
name|drawOptions
decl_stmt|;
name|drawOptions
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|drawOptions
argument_list|)
expr_stmt|;
name|drawOptions
operator|.
name|rcClip
operator|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|sysRgn
operator|.
name|boundingRect
argument_list|()
argument_list|)
expr_stmt|;
name|drawOptions
operator|.
name|dwFlags
operator|=
name|DTBG_CLIPRECT
operator||
operator|(
name|themeData
operator|.
name|noBorder
condition|?
name|DTBG_OMITBORDER
else|:
literal|0
operator|)
operator||
operator|(
name|themeData
operator|.
name|noContent
condition|?
name|DTBG_OMITCONTENT
else|:
literal|0
operator|)
operator||
operator|(
name|themeData
operator|.
name|mirrorHorizontally
condition|?
name|DTBG_MIRRORDC
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pDrawThemeBackgroundEx
operator|!=
literal|0
condition|)
block|{
name|pDrawThemeBackgroundEx
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|dc
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
operator|&
operator|(
name|drawRECT
operator|)
argument_list|,
operator|&
name|drawOptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We are running on a system where the uxtheme.dll does not have
comment|// the DrawThemeBackgroundEx function, so we need to clip away
comment|// borders or contents manually. All flips and mirrors uses the
comment|// fallback implementation
name|int
name|borderSize
init|=
literal|0
decl_stmt|;
name|PROPERTYORIGIN
name|origin
init|=
name|PO_NOTFOUND
decl_stmt|;
name|pGetThemePropertyOrigin
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_BORDERSIZE
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
name|pGetThemeInt
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_BORDERSIZE
argument_list|,
operator|&
name|borderSize
argument_list|)
expr_stmt|;
comment|// Clip away border region
name|QRegion
name|extraClip
init|=
name|sysRgn
decl_stmt|;
if|if
condition|(
operator|(
name|origin
operator|==
name|PO_CLASS
operator|||
name|origin
operator|==
name|PO_PART
operator|||
name|origin
operator|==
name|PO_STATE
operator|)
operator|&&
name|borderSize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|themeData
operator|.
name|noBorder
condition|)
block|{
comment|// extraClip&= area is already done
name|drawRECT
operator|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|area
operator|.
name|adjusted
argument_list|(
operator|-
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|,
name|borderSize
argument_list|,
name|borderSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Clip away content region
if|if
condition|(
name|themeData
operator|.
name|noContent
condition|)
block|{
name|QRegion
name|content
init|=
name|area
operator|.
name|adjusted
argument_list|(
name|borderSize
argument_list|,
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|)
decl_stmt|;
name|extraClip
operator|^=
name|content
expr_stmt|;
block|}
comment|// Set the clip region, if used..
if|if
condition|(
name|themeData
operator|.
name|noBorder
operator|||
name|themeData
operator|.
name|noContent
condition|)
block|{
name|DeleteObject
argument_list|(
name|hrgn
argument_list|)
expr_stmt|;
name|hrgn
operator|=
name|qt_hrgn_from_qregion
argument_list|(
name|extraClip
argument_list|)
expr_stmt|;
name|SelectClipRgn
argument_list|(
name|dc
argument_list|,
name|hrgn
argument_list|)
expr_stmt|;
block|}
block|}
name|pDrawThemeBackground
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|dc
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
operator|&
operator|(
name|drawRECT
operator|)
argument_list|,
operator|&
operator|(
name|drawOptions
operator|.
name|rcClip
operator|)
argument_list|)
expr_stmt|;
block|}
name|SelectClipRgn
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DeleteObject
argument_list|(
name|hrgn
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     This function uses a secondary Native doublebuffer for painting parts.     It should only be used when the painteengine doesn't provide a proper     HDC for direct painting (e.g. when doing a grabWidget(), painting to     other pixmaps etc), or when special transformations are needed (e.g.     flips (horizonal mirroring only, vertical are handled by the theme     engine). */
end_comment
begin_function
DECL|function|drawBackgroundThruNativeBuffer
name|void
name|QWindowsXPStylePrivate
operator|::
name|drawBackgroundThruNativeBuffer
parameter_list|(
name|XPThemeData
modifier|&
name|themeData
parameter_list|)
block|{
name|QPainter
modifier|*
name|painter
init|=
name|themeData
operator|.
name|painter
decl_stmt|;
name|QRect
name|rect
init|=
name|themeData
operator|.
name|rect
decl_stmt|;
if|if
condition|(
operator|(
name|themeData
operator|.
name|rotate
operator|+
literal|90
operator|)
operator|%
literal|180
operator|==
literal|0
condition|)
block|{
comment|// Catch 90,270,etc.. degree flips.
name|rect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|rect
operator|.
name|moveTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|partId
init|=
name|themeData
operator|.
name|partId
decl_stmt|;
name|int
name|stateId
init|=
name|themeData
operator|.
name|stateId
decl_stmt|;
name|int
name|w
init|=
name|rect
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|rect
operator|.
name|height
argument_list|()
decl_stmt|;
comment|// Values initialized later, either from cached values, or from function calls
name|AlphaChannelType
name|alphaType
init|=
name|UnknownAlpha
decl_stmt|;
name|bool
name|stateHasData
init|=
literal|true
decl_stmt|;
comment|// We assume so;
name|bool
name|hasAlpha
init|=
literal|false
decl_stmt|;
name|bool
name|partIsTransparent
decl_stmt|;
name|bool
name|inspectData
decl_stmt|;
name|bool
name|potentialInvalidAlpha
decl_stmt|;
name|QString
name|pixmapCacheKey
init|=
name|QStringLiteral
argument_list|(
literal|"$qt_xp_"
argument_list|)
decl_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|themeName
argument_list|(
name|themeData
operator|.
name|theme
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|partId
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|stateId
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|themeData
operator|.
name|noBorder
condition|?
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'1'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'b'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|themeData
operator|.
name|noContent
condition|?
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'1'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'w'
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|pixmapCacheKey
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
argument_list|)
expr_stmt|;
name|QPixmap
name|cachedPixmap
decl_stmt|;
name|ThemeMapKey
name|key
argument_list|(
name|themeData
argument_list|)
decl_stmt|;
name|ThemeMapData
name|data
init|=
name|alphaCache
operator|.
name|value
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|bool
name|haveCachedPixmap
init|=
literal|false
decl_stmt|;
name|bool
name|isCached
init|=
name|data
operator|.
name|dataValid
decl_stmt|;
if|if
condition|(
name|isCached
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stateHasData
operator|=
name|data
operator|.
name|hasAnyData
operator|)
condition|)
return|return;
comment|// Cached NOOP
name|inspectData
operator|=
name|data
operator|.
name|wasAlphaSwapped
expr_stmt|;
name|partIsTransparent
operator|=
name|data
operator|.
name|partIsTransparent
expr_stmt|;
name|hasAlpha
operator|=
name|data
operator|.
name|hasAlphaChannel
expr_stmt|;
name|alphaType
operator|=
name|data
operator|.
name|alphaType
expr_stmt|;
name|potentialInvalidAlpha
operator|=
name|data
operator|.
name|hadInvalidAlpha
expr_stmt|;
name|haveCachedPixmap
operator|=
name|QPixmapCache
operator|::
name|find
argument_list|(
name|pixmapCacheKey
argument_list|,
name|cachedPixmap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XP_STYLE
name|char
name|buf
index|[
literal|25
index|]
decl_stmt|;
operator|::
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"+ Pixmap(%3d, %3d) ]"
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---[ CACHED %s--------> Name(%-10s) Part(%d) State(%d)\n"
argument_list|,
name|haveCachedPixmap
condition|?
name|buf
else|:
literal|"]-------------------"
argument_list|,
name|qPrintable
argument_list|(
name|themeData
operator|.
name|name
argument_list|)
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// Not cached, so get values from Theme Engine
name|BOOL
name|tmt_borderonly
init|=
literal|false
decl_stmt|;
name|COLORREF
name|tmt_transparentcolor
init|=
literal|0x0
decl_stmt|;
name|PROPERTYORIGIN
name|proporigin
init|=
name|PO_NOTFOUND
decl_stmt|;
name|pGetThemeBool
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_BORDERONLY
argument_list|,
operator|&
name|tmt_borderonly
argument_list|)
expr_stmt|;
name|pGetThemeColor
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_TRANSPARENTCOLOR
argument_list|,
operator|&
name|tmt_transparentcolor
argument_list|)
expr_stmt|;
name|pGetThemePropertyOrigin
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_CAPTIONMARGINS
argument_list|,
operator|&
name|proporigin
argument_list|)
expr_stmt|;
name|inspectData
operator|=
operator|(
name|tmt_transparentcolor
operator|!=
literal|0
operator|||
name|tmt_borderonly
operator|||
name|proporigin
operator|==
name|PO_PART
operator|||
name|proporigin
operator|==
name|PO_STATE
operator|)
expr_stmt|;
comment|// ### This is a vista-specific workaround for broken alpha in titlebar pixmaps
if|if
condition|(
operator|(
name|QSysInfo
operator|::
name|WindowsVersion
operator|>=
name|QSysInfo
operator|::
name|WV_VISTA
operator|&&
operator|(
name|QSysInfo
operator|::
name|WindowsVersion
operator|&
name|QSysInfo
operator|::
name|WV_NT_based
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|themeData
operator|.
name|partId
operator|==
name|WP_CAPTION
operator|||
name|themeData
operator|.
name|partId
operator|==
name|WP_SMALLCAPTION
condition|)
name|inspectData
operator|=
literal|false
expr_stmt|;
block|}
name|partIsTransparent
operator|=
name|isTransparent
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
name|potentialInvalidAlpha
operator|=
literal|false
expr_stmt|;
name|pGetThemePropertyOrigin
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_GLYPHTYPE
argument_list|,
operator|&
name|proporigin
argument_list|)
expr_stmt|;
if|if
condition|(
name|proporigin
operator|==
name|PO_PART
operator|||
name|proporigin
operator|==
name|PO_STATE
condition|)
block|{
name|int
name|tmt_glyphtype
init|=
name|GT_NONE
decl_stmt|;
name|pGetThemeEnumValue
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_GLYPHTYPE
argument_list|,
operator|&
name|tmt_glyphtype
argument_list|)
expr_stmt|;
name|potentialInvalidAlpha
operator|=
name|partIsTransparent
operator|&&
operator|!
name|inspectData
operator|&&
name|tmt_glyphtype
operator|==
name|GT_IMAGEGLYPH
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_XP_STYLE
name|printf
argument_list|(
literal|"---[ NOT CACHED ]-----------------------> Name(%-10s) Part(%d) State(%d)\n"
argument_list|,
name|qPrintable
argument_list|(
name|themeData
operator|.
name|name
argument_list|)
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-->partIsTransparen      = %d\n"
argument_list|,
name|partIsTransparent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-->inspectData           = %d\n"
argument_list|,
name|inspectData
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-->potentialInvalidAlpha = %d\n"
argument_list|,
name|potentialInvalidAlpha
argument_list|)
expr_stmt|;
name|showProperties
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bool
name|wasAlphaSwapped
init|=
literal|false
decl_stmt|;
name|bool
name|wasAlphaFixed
init|=
literal|false
decl_stmt|;
comment|// OLD PSDK Workaround ------------------------------------------------------------------------
comment|// See if we need extra clipping for the older PSDK, which does
comment|// not have a DrawThemeBackgroundEx function for DTGB_OMITBORDER
comment|// and DTGB_OMITCONTENT
name|bool
name|addBorderContentClipping
init|=
literal|false
decl_stmt|;
name|QRegion
name|extraClip
decl_stmt|;
name|QRect
name|area
init|=
name|rect
decl_stmt|;
if|if
condition|(
name|themeData
operator|.
name|noBorder
operator|||
name|themeData
operator|.
name|noContent
condition|)
block|{
name|extraClip
operator|=
name|area
expr_stmt|;
comment|// We are running on a system where the uxtheme.dll does not have
comment|// the DrawThemeBackgroundEx function, so we need to clip away
comment|// borders or contents manually.
name|int
name|borderSize
init|=
literal|0
decl_stmt|;
name|PROPERTYORIGIN
name|origin
init|=
name|PO_NOTFOUND
decl_stmt|;
name|pGetThemePropertyOrigin
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_BORDERSIZE
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
name|pGetThemeInt
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
name|TMT_BORDERSIZE
argument_list|,
operator|&
name|borderSize
argument_list|)
expr_stmt|;
comment|// Clip away border region
if|if
condition|(
operator|(
name|origin
operator|==
name|PO_CLASS
operator|||
name|origin
operator|==
name|PO_PART
operator|||
name|origin
operator|==
name|PO_STATE
operator|)
operator|&&
name|borderSize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|themeData
operator|.
name|noBorder
condition|)
block|{
name|extraClip
operator|&=
name|area
expr_stmt|;
name|area
operator|=
name|area
operator|.
name|adjusted
argument_list|(
operator|-
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|,
name|borderSize
argument_list|,
name|borderSize
argument_list|)
expr_stmt|;
block|}
comment|// Clip away content region
if|if
condition|(
name|themeData
operator|.
name|noContent
condition|)
block|{
name|QRegion
name|content
init|=
name|area
operator|.
name|adjusted
argument_list|(
name|borderSize
argument_list|,
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|,
operator|-
name|borderSize
argument_list|)
decl_stmt|;
name|extraClip
operator|^=
name|content
expr_stmt|;
block|}
block|}
name|addBorderContentClipping
operator|=
operator|(
name|themeData
operator|.
name|noBorder
operator||
name|themeData
operator|.
name|noContent
operator|)
expr_stmt|;
block|}
name|QImage
name|img
decl_stmt|;
if|if
condition|(
operator|!
name|haveCachedPixmap
condition|)
block|{
comment|// If the pixmap is not cached, generate it! -------------------------
name|buffer
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|// Ensure a buffer of at least (w, h) in size
name|HDC
name|dc
init|=
name|bufferHDC
argument_list|()
decl_stmt|;
comment|// Clear the buffer
if|if
condition|(
name|alphaType
operator|!=
name|NoAlpha
condition|)
block|{
comment|// Consider have separate "memset" function for small chunks for more speedup
name|memset
argument_list|(
name|bufferPixels
argument_list|,
name|inspectData
condition|?
literal|0xFF
else|:
literal|0x00
argument_list|,
name|bufferW
operator|*
name|h
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
comment|// Difference between area and rect
name|int
name|dx
init|=
name|area
operator|.
name|x
argument_list|()
operator|-
name|rect
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|dy
init|=
name|area
operator|.
name|y
argument_list|()
operator|-
name|rect
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|dr
init|=
name|area
operator|.
name|right
argument_list|()
operator|-
name|rect
operator|.
name|right
argument_list|()
decl_stmt|;
name|int
name|db
init|=
name|area
operator|.
name|bottom
argument_list|()
operator|-
name|rect
operator|.
name|bottom
argument_list|()
decl_stmt|;
comment|// Adjust so painting rect starts from Origo
name|rect
operator|.
name|moveTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|area
operator|.
name|moveTo
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|DTBGOPTS
name|drawOptions
decl_stmt|;
name|drawOptions
operator|.
name|dwSize
operator|=
sizeof|sizeof
argument_list|(
name|drawOptions
argument_list|)
expr_stmt|;
name|drawOptions
operator|.
name|rcClip
operator|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|drawOptions
operator|.
name|dwFlags
operator|=
name|DTBG_CLIPRECT
operator||
operator|(
name|themeData
operator|.
name|noBorder
condition|?
name|DTBG_OMITBORDER
else|:
literal|0
operator|)
operator||
operator|(
name|themeData
operator|.
name|noContent
condition|?
name|DTBG_OMITCONTENT
else|:
literal|0
operator|)
expr_stmt|;
comment|// Drawing the part into the backing store
if|if
condition|(
name|pDrawThemeBackgroundEx
operator|!=
literal|0
condition|)
block|{
name|RECT
name|rect
argument_list|(
name|themeData
operator|.
name|toRECT
argument_list|(
name|area
argument_list|)
argument_list|)
decl_stmt|;
name|pDrawThemeBackgroundEx
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|dc
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
operator|&
name|rect
argument_list|,
operator|&
name|drawOptions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Set the clip region, if used..
if|if
condition|(
name|addBorderContentClipping
condition|)
block|{
name|HRGN
name|hrgn
init|=
name|qt_hrgn_from_qregion
argument_list|(
name|extraClip
argument_list|)
decl_stmt|;
name|SelectClipRgn
argument_list|(
name|dc
argument_list|,
name|hrgn
argument_list|)
expr_stmt|;
comment|// Compensate for the noBorder area difference (noContent has the same area)
name|drawOptions
operator|.
name|rcClip
operator|=
name|themeData
operator|.
name|toRECT
argument_list|(
name|rect
operator|.
name|adjusted
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|dr
argument_list|,
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|DeleteObject
argument_list|(
name|hrgn
argument_list|)
expr_stmt|;
block|}
name|pDrawThemeBackground
argument_list|(
name|themeData
operator|.
name|handle
argument_list|()
argument_list|,
name|dc
argument_list|,
name|themeData
operator|.
name|partId
argument_list|,
name|themeData
operator|.
name|stateId
argument_list|,
operator|&
operator|(
name|drawOptions
operator|.
name|rcClip
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addBorderContentClipping
condition|)
name|SelectClipRgn
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// If not cached, analyze the buffer data to figure
comment|// out alpha type, and if it contains data
if|if
condition|(
operator|!
name|isCached
condition|)
block|{
if|if
condition|(
name|inspectData
condition|)
name|stateHasData
operator|=
name|hasAnyData
argument_list|(
name|rect
argument_list|)
expr_stmt|;
comment|// SHORTCUT: If the part's state has no data, cache it for NOOP later
if|if
condition|(
operator|!
name|stateHasData
condition|)
block|{
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|dataValid
operator|=
literal|true
expr_stmt|;
name|alphaCache
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|hasAlpha
operator|=
name|hasAlphaChannel
argument_list|(
name|rect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasAlpha
operator|&&
name|partIsTransparent
condition|)
name|potentialInvalidAlpha
operator|=
literal|true
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_XP_STYLE
argument_list|)
operator|&&
literal|1
name|dumpNativeDIB
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// Swap alpha values, if needed
if|if
condition|(
name|inspectData
condition|)
name|wasAlphaSwapped
operator|=
name|swapAlphaChannel
argument_list|(
name|rect
argument_list|)
expr_stmt|;
comment|// Fix alpha values, if needed
if|if
condition|(
name|potentialInvalidAlpha
condition|)
name|wasAlphaFixed
operator|=
name|fixAlphaChannel
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
if|if
condition|(
operator|(
name|partIsTransparent
operator|&&
operator|!
name|wasAlphaSwapped
operator|)
operator|||
operator|(
operator|!
name|partIsTransparent
operator|&&
name|hasAlpha
operator|)
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
name|alphaType
operator|=
name|RealAlpha
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasAlphaSwapped
condition|)
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
name|alphaType
operator|=
name|MaskAlpha
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
comment|// The image data we got from the theme engine does not have any transparency,
comment|// thus the alpha channel is set to 0.
comment|// However, Format_RGB32 requires the alpha part to be set to 0xff, thus
comment|// we must flip it from 0x00 to 0xff
name|swapAlphaChannel
argument_list|(
name|rect
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|alphaType
operator|=
name|NoAlpha
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_XP_STYLE
argument_list|)
operator|&&
literal|1
name|printf
argument_list|(
literal|"Image format is: %s\n"
argument_list|,
name|alphaType
operator|==
name|RealAlpha
condition|?
literal|"Real Alpha"
else|:
name|alphaType
operator|==
name|MaskAlpha
condition|?
literal|"Masked Alpha"
else|:
literal|"No Alpha"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|img
operator|=
name|QImage
argument_list|(
name|bufferPixels
argument_list|,
name|bufferW
argument_list|,
name|bufferH
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
comment|// Blitting backing store
name|bool
name|useRegion
init|=
name|partIsTransparent
operator|&&
operator|!
name|hasAlpha
operator|&&
operator|!
name|wasAlphaSwapped
decl_stmt|;
name|QRegion
name|newRegion
decl_stmt|;
name|QRegion
name|oldRegion
decl_stmt|;
if|if
condition|(
name|useRegion
condition|)
block|{
name|newRegion
operator|=
name|region
argument_list|(
name|themeData
argument_list|)
expr_stmt|;
name|oldRegion
operator|=
name|painter
operator|->
name|clipRegion
argument_list|()
expr_stmt|;
name|painter
operator|->
name|setClipRegion
argument_list|(
name|newRegion
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_XP_STYLE
argument_list|)
operator|&&
literal|0
name|printf
argument_list|(
literal|"Using region:\n"
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|newRegion
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRect
modifier|&
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"    (%d, %d, %d, %d)\n"
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|right
argument_list|()
argument_list|,
name|r
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|addBorderContentClipping
condition|)
name|painter
operator|->
name|setClipRegion
argument_list|(
name|extraClip
argument_list|,
name|Qt
operator|::
name|IntersectClip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|themeData
operator|.
name|mirrorHorizontally
operator|&&
operator|!
name|themeData
operator|.
name|mirrorVertically
operator|&&
operator|!
name|themeData
operator|.
name|rotate
condition|)
block|{
if|if
condition|(
operator|!
name|haveCachedPixmap
condition|)
name|painter
operator|->
name|drawImage
argument_list|(
name|themeData
operator|.
name|rect
argument_list|,
name|img
argument_list|,
name|rect
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|drawPixmap
argument_list|(
name|themeData
operator|.
name|rect
argument_list|,
name|cachedPixmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This is _slow_!
comment|// Make a copy containing only the necessary data, and mirror
comment|// on all wanted axes. Then draw the copy.
comment|// If cached, the normal pixmap is cached, instead of caching
comment|// all possible orientations for each part and state.
name|QImage
name|imgCopy
decl_stmt|;
if|if
condition|(
operator|!
name|haveCachedPixmap
condition|)
name|imgCopy
operator|=
name|img
operator|.
name|copy
argument_list|(
name|rect
argument_list|)
expr_stmt|;
else|else
name|imgCopy
operator|=
name|cachedPixmap
operator|.
name|toImage
argument_list|()
expr_stmt|;
if|if
condition|(
name|themeData
operator|.
name|rotate
condition|)
block|{
name|QMatrix
name|rotMatrix
decl_stmt|;
name|rotMatrix
operator|.
name|rotate
argument_list|(
name|themeData
operator|.
name|rotate
argument_list|)
expr_stmt|;
name|imgCopy
operator|=
name|imgCopy
operator|.
name|transformed
argument_list|(
name|rotMatrix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|themeData
operator|.
name|mirrorHorizontally
operator|||
name|themeData
operator|.
name|mirrorVertically
condition|)
block|{
name|imgCopy
operator|=
name|imgCopy
operator|.
name|mirrored
argument_list|(
name|themeData
operator|.
name|mirrorHorizontally
argument_list|,
name|themeData
operator|.
name|mirrorVertically
argument_list|)
expr_stmt|;
block|}
name|painter
operator|->
name|drawImage
argument_list|(
name|themeData
operator|.
name|rect
argument_list|,
name|imgCopy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useRegion
operator|||
name|addBorderContentClipping
condition|)
block|{
if|if
condition|(
name|oldRegion
operator|.
name|isEmpty
argument_list|()
condition|)
name|painter
operator|->
name|setClipping
argument_list|(
literal|false
argument_list|)
expr_stmt|;
else|else
name|painter
operator|->
name|setClipRegion
argument_list|(
name|oldRegion
argument_list|)
expr_stmt|;
block|}
comment|// Cache the pixmap to avoid expensive swapAlphaChannel() calls
if|if
condition|(
operator|!
name|haveCachedPixmap
operator|&&
name|w
operator|&&
name|h
condition|)
block|{
name|QPixmap
name|pix
init|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|img
argument_list|)
operator|.
name|copy
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|pixmapCacheKey
argument_list|,
name|pix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_XP_STYLE
name|printf
argument_list|(
literal|"+++Adding pixmap to cache, size(%d, %d), wasAlphaSwapped(%d), wasAlphaFixed(%d), name(%s)\n"
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|wasAlphaSwapped
argument_list|,
name|wasAlphaFixed
argument_list|,
name|qPrintable
argument_list|(
name|pixmapCacheKey
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// Add to theme part cache
if|if
condition|(
operator|!
name|isCached
condition|)
block|{
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|dataValid
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|partIsTransparent
operator|=
name|partIsTransparent
expr_stmt|;
name|data
operator|.
name|alphaType
operator|=
name|alphaType
expr_stmt|;
name|data
operator|.
name|hasAlphaChannel
operator|=
name|hasAlpha
expr_stmt|;
name|data
operator|.
name|hasAnyData
operator|=
name|stateHasData
expr_stmt|;
name|data
operator|.
name|wasAlphaSwapped
operator|=
name|wasAlphaSwapped
expr_stmt|;
name|data
operator|.
name|hadInvalidAlpha
operator|=
name|wasAlphaFixed
expr_stmt|;
name|alphaCache
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// ------------------------------------------------------------------------------------------------
end_comment
begin_comment
comment|/*!     \class QWindowsXPStyle     \brief The QWindowsXPStyle class provides a Microsoft Windows XP-like look and feel.      \ingroup appearance     \inmodule QtWidgets      \warning This style is only available on the Windows XP platform     because it makes use of Windows XP's style engine.      Most of the functions are documented in the base classes     QWindowsStyle, QCommonStyle, and QStyle, but the     QWindowsXPStyle overloads of drawComplexControl(), drawControl(),     drawControlMask(), drawPrimitive(), proxy()->subControlRect(), and     sizeFromContents(), are documented here.      \img qwindowsxpstyle.png     \sa QMacStyle, QWindowsStyle, QPlastiqueStyle, QCDEStyle, QMotifStyle */
end_comment
begin_comment
comment|/*!     Constructs a QWindowsStyle */
end_comment
begin_constructor
DECL|function|QWindowsXPStyle
name|QWindowsXPStyle
operator|::
name|QWindowsXPStyle
parameter_list|()
member_init_list|:
name|QWindowsStyle
argument_list|(
operator|*
operator|new
name|QWindowsXPStylePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the style. */
end_comment
begin_destructor
DECL|function|~QWindowsXPStyle
name|QWindowsXPStyle
operator|::
name|~
name|QWindowsXPStyle
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|unpolish
name|void
name|QWindowsXPStyle
operator|::
name|unpolish
parameter_list|(
name|QApplication
modifier|*
name|app
parameter_list|)
block|{
name|QWindowsStyle
operator|::
name|unpolish
argument_list|(
name|app
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|polish
name|void
name|QWindowsXPStyle
operator|::
name|polish
parameter_list|(
name|QApplication
modifier|*
name|app
parameter_list|)
block|{
name|QWindowsStyle
operator|::
name|polish
argument_list|(
name|app
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
condition|)
return|return;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|polish
name|void
name|QWindowsXPStyle
operator|::
name|polish
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|QWindowsStyle
operator|::
name|polish
argument_list|(
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
condition|)
return|return;
if|if
condition|(
name|qobject_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QToolButton
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QTabBar
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_COMBOBOX
operator|||
name|qobject_cast
argument_list|<
name|QComboBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
endif|#
directive|endif
comment|// QT_NO_COMBOBOX
operator|||
name|qobject_cast
argument_list|<
name|QScrollBar
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QSlider
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QHeaderView
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SPINBOX
operator|||
name|qobject_cast
argument_list|<
name|QAbstractSpinBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QSpinBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
endif|#
directive|endif
comment|// QT_NO_SPINBOX
condition|)
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|qobject_cast
argument_list|<
name|QRubberBand
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
block|{
name|widget
operator|->
name|setWindowOpacity
argument_list|(
literal|0.6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|qobject_cast
argument_list|<
name|QStackedWidget
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|&&
name|qobject_cast
argument_list|<
name|QTabWidget
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|parent
argument_list|()
argument_list|)
condition|)
name|widget
operator|->
name|parentWidget
argument_list|()
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_ContentsPropagated
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QWindowsXPStyle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|hasInitColors
condition|)
block|{
comment|// Get text color for group box labels
name|COLORREF
name|cref
decl_stmt|;
name|XPThemeData
name|theme
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QWindowsXPStylePrivate
operator|::
name|ButtonTheme
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|pGetThemeColor
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|BP_GROUPBOX
argument_list|,
name|GBS_NORMAL
argument_list|,
name|TMT_TEXTCOLOR
argument_list|,
operator|&
name|cref
argument_list|)
expr_stmt|;
name|d
operator|->
name|groupBoxTextColor
operator|=
name|qRgb
argument_list|(
name|GetRValue
argument_list|(
name|cref
argument_list|)
argument_list|,
name|GetGValue
argument_list|(
name|cref
argument_list|)
argument_list|,
name|GetBValue
argument_list|(
name|cref
argument_list|)
argument_list|)
expr_stmt|;
name|pGetThemeColor
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|BP_GROUPBOX
argument_list|,
name|GBS_DISABLED
argument_list|,
name|TMT_TEXTCOLOR
argument_list|,
operator|&
name|cref
argument_list|)
expr_stmt|;
name|d
operator|->
name|groupBoxTextColorDisabled
operator|=
name|qRgb
argument_list|(
name|GetRValue
argument_list|(
name|cref
argument_list|)
argument_list|,
name|GetGValue
argument_list|(
name|cref
argument_list|)
argument_list|,
name|GetBValue
argument_list|(
name|cref
argument_list|)
argument_list|)
expr_stmt|;
comment|// Where does this color come from?
comment|//pGetThemeColor(theme.handle(), TKP_TICS, TSS_NORMAL, TMT_COLOR,&cref);
name|d
operator|->
name|sliderTickColor
operator|=
name|qRgb
argument_list|(
literal|165
argument_list|,
literal|162
argument_list|,
literal|148
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasInitColors
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|polish
name|void
name|QWindowsXPStyle
operator|::
name|polish
parameter_list|(
name|QPalette
modifier|&
name|pal
parameter_list|)
block|{
name|QWindowsStyle
operator|::
name|polish
argument_list|(
name|pal
argument_list|)
expr_stmt|;
name|pal
operator|.
name|setBrush
argument_list|(
name|QPalette
operator|::
name|AlternateBase
argument_list|,
name|pal
operator|.
name|base
argument_list|()
operator|.
name|color
argument_list|()
operator|.
name|darker
argument_list|(
literal|110
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|unpolish
name|void
name|QWindowsXPStyle
operator|::
name|unpolish
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_RUBBERBAND
if|if
condition|(
name|qobject_cast
argument_list|<
name|QRubberBand
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
block|{
name|widget
operator|->
name|setWindowOpacity
argument_list|(
literal|1.0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Q_D
argument_list|(
name|QWindowsXPStyle
argument_list|)
expr_stmt|;
comment|// Unpolish of widgets is the first thing that
comment|// happens when a theme changes, or the theme
comment|// engine is turned off. So we detect it here.
name|bool
name|oldState
init|=
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
decl_stmt|;
name|bool
name|newState
init|=
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|oldState
operator|!=
name|newState
operator|)
operator|&&
name|newState
condition|)
block|{
name|d
operator|->
name|cleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Cleanup handle map, if just changing style,
comment|// or turning it on. In both cases the values
comment|// already in the map might be old (other style).
name|d
operator|->
name|cleanupHandleMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|qobject_cast
argument_list|<
name|QAbstractButton
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QToolButton
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QTabBar
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_COMBOBOX
operator|||
name|qobject_cast
argument_list|<
name|QComboBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
endif|#
directive|endif
comment|// QT_NO_COMBOBOX
operator|||
name|qobject_cast
argument_list|<
name|QScrollBar
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QSlider
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QHeaderView
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SPINBOX
operator|||
name|qobject_cast
argument_list|<
name|QAbstractSpinBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
operator|||
name|qobject_cast
argument_list|<
name|QSpinBox
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
endif|#
directive|endif
comment|// QT_NO_SPINBOX
condition|)
block|{
name|widget
operator|->
name|setAttribute
argument_list|(
name|Qt
operator|::
name|WA_Hover
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|QWindowsStyle
operator|::
name|unpolish
argument_list|(
name|widget
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|subElementRect
name|QRect
name|QWindowsXPStyle
operator|::
name|subElementRect
parameter_list|(
name|SubElement
name|sr
parameter_list|,
specifier|const
name|QStyleOption
modifier|*
name|option
parameter_list|,
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
condition|)
block|{
return|return
name|QWindowsStyle
operator|::
name|subElementRect
argument_list|(
name|sr
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
return|;
block|}
name|QRect
name|rect
argument_list|(
name|option
operator|->
name|rect
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sr
condition|)
block|{
case|case
name|SE_DockWidgetCloseButton
case|:
case|case
name|SE_DockWidgetFloatButton
case|:
name|rect
operator|=
name|QWindowsStyle
operator|::
name|subElementRect
argument_list|(
name|sr
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return
name|rect
operator|.
name|translated
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
return|;
break|break;
case|case
name|SE_TabWidgetTabContents
case|:
if|if
condition|(
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionTabWidgetFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|rect
operator|=
name|QWindowsStyle
operator|::
name|subElementRect
argument_list|(
name|sr
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|SE_TabWidgetTabContents
condition|)
block|{
if|if
condition|(
specifier|const
name|QTabWidget
modifier|*
name|tabWidget
init|=
name|qobject_cast
argument_list|<
specifier|const
name|QTabWidget
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
condition|)
block|{
if|if
condition|(
name|tabWidget
operator|->
name|documentMode
argument_list|()
condition|)
break|break;
block|}
name|rect
operator|.
name|adjust
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SE_TabWidgetTabBar
case|:
block|{
name|rect
operator|=
name|QWindowsStyle
operator|::
name|subElementRect
argument_list|(
name|sr
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
specifier|const
name|QStyleOptionTabWidgetFrame
modifier|*
name|twfOption
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionTabWidgetFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
decl_stmt|;
if|if
condition|(
name|twfOption
operator|&&
name|twfOption
operator|->
name|direction
operator|==
name|Qt
operator|::
name|RightToLeft
operator|&&
operator|(
name|twfOption
operator|->
name|shape
operator|==
name|QTabBar
operator|::
name|RoundedNorth
operator|||
name|twfOption
operator|->
name|shape
operator|==
name|QTabBar
operator|::
name|RoundedSouth
operator|)
condition|)
block|{
name|QStyleOptionTab
name|otherOption
decl_stmt|;
name|otherOption
operator|.
name|shape
operator|=
operator|(
name|twfOption
operator|->
name|shape
operator|==
name|QTabBar
operator|::
name|RoundedNorth
condition|?
name|QTabBar
operator|::
name|RoundedEast
else|:
name|QTabBar
operator|::
name|RoundedSouth
operator|)
expr_stmt|;
name|int
name|overlap
init|=
name|proxy
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|PM_TabBarBaseOverlap
argument_list|,
operator|&
name|otherOption
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|int
name|borderThickness
init|=
name|proxy
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|PM_DefaultFrameWidth
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|rect
operator|.
name|adjust
argument_list|(
operator|-
name|overlap
operator|+
name|borderThickness
argument_list|,
literal|0
argument_list|,
operator|-
name|overlap
operator|+
name|borderThickness
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SE_PushButtonContents
case|:
if|if
condition|(
specifier|const
name|QStyleOptionButton
modifier|*
name|btn
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionButton
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|MARGINS
name|borderSize
decl_stmt|;
if|if
condition|(
name|widget
condition|)
block|{
name|XPThemeData
name|buttontheme
argument_list|(
name|widget
argument_list|,
literal|0
argument_list|,
name|QWindowsXPStylePrivate
operator|::
name|ButtonTheme
argument_list|)
decl_stmt|;
name|HTHEME
name|theme
init|=
name|buttontheme
operator|.
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
name|theme
condition|)
block|{
name|int
name|stateId
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|option
operator|->
name|state
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|PBS_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|State_Sunken
condition|)
name|stateId
operator|=
name|PBS_PRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|PBS_HOT
expr_stmt|;
elseif|else
if|if
condition|(
name|btn
operator|->
name|features
operator|&
name|QStyleOptionButton
operator|::
name|DefaultButton
condition|)
name|stateId
operator|=
name|PBS_DEFAULTED
expr_stmt|;
else|else
name|stateId
operator|=
name|PBS_NORMAL
expr_stmt|;
name|int
name|border
init|=
name|proxy
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|PM_DefaultFrameWidth
argument_list|,
name|btn
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|rect
operator|=
name|option
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
name|border
argument_list|,
name|border
argument_list|,
operator|-
name|border
argument_list|,
operator|-
name|border
argument_list|)
expr_stmt|;
name|int
name|result
init|=
name|pGetThemeMargins
argument_list|(
name|theme
argument_list|,
name|NULL
argument_list|,
name|BP_PUSHBUTTON
argument_list|,
name|stateId
argument_list|,
name|TMT_CONTENTMARGINS
argument_list|,
name|NULL
argument_list|,
operator|&
name|borderSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|S_OK
condition|)
block|{
name|rect
operator|.
name|adjust
argument_list|(
name|borderSize
operator|.
name|cxLeftWidth
argument_list|,
name|borderSize
operator|.
name|cyTopHeight
argument_list|,
operator|-
name|borderSize
operator|.
name|cxRightWidth
argument_list|,
operator|-
name|borderSize
operator|.
name|cyBottomHeight
argument_list|)
expr_stmt|;
name|rect
operator|=
name|visualRect
argument_list|(
name|option
operator|->
name|direction
argument_list|,
name|option
operator|->
name|rect
argument_list|,
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|SE_ProgressBarContents
case|:
name|rect
operator|=
name|QCommonStyle
operator|::
name|subElementRect
argument_list|(
name|SE_ProgressBarGroove
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|state
operator|&
name|QStyle
operator|::
name|State_Horizontal
condition|)
name|rect
operator|.
name|adjust
argument_list|(
literal|4
argument_list|,
literal|3
argument_list|,
operator|-
literal|4
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
else|else
name|rect
operator|.
name|adjust
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
operator|-
literal|3
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rect
operator|=
name|QWindowsStyle
operator|::
name|subElementRect
argument_list|(
name|sr
argument_list|,
name|option
argument_list|,
name|widget
argument_list|)
expr_stmt|;
block|}
return|return
name|rect
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|drawPrimitive
name|void
name|QWindowsXPStyle
operator|::
name|drawPrimitive
parameter_list|(
name|PrimitiveElement
name|pe
parameter_list|,
specifier|const
name|QStyleOption
modifier|*
name|option
parameter_list|,
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|QWindowsXPStylePrivate
modifier|*
name|d
init|=
cast|const_cast
argument_list|<
name|QWindowsXPStylePrivate
operator|*
argument_list|>
argument_list|(
name|d_func
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QWindowsXPStylePrivate
operator|::
name|useXP
argument_list|()
condition|)
block|{
name|QWindowsStyle
operator|::
name|drawPrimitive
argument_list|(
name|pe
argument_list|,
name|option
argument_list|,
name|p
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|themeNumber
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|partId
init|=
literal|0
decl_stmt|;
name|int
name|stateId
init|=
literal|0
decl_stmt|;
name|QRect
name|rect
init|=
name|option
operator|->
name|rect
decl_stmt|;
name|State
name|flags
init|=
name|option
operator|->
name|state
decl_stmt|;
name|bool
name|hMirrored
init|=
literal|false
decl_stmt|;
name|bool
name|vMirrored
init|=
literal|false
decl_stmt|;
name|bool
name|noBorder
init|=
literal|false
decl_stmt|;
name|bool
name|noContent
init|=
literal|false
decl_stmt|;
name|int
name|rotate
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pe
condition|)
block|{
case|case
name|PE_FrameTabBarBase
case|:
if|if
condition|(
specifier|const
name|QStyleOptionTabBarBase
modifier|*
name|tbb
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionTabBarBase
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|tbb
operator|->
name|shape
condition|)
block|{
case|case
name|QTabBar
operator|::
name|RoundedNorth
case|:
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|tbb
operator|->
name|palette
operator|.
name|dark
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|tbb
operator|->
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|RoundedWest
case|:
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|tbb
operator|->
name|palette
operator|.
name|dark
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|tbb
operator|->
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|bottom
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|RoundedSouth
case|:
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|tbb
operator|->
name|palette
operator|.
name|dark
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|tbb
operator|->
name|rect
operator|.
name|left
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|top
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|right
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|top
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|RoundedEast
case|:
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|tbb
operator|->
name|palette
operator|.
name|dark
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawLine
argument_list|(
name|tbb
operator|->
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|,
name|tbb
operator|->
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|TriangularNorth
case|:
case|case
name|QTabBar
operator|::
name|TriangularEast
case|:
case|case
name|QTabBar
operator|::
name|TriangularWest
case|:
case|case
name|QTabBar
operator|::
name|TriangularSouth
case|:
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
name|QWindowsStyle
operator|::
name|drawPrimitive
argument_list|(
name|pe
argument_list|,
name|option
argument_list|,
name|p
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
name|PE_PanelButtonBevel
case|:
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ButtonTheme
expr_stmt|;
name|partId
operator|=
name|BP_PUSHBUTTON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|PBS_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|State_Sunken
operator|)
operator|||
operator|(
name|flags
operator|&
name|State_On
operator|)
condition|)
name|stateId
operator|=
name|PBS_PRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|PBS_HOT
expr_stmt|;
comment|//else if (flags& State_ButtonDefault)
comment|//    stateId = PBS_DEFAULTED;
else|else
name|stateId
operator|=
name|PBS_NORMAL
expr_stmt|;
break|break;
case|case
name|PE_PanelButtonTool
case|:
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|inherits
argument_list|(
literal|"QDockWidgetTitleButton"
argument_list|)
condition|)
block|{
if|if
condition|(
specifier|const
name|QWidget
modifier|*
name|dw
init|=
name|widget
operator|->
name|parentWidget
argument_list|()
condition|)
if|if
condition|(
name|dw
operator|->
name|isWindow
argument_list|()
condition|)
return|return;
block|}
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ToolBarTheme
expr_stmt|;
name|partId
operator|=
name|TP_BUTTON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|TS_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_Sunken
condition|)
name|stateId
operator|=
name|TS_PRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|flags
operator|&
name|State_On
condition|?
name|TS_HOTCHECKED
else|:
name|TS_HOT
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_On
condition|)
name|stateId
operator|=
name|TS_CHECKED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_AutoRaise
operator|)
condition|)
name|stateId
operator|=
name|TS_HOT
expr_stmt|;
else|else
name|stateId
operator|=
name|TS_NORMAL
expr_stmt|;
break|break;
case|case
name|PE_IndicatorButtonDropDown
case|:
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ToolBarTheme
expr_stmt|;
name|partId
operator|=
name|TP_SPLITBUTTONDROPDOWN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|TS_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_Sunken
condition|)
name|stateId
operator|=
name|TS_PRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|flags
operator|&
name|State_On
condition|?
name|TS_HOTCHECKED
else|:
name|TS_HOT
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_On
condition|)
name|stateId
operator|=
name|TS_CHECKED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_AutoRaise
operator|)
condition|)
name|stateId
operator|=
name|TS_HOT
expr_stmt|;
else|else
name|stateId
operator|=
name|TS_NORMAL
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|direction
operator|==
name|Qt
operator|::
name|RightToLeft
condition|)
name|hMirrored
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|PE_IndicatorCheckBox
case|:
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ButtonTheme
expr_stmt|;
name|partId
operator|=
name|BP_CHECKBOX
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|CBS_UNCHECKEDDISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_Sunken
condition|)
name|stateId
operator|=
name|CBS_UNCHECKEDPRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|CBS_UNCHECKEDHOT
expr_stmt|;
else|else
name|stateId
operator|=
name|CBS_UNCHECKEDNORMAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|State_On
condition|)
name|stateId
operator|+=
name|CBS_CHECKEDNORMAL
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_NoChange
condition|)
name|stateId
operator|+=
name|CBS_MIXEDNORMAL
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PE_IndicatorRadioButton
case|:
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ButtonTheme
expr_stmt|;
name|partId
operator|=
name|BP_RADIOBUTTON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|RBS_UNCHECKEDDISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_Sunken
condition|)
name|stateId
operator|=
name|RBS_UNCHECKEDPRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|State_MouseOver
condition|)
name|stateId
operator|=
name|RBS_UNCHECKEDHOT
expr_stmt|;
else|else
name|stateId
operator|=
name|RBS_UNCHECKEDNORMAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|State_On
condition|)
name|stateId
operator|+=
name|RBS_CHECKEDNORMAL
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|PE_IndicatorDockWidgetResizeHandle
case|:
return|return;
case|case
name|PE_Frame
case|:
block|{
if|if
condition|(
name|flags
operator|&
name|State_Raised
condition|)
return|return;
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|ListViewTheme
expr_stmt|;
name|partId
operator|=
name|LVP_LISTGROUP
expr_stmt|;
name|XPThemeData
name|theme
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|themeNumber
argument_list|,
name|partId
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|ETS_DISABLED
expr_stmt|;
else|else
name|stateId
operator|=
name|ETS_NORMAL
expr_stmt|;
name|int
name|fillType
decl_stmt|;
if|if
condition|(
name|pGetThemeEnumValue
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|TMT_BGTYPE
argument_list|,
operator|&
name|fillType
argument_list|)
operator|==
name|S_OK
condition|)
block|{
if|if
condition|(
name|fillType
operator|==
name|BT_BORDERFILL
condition|)
block|{
name|COLORREF
name|bcRef
decl_stmt|;
name|pGetThemeColor
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|TMT_BORDERCOLOR
argument_list|,
operator|&
name|bcRef
argument_list|)
expr_stmt|;
name|QColor
name|bordercolor
argument_list|(
name|qRgb
argument_list|(
name|GetRValue
argument_list|(
name|bcRef
argument_list|)
argument_list|,
name|GetGValue
argument_list|(
name|bcRef
argument_list|)
argument_list|,
name|GetBValue
argument_list|(
name|bcRef
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
comment|// int borderSize = 1;
comment|// pGetThemeInt(theme.handle(), partId, stateId, TMT_BORDERCOLOR,&borderSize);
comment|// Inner white border
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|option
operator|->
name|palette
operator|.
name|base
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|option
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Outer dark border
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|bordercolor
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|option
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|fillType
operator|==
name|BT_NONE
condition|)
block|{
return|return;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
case|case
name|PE_FrameLineEdit
case|:
block|{
comment|// we try to check if this lineedit is a delegate on a QAbstractItemView-derived class.
name|QWidget
modifier|*
name|parentWidget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|widget
condition|)
name|parentWidget
operator|=
name|widget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|parentWidget
condition|)
name|parentWidget
operator|=
name|parentWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
if|if
condition|(
name|widget
operator|&&
name|widget
operator|->
name|inherits
argument_list|(
literal|"QLineEdit"
argument_list|)
operator|&&
name|parentWidget
operator|&&
name|parentWidget
operator|->
name|inherits
argument_list|(
literal|"QAbstractItemView"
argument_list|)
condition|)
block|{
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
comment|// Inner white border
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|option
operator|->
name|palette
operator|.
name|base
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|option
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Outer dark border
name|p
operator|->
name|setPen
argument_list|(
name|QPen
argument_list|(
name|option
operator|->
name|palette
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|option
operator|->
name|rect
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|EditTheme
expr_stmt|;
name|partId
operator|=
name|EP_EDITTEXT
expr_stmt|;
name|noContent
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|State_Enabled
operator|)
condition|)
name|stateId
operator|=
name|ETS_DISABLED
expr_stmt|;
else|else
name|stateId
operator|=
name|ETS_NORMAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|PE_PanelLineEdit
case|:
if|if
condition|(
specifier|const
name|QStyleOptionFrame
modifier|*
name|panel
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|EditTheme
expr_stmt|;
name|partId
operator|=
name|EP_EDITTEXT
expr_stmt|;
name|noBorder
operator|=
literal|true
expr_stmt|;
name|QBrush
name|bg
decl_stmt|;
name|bool
name|usePalette
init|=
literal|false
decl_stmt|;
name|bool
name|isEnabled
init|=
name|flags
operator|&
name|State_Enabled
decl_stmt|;
name|uint
name|resolve_mask
init|=
name|panel
operator|->
name|palette
operator|.
name|resolve
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SPINBOX
comment|// Since spin box includes a line edit we need to resolve the palette mask also from
comment|// the parent, as while the color is always correct on the palette supplied by panel,
comment|// the mask can still be empty. If either mask specifies custom base color, use that.
if|if
condition|(
name|widget
condition|)
block|{
if|if
condition|(
name|QAbstractSpinBox
modifier|*
name|spinbox
init|=
name|qobject_cast
argument_list|<
name|QAbstractSpinBox
operator|*
argument_list|>
argument_list|(
name|widget
operator|->
name|parentWidget
argument_list|()
argument_list|)
condition|)
name|resolve_mask
operator||=
name|spinbox
operator|->
name|palette
argument_list|()
operator|.
name|resolve
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_SPINBOX
if|if
condition|(
name|resolve_mask
operator|&
operator|(
literal|1
operator|<<
name|QPalette
operator|::
name|Base
operator|)
condition|)
block|{
comment|// Base color is set for this widget, so use it
name|bg
operator|=
name|panel
operator|->
name|palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
expr_stmt|;
name|usePalette
operator|=
literal|true
expr_stmt|;
block|}
name|stateId
operator|=
name|isEnabled
condition|?
name|ETS_NORMAL
else|:
name|ETS_DISABLED
expr_stmt|;
if|if
condition|(
name|usePalette
condition|)
block|{
name|p
operator|->
name|fillRect
argument_list|(
name|panel
operator|->
name|rect
argument_list|,
name|bg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XPThemeData
name|theme
argument_list|(
literal|0
argument_list|,
name|p
argument_list|,
name|themeNumber
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|theme
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QWindowsStyle
operator|::
name|drawPrimitive
argument_list|(
name|pe
argument_list|,
name|option
argument_list|,
name|p
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|bgType
decl_stmt|;
name|pGetThemeEnumValue
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|TMT_BGTYPE
argument_list|,
operator|&
name|bgType
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgType
operator|==
name|BT_IMAGEFILE
condition|)
block|{
name|theme
operator|.
name|mirrorHorizontally
operator|=
name|hMirrored
expr_stmt|;
name|theme
operator|.
name|mirrorVertically
operator|=
name|vMirrored
expr_stmt|;
name|theme
operator|.
name|noBorder
operator|=
name|noBorder
expr_stmt|;
name|theme
operator|.
name|noContent
operator|=
name|noContent
expr_stmt|;
name|theme
operator|.
name|rotate
operator|=
name|rotate
expr_stmt|;
name|d
operator|->
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBrush
name|fillColor
init|=
name|option
operator|->
name|palette
operator|.
name|brush
argument_list|(
name|QPalette
operator|::
name|Base
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
name|PROPERTYORIGIN
name|origin
init|=
name|PO_NOTFOUND
decl_stmt|;
name|pGetThemePropertyOrigin
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|theme
operator|.
name|partId
argument_list|,
name|theme
operator|.
name|stateId
argument_list|,
name|TMT_FILLCOLOR
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
comment|// Use only if the fill property comes from our part
if|if
condition|(
operator|(
name|origin
operator|==
name|PO_PART
operator|||
name|origin
operator|==
name|PO_STATE
operator|)
condition|)
block|{
name|COLORREF
name|bgRef
decl_stmt|;
name|pGetThemeColor
argument_list|(
name|theme
operator|.
name|handle
argument_list|()
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|TMT_FILLCOLOR
argument_list|,
operator|&
name|bgRef
argument_list|)
expr_stmt|;
name|fillColor
operator|=
name|QBrush
argument_list|(
name|qRgb
argument_list|(
name|GetRValue
argument_list|(
name|bgRef
argument_list|)
argument_list|,
name|GetGValue
argument_list|(
name|bgRef
argument_list|)
argument_list|,
name|GetBValue
argument_list|(
name|bgRef
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|fillRect
argument_list|(
name|option
operator|->
name|rect
argument_list|,
name|fillColor
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|panel
operator|->
name|lineWidth
operator|>
literal|0
condition|)
name|proxy
argument_list|()
operator|->
name|drawPrimitive
argument_list|(
name|PE_FrameLineEdit
argument_list|,
name|panel
argument_list|,
name|p
argument_list|,
name|widget
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PE_FrameTabWidget
case|:
if|if
condition|(
specifier|const
name|QStyleOptionTabWidgetFrame
modifier|*
name|tab
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionTabWidgetFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|TabTheme
expr_stmt|;
name|partId
operator|=
name|TABP_PANE
expr_stmt|;
if|if
condition|(
name|widget
condition|)
block|{
name|bool
name|useGradient
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|maxlength
init|=
literal|256
decl_stmt|;
name|wchar_t
name|themeFileName
index|[
name|maxlength
index|]
decl_stmt|;
name|wchar_t
name|themeColor
index|[
name|maxlength
index|]
decl_stmt|;
comment|// Due to a a scaling issue with the XP Silver theme, tab gradients are not used with it
if|if
condition|(
name|pGetCurrentThemeName
argument_list|(
name|themeFileName
argument_list|,
name|maxlength
argument_list|,
name|themeColor
argument_list|,
name|maxlength
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|S_OK
condition|)
block|{
name|wchar_t
modifier|*
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|=
name|wcsrchr
argument_list|(
name|themeFileName
argument_list|,
name|QChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
operator|.
name|unicode
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|offset
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|lstrcmp
argument_list|(
name|offset
argument_list|,
literal|L"Luna.msstyles"
argument_list|)
operator|&&
operator|!
name|lstrcmp
argument_list|(
name|offset
argument_list|,
literal|L"Metallic"
argument_list|)
condition|)
block|{
name|useGradient
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// This should work, but currently there's an error in the ::drawBackgroundDirectly()
comment|// code, when using the HDC directly..
if|if
condition|(
name|useGradient
condition|)
block|{
name|QStyleOptionTabWidgetFrameV2
name|frameOpt
init|=
operator|*
name|tab
decl_stmt|;
name|frameOpt
operator|.
name|rect
operator|=
name|widget
operator|->
name|rect
argument_list|()
expr_stmt|;
name|QRect
name|contentsRect
init|=
name|subElementRect
argument_list|(
name|SE_TabWidgetTabContents
argument_list|,
operator|&
name|frameOpt
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|QRegion
name|reg
init|=
name|option
operator|->
name|rect
decl_stmt|;
name|reg
operator|-=
name|contentsRect
expr_stmt|;
name|p
operator|->
name|setClipRegion
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|XPThemeData
name|theme
argument_list|(
name|widget
argument_list|,
name|p
argument_list|,
name|themeNumber
argument_list|,
name|partId
argument_list|,
name|stateId
argument_list|,
name|rect
argument_list|)
decl_stmt|;
name|theme
operator|.
name|mirrorHorizontally
operator|=
name|hMirrored
expr_stmt|;
name|theme
operator|.
name|mirrorVertically
operator|=
name|vMirrored
expr_stmt|;
name|d
operator|->
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
name|p
operator|->
name|setClipRect
argument_list|(
name|contentsRect
argument_list|)
expr_stmt|;
name|partId
operator|=
name|TABP_BODY
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|tab
operator|->
name|shape
condition|)
block|{
case|case
name|QTabBar
operator|::
name|RoundedNorth
case|:
case|case
name|QTabBar
operator|::
name|TriangularNorth
case|:
break|break;
case|case
name|QTabBar
operator|::
name|RoundedSouth
case|:
case|case
name|QTabBar
operator|::
name|TriangularSouth
case|:
name|vMirrored
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|RoundedEast
case|:
case|case
name|QTabBar
operator|::
name|TriangularEast
case|:
name|rotate
operator|=
literal|90
expr_stmt|;
break|break;
case|case
name|QTabBar
operator|::
name|RoundedWest
case|:
case|case
name|QTabBar
operator|::
name|TriangularWest
case|:
name|rotate
operator|=
literal|90
expr_stmt|;
name|hMirrored
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|PE_FrameMenu
case|:
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|option
operator|->
name|palette
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|rect
operator|.
name|adjusted
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
return|return;
case|case
name|PE_PanelMenuBar
case|:
break|break;
case|case
name|PE_FrameDockWidget
case|:
if|if
condition|(
specifier|const
name|QStyleOptionFrame
modifier|*
name|frm
init|=
name|qstyleoption_cast
argument_list|<
specifier|const
name|QStyleOptionFrame
operator|*
argument_list|>
argument_list|(
name|option
argument_list|)
condition|)
block|{
name|themeNumber
operator|=
name|QWindowsXPStylePrivate
operator|::
name|WindowTheme
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|State_Active
condition|)
name|stateId
operator|=
name|FS_ACTIVE
expr_stmt|;
else|else
name|stateId
operator|=
name|FS_INACTIVE
expr_stmt|;
name|int
name|fwidth
init|=
name|proxy
argument_list|()
operator|->
name|pixelMetric
argument_list|(
name|PM_DockWidgetFrameWidth
argument_list|,
name|frm
argument_list|,
name|widget
argument_list|)
decl_stmt|;
name|XPThemeData
name|theme
argument_list|(
name|widget
argument_list|,
name|p
argument_list|,
name|themeNumber
argument_list|,
literal|0
argument_list|,
name|stateId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|theme
operator|.
name|isValid
argument_list|()
condition|)
break|break;
name|theme
operator|.
name|rect
operator|=
name|QRect
argument_list|(
name|frm
operator|->
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|x
argument_list|()
operator|+
name|fwidth
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|height
argument_list|()
operator|-
name|fwidth
argument_list|)
expr_stmt|;
name|theme
operator|.
name|partId
operator|=
name|WP_SMALLFRAMELEFT
expr_stmt|;
name|d
operator|->
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
name|theme
operator|.
name|rect
operator|=
name|QRect
argument_list|(
name|frm
operator|->
name|rect
operator|.
name|width
argument_list|()
operator|-
name|fwidth
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|fwidth
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|height
argument_list|()
operator|-
name|fwidth
argument_list|)
expr_stmt|;
name|theme
operator|.
name|partId
operator|=
name|WP_SMALLFRAMERIGHT
expr_stmt|;
name|d
operator|->
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
name|theme
operator|.
name|rect
operator|=
name|QRect
argument_list|(
name|frm
operator|->
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|bottom
argument_list|()
operator|-
name|fwidth
operator|+
literal|1
argument_list|,
name|frm
operator|->
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|fwidth
argument_list|)
expr_stmt|;
name|theme
operator|.
name|partId
operator|=
name|WP_SMALLFRAMEBOTTOM
expr_stmt|;
name|d
operator|->
name|drawBackground
argument_list|(
name|theme
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PE_IndicatorHeaderArrow
case|:
block|{
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// XP theme engine doesn't know about this :(
end_comment
unit|name = QWindowsXPStylePrivate::HEADER");             partId = HP_HEADERSORTARROW;             if (flags& State_Down)                 stateId = HSAS_SORTEDDOWN;             else                 stateId = HSAS_SORTEDUP; #else             if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {                 p->save();                 p->setPen(option->palette.dark().color());                 p->translate(0, option->rect.height()/2 - 4);                 if (header->sortIndicator& QStyleOptionHeader::SortUp) { // invert logic to follow Windows style guide                     p->drawLine(option->rect.x(), option->rect.y(), option->rect.x()+8, option->rect.y());                     p->drawLine(option->rect.x()+1, option->rect.y()+1, option->rect.x()+7, option->rect.y()+1);                     p->drawLine(option->rect.x()+2, option->rect.y()+2, option->rect.x()+6, option->rect.y()+2);                     p->drawLine(option->rect.x()+3, option->rect.y()+3, option->rect.x()+5, option->rect.y()+3);                     p->drawPoint(option->rect.x()+4, option->rect.y()+4);                 } else if(header->sortIndicator& QStyleOptionHeader::SortDown) {                     p->drawLine(option->rect.x(), option->rect.y()+4, option->rect.x()+8, option->rect.y()+4);                     p->drawLine(option->rect.x()+1, option->rect.y()+3, option->rect.x()+7, option->rect.y()+3);                     p->drawLine(option->rect.x()+2, option->rect.y()+2, option->rect.x()+6, option->rect.y()+2);                     p->drawLine(option->rect.x()+3, option->rect.y()+1, option->rect.x()+5, option->rect.y()+1);                     p->drawPoint(option->rect.x()+4, option->rect.y());                 }                 p->restore();                 return;             } #endif         }         break;      case PE_FrameStatusBarItem:         themeNumber = QWindowsXPStylePrivate::StatusTheme;         partId = SP_PANE;         break;      case PE_FrameGroupBox:         themeNumber = QWindowsXPStylePrivate::ButtonTheme;         partId = BP_GROUPBOX;         if (!(flags& State_Enabled))             stateId = GBS_DISABLED;         else             stateId = GBS_NORMAL;         if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(option)) {             const QStyleOptionFrameV2 *frame2 = qstyleoption_cast<const QStyleOptionFrameV2 *>(option);             if (frame2->features& QStyleOptionFrameV2::Flat) {                 // Windows XP does not have a theme part for a flat GroupBox, paint it with the windows style                 QRect fr = frame->rect;                 QPoint p1(fr.x(), fr.y() + 1);                 QPoint p2(fr.x() + fr.width(), p1.y() + 1);                 rect = QRect(p1, p2);                 themeNumber = -1;             }         }         break;      case PE_IndicatorProgressChunk:         {         Qt::Orientation orient = Qt::Horizontal;         bool inverted = false;         if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {             orient = pb2->orientation;             if (pb2->invertedAppearance)                 inverted = true;         }         if (orient == Qt::Horizontal) {             partId = PP_CHUNK;             rect = QRect(option->rect.x(), option->rect.y(), option->rect.width(), option->rect.height() );             if (inverted&& option->direction == Qt::LeftToRight)                 hMirrored = true;         } else {             partId = PP_CHUNKVERT;             rect = QRect(option->rect.x(), option->rect.y(), option->rect.width(), option->rect.height());         }         themeNumber = QWindowsXPStylePrivate::ProgressTheme;         stateId = 1;         }         break;      case PE_FrameWindow:         if (const QStyleOptionFrame *frm = qstyleoption_cast<const QStyleOptionFrame *>(option))         {             themeNumber = QWindowsXPStylePrivate::WindowTheme;             if (flags& State_Active)                 stateId = FS_ACTIVE;             else                 stateId = FS_INACTIVE;              int fwidth = frm->lineWidth + frm->midLineWidth;              XPThemeData theme(0, p, themeNumber, 0, stateId);             if (!theme.isValid())                 break;              theme.rect = QRect(option->rect.x(), option->rect.y()+fwidth, option->rect.x()+fwidth, option->rect.height()-fwidth);             theme.partId = WP_FRAMELEFT;             d->drawBackground(theme);             theme.rect = QRect(option->rect.width()-fwidth, option->rect.y()+fwidth, fwidth, option->rect.height()-fwidth);             theme.partId = WP_FRAMERIGHT;             d->drawBackground(theme);             theme.rect = QRect(option->rect.x(), option->rect.height()-fwidth, option->rect.width(), fwidth);             theme.partId = WP_FRAMEBOTTOM;             d->drawBackground(theme);             theme.rect = QRect(option->rect.x(), option->rect.y(), option->rect.width(), option->rect.y()+fwidth);             theme.partId = WP_CAPTION;             d->drawBackground(theme);             return;         }         break;      case PE_IndicatorBranch:         {             static const int decoration_size = 9;             int mid_h = option->rect.x() + option->rect.width() / 2;             int mid_v = option->rect.y() + option->rect.height() / 2;             int bef_h = mid_h;             int bef_v = mid_v;             int aft_h = mid_h;             int aft_v = mid_v;             QBrush brush(option->palette.dark().color(), Qt::Dense4Pattern);             if (option->state& State_Item) {                 if (option->direction == Qt::RightToLeft)                     p->fillRect(option->rect.left(), mid_v, bef_h - option->rect.left(), 1, brush);                 else                     p->fillRect(aft_h, mid_v, option->rect.right() - aft_h + 1, 1, brush);             }             if (option->state& State_Sibling)                 p->fillRect(mid_h, aft_v, 1, option->rect.bottom() - aft_v + 1, brush);             if (option->state& (State_Open | State_Children | State_Item | State_Sibling))                 p->fillRect(mid_h, option->rect.y(), 1, bef_v - option->rect.y(), brush);             if (option->state& State_Children) {                 int delta = decoration_size / 2;                 bef_h -= delta;                 bef_v -= delta;                 aft_h += delta;                 aft_v += delta;                 XPThemeData theme(0, p, QWindowsXPStylePrivate::TreeViewTheme);                 theme.rect = QRect(bef_h, bef_v, decoration_size, decoration_size);                 theme.partId = TVP_GLYPH;                 theme.stateId = flags& QStyle::State_Open ? GLPS_OPENED : GLPS_CLOSED;                 d->drawBackground(theme);             }         }         return;      case PE_IndicatorToolBarSeparator:         if (option->rect.height()< 3) {             // XP style requires a few pixels for the separator             // to be visible.             QWindowsStyle::drawPrimitive(pe, option, p, widget);             return;         }         themeNumber = QWindowsXPStylePrivate::ToolBarTheme;         partId = TP_SEPARATOR;          if (option->state& State_Horizontal)             partId = TP_SEPARATOR;         else             partId = TP_SEPARATORVERT;          break;      case PE_IndicatorToolBarHandle:          themeNumber = QWindowsXPStylePrivate::RebarTheme;         partId = RP_GRIPPER;         if (option->state& State_Horizontal) {             partId = RP_GRIPPER;             rect.adjust(0, 0, -2, 0);         }         else {             partId = RP_GRIPPERVERT;             rect.adjust(0, 0, 0, -2);         }         break;      case PE_IndicatorItemViewItemCheck: {         QStyleOptionButton button;         button.QStyleOption::operator=(*option);         button.state&= ~State_MouseOver;         proxy()->drawPrimitive(PE_IndicatorCheckBox,&button, p, widget);         return;     }      default:         break;     }      XPThemeData theme(0, p, themeNumber, partId, stateId, rect);     if (!theme.isValid()) {         QWindowsStyle::drawPrimitive(pe, option, p, widget);         return;     }     theme.mirrorHorizontally = hMirrored;     theme.mirrorVertically = vMirrored;     theme.noBorder = noBorder;     theme.noContent = noContent;     theme.rotate = rotate;     d->drawBackground(theme); }  /*!     \reimp */ void QWindowsXPStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *p,                                   const QWidget *widget) const {   QWindowsXPStylePrivate *d = const_cast<QWindowsXPStylePrivate*>(d_func());     if (!QWindowsXPStylePrivate::useXP()) {         QWindowsStyle::drawControl(element, option, p, widget);         return;     }      QRect rect(option->rect);     State flags = option->state;      int rotate = 0;     bool hMirrored = false;     bool vMirrored = false;      int themeNumber = -1;     int partId = 0;     int stateId = 0;     switch (element) {     case CE_SizeGrip:         {             themeNumber = QWindowsXPStylePrivate::StatusTheme;             partId = SP_GRIPPER;             SIZE sz;             XPThemeData theme(0, p, themeNumber, partId, 0);             pGetThemePartSize(theme.handle(), 0, partId, 0, 0, TS_TRUE,&sz);             --sz.cy;             if (const QStyleOptionSizeGrip *sg = qstyleoption_cast<const QStyleOptionSizeGrip *>(option)) {                 switch (sg->corner) {                     case Qt::BottomRightCorner:                         rect = QRect(rect.right() - sz.cx, rect.bottom() - sz.cy, sz.cx, sz.cy);                         break;                     case Qt::BottomLeftCorner:                         rect = QRect(rect.left() + 1, rect.bottom() - sz.cy, sz.cx, sz.cy);                         hMirrored = true;                         break;                     case Qt::TopRightCorner:                         rect = QRect(rect.right() - sz.cx, rect.top() + 1, sz.cx, sz.cy);                         vMirrored = true;                         break;                     case Qt::TopLeftCorner:                         rect = QRect(rect.left() + 1, rect.top() + 1, sz.cx, sz.cy);                         hMirrored = vMirrored = true;                 }             }         }         break;      case CE_HeaderSection:         themeNumber = QWindowsXPStylePrivate::HeaderTheme;         partId = HP_HEADERITEM;         if (flags& State_Sunken)             stateId = HIS_PRESSED;         else if (flags& State_MouseOver)             stateId = HIS_HOT;         else             stateId = HIS_NORMAL;         break;      case CE_Splitter:         p->eraseRect(option->rect);         return;      case CE_PushButtonBevel:         if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option))         {             themeNumber = QWindowsXPStylePrivate::ButtonTheme;             partId = BP_PUSHBUTTON;             bool justFlat = ((btn->features& QStyleOptionButton::Flat)&& !(flags& (State_On|State_Sunken)))                 || ((btn->features& QStyleOptionButton::CommandLinkButton)&& !(flags& State_MouseOver)&& !(btn->features& QStyleOptionButton::DefaultButton));             if (!(flags& State_Enabled)&& !(btn->features& QStyleOptionButton::Flat))                 stateId = PBS_DISABLED;             else if (justFlat)                 ;             else if (flags& (State_Sunken | State_On))                 stateId = PBS_PRESSED;             else if (flags& State_MouseOver)                 stateId = PBS_HOT;             else if (btn->features& QStyleOptionButton::DefaultButton)                 stateId = PBS_DEFAULTED;             else                 stateId = PBS_NORMAL;              if (!justFlat) {                 XPThemeData theme(widget, p, themeNumber, partId, stateId, rect);                 d->drawBackground(theme);             }              if (btn->features& QStyleOptionButton::HasMenu) {                 int mbiw = 0, mbih = 0;                 XPThemeData theme(widget, 0,                                   QWindowsXPStylePrivate::ToolBarTheme,                                   TP_SPLITBUTTONDROPDOWN);                 if (theme.isValid()) {                     SIZE size;                     pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                     mbiw = size.cx;                     mbih = size.cy;                 }                  QRect ir = btn->rect;                 QStyleOptionButton newBtn = *btn;                 newBtn.rect = QRect(ir.right() - mbiw - 1, 1 + (ir.height()/2) - (mbih/2), mbiw, mbih);                 proxy()->drawPrimitive(PE_IndicatorArrowDown,&newBtn, p, widget);             }             return;         }         break;     case CE_TabBarTab:         if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option))         {             stateId = tab->state& State_Enabled ? TIS_NORMAL : TIS_DISABLED;         }     break;      case CE_TabBarTabShape:         if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option))         {             themeNumber = QWindowsXPStylePrivate::TabTheme;             bool isDisabled = !(tab->state& State_Enabled);             bool hasFocus = tab->state& State_HasFocus;             bool isHot = tab->state& State_MouseOver;             bool selected = tab->state& State_Selected;             bool lastTab = tab->position == QStyleOptionTab::End;             bool firstTab = tab->position == QStyleOptionTab::Beginning;             bool onlyOne = tab->position == QStyleOptionTab::OnlyOneTab;             bool leftAligned = proxy()->styleHint(SH_TabBar_Alignment, tab, widget) == Qt::AlignLeft;             bool centerAligned = proxy()->styleHint(SH_TabBar_Alignment, tab, widget) == Qt::AlignCenter;             int borderThickness = proxy()->pixelMetric(PM_DefaultFrameWidth, option, widget);             int tabOverlap = proxy()->pixelMetric(PM_TabBarTabOverlap, option, widget);              if (isDisabled)                 stateId = TIS_DISABLED;             else if (selected)                 stateId = TIS_SELECTED;             else if (hasFocus)                 stateId = TIS_FOCUSED;             else if (isHot)                 stateId = TIS_HOT;             else                 stateId = TIS_NORMAL;              // Selecting proper part depending on position             if (firstTab || onlyOne) {                 if (leftAligned) {                     partId = TABP_TABITEMLEFTEDGE;                 } else if (centerAligned) {                     partId = TABP_TABITEM;                 } else { // rightAligned                     partId = TABP_TABITEMRIGHTEDGE;                 }             } else {                 partId = TABP_TABITEM;             }              if (tab->direction == Qt::RightToLeft&& (tab->shape == QTabBar::RoundedNorth                     || tab->shape == QTabBar::RoundedSouth)) {                 bool temp = firstTab;                 firstTab = lastTab;                 lastTab = temp;             }             bool begin = firstTab || onlyOne;             bool end = lastTab || onlyOne;             switch (tab->shape) {             case QTabBar::RoundedNorth:                 if (selected)                     rect.adjust(begin ? 0 : -tabOverlap, 0, end ? 0 : tabOverlap, borderThickness);                 else                     rect.adjust(begin? tabOverlap : 0, tabOverlap, end ? -tabOverlap : 0, 0);                 break;             case QTabBar::RoundedSouth:                 //vMirrored = true;                 rotate = 180; // Not 100% correct, but works                 if (selected)                     rect.adjust(begin ? 0 : -tabOverlap , -borderThickness, end ? 0 : tabOverlap, 0);                 else                     rect.adjust(begin ? tabOverlap : 0, 0, end ? -tabOverlap : 0 , -tabOverlap);                 break;             case QTabBar::RoundedEast:                 rotate = 90;                 if (selected) {                     rect.adjust(-borderThickness, begin ? 0 : -tabOverlap, 0, end ? 0 : tabOverlap);                 }else{                     rect.adjust(0, begin ? tabOverlap : 0, -tabOverlap, end ? -tabOverlap : 0);                 }                 break;             case QTabBar::RoundedWest:                 hMirrored = true;                 rotate = 90;                 if (selected) {                     rect.adjust(0, begin ? 0 : -tabOverlap, borderThickness, end ? 0 : tabOverlap);                 }else{                     rect.adjust(tabOverlap, begin ? tabOverlap : 0, 0, end ? -tabOverlap : 0);                 }                 break;             default:                 themeNumber = -1; // Do our own painting for triangular                 break;             }              if (!selected) {                 switch (tab->shape) {                 case QTabBar::RoundedNorth:                     rect.adjust(0,0, 0,-1);                     break;                 case QTabBar::RoundedSouth:                     rect.adjust(0,1, 0,0);                     break;                 case QTabBar::RoundedEast:                     rect.adjust( 1,0, 0,0);                     break;                 case QTabBar::RoundedWest:                     rect.adjust(0,0, -1,0);                     break;                 default:                     break;                 }             }         }         break;      case CE_ProgressBarGroove:         {         Qt::Orientation orient = Qt::Horizontal;         if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option))             orient = pb2->orientation;         partId = (orient == Qt::Horizontal) ? PP_BAR : PP_BARVERT;         themeNumber = QWindowsXPStylePrivate::ProgressTheme;         stateId = 1;         }         break;      case CE_MenuEmptyArea:     case CE_MenuItem:         if (const QStyleOptionMenuItem *menuitem = qstyleoption_cast<const QStyleOptionMenuItem *>(option))         {             int tab = menuitem->tabWidth;             bool dis = !(menuitem->state& State_Enabled);             bool act = menuitem->state& State_Selected;             bool checkable = menuitem->menuHasCheckableItems;             bool checked = checkable ? menuitem->checked : false;              // windows always has a check column, regardless whether we have an icon or not             int checkcol = qMax(menuitem->maxIconWidth, 12);              int x, y, w, h;             rect.getRect(&x,&y,&w,&h);              QBrush fill = menuitem->palette.brush(act ? QPalette::Highlight : QPalette::Button);             p->fillRect(rect, fill);              if (element == CE_MenuEmptyArea)                 break;              // draw separator -------------------------------------------------             if (menuitem->menuItemType == QStyleOptionMenuItem::Separator) {                 int yoff = y-1 + h / 2;                 p->setPen(menuitem->palette.dark().color());                 p->drawLine(x, yoff, x+w, yoff);                 ++yoff;                 p->setPen(menuitem->palette.light().color());                 p->drawLine(x, yoff, x+w, yoff);                 return;             }              int xpos = x;              // draw icon ------------------------------------------------------             if (!menuitem->icon.isNull()) {                 QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;                 if (act&& !dis)                     mode = QIcon::Active;                 QPixmap pixmap = checked ?                                  menuitem->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize, option, widget), mode, QIcon::On) :                                  menuitem->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize, option, widget), mode);                 int pixw = pixmap.width();                 int pixh = pixmap.height();                 QRect iconRect(0, 0, pixw, pixh);                 iconRect.moveCenter(QRect(xpos, y, checkcol, h).center());                 QRect vIconRect = visualRect(option->direction, option->rect, iconRect);                 p->setPen(menuitem->palette.text().color());                 p->setBrush(Qt::NoBrush);                 if (checked)                     p->drawRect(vIconRect.adjusted(-1, -1, 0, 0));                 p->drawPixmap(vIconRect.topLeft(), pixmap);              // draw checkmark -------------------------------------------------             } else if (checked) {                 QStyleOptionMenuItem newMi = *menuitem;                 newMi.state = State_None;                 if (!dis)                     newMi.state |= State_Enabled;                 if (act)                     newMi.state |= State_On;                  QRect checkMarkRect = QRect(menuitem->rect.x() + windowsItemFrame,                                             menuitem->rect.y() + windowsItemFrame,                                             checkcol - 2 * windowsItemFrame,                                             menuitem->rect.height() - 2*windowsItemFrame);                 newMi.rect = visualRect(option->direction, option->rect, checkMarkRect);                 proxy()->drawPrimitive(PE_IndicatorMenuCheckMark,&newMi, p, widget);             }              QColor textColor = dis ? menuitem->palette.text().color() :                                act ? menuitem->palette.highlightedText().color() : menuitem->palette.buttonText().color();             p->setPen(textColor);              // draw text ------------------------------------------------------             int xm = windowsItemFrame + checkcol + windowsItemHMargin;             xpos = menuitem->rect.x() + xm;             QRect textRect(xpos, y + windowsItemVMargin, w - xm - windowsRightBorder - tab + 1, h - 2 * windowsItemVMargin);             QRect vTextRect = visualRect(option->direction, option->rect, textRect);             QString s = menuitem->text;             if (!s.isEmpty()) {                 p->save();                 int t = s.indexOf(QLatin1Char('\t'));                 int text_flags = Qt::AlignVCenter|Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine | Qt::AlignLeft;                 if (!proxy()->styleHint(SH_UnderlineShortcut, menuitem, widget))                     text_flags |= Qt::TextHideMnemonic;                 // draw tab text ----------------                 if (t>= 0) {                     QRect vShortcutRect = visualRect(option->direction, option->rect, QRect(textRect.topRight(), menuitem->rect.bottomRight()));                     if (dis&& !act&& proxy()->styleHint(SH_EtchDisabledText, option, widget)) {                         p->setPen(menuitem->palette.light().color());                         p->drawText(vShortcutRect.adjusted(1,1,1,1), text_flags, s.mid(t + 1));                         p->setPen(textColor);                     }                     p->drawText(vShortcutRect, text_flags, s.mid(t + 1));                     s = s.left(t);                 }                 QFont font = menuitem->font;                 if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)                     font.setBold(true);                 p->setFont(font);                 if (dis&& !act&& proxy()->styleHint(SH_EtchDisabledText, option, widget)) {                     p->setPen(menuitem->palette.light().color());                     p->drawText(vTextRect.adjusted(1,1,1,1), text_flags, s.left(t));                     p->setPen(textColor);                 }                 p->drawText(vTextRect, text_flags, s);                 p->restore();             }              // draw sub menu arrow --------------------------------------------             if (menuitem->menuItemType == QStyleOptionMenuItem::SubMenu) {                 int dim = (h - 2) / 2;                 PrimitiveElement arrow;                 arrow = (option->direction == Qt::RightToLeft) ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight;                 xpos = x + w - windowsArrowHMargin - windowsItemFrame - dim;                 QRect vSubMenuRect = visualRect(option->direction, option->rect, QRect(xpos, y + h / 2 - dim / 2, dim, dim));                 QStyleOptionMenuItem newMI = *menuitem;                 newMI.rect = vSubMenuRect;                 newMI.state = dis ? State_None : State_Enabled;                 if (act)                     newMI.palette.setColor(QPalette::ButtonText, newMI.palette.highlightedText().color());                 proxy()->drawPrimitive(arrow,&newMI, p, widget);             }         }         return;      case CE_MenuBarItem:         if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option))         {             if (mbi->menuItemType == QStyleOptionMenuItem::DefaultItem)                 break;              bool act = mbi->state& State_Selected;             bool dis = !(mbi->state& State_Enabled);              QBrush fill = mbi->palette.brush(act ? QPalette::Highlight : QPalette::Button);             QPalette::ColorRole textRole = dis ? QPalette::Text:                                            act ? QPalette::HighlightedText : QPalette::ButtonText;             QPixmap pix = mbi->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize, option, widget), QIcon::Normal);              uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;             if (!proxy()->styleHint(SH_UnderlineShortcut, mbi, widget))                 alignment |= Qt::TextHideMnemonic;              p->fillRect(rect, fill);             if (!pix.isNull())                 drawItemPixmap(p, mbi->rect, alignment, pix);             else                 drawItemText(p, mbi->rect, alignment, mbi->palette, mbi->state& State_Enabled, mbi->text, textRole);         }         return; #ifndef QT_NO_DOCKWIDGET     case CE_DockWidgetTitle:         if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(option))         {             int buttonMargin = 4;             int mw = proxy()->pixelMetric(QStyle::PM_DockWidgetTitleMargin, dwOpt, widget);             int fw = proxy()->pixelMetric(PM_DockWidgetFrameWidth, dwOpt, widget);             bool isFloating = widget&& widget->isWindow();             bool isActive = dwOpt->state& State_Active;              const QStyleOptionDockWidgetV2 *v2                 = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(dwOpt);             bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;              if (verticalTitleBar) {                 QSize s = rect.size();                 s.transpose();                 rect.setSize(s);                  p->translate(rect.left() - 1, rect.top() + rect.width());                 p->rotate(-90);                 p->translate(-rect.left() + 1, -rect.top());             }             QRect r = rect.adjusted(0, 2, -1, -3);             QRect titleRect = r;              if (dwOpt->closable) {                 QSize sz = proxy()->standardIcon(QStyle::SP_TitleBarCloseButton, dwOpt, widget).actualSize(QSize(10, 10));                 titleRect.adjust(0, 0, -sz.width() - mw - buttonMargin, 0);             }              if (dwOpt->floatable) {                 QSize sz = proxy()->standardIcon(QStyle::SP_TitleBarMaxButton, dwOpt, widget).actualSize(QSize(10, 10));                 titleRect.adjust(0, 0, -sz.width() - mw - buttonMargin, 0);             }              if (isFloating) {                 titleRect.adjust(0, -fw, 0, 0);                 if (widget != 0&& widget->windowIcon().cacheKey() != QApplication::windowIcon().cacheKey())                     titleRect.adjust(titleRect.height() + mw, 0, 0, 0);             } else {                 titleRect.adjust(mw, 0, 0, 0);                 if (!dwOpt->floatable&& !dwOpt->closable)                     titleRect.adjust(0, 0, -mw, 0);             }              if (!verticalTitleBar)                 titleRect = visualRect(dwOpt->direction, r, titleRect);              if (!isFloating) {                 QPen oldPen = p->pen();                 QString titleText = p->fontMetrics().elidedText(dwOpt->title, Qt::ElideRight, titleRect.width());                 p->setPen(dwOpt->palette.color(QPalette::Dark));                 p->drawRect(r);                  if (!titleText.isEmpty()) {                     drawItemText(p, titleRect,                                 Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,                                 dwOpt->state& State_Enabled, titleText,                                 QPalette::WindowText);                 }                  p->setPen(oldPen);             } else {                 themeNumber = QWindowsXPStylePrivate::WindowTheme;                 if (isActive)                     stateId = CS_ACTIVE;                 else                     stateId = CS_INACTIVE;                  int titleHeight = rect.height() - 2;                 rect = rect.adjusted(-fw, -fw, fw, 0);                  XPThemeData theme(widget, p, themeNumber, 0, stateId);                 if (!theme.isValid())                     break;                  // Draw small type title bar                 theme.rect = rect;                 theme.partId = WP_SMALLCAPTION;                 d->drawBackground(theme);                  // Figure out maximal button space on title bar                  QIcon ico = widget->windowIcon();                 bool hasIcon = (ico.cacheKey() != QApplication::windowIcon().cacheKey());                 if (hasIcon) {                     QPixmap pxIco = ico.pixmap(titleHeight);                     if (!verticalTitleBar&& dwOpt->direction == Qt::RightToLeft)                         p->drawPixmap(rect.width() - titleHeight - pxIco.width(), rect.bottom() - titleHeight - 2, pxIco);                     else                         p->drawPixmap(fw, rect.bottom() - titleHeight - 2, pxIco);                 }                 if (!dwOpt->title.isEmpty()) {                     QPen oldPen = p->pen();                     QFont oldFont = p->font();                     QFont titleFont = oldFont;                     titleFont.setBold(true);                     p->setFont(titleFont);                     QString titleText                         = p->fontMetrics().elidedText(dwOpt->title, Qt::ElideRight, titleRect.width());                      int result = TST_NONE;                     pGetThemeEnumValue(theme.handle(), WP_SMALLCAPTION, isActive ? CS_ACTIVE : CS_INACTIVE, TMT_TEXTSHADOWTYPE,&result);                     if (result != TST_NONE) {                         COLORREF textShadowRef;                         pGetThemeColor(theme.handle(), WP_SMALLCAPTION, isActive ? CS_ACTIVE : CS_INACTIVE, TMT_TEXTSHADOWCOLOR,&textShadowRef);                         QColor textShadow = qRgb(GetRValue(textShadowRef), GetGValue(textShadowRef), GetBValue(textShadowRef));                         p->setPen(textShadow);                         drawItemText(p, titleRect.adjusted(1, 1, 1, 1),                                     Qt::AlignLeft | Qt::AlignBottom, dwOpt->palette,                                     dwOpt->state& State_Enabled, titleText);                     }                      COLORREF captionText = GetSysColor(isActive ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT);                     QColor textColor = qRgb(GetRValue(captionText), GetGValue(captionText), GetBValue(captionText));                     p->setPen(textColor);                     drawItemText(p, titleRect,                                 Qt::AlignLeft | Qt::AlignBottom, dwOpt->palette,                                 dwOpt->state& State_Enabled, titleText);                     p->setFont(oldFont);                     p->setPen(oldPen);                 }              }              return;         }         break; #endif // QT_NO_DOCKWIDGET #ifndef QT_NO_RUBBERBAND     case CE_RubberBand:         if (qstyleoption_cast<const QStyleOptionRubberBand *>(option)) {             QColor highlight = option->palette.color(QPalette::Active, QPalette::Highlight);             p->save();             p->setPen(highlight.darker(120));             QColor dimHighlight(qMin(highlight.red()/2 + 110, 255),                                 qMin(highlight.green()/2 + 110, 255),                                 qMin(highlight.blue()/2 + 110, 255),                                 (widget&& widget->isTopLevel())? 255 : 127);             p->setBrush(dimHighlight);             p->drawRect(option->rect.adjusted(0, 0, -1, -1));             p->restore();             return;         } #endif // QT_NO_RUBBERBAND     case CE_HeaderEmptyArea:         if (option->state& State_Horizontal)         {             themeNumber = QWindowsXPStylePrivate::HeaderTheme;             stateId = HIS_NORMAL;         }         else {             QWindowsStyle::drawControl(CE_HeaderEmptyArea, option, p, widget);             return;         }         break;     default:         break;     }      XPThemeData theme(widget, p, themeNumber, partId, stateId, rect);     if (!theme.isValid()) {         QWindowsStyle::drawControl(element, option, p, widget);         return;     }      theme.rotate = rotate;     theme.mirrorHorizontally = hMirrored;     theme.mirrorVertically = vMirrored;     d->drawBackground(theme); }   /*!     \reimp */ void QWindowsXPStyle::drawComplexControl(ComplexControl cc, const QStyleOptionComplex *option,                                          QPainter *p, const QWidget *widget) const {     QWindowsXPStylePrivate *d = const_cast<QWindowsXPStylePrivate*>(d_func());      if (!QWindowsXPStylePrivate::useXP()) {         QWindowsStyle::drawComplexControl(cc, option, p, widget);         return;     }      State flags = option->state;     SubControls sub = option->subControls;     QRect r = option->rect;      int partId = 0;     int stateId = 0;     if (widget&& widget->testAttribute(Qt::WA_UnderMouse)&& widget->isActiveWindow())         flags |= State_MouseOver;      switch (cc) { #ifndef QT_NO_SPINBOX     case CC_SpinBox:         if (const QStyleOptionSpinBox *sb = qstyleoption_cast<const QStyleOptionSpinBox *>(option))         {             XPThemeData theme(widget, p, QWindowsXPStylePrivate::SpinTheme);              if (sb->frame&& (sub& SC_SpinBoxFrame)) {                 partId = EP_EDITTEXT;                 if (!(flags& State_Enabled))                     stateId = ETS_DISABLED;                 else if (flags& State_HasFocus)                     stateId = ETS_FOCUSED;                 else                     stateId = ETS_NORMAL;                  XPThemeData ftheme(widget, p, QWindowsXPStylePrivate::EditTheme,                                    partId, stateId, r);                 ftheme.noContent = true;                 d->drawBackground(ftheme);             }             if (sub& SC_SpinBoxUp) {                 theme.rect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxUp, widget);                 partId = SPNP_UP;                 if (!(sb->stepEnabled& QAbstractSpinBox::StepUpEnabled) || !(flags& State_Enabled))                     stateId = UPS_DISABLED;                 else if (sb->activeSubControls == SC_SpinBoxUp&& (sb->state& State_Sunken))                     stateId = UPS_PRESSED;                 else if (sb->activeSubControls == SC_SpinBoxUp&& (sb->state& State_MouseOver))                     stateId = UPS_HOT;                 else                     stateId = UPS_NORMAL;                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }             if (sub& SC_SpinBoxDown) {                 theme.rect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxDown, widget);                 partId = SPNP_DOWN;                 if (!(sb->stepEnabled& QAbstractSpinBox::StepDownEnabled) || !(flags& State_Enabled))                     stateId = DNS_DISABLED;                 else if (sb->activeSubControls == SC_SpinBoxDown&& (sb->state& State_Sunken))                     stateId = DNS_PRESSED;                 else if (sb->activeSubControls == SC_SpinBoxDown&& (sb->state& State_MouseOver))                     stateId = DNS_HOT;                 else                     stateId = DNS_NORMAL;                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }         }         break; #endif // QT_NO_SPINBOX #ifndef QT_NO_COMBOBOX     case CC_ComboBox:         if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(option))         {             if (sub& SC_ComboBoxEditField) {                 if (cmb->frame) {                     partId = EP_EDITTEXT;                     if (!(flags& State_Enabled))                         stateId = ETS_DISABLED;                     else if (flags& State_HasFocus)                         stateId = ETS_FOCUSED;                     else                         stateId = ETS_NORMAL;                     XPThemeData theme(widget, p, QWindowsXPStylePrivate::EditTheme, partId, stateId, r);                     d->drawBackground(theme);                 } else {                     QBrush editBrush = cmb->palette.brush(QPalette::Base);                     p->fillRect(option->rect, editBrush);                 }                 if (!cmb->editable) {                     QRect re = proxy()->subControlRect(CC_ComboBox, option, SC_ComboBoxEditField, widget);                     if (option->state& State_HasFocus) {                         p->fillRect(re, option->palette.highlight());                         p->setPen(option->palette.highlightedText().color());                         p->setBackground(option->palette.highlight());                     } else {                         p->fillRect(re, option->palette.base());                         p->setPen(option->palette.text().color());                         p->setBackground(option->palette.base());                     }                 }             }              if (sub& SC_ComboBoxArrow) {                 XPThemeData theme(widget, p, QWindowsXPStylePrivate::ComboboxTheme);                 theme.rect = proxy()->subControlRect(CC_ComboBox, option, SC_ComboBoxArrow, widget);                 partId = CP_DROPDOWNBUTTON;                 if (!(flags& State_Enabled))                     stateId = CBXS_DISABLED;                 else if (cmb->activeSubControls == SC_ComboBoxArrow&& (cmb->state& State_Sunken))                     stateId = CBXS_PRESSED;                 else if (cmb->activeSubControls == SC_ComboBoxArrow&& (cmb->state& State_MouseOver))                     stateId = CBXS_HOT;                 else                     stateId = CBXS_NORMAL;                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }         }         break; #endif // QT_NO_COMBOBOX     case CC_ScrollBar:         if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(option))         {             XPThemeData theme(widget, p, QWindowsXPStylePrivate::ScrollBarTheme);             bool maxedOut = (scrollbar->maximum == scrollbar->minimum);             if (maxedOut)                 flags&= ~State_Enabled;              bool isHorz = flags& State_Horizontal;             bool isRTL  = option->direction == Qt::RightToLeft;             if (sub& SC_ScrollBarAddLine) {                 theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarAddLine, widget);                 partId = SBP_ARROWBTN;                 if (!(flags& State_Enabled))                     stateId = (isHorz ? (isRTL ? ABS_LEFTDISABLED : ABS_RIGHTDISABLED) : ABS_DOWNDISABLED);                 else if (scrollbar->activeSubControls& SC_ScrollBarAddLine&& (scrollbar->state& State_Sunken))                     stateId = (isHorz ? (isRTL ? ABS_LEFTPRESSED : ABS_RIGHTPRESSED) : ABS_DOWNPRESSED);                 else if (scrollbar->activeSubControls& SC_ScrollBarAddLine&& (scrollbar->state& State_MouseOver))                     stateId = (isHorz ? (isRTL ? ABS_LEFTHOT : ABS_RIGHTHOT) : ABS_DOWNHOT);                 else                     stateId = (isHorz ? (isRTL ? ABS_LEFTNORMAL : ABS_RIGHTNORMAL) : ABS_DOWNNORMAL);                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }             if (sub& SC_ScrollBarSubLine) {                 theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSubLine, widget);                 partId = SBP_ARROWBTN;                 if (!(flags& State_Enabled))                     stateId = (isHorz ? (isRTL ? ABS_RIGHTDISABLED : ABS_LEFTDISABLED) : ABS_UPDISABLED);                 else if (scrollbar->activeSubControls& SC_ScrollBarSubLine&& (scrollbar->state& State_Sunken))                     stateId = (isHorz ? (isRTL ? ABS_RIGHTPRESSED : ABS_LEFTPRESSED) : ABS_UPPRESSED);                 else if (scrollbar->activeSubControls& SC_ScrollBarSubLine&& (scrollbar->state& State_MouseOver))                     stateId = (isHorz ? (isRTL ? ABS_RIGHTHOT : ABS_LEFTHOT) : ABS_UPHOT);                 else                     stateId = (isHorz ? (isRTL ? ABS_RIGHTNORMAL : ABS_LEFTNORMAL) : ABS_UPNORMAL);                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }             if (maxedOut) {                 theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSlider, widget);                 theme.rect = theme.rect.united(proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSubPage, widget));                 theme.rect = theme.rect.united(proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarAddPage, widget));                 partId = scrollbar->orientation == Qt::Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;                 stateId = SCRBS_DISABLED;                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             } else {                 if (sub& SC_ScrollBarSubPage) {                     theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSubPage, widget);                     partId = flags& State_Horizontal ? SBP_UPPERTRACKHORZ : SBP_UPPERTRACKVERT;                     if (!(flags& State_Enabled))                         stateId = SCRBS_DISABLED;                     else if (scrollbar->activeSubControls& SC_ScrollBarSubPage&& (scrollbar->state& State_Sunken))                         stateId = SCRBS_PRESSED;                     else if (scrollbar->activeSubControls& SC_ScrollBarSubPage&& (scrollbar->state& State_MouseOver))                         stateId = SCRBS_HOT;                     else                         stateId = SCRBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_ScrollBarAddPage) {                     theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarAddPage, widget);                     partId = flags& State_Horizontal ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT;                     if (!(flags& State_Enabled))                         stateId = SCRBS_DISABLED;                     else if (scrollbar->activeSubControls& SC_ScrollBarAddPage&& (scrollbar->state& State_Sunken))                         stateId = SCRBS_PRESSED;                     else if (scrollbar->activeSubControls& SC_ScrollBarAddPage&& (scrollbar->state& State_MouseOver))                         stateId = SCRBS_HOT;                     else                         stateId = SCRBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_ScrollBarSlider) {                     theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSlider, widget);                     if (!(flags& State_Enabled))                         stateId = SCRBS_DISABLED;                     else if (scrollbar->activeSubControls& SC_ScrollBarSlider&& (scrollbar->state& State_Sunken))                         stateId = SCRBS_PRESSED;                     else if (scrollbar->activeSubControls& SC_ScrollBarSlider&& (scrollbar->state& State_MouseOver))                         stateId = SCRBS_HOT;                     else                         stateId = SCRBS_NORMAL;                      // Draw handle                     theme.rect = proxy()->subControlRect(CC_ScrollBar, option, SC_ScrollBarSlider, widget);                     theme.partId = flags& State_Horizontal ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;                     theme.stateId = stateId;                     d->drawBackground(theme);                      // Calculate rect of gripper                     const int swidth = theme.rect.width();                     const int sheight = theme.rect.height();                      MARGINS contentsMargin;                     RECT rect = theme.toRECT(theme.rect);                     pGetThemeMargins(theme.handle(), 0, theme.partId, theme.stateId, TMT_SIZINGMARGINS,&rect,&contentsMargin);                      SIZE size;                     theme.partId = flags& State_Horizontal ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;                     pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                     int gw = size.cx, gh = size.cy;                       QRect gripperBounds;                     if (flags& State_Horizontal&& ((swidth - contentsMargin.cxLeftWidth - contentsMargin.cxRightWidth)> gw)) {                         gripperBounds.setLeft(theme.rect.left() + swidth/2 - gw/2);                         gripperBounds.setTop(theme.rect.top() + sheight/2 - gh/2);                         gripperBounds.setWidth(gw);                         gripperBounds.setHeight(gh);                     } else if ((sheight - contentsMargin.cyTopHeight - contentsMargin.cyBottomHeight)> gh) {                         gripperBounds.setLeft(theme.rect.left() + swidth/2 - gw/2);                         gripperBounds.setTop(theme.rect.top() + sheight/2 - gh/2);                         gripperBounds.setWidth(gw);                         gripperBounds.setHeight(gh);                     }                      // Draw gripper if there is enough space                     if (!gripperBounds.isEmpty()) {                         p->save();                         theme.rect = gripperBounds;                         p->setClipRegion(d->region(theme));// Only change inside the region of the gripper                         d->drawBackground(theme);          // Transparent gripper ontop of background                         p->restore();                     }                 }             }         }         break;  #ifndef QT_NO_SLIDER     case CC_Slider:         if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option))         {             XPThemeData theme(widget, p, QWindowsXPStylePrivate::TrackBarTheme);             QRect slrect = slider->rect;             QRegion tickreg = slrect;             if (sub& SC_SliderGroove) {                 theme.rect = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);                 if (slider->orientation == Qt::Horizontal) {                     partId = TKP_TRACK;                     stateId = TRS_NORMAL;                     theme.rect = QRect(slrect.left(), theme.rect.center().y() - 2, slrect.width(), 4);                 } else {                     partId = TKP_TRACKVERT;                     stateId = TRVS_NORMAL;                     theme.rect = QRect(theme.rect.center().x() - 2, slrect.top(), 4, slrect.height());                 }                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);                 tickreg -= theme.rect;             }             if (sub& SC_SliderTickmarks) {                 int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);                 int ticks = slider->tickPosition;                 int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);                 int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);                 int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);                 int interval = slider->tickInterval;                 if (interval<= 0) {                     interval = slider->singleStep;                     if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,                                                         available)                         - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,                                                           0, available)< 3)                         interval = slider->pageStep;                 }                 if (!interval)                     interval = 1;                 int fudge = len / 2;                 int pos;                 int bothOffset = (ticks& QSlider::TicksAbove&& ticks& QSlider::TicksBelow) ? 1 : 0;                 p->setPen(d->sliderTickColor);                 QVarLengthArray<QLine, 32> lines;                 int v = slider->minimum;                 while (v<= slider->maximum + 1) {                     if (v == slider->maximum + 1&& interval == 1)                         break;                     const int v_ = qMin(v, slider->maximum);                     int tickLength = (v_ == slider->minimum || v_>= slider->maximum) ? 4 : 3;                     pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,                                                           v_, available) + fudge;                     if (slider->orientation == Qt::Horizontal) {                         if (ticks& QSlider::TicksAbove)                             lines.append(QLine(pos, tickOffset - 1 - bothOffset,                                                pos, tickOffset - 1 - bothOffset - tickLength));                          if (ticks& QSlider::TicksBelow)                             lines.append(QLine(pos, tickOffset + thickness + bothOffset,                                                pos, tickOffset + thickness + bothOffset + tickLength));                     } else {                         if (ticks& QSlider::TicksAbove)                             lines.append(QLine(tickOffset - 1 - bothOffset, pos,                                                tickOffset - 1 - bothOffset - tickLength, pos));                          if (ticks& QSlider::TicksBelow)                             lines.append(QLine(tickOffset + thickness + bothOffset, pos,                                                tickOffset + thickness + bothOffset + tickLength, pos));                     }                     // in the case where maximum is max int                     int nextInterval = v + interval;                     if (nextInterval< v)                         break;                     v = nextInterval;                 }                 if (lines.size()> 0) {                     p->save();                     p->translate(slrect.topLeft());                     p->drawLines(lines.constData(), lines.size());                     p->restore();                 }             }             if (sub& SC_SliderHandle) {                 theme.rect = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);                 if (slider->orientation == Qt::Horizontal) {                     if (slider->tickPosition == QSlider::TicksAbove)                         partId = TKP_THUMBTOP;                     else if (slider->tickPosition == QSlider::TicksBelow)                         partId = TKP_THUMBBOTTOM;                     else                         partId = TKP_THUMB;                      if (!(slider->state& State_Enabled))                         stateId = TUS_DISABLED;                     else if (slider->activeSubControls& SC_SliderHandle&& (slider->state& State_Sunken))                         stateId = TUS_PRESSED;                     else if (slider->activeSubControls& SC_SliderHandle&& (slider->state& State_MouseOver))                         stateId = TUS_HOT;                     else if (flags& State_HasFocus)                         stateId = TUS_FOCUSED;                     else                         stateId = TUS_NORMAL;                 } else {                     if (slider->tickPosition == QSlider::TicksLeft)                         partId = TKP_THUMBLEFT;                     else if (slider->tickPosition == QSlider::TicksRight)                         partId = TKP_THUMBRIGHT;                     else                         partId = TKP_THUMBVERT;                      if (!(slider->state& State_Enabled))                         stateId = TUVS_DISABLED;                     else if (slider->activeSubControls& SC_SliderHandle&& (slider->state& State_Sunken))                         stateId = TUVS_PRESSED;                     else if (slider->activeSubControls& SC_SliderHandle&& (slider->state& State_MouseOver))                         stateId = TUVS_HOT;                     else if (flags& State_HasFocus)                         stateId = TUVS_FOCUSED;                     else                         stateId = TUVS_NORMAL;                 }                 theme.partId = partId;                 theme.stateId = stateId;                 d->drawBackground(theme);             }             if (slider->state& State_HasFocus) {                 QStyleOptionFocusRect fropt;                 fropt.QStyleOption::operator=(*slider);                 fropt.rect = subElementRect(SE_SliderFocusRect, slider, widget);                 proxy()->drawPrimitive(PE_FrameFocusRect,&fropt, p, widget);             }         }         break; #endif #ifndef QT_NO_TOOLBUTTON     case CC_ToolButton:         if (const QStyleOptionToolButton *toolbutton             = qstyleoption_cast<const QStyleOptionToolButton *>(option)) {             QRect button, menuarea;             button = proxy()->subControlRect(cc, toolbutton, SC_ToolButton, widget);             menuarea = proxy()->subControlRect(cc, toolbutton, SC_ToolButtonMenu, widget);              State bflags = toolbutton->state& ~State_Sunken;             State mflags = bflags;             bool autoRaise = flags& State_AutoRaise;             if (autoRaise) {                 if (!(bflags& State_MouseOver) || !(bflags& State_Enabled)) {                     bflags&= ~State_Raised;                 }             }              if (toolbutton->state& State_Sunken) {                 if (toolbutton->activeSubControls& SC_ToolButton) {                     bflags |= State_Sunken;                     mflags |= State_MouseOver | State_Sunken;                 } else if (toolbutton->activeSubControls& SC_ToolButtonMenu) {                     mflags |= State_Sunken;                     bflags |= State_MouseOver;                 }             }              QStyleOption tool(0);             tool.palette = toolbutton->palette;             if (toolbutton->subControls& SC_ToolButton) {                 if (flags& (State_Sunken | State_On | State_Raised) || !autoRaise) {                     if (toolbutton->features& QStyleOptionToolButton::MenuButtonPopup&& autoRaise) {                         XPThemeData theme(widget, p, QWindowsXPStylePrivate::ToolBarTheme);                         theme.partId = TP_SPLITBUTTON;                         theme.rect = button;                         if (!(bflags& State_Enabled))                             stateId = TS_DISABLED;                         else if (bflags& State_Sunken)                             stateId = TS_PRESSED;                         else if (bflags& State_MouseOver || !(flags& State_AutoRaise))                             stateId = flags& State_On ? TS_HOTCHECKED : TS_HOT;                         else if (bflags& State_On)                             stateId = TS_CHECKED;                         else                             stateId = TS_NORMAL;                         if (option->direction == Qt::RightToLeft)                             theme.mirrorHorizontally = true;                         theme.stateId = stateId;                         d->drawBackground(theme);                     } else {                         tool.rect = option->rect;                         tool.state = bflags;                         if (autoRaise) // for tool bars                             proxy()->drawPrimitive(PE_PanelButtonTool,&tool, p, widget);                         else                             proxy()->drawPrimitive(PE_PanelButtonBevel,&tool, p, widget);                     }                 }             }              if (toolbutton->state& State_HasFocus) {                 QStyleOptionFocusRect fr;                 fr.QStyleOption::operator=(*toolbutton);                 fr.rect.adjust(3, 3, -3, -3);                 if (toolbutton->features& QStyleOptionToolButton::MenuButtonPopup)                     fr.rect.adjust(0, 0, -proxy()->pixelMetric(QStyle::PM_MenuButtonIndicator,                                                       toolbutton, widget), 0);                 proxy()->drawPrimitive(PE_FrameFocusRect,&fr, p, widget);             }             QStyleOptionToolButton label = *toolbutton;             label.state = bflags;             int fw = 2;             if (!autoRaise)                 label.state&= ~State_Sunken;             label.rect = button.adjusted(fw, fw, -fw, -fw);             proxy()->drawControl(CE_ToolButtonLabel,&label, p, widget);              if (toolbutton->subControls& SC_ToolButtonMenu) {                 tool.rect = menuarea;                 tool.state = mflags;                 if (autoRaise) {                     proxy()->drawPrimitive(PE_IndicatorButtonDropDown,&tool, p, widget);                 } else {                     tool.state = mflags;                     menuarea.adjust(-2, 0, 0, 0);                     // Draw menu button                     if ((bflags& State_Sunken) != (mflags& State_Sunken)){                         p->save();                         p->setClipRect(menuarea);                         tool.rect = option->rect;                         proxy()->drawPrimitive(PE_PanelButtonBevel,&tool, p, 0);                         p->restore();                     }                     // Draw arrow                     p->save();                     p->setPen(option->palette.dark().color());                     p->drawLine(menuarea.left(), menuarea.top() + 3,                                 menuarea.left(), menuarea.bottom() - 3);                     p->setPen(option->palette.light().color());                     p->drawLine(menuarea.left() - 1, menuarea.top() + 3,                                 menuarea.left() - 1, menuarea.bottom() - 3);                      tool.rect = menuarea.adjusted(2, 3, -2, -1);                     proxy()->drawPrimitive(PE_IndicatorArrowDown,&tool, p, widget);                     p->restore();                 }             } else if (toolbutton->features& QStyleOptionToolButton::HasMenu) {                 int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, toolbutton, widget);                 QRect ir = toolbutton->rect;                 QStyleOptionToolButton newBtn = *toolbutton;                 newBtn.rect = QRect(ir.right() + 4 - mbi, ir.height() - mbi + 4, mbi - 5, mbi - 5);                 proxy()->drawPrimitive(PE_IndicatorArrowDown,&newBtn, p, widget);             }         }         break; #endif // QT_NO_TOOLBUTTON      case CC_TitleBar:         {             if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option))             {                 bool isActive = tb->titleBarState& QStyle::State_Active;                 XPThemeData theme(widget, p, QWindowsXPStylePrivate::WindowTheme);                 if (sub& SC_TitleBarLabel) {                          partId = (tb->titleBarState& Qt::WindowMinimized) ? WP_MINCAPTION : WP_CAPTION;                     theme.rect = option->rect;                     if (widget&& !widget->isEnabled())                         stateId = CS_DISABLED;                     else if (isActive)                         stateId = CS_ACTIVE;                     else                         stateId = CS_INACTIVE;                      theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                      QRect ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarLabel, widget);                      int result = TST_NONE;                     pGetThemeEnumValue(theme.handle(), WP_CAPTION, isActive ? CS_ACTIVE : CS_INACTIVE, TMT_TEXTSHADOWTYPE,&result);                     if (result != TST_NONE) {                         COLORREF textShadowRef;                         pGetThemeColor(theme.handle(), WP_CAPTION, isActive ? CS_ACTIVE : CS_INACTIVE, TMT_TEXTSHADOWCOLOR,&textShadowRef);                         QColor textShadow = qRgb(GetRValue(textShadowRef), GetGValue(textShadowRef), GetBValue(textShadowRef));                         p->setPen(textShadow);                         p->drawText(ir.x() + 3, ir.y() + 2, ir.width() - 1, ir.height(),                                     Qt::AlignLeft | Qt::AlignVCenter | Qt::TextSingleLine, tb->text);                     }                     COLORREF captionText = GetSysColor(isActive ? COLOR_CAPTIONTEXT : COLOR_INACTIVECAPTIONTEXT);                     QColor textColor = qRgb(GetRValue(captionText), GetGValue(captionText), GetBValue(captionText));                     p->setPen(textColor);                     p->drawText(ir.x() + 2, ir.y() + 1, ir.width() - 2, ir.height(),                                 Qt::AlignLeft | Qt::AlignVCenter | Qt::TextSingleLine, tb->text);                 }                 if (sub& SC_TitleBarSysMenu&& tb->titleBarFlags& Qt::WindowSystemMenuHint) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarSysMenu, widget);                     partId = WP_SYSBUTTON;                     if ((widget&& !widget->isEnabled()) || !isActive)                         stateId = SBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarSysMenu&& (option->state& State_Sunken))                         stateId = SBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarSysMenu&& (option->state& State_MouseOver))                         stateId = SBS_HOT;                     else                         stateId = SBS_NORMAL;                     if (!tb->icon.isNull()) {                         tb->icon.paint(p, theme.rect);                     } else {                         theme.partId = partId;                         theme.stateId = stateId;                         SIZE sz;                         pGetThemePartSize(theme.handle(), qt_win_display_dc(), theme.partId, theme.stateId, 0, TS_TRUE,&sz);                         if (sz.cx == 0 || sz.cy == 0) {                             int iconSize = proxy()->pixelMetric(PM_SmallIconSize, tb, widget);                             QPixmap pm = proxy()->standardIcon(SP_TitleBarMenuButton, tb, widget).pixmap(iconSize, iconSize);                             p->save();                             drawItemPixmap(p, theme.rect, Qt::AlignCenter, pm);                             p->restore();                         } else {                             d->drawBackground(theme);                         }                     }                 }                  if (sub& SC_TitleBarMinButton&& tb->titleBarFlags& Qt::WindowMinimizeButtonHint&& !(tb->titleBarState& Qt::WindowMinimized)) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarMinButton, widget);                     partId = WP_MINBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = MINBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarMinButton&& (option->state& State_Sunken))                         stateId = MINBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarMinButton&& (option->state& State_MouseOver))                         stateId = MINBS_HOT;                     else if (!isActive)                         stateId = MINBS_INACTIVE;                     else                         stateId = MINBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_TitleBarMaxButton&& tb->titleBarFlags& Qt::WindowMaximizeButtonHint&& !(tb->titleBarState& Qt::WindowMaximized)) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarMaxButton, widget);                     partId = WP_MAXBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = MAXBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarMaxButton&& (option->state& State_Sunken))                         stateId = MAXBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarMaxButton&& (option->state& State_MouseOver))                         stateId = MAXBS_HOT;                     else if (!isActive)                         stateId = MAXBS_INACTIVE;                     else                         stateId = MAXBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_TitleBarContextHelpButton&& tb->titleBarFlags& Qt::WindowContextHelpButtonHint) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarContextHelpButton, widget);                     partId = WP_HELPBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = MINBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarContextHelpButton&& (option->state& State_Sunken))                         stateId = MINBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarContextHelpButton&& (option->state& State_MouseOver))                         stateId = MINBS_HOT;                     else if (!isActive)                         stateId = MINBS_INACTIVE;                     else                         stateId = MINBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 bool drawNormalButton = (sub& SC_TitleBarNormalButton)&& (((tb->titleBarFlags& Qt::WindowMinimizeButtonHint)&& (tb->titleBarState& Qt::WindowMinimized))                                         || ((tb->titleBarFlags& Qt::WindowMaximizeButtonHint)&& (tb->titleBarState& Qt::WindowMaximized)));                 if (drawNormalButton) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarNormalButton, widget);                     partId = WP_RESTOREBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = RBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarNormalButton&& (option->state& State_Sunken))                         stateId = RBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarNormalButton&& (option->state& State_MouseOver))                         stateId = RBS_HOT;                     else if (!isActive)                         stateId = RBS_INACTIVE;                     else                         stateId = RBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_TitleBarShadeButton&& tb->titleBarFlags& Qt::WindowShadeButtonHint&& !(tb->titleBarState& Qt::WindowMinimized)) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarShadeButton, widget);                     partId = WP_MINBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = MINBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarShadeButton&& (option->state& State_Sunken))                         stateId = MINBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarShadeButton&& (option->state& State_MouseOver))                         stateId = MINBS_HOT;                     else if (!isActive)                         stateId = MINBS_INACTIVE;                     else                         stateId = MINBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_TitleBarUnshadeButton&& tb->titleBarFlags& Qt::WindowShadeButtonHint&& tb->titleBarState& Qt::WindowMinimized) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarUnshadeButton, widget);                     partId = WP_RESTOREBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = RBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarUnshadeButton&& (option->state& State_Sunken))                         stateId = RBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarUnshadeButton&& (option->state& State_MouseOver))                         stateId = RBS_HOT;                     else if (!isActive)                         stateId = RBS_INACTIVE;                     else                         stateId = RBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }                 if (sub& SC_TitleBarCloseButton&& tb->titleBarFlags& Qt::WindowSystemMenuHint) {                     theme.rect = proxy()->subControlRect(CC_TitleBar, option, SC_TitleBarCloseButton, widget);                     //partId = titlebar->testWFlags(Qt::WA_WState_Tool) ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON;                     partId = WP_CLOSEBUTTON;                     if (widget&& !widget->isEnabled())                         stateId = CBS_DISABLED;                     else if (option->activeSubControls == SC_TitleBarCloseButton&& (option->state& State_Sunken))                         stateId = CBS_PUSHED;                     else if (option->activeSubControls == SC_TitleBarCloseButton&& (option->state& State_MouseOver))                         stateId = CBS_HOT;                     else if (!isActive)                         stateId = CBS_INACTIVE;                     else                         stateId = CBS_NORMAL;                     theme.partId = partId;                     theme.stateId = stateId;                     d->drawBackground(theme);                 }             }         }         break;  #ifndef QT_NO_DIAL     case CC_Dial:         if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))             QStyleHelper::drawDial(dial, p);         break; #endif // QT_NO_DIAL     default:         QWindowsStyle::drawComplexControl(cc, option, p, widget);         break;     } }  /*! \reimp */ int QWindowsXPStyle::pixelMetric(PixelMetric pm, const QStyleOption *option, const QWidget *widget) const {     if (!QWindowsXPStylePrivate::useXP())         return QWindowsStyle::pixelMetric(pm, option, widget);      int res = 0;     switch (pm) {     case PM_MenuBarPanelWidth:         res = 0;         break;      case PM_DefaultFrameWidth:         if (qobject_cast<const QListView*>(widget))             res = 2;         else             res = 1;         break;     case PM_MenuPanelWidth:     case PM_SpinBoxFrameWidth:         res = 1;         break;      case PM_TabBarTabOverlap:     case PM_MenuHMargin:     case PM_MenuVMargin:         res = 2;         break;      case PM_TabBarBaseOverlap:         if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {             switch (tab->shape) {             case QTabBar::RoundedNorth:             case QTabBar::TriangularNorth:                 res = 1;                 break;             case QTabBar::RoundedSouth:             case QTabBar::TriangularSouth:                 res = 2;                 break;             case QTabBar::RoundedEast:             case QTabBar::TriangularEast:                 res = 3;                 break;             case QTabBar::RoundedWest:             case QTabBar::TriangularWest:                 res = 1;                 break;             }         }         break;      case PM_SplitterWidth:         res = qMax(int(QStyleHelper::dpiScaled(5.)), QApplication::globalStrut().width());         break;      case PM_IndicatorWidth:     case PM_IndicatorHeight:         {             XPThemeData theme(widget, 0, QWindowsXPStylePrivate::ButtonTheme, BP_CHECKBOX, CBS_UNCHECKEDNORMAL);             if (theme.isValid()) {                 SIZE size;                 pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                 res = (pm == PM_IndicatorWidth) ? size.cx : size.cy;             }         }         break;      case PM_ExclusiveIndicatorWidth:     case PM_ExclusiveIndicatorHeight:         {             XPThemeData theme(widget, 0, QWindowsXPStylePrivate::ButtonTheme, BP_RADIOBUTTON, RBS_UNCHECKEDNORMAL);             if (theme.isValid()) {                 SIZE size;                 pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                 res = (pm == PM_ExclusiveIndicatorWidth) ? size.cx : size.cy;             }         }         break;      case PM_ProgressBarChunkWidth:         {             Qt::Orientation orient = Qt::Horizontal;             if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option))                 orient = pb2->orientation;             XPThemeData theme(widget, 0, QWindowsXPStylePrivate::ProgressTheme,                               (orient == Qt::Horizontal) ? PP_CHUNK : PP_CHUNKVERT);             if (theme.isValid()) {                 SIZE size;                 pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                 res = (orient == Qt::Horizontal) ? size.cx : size.cy;             }         }         break;      case PM_SliderThickness:         {             XPThemeData theme(widget, 0, QWindowsXPStylePrivate::TrackBarTheme,                               TKP_THUMB);             if (theme.isValid()) {                 SIZE size;                 pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                 res = size.cy;             }         }         break;      case PM_TitleBarHeight:         {             if (widget&& (widget->windowType() == Qt::Tool))                 res = GetSystemMetrics(SM_CYSMCAPTION) + GetSystemMetrics(SM_CXSIZEFRAME);             else                 res = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CXSIZEFRAME);         }         break;      case PM_MdiSubWindowFrameWidth:         {             XPThemeData theme(widget, 0, QWindowsXPStylePrivate::WindowTheme, WP_FRAMELEFT, FS_ACTIVE);             if (theme.isValid()) {                 SIZE size;                 pGetThemePartSize(theme.handle(), 0, WP_FRAMELEFT, FS_ACTIVE, 0, TS_TRUE,&size);                 res = size.cx-1;             }         }         break;      case PM_MdiSubWindowMinimizedWidth:         res = 160;         break;  #ifndef QT_NO_TOOLBAR     case PM_ToolBarHandleExtent:         res = int(QStyleHelper::dpiScaled(8.));         break;  #endif // QT_NO_TOOLBAR     case PM_DockWidgetFrameWidth:     {         XPThemeData theme(widget, 0, QWindowsXPStylePrivate::WindowTheme, WP_SMALLFRAMERIGHT, FS_ACTIVE);         if (theme.isValid()) {             SIZE size;             pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);             res = size.cx;         }     }     break;     case PM_DockWidgetSeparatorExtent:         res = int(QStyleHelper::dpiScaled(4.));         break;     case PM_DockWidgetTitleMargin:         res = int(QStyleHelper::dpiScaled(4.));         break;      case PM_ButtonShiftHorizontal:     case PM_ButtonShiftVertical:         if (qstyleoption_cast<const QStyleOptionToolButton *>(option))             res = 1;         else             res = 0;         break;      case PM_ButtonDefaultIndicator:         res = 0;         break;      default:         res = QWindowsStyle::pixelMetric(pm, option, widget);     }      return res; }  /*   This function is used by subControlRect to check if a button   should be drawn for the given subControl given a set of window flags. */ static bool buttonVisible(const QStyle::SubControl sc, const QStyleOptionTitleBar *tb){      bool isMinimized = tb->titleBarState& Qt::WindowMinimized;     bool isMaximized = tb->titleBarState& Qt::WindowMaximized;     const uint flags = tb->titleBarFlags;     bool retVal = false;     switch (sc) {     case QStyle::SC_TitleBarContextHelpButton:         if (flags& Qt::WindowContextHelpButtonHint)             retVal = true;         break;     case QStyle::SC_TitleBarMinButton:         if (!isMinimized&& (flags& Qt::WindowMinimizeButtonHint))             retVal = true;         break;     case QStyle::SC_TitleBarNormalButton:         if (isMinimized&& (flags& Qt::WindowMinimizeButtonHint))             retVal = true;         else if (isMaximized&& (flags& Qt::WindowMaximizeButtonHint))             retVal = true;         break;     case QStyle::SC_TitleBarMaxButton:         if (!isMaximized&& (flags& Qt::WindowMaximizeButtonHint))             retVal = true;         break;     case QStyle::SC_TitleBarShadeButton:         if (!isMinimized&&  flags& Qt::WindowShadeButtonHint)             retVal = true;         break;     case QStyle::SC_TitleBarUnshadeButton:         if (isMinimized&& flags& Qt::WindowShadeButtonHint)             retVal = true;         break;     case QStyle::SC_TitleBarCloseButton:         if (flags& Qt::WindowSystemMenuHint)             retVal = true;         break;     case QStyle::SC_TitleBarSysMenu:         if (flags& Qt::WindowSystemMenuHint)             retVal = true;         break;     default :         retVal = true;     }     return retVal; }  /*!     \reimp */ QRect QWindowsXPStyle::subControlRect(ComplexControl cc, const QStyleOptionComplex *option,                                       SubControl subControl, const QWidget *widget) const {     if (!QWindowsXPStylePrivate::useXP())         return QWindowsStyle::subControlRect(cc, option, subControl, widget);      QRect rect;      switch (cc) {     case CC_TitleBar:         if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {             if (!buttonVisible(subControl, tb))                 return rect;             const bool isToolTitle = false;             const int height = tb->rect.height();             const int width = tb->rect.width();             int buttonHeight = GetSystemMetrics(SM_CYSIZE) - 4;             int buttonWidth = GetSystemMetrics(SM_CXSIZE) - 4;             const int delta = buttonWidth + 2;             int controlTop = option->rect.bottom() - buttonHeight - 2;             const int frameWidth = proxy()->pixelMetric(PM_MdiSubWindowFrameWidth, option, widget);             const bool sysmenuHint  = (tb->titleBarFlags& Qt::WindowSystemMenuHint) != 0;             const bool minimizeHint = (tb->titleBarFlags& Qt::WindowMinimizeButtonHint) != 0;             const bool maximizeHint = (tb->titleBarFlags& Qt::WindowMaximizeButtonHint) != 0;             const bool contextHint = (tb->titleBarFlags& Qt::WindowContextHelpButtonHint) != 0;             const bool shadeHint = (tb->titleBarFlags& Qt::WindowShadeButtonHint) != 0;             bool isMinimized = tb->titleBarState& Qt::WindowMinimized;             bool isMaximized = tb->titleBarState& Qt::WindowMaximized;             int offset = 0;              switch (subControl) {             case SC_TitleBarLabel:                 rect = QRect(frameWidth, 0, width - (buttonWidth + frameWidth + 10), height);                 if (isToolTitle) {                     if (sysmenuHint) {                         rect.adjust(0, 0, -buttonWidth - 3, 0);                     }                     if (minimizeHint || maximizeHint)                         rect.adjust(0, 0, -buttonWidth - 2, 0);                 } else {                     if (sysmenuHint) {                         const int leftOffset = height - 8;                         rect.adjust(leftOffset, 0, 0, 0);                     }                     if (minimizeHint)                         rect.adjust(0, 0, -buttonWidth - 2, 0);                     if (maximizeHint)                         rect.adjust(0, 0, -buttonWidth - 2, 0);                     if (contextHint)                         rect.adjust(0, 0, -buttonWidth - 2, 0);                     if (shadeHint)                         rect.adjust(0, 0, -buttonWidth - 2, 0);                 }                 break;              case SC_TitleBarContextHelpButton:                 if (tb->titleBarFlags& Qt::WindowContextHelpButtonHint)                     offset += delta;                 //fall through             case SC_TitleBarMinButton:                 if (!isMinimized&& (tb->titleBarFlags& Qt::WindowMinimizeButtonHint))                     offset += delta;                 else if (subControl == SC_TitleBarMinButton)                     break;                 //fall through             case SC_TitleBarNormalButton:                 if (isMinimized&& (tb->titleBarFlags& Qt::WindowMinimizeButtonHint))                     offset += delta;                 else if (isMaximized&& (tb->titleBarFlags& Qt::WindowMaximizeButtonHint))                     offset += delta;                 else if (subControl == SC_TitleBarNormalButton)                     break;                 //fall through             case SC_TitleBarMaxButton:                 if (!isMaximized&& (tb->titleBarFlags& Qt::WindowMaximizeButtonHint))                     offset += delta;                 else if (subControl == SC_TitleBarMaxButton)                     break;                 //fall through             case SC_TitleBarShadeButton:                 if (!isMinimized&& (tb->titleBarFlags& Qt::WindowShadeButtonHint))                     offset += delta;                 else if (subControl == SC_TitleBarShadeButton)                     break;                 //fall through             case SC_TitleBarUnshadeButton:                 if (isMinimized&& (tb->titleBarFlags& Qt::WindowShadeButtonHint))                     offset += delta;                 else if (subControl == SC_TitleBarUnshadeButton)                     break;                 //fall through             case SC_TitleBarCloseButton:                 if (tb->titleBarFlags& Qt::WindowSystemMenuHint)                     offset += delta;                 else if (subControl == SC_TitleBarCloseButton)                     break;                  rect.setRect(width - offset - controlTop + 1, controlTop,                              buttonWidth, buttonHeight);                 break;              case SC_TitleBarSysMenu:                 {                     const int controlTop = 6;                     const int controlHeight = height - controlTop - 3;                     const int iconExtent = proxy()->pixelMetric(PM_SmallIconSize);                     QSize iconSize = tb->icon.actualSize(QSize(iconExtent, iconExtent));                     if (tb->icon.isNull())                         iconSize = QSize(controlHeight, controlHeight);                     int hPad = (controlHeight - iconSize.height())/2;                     int vPad = (controlHeight - iconSize.width())/2;                     rect = QRect(frameWidth + hPad, controlTop + vPad, iconSize.width(), iconSize.height());                 }                 break;             default:                 break;             }         }         break;      case CC_ComboBox:         if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {             int x = cmb->rect.x(), y = cmb->rect.y(), wi = cmb->rect.width(), he = cmb->rect.height();             int xpos = x;             xpos += wi - 1 - 16;              switch (subControl) {             case SC_ComboBoxFrame:                 rect = cmb->rect;                 break;              case SC_ComboBoxArrow:                 rect = QRect(xpos, y+1, 16, he-2);                 break;              case SC_ComboBoxEditField:                 rect = QRect(x+2, y+2, wi-3-16, he-4);                 break;              case SC_ComboBoxListBoxPopup:                 rect = cmb->rect;                 break;              default:                 break;             }         }         break;      default:         rect = visualRect(option->direction, option->rect,                           QWindowsStyle::subControlRect(cc, option, subControl, widget));         break;     }     return visualRect(option->direction, option->rect, rect); }  /*!     \reimp */ QSize QWindowsXPStyle::sizeFromContents(ContentsType ct, const QStyleOption *option,                                         const QSize&contentsSize, const QWidget *widget) const {     if (!QWindowsXPStylePrivate::useXP())         return QWindowsStyle::sizeFromContents(ct, option, contentsSize, widget);      QSize sz(contentsSize);     switch (ct) {     case CT_LineEdit:     case CT_ComboBox:         {             XPThemeData buttontheme(widget, 0, QWindowsXPStylePrivate::ButtonTheme);             HTHEME theme = buttontheme.handle();             MARGINS borderSize;             if (theme) {                 int result = pGetThemeMargins(theme,                                               NULL,                                               BP_PUSHBUTTON,                                               PBS_NORMAL,                                               TMT_CONTENTMARGINS,                                               NULL,&borderSize);                 if (result == S_OK) {                     sz += QSize(borderSize.cxLeftWidth + borderSize.cxRightWidth - 2,                                 borderSize.cyBottomHeight + borderSize.cyTopHeight - 2);                 }                 const int textMargins = 2*(proxy()->pixelMetric(PM_FocusFrameHMargin) + 1);                 sz += QSize(qMax(pixelMetric(QStyle::PM_ScrollBarExtent, option, widget)                                  + textMargins, 23), 0); //arrow button             }         }         break;     case CT_SpinBox:         {             //Spinbox adds frame twice             sz = QWindowsStyle::sizeFromContents(ct, option, contentsSize, widget);             int border = proxy()->pixelMetric(PM_SpinBoxFrameWidth, option, widget);             sz -= QSize(2*border, 2*border);         }         break;     case CT_TabWidget:         sz += QSize(6, 6);         break;     case CT_Menu:         sz += QSize(1, 0);         break; #ifndef QT_NO_MENUBAR     case CT_MenuBarItem:         if (!sz.isEmpty())             sz += QSize(windowsItemHMargin * 5 + 1, 6);         break; #endif     case CT_MenuItem:         if (const QStyleOptionMenuItem *menuitem = qstyleoption_cast<const QStyleOptionMenuItem *>(option))         {             if (menuitem->menuItemType != QStyleOptionMenuItem::Separator) {                 sz = QWindowsStyle::sizeFromContents(ct, option, sz, widget);                 sz.setHeight(sz.height() - 2);                 return sz;             }         }         sz = QWindowsStyle::sizeFromContents(ct, option, sz, widget);         break;      case CT_MdiControls:         if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(option)) {             int width = 0;             if (styleOpt->subControls& SC_MdiMinButton)                 width += 17 + 1;             if (styleOpt->subControls& SC_MdiNormalButton)                 width += 17 + 1;             if (styleOpt->subControls& SC_MdiCloseButton)                 width += 17 + 1;             sz = QSize(width, 19);         } else {             sz = QSize(54, 19);         }         break;      default:         sz = QWindowsStyle::sizeFromContents(ct, option, sz, widget);         break;     }      return sz; }   /*! \reimp */ int QWindowsXPStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,                                QStyleHintReturn *returnData) const {   QWindowsXPStylePrivate *d = const_cast<QWindowsXPStylePrivate*>(d_func());     if (!QWindowsXPStylePrivate::useXP())         return QWindowsStyle::styleHint(hint, option, widget, returnData);      int res = 0;     switch (hint) {      case SH_EtchDisabledText:         res = (qobject_cast<const QLabel*>(widget) != 0);         break;      case SH_SpinControls_DisableOnBounds:         res = 0;         break;      case SH_TitleBar_AutoRaise:     case SH_TitleBar_NoBorder:         res = 1;         break;      case SH_GroupBox_TextLabelColor:         if (!widget || (widget&& widget->isEnabled()))             res = d->groupBoxTextColor;         else             res = d->groupBoxTextColorDisabled;         break;      case SH_Table_GridLineColor:         res = 0xC0C0C0;         break;      case SH_WindowFrame_Mask:         {             res = 1;             QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData);             const QStyleOptionTitleBar *titlebar = qstyleoption_cast<const QStyleOptionTitleBar *>(option);             if (mask&& titlebar) {                 // Note certain themes will not return the whole window frame but only the titlebar part when                 // queried This function needs to return the entire window mask, hence we will only fetch the mask for the                 // titlebar itself and add the remaining part of the window rect at the bottom.                 int tbHeight = proxy()->pixelMetric(PM_TitleBarHeight, option, widget);                 QRect titleBarRect = option->rect;                 titleBarRect.setHeight(tbHeight);                 XPThemeData themeData;                 if (titlebar->titleBarState& Qt::WindowMinimized) {                     themeData = XPThemeData(widget, 0,                                             QWindowsXPStylePrivate::WindowTheme,                                             WP_MINCAPTION, CS_ACTIVE, titleBarRect);                 } else                     themeData = XPThemeData(widget, 0,                                             QWindowsXPStylePrivate::WindowTheme,                                             WP_CAPTION, CS_ACTIVE, titleBarRect);                 mask->region = d->region(themeData) +                                QRect(0, tbHeight, option->rect.width(), option->rect.height() - tbHeight);             }         }         break; #ifndef QT_NO_RUBBERBAND     case SH_RubberBand_Mask:         if (qstyleoption_cast<const QStyleOptionRubberBand *>(option)) {             res = 0;             break;         } #endif // QT_NO_RUBBERBAND      case SH_ItemView_DrawDelegateFrame:         res = 1;         break;      default:         res =QWindowsStyle::styleHint(hint, option, widget, returnData);     }      return res; }  /*! \reimp */ QPalette QWindowsXPStyle::standardPalette() const {     if (QWindowsXPStylePrivate::useXP()&& QApplicationPrivate::sys_pal)         return *QApplicationPrivate::sys_pal;     else         return QWindowsStyle::standardPalette(); }  /*!     \reimp */ QPixmap QWindowsXPStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *option,                                         const QWidget *widget) const {     if (!QWindowsXPStylePrivate::useXP())         return QWindowsStyle::standardPixmap(standardPixmap, option, widget);      switch(standardPixmap) {     case SP_TitleBarMaxButton:     case SP_TitleBarCloseButton:         if (qstyleoption_cast<const QStyleOptionDockWidget *>(option))         {             if (widget&& widget->isWindow()) {                 XPThemeData theme(widget, 0, QWindowsXPStylePrivate::WindowTheme, WP_SMALLCLOSEBUTTON, CBS_NORMAL);                 if (theme.isValid()) {                     SIZE sz;                     pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&sz);                     return QIcon(QWindowsStyle::standardPixmap(standardPixmap, option, widget)).pixmap(QSize(sz.cx, sz.cy));                 }             }         }         break;     default:         break;     }     return QWindowsStyle::standardPixmap(standardPixmap, option, widget); }  /*!     \internal */ QIcon QWindowsXPStyle::standardIconImplementation(StandardPixmap standardIcon,                                                   const QStyleOption *option,                                                   const QWidget *widget) const {     if (!QWindowsXPStylePrivate::useXP()) {         return QWindowsStyle::standardIconImplementation(standardIcon, option, widget);     }      QWindowsXPStylePrivate *d = const_cast<QWindowsXPStylePrivate*>(d_func());     switch(standardIcon) {     case SP_TitleBarMaxButton:         if (qstyleoption_cast<const QStyleOptionDockWidget *>(option))         {             if (d->dockFloat.isNull()) {                 XPThemeData themeSize(0, 0, QWindowsXPStylePrivate::WindowTheme,                                       WP_SMALLCLOSEBUTTON, CBS_NORMAL);                 XPThemeData theme(0, 0, QWindowsXPStylePrivate::WindowTheme,                                   WP_MAXBUTTON, MAXBS_NORMAL);                 if (theme.isValid()) {                     SIZE size;                     pGetThemePartSize(themeSize.handle(), 0, themeSize.partId, themeSize.stateId, 0, TS_TRUE,&size);                     QPixmap pm = QPixmap(size.cx, size.cy);                     pm.fill(Qt::transparent);                     QPainter p(&pm);                     theme.painter =&p;                     theme.rect = QRect(0, 0, size.cx, size.cy);                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Normal, QIcon::Off);    // Normal                     pm.fill(Qt::transparent);                     theme.stateId = MAXBS_PUSHED;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Normal, QIcon::On);     // Pressed                     pm.fill(Qt::transparent);                     theme.stateId = MAXBS_HOT;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Active, QIcon::Off);    // Hover                     pm.fill(Qt::transparent);                     theme.stateId = MAXBS_INACTIVE;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Disabled, QIcon::Off);  // Disabled                 }             }             if (widget&& widget->isWindow())                 return d->dockFloat;          }         break;     case SP_TitleBarCloseButton:         if (qstyleoption_cast<const QStyleOptionDockWidget *>(option))         {             if (d->dockClose.isNull()) {                 XPThemeData theme(0, 0, QWindowsXPStylePrivate::WindowTheme,                                   WP_SMALLCLOSEBUTTON, CBS_NORMAL);                 if (theme.isValid()) {                     SIZE size;                     pGetThemePartSize(theme.handle(), 0, theme.partId, theme.stateId, 0, TS_TRUE,&size);                     QPixmap pm = QPixmap(size.cx, size.cy);                     pm.fill(Qt::transparent);                     QPainter p(&pm);                     theme.painter =&p;                     theme.partId = WP_CLOSEBUTTON; // ####                     theme.rect = QRect(0, 0, size.cx, size.cy);                     d->drawBackground(theme);                     d->dockClose.addPixmap(pm, QIcon::Normal, QIcon::Off);    // Normal                     pm.fill(Qt::transparent);                     theme.stateId = CBS_PUSHED;                     d->drawBackground(theme);                     d->dockClose.addPixmap(pm, QIcon::Normal, QIcon::On);     // Pressed                     pm.fill(Qt::transparent);                     theme.stateId = CBS_HOT;                     d->drawBackground(theme);                     d->dockClose.addPixmap(pm, QIcon::Active, QIcon::Off);    // Hover                     pm.fill(Qt::transparent);                     theme.stateId = CBS_INACTIVE;                     d->drawBackground(theme);                     d->dockClose.addPixmap(pm, QIcon::Disabled, QIcon::Off);  // Disabled                 }             }             if (widget&& widget->isWindow())                 return d->dockClose;         }         break;     case SP_TitleBarNormalButton:         if (qstyleoption_cast<const QStyleOptionDockWidget *>(option))         {             if (d->dockFloat.isNull()) {                 XPThemeData themeSize(0, 0, QWindowsXPStylePrivate::WindowTheme,                                       WP_SMALLCLOSEBUTTON, CBS_NORMAL);                 XPThemeData theme(0, 0, QWindowsXPStylePrivate::WindowTheme,                                   WP_RESTOREBUTTON, RBS_NORMAL);                 if (theme.isValid()) {                     SIZE size;                     pGetThemePartSize(themeSize.handle(), 0, themeSize.partId, themeSize.stateId, 0, TS_TRUE,&size);                     QPixmap pm = QPixmap(size.cx, size.cy);                     pm.fill(Qt::transparent);                     QPainter p(&pm);                     theme.painter =&p;                     theme.rect = QRect(0, 0, size.cx, size.cy);                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Normal, QIcon::Off);    // Normal                     pm.fill(Qt::transparent);                     theme.stateId = RBS_PUSHED;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Normal, QIcon::On);     // Pressed                     pm.fill(Qt::transparent);                     theme.stateId = RBS_HOT;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Active, QIcon::Off);    // Hover                     pm.fill(Qt::transparent);                     theme.stateId = RBS_INACTIVE;                     d->drawBackground(theme);                     d->dockFloat.addPixmap(pm, QIcon::Disabled, QIcon::Off);  // Disabled                 }             }             if (widget&& widget->isWindow())                 return d->dockFloat;          }         break;     default:         break;     }      return QWindowsStyle::standardIconImplementation(standardIcon, option, widget); }  /*!     \internal      Constructs a QWindowsXPStyle object. */ QWindowsXPStyle::QWindowsXPStyle(QWindowsXPStylePrivate&dd) : QWindowsStyle(dd) { }   // Debugging code ---------------------------------------------------------------------[ START ]--- // The code for this point on is not compiled by default, but only used as assisting // debugging code when you uncomment the DEBUG_XP_STYLE define at the top of the file.  #ifdef DEBUG_XP_STYLE // The schema file expects these to be defined by the user. #define TMT_ENUMDEF 8 #define TMT_ENUMVAL TEXT('A') #define TMT_ENUM    TEXT('B') #define SCHEMA_STRINGS // For 2nd pass on schema file QT_BEGIN_INCLUDE_NAMESPACE #include<tmschema.h> QT_END_INCLUDE_NAMESPACE  // A property's value, type and name combo struct PropPair {     int propValue;     int propType;     LPCWSTR propName; };  // Operator for sorting of PropPairs bool operator<(PropPair a, PropPair b) {     return wcscmp(a.propName, b.propName)< 0; }  // Our list of all possible properties static QList<PropPair> all_props;   /*! \internal     Dumps a portion of the full native DIB section double buffer.     The DIB section double buffer is only used when doing special     transformations to the theme part, or when the real double     buffer in the paintengine does not have an HDC we may use     directly.     Since we cannot rely on the pixel data we get from Microsoft     when drawing into the DIB section, we use this function to     see the actual data we got, and can determin the appropriate     action. */ void QWindowsXPStylePrivate::dumpNativeDIB(int w, int h) {     if (w&& h) {         static int pCount = 0;         DWORD *bufPix = (DWORD*)bufferPixels;          char *bufferDump = new char[bufferH * bufferW * 16];         char *bufferPos = bufferDump;          memset(bufferDump, 0, sizeof(bufferDump));         bufferPos += sprintf(bufferPos, "const int pixelBufferW%d = %d;\n", pCount, w);         bufferPos += sprintf(bufferPos, "const int pixelBufferH%d = %d;\n", pCount, h);         bufferPos += sprintf(bufferPos, "const unsigned DWORD pixelBuffer%d[] = {", pCount);         for (int iy = 0; iy< h; ++iy) {             bufferPos += sprintf(bufferPos, "\n    ");             bufPix = (DWORD*)(bufferPixels + (iy * bufferW * 4));             for (int ix = 0; ix< w; ++ix) {                 bufferPos += sprintf(bufferPos, "0x%08x, ", *bufPix);                 ++bufPix;             }         }         bufferPos += sprintf(bufferPos, "\n};\n\n");         printf(bufferDump);          delete[] bufferDump;         ++pCount;     } }  /*! \internal     Shows the value of a given property for a part. */ static void showProperty(XPThemeData&themeData, const PropPair&prop) {     PROPERTYORIGIN origin = PO_NOTFOUND;     pGetThemePropertyOrigin(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&origin);     const char *originStr;     switch(origin) {     case PO_STATE:         originStr = "State ";         break;     case PO_PART:         originStr = "Part  ";         break;     case PO_CLASS:         originStr = "Class ";         break;     case PO_GLOBAL:         originStr = "Globl ";         break;     case PO_NOTFOUND:     default:         originStr = "Unkwn ";         break;     }      switch(prop.propType) {     case TMT_STRING:         {             wchar_t buffer[512];             pGetThemeString(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue, buffer, 512);             printf("  (%sString)  %-20S: %S\n", originStr, prop.propName, buffer);         }         break;     case TMT_ENUM:         {             int result = -1;             pGetThemeEnumValue(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sEnum)    %-20S: %d\n", originStr, prop.propName, result);         }         break;     case TMT_INT:         {             int result = -1;             pGetThemeInt(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sint)     %-20S: %d\n", originStr, prop.propName, result);         }         break;     case TMT_BOOL:         {             BOOL result = false;             pGetThemeBool(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sbool)    %-20S: %d\n", originStr, prop.propName, result);         }         break;     case TMT_COLOR:         {             COLORREF result = 0;             pGetThemeColor(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%scolor)   %-20S: 0x%08X\n", originStr, prop.propName, result);         }         break;     case TMT_MARGINS:         {             MARGINS result;             memset(&result, 0, sizeof(result));             pGetThemeMargins(themeData.handle(), 0, themeData.partId, themeData.stateId, prop.propValue, 0,&result);             printf("  (%smargins) %-20S: (%d, %d, %d, %d)\n", originStr,                    prop.propName, result.cxLeftWidth, result.cyTopHeight, result.cxRightWidth, result.cyBottomHeight);         }         break;     case TMT_FILENAME:         {             wchar_t buffer[512];             pGetThemeFilename(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue, buffer, 512);             printf("  (%sfilename)%-20S: %S\n", originStr, prop.propName, buffer);         }         break;     case TMT_SIZE:         {             SIZE result1;             SIZE result2;             SIZE result3;             memset(&result1, 0, sizeof(result1));             memset(&result2, 0, sizeof(result2));             memset(&result3, 0, sizeof(result3));             pGetThemePartSize(themeData.handle(), 0, themeData.partId, themeData.stateId, 0, TS_MIN,&result1);             pGetThemePartSize(themeData.handle(), 0, themeData.partId, themeData.stateId, 0, TS_TRUE,&result2);             pGetThemePartSize(themeData.handle(), 0, themeData.partId, themeData.stateId, 0, TS_DRAW,&result3);             printf("  (%ssize)    %-20S: Min (%d, %d),  True(%d, %d),  Draw(%d, %d)\n", originStr, prop.propName,                    result1.cx, result1.cy, result2.cx, result2.cy, result3.cx, result3.cy);         }         break;     case TMT_POSITION:         {             POINT result;             memset(&result, 0, sizeof(result));             pGetThemePosition(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sPosition)%-20S: (%d, %d)\n", originStr, prop.propName, result.x, result.y);         }         break;     case TMT_RECT:         {             RECT result;             memset(&result, 0, sizeof(result));             pGetThemeRect(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sRect)    %-20S: (%d, %d, %d, %d)\n", originStr, prop.propName, result.left, result.top, result.right, result.bottom);         }         break;     case TMT_FONT:         {             LOGFONT result;             memset(&result, 0, sizeof(result));             pGetThemeFont(themeData.handle(), 0, themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sFont)    %-20S: %S  height(%d)  width(%d)  weight(%d)\n", originStr, prop.propName,                    result.lfFaceName, result.lfHeight, result.lfWidth, result.lfWeight);         }         break;     case TMT_INTLIST:         {             INTLIST result;             memset(&result, 0, sizeof(result));             pGetThemeIntList(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&result);             printf("  (%sInt list)%-20S: { ", originStr, prop.propName);             for (int i = 0; i< result.iValueCount; ++i)                 printf("%d ", result.iValues[i]);             printf("}\n");         }         break;     default:         printf("    %s%S : Unknown property type (%d)!\n", originStr, prop.propName, prop.propType);     } }  /*! \internal     Dump all valid properties for a part.     If it's the first time this function is called, then the name,     enum value and documentation of all properties are shown, as     well as all global properties. */ void QWindowsXPStylePrivate::showProperties(XPThemeData&themeData) {     if (!all_props.count()) {         const TMSCHEMAINFO *infoTable = GetSchemaInfo();         for (int i = 0; i< infoTable->iPropCount; ++i) {             int propType  = infoTable->pPropTable[i].bPrimVal;             int propValue = infoTable->pPropTable[i].sEnumVal;             LPCWSTR propName = infoTable->pPropTable[i].pszName;              switch(propType) {             case TMT_ENUMDEF:             case TMT_ENUMVAL:                 continue;             default:                 if (propType != propValue) {                     PropPair prop;                     prop.propValue = propValue;                     prop.propName  = propName;                     prop.propType  = propType;                     all_props.append(prop);                 }             }         }         qSort(all_props);          {// List all properties             printf("part properties count = %d:\n", all_props.count());             printf("      Enum  Property Name        Description\n");             printf("-----------------------------------------------------------\n");             wchar_t themeName[256];             pGetCurrentThemeName(themeName, 256, 0, 0, 0, 0);             for (int j = 0; j< all_props.count(); ++j) {                 PropPair prop = all_props.at(j);                 wchar_t buf[500];                 pGetThemeDocumentationProperty(themeName, prop.propName, buf, 500);                 printf("%3d: (%4d) %-20S %S\n", j, prop.propValue, prop.propName, buf);             }         }          {// Show Global values             printf("Global Properties:\n");             for (int j = 0; j< all_props.count(); ++j) {                 PropPair prop = all_props.at(j);                 PROPERTYORIGIN origin = PO_NOTFOUND;                 pGetThemePropertyOrigin(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&origin);                 if (origin == PO_GLOBAL) {                     showProperty(themeData, prop);                 }             }         }     }      for (int j = 0; j< all_props.count(); ++j) {         PropPair prop = all_props.at(j);         PROPERTYORIGIN origin = PO_NOTFOUND;         pGetThemePropertyOrigin(themeData.handle(), themeData.partId, themeData.stateId, prop.propValue,&origin);         if (origin != PO_NOTFOUND)         {             showProperty(themeData, prop);         }     } } #endif // Debugging code -----------------------------------------------------------------------[ END ]---   QT_END_NAMESPACE  #endif //QT_NO_WINDOWSXP
end_unit
