begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qdrawutil.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qpalette.h"
end_include
begin_include
include|#
directive|include
file|<private/qpaintengineex_p.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qhexstring_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \headerfile<qdrawutil.h>     \title Drawing Utility Functions      \sa QPainter */
comment|/*!     \fn void qDrawShadeLine(QPainter *painter, int x1, int y1, int x2, int y2,                      const QPalette&palette, bool sunken,                      int lineWidth, int midLineWidth)     \relates<qdrawutil.h>      Draws a horizontal (\a y1 == \a y2) or vertical (\a x1 == \a x2)     shaded line using the given \a painter.  Note that nothing is     drawn if \a y1 != \a y2 and \a x1 != \a x2 (i.e. the line is     neither horizontal nor vertical).      The provided \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).  The given \a lineWidth     specifies the line width for each of the lines; it is not the     total line width. The given \a midLineWidth specifies the width of     a middle line drawn in the QPalette::mid() color.      The line appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style().  Use the drawing functions in QStyle to     make widgets that follow the current GUI style.       Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded line:      \snippet code/src_gui_painting_qdrawutil.cpp 0      \sa qDrawShadeRect(), qDrawShadePanel(), QStyle */
DECL|function|qDrawShadeLine
name|void
name|qDrawShadeLine
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
name|int
name|midLineWidth
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|&&
name|lineWidth
operator|>=
literal|0
operator|&&
name|midLineWidth
operator|>=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"qDrawShadeLine: Invalid parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|tlw
init|=
name|lineWidth
operator|*
literal|2
operator|+
name|midLineWidth
decl_stmt|;
comment|// total line width
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
comment|// save pen
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|color
argument_list|(
name|QPalette
operator|::
name|Dark
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|QPolygon
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
block|{
comment|// horizontal line
name|int
name|y
init|=
name|y1
operator|-
name|tlw
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
comment|// swap x1 and x2
name|int
name|t
init|=
name|x1
decl_stmt|;
name|x1
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|t
expr_stmt|;
block|}
name|x2
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw top shadow
name|a
operator|.
name|setPoints
argument_list|(
literal|3
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y
operator|+
name|tlw
operator|-
literal|1
operator|-
name|i
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y
operator|+
name|i
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y
operator|+
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|midLineWidth
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|mid
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|midLineWidth
condition|;
name|i
operator|++
control|)
comment|// draw lines in the middle
name|p
operator|->
name|drawLine
argument_list|(
name|x1
operator|+
name|lineWidth
argument_list|,
name|y
operator|+
name|lineWidth
operator|+
name|i
argument_list|,
name|x2
operator|-
name|lineWidth
argument_list|,
name|y
operator|+
name|lineWidth
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw bottom shadow
name|a
operator|.
name|setPoints
argument_list|(
literal|3
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y
operator|+
name|tlw
operator|-
name|i
operator|-
literal|1
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y
operator|+
name|tlw
operator|-
name|i
operator|-
literal|1
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
block|{
comment|// vertical line
name|int
name|x
init|=
name|x1
operator|-
name|tlw
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|y1
operator|>
name|y2
condition|)
block|{
comment|// swap y1 and y2
name|int
name|t
init|=
name|y1
decl_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|t
expr_stmt|;
block|}
name|y2
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw left shadow
name|a
operator|.
name|setPoints
argument_list|(
literal|3
argument_list|,
name|x
operator|+
name|i
argument_list|,
name|y2
argument_list|,
name|x
operator|+
name|i
argument_list|,
name|y1
operator|+
name|i
argument_list|,
name|x
operator|+
name|tlw
operator|-
literal|1
argument_list|,
name|y1
operator|+
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|midLineWidth
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|mid
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|midLineWidth
condition|;
name|i
operator|++
control|)
comment|// draw lines in the middle
name|p
operator|->
name|drawLine
argument_list|(
name|x
operator|+
name|lineWidth
operator|+
name|i
argument_list|,
name|y1
operator|+
name|lineWidth
argument_list|,
name|x
operator|+
name|lineWidth
operator|+
name|i
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw right shadow
name|a
operator|.
name|setPoints
argument_list|(
literal|3
argument_list|,
name|x
operator|+
name|lineWidth
argument_list|,
name|y2
operator|-
name|i
argument_list|,
name|x
operator|+
name|tlw
operator|-
name|i
operator|-
literal|1
argument_list|,
name|y2
operator|-
name|i
argument_list|,
name|x
operator|+
name|tlw
operator|-
name|i
operator|-
literal|1
argument_list|,
name|y1
operator|+
name|lineWidth
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawShadeRect(QPainter *painter, int x, int y, int width, int height,                      const QPalette&palette, bool sunken,                      int lineWidth, int midLineWidth,                      const QBrush *fill)     \relates<qdrawutil.h>      Draws the shaded rectangle beginning at (\a x, \a y) with the     given \a width and \a height using the provided \a painter.      The provide \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors.  The given \a lineWidth     specifies the line width for each of the lines; it is not the     total line width.  The \a midLineWidth specifies the width of a     middle line drawn in the QPalette::mid() color.  The rectangle's     interior is filled with the \a fill brush unless \a fill is 0.      The rectangle appears sunken if \a sunken is true, otherwise     raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded rectangle:      \snippet code/src_gui_painting_qdrawutil.cpp 1      \sa qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawShadeRect
name|void
name|qDrawShadeRect
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
name|int
name|midLineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
operator|&&
name|lineWidth
operator|>=
literal|0
operator|&&
name|midLineWidth
operator|>=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"qDrawShadeRect: Invalid parameters"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|x1
init|=
name|x
decl_stmt|,
name|y1
init|=
name|y
decl_stmt|,
name|x2
init|=
name|x
operator|+
name|w
operator|-
literal|1
decl_stmt|,
name|y2
init|=
name|y
operator|+
name|h
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lineWidth
operator|==
literal|1
operator|&&
name|midLineWidth
operator|==
literal|0
condition|)
block|{
comment|// standard shade rectangle
name|p
operator|->
name|drawRect
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|w
operator|-
literal|2
argument_list|,
name|h
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|QLineF
name|lines
index|[
literal|4
index|]
init|=
block|{
name|QLineF
argument_list|(
name|x1
operator|+
literal|1
argument_list|,
name|y1
operator|+
literal|1
argument_list|,
name|x2
operator|-
literal|2
argument_list|,
name|y1
operator|+
literal|1
argument_list|)
block|,
name|QLineF
argument_list|(
name|x1
operator|+
literal|1
argument_list|,
name|y1
operator|+
literal|2
argument_list|,
name|x1
operator|+
literal|1
argument_list|,
name|y2
operator|-
literal|2
argument_list|)
block|,
name|QLineF
argument_list|(
name|x1
argument_list|,
name|y2
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
block|,
name|QLineF
argument_list|(
argument|x2
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2-
literal|1
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// draw bottom/right lines
block|}
else|else
block|{
comment|// more complicated
name|int
name|m
init|=
name|lineWidth
operator|+
name|midLineWidth
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw top shadow
name|QLineF
name|lines
index|[
literal|4
index|]
init|=
block|{
name|QLineF
argument_list|(
name|x1
operator|+
name|i
argument_list|,
name|y2
operator|-
name|i
argument_list|,
name|x1
operator|+
name|i
argument_list|,
name|y1
operator|+
name|i
argument_list|)
block|,
name|QLineF
argument_list|(
name|x1
operator|+
name|i
argument_list|,
name|y1
operator|+
name|i
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y1
operator|+
name|i
argument_list|)
block|,
name|QLineF
argument_list|(
name|x1
operator|+
name|k
argument_list|,
name|y2
operator|-
name|k
argument_list|,
name|x2
operator|-
name|k
argument_list|,
name|y2
operator|-
name|k
argument_list|)
block|,
name|QLineF
argument_list|(
argument|x2-k
argument_list|,
argument|y2-k
argument_list|,
argument|x2-k
argument_list|,
argument|y1+k
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|mid
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|j
operator|=
name|lineWidth
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|midLineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw lines in the middle
name|p
operator|->
name|drawRect
argument_list|(
name|x1
operator|+
name|lineWidth
operator|+
name|i
argument_list|,
name|y1
operator|+
name|lineWidth
operator|+
name|i
argument_list|,
name|w
operator|-
name|j
operator|-
literal|1
argument_list|,
name|h
operator|-
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|k
operator|=
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// draw bottom shadow
name|QLineF
name|lines
index|[
literal|4
index|]
init|=
block|{
name|QLineF
argument_list|(
name|x1
operator|+
literal|1
operator|+
name|i
argument_list|,
name|y2
operator|-
name|i
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y2
operator|-
name|i
argument_list|)
block|,
name|QLineF
argument_list|(
name|x2
operator|-
name|i
argument_list|,
name|y2
operator|-
name|i
argument_list|,
name|x2
operator|-
name|i
argument_list|,
name|y1
operator|+
name|i
operator|+
literal|1
argument_list|)
block|,
name|QLineF
argument_list|(
name|x1
operator|+
name|k
argument_list|,
name|y2
operator|-
name|k
argument_list|,
name|x1
operator|+
name|k
argument_list|,
name|y1
operator|+
name|k
argument_list|)
block|,
name|QLineF
argument_list|(
argument|x1+k
argument_list|,
argument|y1+k
argument_list|,
argument|x2-k
argument_list|,
argument|y1+k
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fill
condition|)
block|{
name|QBrush
name|oldBrush
init|=
name|p
operator|->
name|brush
argument_list|()
decl_stmt|;
name|int
name|tlw
init|=
name|lineWidth
operator|+
name|midLineWidth
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
operator|*
name|fill
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|x
operator|+
name|tlw
argument_list|,
name|y
operator|+
name|tlw
argument_list|,
name|w
operator|-
literal|2
operator|*
name|tlw
argument_list|,
name|h
operator|-
literal|2
operator|*
name|tlw
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
comment|// restore pen
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawShadePanel(QPainter *painter, int x, int y, int width, int height,                       const QPalette&palette, bool sunken,                       int lineWidth, const QBrush *fill)     \relates<qdrawutil.h>      Draws the shaded panel beginning at (\a x, \a y) with the given \a     width and \a height using the provided \a painter and the given \a     lineWidth.      The given \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).  The panel's interior is filled     with the \a fill brush unless \a fill is 0.      The panel appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded panel:      \snippet code/src_gui_painting_qdrawutil.cpp 2      \sa qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawShadePanel
name|void
name|qDrawShadePanel
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
operator|&&
name|lineWidth
operator|>=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"qDrawShadePanel: Invalid parameters"
argument_list|)
expr_stmt|;
block|}
name|QColor
name|shade
init|=
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
decl_stmt|;
name|QColor
name|light
init|=
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
decl_stmt|;
if|if
condition|(
name|fill
condition|)
block|{
if|if
condition|(
name|fill
operator|->
name|color
argument_list|()
operator|==
name|shade
condition|)
name|shade
operator|=
name|pal
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
if|if
condition|(
name|fill
operator|->
name|color
argument_list|()
operator|==
name|light
condition|)
name|light
operator|=
name|pal
operator|.
name|midlight
argument_list|()
operator|.
name|color
argument_list|()
expr_stmt|;
block|}
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
comment|// save pen
name|QVector
argument_list|<
name|QLineF
argument_list|>
name|lines
decl_stmt|;
name|lines
operator|.
name|reserve
argument_list|(
literal|2
operator|*
name|lineWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|shade
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|light
argument_list|)
expr_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x1
operator|=
name|x
expr_stmt|;
name|y1
operator|=
name|y2
operator|=
name|y
expr_stmt|;
name|x2
operator|=
name|x
operator|+
name|w
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// top shadow
name|lines
operator|<<
name|QLineF
argument_list|(
name|x1
argument_list|,
name|y1
operator|++
argument_list|,
name|x2
operator|--
argument_list|,
name|y2
operator|++
argument_list|)
expr_stmt|;
block|}
name|x2
operator|=
name|x1
expr_stmt|;
name|y1
operator|=
name|y
operator|+
name|h
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// left shado
name|lines
operator|<<
name|QLineF
argument_list|(
name|x1
operator|++
argument_list|,
name|y1
argument_list|,
name|x2
operator|++
argument_list|,
name|y2
operator|--
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|)
expr_stmt|;
name|lines
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|sunken
condition|)
name|p
operator|->
name|setPen
argument_list|(
name|light
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|setPen
argument_list|(
name|shade
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x
expr_stmt|;
name|y1
operator|=
name|y2
operator|=
name|y
operator|+
name|h
operator|-
literal|1
expr_stmt|;
name|x2
operator|=
name|x
operator|+
name|w
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// bottom shadow
name|lines
operator|<<
name|QLineF
argument_list|(
name|x1
operator|++
argument_list|,
name|y1
operator|--
argument_list|,
name|x2
argument_list|,
name|y2
operator|--
argument_list|)
expr_stmt|;
block|}
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y
expr_stmt|;
name|y2
operator|=
name|y
operator|+
name|h
operator|-
name|lineWidth
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
block|{
comment|// right shadow
name|lines
operator|<<
name|QLineF
argument_list|(
name|x1
operator|--
argument_list|,
name|y1
operator|++
argument_list|,
name|x2
operator|--
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|drawLines
argument_list|(
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
condition|)
comment|// fill with fill color
name|p
operator|->
name|fillRect
argument_list|(
name|x
operator|+
name|lineWidth
argument_list|,
name|y
operator|+
name|lineWidth
argument_list|,
name|w
operator|-
name|lineWidth
operator|*
literal|2
argument_list|,
name|h
operator|-
name|lineWidth
operator|*
literal|2
argument_list|,
operator|*
name|fill
argument_list|)
expr_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
comment|// restore pen
block|}
end_function
begin_comment
comment|/*!   \internal   This function draws a rectangle with two pixel line width.   It is called from qDrawWinButton() and qDrawWinPanel().    c1..c4 and fill are used:      1 1 1 1 1 2     1 3 3 3 4 2     1 3 F F 4 2     1 3 F F 4 2     1 4 4 4 4 2     2 2 2 2 2 2 */
end_comment
begin_function
DECL|function|qDrawWinShades
specifier|static
name|void
name|qDrawWinShades
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c1
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c2
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c3
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c4
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|w
operator|<
literal|2
operator|||
name|h
operator|<
literal|2
condition|)
comment|// can't do anything with that
return|return;
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
name|QPoint
name|a
index|[
literal|3
index|]
init|=
block|{
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
literal|2
argument_list|)
block|,
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
block|,
name|QPoint
argument_list|(
argument|x+w-
literal|2
argument_list|,
argument|y
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|QPoint
name|b
index|[
literal|3
index|]
init|=
block|{
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
literal|1
argument_list|)
block|,
name|QPoint
argument_list|(
name|x
operator|+
name|w
operator|-
literal|1
argument_list|,
name|y
operator|+
name|h
operator|-
literal|1
argument_list|)
block|,
name|QPoint
argument_list|(
argument|x+w-
literal|1
argument_list|,
argument|y
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|c2
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|b
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|4
operator|&&
name|h
operator|>
literal|4
condition|)
block|{
name|QPoint
name|c
index|[
literal|3
index|]
init|=
block|{
name|QPoint
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
operator|+
name|h
operator|-
literal|3
argument_list|)
block|,
name|QPoint
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
operator|+
literal|1
argument_list|)
block|,
name|QPoint
argument_list|(
argument|x+w-
literal|3
argument_list|,
argument|y+
literal|1
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|c3
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|c
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|QPoint
name|d
index|[
literal|3
index|]
init|=
block|{
name|QPoint
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
operator|+
name|h
operator|-
literal|2
argument_list|)
block|,
name|QPoint
argument_list|(
name|x
operator|+
name|w
operator|-
literal|2
argument_list|,
name|y
operator|+
name|h
operator|-
literal|2
argument_list|)
block|,
name|QPoint
argument_list|(
argument|x+w-
literal|2
argument_list|,
argument|y+
literal|1
argument_list|)
block|}
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|c4
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawPolyline
argument_list|(
name|d
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
condition|)
name|p
operator|->
name|fillRect
argument_list|(
name|QRect
argument_list|(
name|x
operator|+
literal|2
argument_list|,
name|y
operator|+
literal|2
argument_list|,
name|w
operator|-
literal|4
argument_list|,
name|h
operator|-
literal|4
argument_list|)
argument_list|,
operator|*
name|fill
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawWinButton(QPainter *painter, int x, int y, int width, int height,                      const QPalette&palette, bool sunken,                      const QBrush *fill)     \relates<qdrawutil.h>      Draws the Windows-style button specified by the given point (\a x,     \a y}, \a width and \a height using the provided \a painter with a     line width of 2 pixels. The button's interior is filled with the     \a{fill} brush unless \a fill is 0.      The given \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).      The button appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style()-> Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      \sa qDrawWinPanel(), QStyle */
end_comment
begin_function
DECL|function|qDrawWinButton
name|void
name|qDrawWinButton
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|sunken
condition|)
name|qDrawWinShades
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|pal
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|button
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|fill
argument_list|)
expr_stmt|;
else|else
name|qDrawWinShades
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|button
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawWinPanel(QPainter *painter, int x, int y, int width, int height,                     const QPalette&palette, bool        sunken,                     const QBrush *fill)     \relates<qdrawutil.h>      Draws the Windows-style panel specified by the given point(\a x,     \a y), \a width and \a height using the provided \a painter with a     line width of 2 pixels. The button's interior is filled with the     \a fill brush unless \a fill is 0.      The given \a palette specifies the shading colors.  The panel     appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded panel:      \snippet code/src_gui_painting_qdrawutil.cpp 3      \sa qDrawShadePanel(), qDrawWinButton(), QStyle */
end_comment
begin_function
DECL|function|qDrawWinPanel
name|void
name|qDrawWinPanel
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|sunken
condition|)
name|qDrawWinShades
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|midlight
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|fill
argument_list|)
expr_stmt|;
else|else
name|qDrawWinShades
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|pal
operator|.
name|light
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|shadow
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|midlight
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|pal
operator|.
name|dark
argument_list|()
operator|.
name|color
argument_list|()
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawPlainRect(QPainter *painter, int x, int y, int width, int height, const QColor&lineColor,                      int lineWidth, const QBrush *fill)     \relates<qdrawutil.h>      Draws the plain rectangle beginning at (\a x, \a y) with the given     \a width and \a height, using the specified \a painter, \a lineColor     and \a lineWidth. The rectangle's interior is filled with the \a     fill brush unless \a fill is 0.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a plain rectangle:      \snippet code/src_gui_painting_qdrawutil.cpp 4      \sa qDrawShadeRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawPlainRect
name|void
name|qDrawPlainRect
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c
parameter_list|,
name|int
name|lineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|h
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
operator|&&
name|lineWidth
operator|>=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"qDrawPlainRect: Invalid parameters"
argument_list|)
expr_stmt|;
block|}
name|QPen
name|oldPen
init|=
name|p
operator|->
name|pen
argument_list|()
decl_stmt|;
name|QBrush
name|oldBrush
init|=
name|p
operator|->
name|brush
argument_list|()
decl_stmt|;
name|p
operator|->
name|setPen
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|Qt
operator|::
name|NoBrush
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineWidth
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|drawRect
argument_list|(
name|x
operator|+
name|i
argument_list|,
name|y
operator|+
name|i
argument_list|,
name|w
operator|-
name|i
operator|*
literal|2
operator|-
literal|1
argument_list|,
name|h
operator|-
name|i
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
condition|)
block|{
comment|// fill with fill color
name|p
operator|->
name|setPen
argument_list|(
name|Qt
operator|::
name|NoPen
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
operator|*
name|fill
argument_list|)
expr_stmt|;
name|p
operator|->
name|drawRect
argument_list|(
name|x
operator|+
name|lineWidth
argument_list|,
name|y
operator|+
name|lineWidth
argument_list|,
name|w
operator|-
name|lineWidth
operator|*
literal|2
argument_list|,
name|h
operator|-
name|lineWidth
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|setPen
argument_list|(
name|oldPen
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Overloaded functions.  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn void qDrawShadeLine(QPainter *painter, const QPoint&p1, const QPoint&p2,              const QPalette&palette, bool sunken, int lineWidth, int midLineWidth)     \relates<qdrawutil.h>     \overload      Draws a horizontal or vertical shaded line between \a p1 and \a p2     using the given \a painter.  Note that nothing is drawn if the line     between the points would be neither horizontal nor vertical.      The provided \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).  The given \a lineWidth     specifies the line width for each of the lines; it is not the     total line width. The given \a midLineWidth specifies the width of     a middle line drawn in the QPalette::mid() color.      The line appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style().  Use the drawing functions in QStyle to     make widgets that follow the current GUI style.       Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded line:      \snippet code/src_gui_painting_qdrawutil.cpp 5      \sa qDrawShadeRect(), qDrawShadePanel(), QStyle */
end_comment
begin_function
DECL|function|qDrawShadeLine
name|void
name|qDrawShadeLine
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p1
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p2
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
name|int
name|midLineWidth
parameter_list|)
block|{
name|qDrawShadeLine
argument_list|(
name|p
argument_list|,
name|p1
operator|.
name|x
argument_list|()
argument_list|,
name|p1
operator|.
name|y
argument_list|()
argument_list|,
name|p2
operator|.
name|x
argument_list|()
argument_list|,
name|p2
operator|.
name|y
argument_list|()
argument_list|,
name|pal
argument_list|,
name|sunken
argument_list|,
name|lineWidth
argument_list|,
name|midLineWidth
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawShadeRect(QPainter *painter, const QRect&rect, const QPalette&palette,              bool sunken, int lineWidth, int midLineWidth, const QBrush *fill)     \relates<qdrawutil.h>     \overload      Draws the shaded rectangle specified by \a rect using the given \a painter.      The provide \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors.  The given \a lineWidth     specifies the line width for each of the lines; it is not the     total line width.  The \a midLineWidth specifies the width of a     middle line drawn in the QPalette::mid() color.  The rectangle's     interior is filled with the \a fill brush unless \a fill is 0.      The rectangle appears sunken if \a sunken is true, otherwise     raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded rectangle:      \snippet code/src_gui_painting_qdrawutil.cpp 6      \sa qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawShadeRect
name|void
name|qDrawShadeRect
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
name|int
name|midLineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
name|qDrawShadeRect
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pal
argument_list|,
name|sunken
argument_list|,
name|lineWidth
argument_list|,
name|midLineWidth
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawShadePanel(QPainter *painter, const QRect&rect, const QPalette&palette,              bool sunken, int lineWidth, const QBrush *fill)     \relates<qdrawutil.h>     \overload      Draws the shaded panel at the rectangle specified by \a rect using the     given \a painter and the given \a lineWidth.      The given \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).  The panel's interior is filled     with the \a fill brush unless \a fill is 0.      The panel appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded panel:      \snippet code/src_gui_painting_qdrawutil.cpp 7      \sa qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawShadePanel
name|void
name|qDrawShadePanel
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
name|int
name|lineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
name|qDrawShadePanel
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pal
argument_list|,
name|sunken
argument_list|,
name|lineWidth
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawWinButton(QPainter *painter, const QRect&rect, const QPalette&palette,              bool sunken, const QBrush *fill)     \relates<qdrawutil.h>     \overload      Draws the Windows-style button at the rectangle specified by \a rect using     the given \a painter with a line width of 2 pixels. The button's interior     is filled with the \a{fill} brush unless \a fill is 0.      The given \a palette specifies the shading colors (\l     {QPalette::light()}{light}, \l {QPalette::dark()}{dark} and \l     {QPalette::mid()}{middle} colors).      The button appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style()-> Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      \sa qDrawWinPanel(), QStyle */
end_comment
begin_function
DECL|function|qDrawWinButton
name|void
name|qDrawWinButton
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
name|qDrawWinButton
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pal
argument_list|,
name|sunken
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawWinPanel(QPainter *painter, const QRect&rect, const QPalette&palette,              bool sunken, const QBrush *fill)     \overload      Draws the Windows-style panel at the rectangle specified by \a rect using     the given \a painter with a line width of 2 pixels. The button's interior     is filled with the \a fill brush unless \a fill is 0.      The given \a palette specifies the shading colors.  The panel     appears sunken if \a sunken is true, otherwise raised.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a shaded panel:      \snippet code/src_gui_painting_qdrawutil.cpp 8      \sa qDrawShadePanel(), qDrawWinButton(), QStyle */
end_comment
begin_function
DECL|function|qDrawWinPanel
name|void
name|qDrawWinPanel
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QPalette
modifier|&
name|pal
parameter_list|,
name|bool
name|sunken
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
name|qDrawWinPanel
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|pal
argument_list|,
name|sunken
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void qDrawPlainRect(QPainter *painter, const QRect&rect, const QColor&lineColor, int lineWidth, const QBrush *fill)     \relates<qdrawutil.h>     \overload      Draws the plain rectangle specified by \a rect using the given \a painter,     \a lineColor and \a lineWidth. The rectangle's interior is filled with the     \a fill brush unless \a fill is 0.      \warning This function does not look at QWidget::style() or     QApplication::style(). Use the drawing functions in QStyle to make     widgets that follow the current GUI style.      Alternatively you can use a QFrame widget and apply the     QFrame::setFrameStyle() function to display a plain rectangle:      \snippet code/src_gui_painting_qdrawutil.cpp 9      \sa qDrawShadeRect(), QStyle */
end_comment
begin_function
DECL|function|qDrawPlainRect
name|void
name|qDrawPlainRect
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRect
modifier|&
name|r
parameter_list|,
specifier|const
name|QColor
modifier|&
name|c
parameter_list|,
name|int
name|lineWidth
parameter_list|,
specifier|const
name|QBrush
modifier|*
name|fill
parameter_list|)
block|{
name|qDrawPlainRect
argument_list|(
name|p
argument_list|,
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|c
argument_list|,
name|lineWidth
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTileRules     \since 4.6      \inmodule QtWidgets       \brief The QTileRules class provides the rules used to draw a     pixmap or image split into nine segments.       Spliiting is similar to \l{http://www.w3.org/TR/css3-background/}{CSS3 border-images}.      \sa Qt::TileRule, QMargins */
end_comment
begin_comment
comment|/*! \fn QTileRules::QTileRules(Qt::TileRule horizontalRule, Qt::TileRule verticalRule)   Constructs a QTileRules with the given \a horizontalRule and   \a verticalRule.  */
end_comment
begin_comment
comment|/*! \fn QTileRules::QTileRules(Qt::TileRule rule)   Constructs a QTileRules with the given \a rule used for both   the horizontal rule and the vertical rule.  */
end_comment
begin_comment
comment|/*!     \fn void qDrawBorderPixmap(QPainter *painter, const QRect&target, const QMargins&margins, const QPixmap&pixmap)     \relates<qdrawutil.h>     \since 4.6     \overload      \brief The qDrawBorderPixmap function is for drawing a pixmap into     the margins of a rectangle.      Draws the given \a pixmap into the given \a target rectangle, using the     given \a painter. The pixmap will be split into nine segments and drawn     according to the \a margins structure. */
end_comment
begin_typedef
DECL|typedef|QPixmapFragmentsArray
typedef|typedef
name|QVarLengthArray
argument_list|<
name|QPainter
operator|::
name|PixmapFragment
argument_list|,
literal|16
argument_list|>
name|QPixmapFragmentsArray
typedef|;
end_typedef
begin_comment
comment|/*!     \since 4.6      Draws the indicated \a sourceRect rectangle from the given \a pixmap into     the given \a targetRect rectangle, using the given \a painter. The pixmap     will be split into nine segments according to the given \a targetMargins     and \a sourceMargins structures. Finally, the pixmap will be drawn     according to the given \a rules.      This function is used to draw a scaled pixmap, similar to     \l{http://www.w3.org/TR/css3-background/}{CSS3 border-images}      \sa Qt::TileRule, QTileRules, QMargins */
end_comment
begin_function
DECL|function|qDrawBorderPixmap
name|void
name|qDrawBorderPixmap
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRect
modifier|&
name|targetRect
parameter_list|,
specifier|const
name|QMargins
modifier|&
name|targetMargins
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sourceRect
parameter_list|,
specifier|const
name|QMargins
modifier|&
name|sourceMargins
parameter_list|,
specifier|const
name|QTileRules
modifier|&
name|rules
parameter_list|,
name|QDrawBorderPixmap
operator|::
name|DrawingHints
name|hints
parameter_list|)
block|{
name|QPainter
operator|::
name|PixmapFragment
name|d
decl_stmt|;
name|d
operator|.
name|opacity
operator|=
literal|1.0
expr_stmt|;
name|d
operator|.
name|rotation
operator|=
literal|0.0
expr_stmt|;
name|QPixmapFragmentsArray
name|opaqueData
decl_stmt|;
name|QPixmapFragmentsArray
name|translucentData
decl_stmt|;
comment|// source center
specifier|const
name|int
name|sourceCenterTop
init|=
name|sourceRect
operator|.
name|top
argument_list|()
operator|+
name|sourceMargins
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sourceCenterLeft
init|=
name|sourceRect
operator|.
name|left
argument_list|()
operator|+
name|sourceMargins
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|sourceCenterBottom
init|=
name|sourceRect
operator|.
name|bottom
argument_list|()
operator|-
name|sourceMargins
operator|.
name|bottom
argument_list|()
operator|+
literal|1
decl_stmt|;
specifier|const
name|int
name|sourceCenterRight
init|=
name|sourceRect
operator|.
name|right
argument_list|()
operator|-
name|sourceMargins
operator|.
name|right
argument_list|()
operator|+
literal|1
decl_stmt|;
specifier|const
name|int
name|sourceCenterWidth
init|=
name|sourceCenterRight
operator|-
name|sourceCenterLeft
decl_stmt|;
specifier|const
name|int
name|sourceCenterHeight
init|=
name|sourceCenterBottom
operator|-
name|sourceCenterTop
decl_stmt|;
comment|// target center
specifier|const
name|int
name|targetCenterTop
init|=
name|targetRect
operator|.
name|top
argument_list|()
operator|+
name|targetMargins
operator|.
name|top
argument_list|()
decl_stmt|;
specifier|const
name|int
name|targetCenterLeft
init|=
name|targetRect
operator|.
name|left
argument_list|()
operator|+
name|targetMargins
operator|.
name|left
argument_list|()
decl_stmt|;
specifier|const
name|int
name|targetCenterBottom
init|=
name|targetRect
operator|.
name|bottom
argument_list|()
operator|-
name|targetMargins
operator|.
name|bottom
argument_list|()
operator|+
literal|1
decl_stmt|;
specifier|const
name|int
name|targetCenterRight
init|=
name|targetRect
operator|.
name|right
argument_list|()
operator|-
name|targetMargins
operator|.
name|right
argument_list|()
operator|+
literal|1
decl_stmt|;
specifier|const
name|int
name|targetCenterWidth
init|=
name|targetCenterRight
operator|-
name|targetCenterLeft
decl_stmt|;
specifier|const
name|int
name|targetCenterHeight
init|=
name|targetCenterBottom
operator|-
name|targetCenterTop
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|qreal
argument_list|,
literal|16
argument_list|>
name|xTarget
decl_stmt|;
comment|// x-coordinates of target rectangles
name|QVarLengthArray
argument_list|<
name|qreal
argument_list|,
literal|16
argument_list|>
name|yTarget
decl_stmt|;
comment|// y-coordinates of target rectangles
name|int
name|columns
init|=
literal|3
decl_stmt|;
name|int
name|rows
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|rules
operator|.
name|horizontal
operator|!=
name|Qt
operator|::
name|StretchTile
operator|&&
name|sourceCenterWidth
operator|!=
literal|0
condition|)
name|columns
operator|=
name|qMax
argument_list|(
literal|3
argument_list|,
literal|2
operator|+
name|qCeil
argument_list|(
name|targetCenterWidth
operator|/
name|qreal
argument_list|(
name|sourceCenterWidth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rules
operator|.
name|vertical
operator|!=
name|Qt
operator|::
name|StretchTile
operator|&&
name|sourceCenterHeight
operator|!=
literal|0
condition|)
name|rows
operator|=
name|qMax
argument_list|(
literal|3
argument_list|,
literal|2
operator|+
name|qCeil
argument_list|(
name|targetCenterHeight
operator|/
name|qreal
argument_list|(
name|sourceCenterHeight
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xTarget
operator|.
name|resize
argument_list|(
name|columns
operator|+
literal|1
argument_list|)
expr_stmt|;
name|yTarget
operator|.
name|resize
argument_list|(
name|rows
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bool
name|oldAA
init|=
name|painter
operator|->
name|testRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
decl_stmt|;
if|if
condition|(
name|painter
operator|->
name|paintEngine
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|QPaintEngine
operator|::
name|OpenGL
operator|&&
name|painter
operator|->
name|paintEngine
argument_list|()
operator|->
name|type
argument_list|()
operator|!=
name|QPaintEngine
operator|::
name|OpenGL2
operator|&&
name|oldAA
operator|&&
name|painter
operator|->
name|combinedTransform
argument_list|()
operator|.
name|type
argument_list|()
operator|!=
name|QTransform
operator|::
name|TxNone
condition|)
block|{
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|xTarget
index|[
literal|0
index|]
operator|=
name|targetRect
operator|.
name|left
argument_list|()
expr_stmt|;
name|xTarget
index|[
literal|1
index|]
operator|=
name|targetCenterLeft
expr_stmt|;
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|=
name|targetCenterRight
expr_stmt|;
name|xTarget
index|[
name|columns
index|]
operator|=
name|targetRect
operator|.
name|left
argument_list|()
operator|+
name|targetRect
operator|.
name|width
argument_list|()
expr_stmt|;
name|yTarget
index|[
literal|0
index|]
operator|=
name|targetRect
operator|.
name|top
argument_list|()
expr_stmt|;
name|yTarget
index|[
literal|1
index|]
operator|=
name|targetCenterTop
expr_stmt|;
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|=
name|targetCenterBottom
expr_stmt|;
name|yTarget
index|[
name|rows
index|]
operator|=
name|targetRect
operator|.
name|top
argument_list|()
operator|+
name|targetRect
operator|.
name|height
argument_list|()
expr_stmt|;
name|qreal
name|dx
init|=
name|targetCenterWidth
decl_stmt|;
name|qreal
name|dy
init|=
name|targetCenterHeight
decl_stmt|;
switch|switch
condition|(
name|rules
operator|.
name|horizontal
condition|)
block|{
case|case
name|Qt
operator|::
name|StretchTile
case|:
name|dx
operator|=
name|targetCenterWidth
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RepeatTile
case|:
name|dx
operator|=
name|sourceCenterWidth
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RoundTile
case|:
name|dx
operator|=
name|targetCenterWidth
operator|/
name|qreal
argument_list|(
name|columns
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|xTarget
index|[
name|i
index|]
operator|=
name|xTarget
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|dx
expr_stmt|;
switch|switch
condition|(
name|rules
operator|.
name|vertical
condition|)
block|{
case|case
name|Qt
operator|::
name|StretchTile
case|:
name|dy
operator|=
name|targetCenterHeight
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RepeatTile
case|:
name|dy
operator|=
name|sourceCenterHeight
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|RoundTile
case|:
name|dy
operator|=
name|targetCenterHeight
operator|/
name|qreal
argument_list|(
name|rows
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|rows
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|yTarget
index|[
name|i
index|]
operator|=
name|yTarget
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|dy
expr_stmt|;
comment|// corners
if|if
condition|(
name|targetMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
operator|&&
name|targetMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// top left
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
literal|1
index|]
operator|+
name|xTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
literal|1
index|]
operator|+
name|yTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceRect
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceRect
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
literal|1
index|]
operator|-
name|xTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
literal|1
index|]
operator|-
name|yTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueTopLeft
condition|)
name|opaqueData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|translucentData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
operator|&&
name|targetMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// top right
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|columns
index|]
operator|+
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
literal|1
index|]
operator|+
name|yTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterRight
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceRect
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|right
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
name|columns
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
literal|1
index|]
operator|-
name|yTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueTopRight
condition|)
name|opaqueData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|translucentData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
operator|&&
name|targetMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// bottom left
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
literal|1
index|]
operator|+
name|xTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|rows
index|]
operator|+
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceRect
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterBottom
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|bottom
argument_list|()
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
literal|1
index|]
operator|-
name|xTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
name|rows
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueBottomLeft
condition|)
name|opaqueData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|translucentData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
operator|&&
name|targetMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// bottom right
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|columns
index|]
operator|+
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|rows
index|]
operator|+
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterRight
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterBottom
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|right
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|bottom
argument_list|()
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
name|columns
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
name|rows
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
if|if
condition|(
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueBottomRight
condition|)
name|opaqueData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|translucentData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|// horizontal edges
if|if
condition|(
name|targetCenterWidth
operator|>
literal|0
operator|&&
name|sourceCenterWidth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|targetMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|top
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// top
name|QPixmapFragmentsArray
modifier|&
name|data
init|=
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueTop
condition|?
name|opaqueData
else|:
name|translucentData
decl_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterLeft
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceRect
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceCenterWidth
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|top
argument_list|()
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
literal|1
index|]
operator|+
name|yTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|dx
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
literal|1
index|]
operator|-
name|yTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|xTarget
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|horizontal
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|width
operator|=
operator|(
operator|(
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleX
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|bottom
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// bottom
name|QPixmapFragmentsArray
modifier|&
name|data
init|=
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueBottom
condition|?
name|opaqueData
else|:
name|translucentData
decl_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterLeft
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterBottom
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceCenterWidth
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceMargins
operator|.
name|bottom
argument_list|()
expr_stmt|;
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|rows
index|]
operator|+
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|dx
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|qreal
argument_list|(
name|yTarget
index|[
name|rows
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|height
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|xTarget
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|horizontal
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|width
operator|=
operator|(
operator|(
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleX
operator|)
expr_stmt|;
block|}
block|}
comment|// vertical edges
if|if
condition|(
name|targetCenterHeight
operator|>
literal|0
operator|&&
name|sourceCenterHeight
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|targetMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|left
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// left
name|QPixmapFragmentsArray
modifier|&
name|data
init|=
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueLeft
condition|?
name|opaqueData
else|:
name|translucentData
decl_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceRect
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterTop
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|left
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceCenterHeight
expr_stmt|;
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
literal|1
index|]
operator|+
name|xTarget
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
literal|1
index|]
operator|-
name|xTarget
index|[
literal|0
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|dy
operator|/
name|d
operator|.
name|height
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rows
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|yTarget
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|vertical
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|height
operator|=
operator|(
operator|(
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|targetMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
operator|&&
name|sourceMargins
operator|.
name|right
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// right
name|QPixmapFragmentsArray
modifier|&
name|data
init|=
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueRight
condition|?
name|opaqueData
else|:
name|translucentData
decl_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterRight
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterTop
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceMargins
operator|.
name|right
argument_list|()
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceCenterHeight
expr_stmt|;
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|columns
index|]
operator|+
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|)
operator|)
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|qreal
argument_list|(
name|xTarget
index|[
name|columns
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
argument_list|)
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|dy
operator|/
name|d
operator|.
name|height
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rows
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|yTarget
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|vertical
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|height
operator|=
operator|(
operator|(
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleY
operator|)
expr_stmt|;
block|}
block|}
comment|// center
if|if
condition|(
name|targetCenterWidth
operator|>
literal|0
operator|&&
name|targetCenterHeight
operator|>
literal|0
operator|&&
name|sourceCenterWidth
operator|>
literal|0
operator|&&
name|sourceCenterHeight
operator|>
literal|0
condition|)
block|{
name|QPixmapFragmentsArray
modifier|&
name|data
init|=
name|hints
operator|&
name|QDrawBorderPixmap
operator|::
name|OpaqueCenter
condition|?
name|opaqueData
else|:
name|translucentData
decl_stmt|;
name|d
operator|.
name|sourceLeft
operator|=
name|sourceCenterLeft
expr_stmt|;
name|d
operator|.
name|sourceTop
operator|=
name|sourceCenterTop
expr_stmt|;
name|d
operator|.
name|width
operator|=
name|sourceCenterWidth
expr_stmt|;
name|d
operator|.
name|height
operator|=
name|sourceCenterHeight
expr_stmt|;
name|d
operator|.
name|scaleX
operator|=
name|dx
operator|/
name|d
operator|.
name|width
expr_stmt|;
name|d
operator|.
name|scaleY
operator|=
name|dy
operator|/
name|d
operator|.
name|height
expr_stmt|;
name|qreal
name|repeatWidth
init|=
operator|(
name|xTarget
index|[
name|columns
operator|-
literal|1
index|]
operator|-
name|xTarget
index|[
name|columns
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleX
decl_stmt|;
name|qreal
name|repeatHeight
init|=
operator|(
name|yTarget
index|[
name|rows
operator|-
literal|1
index|]
operator|-
name|yTarget
index|[
name|rows
operator|-
literal|2
index|]
operator|)
operator|/
name|d
operator|.
name|scaleY
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|rows
operator|-
literal|1
condition|;
operator|++
name|j
control|)
block|{
name|d
operator|.
name|y
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|yTarget
index|[
name|j
operator|+
literal|1
index|]
operator|+
name|yTarget
index|[
name|j
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|.
name|x
operator|=
operator|(
literal|0.5
operator|*
operator|(
name|xTarget
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|xTarget
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|horizontal
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|.
name|width
operator|=
name|repeatWidth
expr_stmt|;
block|}
if|if
condition|(
name|rules
operator|.
name|vertical
operator|==
name|Qt
operator|::
name|RepeatTile
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|data
index|[
name|data
operator|.
name|size
argument_list|()
operator|-
name|i
index|]
operator|.
name|height
operator|=
name|repeatHeight
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opaqueData
operator|.
name|size
argument_list|()
condition|)
name|painter
operator|->
name|drawPixmapFragments
argument_list|(
name|opaqueData
operator|.
name|data
argument_list|()
argument_list|,
name|opaqueData
operator|.
name|size
argument_list|()
argument_list|,
name|pixmap
argument_list|,
name|QPainter
operator|::
name|OpaqueHint
argument_list|)
expr_stmt|;
if|if
condition|(
name|translucentData
operator|.
name|size
argument_list|()
condition|)
name|painter
operator|->
name|drawPixmapFragments
argument_list|(
name|translucentData
operator|.
name|data
argument_list|()
argument_list|,
name|translucentData
operator|.
name|size
argument_list|()
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldAA
condition|)
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
