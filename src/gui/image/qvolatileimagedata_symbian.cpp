begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qvolatileimagedata_p.h"
end_include
begin_include
include|#
directive|include
file|<fbs.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qt_s60_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/qpaintengine.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qimage_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|rasterizeBitmap
specifier|static
name|CFbsBitmap
modifier|*
name|rasterizeBitmap
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|,
name|TDisplayMode
name|newMode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bitmap
condition|)
block|{
return|return
literal|0
return|;
block|}
name|QScopedPointer
argument_list|<
name|CFbsBitmap
argument_list|>
name|newBitmap
argument_list|(
operator|new
name|CFbsBitmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBitmap
operator|->
name|Create
argument_list|(
name|bitmap
operator|->
name|SizeInPixels
argument_list|()
argument_list|,
name|newMode
argument_list|)
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVolatileImage: Failed to create new bitmap"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CFbsBitmapDevice
modifier|*
name|bitmapDevice
init|=
literal|0
decl_stmt|;
name|CFbsBitGc
modifier|*
name|bitmapGc
init|=
literal|0
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|bitmapDevice
operator|=
name|CFbsBitmapDevice
operator|::
name|NewL
argument_list|(
name|newBitmap
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QScopedPointer
argument_list|<
name|CFbsBitmapDevice
argument_list|>
name|bitmapDevicePtr
argument_list|(
name|bitmapDevice
argument_list|)
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
name|bitmapGc
operator|=
name|CFbsBitGc
operator|::
name|NewL
argument_list|()
argument_list|)
expr_stmt|;
name|bitmapGc
operator|->
name|Activate
argument_list|(
name|bitmapDevice
argument_list|)
expr_stmt|;
name|bitmapGc
operator|->
name|BitBlt
argument_list|(
name|TPoint
argument_list|()
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
operator|delete
name|bitmapGc
expr_stmt|;
return|return
name|newBitmap
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|format2TDisplayMode
specifier|static
specifier|inline
name|TDisplayMode
name|format2TDisplayMode
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
name|TDisplayMode
name|mode
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|mode
operator|=
name|EGray2
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|mode
operator|=
name|EColor256
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|mode
operator|=
name|EColor4K
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|mode
operator|=
name|EColor64K
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|mode
operator|=
name|EColor16M
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|mode
operator|=
name|EColor16MU
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
name|mode
operator|=
name|EColor16MA
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|mode
operator|=
name|Q_SYMBIAN_ECOLOR16MAP
expr_stmt|;
break|break;
default|default:
name|mode
operator|=
name|ENone
expr_stmt|;
break|break;
block|}
return|return
name|mode
return|;
block|}
end_function
begin_function
DECL|function|imageToBitmap
specifier|static
name|CFbsBitmap
modifier|*
name|imageToBitmap
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
name|CFbsBitmap
modifier|*
name|bitmap
init|=
operator|new
name|CFbsBitmap
decl_stmt|;
if|if
condition|(
name|bitmap
operator|->
name|Create
argument_list|(
name|TSize
argument_list|(
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|)
argument_list|,
name|format2TDisplayMode
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
argument_list|)
operator|==
name|KErrNone
condition|)
block|{
name|bitmap
operator|->
name|BeginDataAccess
argument_list|()
expr_stmt|;
name|uchar
modifier|*
name|dptr
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|bitmap
operator|->
name|DataAddress
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|bmpLineLen
init|=
name|bitmap
operator|->
name|DataStride
argument_list|()
decl_stmt|;
name|int
name|imgLineLen
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|bmpLineLen
operator|==
name|imgLineLen
condition|)
block|{
name|qMemCopy
argument_list|(
name|dptr
argument_list|,
name|image
operator|.
name|constBits
argument_list|()
argument_list|,
name|image
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|len
init|=
name|qMin
argument_list|(
name|bmpLineLen
argument_list|,
name|imgLineLen
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
name|image
operator|.
name|constBits
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|image
operator|.
name|height
argument_list|()
condition|;
operator|++
name|y
control|)
block|{
name|qMemCopy
argument_list|(
name|dptr
argument_list|,
name|sptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dptr
operator|+=
name|bmpLineLen
expr_stmt|;
name|sptr
operator|+=
name|imgLineLen
expr_stmt|;
block|}
block|}
name|bitmap
operator|->
name|EndDataAccess
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QVolatileImage: Failed to create source bitmap"
argument_list|)
expr_stmt|;
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|bitmap
return|;
block|}
end_function
begin_function
DECL|function|copyData
specifier|static
name|CFbsBitmap
modifier|*
name|copyData
parameter_list|(
specifier|const
name|QVolatileImageData
modifier|&
name|source
parameter_list|)
block|{
name|source
operator|.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|CFbsBitmap
modifier|*
name|bmp
init|=
name|imageToBitmap
argument_list|(
name|source
operator|.
name|image
argument_list|)
decl_stmt|;
name|source
operator|.
name|endDataAccess
argument_list|()
expr_stmt|;
return|return
name|bmp
return|;
block|}
end_function
begin_function
DECL|function|convertData
specifier|static
name|CFbsBitmap
modifier|*
name|convertData
parameter_list|(
specifier|const
name|QVolatileImageData
modifier|&
name|source
parameter_list|,
name|QImage
operator|::
name|Format
name|newFormat
parameter_list|)
block|{
name|source
operator|.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QImage
name|img
init|=
name|source
operator|.
name|image
operator|.
name|convertToFormat
argument_list|(
name|newFormat
argument_list|)
decl_stmt|;
name|CFbsBitmap
modifier|*
name|bmp
init|=
name|imageToBitmap
argument_list|(
name|img
argument_list|)
decl_stmt|;
name|source
operator|.
name|endDataAccess
argument_list|()
expr_stmt|;
return|return
name|bmp
return|;
block|}
end_function
begin_function
DECL|function|duplicateBitmap
specifier|static
name|CFbsBitmap
modifier|*
name|duplicateBitmap
parameter_list|(
specifier|const
name|CFbsBitmap
modifier|&
name|sourceBitmap
parameter_list|)
block|{
name|CFbsBitmap
modifier|*
name|bitmap
init|=
operator|new
name|CFbsBitmap
decl_stmt|;
if|if
condition|(
name|bitmap
operator|->
name|Duplicate
argument_list|(
name|sourceBitmap
operator|.
name|Handle
argument_list|()
argument_list|)
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVolatileImage: Failed to duplicate source bitmap"
argument_list|)
expr_stmt|;
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|bitmap
return|;
block|}
end_function
begin_function
DECL|function|createBitmap
specifier|static
name|CFbsBitmap
modifier|*
name|createBitmap
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
name|CFbsBitmap
modifier|*
name|bitmap
init|=
operator|new
name|CFbsBitmap
decl_stmt|;
if|if
condition|(
name|bitmap
operator|->
name|Create
argument_list|(
name|TSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|format2TDisplayMode
argument_list|(
name|format
argument_list|)
argument_list|)
operator|!=
name|KErrNone
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVolatileImage: Failed to create source bitmap %d,%d (%d)"
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|bitmap
return|;
block|}
end_function
begin_function
DECL|function|bitmapNeedsCopy
specifier|static
specifier|inline
name|bool
name|bitmapNeedsCopy
parameter_list|(
name|CFbsBitmap
modifier|*
name|bitmap
parameter_list|)
block|{
name|bool
name|needsCopy
init|=
name|bitmap
operator|->
name|IsCompressedInRAM
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_SYMBIAN_HAS_EXTENDED_BITMAP_TYPE
name|needsCopy
operator||=
operator|(
name|bitmap
operator|->
name|ExtendedBitmapType
argument_list|()
operator|!=
name|KNullUid
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|needsCopy
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|cleanup_function_registered
specifier|static
name|bool
name|cleanup_function_registered
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|firstImageData
specifier|static
name|QVolatileImageData
modifier|*
name|firstImageData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cleanup
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|RFbsSession
operator|::
name|GetSession
argument_list|()
condition|)
block|{
name|QVolatileImageData
modifier|*
name|imageData
init|=
name|firstImageData
decl_stmt|;
while|while
condition|(
name|imageData
condition|)
block|{
name|imageData
operator|->
name|release
argument_list|()
expr_stmt|;
name|imageData
operator|=
name|imageData
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|ensureCleanup
specifier|static
name|void
name|ensureCleanup
parameter_list|()
block|{
comment|// Destroy all underlying bitmaps in a post routine to prevent panics.
comment|// This is a must because CFbsBitmap destructor needs the fbs session,
comment|// that was used to create the bitmap, to be open still.
if|if
condition|(
operator|!
name|cleanup_function_registered
condition|)
block|{
name|qAddPostRoutine
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup_function_registered
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerImageData
specifier|static
name|void
name|registerImageData
parameter_list|(
name|QVolatileImageData
modifier|*
name|imageData
parameter_list|)
block|{
name|ensureCleanup
argument_list|()
expr_stmt|;
name|imageData
operator|->
name|next
operator|=
name|firstImageData
expr_stmt|;
if|if
condition|(
name|firstImageData
condition|)
block|{
name|firstImageData
operator|->
name|prev
operator|=
name|imageData
expr_stmt|;
block|}
name|firstImageData
operator|=
name|imageData
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterImageData
specifier|static
name|void
name|unregisterImageData
parameter_list|(
name|QVolatileImageData
modifier|*
name|imageData
parameter_list|)
block|{
if|if
condition|(
name|imageData
operator|->
name|prev
condition|)
block|{
name|imageData
operator|->
name|prev
operator|->
name|next
operator|=
name|imageData
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|firstImageData
operator|=
name|imageData
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|imageData
operator|->
name|next
condition|)
block|{
name|imageData
operator|->
name|next
operator|->
name|prev
operator|=
name|imageData
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QVolatileImageData
name|QVolatileImageData
operator|::
name|QVolatileImageData
parameter_list|()
member_init_list|:
name|next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|prev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bitmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{
name|registerImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVolatileImageData
name|QVolatileImageData
operator|::
name|QVolatileImageData
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|)
member_init_list|:
name|next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|prev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bitmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{
name|registerImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|createBitmap
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|updateImage
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVolatileImageData
name|QVolatileImageData
operator|::
name|QVolatileImageData
parameter_list|(
specifier|const
name|QImage
modifier|&
name|sourceImage
parameter_list|)
member_init_list|:
name|next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|prev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bitmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{
name|registerImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|image
operator|=
name|sourceImage
expr_stmt|;
comment|// The following is not mandatory, but we do it here to have a bitmap
comment|// created always in order to reduce local heap usage.
name|ensureBitmap
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVolatileImageData
name|QVolatileImageData
operator|::
name|QVolatileImageData
parameter_list|(
name|void
modifier|*
name|nativeImage
parameter_list|,
name|void
modifier|*
name|nativeMask
parameter_list|)
member_init_list|:
name|next
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|prev
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bitmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pengine
argument_list|(
literal|0
argument_list|)
block|{
name|registerImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|nativeImage
condition|)
block|{
name|CFbsBitmap
modifier|*
name|source
init|=
cast|static_cast
argument_list|<
name|CFbsBitmap
operator|*
argument_list|>
argument_list|(
name|nativeImage
argument_list|)
decl_stmt|;
name|CFbsBitmap
modifier|*
name|mask
init|=
cast|static_cast
argument_list|<
name|CFbsBitmap
operator|*
argument_list|>
argument_list|(
name|nativeMask
argument_list|)
decl_stmt|;
name|initWithBitmap
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|applyMask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_constructor
begin_constructor
DECL|function|QVolatileImageData
name|QVolatileImageData
operator|::
name|QVolatileImageData
parameter_list|(
specifier|const
name|QVolatileImageData
modifier|&
name|other
parameter_list|)
block|{
name|bitmap
operator|=
literal|0
expr_stmt|;
name|pengine
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|prev
operator|=
literal|0
expr_stmt|;
name|registerImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|other
operator|.
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|bitmap
operator|=
name|copyData
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|updateImage
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QVolatileImageData
name|QVolatileImageData
operator|::
name|~
name|QVolatileImageData
parameter_list|()
block|{
name|release
argument_list|()
expr_stmt|;
name|unregisterImageData
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|release
name|void
name|QVolatileImageData
operator|::
name|release
parameter_list|()
block|{
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
literal|0
expr_stmt|;
operator|delete
name|pengine
expr_stmt|;
name|pengine
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|beginDataAccess
name|void
name|QVolatileImageData
operator|::
name|beginDataAccess
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|bitmap
condition|)
block|{
name|bitmap
operator|->
name|BeginDataAccess
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|endDataAccess
name|void
name|QVolatileImageData
operator|::
name|endDataAccess
parameter_list|(
name|bool
name|readOnly
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|bitmap
condition|)
block|{
name|bitmap
operator|->
name|EndDataAccess
argument_list|(
name|readOnly
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureFormat
name|bool
name|QVolatileImageData
operator|::
name|ensureFormat
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|!=
name|format
condition|)
block|{
name|CFbsBitmap
modifier|*
name|newBitmap
init|=
name|convertData
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|newBitmap
operator|&&
name|newBitmap
operator|!=
name|bitmap
condition|)
block|{
operator|delete
name|bitmap
expr_stmt|;
name|bitmap
operator|=
name|newBitmap
expr_stmt|;
name|updateImage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|duplicateNativeImage
name|void
modifier|*
name|QVolatileImageData
operator|::
name|duplicateNativeImage
parameter_list|()
specifier|const
block|{
cast|const_cast
argument_list|<
name|QVolatileImageData
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|ensureBitmap
argument_list|()
expr_stmt|;
if|if
condition|(
name|bitmap
condition|)
block|{
if|if
condition|(
name|bitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EColor16M
condition|)
block|{
comment|// slow path: needs rgb swapping
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QImage
name|tmp
init|=
name|image
operator|.
name|rgbSwapped
argument_list|()
decl_stmt|;
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|imageToBitmap
argument_list|(
name|tmp
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|bitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray2
condition|)
block|{
comment|// slow path: needs inverting pixels
name|beginDataAccess
argument_list|()
expr_stmt|;
name|QImage
name|tmp
init|=
name|image
operator|.
name|copy
argument_list|()
decl_stmt|;
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
return|return
name|imageToBitmap
argument_list|(
name|tmp
argument_list|)
return|;
block|}
else|else
block|{
comment|// fast path: just duplicate the bitmap
return|return
name|duplicateBitmap
argument_list|(
operator|*
name|bitmap
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|updateImage
name|void
name|QVolatileImageData
operator|::
name|updateImage
parameter_list|()
block|{
if|if
condition|(
name|bitmap
condition|)
block|{
name|TSize
name|size
init|=
name|bitmap
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|beginDataAccess
argument_list|()
expr_stmt|;
comment|// Use existing buffer, no copy.  The data address never changes so it
comment|// is enough to do this whenever we have a new CFbsBitmap.  N.B. never
comment|// use const uchar* here, that would create a read-only image data which
comment|// would make a copy in detach() even when refcount is 1.
name|image
operator|=
name|QImage
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|bitmap
operator|->
name|DataAddress
argument_list|()
argument_list|)
argument_list|,
name|size
operator|.
name|iWidth
argument_list|,
name|size
operator|.
name|iHeight
argument_list|,
name|bitmap
operator|->
name|DataStride
argument_list|()
argument_list|,
name|qt_TDisplayMode2Format
argument_list|(
name|bitmap
operator|->
name|DisplayMode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|image
operator|=
name|QImage
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initWithBitmap
name|void
name|QVolatileImageData
operator|::
name|initWithBitmap
parameter_list|(
name|CFbsBitmap
modifier|*
name|source
parameter_list|)
block|{
name|bool
name|needsCopy
init|=
name|bitmapNeedsCopy
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EColor16M
condition|)
block|{
comment|// EColor16M is BGR
name|CFbsBitmap
modifier|*
name|unswappedBmp
init|=
name|source
decl_stmt|;
if|if
condition|(
name|needsCopy
condition|)
block|{
name|unswappedBmp
operator|=
name|rasterizeBitmap
argument_list|(
name|source
argument_list|,
name|source
operator|->
name|DisplayMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|unswappedBmp
operator|->
name|BeginDataAccess
argument_list|()
expr_stmt|;
name|TSize
name|sourceSize
init|=
name|unswappedBmp
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|QImage
name|img
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|unswappedBmp
operator|->
name|DataAddress
argument_list|()
argument_list|,
name|sourceSize
operator|.
name|iWidth
argument_list|,
name|sourceSize
operator|.
name|iHeight
argument_list|,
name|unswappedBmp
operator|->
name|DataStride
argument_list|()
argument_list|,
name|qt_TDisplayMode2Format
argument_list|(
name|unswappedBmp
operator|->
name|DisplayMode
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|img
operator|=
name|img
operator|.
name|rgbSwapped
argument_list|()
expr_stmt|;
name|unswappedBmp
operator|->
name|EndDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|imageToBitmap
argument_list|(
name|img
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsCopy
condition|)
block|{
operator|delete
name|unswappedBmp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|needsCopy
condition|)
block|{
comment|// Rasterize extended and compressed bitmaps.
name|bitmap
operator|=
name|rasterizeBitmap
argument_list|(
name|source
argument_list|,
name|EColor16MAP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray2
condition|)
block|{
comment|// The pixels will be inverted, must make a copy.
name|bitmap
operator|=
name|rasterizeBitmap
argument_list|(
name|source
argument_list|,
name|source
operator|->
name|DisplayMode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Efficient path: no pixel data copying. Just duplicate. This of course
comment|// means the original bitmap's data may get modified, but that's fine
comment|// and is in accordance with the QPixmap::fromSymbianCFbsBitmap() docs.
name|bitmap
operator|=
name|duplicateBitmap
argument_list|(
operator|*
name|source
argument_list|)
expr_stmt|;
block|}
name|updateImage
argument_list|()
expr_stmt|;
if|if
condition|(
name|bitmap
operator|&&
name|bitmap
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray2
condition|)
block|{
comment|// Symbian thinks set pixels are white/transparent, Qt thinks they are
comment|// foreground/solid. Invert mono bitmaps so that masks work correctly.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|image
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|applyMask
name|void
name|QVolatileImageData
operator|::
name|applyMask
parameter_list|(
name|CFbsBitmap
modifier|*
name|mask
parameter_list|)
block|{
name|ensureFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|bool
name|destroyMask
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|bitmapNeedsCopy
argument_list|(
name|mask
argument_list|)
condition|)
block|{
name|mask
operator|=
name|rasterizeBitmap
argument_list|(
name|mask
argument_list|,
name|EColor16MU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
block|{
return|return;
block|}
name|destroyMask
operator|=
literal|true
expr_stmt|;
block|}
name|mask
operator|->
name|BeginDataAccess
argument_list|()
expr_stmt|;
name|TSize
name|maskSize
init|=
name|mask
operator|->
name|SizeInPixels
argument_list|()
decl_stmt|;
name|QImage
name|maskImg
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|mask
operator|->
name|DataAddress
argument_list|()
argument_list|,
name|maskSize
operator|.
name|iWidth
argument_list|,
name|maskSize
operator|.
name|iHeight
argument_list|,
name|mask
operator|->
name|DataStride
argument_list|()
argument_list|,
name|qt_TDisplayMode2Format
argument_list|(
name|mask
operator|->
name|DisplayMode
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
operator|->
name|DisplayMode
argument_list|()
operator|==
name|EGray2
condition|)
block|{
name|maskImg
operator|=
name|maskImg
operator|.
name|copy
argument_list|()
expr_stmt|;
name|maskImg
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
block|}
name|beginDataAccess
argument_list|()
expr_stmt|;
name|image
operator|.
name|setAlphaChannel
argument_list|(
name|maskImg
argument_list|)
expr_stmt|;
name|endDataAccess
argument_list|()
expr_stmt|;
name|mask
operator|->
name|EndDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ensureImage
argument_list|()
expr_stmt|;
if|if
condition|(
name|destroyMask
condition|)
block|{
operator|delete
name|mask
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureImage
name|void
name|QVolatileImageData
operator|::
name|ensureImage
parameter_list|()
block|{
if|if
condition|(
name|bitmap
operator|&&
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QImageData
modifier|*
name|imaged
init|=
name|image
operator|.
name|data_ptr
argument_list|()
decl_stmt|;
if|if
condition|(
name|imaged
operator|->
name|ref
operator|!=
literal|1
operator|||
name|imaged
operator|->
name|ro_data
condition|)
block|{
comment|// This is bad, the imagedata got shared somehow. Detach, in order to
comment|// have the next check fail and thus have 'image' recreated.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|image
operator|.
name|detach
argument_list|()
expr_stmt|;
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitmap
operator|&&
name|image
operator|.
name|constBits
argument_list|()
operator|!=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|bitmap
operator|->
name|DataAddress
argument_list|()
argument_list|)
condition|)
block|{
comment|// Should not ever get here. If we do it means that either 'image' has
comment|// been replaced with a copy (e.g. because some QImage API assigned a
comment|// new, regular QImage to *this) or the bitmap's data address changed
comment|// unexpectedly.
name|qWarning
argument_list|(
literal|"QVolatileImageData: Ptr mismatch"
argument_list|)
expr_stmt|;
comment|// Recover by recreating the image so that it uses the bitmap as its buffer.
name|updateImage
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureBitmap
name|void
name|QVolatileImageData
operator|::
name|ensureBitmap
parameter_list|()
block|{
if|if
condition|(
operator|!
name|bitmap
operator|&&
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|bitmap
operator|=
name|imageToBitmap
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|updateImage
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
