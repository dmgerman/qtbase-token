begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QIMAGEREADER_DEBUG
end_comment
begin_comment
comment|/*!     \class QImageReader     \brief The QImageReader class provides a format independent interface     for reading images from files or other devices.      \reentrant     \ingroup painting     \ingroup io      The most common way to read images is through QImage and QPixmap's     constructors, or by calling QImage::load() and     QPixmap::load(). QImageReader is a specialized class which gives     you more control when reading images. For example, you can read an     image into a specific size by calling setScaledSize(), and you can     select a clip rect, effectively loading only parts of an image, by     calling setClipRect(). Depending on the underlying support in the     image format, this can save memory and speed up loading of images.      To read an image, you start by constructing a QImageReader object.     Pass either a file name or a device pointer, and the image format     to QImageReader's constructor. You can then set several options,     such as the clip rect (by calling setClipRect()) and scaled size     (by calling setScaledSize()). canRead() returns the image if the     QImageReader can read the image (i.e., the image format is     supported and the device is open for reading). Call read() to read     the image.      If any error occurs when reading the image, read() will return a     null QImage. You can then call error() to find the type of error     that occurred, or errorString() to get a human readable     description of what went wrong.      Call supportedImageFormats() for a list of formats that     QImageReader can read. QImageReader supports all built-in image     formats, in addition to any image format plugins that support     reading.      QImageReader autodetects the image format by default, by looking at the     provided (optional) format string, the file name suffix, and the data     stream contents. You can enable or disable this feature, by calling     setAutoDetectImageFormat().      \sa QImageWriter, QImageIOHandler, QImageIOPlugin */
end_comment
begin_comment
comment|/*!     \enum QImageReader::ImageReaderError      This enum describes the different types of errors that can occur     when reading images with QImageReader.      \value FileNotFoundError QImageReader was used with a file name,     but not file was found with that name. This can also happen if the     file name contained no extension, and the file with the correct     extension is not supported by Qt.      \value DeviceError QImageReader encountered a device error when     reading the image. You can consult your particular device for more     details on what went wrong.      \value UnsupportedFormatError Qt does not support the requested     image format.      \value InvalidDataError The image data was invalid, and     QImageReader was unable to read an image from it. The can happen     if the image file is damaged.      \value UnknownError An unknown error occurred. If you get this     value after calling read(), it is most likely caused by a bug in     QImageReader. */
end_comment
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_include
include|#
directive|include
file|<qimageiohandler.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|<qrect.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qsize.h>
end_include
begin_include
include|#
directive|include
file|<qcolor.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_comment
comment|// factory loader
end_comment
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_comment
comment|// image handlers
end_comment
begin_include
include|#
directive|include
file|<private/qbmphandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qppmhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qxbmhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qxpmhandler_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
end_ifndef
begin_include
include|#
directive|include
file|<private/qpnghandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
end_ifndef
begin_include
include|#
directive|include
file|<private/qjpeghandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_TIFF
end_ifndef
begin_include
include|#
directive|include
file|<private/qtiffhandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
end_ifdef
begin_include
include|#
directive|include
file|<private/qgifhandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QFactoryLoader
argument_list|,
name|loader
argument_list|,
operator|(
name|QImageIOHandlerFactoryInterface_iid
operator|,
name|QLatin1String
argument_list|(
literal|"/imageformats"
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
decl|enum
DECL|enum|_qt_BuiltInFormatType
name|_qt_BuiltInFormatType
argument_list|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
DECL|enumerator|_qt_PngFormat
name|_qt_PngFormat
argument_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
DECL|enumerator|_qt_JpgFormat
name|_qt_JpgFormat
argument_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_TIFF
DECL|enumerator|_qt_TifFormat
name|_qt_TifFormat
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
DECL|enumerator|_qt_GifFormat
name|_qt_GifFormat
argument_list|,
endif|#
directive|endif
DECL|enumerator|_qt_BmpFormat
name|_qt_BmpFormat
argument_list|,
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
DECL|enumerator|_qt_PpmFormat
name|_qt_PpmFormat
argument_list|,
DECL|enumerator|_qt_PgmFormat
name|_qt_PgmFormat
argument_list|,
DECL|enumerator|_qt_PbmFormat
name|_qt_PbmFormat
argument_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
DECL|enumerator|_qt_XbmFormat
name|_qt_XbmFormat
argument_list|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
DECL|enumerator|_qt_XpmFormat
name|_qt_XpmFormat
argument_list|,
endif|#
directive|endif
DECL|enumerator|_qt_NumFormats
name|_qt_NumFormats
argument_list|,
DECL|enumerator|_qt_NoFormat
name|_qt_NoFormat
operator|=
operator|-
literal|1
argument_list|}
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|_qt_BuiltInFormatStruct
struct|struct
name|_qt_BuiltInFormatStruct
block|{
DECL|member|type
name|_qt_BuiltInFormatType
name|type
decl_stmt|;
DECL|member|extension
specifier|const
name|char
modifier|*
name|extension
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|_qt_BuiltInFormats
specifier|static
specifier|const
name|_qt_BuiltInFormatStruct
name|_qt_BuiltInFormats
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
block|{
name|_qt_PngFormat
block|,
literal|"png"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
block|{
name|_qt_JpgFormat
block|,
literal|"jpg"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_TIFF
block|{
name|_qt_TifFormat
block|,
literal|"tif"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
block|{
name|_qt_GifFormat
block|,
literal|"gif"
block|}
block|,
endif|#
directive|endif
block|{
name|_qt_BmpFormat
block|,
literal|"bmp"
block|}
block|,
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
block|{
name|_qt_PpmFormat
block|,
literal|"ppm"
block|}
block|,
block|{
name|_qt_PgmFormat
block|,
literal|"pgm"
block|}
block|,
block|{
name|_qt_PbmFormat
block|,
literal|"pbm"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
block|{
name|_qt_XbmFormat
block|,
literal|"xbm"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
block|{
name|_qt_XpmFormat
block|,
literal|"xpm"
block|}
block|,
endif|#
directive|endif
block|{
name|_qt_NoFormat
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|createReadHandlerHelper
specifier|static
name|QImageIOHandler
modifier|*
name|createReadHandlerHelper
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|,
name|bool
name|autoDetectImageFormat
parameter_list|,
name|bool
name|ignoresFormatAndExtension
parameter_list|)
block|{
if|if
condition|(
operator|!
name|autoDetectImageFormat
operator|&&
name|format
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QByteArray
name|form
init|=
name|format
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QImageIOHandler
modifier|*
name|handler
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
comment|// check if we have plugins that support the image format
name|QFactoryLoader
modifier|*
name|l
init|=
name|loader
argument_list|()
decl_stmt|;
name|QStringList
name|keys
init|=
name|l
operator|->
name|keys
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|QByteArray
name|suffix
decl_stmt|;
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler( device ="
operator|<<
operator|(
name|void
operator|*
operator|)
name|device
operator|<<
literal|", format ="
operator|<<
name|format
operator|<<
literal|"),"
operator|<<
name|keys
operator|.
name|size
argument_list|()
operator|<<
literal|"plugins available: "
operator|<<
name|keys
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|int
name|suffixPluginIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|device
operator|&&
name|format
operator|.
name|isEmpty
argument_list|()
operator|&&
name|autoDetectImageFormat
operator|&&
operator|!
name|ignoresFormatAndExtension
condition|)
block|{
comment|// if there's no format, see if \a device is a file, and if so, find
comment|// the file suffix and find support for that format among our plugins.
comment|// this allows plugins to override our built-in handlers.
if|if
condition|(
name|QFile
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: device is a file:"
operator|<<
name|file
operator|->
name|fileName
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|suffix
operator|=
name|QFileInfo
argument_list|(
name|file
operator|->
name|fileName
argument_list|()
argument_list|)
operator|.
name|suffix
argument_list|()
operator|.
name|toLower
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|index
init|=
name|keys
operator|.
name|indexOf
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|suffix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: suffix recognized; the"
operator|<<
name|suffix
operator|<<
literal|"plugin might be able to read this"
expr_stmt|;
endif|#
directive|endif
name|suffixPluginIndex
operator|=
name|index
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_LIBRARY
name|QByteArray
name|testFormat
init|=
operator|!
name|form
operator|.
name|isEmpty
argument_list|()
condition|?
name|form
else|:
name|suffix
decl_stmt|;
if|if
condition|(
name|ignoresFormatAndExtension
condition|)
name|testFormat
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
name|suffixPluginIndex
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// check if the plugin that claims support for this format can load
comment|// from this device with this format.
specifier|const
name|qint64
name|pos
init|=
name|device
condition|?
name|device
operator|->
name|pos
argument_list|()
else|:
literal|0
decl_stmt|;
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|suffix
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanRead
condition|)
block|{
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: using the"
operator|<<
name|suffix
operator|<<
literal|"plugin"
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|device
operator|&&
operator|!
name|device
operator|->
name|isSequential
argument_list|()
condition|)
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|handler
operator|&&
operator|!
name|testFormat
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ignoresFormatAndExtension
condition|)
block|{
comment|// check if any plugin supports the format (they are not allowed to
comment|// read from the device yet).
specifier|const
name|qint64
name|pos
init|=
name|device
condition|?
name|device
operator|->
name|pos
argument_list|()
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|autoDetectImageFormat
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|suffixPluginIndex
condition|)
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanRead
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: the"
operator|<<
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"plugin can read this format"
expr_stmt|;
endif|#
directive|endif
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|QLatin1String
argument_list|(
name|testFormat
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanRead
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: the"
operator|<<
name|testFormat
operator|<<
literal|"plugin can read this format"
expr_stmt|;
endif|#
directive|endif
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|device
operator|&&
operator|!
name|device
operator|->
name|isSequential
argument_list|()
condition|)
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_LIBRARY
comment|// if we don't have a handler yet, check if we have built-in support for
comment|// the format
if|if
condition|(
operator|!
name|handler
operator|&&
operator|!
name|testFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"png"
condition|)
block|{
name|handler
operator|=
operator|new
name|QPngHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"jpg"
operator|||
name|testFormat
operator|==
literal|"jpeg"
condition|)
block|{
name|handler
operator|=
operator|new
name|QJpegHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_TIFF
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"tif"
operator|||
name|testFormat
operator|==
literal|"tiff"
condition|)
block|{
name|handler
operator|=
operator|new
name|QTiffHandler
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"gif"
condition|)
block|{
name|handler
operator|=
operator|new
name|QGifHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_BMP
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"bmp"
condition|)
block|{
name|handler
operator|=
operator|new
name|QBmpHandler
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"dib"
condition|)
block|{
name|handler
operator|=
operator|new
name|QBmpHandler
argument_list|(
name|QBmpHandler
operator|::
name|DibFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"xpm"
condition|)
block|{
name|handler
operator|=
operator|new
name|QXpmHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"xbm"
condition|)
block|{
name|handler
operator|=
operator|new
name|QXbmHandler
expr_stmt|;
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|SubType
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"pbm"
operator|||
name|testFormat
operator|==
literal|"pbmraw"
operator|||
name|testFormat
operator|==
literal|"pgm"
operator|||
name|testFormat
operator|==
literal|"pgmraw"
operator|||
name|testFormat
operator|==
literal|"ppm"
operator|||
name|testFormat
operator|==
literal|"ppmraw"
condition|)
block|{
name|handler
operator|=
operator|new
name|QPpmHandler
expr_stmt|;
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|SubType
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
if|if
condition|(
name|handler
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: using the built-in handler for"
operator|<<
name|testFormat
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
operator|!
name|handler
operator|&&
operator|(
name|autoDetectImageFormat
operator|||
name|ignoresFormatAndExtension
operator|)
condition|)
block|{
comment|// check if any of our plugins recognize the file from its contents.
specifier|const
name|qint64
name|pos
init|=
name|device
condition|?
name|device
operator|->
name|pos
argument_list|()
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|suffixPluginIndex
condition|)
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanRead
condition|)
block|{
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: the"
operator|<<
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"plugin can read this data"
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
if|if
condition|(
name|device
operator|&&
operator|!
name|device
operator|->
name|isSequential
argument_list|()
condition|)
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_LIBRARY
if|if
condition|(
operator|!
name|handler
operator|&&
operator|(
name|autoDetectImageFormat
operator|||
name|ignoresFormatAndExtension
operator|)
condition|)
block|{
comment|// check if any of our built-in handlers recognize the file from its
comment|// contents.
name|int
name|currentFormat
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|suffix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If reading from a file with a suffix, start testing our
comment|// built-in handler for that suffix first.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_qt_NumFormats
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|_qt_BuiltInFormats
index|[
name|i
index|]
operator|.
name|extension
operator|==
name|suffix
condition|)
block|{
name|currentFormat
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|QByteArray
name|subType
decl_stmt|;
name|int
name|numFormats
init|=
name|_qt_NumFormats
decl_stmt|;
while|while
condition|(
name|device
operator|&&
name|numFormats
operator|>=
literal|0
condition|)
block|{
specifier|const
name|_qt_BuiltInFormatStruct
modifier|*
name|formatStruct
init|=
operator|&
name|_qt_BuiltInFormats
index|[
name|currentFormat
index|]
decl_stmt|;
specifier|const
name|qint64
name|pos
init|=
name|device
operator|->
name|pos
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|formatStruct
operator|->
name|type
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
case|case
name|_qt_PngFormat
case|:
if|if
condition|(
name|QPngHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QPngHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
case|case
name|_qt_JpgFormat
case|:
if|if
condition|(
name|QJpegHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QJpegHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_TIFF
case|case
name|_qt_TifFormat
case|:
if|if
condition|(
name|QTiffHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QTiffHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
case|case
name|_qt_GifFormat
case|:
if|if
condition|(
name|QGifHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QGifHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_BMP
case|case
name|_qt_BmpFormat
case|:
if|if
condition|(
name|QBmpHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QBmpHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
case|case
name|_qt_XpmFormat
case|:
if|if
condition|(
name|QXpmHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QXpmHandler
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
case|case
name|_qt_PbmFormat
case|:
case|case
name|_qt_PgmFormat
case|:
case|case
name|_qt_PpmFormat
case|:
if|if
condition|(
name|QPpmHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|,
operator|&
name|subType
argument_list|)
condition|)
block|{
name|handler
operator|=
operator|new
name|QPpmHandler
expr_stmt|;
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|SubType
argument_list|,
name|subType
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
case|case
name|_qt_XbmFormat
case|:
if|if
condition|(
name|QXbmHandler
operator|::
name|canRead
argument_list|(
name|device
argument_list|)
condition|)
name|handler
operator|=
operator|new
name|QXbmHandler
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|device
operator|->
name|isSequential
argument_list|()
condition|)
name|device
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: the"
operator|<<
name|formatStruct
operator|->
name|extension
operator|<<
literal|"built-in handler can read this data"
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
operator|--
name|numFormats
expr_stmt|;
operator|++
name|currentFormat
expr_stmt|;
name|currentFormat
operator|%=
name|_qt_NumFormats
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|handler
condition|)
block|{
ifdef|#
directive|ifdef
name|QIMAGEREADER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QImageReader::createReadHandler: no handlers found. giving up."
expr_stmt|;
endif|#
directive|endif
comment|// no handler: give up.
return|return
literal|0
return|;
block|}
name|handler
operator|->
name|setDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|.
name|isEmpty
argument_list|()
condition|)
name|handler
operator|->
name|setFormat
argument_list|(
name|form
argument_list|)
expr_stmt|;
return|return
name|handler
return|;
block|}
end_function
begin_class
DECL|class|QImageReaderPrivate
class|class
name|QImageReaderPrivate
block|{
public|public:
name|QImageReaderPrivate
parameter_list|(
name|QImageReader
modifier|*
name|qq
parameter_list|)
constructor_decl|;
name|~
name|QImageReaderPrivate
parameter_list|()
destructor_decl|;
comment|// device
DECL|member|format
name|QByteArray
name|format
decl_stmt|;
DECL|member|autoDetectImageFormat
name|bool
name|autoDetectImageFormat
decl_stmt|;
DECL|member|ignoresFormatAndExtension
name|bool
name|ignoresFormatAndExtension
decl_stmt|;
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|deleteDevice
name|bool
name|deleteDevice
decl_stmt|;
DECL|member|handler
name|QImageIOHandler
modifier|*
name|handler
decl_stmt|;
name|bool
name|initHandler
parameter_list|()
function_decl|;
comment|// image options
DECL|member|clipRect
name|QRect
name|clipRect
decl_stmt|;
DECL|member|scaledSize
name|QSize
name|scaledSize
decl_stmt|;
DECL|member|scaledClipRect
name|QRect
name|scaledClipRect
decl_stmt|;
DECL|member|quality
name|int
name|quality
decl_stmt|;
DECL|member|text
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|text
decl_stmt|;
name|void
name|getText
parameter_list|()
function_decl|;
comment|// error
DECL|member|imageReaderError
name|QImageReader
operator|::
name|ImageReaderError
name|imageReaderError
decl_stmt|;
DECL|member|errorString
name|QString
name|errorString
decl_stmt|;
DECL|member|q
name|QImageReader
modifier|*
name|q
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QImageReaderPrivate
name|QImageReaderPrivate
operator|::
name|QImageReaderPrivate
parameter_list|(
name|QImageReader
modifier|*
name|qq
parameter_list|)
member_init_list|:
name|autoDetectImageFormat
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|ignoresFormatAndExtension
argument_list|(
literal|false
argument_list|)
block|{
name|device
operator|=
literal|0
expr_stmt|;
name|deleteDevice
operator|=
literal|false
expr_stmt|;
name|handler
operator|=
literal|0
expr_stmt|;
name|quality
operator|=
operator|-
literal|1
expr_stmt|;
name|imageReaderError
operator|=
name|QImageReader
operator|::
name|UnknownError
expr_stmt|;
name|q
operator|=
name|qq
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QImageReaderPrivate
name|QImageReaderPrivate
operator|::
name|~
name|QImageReaderPrivate
parameter_list|()
block|{
if|if
condition|(
name|deleteDevice
condition|)
operator|delete
name|device
expr_stmt|;
operator|delete
name|handler
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|initHandler
name|bool
name|QImageReaderPrivate
operator|::
name|initHandler
parameter_list|()
block|{
comment|// check some preconditions
if|if
condition|(
operator|!
name|device
operator|||
operator|(
operator|!
name|deleteDevice
operator|&&
operator|!
name|device
operator|->
name|isOpen
argument_list|()
operator|&&
operator|!
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|)
condition|)
block|{
name|imageReaderError
operator|=
name|QImageReader
operator|::
name|DeviceError
expr_stmt|;
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageReader
argument_list|,
literal|"Invalid device"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// probe the file extension
if|if
condition|(
name|deleteDevice
operator|&&
operator|!
name|device
operator|->
name|isOpen
argument_list|()
operator|&&
operator|!
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|&&
name|autoDetectImageFormat
condition|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|extensions
init|=
name|QImageReader
operator|::
name|supportedImageFormats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|format
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Try the most probable extension first
name|int
name|currentFormatIndex
init|=
name|extensions
operator|.
name|indexOf
argument_list|(
name|format
operator|.
name|toLower
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentFormatIndex
operator|>
literal|0
condition|)
name|extensions
operator|.
name|swap
argument_list|(
literal|0
argument_list|,
name|currentFormatIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|currentExtension
init|=
literal|0
decl_stmt|;
name|QFile
modifier|*
name|file
init|=
cast|static_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|QString
name|fileName
init|=
name|file
operator|->
name|fileName
argument_list|()
decl_stmt|;
do|do
block|{
name|file
operator|->
name|setFileName
argument_list|(
name|fileName
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|QString
operator|::
name|fromLatin1
argument_list|(
name|extensions
operator|.
name|at
argument_list|(
name|currentExtension
operator|++
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|file
operator|->
name|isOpen
argument_list|()
operator|&&
name|currentExtension
operator|<
name|extensions
operator|.
name|size
argument_list|()
condition|)
do|;
if|if
condition|(
operator|!
name|device
operator|->
name|isOpen
argument_list|()
condition|)
block|{
name|imageReaderError
operator|=
name|QImageReader
operator|::
name|FileNotFoundError
expr_stmt|;
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageReader
argument_list|,
literal|"File not found"
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|setFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
comment|// restore the old file name
return|return
literal|false
return|;
block|}
block|}
comment|// assign a handler
if|if
condition|(
operator|!
name|handler
operator|&&
operator|(
name|handler
operator|=
name|createReadHandlerHelper
argument_list|(
name|device
argument_list|,
name|format
argument_list|,
name|autoDetectImageFormat
argument_list|,
name|ignoresFormatAndExtension
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|imageReaderError
operator|=
name|QImageReader
operator|::
name|UnsupportedFormatError
expr_stmt|;
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageReader
argument_list|,
literal|"Unsupported image format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|getText
name|void
name|QImageReaderPrivate
operator|::
name|getText
parameter_list|()
block|{
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
operator|!
name|handler
operator|&&
operator|!
name|initHandler
argument_list|()
operator|)
operator|||
operator|!
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Description
argument_list|)
condition|)
return|return;
foreach|foreach
control|(
name|QString
name|pair
decl|,
name|handler
operator|->
name|option
argument_list|(
name|QImageIOHandler
operator|::
name|Description
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
control|)
block|{
name|int
name|index
init|=
name|pair
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|pair
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|<
name|index
condition|)
block|{
name|text
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"Description"
argument_list|)
argument_list|,
name|pair
operator|.
name|simplified
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|key
init|=
name|pair
operator|.
name|left
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|text
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|pair
operator|.
name|mid
argument_list|(
name|index
operator|+
literal|2
argument_list|)
operator|.
name|simplified
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs an empty QImageReader object. Before reading an image,     call setDevice() or setFileName(). */
end_comment
begin_constructor
DECL|function|QImageReader
name|QImageReader
operator|::
name|QImageReader
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QImageReader object with the device \a device and the     image format \a format. */
end_comment
begin_constructor
DECL|function|QImageReader
name|QImageReader
operator|::
name|QImageReader
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QImageReader object with the file name \a fileName     and the image format \a format.      \sa setFileName() */
end_comment
begin_constructor
DECL|function|QImageReader
name|QImageReader
operator|::
name|QImageReader
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|QFile
modifier|*
name|file
init|=
operator|new
name|QFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|d
operator|->
name|device
operator|=
name|file
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QImageReader object. */
end_comment
begin_destructor
DECL|function|~QImageReader
name|QImageReader
operator|::
name|~
name|QImageReader
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the format QImageReader will use when reading images, to \a     format. \a format is a case insensitive text string. Example:      \snippet doc/src/snippets/code/src_gui_image_qimagereader.cpp 0      You can call supportedImageFormats() for the full list of formats     QImageReader supports.      \sa format() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QImageReader
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
block|{
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format QImageReader uses for reading images.      You can call this function after assigning a device to the     reader to determine the format of the device. For example:      \snippet doc/src/snippets/code/src_gui_image_qimagereader.cpp 1      If the reader cannot read any image from the device (e.g., there is no     image there, or the image has already been read), or if the format is     unsupported, this function returns an empty QByteArray().      \sa setFormat(), supportedImageFormats() */
end_comment
begin_function
DECL|function|format
name|QByteArray
name|QImageReader
operator|::
name|format
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|canRead
argument_list|()
condition|?
name|d
operator|->
name|handler
operator|->
name|format
argument_list|()
else|:
name|QByteArray
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enabled is true, image format autodetection is enabled; otherwise,     it is disabled. By default, autodetection is enabled.      QImageReader uses an extensive approach to detecting the image format;     firstly, if you pass a file name to QImageReader, it will attempt to     detect the file extension if the given file name does not point to an     existing file, by appending supported default extensions to the given file     name, one at a time. It then uses the following approach to detect the     image format:      \list      \o Image plugins are queried first, based on either the optional format     string, or the file name suffix (if the source device is a file). No     content detection is done at this stage. QImageReader will choose the     first plugin that supports reading for this format.      \o If no plugin supports the image format, Qt's built-in handlers are     checked based on either the optional format string, or the file name     suffix.      \o If no capable plugins or built-in handlers are found, each plugin is     tested by inspecting the content of the data stream.      \o If no plugins could detect the image format based on data contents,     each built-in image handler is tested by inspecting the contents.      \o Finally, if all above approaches fail, QImageReader will report failure     when trying to read the image.      \endlist      By disabling image format autodetection, QImageReader will only query the     plugins and built-in handlers based on the format string (i.e., no file     name extensions are tested).      \sa QImageIOHandler::canRead(), QImageIOPlugin::capabilities() */
end_comment
begin_function
DECL|function|setAutoDetectImageFormat
name|void
name|QImageReader
operator|::
name|setAutoDetectImageFormat
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|d
operator|->
name|autoDetectImageFormat
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if image format autodetection is enabled on this image     reader; otherwise returns false. By default, autodetection is enabled.      \sa setAutoDetectImageFormat() */
end_comment
begin_function
DECL|function|autoDetectImageFormat
name|bool
name|QImageReader
operator|::
name|autoDetectImageFormat
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|autoDetectImageFormat
return|;
block|}
end_function
begin_comment
comment|/*!     If \a ignored is set to true, then the image reader will ignore     specified formats or file extensions and decide which plugin to     use only based on the contents in the datastream.      Setting this flag means that all image plugins gets loaded. Each     plugin will read the first bytes in the image data and decide if     the plugin is compatible or not.      This also disables auto detecting the image format.      \sa decideFormatFromContent() */
end_comment
begin_function
DECL|function|setDecideFormatFromContent
name|void
name|QImageReader
operator|::
name|setDecideFormatFromContent
parameter_list|(
name|bool
name|ignored
parameter_list|)
block|{
name|d
operator|->
name|ignoresFormatAndExtension
operator|=
name|ignored
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns whether the image reader should decide which plugin to use     only based on the contents of the datastream rather than on the file     extension.      \sa setDecideFormatFromContent() */
end_comment
begin_function
DECL|function|decideFormatFromContent
name|bool
name|QImageReader
operator|::
name|decideFormatFromContent
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|ignoresFormatAndExtension
return|;
block|}
end_function
begin_comment
comment|/*!     Sets QImageReader's device to \a device. If a device has already     been set, the old device is removed from QImageReader and is     otherwise left unchanged.      If the device is not already open, QImageReader will attempt to     open the device in \l QIODevice::ReadOnly mode by calling     open(). Note that this does not work for certain devices, such as     QProcess, QTcpSocket and QUdpSocket, where more logic is required     to open the device.      \sa device(), setFileName() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QImageReader
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|device
operator|&&
name|d
operator|->
name|deleteDevice
condition|)
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
operator|delete
name|d
operator|->
name|handler
expr_stmt|;
name|d
operator|->
name|handler
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|text
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the device currently assigned to QImageReader, or 0 if no     device has been assigned. */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QImageReader
operator|::
name|device
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file name of QImageReader to \a fileName. Internally,     QImageReader will create a QFile object and open it in \l     QIODevice::ReadOnly mode, and use this when reading images.      If \a fileName does not include a file extension (e.g., .png or .bmp),     QImageReader will cycle through all supported extensions until it finds     a matching file.      \sa fileName(), setDevice(), supportedImageFormats() */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QImageReader
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|setDevice
argument_list|(
operator|new
name|QFile
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the currently assigned device is a QFile, or if setFileName()     has been called, this function returns the name of the file     QImageReader reads from. Otherwise (i.e., if no device has been     assigned or the device is not a QFile), an empty QString is     returned.      \sa setFileName(), setDevice() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QImageReader
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|QFile
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|device
argument_list|)
decl_stmt|;
return|return
name|file
condition|?
name|file
operator|->
name|fileName
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      This is an image format specific function that sets the quality     level of the image to \a quality. For image formats that do not     support setting the quality, this value is ignored.      The value range of \a quality depends on the image format. For     example, the "jpeg" format supports a quality range from 0 (low     quality, high compression) to 100 (high quality, low compression).      \sa quality() */
end_comment
begin_function
DECL|function|setQuality
name|void
name|QImageReader
operator|::
name|setQuality
parameter_list|(
name|int
name|quality
parameter_list|)
block|{
name|d
operator|->
name|quality
operator|=
name|quality
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the quality level of the image.      \sa setQuality() */
end_comment
begin_function
DECL|function|quality
name|int
name|QImageReader
operator|::
name|quality
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|quality
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size of the image, without actually reading the image     contents.      If the image format does not support this feature, this function returns     an invalid size. Qt's built-in image handlers all support this feature,     but custom image format plugins are not required to do so.      \sa QImageIOHandler::ImageOption, QImageIOHandler::option(), QImageIOHandler::supportsOption() */
end_comment
begin_function
DECL|function|size
name|QSize
name|QImageReader
operator|::
name|size
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
name|QSize
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Size
argument_list|)
condition|)
return|return
name|d
operator|->
name|handler
operator|->
name|option
argument_list|(
name|QImageIOHandler
operator|::
name|Size
argument_list|)
operator|.
name|toSize
argument_list|()
return|;
return|return
name|QSize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the format of the image, without actually reading the image     contents. The format describes the image format \l QImageReader::read()     returns, not the format of the actual image.      If the image format does not support this feature, this function returns     an invalid format.      \sa QImageIOHandler::ImageOption, QImageIOHandler::option(), QImageIOHandler::supportsOption() */
end_comment
begin_function
DECL|function|imageFormat
name|QImage
operator|::
name|Format
name|QImageReader
operator|::
name|imageFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
name|QImage
operator|::
name|Format_Invalid
return|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ImageFormat
argument_list|)
condition|)
return|return
operator|(
name|QImage
operator|::
name|Format
operator|)
name|d
operator|->
name|handler
operator|->
name|option
argument_list|(
name|QImageIOHandler
operator|::
name|ImageFormat
argument_list|)
operator|.
name|toInt
argument_list|()
return|;
return|return
name|QImage
operator|::
name|Format_Invalid
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the text keys for this image. You can use     these keys with text() to list the image text for     a certain key.      Support for this option is implemented through     QImageIOHandler::Description.      \sa text(), QImageWriter::setText(), QImage::textKeys() */
end_comment
begin_function
DECL|function|textKeys
name|QStringList
name|QImageReader
operator|::
name|textKeys
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|getText
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|text
operator|.
name|keys
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the image text associated with \a key.      Support for this option is implemented through     QImageIOHandler::Description.      \sa textKeys(), QImageWriter::setText() */
end_comment
begin_function
DECL|function|text
name|QString
name|QImageReader
operator|::
name|text
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|getText
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|text
operator|.
name|value
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the image clip rect (also known as the ROI, or Region Of     Interest) to \a rect. The coordinates of \a rect are relative to     the untransformed image size, as returned by size().      \sa clipRect(), setScaledSize(), setScaledClipRect() */
end_comment
begin_function
DECL|function|setClipRect
name|void
name|QImageReader
operator|::
name|setClipRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|d
operator|->
name|clipRect
operator|=
name|rect
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the clip rect (also known as the ROI, or Region Of     Interest) of the image. If no clip rect has been set, an invalid     QRect is returned.      \sa setClipRect() */
end_comment
begin_function
DECL|function|clipRect
name|QRect
name|QImageReader
operator|::
name|clipRect
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|clipRect
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the scaled size of the image to \a size. The scaling is     performed after the initial clip rect, but before the scaled clip     rect is applied. The algorithm used for scaling depends on the     image format. By default (i.e., if the image format does not     support scaling), QImageReader will use QImage::scale() with     Qt::SmoothScaling.      \sa scaledSize(), setClipRect(), setScaledClipRect() */
end_comment
begin_function
DECL|function|setScaledSize
name|void
name|QImageReader
operator|::
name|setScaledSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|d
operator|->
name|scaledSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the scaled size of the image.      \sa setScaledSize() */
end_comment
begin_function
DECL|function|scaledSize
name|QSize
name|QImageReader
operator|::
name|scaledSize
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|scaledSize
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the scaled clip rect to \a rect. The scaled clip rect is the     clip rect (also known as ROI, or Region Of Interest) that is     applied after the image has been scaled.      \sa scaledClipRect(), setScaledSize() */
end_comment
begin_function
DECL|function|setScaledClipRect
name|void
name|QImageReader
operator|::
name|setScaledClipRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|d
operator|->
name|scaledClipRect
operator|=
name|rect
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the scaled clip rect of the image.      \sa setScaledClipRect() */
end_comment
begin_function
DECL|function|scaledClipRect
name|QRect
name|QImageReader
operator|::
name|scaledClipRect
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|scaledClipRect
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the background color to \a color.     Image formats that support this operation are expected to     initialize the background to \a color before reading an image.      \sa backgroundColor(), read() */
end_comment
begin_function
DECL|function|setBackgroundColor
name|void
name|QImageReader
operator|::
name|setBackgroundColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|BackgroundColor
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|BackgroundColor
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the background color that's used when reading an image.     If the image format does not support setting the background color     an invalid color is returned.      \sa setBackgroundColor(), read() */
end_comment
begin_function
DECL|function|backgroundColor
name|QColor
name|QImageReader
operator|::
name|backgroundColor
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
name|QColor
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|BackgroundColor
argument_list|)
condition|)
return|return
name|qvariant_cast
argument_list|<
name|QColor
argument_list|>
argument_list|(
name|d
operator|->
name|handler
operator|->
name|option
argument_list|(
name|QImageIOHandler
operator|::
name|BackgroundColor
argument_list|)
argument_list|)
return|;
return|return
name|QColor
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns true if the image format supports animation;     otherwise, false is returned.      \sa QMovie::supportedFormats() */
end_comment
begin_function
DECL|function|supportsAnimation
name|bool
name|QImageReader
operator|::
name|supportsAnimation
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Animation
argument_list|)
condition|)
return|return
name|d
operator|->
name|handler
operator|->
name|option
argument_list|(
name|QImageIOHandler
operator|::
name|Animation
argument_list|)
operator|.
name|toBool
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if an image can be read for the device (i.e., the     image format is supported, and the device seems to contain valid     data); otherwise returns false.      canRead() is a lightweight function that only does a quick test to     see if the image data is valid. read() may still return false     after canRead() returns true, if the image data is corrupt.      For images that support animation, canRead() returns false when     all frames have been read.      \sa read(), supportedImageFormats() */
end_comment
begin_function
DECL|function|canRead
name|bool
name|QImageReader
operator|::
name|canRead
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|canRead
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Reads an image from the device. On success, the image that was     read is returned; otherwise, a null QImage is returned. You can     then call error() to find the type of error that occurred, or     errorString() to get a human readable description of the error.      For image formats that support animation, calling read()     repeatedly will return the next frame. When all frames have been     read, a null image will be returned.      \sa canRead(), supportedImageFormats(), supportsAnimation(), QMovie */
end_comment
begin_function
DECL|function|read
name|QImage
name|QImageReader
operator|::
name|read
parameter_list|()
block|{
comment|// Because failed image reading might have side effects, we explicitly
comment|// return a null image instead of the image we've just created.
name|QImage
name|image
decl_stmt|;
return|return
name|read
argument_list|(
operator|&
name|image
argument_list|)
condition|?
name|image
else|:
name|QImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads an image from the device into \a image, which must point to a     QImage. Returns true on success; otherwise, returns false.      If \a image has same format and size as the image data that is about to be     read, this function may not need to allocate a new image before     reading. Because of this, it can be faster than the other read() overload,     which always constructs a new image; especially when reading several     images with the same format and size.      \snippet doc/src/snippets/code/src_gui_image_qimagereader.cpp 2      For image formats that support animation, calling read() repeatedly will     return the next frame. When all frames have been read, a null image will     be returned.      \sa canRead(), supportedImageFormats(), supportsAnimation(), QMovie */
end_comment
begin_function
DECL|function|read
name|bool
name|QImageReader
operator|::
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|image
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImageReader::read: cannot read into null pointer"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|handler
operator|&&
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// set the handler specific options.
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledSize
argument_list|)
operator|&&
name|d
operator|->
name|scaledSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|clipRect
operator|.
name|isNull
argument_list|()
operator|)
operator|||
name|d
operator|->
name|clipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Only enable the ScaledSize option if there is no clip rect, or
comment|// if the handler also supports ClipRect.
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledSize
argument_list|,
name|d
operator|->
name|scaledSize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|clipRect
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|ClipRect
argument_list|,
name|d
operator|->
name|clipRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|,
name|d
operator|->
name|scaledClipRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Quality
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|Quality
argument_list|,
name|d
operator|->
name|quality
argument_list|)
expr_stmt|;
comment|// read the image
if|if
condition|(
operator|!
name|d
operator|->
name|handler
operator|->
name|read
argument_list|(
name|image
argument_list|)
condition|)
block|{
name|d
operator|->
name|imageReaderError
operator|=
name|InvalidDataError
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageReader
argument_list|,
literal|"Unable to read image data"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// provide default implementations for any unsupported image
comment|// options
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|clipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledSize
argument_list|)
operator|&&
name|d
operator|->
name|scaledSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// all features are supported by the handler; nothing to do.
block|}
else|else
block|{
comment|// the image is already scaled, so apply scaled clipping.
if|if
condition|(
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
operator|*
name|image
operator|=
name|image
operator|->
name|copy
argument_list|(
name|d
operator|->
name|scaledClipRect
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// supports scaled clipping but not scaling, most
comment|// likely a broken handler.
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|scaledSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
operator|*
name|image
operator|=
name|image
operator|->
name|scaled
argument_list|(
name|d
operator|->
name|scaledSize
argument_list|,
name|Qt
operator|::
name|IgnoreAspectRatio
argument_list|,
name|Qt
operator|::
name|SmoothTransformation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|scaledClipRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
operator|*
name|image
operator|=
name|image
operator|->
name|copy
argument_list|(
name|d
operator|->
name|scaledClipRect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledSize
argument_list|)
operator|&&
name|d
operator|->
name|scaledSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// in this case, there's nothing we can do. if the
comment|// plugin supports scaled size but not ClipRect, then
comment|// we have to ignore ClipRect."
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// nothing to do (ClipRect is ignored!)
block|}
else|else
block|{
comment|// provide all workarounds.
if|if
condition|(
name|d
operator|->
name|scaledClipRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
operator|*
name|image
operator|=
name|image
operator|->
name|copy
argument_list|(
name|d
operator|->
name|scaledClipRect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|ScaledClipRect
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|scaledClipRect
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// this makes no sense; a handler that supports
comment|// ScaledClipRect but not ScaledSize is broken, and we
comment|// can't work around it.
block|}
else|else
block|{
comment|// provide all workarounds.
if|if
condition|(
name|d
operator|->
name|clipRect
operator|.
name|isValid
argument_list|()
condition|)
operator|*
name|image
operator|=
name|image
operator|->
name|copy
argument_list|(
name|d
operator|->
name|clipRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scaledSize
operator|.
name|isValid
argument_list|()
condition|)
operator|*
name|image
operator|=
name|image
operator|->
name|scaled
argument_list|(
name|d
operator|->
name|scaledSize
argument_list|,
name|Qt
operator|::
name|IgnoreAspectRatio
argument_list|,
name|Qt
operator|::
name|SmoothTransformation
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|scaledClipRect
operator|.
name|isValid
argument_list|()
condition|)
operator|*
name|image
operator|=
name|image
operator|->
name|copy
argument_list|(
name|d
operator|->
name|scaledClipRect
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!    For image formats that support animation, this function steps over the    current image, returning true if successful or false if there is no    following image in the animation.     The default implementation calls read(), then discards the resulting    image, but the image handler may have a more efficient way of implementing    this operation.     \sa jumpToImage(), QImageIOHandler::jumpToNextImage() */
end_comment
begin_function
DECL|function|jumpToNextImage
name|bool
name|QImageReader
operator|::
name|jumpToNextImage
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|jumpToNextImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    For image formats that support animation, this function skips to the image    whose sequence number is \a imageNumber, returning true if successful    or false if the corresponding image cannot be found.     The next call to read() will attempt to read this image.     \sa jumpToNextImage(), QImageIOHandler::jumpToImage() */
end_comment
begin_function
DECL|function|jumpToImage
name|bool
name|QImageReader
operator|::
name|jumpToImage
parameter_list|(
name|int
name|imageNumber
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|jumpToImage
argument_list|(
name|imageNumber
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support animation, this function returns the number     of times the animation should loop. If this function returns -1, it can     either mean the animation should loop forever, or that an error occurred.     If an error occurred, canRead() will return false.      \sa supportsAnimation(), QImageIOHandler::loopCount(), canRead() */
end_comment
begin_function
DECL|function|loopCount
name|int
name|QImageReader
operator|::
name|loopCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|loopCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support animation, this function returns the total     number of images in the animation. If the format does not support     animation, 0 is returned.      This function returns -1 if an error occurred.      \sa supportsAnimation(), QImageIOHandler::imageCount(), canRead() */
end_comment
begin_function
DECL|function|imageCount
name|int
name|QImageReader
operator|::
name|imageCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|imageCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support animation, this function returns the number     of milliseconds to wait until displaying the next frame in the animation.     If the image format doesn't support animation, 0 is returned.      This function returns -1 if an error occurred.      \sa supportsAnimation(), QImageIOHandler::nextImageDelay(), canRead() */
end_comment
begin_function
DECL|function|nextImageDelay
name|int
name|QImageReader
operator|::
name|nextImageDelay
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|nextImageDelay
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support animation, this function returns the     sequence number of the current frame. If the image format doesn't support     animation, 0 is returned.      This function returns -1 if an error occurred.      \sa supportsAnimation(), QImageIOHandler::currentImageNumber(), canRead() */
end_comment
begin_function
DECL|function|currentImageNumber
name|int
name|QImageReader
operator|::
name|currentImageNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|currentImageNumber
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support animation, this function returns     the rect for the current frame. Otherwise, a null rect is returned.      \sa supportsAnimation(), QImageIOHandler::currentImageRect() */
end_comment
begin_function
DECL|function|currentImageRect
name|QRect
name|QImageReader
operator|::
name|currentImageRect
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|currentImageRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of error that occurred last.      \sa ImageReaderError, errorString() */
end_comment
begin_function
DECL|function|error
name|QImageReader
operator|::
name|ImageReaderError
name|QImageReader
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|imageReaderError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a human readable description of the last error that     occurred.      \sa error() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QImageReader
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageReader
argument_list|,
literal|"Unknown error"
argument_list|)
argument_list|)
return|;
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if the reader supports \a option; otherwise returns     false.      Different image formats support different options. Call this function to     determine whether a certain option is supported by the current format. For     example, the PNG format allows you to embed text into the image's metadata     (see text()), and the BMP format allows you to determine the image's size     without loading the whole image into memory (see size()).      \snippet doc/src/snippets/code/src_gui_image_qimagereader.cpp 3      \sa QImageWriter::supportsOption() */
end_comment
begin_function
DECL|function|supportsOption
name|bool
name|QImageReader
operator|::
name|supportsOption
parameter_list|(
name|QImageIOHandler
operator|::
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|initHandler
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If supported, this function returns the image format of the file     \a fileName. Otherwise, an empty string is returned. */
end_comment
begin_function
DECL|function|imageFormat
name|QByteArray
name|QImageReader
operator|::
name|imageFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|imageFormat
argument_list|(
operator|&
name|file
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     If supported, this function returns the image format of the device     \a device. Otherwise, an empty string is returned.      \sa QImageReader::autoDetectImageFormat() */
end_comment
begin_function
DECL|function|imageFormat
name|QByteArray
name|QImageReader
operator|::
name|imageFormat
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|QByteArray
name|format
decl_stmt|;
name|QImageIOHandler
modifier|*
name|handler
init|=
name|createReadHandlerHelper
argument_list|(
name|device
argument_list|,
name|format
argument_list|,
comment|/* autoDetectImageFormat = */
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
condition|)
block|{
if|if
condition|(
name|handler
operator|->
name|canRead
argument_list|()
condition|)
name|format
operator|=
name|handler
operator|->
name|format
argument_list|()
expr_stmt|;
operator|delete
name|handler
expr_stmt|;
block|}
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of image formats supported by QImageReader.      By default, Qt can read the following formats:      \table     \header \o Format \o Description     \row    \o BMP    \o Windows Bitmap     \row    \o GIF    \o Graphic Interchange Format (optional)     \row    \o JPG    \o Joint Photographic Experts Group     \row    \o JPEG   \o Joint Photographic Experts Group     \row    \o PNG    \o Portable Network Graphics     \row    \o PBM    \o Portable Bitmap     \row    \o PGM    \o Portable Graymap     \row    \o PPM    \o Portable Pixmap     \row    \o TIFF   \o Tagged Image File Format     \row    \o XBM    \o X11 Bitmap     \row    \o XPM    \o X11 Pixmap     \row    \o SVG    \o Scalable Vector Graphics     \endtable      Reading and writing SVG files is supported through Qt's     \l{QtSvg Module}{SVG Module}.      To configure Qt with GIF support, pass \c -qt-gif to the \c     configure script or check the appropriate option in the graphical     installer.      Note that the QApplication instance must be created before this function is     called.      \sa setFormat(), QImageWriter::supportedImageFormats(), QImageIOPlugin */
end_comment
begin_function
DECL|function|supportedImageFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QImageReader
operator|::
name|supportedImageFormats
parameter_list|()
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|formats
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_qt_NumFormats
condition|;
operator|++
name|i
control|)
name|formats
operator|<<
name|_qt_BuiltInFormats
index|[
name|i
index|]
operator|.
name|extension
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|QFactoryLoader
modifier|*
name|l
init|=
name|loader
argument_list|()
decl_stmt|;
name|QStringList
name|keys
init|=
name|l
operator|->
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
name|plugin
operator|->
name|capabilities
argument_list|(
literal|0
argument_list|,
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanRead
condition|)
name|formats
operator|<<
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_LIBRARY
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|sortedFormats
decl_stmt|;
for|for
control|(
name|QSet
argument_list|<
name|QByteArray
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|formats
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|formats
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|sortedFormats
operator|<<
operator|*
name|it
expr_stmt|;
name|qSort
argument_list|(
name|sortedFormats
argument_list|)
expr_stmt|;
return|return
name|sortedFormats
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
