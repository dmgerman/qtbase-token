begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ** WARNING: **      A separate license from Unisys may be required to use the gif **      reader. See http://www.unisys.com/about__unisys/lzw/ **      for information from Unisys ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qgifhandler_p.h"
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|Q_TRANSPARENT
define|#
directive|define
name|Q_TRANSPARENT
value|0x00ffffff
end_define
begin_comment
comment|// avoid going through QImage::scanLine() which calls detach
end_comment
begin_define
DECL|macro|FAST_SCAN_LINE
define|#
directive|define
name|FAST_SCAN_LINE
parameter_list|(
name|bits
parameter_list|,
name|bpl
parameter_list|,
name|y
parameter_list|)
value|(bits + (y) * bpl)
end_define
begin_comment
comment|/*   Incremental image decoder for GIF image format.    This subclass of QImageFormat decodes GIF format images,   including animated GIFs. Internally in */
end_comment
begin_class
DECL|class|QGIFFormat
class|class
name|QGIFFormat
block|{
public|public:
name|QGIFFormat
parameter_list|()
constructor_decl|;
name|~
name|QGIFFormat
parameter_list|()
destructor_decl|;
name|int
name|decode
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|,
specifier|const
name|uchar
modifier|*
name|buffer
parameter_list|,
name|int
name|length
parameter_list|,
name|int
modifier|*
name|nextFrameDelay
parameter_list|,
name|int
modifier|*
name|loopCount
parameter_list|)
function_decl|;
specifier|static
name|void
name|scan
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QVector
argument_list|<
name|QSize
argument_list|>
modifier|*
name|imageSizes
parameter_list|,
name|int
modifier|*
name|loopCount
parameter_list|)
function_decl|;
DECL|member|newFrame
name|bool
name|newFrame
decl_stmt|;
DECL|member|partialNewFrame
name|bool
name|partialNewFrame
decl_stmt|;
private|private:
name|void
name|fillRect
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QRgb
name|col
parameter_list|)
function_decl|;
specifier|inline
name|QRgb
name|color
parameter_list|(
name|uchar
name|index
parameter_list|)
specifier|const
function_decl|;
comment|// GIF specific stuff
DECL|member|globalcmap
name|QRgb
modifier|*
name|globalcmap
decl_stmt|;
DECL|member|localcmap
name|QRgb
modifier|*
name|localcmap
decl_stmt|;
DECL|member|backingstore
name|QImage
name|backingstore
decl_stmt|;
DECL|member|hold
name|unsigned
name|char
name|hold
index|[
literal|16
index|]
decl_stmt|;
DECL|member|gif89
name|bool
name|gif89
decl_stmt|;
DECL|member|count
name|int
name|count
decl_stmt|;
DECL|member|ccount
name|int
name|ccount
decl_stmt|;
DECL|member|expectcount
name|int
name|expectcount
decl_stmt|;
DECL|enum|State
enum|enum
name|State
block|{
DECL|enumerator|Header
name|Header
block|,
DECL|enumerator|LogicalScreenDescriptor
name|LogicalScreenDescriptor
block|,
DECL|enumerator|GlobalColorMap
name|GlobalColorMap
block|,
DECL|enumerator|LocalColorMap
name|LocalColorMap
block|,
DECL|enumerator|Introducer
name|Introducer
block|,
DECL|enumerator|ImageDescriptor
name|ImageDescriptor
block|,
DECL|enumerator|TableImageLZWSize
name|TableImageLZWSize
block|,
DECL|enumerator|ImageDataBlockSize
name|ImageDataBlockSize
block|,
DECL|enumerator|ImageDataBlock
name|ImageDataBlock
block|,
DECL|enumerator|ExtensionLabel
name|ExtensionLabel
block|,
DECL|enumerator|GraphicControlExtension
name|GraphicControlExtension
block|,
DECL|enumerator|ApplicationExtension
name|ApplicationExtension
block|,
DECL|enumerator|NetscapeExtensionBlockSize
name|NetscapeExtensionBlockSize
block|,
DECL|enumerator|NetscapeExtensionBlock
name|NetscapeExtensionBlock
block|,
DECL|enumerator|SkipBlockSize
name|SkipBlockSize
block|,
DECL|enumerator|SkipBlock
name|SkipBlock
block|,
DECL|enumerator|Done
name|Done
block|,
DECL|enumerator|Error
name|Error
block|}
DECL|member|state
name|state
enum|;
DECL|member|gncols
name|int
name|gncols
decl_stmt|;
DECL|member|lncols
name|int
name|lncols
decl_stmt|;
DECL|member|ncols
name|int
name|ncols
decl_stmt|;
DECL|member|lzwsize
name|int
name|lzwsize
decl_stmt|;
DECL|member|lcmap
name|bool
name|lcmap
decl_stmt|;
DECL|member|swidth
DECL|member|sheight
name|int
name|swidth
decl_stmt|,
name|sheight
decl_stmt|;
DECL|member|width
DECL|member|height
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
DECL|member|left
DECL|member|top
DECL|member|right
DECL|member|bottom
name|int
name|left
decl_stmt|,
name|top
decl_stmt|,
name|right
decl_stmt|,
name|bottom
decl_stmt|;
DECL|enum|Disposal
DECL|enumerator|NoDisposal
DECL|enumerator|DoNotChange
DECL|enumerator|RestoreBackground
DECL|enumerator|RestoreImage
enum|enum
name|Disposal
block|{
name|NoDisposal
block|,
name|DoNotChange
block|,
name|RestoreBackground
block|,
name|RestoreImage
block|}
enum|;
DECL|member|disposal
name|Disposal
name|disposal
decl_stmt|;
DECL|member|disposed
name|bool
name|disposed
decl_stmt|;
DECL|member|trans_index
name|int
name|trans_index
decl_stmt|;
DECL|member|gcmap
name|bool
name|gcmap
decl_stmt|;
DECL|member|bgcol
name|int
name|bgcol
decl_stmt|;
DECL|member|interlace
name|int
name|interlace
decl_stmt|;
DECL|member|accum
name|int
name|accum
decl_stmt|;
DECL|member|bitcount
name|int
name|bitcount
decl_stmt|;
DECL|enumerator|max_lzw_bits
enum|enum
block|{
name|max_lzw_bits
init|=
literal|12
block|}
enum|;
comment|// (poor-compiler's static const int)
DECL|member|code_size
DECL|member|clear_code
DECL|member|end_code
DECL|member|max_code_size
DECL|member|max_code
name|int
name|code_size
decl_stmt|,
name|clear_code
decl_stmt|,
name|end_code
decl_stmt|,
name|max_code_size
decl_stmt|,
name|max_code
decl_stmt|;
DECL|member|firstcode
DECL|member|oldcode
DECL|member|incode
name|int
name|firstcode
decl_stmt|,
name|oldcode
decl_stmt|,
name|incode
decl_stmt|;
DECL|member|table
name|short
modifier|*
name|table
index|[
literal|2
index|]
decl_stmt|;
DECL|member|stack
name|short
modifier|*
name|stack
decl_stmt|;
DECL|member|sp
name|short
modifier|*
name|sp
decl_stmt|;
DECL|member|needfirst
name|bool
name|needfirst
decl_stmt|;
DECL|member|x
DECL|member|y
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
DECL|member|frame
name|int
name|frame
decl_stmt|;
DECL|member|out_of_bounds
name|bool
name|out_of_bounds
decl_stmt|;
DECL|member|digress
name|bool
name|digress
decl_stmt|;
name|void
name|nextY
parameter_list|(
name|unsigned
name|char
modifier|*
name|bits
parameter_list|,
name|int
name|bpl
parameter_list|)
function_decl|;
name|void
name|disposePrevious
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QGIFFormat. */
end_comment
begin_constructor
DECL|function|QGIFFormat
name|QGIFFormat
operator|::
name|QGIFFormat
parameter_list|()
block|{
name|globalcmap
operator|=
literal|0
expr_stmt|;
name|localcmap
operator|=
literal|0
expr_stmt|;
name|lncols
operator|=
literal|0
expr_stmt|;
name|gncols
operator|=
literal|0
expr_stmt|;
name|disposal
operator|=
name|NoDisposal
expr_stmt|;
name|out_of_bounds
operator|=
literal|false
expr_stmt|;
name|disposed
operator|=
literal|true
expr_stmt|;
name|frame
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|=
name|Header
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|lcmap
operator|=
literal|false
expr_stmt|;
name|newFrame
operator|=
literal|false
expr_stmt|;
name|partialNewFrame
operator|=
literal|false
expr_stmt|;
name|table
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|table
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stack
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys a QGIFFormat. */
end_comment
begin_destructor
DECL|function|~QGIFFormat
name|QGIFFormat
operator|::
name|~
name|QGIFFormat
parameter_list|()
block|{
if|if
condition|(
name|globalcmap
condition|)
operator|delete
index|[]
name|globalcmap
expr_stmt|;
if|if
condition|(
name|localcmap
condition|)
operator|delete
index|[]
name|localcmap
expr_stmt|;
operator|delete
index|[]
name|stack
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|disposePrevious
name|void
name|QGIFFormat
operator|::
name|disposePrevious
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|out_of_bounds
condition|)
block|{
comment|// flush anything that survived
comment|// ### Changed: QRect(0, 0, swidth, sheight)
block|}
comment|// Handle disposal of previous image before processing next one
if|if
condition|(
name|disposed
condition|)
return|return;
name|int
name|l
init|=
name|qMin
argument_list|(
name|swidth
operator|-
literal|1
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|qMin
argument_list|(
name|swidth
operator|-
literal|1
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|qMin
argument_list|(
name|sheight
operator|-
literal|1
argument_list|,
name|top
argument_list|)
decl_stmt|;
name|int
name|b
init|=
name|qMin
argument_list|(
name|sheight
operator|-
literal|1
argument_list|,
name|bottom
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|disposal
condition|)
block|{
case|case
name|NoDisposal
case|:
break|break;
case|case
name|DoNotChange
case|:
break|break;
case|case
name|RestoreBackground
case|:
if|if
condition|(
name|trans_index
operator|>=
literal|0
condition|)
block|{
comment|// Easy:  we use the transparent color
name|fillRect
argument_list|(
name|image
argument_list|,
name|l
argument_list|,
name|t
argument_list|,
name|r
operator|-
name|l
operator|+
literal|1
argument_list|,
name|b
operator|-
name|t
operator|+
literal|1
argument_list|,
name|Q_TRANSPARENT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bgcol
operator|>=
literal|0
condition|)
block|{
comment|// Easy:  we use the bgcol given
name|fillRect
argument_list|(
name|image
argument_list|,
name|l
argument_list|,
name|t
argument_list|,
name|r
operator|-
name|l
operator|+
literal|1
argument_list|,
name|b
operator|-
name|t
operator|+
literal|1
argument_list|,
name|color
argument_list|(
name|bgcol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Impossible:  We don't know of a bgcol - use pixel 0
name|QRgb
modifier|*
name|bits
init|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|->
name|bits
argument_list|()
decl_stmt|;
name|fillRect
argument_list|(
name|image
argument_list|,
name|l
argument_list|,
name|t
argument_list|,
name|r
operator|-
name|l
operator|+
literal|1
argument_list|,
name|b
operator|-
name|t
operator|+
literal|1
argument_list|,
name|bits
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// ### Changed: QRect(l, t, r-l+1, b-t+1)
break|break;
case|case
name|RestoreImage
case|:
block|{
if|if
condition|(
name|frame
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|ln
init|=
name|t
init|;
name|ln
operator|<=
name|b
condition|;
name|ln
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|image
operator|->
name|scanLine
argument_list|(
name|ln
argument_list|)
operator|+
name|l
argument_list|,
name|backingstore
operator|.
name|scanLine
argument_list|(
name|ln
operator|-
name|t
argument_list|)
argument_list|,
operator|(
name|r
operator|-
name|l
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ### Changed: QRect(l, t, r-l+1, b-t+1)
block|}
block|}
block|}
name|disposal
operator|=
name|NoDisposal
expr_stmt|;
comment|// Until an extension says otherwise.
name|disposed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function decodes some data into image changes.      Returns the number of bytes consumed. */
end_comment
begin_function
DECL|function|decode
name|int
name|QGIFFormat
operator|::
name|decode
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|,
specifier|const
name|uchar
modifier|*
name|buffer
parameter_list|,
name|int
name|length
parameter_list|,
name|int
modifier|*
name|nextFrameDelay
parameter_list|,
name|int
modifier|*
name|loopCount
parameter_list|)
block|{
comment|// We are required to state that
comment|//    "The Graphics Interchange Format(c) is the Copyright property of
comment|//    CompuServe Incorporated. GIF(sm) is a Service Mark property of
comment|//    CompuServe Incorporated."
if|if
condition|(
operator|!
name|stack
condition|)
block|{
name|stack
operator|=
operator|new
name|short
index|[
operator|(
literal|1
operator|<<
name|max_lzw_bits
operator|)
operator|*
literal|4
index|]
expr_stmt|;
name|table
index|[
literal|0
index|]
operator|=
operator|&
name|stack
index|[
operator|(
literal|1
operator|<<
name|max_lzw_bits
operator|)
operator|*
literal|2
index|]
expr_stmt|;
name|table
index|[
literal|1
index|]
operator|=
operator|&
name|stack
index|[
operator|(
literal|1
operator|<<
name|max_lzw_bits
operator|)
operator|*
literal|3
index|]
expr_stmt|;
block|}
name|image
operator|->
name|detach
argument_list|()
expr_stmt|;
name|int
name|bpl
init|=
name|image
operator|->
name|bytesPerLine
argument_list|()
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bits
init|=
name|image
operator|->
name|bits
argument_list|()
decl_stmt|;
DECL|macro|LM
define|#
directive|define
name|LM
parameter_list|(
name|l
parameter_list|,
name|m
parameter_list|)
value|(((m)<<8)|l)
name|digress
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|initial
init|=
name|length
decl_stmt|;
while|while
condition|(
operator|!
name|digress
operator|&&
name|length
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|unsigned
name|char
name|ch
init|=
operator|*
name|buffer
operator|++
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Header
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|6
condition|)
block|{
comment|// Header
name|gif89
operator|=
operator|(
name|hold
index|[
literal|3
index|]
operator|!=
literal|'8'
operator|||
name|hold
index|[
literal|4
index|]
operator|!=
literal|'7'
operator|)
expr_stmt|;
name|state
operator|=
name|LogicalScreenDescriptor
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|LogicalScreenDescriptor
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|7
condition|)
block|{
comment|// Logical Screen Descriptor
name|swidth
operator|=
name|LM
argument_list|(
name|hold
index|[
literal|0
index|]
argument_list|,
name|hold
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sheight
operator|=
name|LM
argument_list|(
name|hold
index|[
literal|2
index|]
argument_list|,
name|hold
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gcmap
operator|=
operator|!
operator|!
operator|(
name|hold
index|[
literal|4
index|]
operator|&
literal|0x80
operator|)
expr_stmt|;
comment|//UNUSED: bpchan=(((hold[4]&0x70)>>3)+1);
comment|//UNUSED: gcmsortflag=!!(hold[4]&0x08);
name|gncols
operator|=
literal|2
operator|<<
operator|(
name|hold
index|[
literal|4
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
name|bgcol
operator|=
operator|(
name|gcmap
operator|)
condition|?
name|hold
index|[
literal|5
index|]
else|:
operator|-
literal|1
expr_stmt|;
comment|//aspect=hold[6] ? double(hold[6]+15)/64.0 : 1.0;
name|trans_index
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|ncols
operator|=
name|gncols
expr_stmt|;
if|if
condition|(
name|gcmap
condition|)
block|{
name|ccount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|GlobalColorMap
expr_stmt|;
name|globalcmap
operator|=
operator|new
name|QRgb
index|[
name|gncols
operator|+
literal|1
index|]
expr_stmt|;
comment|// +1 for trans_index
name|globalcmap
index|[
name|gncols
index|]
operator|=
name|Q_TRANSPARENT
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GlobalColorMap
case|:
case|case
name|LocalColorMap
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
block|{
name|QRgb
name|rgb
init|=
name|qRgb
argument_list|(
name|hold
index|[
literal|0
index|]
argument_list|,
name|hold
index|[
literal|1
index|]
argument_list|,
name|hold
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|LocalColorMap
condition|)
block|{
if|if
condition|(
name|ccount
operator|<
name|lncols
condition|)
name|localcmap
index|[
name|ccount
index|]
operator|=
name|rgb
expr_stmt|;
block|}
else|else
block|{
name|globalcmap
index|[
name|ccount
index|]
operator|=
name|rgb
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ccount
operator|>=
name|ncols
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|LocalColorMap
condition|)
name|state
operator|=
name|TableImageLZWSize
expr_stmt|;
else|else
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|Introducer
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|','
case|:
name|state
operator|=
name|ImageDescriptor
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|state
operator|=
name|ExtensionLabel
expr_stmt|;
break|break;
case|case
literal|';'
case|:
comment|// ### Changed: QRect(0, 0, swidth, sheight)
name|state
operator|=
name|Done
expr_stmt|;
break|break;
default|default:
name|digress
operator|=
literal|true
expr_stmt|;
comment|// Unexpected Introducer - ignore block
name|state
operator|=
name|Error
expr_stmt|;
block|}
break|break;
case|case
name|ImageDescriptor
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|10
condition|)
block|{
name|int
name|newleft
init|=
name|LM
argument_list|(
name|hold
index|[
literal|1
index|]
argument_list|,
name|hold
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|newtop
init|=
name|LM
argument_list|(
name|hold
index|[
literal|3
index|]
argument_list|,
name|hold
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|int
name|newwidth
init|=
name|LM
argument_list|(
name|hold
index|[
literal|5
index|]
argument_list|,
name|hold
index|[
literal|6
index|]
argument_list|)
decl_stmt|;
name|int
name|newheight
init|=
name|LM
argument_list|(
name|hold
index|[
literal|7
index|]
argument_list|,
name|hold
index|[
literal|8
index|]
argument_list|)
decl_stmt|;
comment|// disbelieve ridiculous logical screen sizes,
comment|// unless the image frames are also large.
if|if
condition|(
name|swidth
operator|/
literal|10
operator|>
name|qMax
argument_list|(
name|newwidth
argument_list|,
literal|200
argument_list|)
condition|)
name|swidth
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sheight
operator|/
literal|10
operator|>
name|qMax
argument_list|(
name|newheight
argument_list|,
literal|200
argument_list|)
condition|)
name|sheight
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|swidth
operator|<=
literal|0
condition|)
name|swidth
operator|=
name|newleft
operator|+
name|newwidth
expr_stmt|;
if|if
condition|(
name|sheight
operator|<=
literal|0
condition|)
name|sheight
operator|=
name|newtop
operator|+
name|newheight
expr_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|trans_index
operator|>=
literal|0
condition|?
name|QImage
operator|::
name|Format_ARGB32
else|:
name|QImage
operator|::
name|Format_RGB32
decl_stmt|;
if|if
condition|(
name|image
operator|->
name|isNull
argument_list|()
condition|)
block|{
operator|(
operator|*
name|image
operator|)
operator|=
name|QImage
argument_list|(
name|swidth
argument_list|,
name|sheight
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|bpl
operator|=
name|image
operator|->
name|bytesPerLine
argument_list|()
expr_stmt|;
name|bits
operator|=
name|image
operator|->
name|bits
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|bits
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|disposePrevious
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|disposed
operator|=
literal|false
expr_stmt|;
name|left
operator|=
name|newleft
expr_stmt|;
name|top
operator|=
name|newtop
expr_stmt|;
name|width
operator|=
name|newwidth
expr_stmt|;
name|height
operator|=
name|newheight
expr_stmt|;
name|right
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|qMin
argument_list|(
name|left
operator|+
name|width
argument_list|,
name|swidth
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|qMin
argument_list|(
name|top
operator|+
name|height
argument_list|,
name|sheight
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lcmap
operator|=
operator|!
operator|!
operator|(
name|hold
index|[
literal|9
index|]
operator|&
literal|0x80
operator|)
expr_stmt|;
name|interlace
operator|=
operator|!
operator|!
operator|(
name|hold
index|[
literal|9
index|]
operator|&
literal|0x40
operator|)
expr_stmt|;
comment|//bool lcmsortflag=!!(hold[9]&0x20);
name|lncols
operator|=
name|lcmap
condition|?
operator|(
literal|2
operator|<<
operator|(
name|hold
index|[
literal|9
index|]
operator|&
literal|0x7
operator|)
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|lncols
condition|)
block|{
if|if
condition|(
name|localcmap
condition|)
operator|delete
index|[]
name|localcmap
expr_stmt|;
name|localcmap
operator|=
operator|new
name|QRgb
index|[
name|lncols
operator|+
literal|1
index|]
expr_stmt|;
name|localcmap
index|[
name|lncols
index|]
operator|=
name|Q_TRANSPARENT
expr_stmt|;
name|ncols
operator|=
name|lncols
expr_stmt|;
block|}
else|else
block|{
name|ncols
operator|=
name|gncols
expr_stmt|;
block|}
name|frame
operator|++
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|left
operator|||
name|top
operator|||
name|width
operator|<
name|swidth
operator|||
name|height
operator|<
name|sheight
condition|)
block|{
comment|// Not full-size image - erase with bg or transparent
if|if
condition|(
name|trans_index
operator|>=
literal|0
condition|)
block|{
name|fillRect
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|,
name|color
argument_list|(
name|trans_index
argument_list|)
argument_list|)
expr_stmt|;
comment|// ### Changed: QRect(0, 0, swidth, sheight)
block|}
elseif|else
if|if
condition|(
name|bgcol
operator|>=
literal|0
condition|)
block|{
name|fillRect
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|swidth
argument_list|,
name|sheight
argument_list|,
name|color
argument_list|(
name|bgcol
argument_list|)
argument_list|)
expr_stmt|;
comment|// ### Changed: QRect(0, 0, swidth, sheight)
block|}
block|}
block|}
if|if
condition|(
name|disposal
operator|==
name|RestoreImage
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|swidth
operator|-
literal|1
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|qMin
argument_list|(
name|swidth
operator|-
literal|1
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|int
name|t
init|=
name|qMin
argument_list|(
name|sheight
operator|-
literal|1
argument_list|,
name|top
argument_list|)
decl_stmt|;
name|int
name|b
init|=
name|qMin
argument_list|(
name|sheight
operator|-
literal|1
argument_list|,
name|bottom
argument_list|)
decl_stmt|;
name|int
name|w
init|=
name|r
operator|-
name|l
operator|+
literal|1
decl_stmt|;
name|int
name|h
init|=
name|b
operator|-
name|t
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|backingstore
operator|.
name|width
argument_list|()
operator|<
name|w
operator|||
name|backingstore
operator|.
name|height
argument_list|()
operator|<
name|h
condition|)
block|{
comment|// We just use the backing store as a byte array
name|backingstore
operator|=
name|QImage
argument_list|(
name|qMax
argument_list|(
name|backingstore
operator|.
name|width
argument_list|()
argument_list|,
name|w
argument_list|)
argument_list|,
name|qMax
argument_list|(
name|backingstore
operator|.
name|height
argument_list|()
argument_list|,
name|h
argument_list|)
argument_list|,
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bits
argument_list|,
literal|0
argument_list|,
name|image
operator|->
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|dest_bpl
init|=
name|backingstore
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest_data
init|=
name|backingstore
operator|.
name|bits
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ln
init|=
literal|0
init|;
name|ln
operator|<
name|h
condition|;
name|ln
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|FAST_SCAN_LINE
argument_list|(
name|dest_data
argument_list|,
name|dest_bpl
argument_list|,
name|ln
argument_list|)
argument_list|,
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|t
operator|+
name|ln
argument_list|)
operator|+
name|l
argument_list|,
name|w
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lcmap
condition|)
block|{
name|ccount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|LocalColorMap
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|TableImageLZWSize
expr_stmt|;
block|}
name|x
operator|=
name|left
expr_stmt|;
name|y
operator|=
name|top
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
name|bitcount
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
name|firstcode
operator|=
name|oldcode
operator|=
literal|0
expr_stmt|;
name|needfirst
operator|=
literal|true
expr_stmt|;
name|out_of_bounds
operator|=
name|left
operator|>=
name|swidth
operator|||
name|y
operator|>=
name|sheight
expr_stmt|;
block|}
break|break;
case|case
name|TableImageLZWSize
case|:
block|{
name|lzwsize
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|lzwsize
operator|>
name|max_lzw_bits
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
block|}
else|else
block|{
name|code_size
operator|=
name|lzwsize
operator|+
literal|1
expr_stmt|;
name|clear_code
operator|=
literal|1
operator|<<
name|lzwsize
expr_stmt|;
name|end_code
operator|=
name|clear_code
operator|+
literal|1
expr_stmt|;
name|max_code_size
operator|=
literal|2
operator|*
name|clear_code
expr_stmt|;
name|max_code
operator|=
name|clear_code
operator|+
literal|2
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clear_code
condition|;
name|i
operator|++
control|)
block|{
name|table
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|table
index|[
literal|1
index|]
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|state
operator|=
name|ImageDataBlockSize
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|ImageDataBlockSize
case|:
name|expectcount
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|expectcount
condition|)
block|{
name|state
operator|=
name|ImageDataBlock
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Introducer
expr_stmt|;
name|digress
operator|=
literal|true
expr_stmt|;
name|newFrame
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|ImageDataBlock
case|:
name|count
operator|++
expr_stmt|;
name|accum
operator||=
operator|(
name|ch
operator|<<
name|bitcount
operator|)
expr_stmt|;
name|bitcount
operator|+=
literal|8
expr_stmt|;
while|while
condition|(
name|bitcount
operator|>=
name|code_size
operator|&&
name|state
operator|==
name|ImageDataBlock
condition|)
block|{
name|int
name|code
init|=
name|accum
operator|&
operator|(
operator|(
literal|1
operator|<<
name|code_size
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|bitcount
operator|-=
name|code_size
expr_stmt|;
name|accum
operator|>>=
name|code_size
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|clear_code
condition|)
block|{
if|if
condition|(
operator|!
name|needfirst
condition|)
block|{
name|code_size
operator|=
name|lzwsize
operator|+
literal|1
expr_stmt|;
name|max_code_size
operator|=
literal|2
operator|*
name|clear_code
expr_stmt|;
name|max_code
operator|=
name|clear_code
operator|+
literal|2
expr_stmt|;
block|}
name|needfirst
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|end_code
condition|)
block|{
name|bitcount
operator|=
operator|-
literal|32768
expr_stmt|;
comment|// Left the block end arrive
block|}
else|else
block|{
if|if
condition|(
name|needfirst
condition|)
block|{
name|firstcode
operator|=
name|oldcode
operator|=
name|code
expr_stmt|;
if|if
condition|(
operator|!
name|out_of_bounds
operator|&&
name|image
operator|->
name|height
argument_list|()
operator|>
name|y
operator|&&
operator|(
operator|(
name|frame
operator|==
literal|0
operator|)
operator|||
operator|(
name|firstcode
operator|!=
name|trans_index
operator|)
operator|)
condition|)
operator|(
operator|(
name|QRgb
operator|*
operator|)
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
operator|)
index|[
name|x
index|]
operator|=
name|color
argument_list|(
name|firstcode
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|swidth
condition|)
name|out_of_bounds
operator|=
literal|true
expr_stmt|;
name|needfirst
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|left
operator|+
name|width
condition|)
block|{
name|x
operator|=
name|left
expr_stmt|;
name|out_of_bounds
operator|=
name|left
operator|>=
name|swidth
operator|||
name|y
operator|>=
name|sheight
expr_stmt|;
name|nextY
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|incode
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|max_code
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|firstcode
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
while|while
condition|(
name|code
operator|>=
name|clear_code
operator|+
literal|2
condition|)
block|{
if|if
condition|(
name|code
operator|>=
name|max_code
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|sp
operator|++
operator|=
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sp
operator|-
name|stack
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|max_lzw_bits
operator|)
operator|)
operator|*
literal|2
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|code
operator|=
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|sp
operator|++
operator|=
name|firstcode
operator|=
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
expr_stmt|;
name|code
operator|=
name|max_code
expr_stmt|;
if|if
condition|(
name|code
operator|<
operator|(
literal|1
operator|<<
name|max_lzw_bits
operator|)
condition|)
block|{
name|table
index|[
literal|0
index|]
index|[
name|code
index|]
operator|=
name|oldcode
expr_stmt|;
name|table
index|[
literal|1
index|]
index|[
name|code
index|]
operator|=
name|firstcode
expr_stmt|;
name|max_code
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|max_code
operator|>=
name|max_code_size
operator|)
operator|&&
operator|(
name|max_code_size
operator|<
operator|(
literal|1
operator|<<
name|max_lzw_bits
operator|)
operator|)
condition|)
block|{
name|max_code_size
operator|*=
literal|2
expr_stmt|;
name|code_size
operator|++
expr_stmt|;
block|}
block|}
name|oldcode
operator|=
name|incode
expr_stmt|;
specifier|const
name|int
name|h
init|=
name|image
operator|->
name|height
argument_list|()
decl_stmt|;
name|QRgb
modifier|*
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|out_of_bounds
operator|&&
name|h
operator|>
name|y
condition|)
name|line
operator|=
operator|(
name|QRgb
operator|*
operator|)
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|>
name|stack
condition|)
block|{
specifier|const
name|uchar
name|index
init|=
operator|*
operator|(
operator|--
name|sp
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|out_of_bounds
operator|&&
name|h
operator|>
name|y
operator|&&
operator|(
operator|(
name|frame
operator|==
literal|0
operator|)
operator|||
operator|(
name|index
operator|!=
name|trans_index
operator|)
operator|)
condition|)
block|{
name|line
index|[
name|x
index|]
operator|=
name|color
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|swidth
condition|)
name|out_of_bounds
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|left
operator|+
name|width
condition|)
block|{
name|x
operator|=
name|left
expr_stmt|;
name|out_of_bounds
operator|=
name|left
operator|>=
name|swidth
operator|||
name|y
operator|>=
name|sheight
expr_stmt|;
name|nextY
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out_of_bounds
operator|&&
name|h
operator|>
name|y
condition|)
name|line
operator|=
operator|(
name|QRgb
operator|*
operator|)
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|partialNewFrame
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|expectcount
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|ImageDataBlockSize
expr_stmt|;
block|}
break|break;
case|case
name|ExtensionLabel
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0xf9
case|:
name|state
operator|=
name|GraphicControlExtension
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|state
operator|=
name|ApplicationExtension
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 0xfe:                 state=CommentExtension;                 break;             case 0x01:                 break;
endif|#
directive|endif
default|default:
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ApplicationExtension
case|:
if|if
condition|(
name|count
operator|<
literal|11
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|hold
index|[
literal|0
index|]
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|qstrncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|hold
operator|+
literal|1
operator|)
argument_list|,
literal|"NETSCAPE"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Looping extension
name|state
operator|=
name|NetscapeExtensionBlockSize
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|NetscapeExtensionBlockSize
case|:
name|expectcount
operator|=
name|ch
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expectcount
condition|)
name|state
operator|=
name|NetscapeExtensionBlock
expr_stmt|;
else|else
name|state
operator|=
name|Introducer
expr_stmt|;
break|break;
case|case
name|NetscapeExtensionBlock
case|:
if|if
condition|(
name|count
operator|<
literal|3
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|expectcount
condition|)
block|{
operator|*
name|loopCount
operator|=
name|hold
index|[
literal|1
index|]
operator|+
name|hold
index|[
literal|2
index|]
operator|*
literal|256
expr_stmt|;
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
comment|// Ignore further blocks
block|}
break|break;
case|case
name|GraphicControlExtension
case|:
if|if
condition|(
name|count
operator|<
literal|5
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|hold
index|[
literal|0
index|]
operator|+
literal|1
condition|)
block|{
name|disposePrevious
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|disposal
operator|=
name|Disposal
argument_list|(
operator|(
name|hold
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x7
argument_list|)
expr_stmt|;
comment|//UNUSED: waitforuser=!!((hold[1]>>1)&0x1);
name|int
name|delay
init|=
name|count
operator|>
literal|3
condition|?
name|LM
argument_list|(
name|hold
index|[
literal|2
index|]
argument_list|,
name|hold
index|[
literal|3
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
comment|// IE and mozilla use a minimum delay of 10. With the minimum delay of 10
comment|// we are compatible to them and avoid huge loads on the app and xserver.
operator|*
name|nextFrameDelay
operator|=
operator|(
name|delay
operator|<
literal|2
condition|?
literal|10
else|:
name|delay
operator|)
operator|*
literal|10
expr_stmt|;
name|bool
name|havetrans
init|=
name|hold
index|[
literal|1
index|]
operator|&
literal|0x1
decl_stmt|;
name|trans_index
operator|=
name|havetrans
condition|?
name|hold
index|[
literal|4
index|]
else|:
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
break|break;
case|case
name|SkipBlockSize
case|:
name|expectcount
operator|=
name|ch
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expectcount
condition|)
name|state
operator|=
name|SkipBlock
expr_stmt|;
else|else
name|state
operator|=
name|Introducer
expr_stmt|;
break|break;
case|case
name|SkipBlock
case|:
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|expectcount
condition|)
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|digress
operator|=
literal|true
expr_stmt|;
comment|/* Netscape ignores the junk, so we do too.             length++; // Unget             state=Error; // More calls to this is an error             */
break|break;
case|case
name|Error
case|:
return|return
operator|-
literal|1
return|;
comment|// Called again after done.
block|}
block|}
return|return
name|initial
operator|-
name|length
return|;
block|}
end_function
begin_comment
comment|/*!    Scans through the data stream defined by \a device and returns the image    sizes found in the stream in the \a imageSizes vector. */
end_comment
begin_function
DECL|function|scan
name|void
name|QGIFFormat
operator|::
name|scan
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QVector
argument_list|<
name|QSize
argument_list|>
modifier|*
name|imageSizes
parameter_list|,
name|int
modifier|*
name|loopCount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
return|return;
name|qint64
name|oldPos
init|=
name|device
operator|->
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|seek
argument_list|(
literal|0
argument_list|)
condition|)
return|return;
name|int
name|colorCount
init|=
literal|0
decl_stmt|;
name|int
name|localColorCount
init|=
literal|0
decl_stmt|;
name|int
name|globalColorCount
init|=
literal|0
decl_stmt|;
name|int
name|colorReadCount
init|=
literal|0
decl_stmt|;
name|bool
name|localColormap
init|=
literal|false
decl_stmt|;
name|bool
name|globalColormap
init|=
literal|false
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|blockSize
init|=
literal|0
decl_stmt|;
name|int
name|imageWidth
init|=
literal|0
decl_stmt|;
name|int
name|imageHeight
init|=
literal|0
decl_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|uchar
name|hold
index|[
literal|16
index|]
decl_stmt|;
name|State
name|state
init|=
name|Header
decl_stmt|;
specifier|const
name|int
name|readBufferSize
init|=
literal|40960
decl_stmt|;
comment|// 40k read buffer
name|QByteArray
name|readBuffer
argument_list|(
name|device
operator|->
name|read
argument_list|(
name|readBufferSize
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|device
operator|->
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This is a specialized version of the state machine from decode(),
comment|// which doesn't do any image decoding or mallocing, and has an
comment|// optimized way of skipping SkipBlocks, ImageDataBlocks and
comment|// Global/LocalColorMaps.
while|while
condition|(
operator|!
name|readBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|length
init|=
name|readBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|buffer
init|=
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|readBuffer
operator|.
name|constData
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|length
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|uchar
name|ch
init|=
operator|*
name|buffer
operator|++
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Header
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|6
condition|)
block|{
name|state
operator|=
name|LogicalScreenDescriptor
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|LogicalScreenDescriptor
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|7
condition|)
block|{
name|imageWidth
operator|=
name|LM
argument_list|(
name|hold
index|[
literal|0
index|]
argument_list|,
name|hold
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|imageHeight
operator|=
name|LM
argument_list|(
name|hold
index|[
literal|2
index|]
argument_list|,
name|hold
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|globalColormap
operator|=
operator|!
operator|!
operator|(
name|hold
index|[
literal|4
index|]
operator|&
literal|0x80
operator|)
expr_stmt|;
name|globalColorCount
operator|=
literal|2
operator|<<
operator|(
name|hold
index|[
literal|4
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|colorCount
operator|=
name|globalColorCount
expr_stmt|;
if|if
condition|(
name|globalColormap
condition|)
block|{
name|int
name|colorTableSize
init|=
literal|3
operator|*
name|globalColorCount
decl_stmt|;
if|if
condition|(
name|length
operator|>=
name|colorTableSize
condition|)
block|{
comment|// skip the global color table in one go
name|length
operator|-=
name|colorTableSize
expr_stmt|;
name|buffer
operator|+=
name|colorTableSize
expr_stmt|;
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
else|else
block|{
name|colorReadCount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|GlobalColorMap
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GlobalColorMap
case|:
case|case
name|LocalColorMap
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|++
name|colorReadCount
operator|>=
name|colorCount
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|LocalColorMap
condition|)
name|state
operator|=
name|TableImageLZWSize
expr_stmt|;
else|else
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|Introducer
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x2c
case|:
name|state
operator|=
name|ImageDescriptor
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
name|state
operator|=
name|ExtensionLabel
expr_stmt|;
break|break;
case|case
literal|0x3b
case|:
name|state
operator|=
name|Done
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|Error
expr_stmt|;
block|}
break|break;
case|case
name|ImageDescriptor
case|:
name|hold
index|[
name|count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|10
condition|)
block|{
name|int
name|newLeft
init|=
name|LM
argument_list|(
name|hold
index|[
literal|1
index|]
argument_list|,
name|hold
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|newTop
init|=
name|LM
argument_list|(
name|hold
index|[
literal|3
index|]
argument_list|,
name|hold
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|int
name|newWidth
init|=
name|LM
argument_list|(
name|hold
index|[
literal|5
index|]
argument_list|,
name|hold
index|[
literal|6
index|]
argument_list|)
decl_stmt|;
name|int
name|newHeight
init|=
name|LM
argument_list|(
name|hold
index|[
literal|7
index|]
argument_list|,
name|hold
index|[
literal|8
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|imageWidth
operator|/
literal|10
operator|>
name|qMax
argument_list|(
name|newWidth
argument_list|,
literal|200
argument_list|)
condition|)
name|imageWidth
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imageHeight
operator|/
literal|10
operator|>
name|qMax
argument_list|(
name|newHeight
argument_list|,
literal|200
argument_list|)
condition|)
name|imageHeight
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|imageWidth
operator|<=
literal|0
condition|)
name|imageWidth
operator|=
name|newLeft
operator|+
name|newWidth
expr_stmt|;
if|if
condition|(
name|imageHeight
operator|<=
literal|0
condition|)
name|imageHeight
operator|=
name|newTop
operator|+
name|newHeight
expr_stmt|;
operator|*
name|imageSizes
operator|<<
name|QSize
argument_list|(
name|imageWidth
argument_list|,
name|imageHeight
argument_list|)
expr_stmt|;
name|localColormap
operator|=
operator|!
operator|!
operator|(
name|hold
index|[
literal|9
index|]
operator|&
literal|0x80
operator|)
expr_stmt|;
name|localColorCount
operator|=
name|localColormap
condition|?
operator|(
literal|2
operator|<<
operator|(
name|hold
index|[
literal|9
index|]
operator|&
literal|0x7
operator|)
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|localColorCount
condition|)
name|colorCount
operator|=
name|localColorCount
expr_stmt|;
else|else
name|colorCount
operator|=
name|globalColorCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|localColormap
condition|)
block|{
name|int
name|colorTableSize
init|=
literal|3
operator|*
name|localColorCount
decl_stmt|;
if|if
condition|(
name|length
operator|>=
name|colorTableSize
condition|)
block|{
comment|// skip the local color table in one go
name|length
operator|-=
name|colorTableSize
expr_stmt|;
name|buffer
operator|+=
name|colorTableSize
expr_stmt|;
name|state
operator|=
name|TableImageLZWSize
expr_stmt|;
block|}
else|else
block|{
name|colorReadCount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|LocalColorMap
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|TableImageLZWSize
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TableImageLZWSize
case|:
if|if
condition|(
name|ch
operator|>
name|max_lzw_bits
condition|)
name|state
operator|=
name|Error
expr_stmt|;
else|else
name|state
operator|=
name|ImageDataBlockSize
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ImageDataBlockSize
case|:
name|blockSize
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|blockSize
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|blockSize
condition|)
block|{
comment|// we can skip the block in one go
name|length
operator|-=
name|blockSize
expr_stmt|;
name|buffer
operator|+=
name|blockSize
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|ImageDataBlock
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
break|break;
case|case
name|ImageDataBlock
case|:
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|blockSize
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|ImageDataBlockSize
expr_stmt|;
block|}
break|break;
case|case
name|ExtensionLabel
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0xf9
case|:
name|state
operator|=
name|GraphicControlExtension
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|state
operator|=
name|ApplicationExtension
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ApplicationExtension
case|:
if|if
condition|(
name|count
operator|<
literal|11
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|hold
index|[
literal|0
index|]
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|qstrncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|hold
operator|+
literal|1
operator|)
argument_list|,
literal|"NETSCAPE"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|=
name|NetscapeExtensionBlockSize
expr_stmt|;
else|else
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|GraphicControlExtension
case|:
if|if
condition|(
name|count
operator|<
literal|5
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|hold
index|[
literal|0
index|]
operator|+
literal|1
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
break|break;
case|case
name|NetscapeExtensionBlockSize
case|:
name|blockSize
operator|=
name|ch
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blockSize
condition|)
name|state
operator|=
name|NetscapeExtensionBlock
expr_stmt|;
else|else
name|state
operator|=
name|Introducer
expr_stmt|;
break|break;
case|case
name|NetscapeExtensionBlock
case|:
if|if
condition|(
name|count
operator|<
literal|3
condition|)
name|hold
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|blockSize
condition|)
block|{
operator|*
name|loopCount
operator|=
name|LM
argument_list|(
name|hold
index|[
literal|1
index|]
argument_list|,
name|hold
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
block|}
break|break;
case|case
name|SkipBlockSize
case|:
name|blockSize
operator|=
name|ch
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blockSize
condition|)
block|{
if|if
condition|(
name|length
operator|>=
name|blockSize
condition|)
block|{
comment|// we can skip the block in one go
name|length
operator|-=
name|blockSize
expr_stmt|;
name|buffer
operator|+=
name|blockSize
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|SkipBlock
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Introducer
expr_stmt|;
block|}
break|break;
case|case
name|SkipBlock
case|:
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|blockSize
condition|)
name|state
operator|=
name|SkipBlockSize
expr_stmt|;
break|break;
case|case
name|Done
case|:
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Error
case|:
name|device
operator|->
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|readBuffer
operator|=
name|device
operator|->
name|read
argument_list|(
name|readBufferSize
argument_list|)
expr_stmt|;
block|}
name|device
operator|->
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|fillRect
name|void
name|QGIFFormat
operator|::
name|fillRect
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QRgb
name|color
parameter_list|)
block|{
if|if
condition|(
name|w
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|h
condition|;
name|j
operator|++
control|)
block|{
name|QRgb
modifier|*
name|line
init|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|->
name|scanLine
argument_list|(
name|j
operator|+
name|row
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|line
operator|+
name|col
operator|+
name|i
operator|)
operator|=
name|color
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|nextY
name|void
name|QGIFFormat
operator|::
name|nextY
parameter_list|(
name|unsigned
name|char
modifier|*
name|bits
parameter_list|,
name|int
name|bpl
parameter_list|)
block|{
name|int
name|my
decl_stmt|;
switch|switch
condition|(
name|interlace
condition|)
block|{
case|case
literal|0
case|:
comment|// Non-interlaced
comment|// if (!out_of_bounds) {
comment|//     ### Changed: QRect(left, y, right - left + 1, 1);
comment|// }
name|y
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
name|int
name|i
decl_stmt|;
name|my
operator|=
name|qMin
argument_list|(
literal|7
argument_list|,
name|bottom
operator|-
name|y
argument_list|)
expr_stmt|;
comment|// Don't dup with transparency
if|if
condition|(
name|trans_index
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|my
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
operator|+
name|i
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
operator|(
name|right
operator|-
name|left
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if (!out_of_bounds) {
comment|//     ### Changed: QRect(left, y, right - left + 1, my + 1);
comment|// }
comment|//        if (!out_of_bounds)
comment|//            qDebug("consumer->changed(QRect(%d, %d, %d, %d))", left, y, right-left+1, my+1);
name|y
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
name|interlace
operator|++
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
comment|// for really broken GIFs with bottom< 5
name|interlace
operator|=
literal|2
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
comment|// for really broken GIF with bottom< 3
name|interlace
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
literal|2
case|:
block|{
name|int
name|i
decl_stmt|;
name|my
operator|=
name|qMin
argument_list|(
literal|3
argument_list|,
name|bottom
operator|-
name|y
argument_list|)
expr_stmt|;
comment|// Don't dup with transparency
if|if
condition|(
name|trans_index
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|my
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
operator|+
name|i
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
operator|(
name|right
operator|-
name|left
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if (!out_of_bounds) {
comment|//     ### Changed: QRect(left, y, right - left + 1, my + 1);
comment|// }
name|y
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
name|interlace
operator|++
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|2
expr_stmt|;
comment|// handle broken GIF with bottom< 3
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
name|interlace
operator|=
literal|3
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|3
case|:
block|{
name|int
name|i
decl_stmt|;
name|my
operator|=
name|qMin
argument_list|(
literal|1
argument_list|,
name|bottom
operator|-
name|y
argument_list|)
expr_stmt|;
comment|// Don't dup with transparency
if|if
condition|(
name|trans_index
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|my
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
operator|+
name|i
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
name|FAST_SCAN_LINE
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|y
argument_list|)
operator|+
name|left
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|,
operator|(
name|right
operator|-
name|left
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QRgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if (!out_of_bounds) {
comment|//     ### Changed: QRect(left, y, right - left + 1, my + 1);
comment|// }
name|y
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|bottom
condition|)
block|{
name|interlace
operator|++
expr_stmt|;
name|y
operator|=
name|top
operator|+
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|4
case|:
comment|// if (!out_of_bounds) {
comment|//     ### Changed: QRect(left, y, right - left + 1, 1);
comment|// }
name|y
operator|+=
literal|2
expr_stmt|;
block|}
comment|// Consume bogus extra lines
if|if
condition|(
name|y
operator|>=
name|sheight
condition|)
name|out_of_bounds
operator|=
literal|true
expr_stmt|;
comment|//y=bottom;
block|}
end_function
begin_function
DECL|function|color
specifier|inline
name|QRgb
name|QGIFFormat
operator|::
name|color
parameter_list|(
name|uchar
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|>
name|ncols
condition|)
return|return
name|Q_TRANSPARENT
return|;
name|QRgb
modifier|*
name|map
init|=
name|lcmap
condition|?
name|localcmap
else|:
name|globalcmap
decl_stmt|;
name|QRgb
name|col
init|=
name|map
condition|?
name|map
index|[
name|index
index|]
else|:
literal|0
decl_stmt|;
return|return
name|index
operator|==
name|trans_index
condition|?
name|col
operator|&
name|Q_TRANSPARENT
else|:
name|col
return|;
block|}
end_function
begin_comment
comment|//-------------------------------------------------------------------------
end_comment
begin_comment
comment|//-------------------------------------------------------------------------
end_comment
begin_comment
comment|//-------------------------------------------------------------------------
end_comment
begin_constructor
DECL|function|QGifHandler
name|QGifHandler
operator|::
name|QGifHandler
parameter_list|()
block|{
name|gifFormat
operator|=
operator|new
name|QGIFFormat
expr_stmt|;
name|nextDelay
operator|=
literal|100
expr_stmt|;
name|loopCnt
operator|=
operator|-
literal|1
expr_stmt|;
name|frameNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|scanIsCached
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QGifHandler
name|QGifHandler
operator|::
name|~
name|QGifHandler
parameter_list|()
block|{
operator|delete
name|gifFormat
expr_stmt|;
block|}
end_destructor
begin_comment
comment|// Does partial decode if necessary, just to see if an image is coming
end_comment
begin_function
DECL|function|imageIsComing
name|bool
name|QGifHandler
operator|::
name|imageIsComing
parameter_list|()
specifier|const
block|{
specifier|const
name|int
name|GifChunkSize
init|=
literal|4096
decl_stmt|;
while|while
condition|(
operator|!
name|gifFormat
operator|->
name|partialNewFrame
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buffer
operator|+=
name|device
argument_list|()
operator|->
name|read
argument_list|(
name|GifChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
block|}
name|int
name|decoded
init|=
name|gifFormat
operator|->
name|decode
argument_list|(
operator|&
name|lastImage
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|buffer
operator|.
name|constData
argument_list|()
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|nextDelay
argument_list|,
operator|&
name|loopCnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|decoded
operator|==
operator|-
literal|1
condition|)
break|break;
name|buffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
return|return
name|gifFormat
operator|->
name|partialNewFrame
return|;
block|}
end_function
begin_function
DECL|function|canRead
name|bool
name|QGifHandler
operator|::
name|canRead
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|canRead
argument_list|(
name|device
argument_list|()
argument_list|)
operator|||
name|imageIsComing
argument_list|()
condition|)
block|{
name|setFormat
argument_list|(
literal|"gif"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canRead
name|bool
name|QGifHandler
operator|::
name|canRead
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QGifHandler::canRead() called with no device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|char
name|head
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|peek
argument_list|(
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|head
argument_list|)
condition|)
return|return
name|qstrncmp
argument_list|(
name|head
argument_list|,
literal|"GIF87a"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|qstrncmp
argument_list|(
name|head
argument_list|,
literal|"GIF89a"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QGifHandler
operator|::
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
specifier|const
name|int
name|GifChunkSize
init|=
literal|4096
decl_stmt|;
while|while
condition|(
operator|!
name|gifFormat
operator|->
name|newFrame
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buffer
operator|+=
name|device
argument_list|()
operator|->
name|read
argument_list|(
name|GifChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
block|}
name|int
name|decoded
init|=
name|gifFormat
operator|->
name|decode
argument_list|(
operator|&
name|lastImage
argument_list|,
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|buffer
operator|.
name|constData
argument_list|()
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|nextDelay
argument_list|,
operator|&
name|loopCnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|decoded
operator|==
operator|-
literal|1
condition|)
break|break;
name|buffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gifFormat
operator|->
name|newFrame
operator|||
operator|(
name|gifFormat
operator|->
name|partialNewFrame
operator|&&
name|device
argument_list|()
operator|->
name|atEnd
argument_list|()
operator|)
condition|)
block|{
operator|*
name|image
operator|=
name|lastImage
expr_stmt|;
operator|++
name|frameNumber
expr_stmt|;
name|gifFormat
operator|->
name|newFrame
operator|=
literal|false
expr_stmt|;
name|gifFormat
operator|->
name|partialNewFrame
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|write
name|bool
name|QGifHandler
operator|::
name|write
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|supportsOption
name|bool
name|QGifHandler
operator|::
name|supportsOption
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|device
argument_list|()
operator|||
name|device
argument_list|()
operator|->
name|isSequential
argument_list|()
condition|)
return|return
name|option
operator|==
name|Animation
return|;
else|else
return|return
name|option
operator|==
name|Size
operator|||
name|option
operator|==
name|Animation
return|;
block|}
end_function
begin_function
DECL|function|option
name|QVariant
name|QGifHandler
operator|::
name|option
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|option
operator|==
name|Size
condition|)
block|{
if|if
condition|(
operator|!
name|scanIsCached
condition|)
block|{
name|QGIFFormat
operator|::
name|scan
argument_list|(
name|device
argument_list|()
argument_list|,
operator|&
name|imageSizes
argument_list|,
operator|&
name|loopCnt
argument_list|)
expr_stmt|;
name|scanIsCached
operator|=
literal|true
expr_stmt|;
block|}
comment|// before the first frame is read, or we have an empty data stream
if|if
condition|(
name|frameNumber
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|imageSizes
operator|.
name|count
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|QVariant
argument_list|(
name|imageSizes
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
else|:
name|QVariant
argument_list|()
return|;
comment|// after the last frame has been read, the next size is undefined
if|if
condition|(
name|frameNumber
operator|>=
name|imageSizes
operator|.
name|count
argument_list|()
operator|-
literal|1
condition|)
return|return
name|QVariant
argument_list|()
return|;
comment|// and the last case: the size of the next frame
return|return
name|imageSizes
operator|.
name|at
argument_list|(
name|frameNumber
operator|+
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|option
operator|==
name|Animation
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setOption
name|void
name|QGifHandler
operator|::
name|setOption
parameter_list|(
name|ImageOption
name|option
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nextImageDelay
name|int
name|QGifHandler
operator|::
name|nextImageDelay
parameter_list|()
specifier|const
block|{
return|return
name|nextDelay
return|;
block|}
end_function
begin_function
DECL|function|imageCount
name|int
name|QGifHandler
operator|::
name|imageCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|scanIsCached
condition|)
block|{
name|QGIFFormat
operator|::
name|scan
argument_list|(
name|device
argument_list|()
argument_list|,
operator|&
name|imageSizes
argument_list|,
operator|&
name|loopCnt
argument_list|)
expr_stmt|;
name|scanIsCached
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|imageSizes
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|loopCount
name|int
name|QGifHandler
operator|::
name|loopCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|scanIsCached
condition|)
block|{
name|QGIFFormat
operator|::
name|scan
argument_list|(
name|device
argument_list|()
argument_list|,
operator|&
name|imageSizes
argument_list|,
operator|&
name|loopCnt
argument_list|)
expr_stmt|;
name|scanIsCached
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|loopCnt
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|loopCnt
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
name|loopCnt
return|;
block|}
end_function
begin_function
DECL|function|currentImageNumber
name|int
name|QGifHandler
operator|::
name|currentImageNumber
parameter_list|()
specifier|const
block|{
return|return
name|frameNumber
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QGifHandler
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"gif"
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
