begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!      \class QMovie      \brief The QMovie class is a convenience class for playing movies     with QImageReader.      \ingroup painting      This class is used to show simple animations without sound. If you want     to display video and media content, use the \l{Phonon Module}{Phonon}     multimedia framework instead.      First, create a QMovie object by passing either the name of a file or a     pointer to a QIODevice containing an animated image format to QMovie's     constructor. You can call isValid() to check if the image data is valid,     before starting the movie. To start the movie, call start(). QMovie will     enter \l Running state, and emit started() and stateChanged(). To get the     current state of the movie, call state().      To display the movie in your application, you can pass your QMovie object     to QLabel::setMovie(). Example:      \snippet doc/src/snippets/code/src_gui_image_qmovie.cpp 0      Whenever a new frame is available in the movie, QMovie will emit     updated(). If the size of the frame changes, resized() is emitted. You can     call currentImage() or currentPixmap() to get a copy of the current     frame. When the movie is done, QMovie emits finished(). If any error     occurs during playback (i.e, the image file is corrupt), QMovie will emit     error().      You can control the speed of the movie playback by calling setSpeed(),     which takes the percentage of the original speed as an argument. Pause the     movie by calling setPaused(true). QMovie will then enter \l Paused state     and emit stateChanged(). If you call setPaused(false), QMovie will reenter     \l Running state and start the movie again. To stop the movie, call     stop().      Certain animation formats allow you to set the background color. You can     call setBackgroundColor() to set the color, or backgroundColor() to     retrieve the current background color.      currentFrameNumber() returns the sequence number of the current frame. The     first frame in the animation has the sequence number 0. frameCount()     returns the total number of frames in the animation, if the image format     supports this. You can call loopCount() to get the number of times the     movie should loop before finishing. nextFrameDelay() returns the number of     milliseconds the current frame should be displayed.      QMovie can be instructed to cache frames of an animation by calling     setCacheMode().      Call supportedFormats() for a list of formats that QMovie supports.      \sa QLabel, QImageReader, {Movie Example} */
end_comment
begin_comment
comment|/*! \enum QMovie::MovieState      This enum describes the different states of QMovie.      \value NotRunning The movie is not running. This is QMovie's initial     state, and the state it enters after stop() has been called or the movie     is finished.      \value Paused The movie is paused, and QMovie stops emitting updated() or     resized(). This state is entered after calling pause() or     setPaused(true). The current frame number it kept, and the movie will     continue with the next frame when unpause() or setPaused(false) is called.      \value Running The movie is running. */
end_comment
begin_comment
comment|/*! \enum QMovie::CacheMode      This enum describes the different cache modes of QMovie.      \value CacheNone No frames are cached (the default).      \value CacheAll All frames are cached. */
end_comment
begin_comment
comment|/*! \fn void QMovie::started()      This signal is emitted after QMovie::start() has been called, and QMovie     has entered QMovie::Running state. */
end_comment
begin_comment
comment|/*! \fn void QMovie::resized(const QSize&size)      This signal is emitted when the current frame has been resized to \a     size. This effect is sometimes used in animations as an alternative to     replacing the frame. You can call currentImage() or currentPixmap() to get a     copy of the updated frame. */
end_comment
begin_comment
comment|/*! \fn void QMovie::updated(const QRect&rect)      This signal is emitted when the rect \a rect in the current frame has been     updated. You can call currentImage() or currentPixmap() to get a copy of the     updated frame. */
end_comment
begin_comment
comment|/*! \fn void QMovie::frameChanged(int frameNumber)     \since 4.1      This signal is emitted when the frame number has changed to     \a frameNumber.  You can call currentImage() or currentPixmap() to get a     copy of the frame. */
end_comment
begin_comment
comment|/*!      \fn void QMovie::stateChanged(QMovie::MovieState state)      This signal is emitted every time the state of the movie changes. The new     state is specified by \a state.      \sa QMovie::state() */
end_comment
begin_comment
comment|/*! \fn void QMovie::error(QImageReader::ImageReaderError error)      This signal is emitted by QMovie when the error \a error occurred during     playback.  QMovie will stop the movie, and enter QMovie::NotRunning state. */
end_comment
begin_comment
comment|/*! \fn void QMovie::finished()      This signal is emitted when the movie has finished.      \sa QMovie::stop() */
end_comment
begin_include
include|#
directive|include
file|"qglobal.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_MOVIE
end_ifndef
begin_include
include|#
directive|include
file|"qmovie.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|"qpair.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_define
DECL|macro|QMOVIE_INVALID_DELAY
define|#
directive|define
name|QMOVIE_INVALID_DELAY
value|-1
end_define
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QFrameInfo
class|class
name|QFrameInfo
block|{
public|public:
DECL|member|pixmap
name|QPixmap
name|pixmap
decl_stmt|;
DECL|member|delay
name|int
name|delay
decl_stmt|;
DECL|member|endMark
name|bool
name|endMark
decl_stmt|;
DECL|function|QFrameInfo
specifier|inline
name|QFrameInfo
parameter_list|(
name|bool
name|endMark
parameter_list|)
member_init_list|:
name|pixmap
argument_list|(
name|QPixmap
argument_list|()
argument_list|)
member_init_list|,
name|delay
argument_list|(
name|QMOVIE_INVALID_DELAY
argument_list|)
member_init_list|,
name|endMark
argument_list|(
name|endMark
argument_list|)
block|{ }
DECL|function|QFrameInfo
specifier|inline
name|QFrameInfo
parameter_list|()
member_init_list|:
name|pixmap
argument_list|(
name|QPixmap
argument_list|()
argument_list|)
member_init_list|,
name|delay
argument_list|(
name|QMOVIE_INVALID_DELAY
argument_list|)
member_init_list|,
name|endMark
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|QFrameInfo
specifier|inline
name|QFrameInfo
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|int
name|delay
parameter_list|)
member_init_list|:
name|pixmap
argument_list|(
name|pixmap
argument_list|)
member_init_list|,
name|delay
argument_list|(
name|delay
argument_list|)
member_init_list|,
name|endMark
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|isValid
specifier|inline
name|bool
name|isValid
parameter_list|()
block|{
return|return
name|endMark
operator|||
operator|!
operator|(
name|pixmap
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
name|delay
operator|==
name|QMOVIE_INVALID_DELAY
operator|)
operator|)
return|;
block|}
DECL|function|isEndMarker
specifier|inline
name|bool
name|isEndMarker
parameter_list|()
block|{
return|return
name|endMark
return|;
block|}
DECL|function|endMarker
specifier|static
specifier|inline
name|QFrameInfo
name|endMarker
parameter_list|()
block|{
return|return
name|QFrameInfo
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_class
DECL|class|QMoviePrivate
class|class
name|QMoviePrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QMovie
parameter_list|)
specifier|public
private|:
name|QMoviePrivate
parameter_list|(
name|QMovie
modifier|*
name|qq
parameter_list|)
constructor_decl|;
name|bool
name|isDone
parameter_list|()
function_decl|;
name|bool
name|next
parameter_list|()
function_decl|;
name|int
name|speedAdjustedDelay
parameter_list|(
name|int
name|delay
parameter_list|)
specifier|const
function_decl|;
name|bool
name|isValid
parameter_list|()
specifier|const
function_decl|;
name|bool
name|jumpToFrame
parameter_list|(
name|int
name|frameNumber
parameter_list|)
function_decl|;
name|int
name|frameCount
parameter_list|()
specifier|const
function_decl|;
name|bool
name|jumpToNextFrame
parameter_list|()
function_decl|;
name|QFrameInfo
name|infoForFrame
parameter_list|(
name|int
name|frameNumber
parameter_list|)
function_decl|;
name|void
name|reset
parameter_list|()
function_decl|;
DECL|function|enterState
specifier|inline
name|void
name|enterState
parameter_list|(
name|QMovie
operator|::
name|MovieState
name|newState
parameter_list|)
block|{
name|movieState
operator|=
name|newState
expr_stmt|;
emit|emit
name|q_func
argument_list|()
operator|->
name|stateChanged
argument_list|(
name|newState
argument_list|)
emit|;
block|}
comment|// private slots
name|void
name|_q_loadNextFrame
parameter_list|()
function_decl|;
name|void
name|_q_loadNextFrame
parameter_list|(
name|bool
name|starting
parameter_list|)
function_decl|;
DECL|member|reader
name|QImageReader
modifier|*
name|reader
decl_stmt|;
DECL|member|speed
name|int
name|speed
decl_stmt|;
DECL|member|movieState
name|QMovie
operator|::
name|MovieState
name|movieState
decl_stmt|;
DECL|member|frameRect
name|QRect
name|frameRect
decl_stmt|;
DECL|member|currentPixmap
name|QPixmap
name|currentPixmap
decl_stmt|;
DECL|member|currentFrameNumber
name|int
name|currentFrameNumber
decl_stmt|;
DECL|member|nextFrameNumber
name|int
name|nextFrameNumber
decl_stmt|;
DECL|member|greatestFrameNumber
name|int
name|greatestFrameNumber
decl_stmt|;
DECL|member|nextDelay
name|int
name|nextDelay
decl_stmt|;
DECL|member|playCounter
name|int
name|playCounter
decl_stmt|;
DECL|member|initialDevicePos
name|qint64
name|initialDevicePos
decl_stmt|;
DECL|member|cacheMode
name|QMovie
operator|::
name|CacheMode
name|cacheMode
decl_stmt|;
DECL|member|haveReadAll
name|bool
name|haveReadAll
decl_stmt|;
DECL|member|isFirstIteration
name|bool
name|isFirstIteration
decl_stmt|;
DECL|member|frameMap
name|QMap
argument_list|<
name|int
argument_list|,
name|QFrameInfo
argument_list|>
name|frameMap
decl_stmt|;
DECL|member|absoluteFilePath
name|QString
name|absoluteFilePath
decl_stmt|;
DECL|member|nextImageTimer
name|QTimer
name|nextImageTimer
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QMoviePrivate
name|QMoviePrivate
operator|::
name|QMoviePrivate
parameter_list|(
name|QMovie
modifier|*
name|qq
parameter_list|)
member_init_list|:
name|reader
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|speed
argument_list|(
literal|100
argument_list|)
member_init_list|,
name|movieState
argument_list|(
name|QMovie
operator|::
name|NotRunning
argument_list|)
member_init_list|,
name|currentFrameNumber
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|nextFrameNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|greatestFrameNumber
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|nextDelay
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|playCounter
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|cacheMode
argument_list|(
name|QMovie
operator|::
name|CacheNone
argument_list|)
member_init_list|,
name|haveReadAll
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isFirstIteration
argument_list|(
literal|true
argument_list|)
block|{
name|q_ptr
operator|=
name|qq
expr_stmt|;
name|nextImageTimer
operator|.
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|reset
name|void
name|QMoviePrivate
operator|::
name|reset
parameter_list|()
block|{
name|nextImageTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|->
name|device
argument_list|()
condition|)
name|initialDevicePos
operator|=
name|reader
operator|->
name|device
argument_list|()
operator|->
name|pos
argument_list|()
expr_stmt|;
name|currentFrameNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|nextFrameNumber
operator|=
literal|0
expr_stmt|;
name|greatestFrameNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|nextDelay
operator|=
literal|0
expr_stmt|;
name|playCounter
operator|=
operator|-
literal|1
expr_stmt|;
name|haveReadAll
operator|=
literal|false
expr_stmt|;
name|isFirstIteration
operator|=
literal|true
expr_stmt|;
name|frameMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|isDone
name|bool
name|QMoviePrivate
operator|::
name|isDone
parameter_list|()
block|{
return|return
operator|(
name|playCounter
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Given the original \a delay, this function returns the     actual number of milliseconds to delay according to     the current speed. E.g. if the speed is 200%, the     result will be half of the original delay. */
end_comment
begin_function
DECL|function|speedAdjustedDelay
name|int
name|QMoviePrivate
operator|::
name|speedAdjustedDelay
parameter_list|(
name|int
name|delay
parameter_list|)
specifier|const
block|{
return|return
name|int
argument_list|(
operator|(
name|qint64
argument_list|(
name|delay
argument_list|)
operator|*
name|qint64
argument_list|(
literal|100
argument_list|)
operator|)
operator|/
name|qint64
argument_list|(
name|speed
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the QFrameInfo for the given \a frameNumber.      If the frame number is invalid, an invalid QFrameInfo is     returned.      If the end of the animation has been reached, a     special end marker QFrameInfo is returned.  */
end_comment
begin_function
DECL|function|infoForFrame
name|QFrameInfo
name|QMoviePrivate
operator|::
name|infoForFrame
parameter_list|(
name|int
name|frameNumber
parameter_list|)
block|{
if|if
condition|(
name|frameNumber
operator|<
literal|0
condition|)
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
if|if
condition|(
name|haveReadAll
operator|&&
operator|(
name|frameNumber
operator|>
name|greatestFrameNumber
operator|)
condition|)
block|{
if|if
condition|(
name|frameNumber
operator|==
name|greatestFrameNumber
operator|+
literal|1
condition|)
return|return
name|QFrameInfo
operator|::
name|endMarker
argument_list|()
return|;
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
block|}
if|if
condition|(
name|cacheMode
operator|==
name|QMovie
operator|::
name|CacheNone
condition|)
block|{
if|if
condition|(
name|frameNumber
operator|!=
name|currentFrameNumber
operator|+
literal|1
condition|)
block|{
comment|// Non-sequential frame access
if|if
condition|(
operator|!
name|reader
operator|->
name|jumpToImage
argument_list|(
name|frameNumber
argument_list|)
condition|)
block|{
if|if
condition|(
name|frameNumber
operator|==
literal|0
condition|)
block|{
comment|// Special case: Attempt to "rewind" so we can loop
comment|// ### This could be implemented as QImageReader::rewind()
if|if
condition|(
name|reader
operator|->
name|device
argument_list|()
operator|->
name|isSequential
argument_list|()
condition|)
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
name|QString
name|fileName
init|=
name|reader
operator|->
name|fileName
argument_list|()
decl_stmt|;
name|QByteArray
name|format
init|=
name|reader
operator|->
name|format
argument_list|()
decl_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|reader
operator|->
name|device
argument_list|()
decl_stmt|;
name|QColor
name|bgColor
init|=
name|reader
operator|->
name|backgroundColor
argument_list|()
decl_stmt|;
name|QSize
name|scaledSize
init|=
name|reader
operator|->
name|scaledSize
argument_list|()
decl_stmt|;
operator|delete
name|reader
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
name|reader
operator|=
operator|new
name|QImageReader
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
name|reader
operator|=
operator|new
name|QImageReader
argument_list|(
name|absoluteFilePath
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reader
operator|->
name|canRead
argument_list|()
expr_stmt|;
comment|// Provoke a device->open() call
name|reader
operator|->
name|device
argument_list|()
operator|->
name|seek
argument_list|(
name|initialDevicePos
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setBackgroundColor
argument_list|(
name|bgColor
argument_list|)
expr_stmt|;
name|reader
operator|->
name|setScaledSize
argument_list|(
name|scaledSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
block|}
block|}
block|}
if|if
condition|(
name|reader
operator|->
name|canRead
argument_list|()
condition|)
block|{
comment|// reader says we can read. Attempt to actually read image
name|QImage
name|anImage
init|=
name|reader
operator|->
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|anImage
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Reading image failed.
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
block|}
if|if
condition|(
name|frameNumber
operator|>
name|greatestFrameNumber
condition|)
name|greatestFrameNumber
operator|=
name|frameNumber
expr_stmt|;
name|QPixmap
name|aPixmap
init|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|anImage
argument_list|)
decl_stmt|;
name|int
name|aDelay
init|=
name|reader
operator|->
name|nextImageDelay
argument_list|()
decl_stmt|;
return|return
name|QFrameInfo
argument_list|(
name|aPixmap
argument_list|,
name|aDelay
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|frameNumber
operator|!=
literal|0
condition|)
block|{
comment|// We've read all frames now. Return an end marker
name|haveReadAll
operator|=
literal|true
expr_stmt|;
return|return
name|QFrameInfo
operator|::
name|endMarker
argument_list|()
return|;
block|}
else|else
block|{
comment|// No readable frames
name|haveReadAll
operator|=
literal|true
expr_stmt|;
return|return
name|QFrameInfo
argument_list|()
return|;
block|}
block|}
comment|// CacheMode == CacheAll
if|if
condition|(
name|frameNumber
operator|>
name|greatestFrameNumber
condition|)
block|{
comment|// Frame hasn't been read from file yet. Try to do it
for|for
control|(
name|int
name|i
init|=
name|greatestFrameNumber
operator|+
literal|1
init|;
name|i
operator|<=
name|frameNumber
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|reader
operator|->
name|canRead
argument_list|()
condition|)
block|{
comment|// reader says we can read. Attempt to actually read image
name|QImage
name|anImage
init|=
name|reader
operator|->
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|anImage
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Reading image failed.
return|return
name|QFrameInfo
argument_list|()
return|;
comment|// Invalid
block|}
name|greatestFrameNumber
operator|=
name|i
expr_stmt|;
name|QPixmap
name|aPixmap
init|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|anImage
argument_list|)
decl_stmt|;
name|int
name|aDelay
init|=
name|reader
operator|->
name|nextImageDelay
argument_list|()
decl_stmt|;
name|QFrameInfo
name|info
argument_list|(
name|aPixmap
argument_list|,
name|aDelay
argument_list|)
decl_stmt|;
comment|// Cache it!
name|frameMap
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|frameNumber
condition|)
block|{
return|return
name|info
return|;
block|}
block|}
else|else
block|{
comment|// We've read all frames now. Return an end marker
name|haveReadAll
operator|=
literal|true
expr_stmt|;
return|return
name|QFrameInfo
operator|::
name|endMarker
argument_list|()
return|;
block|}
block|}
block|}
comment|// Return info for requested (cached) frame
return|return
name|frameMap
operator|.
name|value
argument_list|(
name|frameNumber
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Attempts to advance the animation to the next frame.     If successful, currentFrameNumber, currentPixmap and     nextDelay are updated accordingly, and true is returned.     Otherwise, false is returned.     When false is returned, isDone() can be called to     determine whether the animation ended gracefully or     an error occurred when reading the frame. */
end_comment
begin_function
DECL|function|next
name|bool
name|QMoviePrivate
operator|::
name|next
parameter_list|()
block|{
name|QTime
name|time
decl_stmt|;
name|time
operator|.
name|start
argument_list|()
expr_stmt|;
name|QFrameInfo
name|info
init|=
name|infoForFrame
argument_list|(
name|nextFrameNumber
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|info
operator|.
name|isEndMarker
argument_list|()
condition|)
block|{
comment|// We reached the end of the animation.
if|if
condition|(
name|isFirstIteration
condition|)
block|{
if|if
condition|(
name|nextFrameNumber
operator|==
literal|0
condition|)
block|{
comment|// No frames could be read at all (error).
return|return
literal|false
return|;
block|}
comment|// End of first iteration. Initialize play counter
name|playCounter
operator|=
name|reader
operator|->
name|loopCount
argument_list|()
expr_stmt|;
name|isFirstIteration
operator|=
literal|false
expr_stmt|;
block|}
comment|// Loop as appropriate
if|if
condition|(
name|playCounter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|playCounter
operator|!=
operator|-
literal|1
condition|)
comment|// Infinite?
name|playCounter
operator|--
expr_stmt|;
comment|// Nope
name|nextFrameNumber
operator|=
literal|0
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
comment|// Loop no more. Done
return|return
literal|false
return|;
block|}
comment|// Image and delay OK, update internal state
name|currentFrameNumber
operator|=
name|nextFrameNumber
operator|++
expr_stmt|;
name|QSize
name|scaledSize
init|=
name|reader
operator|->
name|scaledSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|scaledSize
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|scaledSize
operator|!=
name|info
operator|.
name|pixmap
operator|.
name|size
argument_list|()
operator|)
condition|)
name|currentPixmap
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|info
operator|.
name|pixmap
operator|.
name|toImage
argument_list|()
operator|.
name|scaled
argument_list|(
name|scaledSize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|currentPixmap
operator|=
name|info
operator|.
name|pixmap
expr_stmt|;
name|nextDelay
operator|=
name|speedAdjustedDelay
argument_list|(
name|info
operator|.
name|delay
argument_list|)
expr_stmt|;
comment|// Adjust delay according to the time it took to read the frame
name|int
name|processingTime
init|=
name|time
operator|.
name|elapsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|processingTime
operator|>
name|nextDelay
condition|)
name|nextDelay
operator|=
literal|0
expr_stmt|;
else|else
name|nextDelay
operator|=
name|nextDelay
operator|-
name|processingTime
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|_q_loadNextFrame
name|void
name|QMoviePrivate
operator|::
name|_q_loadNextFrame
parameter_list|()
block|{
name|_q_loadNextFrame
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_loadNextFrame
name|void
name|QMoviePrivate
operator|::
name|_q_loadNextFrame
parameter_list|(
name|bool
name|starting
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|starting
operator|&&
name|movieState
operator|==
name|QMovie
operator|::
name|NotRunning
condition|)
block|{
name|enterState
argument_list|(
name|QMovie
operator|::
name|Running
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|started
argument_list|()
emit|;
block|}
if|if
condition|(
name|frameRect
operator|.
name|size
argument_list|()
operator|!=
name|currentPixmap
operator|.
name|rect
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
name|frameRect
operator|=
name|currentPixmap
operator|.
name|rect
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|resized
argument_list|(
name|frameRect
operator|.
name|size
argument_list|()
argument_list|)
emit|;
block|}
emit|emit
name|q
operator|->
name|updated
argument_list|(
name|frameRect
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|frameChanged
argument_list|(
name|currentFrameNumber
argument_list|)
emit|;
if|if
condition|(
name|movieState
operator|==
name|QMovie
operator|::
name|Running
condition|)
name|nextImageTimer
operator|.
name|start
argument_list|(
name|nextDelay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Could not read another frame
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
emit|emit
name|q
operator|->
name|error
argument_list|(
name|reader
operator|->
name|error
argument_list|()
argument_list|)
emit|;
block|}
comment|// Graceful finish
if|if
condition|(
name|movieState
operator|!=
name|QMovie
operator|::
name|Paused
condition|)
block|{
name|nextFrameNumber
operator|=
literal|0
expr_stmt|;
name|isFirstIteration
operator|=
literal|true
expr_stmt|;
name|playCounter
operator|=
operator|-
literal|1
expr_stmt|;
name|enterState
argument_list|(
name|QMovie
operator|::
name|NotRunning
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|finished
argument_list|()
emit|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QMoviePrivate
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|greatestFrameNumber
operator|>=
literal|0
operator|)
comment|// have we seen valid data
operator|||
name|reader
operator|->
name|canRead
argument_list|()
return|;
comment|// or does the reader see valid data
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|jumpToFrame
name|bool
name|QMoviePrivate
operator|::
name|jumpToFrame
parameter_list|(
name|int
name|frameNumber
parameter_list|)
block|{
if|if
condition|(
name|frameNumber
operator|<
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|currentFrameNumber
operator|==
name|frameNumber
condition|)
return|return
literal|true
return|;
name|nextFrameNumber
operator|=
name|frameNumber
expr_stmt|;
if|if
condition|(
name|movieState
operator|==
name|QMovie
operator|::
name|Running
condition|)
name|nextImageTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|_q_loadNextFrame
argument_list|()
expr_stmt|;
return|return
operator|(
name|nextFrameNumber
operator|==
name|currentFrameNumber
operator|+
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|frameCount
name|int
name|QMoviePrivate
operator|::
name|frameCount
parameter_list|()
specifier|const
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|reader
operator|->
name|imageCount
argument_list|()
operator|)
operator|!=
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|haveReadAll
condition|)
return|return
name|greatestFrameNumber
operator|+
literal|1
return|;
return|return
literal|0
return|;
comment|// Don't know
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|jumpToNextFrame
name|bool
name|QMoviePrivate
operator|::
name|jumpToNextFrame
parameter_list|()
block|{
return|return
name|jumpToFrame
argument_list|(
name|currentFrameNumber
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QMovie object, passing the \a parent object to QObject's     constructor.      \sa setFileName(), setDevice(), setFormat()  */
end_comment
begin_constructor
DECL|function|QMovie
name|QMovie
operator|::
name|QMovie
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QMoviePrivate
argument_list|(
name|this
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|=
operator|new
name|QImageReader
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|nextImageTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_loadNextFrame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QMovie object. QMovie will use read image data from \a     device, which it assumes is open and readable. If \a format is not empty,     QMovie will use the image format \a format for decoding the image     data. Otherwise, QMovie will attempt to guess the format.      The \a parent object is passed to QObject's constructor.  */
end_comment
begin_constructor
DECL|function|QMovie
name|QMovie
operator|::
name|QMovie
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QMoviePrivate
argument_list|(
name|this
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|=
operator|new
name|QImageReader
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|d
operator|->
name|initialDevicePos
operator|=
name|device
operator|->
name|pos
argument_list|()
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|nextImageTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_loadNextFrame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QMovie object. QMovie will use read image data from \a     fileName. If \a format is not empty, QMovie will use the image format \a     format for decoding the image data. Otherwise, QMovie will attempt to     guess the format.      The \a parent object is passed to QObject's constructor.  */
end_comment
begin_constructor
DECL|function|QMovie
name|QMovie
operator|::
name|QMovie
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QMoviePrivate
argument_list|(
name|this
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|absoluteFilePath
operator|=
name|QDir
argument_list|(
name|fileName
argument_list|)
operator|.
name|absolutePath
argument_list|()
expr_stmt|;
name|d
operator|->
name|reader
operator|=
operator|new
name|QImageReader
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|reader
operator|->
name|device
argument_list|()
condition|)
name|d
operator|->
name|initialDevicePos
operator|=
name|d
operator|->
name|reader
operator|->
name|device
argument_list|()
operator|->
name|pos
argument_list|()
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|nextImageTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_loadNextFrame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QMovie object. */
end_comment
begin_destructor
DECL|function|~QMovie
name|QMovie
operator|::
name|~
name|QMovie
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|reader
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the current device to \a device. QMovie will read image data from     this device when the movie is running.      \sa device(), setFormat() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QMovie
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|->
name|setDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the device QMovie reads image data from. If no device has     currently been assigned, 0 is returned.      \sa setDevice(), fileName() */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QMovie
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|device
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the name of the file that QMovie reads image data from, to \a     fileName.      \sa fileName(), setDevice(), setFormat() */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QMovie
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|absoluteFilePath
operator|=
name|QDir
argument_list|(
name|fileName
argument_list|)
operator|.
name|absolutePath
argument_list|()
expr_stmt|;
name|d
operator|->
name|reader
operator|->
name|setFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|d
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the file that QMovie reads image data from. If no file     name has been assigned, or if the assigned device is not a file, an empty     QString is returned.      \sa setFileName(), device() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QMovie
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|fileName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the format that QMovie will use when decoding image data, to \a     format. By default, QMovie will attempt to guess the format of the image     data.      You can call supportedFormats() for the full list of formats     QMovie supports.      \sa QImageReader::supportedImageFormats() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QMovie
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|->
name|setFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format that QMovie uses when decoding image data. If no format     has been assigned, an empty QByteArray() is returned.      \sa setFormat() */
end_comment
begin_function
DECL|function|format
name|QByteArray
name|QMovie
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|format
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     For image formats that support it, this function sets the background color     to \a color.      \sa backgroundColor() */
end_comment
begin_function
DECL|function|setBackgroundColor
name|void
name|QMovie
operator|::
name|setBackgroundColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|->
name|setBackgroundColor
argument_list|(
name|color
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the background color of the movie. If no background color has been     assigned, an invalid QColor is returned.      \sa setBackgroundColor() */
end_comment
begin_function
DECL|function|backgroundColor
name|QColor
name|QMovie
operator|::
name|backgroundColor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|backgroundColor
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current state of QMovie.      \sa MovieState, stateChanged() */
end_comment
begin_function
DECL|function|state
name|QMovie
operator|::
name|MovieState
name|QMovie
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|movieState
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the rect of the last frame. If no frame has yet been updated, an     invalid QRect is returned.      \sa currentImage(), currentPixmap() */
end_comment
begin_function
DECL|function|frameRect
name|QRect
name|QMovie
operator|::
name|frameRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|frameRect
return|;
block|}
end_function
begin_comment
comment|/*! \fn QImage QMovie::framePixmap() const      Use currentPixmap() instead. */
end_comment
begin_comment
comment|/*! \fn void QMovie::pause()      Use setPaused(true) instead. */
end_comment
begin_comment
comment|/*! \fn void QMovie::unpause()      Use setPaused(false) instead. */
end_comment
begin_comment
comment|/*!     Returns the current frame as a QPixmap.      \sa currentImage(), updated() */
end_comment
begin_function
DECL|function|currentPixmap
name|QPixmap
name|QMovie
operator|::
name|currentPixmap
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentPixmap
return|;
block|}
end_function
begin_comment
comment|/*! \fn QImage QMovie::frameImage() const      Use currentImage() instead. */
end_comment
begin_comment
comment|/*!     Returns the current frame as a QImage.      \sa currentPixmap(), updated() */
end_comment
begin_function
DECL|function|currentImage
name|QImage
name|QMovie
operator|::
name|currentImage
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentPixmap
operator|.
name|toImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the movie is valid (e.g., the image data is readable and     the image format is supported); otherwise returns false. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QMovie
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QMovie::running() const      Use state() instead. */
end_comment
begin_comment
comment|/*! \fn bool QMovie::isNull() const      Use isValid() instead. */
end_comment
begin_comment
comment|/*! \fn int QMovie::frameNumber() const      Use currentFrameNumber() instead. */
end_comment
begin_comment
comment|/*! \fn bool QMovie::paused() const      Use state() instead. */
end_comment
begin_comment
comment|/*! \fn bool QMovie::finished() const      Use state() instead. */
end_comment
begin_comment
comment|/*! \fn void QMovie::restart()      Use stop() and start() instead. */
end_comment
begin_comment
comment|/*!     \fn void QMovie::step()      Use jumpToNextFrame() instead. */
end_comment
begin_comment
comment|/*!     Returns the number of frames in the movie.      Certain animation formats do not support this feature, in which     case 0 is returned. */
end_comment
begin_function
DECL|function|frameCount
name|int
name|QMovie
operator|::
name|frameCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|frameCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds QMovie will wait before updating the     next frame in the animation. */
end_comment
begin_function
DECL|function|nextFrameDelay
name|int
name|QMovie
operator|::
name|nextFrameDelay
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nextDelay
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the sequence number of the current frame. The number of the first     frame in the movie is 0. */
end_comment
begin_function
DECL|function|currentFrameNumber
name|int
name|QMovie
operator|::
name|currentFrameNumber
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentFrameNumber
return|;
block|}
end_function
begin_comment
comment|/*!     Jumps to the next frame. Returns true on success; otherwise returns false. */
end_comment
begin_function
DECL|function|jumpToNextFrame
name|bool
name|QMovie
operator|::
name|jumpToNextFrame
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|jumpToNextFrame
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Jumps to frame number \a frameNumber. Returns true on success; otherwise     returns false. */
end_comment
begin_function
DECL|function|jumpToFrame
name|bool
name|QMovie
operator|::
name|jumpToFrame
parameter_list|(
name|int
name|frameNumber
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|jumpToFrame
argument_list|(
name|frameNumber
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of times the movie will loop before it finishes.     If the movie will only play once (no looping), loopCount returns 0.     If the movie loops forever, loopCount returns -1.      Note that, if the image data comes from a sequential device (e.g. a     socket), QMovie can only loop the movie if the cacheMode is set to     QMovie::CacheAll. */
end_comment
begin_function
DECL|function|loopCount
name|int
name|QMovie
operator|::
name|loopCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|loopCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     If \a paused is true, QMovie will enter \l Paused state and emit     stateChanged(Paused); otherwise it will enter \l Running state and emit     stateChanged(Running).      \sa state() */
end_comment
begin_function
DECL|function|setPaused
name|void
name|QMovie
operator|::
name|setPaused
parameter_list|(
name|bool
name|paused
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
if|if
condition|(
name|paused
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|movieState
operator|==
name|NotRunning
condition|)
return|return;
name|d
operator|->
name|enterState
argument_list|(
name|Paused
argument_list|)
expr_stmt|;
name|d
operator|->
name|nextImageTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|movieState
operator|==
name|Running
condition|)
return|return;
name|d
operator|->
name|enterState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
name|d
operator|->
name|nextImageTimer
operator|.
name|start
argument_list|(
name|nextFrameDelay
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QMovie::speed     \brief the movie's speed      The speed is measured in percentage of the original movie speed.     The default speed is 100%.     Example:      \snippet doc/src/snippets/code/src_gui_image_qmovie.cpp 1 */
end_comment
begin_function
DECL|function|setSpeed
name|void
name|QMovie
operator|::
name|setSpeed
parameter_list|(
name|int
name|percentSpeed
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|speed
operator|=
name|percentSpeed
expr_stmt|;
block|}
end_function
begin_function
DECL|function|speed
name|int
name|QMovie
operator|::
name|speed
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|speed
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the movie. QMovie will enter \l Running state, and start emitting     updated() and resized() as the movie progresses.      If QMovie is in the \l Paused state, this function is equivalent     to calling setPaused(false). If QMovie is already in the \l     Running state, this function does nothing.      \sa stop(), setPaused() */
end_comment
begin_function
DECL|function|start
name|void
name|QMovie
operator|::
name|start
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|movieState
operator|==
name|NotRunning
condition|)
block|{
name|d
operator|->
name|_q_loadNextFrame
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|movieState
operator|==
name|Paused
condition|)
block|{
name|setPaused
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Stops the movie. QMovie enters \l NotRunning state, and stops emitting     updated() and resized(). If start() is called again, the movie will     restart from the beginning.      If QMovie is already in the \l NotRunning state, this function     does nothing.      \sa start(), setPaused() */
end_comment
begin_function
DECL|function|stop
name|void
name|QMovie
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|movieState
operator|==
name|NotRunning
condition|)
return|return;
name|d
operator|->
name|enterState
argument_list|(
name|NotRunning
argument_list|)
expr_stmt|;
name|d
operator|->
name|nextImageTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|d
operator|->
name|nextFrameNumber
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the scaled size of frames.      \sa QImageReader::scaledSize() */
end_comment
begin_function
DECL|function|scaledSize
name|QSize
name|QMovie
operator|::
name|scaledSize
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reader
operator|->
name|scaledSize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the scaled frame size to \a size.      \sa QImageReader::setScaledSize() */
end_comment
begin_function
DECL|function|setScaledSize
name|void
name|QMovie
operator|::
name|setScaledSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|reader
operator|->
name|setScaledSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the list of image formats supported by QMovie.      \sa QImageReader::supportedImageFormats() */
end_comment
begin_function
DECL|function|supportedFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMovie
operator|::
name|supportedFormats
parameter_list|()
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
init|=
name|QImageReader
operator|::
name|supportedImageFormats
argument_list|()
decl_stmt|;
name|QMutableListIterator
argument_list|<
name|QByteArray
argument_list|>
name|it
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|QBuffer
name|buffer
decl_stmt|;
name|buffer
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QImageReader
name|reader
argument_list|(
operator|&
name|buffer
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reader
operator|.
name|supportsAnimation
argument_list|()
condition|)
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \property QMovie::cacheMode     \brief the movie's cache mode      Caching frames can be useful when the underlying animation format handler     that QMovie relies on to decode the animation data does not support     jumping to particular frames in the animation, or even "rewinding" the     animation to the beginning (for looping). Furthermore, if the image data     comes from a sequential device, it is not possible for the underlying     animation handler to seek back to frames whose data has already been read     (making looping altogether impossible).      To aid in such situations, a QMovie object can be instructed to cache the     frames, at the added memory cost of keeping the frames in memory for the     lifetime of the object.      By default, this property is set to \l CacheNone.      \sa QMovie::CacheMode */
end_comment
begin_function
DECL|function|cacheMode
name|QMovie
operator|::
name|CacheMode
name|QMovie
operator|::
name|cacheMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cacheMode
return|;
block|}
end_function
begin_function
DECL|function|setCacheMode
name|void
name|QMovie
operator|::
name|setCacheMode
parameter_list|(
name|CacheMode
name|cacheMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
name|d
operator|->
name|cacheMode
operator|=
name|cacheMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|cacheMode
name|QMovie
operator|::
name|CacheMode
name|QMovie
operator|::
name|cacheMode
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QMovie
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cacheMode
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qmovie.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_MOVIE
end_comment
end_unit
