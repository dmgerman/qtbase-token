begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qjpeghandler_p.h"
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qmath.h>
end_include
begin_include
include|#
directive|include
file|<private/qsimd_p.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|// jpeglib needs this to be pre-included
end_comment
begin_include
include|#
directive|include
file|<setjmp.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FAR
end_ifdef
begin_undef
DECL|macro|FAR
undef|#
directive|undef
name|FAR
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// including jpeglib.h seems to be a little messy
end_comment
begin_extern
extern|extern
literal|"C"
block|{
comment|// mingw includes rpcndr.h but does not define boolean
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__RPCNDR_H__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|boolean
argument_list|)
DECL|typedef|boolean
typedef|typedef
name|unsigned
name|char
name|boolean
typedef|;
DECL|macro|HAVE_BOOLEAN
define|#
directive|define
name|HAVE_BOOLEAN
endif|#
directive|endif
endif|#
directive|endif
DECL|macro|XMD_H
define|#
directive|define
name|XMD_H
comment|// shut JPEGlib up
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIXWARE
argument_list|)
DECL|macro|HAVE_BOOLEAN
define|#
directive|define
name|HAVE_BOOLEAN
comment|// libjpeg under Unixware seems to need this
endif|#
directive|endif
include|#
directive|include
file|<jpeglib.h>
ifdef|#
directive|ifdef
name|const
DECL|macro|const
undef|#
directive|undef
name|const
comment|// remove crazy C hackery in jconfig.h
endif|#
directive|endif
block|}
end_extern
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|convert_rgb888_to_rgb32_C
name|void
name|QT_FASTCALL
name|convert_rgb888_to_rgb32_C
parameter_list|(
name|quint32
modifier|*
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// Expand 24->32 bpp.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|dst
operator|++
operator|=
name|qRgb
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|,
name|src
index|[
literal|1
index|]
argument_list|,
name|src
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_typedef
DECL|typedef|Rgb888ToRgb32Converter
typedef|typedef
name|void
function_decl|(
name|QT_FASTCALL
modifier|*
name|Rgb888ToRgb32Converter
function_decl|)
parameter_list|(
name|quint32
modifier|*
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|rgb888ToRgb32ConverterPtr
specifier|static
name|Rgb888ToRgb32Converter
name|rgb888ToRgb32ConverterPtr
init|=
name|convert_rgb888_to_rgb32_C
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|my_error_mgr
struct|struct
name|my_error_mgr
super|:
specifier|public
name|jpeg_error_mgr
block|{
DECL|member|setjmp_buffer
name|jmp_buf
name|setjmp_buffer
decl_stmt|;
block|}
struct|;
end_struct
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|my_error_exit
specifier|static
name|void
name|my_error_exit
parameter_list|(
name|j_common_ptr
name|cinfo
parameter_list|)
block|{
name|my_error_mgr
modifier|*
name|myerr
init|=
operator|(
name|my_error_mgr
operator|*
operator|)
name|cinfo
operator|->
name|err
decl_stmt|;
name|char
name|buffer
index|[
name|JMSG_LENGTH_MAX
index|]
decl_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|format_message
call|)
argument_list|(
name|cinfo
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|myerr
operator|->
name|setjmp_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|my_output_message
specifier|static
name|void
name|my_output_message
parameter_list|(
name|j_common_ptr
name|cinfo
parameter_list|)
block|{
name|char
name|buffer
index|[
name|JMSG_LENGTH_MAX
index|]
decl_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|format_message
call|)
argument_list|(
name|cinfo
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_extern
begin_decl_stmt
DECL|variable|max_buf
specifier|static
specifier|const
name|int
name|max_buf
init|=
literal|4096
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|my_jpeg_source_mgr
struct|struct
name|my_jpeg_source_mgr
super|:
specifier|public
name|jpeg_source_mgr
block|{
comment|// Nothing dynamic - cannot rely on destruction over longjump
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|buffer
name|JOCTET
name|buffer
index|[
name|max_buf
index|]
decl_stmt|;
DECL|member|memDevice
specifier|const
name|QBuffer
modifier|*
name|memDevice
decl_stmt|;
public|public:
name|my_jpeg_source_mgr
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
constructor_decl|;
block|}
struct|;
end_struct
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|qt_init_source
specifier|static
name|void
name|qt_init_source
parameter_list|(
name|j_decompress_ptr
parameter_list|)
block|{ }
DECL|function|qt_fill_input_buffer
specifier|static
name|boolean
name|qt_fill_input_buffer
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|my_jpeg_source_mgr
modifier|*
name|src
init|=
operator|(
name|my_jpeg_source_mgr
operator|*
operator|)
name|cinfo
operator|->
name|src
decl_stmt|;
name|qint64
name|num_read
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|memDevice
condition|)
block|{
name|src
operator|->
name|next_input_byte
operator|=
operator|(
specifier|const
name|JOCTET
operator|*
operator|)
operator|(
name|src
operator|->
name|memDevice
operator|->
name|data
argument_list|()
operator|.
name|constData
argument_list|()
operator|+
name|src
operator|->
name|memDevice
operator|->
name|pos
argument_list|()
operator|)
expr_stmt|;
name|num_read
operator|=
name|src
operator|->
name|memDevice
operator|->
name|data
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|src
operator|->
name|memDevice
operator|->
name|pos
argument_list|()
expr_stmt|;
name|src
operator|->
name|device
operator|->
name|seek
argument_list|(
name|src
operator|->
name|memDevice
operator|->
name|data
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|next_input_byte
operator|=
name|src
operator|->
name|buffer
expr_stmt|;
name|num_read
operator|=
name|src
operator|->
name|device
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
operator|->
name|buffer
argument_list|,
name|max_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_read
operator|<=
literal|0
condition|)
block|{
comment|// Insert a fake EOI marker - as per jpeglib recommendation
name|src
operator|->
name|next_input_byte
operator|=
name|src
operator|->
name|buffer
expr_stmt|;
name|src
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
operator|(
name|JOCTET
operator|)
literal|0xFF
expr_stmt|;
name|src
operator|->
name|buffer
index|[
literal|1
index|]
operator|=
operator|(
name|JOCTET
operator|)
name|JPEG_EOI
expr_stmt|;
name|src
operator|->
name|bytes_in_buffer
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|bytes_in_buffer
operator|=
name|num_read
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
DECL|function|qt_skip_input_data
specifier|static
name|void
name|qt_skip_input_data
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|,
name|long
name|num_bytes
parameter_list|)
block|{
name|my_jpeg_source_mgr
modifier|*
name|src
init|=
operator|(
name|my_jpeg_source_mgr
operator|*
operator|)
name|cinfo
operator|->
name|src
decl_stmt|;
comment|// `dumb' implementation from jpeglib
comment|/* Just a dumb implementation for now.  Could use fseek() except      * it doesn't work on pipes.  Not clear that being smart is worth      * any trouble anyway --- large skips are infrequent.      */
if|if
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|num_bytes
operator|>
operator|(
name|long
operator|)
name|src
operator|->
name|bytes_in_buffer
condition|)
block|{
comment|// Should not happen in case of memDevice
name|num_bytes
operator|-=
operator|(
name|long
operator|)
name|src
operator|->
name|bytes_in_buffer
expr_stmt|;
operator|(
name|void
operator|)
name|qt_fill_input_buffer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* note we assume that qt_fill_input_buffer will never return false,             * so suspension need not be handled.             */
block|}
name|src
operator|->
name|next_input_byte
operator|+=
operator|(
name|size_t
operator|)
name|num_bytes
expr_stmt|;
name|src
operator|->
name|bytes_in_buffer
operator|-=
operator|(
name|size_t
operator|)
name|num_bytes
expr_stmt|;
block|}
block|}
DECL|function|qt_term_source
specifier|static
name|void
name|qt_term_source
parameter_list|(
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|my_jpeg_source_mgr
modifier|*
name|src
init|=
operator|(
name|my_jpeg_source_mgr
operator|*
operator|)
name|cinfo
operator|->
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|src
operator|->
name|device
operator|->
name|isSequential
argument_list|()
condition|)
name|src
operator|->
name|device
operator|->
name|seek
argument_list|(
name|src
operator|->
name|device
operator|->
name|pos
argument_list|()
operator|-
name|src
operator|->
name|bytes_in_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_extern
begin_constructor
DECL|function|my_jpeg_source_mgr
specifier|inline
name|my_jpeg_source_mgr
operator|::
name|my_jpeg_source_mgr
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|jpeg_source_mgr
operator|::
name|init_source
operator|=
name|qt_init_source
expr_stmt|;
name|jpeg_source_mgr
operator|::
name|fill_input_buffer
operator|=
name|qt_fill_input_buffer
expr_stmt|;
name|jpeg_source_mgr
operator|::
name|skip_input_data
operator|=
name|qt_skip_input_data
expr_stmt|;
name|jpeg_source_mgr
operator|::
name|resync_to_restart
operator|=
name|jpeg_resync_to_restart
expr_stmt|;
name|jpeg_source_mgr
operator|::
name|term_source
operator|=
name|qt_term_source
expr_stmt|;
name|this
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|memDevice
operator|=
name|qobject_cast
argument_list|<
name|QBuffer
operator|*
argument_list|>
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|bytes_in_buffer
operator|=
literal|0
expr_stmt|;
name|next_input_byte
operator|=
name|buffer
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|read_jpeg_size
specifier|inline
specifier|static
name|bool
name|read_jpeg_size
parameter_list|(
name|int
modifier|&
name|w
parameter_list|,
name|int
modifier|&
name|h
parameter_list|,
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
operator|(
name|void
operator|)
name|jpeg_calc_output_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|w
operator|=
name|cinfo
operator|->
name|output_width
expr_stmt|;
name|h
operator|=
name|cinfo
operator|->
name|output_height
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_define
DECL|macro|HIGH_QUALITY_THRESHOLD
define|#
directive|define
name|HIGH_QUALITY_THRESHOLD
value|50
end_define
begin_function
DECL|function|read_jpeg_format
specifier|inline
specifier|static
name|bool
name|read_jpeg_format
parameter_list|(
name|QImage
operator|::
name|Format
modifier|&
name|format
parameter_list|,
name|j_decompress_ptr
name|cinfo
parameter_list|)
block|{
name|bool
name|result
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|cinfo
operator|->
name|output_components
condition|)
block|{
case|case
literal|1
case|:
name|format
operator|=
name|QImage
operator|::
name|Format_Grayscale8
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|cinfo
operator|->
name|output_scanline
operator|=
name|cinfo
operator|->
name|output_height
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|ensureValidImage
specifier|static
name|bool
name|ensureValidImage
parameter_list|(
name|QImage
modifier|*
name|dest
parameter_list|,
name|struct
name|jpeg_decompress_struct
modifier|*
name|info
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
switch|switch
condition|(
name|info
operator|->
name|output_components
condition|)
block|{
case|case
literal|1
case|:
name|format
operator|=
name|QImage
operator|::
name|Format_Grayscale8
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
comment|// unsupported format
block|}
if|if
condition|(
name|dest
operator|->
name|size
argument_list|()
operator|!=
name|size
operator|||
name|dest
operator|->
name|format
argument_list|()
operator|!=
name|format
condition|)
operator|*
name|dest
operator|=
name|QImage
argument_list|(
name|size
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
operator|!
name|dest
operator|->
name|isNull
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|read_jpeg_image
specifier|static
name|bool
name|read_jpeg_image
parameter_list|(
name|QImage
modifier|*
name|outImage
parameter_list|,
name|QSize
name|scaledSize
parameter_list|,
name|QRect
name|scaledClipRect
parameter_list|,
name|QRect
name|clipRect
parameter_list|,
specifier|volatile
name|int
name|inQuality
parameter_list|,
name|j_decompress_ptr
name|info
parameter_list|,
name|struct
name|my_error_mgr
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|err
operator|->
name|setjmp_buffer
argument_list|)
condition|)
block|{
comment|// -1 means default quality.
name|int
name|quality
init|=
name|inQuality
decl_stmt|;
if|if
condition|(
name|quality
operator|<
literal|0
condition|)
name|quality
operator|=
literal|75
expr_stmt|;
comment|// If possible, merge the scaledClipRect into either scaledSize
comment|// or clipRect to avoid doing a separate scaled clipping pass.
comment|// Best results are achieved by clipping before scaling, not after.
if|if
condition|(
operator|!
name|scaledClipRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|scaledSize
operator|.
name|isEmpty
argument_list|()
operator|&&
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No clipping or scaling before final clip.
name|clipRect
operator|=
name|scaledClipRect
expr_stmt|;
name|scaledClipRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaledSize
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Clipping, but no scaling: combine the clip regions.
name|scaledClipRect
operator|.
name|translate
argument_list|(
name|clipRect
operator|.
name|topLeft
argument_list|()
argument_list|)
expr_stmt|;
name|clipRect
operator|=
name|scaledClipRect
operator|.
name|intersected
argument_list|(
name|clipRect
argument_list|)
expr_stmt|;
name|scaledClipRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No clipping, but scaling: if we can map back to an
comment|// integer pixel boundary, then clip before scaling.
if|if
condition|(
operator|(
name|info
operator|->
name|image_width
operator|%
name|scaledSize
operator|.
name|width
argument_list|()
operator|)
operator|==
literal|0
operator|&&
operator|(
name|info
operator|->
name|image_height
operator|%
name|scaledSize
operator|.
name|height
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|x
init|=
name|scaledClipRect
operator|.
name|x
argument_list|()
operator|*
name|info
operator|->
name|image_width
operator|/
name|scaledSize
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|scaledClipRect
operator|.
name|y
argument_list|()
operator|*
name|info
operator|->
name|image_height
operator|/
name|scaledSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|width
init|=
operator|(
name|scaledClipRect
operator|.
name|right
argument_list|()
operator|+
literal|1
operator|)
operator|*
name|info
operator|->
name|image_width
operator|/
name|scaledSize
operator|.
name|width
argument_list|()
operator|-
name|x
decl_stmt|;
name|int
name|height
init|=
operator|(
name|scaledClipRect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
operator|)
operator|*
name|info
operator|->
name|image_height
operator|/
name|scaledSize
operator|.
name|height
argument_list|()
operator|-
name|y
decl_stmt|;
name|clipRect
operator|=
name|QRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|scaledSize
operator|=
name|scaledClipRect
operator|.
name|size
argument_list|()
expr_stmt|;
name|scaledClipRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Clipping and scaling: too difficult to figure out,
comment|// and not a likely use case, so do it the long way.
block|}
block|}
comment|// Determine the scale factor to pass to libjpeg for quick downscaling.
if|if
condition|(
operator|!
name|scaledSize
operator|.
name|isEmpty
argument_list|()
operator|&&
name|info
operator|->
name|image_width
operator|&&
name|info
operator|->
name|image_height
condition|)
block|{
if|if
condition|(
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|double
name|f
init|=
name|qMin
argument_list|(
name|double
argument_list|(
name|info
operator|->
name|image_width
argument_list|)
operator|/
name|scaledSize
operator|.
name|width
argument_list|()
argument_list|,
name|double
argument_list|(
name|info
operator|->
name|image_height
argument_list|)
operator|/
name|scaledSize
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
comment|// libjpeg supports M/8 scaling with M=[1,16]. All downscaling factors
comment|// are a speed improvement, but upscaling during decode is slower.
name|info
operator|->
name|scale_num
operator|=
name|qBound
argument_list|(
literal|1
argument_list|,
name|qCeil
argument_list|(
literal|8
operator|/
name|f
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|info
operator|->
name|scale_denom
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|scale_denom
operator|=
name|qMin
argument_list|(
name|clipRect
operator|.
name|width
argument_list|()
operator|/
name|scaledSize
operator|.
name|width
argument_list|()
argument_list|,
name|clipRect
operator|.
name|height
argument_list|()
operator|/
name|scaledSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
comment|// Only scale by powers of two when clipping so we can
comment|// keep the exact pixel boundaries
if|if
condition|(
name|info
operator|->
name|scale_denom
operator|<
literal|2
condition|)
name|info
operator|->
name|scale_denom
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|scale_denom
operator|<
literal|4
condition|)
name|info
operator|->
name|scale_denom
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|scale_denom
operator|<
literal|8
condition|)
name|info
operator|->
name|scale_denom
operator|=
literal|4
expr_stmt|;
else|else
name|info
operator|->
name|scale_denom
operator|=
literal|8
expr_stmt|;
name|info
operator|->
name|scale_num
operator|=
literal|1
expr_stmt|;
comment|// Correct the scale factor so that we clip accurately.
comment|// It is recommended that the clip rectangle be aligned
comment|// on an 8-pixel boundary for best performance.
while|while
condition|(
name|info
operator|->
name|scale_denom
operator|>
literal|1
operator|&&
operator|(
operator|(
name|clipRect
operator|.
name|x
argument_list|()
operator|%
name|info
operator|->
name|scale_denom
operator|)
operator|!=
literal|0
operator|||
operator|(
name|clipRect
operator|.
name|y
argument_list|()
operator|%
name|info
operator|->
name|scale_denom
operator|)
operator|!=
literal|0
operator|||
operator|(
name|clipRect
operator|.
name|width
argument_list|()
operator|%
name|info
operator|->
name|scale_denom
operator|)
operator|!=
literal|0
operator|||
operator|(
name|clipRect
operator|.
name|height
argument_list|()
operator|%
name|info
operator|->
name|scale_denom
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|info
operator|->
name|scale_denom
operator|/=
literal|2
expr_stmt|;
block|}
block|}
block|}
comment|// If high quality not required, use fast decompression
if|if
condition|(
name|quality
operator|<
name|HIGH_QUALITY_THRESHOLD
condition|)
block|{
name|info
operator|->
name|dct_method
operator|=
name|JDCT_IFAST
expr_stmt|;
name|info
operator|->
name|do_fancy_upsampling
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|jpeg_calc_output_dimensions
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|// Determine the clip region to extract.
name|QRect
name|imageRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|output_width
argument_list|,
name|info
operator|->
name|output_height
argument_list|)
decl_stmt|;
name|QRect
name|clip
decl_stmt|;
if|if
condition|(
name|clipRect
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|clip
operator|=
name|imageRect
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|scale_denom
operator|==
name|info
operator|->
name|scale_num
condition|)
block|{
name|clip
operator|=
name|clipRect
operator|.
name|intersected
argument_list|(
name|imageRect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The scale factor was corrected above to ensure that
comment|// we don't miss pixels when we scale the clip rectangle.
name|clip
operator|=
name|QRect
argument_list|(
name|clipRect
operator|.
name|x
argument_list|()
operator|/
name|int
argument_list|(
name|info
operator|->
name|scale_denom
argument_list|)
argument_list|,
name|clipRect
operator|.
name|y
argument_list|()
operator|/
name|int
argument_list|(
name|info
operator|->
name|scale_denom
argument_list|)
argument_list|,
name|clipRect
operator|.
name|width
argument_list|()
operator|/
name|int
argument_list|(
name|info
operator|->
name|scale_denom
argument_list|)
argument_list|,
name|clipRect
operator|.
name|height
argument_list|()
operator|/
name|int
argument_list|(
name|info
operator|->
name|scale_denom
argument_list|)
argument_list|)
expr_stmt|;
name|clip
operator|=
name|clip
operator|.
name|intersected
argument_list|(
name|imageRect
argument_list|)
expr_stmt|;
block|}
comment|// Allocate memory for the clipped QImage.
if|if
condition|(
operator|!
name|ensureValidImage
argument_list|(
name|outImage
argument_list|,
name|info
argument_list|,
name|clip
operator|.
name|size
argument_list|()
argument_list|)
condition|)
name|longjmp
argument_list|(
name|err
operator|->
name|setjmp_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Avoid memcpy() overhead if grayscale with no clipping.
name|bool
name|quickGray
init|=
operator|(
name|info
operator|->
name|output_components
operator|==
literal|1
operator|&&
name|clip
operator|==
name|imageRect
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|quickGray
condition|)
block|{
comment|// Ask the jpeg library to allocate a temporary row.
comment|// The library will automatically delete it for us later.
comment|// The libjpeg docs say we should do this before calling
comment|// jpeg_start_decompress().  We can't use "new" here
comment|// because we are inside the setjmp() block and an error
comment|// in the jpeg input stream would cause a memory leak.
name|JSAMPARRAY
name|rows
init|=
call|(
name|info
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|info
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|info
operator|->
name|output_width
operator|*
name|info
operator|->
name|output_components
argument_list|,
literal|1
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|jpeg_start_decompress
argument_list|(
name|info
argument_list|)
expr_stmt|;
while|while
condition|(
name|info
operator|->
name|output_scanline
operator|<
name|info
operator|->
name|output_height
condition|)
block|{
name|int
name|y
init|=
name|int
argument_list|(
name|info
operator|->
name|output_scanline
argument_list|)
operator|-
name|clip
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|y
operator|>=
name|clip
operator|.
name|height
argument_list|()
condition|)
break|break;
comment|// We've read the entire clip region, so abort.
operator|(
name|void
operator|)
name|jpeg_read_scanlines
argument_list|(
name|info
argument_list|,
name|rows
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
continue|continue;
comment|// Haven't reached the starting line yet.
if|if
condition|(
name|info
operator|->
name|output_components
operator|==
literal|3
condition|)
block|{
name|uchar
modifier|*
name|in
init|=
name|rows
index|[
literal|0
index|]
operator|+
name|clip
operator|.
name|x
argument_list|()
operator|*
literal|3
decl_stmt|;
name|QRgb
modifier|*
name|out
init|=
operator|(
name|QRgb
operator|*
operator|)
name|outImage
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rgb888ToRgb32ConverterPtr
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|clip
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|out_color_space
operator|==
name|JCS_CMYK
condition|)
block|{
comment|// Convert CMYK->RGB.
name|uchar
modifier|*
name|in
init|=
name|rows
index|[
literal|0
index|]
operator|+
name|clip
operator|.
name|x
argument_list|()
operator|*
literal|4
decl_stmt|;
name|QRgb
modifier|*
name|out
init|=
operator|(
name|QRgb
operator|*
operator|)
name|outImage
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clip
operator|.
name|width
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|k
init|=
name|in
index|[
literal|3
index|]
decl_stmt|;
operator|*
name|out
operator|++
operator|=
name|qRgb
argument_list|(
name|k
operator|*
name|in
index|[
literal|0
index|]
operator|/
literal|255
argument_list|,
name|k
operator|*
name|in
index|[
literal|1
index|]
operator|/
literal|255
argument_list|,
name|k
operator|*
name|in
index|[
literal|2
index|]
operator|/
literal|255
argument_list|)
expr_stmt|;
name|in
operator|+=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|output_components
operator|==
literal|1
condition|)
block|{
comment|// Grayscale.
name|memcpy
argument_list|(
name|outImage
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|rows
index|[
literal|0
index|]
operator|+
name|clip
operator|.
name|x
argument_list|()
argument_list|,
name|clip
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Load unclipped grayscale data directly into the QImage.
operator|(
name|void
operator|)
name|jpeg_start_decompress
argument_list|(
name|info
argument_list|)
expr_stmt|;
while|while
condition|(
name|info
operator|->
name|output_scanline
operator|<
name|info
operator|->
name|output_height
condition|)
block|{
name|uchar
modifier|*
name|row
init|=
name|outImage
operator|->
name|scanLine
argument_list|(
name|info
operator|->
name|output_scanline
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|jpeg_read_scanlines
argument_list|(
name|info
argument_list|,
operator|&
name|row
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|output_scanline
operator|==
name|info
operator|->
name|output_height
condition|)
operator|(
name|void
operator|)
name|jpeg_finish_decompress
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|density_unit
operator|==
literal|1
condition|)
block|{
name|outImage
operator|->
name|setDotsPerMeterX
argument_list|(
name|int
argument_list|(
literal|100.
operator|*
name|info
operator|->
name|X_density
operator|/
literal|2.54
argument_list|)
argument_list|)
expr_stmt|;
name|outImage
operator|->
name|setDotsPerMeterY
argument_list|(
name|int
argument_list|(
literal|100.
operator|*
name|info
operator|->
name|Y_density
operator|/
literal|2.54
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|density_unit
operator|==
literal|2
condition|)
block|{
name|outImage
operator|->
name|setDotsPerMeterX
argument_list|(
name|int
argument_list|(
literal|100.
operator|*
name|info
operator|->
name|X_density
argument_list|)
argument_list|)
expr_stmt|;
name|outImage
operator|->
name|setDotsPerMeterY
argument_list|(
name|int
argument_list|(
literal|100.
operator|*
name|info
operator|->
name|Y_density
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scaledSize
operator|.
name|isValid
argument_list|()
operator|&&
name|scaledSize
operator|!=
name|clip
operator|.
name|size
argument_list|()
condition|)
block|{
operator|*
name|outImage
operator|=
name|outImage
operator|->
name|scaled
argument_list|(
name|scaledSize
argument_list|,
name|Qt
operator|::
name|IgnoreAspectRatio
argument_list|,
name|quality
operator|>=
name|HIGH_QUALITY_THRESHOLD
condition|?
name|Qt
operator|::
name|SmoothTransformation
else|:
name|Qt
operator|::
name|FastTransformation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scaledClipRect
operator|.
name|isEmpty
argument_list|()
condition|)
operator|*
name|outImage
operator|=
name|outImage
operator|->
name|copy
argument_list|(
name|scaledClipRect
argument_list|)
expr_stmt|;
return|return
operator|!
name|outImage
operator|->
name|isNull
argument_list|()
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
end_function
begin_struct
DECL|struct|my_jpeg_destination_mgr
struct|struct
name|my_jpeg_destination_mgr
super|:
specifier|public
name|jpeg_destination_mgr
block|{
comment|// Nothing dynamic - cannot rely on destruction over longjump
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|buffer
name|JOCTET
name|buffer
index|[
name|max_buf
index|]
decl_stmt|;
public|public:
name|my_jpeg_destination_mgr
parameter_list|(
name|QIODevice
modifier|*
parameter_list|)
constructor_decl|;
block|}
struct|;
end_struct
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|qt_init_destination
specifier|static
name|void
name|qt_init_destination
parameter_list|(
name|j_compress_ptr
parameter_list|)
block|{ }
DECL|function|qt_empty_output_buffer
specifier|static
name|boolean
name|qt_empty_output_buffer
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|my_jpeg_destination_mgr
modifier|*
name|dest
init|=
operator|(
name|my_jpeg_destination_mgr
operator|*
operator|)
name|cinfo
operator|->
name|dest
decl_stmt|;
name|int
name|written
init|=
name|dest
operator|->
name|device
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dest
operator|->
name|buffer
argument_list|,
name|max_buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|error_exit
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
name|dest
operator|->
name|next_output_byte
operator|=
name|dest
operator|->
name|buffer
expr_stmt|;
name|dest
operator|->
name|free_in_buffer
operator|=
name|max_buf
expr_stmt|;
return|return
name|TRUE
return|;
block|}
DECL|function|qt_term_destination
specifier|static
name|void
name|qt_term_destination
parameter_list|(
name|j_compress_ptr
name|cinfo
parameter_list|)
block|{
name|my_jpeg_destination_mgr
modifier|*
name|dest
init|=
operator|(
name|my_jpeg_destination_mgr
operator|*
operator|)
name|cinfo
operator|->
name|dest
decl_stmt|;
name|qint64
name|n
init|=
name|max_buf
operator|-
name|dest
operator|->
name|free_in_buffer
decl_stmt|;
name|qint64
name|written
init|=
name|dest
operator|->
name|device
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dest
operator|->
name|buffer
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|==
operator|-
literal|1
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|error_exit
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_extern
begin_constructor
DECL|function|my_jpeg_destination_mgr
specifier|inline
name|my_jpeg_destination_mgr
operator|::
name|my_jpeg_destination_mgr
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|jpeg_destination_mgr
operator|::
name|init_destination
operator|=
name|qt_init_destination
expr_stmt|;
name|jpeg_destination_mgr
operator|::
name|empty_output_buffer
operator|=
name|qt_empty_output_buffer
expr_stmt|;
name|jpeg_destination_mgr
operator|::
name|term_destination
operator|=
name|qt_term_destination
expr_stmt|;
name|this
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|next_output_byte
operator|=
name|buffer
expr_stmt|;
name|free_in_buffer
operator|=
name|max_buf
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|set_text
specifier|static
specifier|inline
name|void
name|set_text
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|j_compress_ptr
name|cinfo
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
name|text
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|key
decl|,
name|image
operator|.
name|textKeys
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|image
operator|.
name|text
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|pair
decl|,
name|description
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
argument_list|)
control|)
block|{
name|int
name|index
init|=
name|pair
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|pair
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|<
name|index
condition|)
block|{
name|QString
name|s
init|=
name|pair
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"Description"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QString
name|key
init|=
name|pair
operator|.
name|left
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|simplified
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|pair
operator|.
name|mid
argument_list|(
name|index
operator|+
literal|2
argument_list|)
operator|.
name|simplified
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|QMap
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|text
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|text
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QByteArray
name|comment
init|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|comment
operator|.
name|isEmpty
argument_list|()
condition|)
name|comment
operator|+=
literal|": "
expr_stmt|;
name|comment
operator|+=
name|it
operator|.
name|value
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
if|if
condition|(
name|comment
operator|.
name|length
argument_list|()
operator|>
literal|65530
condition|)
name|comment
operator|.
name|truncate
argument_list|(
literal|65530
argument_list|)
expr_stmt|;
name|jpeg_write_marker
argument_list|(
name|cinfo
argument_list|,
name|JPEG_COM
argument_list|,
operator|(
name|JOCTET
operator|*
operator|)
name|comment
operator|.
name|constData
argument_list|()
argument_list|,
name|comment
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_jpeg_image
specifier|static
name|bool
name|write_jpeg_image
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|volatile
name|int
name|sourceQuality
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|,
name|bool
name|optimize
parameter_list|,
name|bool
name|progressive
parameter_list|)
block|{
name|bool
name|success
init|=
literal|false
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|cmap
init|=
name|image
operator|.
name|colorTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Invalid
operator|||
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Alpha8
condition|)
return|return
literal|false
return|;
name|struct
name|jpeg_compress_struct
name|cinfo
decl_stmt|;
name|JSAMPROW
name|row_pointer
index|[
literal|1
index|]
decl_stmt|;
name|row_pointer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|struct
name|my_jpeg_destination_mgr
modifier|*
name|iod_dest
init|=
operator|new
name|my_jpeg_destination_mgr
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|struct
name|my_error_mgr
name|jerr
decl_stmt|;
name|cinfo
operator|.
name|err
operator|=
name|jpeg_std_error
argument_list|(
operator|&
name|jerr
argument_list|)
expr_stmt|;
name|jerr
operator|.
name|error_exit
operator|=
name|my_error_exit
expr_stmt|;
name|jerr
operator|.
name|output_message
operator|=
name|my_output_message
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|jerr
operator|.
name|setjmp_buffer
argument_list|)
condition|)
block|{
comment|// WARNING:
comment|// this if loop is inside a setjmp/longjmp branch
comment|// do not create C++ temporaries here because the destructor may never be called
comment|// if you allocate memory, make sure that you can free it (row_pointer[0])
name|jpeg_create_compress
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|cinfo
operator|.
name|dest
operator|=
name|iod_dest
expr_stmt|;
name|cinfo
operator|.
name|image_width
operator|=
name|image
operator|.
name|width
argument_list|()
expr_stmt|;
name|cinfo
operator|.
name|image_height
operator|=
name|image
operator|.
name|height
argument_list|()
expr_stmt|;
name|bool
name|gray
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|gray
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|image
operator|.
name|colorCount
argument_list|()
init|;
name|gray
operator|&&
name|i
condition|;
name|i
operator|--
control|)
block|{
name|gray
operator|=
name|gray
operator|&
name|qIsGray
argument_list|(
name|cmap
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|.
name|input_components
operator|=
name|gray
condition|?
literal|1
else|:
literal|3
expr_stmt|;
name|cinfo
operator|.
name|in_color_space
operator|=
name|gray
condition|?
name|JCS_GRAYSCALE
else|:
name|JCS_RGB
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Grayscale8
case|:
name|gray
operator|=
literal|true
expr_stmt|;
name|cinfo
operator|.
name|input_components
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|.
name|in_color_space
operator|=
name|JCS_GRAYSCALE
expr_stmt|;
break|break;
default|default:
name|cinfo
operator|.
name|input_components
operator|=
literal|3
expr_stmt|;
name|cinfo
operator|.
name|in_color_space
operator|=
name|JCS_RGB
expr_stmt|;
block|}
name|jpeg_set_defaults
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|qreal
name|diffInch
init|=
name|qAbs
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
operator|-
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
argument_list|)
argument_list|)
operator|+
name|qAbs
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
operator|-
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
argument_list|)
argument_list|)
decl_stmt|;
name|qreal
name|diffCm
init|=
operator|(
name|qAbs
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|/
literal|100.
operator|-
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|/
literal|100.
argument_list|)
argument_list|)
operator|+
name|qAbs
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|/
literal|100.
operator|-
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|/
literal|100.
argument_list|)
argument_list|)
operator|)
operator|*
literal|2.54
decl_stmt|;
if|if
condition|(
name|diffInch
operator|<
name|diffCm
condition|)
block|{
name|cinfo
operator|.
name|density_unit
operator|=
literal|1
expr_stmt|;
comment|// dots/inch
name|cinfo
operator|.
name|X_density
operator|=
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
argument_list|)
expr_stmt|;
name|cinfo
operator|.
name|Y_density
operator|=
name|qRound
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|*
literal|2.54
operator|/
literal|100.
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cinfo
operator|.
name|density_unit
operator|=
literal|2
expr_stmt|;
comment|// dots/cm
name|cinfo
operator|.
name|X_density
operator|=
operator|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|cinfo
operator|.
name|Y_density
operator|=
operator|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|optimize
condition|)
name|cinfo
operator|.
name|optimize_coding
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|progressive
condition|)
name|jpeg_simple_progression
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|int
name|quality
init|=
name|sourceQuality
operator|>=
literal|0
condition|?
name|qMin
argument_list|(
name|int
argument_list|(
name|sourceQuality
argument_list|)
argument_list|,
literal|100
argument_list|)
else|:
literal|75
decl_stmt|;
name|jpeg_set_quality
argument_list|(
operator|&
name|cinfo
argument_list|,
name|quality
argument_list|,
name|TRUE
comment|/* limit to baseline-JPEG values */
argument_list|)
expr_stmt|;
name|jpeg_start_compress
argument_list|(
operator|&
name|cinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|set_text
argument_list|(
name|image
argument_list|,
operator|&
name|cinfo
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|row_pointer
index|[
literal|0
index|]
operator|=
operator|new
name|uchar
index|[
name|cinfo
operator|.
name|image_width
operator|*
name|cinfo
operator|.
name|input_components
index|]
expr_stmt|;
name|int
name|w
init|=
name|cinfo
operator|.
name|image_width
decl_stmt|;
while|while
condition|(
name|cinfo
operator|.
name|next_scanline
operator|<
name|cinfo
operator|.
name|image_height
condition|)
block|{
name|uchar
modifier|*
name|row
init|=
name|row_pointer
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
if|if
condition|(
name|gray
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|data
init|=
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|bit
init|=
operator|!
operator|!
operator|(
operator|*
operator|(
name|data
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
decl_stmt|;
name|row
index|[
name|i
index|]
operator|=
name|qRed
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|bit
init|=
operator|!
operator|!
operator|(
operator|*
operator|(
name|data
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
decl_stmt|;
name|row
index|[
name|i
index|]
operator|=
name|qRed
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|uchar
modifier|*
name|data
init|=
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|bit
init|=
operator|!
operator|!
operator|(
operator|*
operator|(
name|data
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
decl_stmt|;
operator|*
name|row
operator|++
operator|=
name|qRed
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qGreen
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qBlue
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|bit
init|=
operator|!
operator|!
operator|(
operator|*
operator|(
name|data
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
decl_stmt|;
operator|*
name|row
operator|++
operator|=
name|qRed
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qGreen
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qBlue
argument_list|(
name|cmap
index|[
name|bit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
if|if
condition|(
name|gray
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|pix
init|=
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|row
operator|=
name|qRed
argument_list|(
name|cmap
index|[
operator|*
name|pix
index|]
argument_list|)
expr_stmt|;
operator|++
name|row
expr_stmt|;
operator|++
name|pix
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|uchar
modifier|*
name|pix
init|=
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|row
operator|++
operator|=
name|qRed
argument_list|(
name|cmap
index|[
operator|*
name|pix
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qGreen
argument_list|(
name|cmap
index|[
operator|*
name|pix
index|]
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qBlue
argument_list|(
name|cmap
index|[
operator|*
name|pix
index|]
argument_list|)
expr_stmt|;
operator|++
name|pix
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_Grayscale8
case|:
name|memcpy
argument_list|(
name|row
argument_list|,
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
argument_list|,
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|memcpy
argument_list|(
name|row
argument_list|,
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
argument_list|,
name|w
operator|*
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
block|{
specifier|const
name|QRgb
modifier|*
name|rgb
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|image
operator|.
name|constScanLine
argument_list|(
name|cinfo
operator|.
name|next_scanline
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|row
operator|++
operator|=
name|qRed
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qGreen
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qBlue
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|++
name|rgb
expr_stmt|;
block|}
block|}
break|break;
default|default:
block|{
comment|// (Testing shows that this way is actually faster than converting to RGB888 + memcpy)
name|QImage
name|rowImg
init|=
name|image
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
name|cinfo
operator|.
name|next_scanline
argument_list|,
name|w
argument_list|,
literal|1
argument_list|)
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|rgb
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|rowImg
operator|.
name|constScanLine
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|row
operator|++
operator|=
name|qRed
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qGreen
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|*
name|row
operator|++
operator|=
name|qBlue
argument_list|(
operator|*
name|rgb
argument_list|)
expr_stmt|;
operator|++
name|rgb
expr_stmt|;
block|}
block|}
break|break;
block|}
name|jpeg_write_scanlines
argument_list|(
operator|&
name|cinfo
argument_list|,
name|row_pointer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|jpeg_finish_compress
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|jpeg_destroy_compress
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|jpeg_destroy_compress
argument_list|(
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
operator|delete
name|iod_dest
expr_stmt|;
operator|delete
index|[]
name|row_pointer
index|[
literal|0
index|]
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_class
DECL|class|QJpegHandlerPrivate
class|class
name|QJpegHandlerPrivate
block|{
public|public:
DECL|enum|State
enum|enum
name|State
block|{
DECL|enumerator|Ready
name|Ready
block|,
DECL|enumerator|ReadHeader
name|ReadHeader
block|,
DECL|enumerator|Error
name|Error
block|}
enum|;
DECL|function|QJpegHandlerPrivate
name|QJpegHandlerPrivate
parameter_list|(
name|QJpegHandler
modifier|*
name|qq
parameter_list|)
member_init_list|:
name|quality
argument_list|(
literal|75
argument_list|)
member_init_list|,
name|exifOrientation
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|iod_src
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|Ready
argument_list|)
member_init_list|,
name|optimize
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|progressive
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|q
argument_list|(
name|qq
argument_list|)
block|{}
DECL|function|~QJpegHandlerPrivate
name|~
name|QJpegHandlerPrivate
parameter_list|()
block|{
if|if
condition|(
name|iod_src
condition|)
block|{
name|jpeg_destroy_decompress
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
operator|delete
name|iod_src
expr_stmt|;
name|iod_src
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bool
name|readJpegHeader
parameter_list|(
name|QIODevice
modifier|*
parameter_list|)
function_decl|;
name|bool
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
function_decl|;
name|void
name|applyExifOrientation
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
function_decl|;
DECL|member|quality
name|int
name|quality
decl_stmt|;
DECL|member|exifOrientation
name|int
name|exifOrientation
decl_stmt|;
DECL|member|size
name|QVariant
name|size
decl_stmt|;
DECL|member|format
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
DECL|member|scaledSize
name|QSize
name|scaledSize
decl_stmt|;
DECL|member|scaledClipRect
name|QRect
name|scaledClipRect
decl_stmt|;
DECL|member|clipRect
name|QRect
name|clipRect
decl_stmt|;
DECL|member|description
name|QString
name|description
decl_stmt|;
DECL|member|readTexts
name|QStringList
name|readTexts
decl_stmt|;
DECL|member|info
name|struct
name|jpeg_decompress_struct
name|info
decl_stmt|;
DECL|member|iod_src
name|struct
name|my_jpeg_source_mgr
modifier|*
name|iod_src
decl_stmt|;
DECL|member|err
name|struct
name|my_error_mgr
name|err
decl_stmt|;
DECL|member|state
name|State
name|state
decl_stmt|;
DECL|member|optimize
name|bool
name|optimize
decl_stmt|;
DECL|member|progressive
name|bool
name|progressive
decl_stmt|;
DECL|member|q
name|QJpegHandler
modifier|*
name|q
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|readExifHeader
specifier|static
name|bool
name|readExifHeader
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|)
block|{
name|char
name|prefix
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|stream
operator|.
name|readRawData
argument_list|(
name|prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|prefix
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|||
name|prefix
index|[
literal|1
index|]
operator|!=
literal|'x'
operator|||
name|prefix
index|[
literal|2
index|]
operator|!=
literal|'i'
operator|||
name|prefix
index|[
literal|3
index|]
operator|!=
literal|'f'
operator|||
name|prefix
index|[
literal|4
index|]
operator|!=
literal|0
operator|||
name|prefix
index|[
literal|5
index|]
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*  * Returns -1 on error  * Returns 0 if no Exif orientation was found  * Returns 1 orientation is horizontal (normal)  * Returns 2 mirror horizontal  * Returns 3 rotate 180  * Returns 4 mirror vertical  * Returns 5 mirror horizontal and rotate 270 CCW  * Returns 6 rotate 90 CW  * Returns 7 mirror horizontal and rotate 90 CW  * Returns 8 rotate 270 CW  */
end_comment
begin_function
DECL|function|getExifOrientation
specifier|static
name|int
name|getExifOrientation
parameter_list|(
name|QByteArray
modifier|&
name|exifData
parameter_list|)
block|{
name|QDataStream
name|stream
argument_list|(
operator|&
name|exifData
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|readExifHeader
argument_list|(
name|stream
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|quint16
name|val
decl_stmt|;
name|quint32
name|offset
decl_stmt|;
comment|// read byte order marker
name|stream
operator|>>
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0x4949
condition|)
comment|// 'II' == Intel
name|stream
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|0x4d4d
condition|)
comment|// 'MM' == Motorola
name|stream
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|BigEndian
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
comment|// unknown byte order
comment|// read size
name|stream
operator|>>
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0x2a
condition|)
return|return
operator|-
literal|1
return|;
name|stream
operator|>>
name|offset
expr_stmt|;
comment|// we have already used 8 bytes of TIFF header
name|offset
operator|-=
literal|8
expr_stmt|;
comment|// read IFD
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|quint16
name|numEntries
decl_stmt|;
comment|// skip offset bytes to get the next IFD
if|if
condition|(
name|stream
operator|.
name|skipRawData
argument_list|(
name|offset
argument_list|)
operator|!=
operator|(
name|qint32
operator|)
name|offset
condition|)
return|return
operator|-
literal|1
return|;
name|stream
operator|>>
name|numEntries
expr_stmt|;
for|for
control|(
init|;
name|numEntries
operator|>
literal|0
condition|;
operator|--
name|numEntries
control|)
block|{
name|quint16
name|tag
decl_stmt|;
name|quint16
name|type
decl_stmt|;
name|quint32
name|components
decl_stmt|;
name|quint16
name|value
decl_stmt|;
name|quint16
name|dummy
decl_stmt|;
name|stream
operator|>>
name|tag
operator|>>
name|type
operator|>>
name|components
operator|>>
name|value
operator|>>
name|dummy
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0x0112
condition|)
block|{
comment|// Tag Exif.Image.Orientation
if|if
condition|(
name|components
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|type
operator|!=
literal|3
condition|)
comment|// we are expecting it to be an unsigned short
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|value
argument_list|<
literal|1
operator|||
name|value
argument_list|>
literal|8
condition|)
comment|// check for valid range
return|return
operator|-
literal|1
return|;
comment|// It is possible to include the orientation multiple times.
comment|// Right now the first value is returned.
return|return
name|value
return|;
block|}
block|}
comment|// read offset to next IFD
name|stream
operator|>>
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
comment|// this is the last IFD
break|break;
block|}
comment|// No Exif orientation was found
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|readJpegHeader
name|bool
name|QJpegHandlerPrivate
operator|::
name|readJpegHeader
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|Ready
condition|)
block|{
name|state
operator|=
name|Error
expr_stmt|;
name|iod_src
operator|=
operator|new
name|my_jpeg_source_mgr
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|info
operator|.
name|err
operator|=
name|jpeg_std_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|err
operator|.
name|error_exit
operator|=
name|my_error_exit
expr_stmt|;
name|err
operator|.
name|output_message
operator|=
name|my_output_message
expr_stmt|;
name|jpeg_create_decompress
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|src
operator|=
name|iod_src
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|err
operator|.
name|setjmp_buffer
argument_list|)
condition|)
block|{
name|jpeg_save_markers
argument_list|(
operator|&
name|info
argument_list|,
name|JPEG_COM
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|jpeg_save_markers
argument_list|(
operator|&
name|info
argument_list|,
name|JPEG_APP0
operator|+
literal|1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|// Exif uses APP1 marker
operator|(
name|void
operator|)
name|jpeg_read_header
argument_list|(
operator|&
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|int
name|height
init|=
literal|0
decl_stmt|;
name|read_jpeg_size
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|size
operator|=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|format
operator|=
name|QImage
operator|::
name|Format_Invalid
expr_stmt|;
name|read_jpeg_format
argument_list|(
name|format
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|QByteArray
name|exifData
decl_stmt|;
for|for
control|(
name|jpeg_saved_marker_ptr
name|marker
init|=
name|info
operator|.
name|marker_list
init|;
name|marker
operator|!=
name|NULL
condition|;
name|marker
operator|=
name|marker
operator|->
name|next
control|)
block|{
if|if
condition|(
name|marker
operator|->
name|marker
operator|==
name|JPEG_COM
condition|)
block|{
name|QString
name|key
decl_stmt|,
name|value
decl_stmt|;
name|QString
name|s
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|marker
operator|->
name|data
argument_list|,
name|marker
operator|->
name|data_length
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|s
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
operator|||
name|s
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|<
name|index
condition|)
block|{
name|key
operator|=
name|QLatin1String
argument_list|(
literal|"Description"
argument_list|)
expr_stmt|;
name|value
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|key
operator|=
name|s
operator|.
name|left
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|value
operator|=
name|s
operator|.
name|mid
argument_list|(
name|index
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|description
operator|.
name|isEmpty
argument_list|()
condition|)
name|description
operator|+=
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|description
operator|+=
name|key
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
operator|+
name|value
operator|.
name|simplified
argument_list|()
expr_stmt|;
name|readTexts
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|readTexts
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker
operator|->
name|marker
operator|==
name|JPEG_APP0
operator|+
literal|1
condition|)
block|{
name|exifData
operator|.
name|append
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|marker
operator|->
name|data
argument_list|,
name|marker
operator|->
name|data_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exifData
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Exif data present
name|int
name|orientation
init|=
name|getExifOrientation
argument_list|(
name|exifData
argument_list|)
decl_stmt|;
if|if
condition|(
name|orientation
operator|>
literal|0
condition|)
name|exifOrientation
operator|=
name|orientation
expr_stmt|;
block|}
name|state
operator|=
name|ReadHeader
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|Error
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|applyExifOrientation
name|void
name|QJpegHandlerPrivate
operator|::
name|applyExifOrientation
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
comment|// This is not an optimized implementation, but easiest to maintain
name|QTransform
name|transform
decl_stmt|;
switch|switch
condition|(
name|exifOrientation
condition|)
block|{
case|case
literal|1
case|:
comment|// normal
break|break;
case|case
literal|2
case|:
comment|// mirror horizontal
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// rotate 180
name|transform
operator|.
name|rotate
argument_list|(
literal|180
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transform
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// mirror vertical
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|// mirror horizontal and rotate 270 CCW
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|transform
operator|.
name|rotate
argument_list|(
literal|270
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transform
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|// rotate 90 CW
name|transform
operator|.
name|rotate
argument_list|(
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transform
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|// mirror horizontal and rotate 90 CW
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|transform
operator|.
name|rotate
argument_list|(
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transform
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|// rotate 270 CW
name|transform
operator|.
name|rotate
argument_list|(
operator|-
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transform
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"This should never happen"
argument_list|)
expr_stmt|;
block|}
name|exifOrientation
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QJpegHandlerPrivate
operator|::
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|Ready
condition|)
name|readJpegHeader
argument_list|(
name|q
operator|->
name|device
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ReadHeader
condition|)
block|{
name|bool
name|success
init|=
name|read_jpeg_image
argument_list|(
name|image
argument_list|,
name|scaledSize
argument_list|,
name|scaledClipRect
argument_list|,
name|clipRect
argument_list|,
name|quality
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|err
argument_list|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readTexts
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
name|image
operator|->
name|setText
argument_list|(
name|readTexts
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|readTexts
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|applyExifOrientation
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|state
operator|=
name|Ready
expr_stmt|;
return|return
literal|true
return|;
block|}
name|state
operator|=
name|Error
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|void
name|QT_FASTCALL
name|qt_convert_rgb888_to_rgb32_neon
parameter_list|(
name|quint32
modifier|*
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_GUI_EXPORT
name|void
name|QT_FASTCALL
name|qt_convert_rgb888_to_rgb32_ssse3
parameter_list|(
name|quint32
modifier|*
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl
begin_extern
extern|extern
literal|"C"
name|void
name|qt_convert_rgb888_to_rgb32_mips_dspr2_asm
parameter_list|(
name|quint32
modifier|*
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_extern
begin_constructor
DECL|function|QJpegHandler
name|QJpegHandler
operator|::
name|QJpegHandler
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QJpegHandlerPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__ARM_NEON__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_PROCESSOR_ARM_64
argument_list|)
comment|// from qimage_neon.cpp
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|NEON
argument_list|)
condition|)
name|rgb888ToRgb32ConverterPtr
operator|=
name|qt_convert_rgb888_to_rgb32_neon
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSSE3
argument_list|)
comment|// from qimage_ssse3.cpp
if|if
condition|(
literal|false
condition|)
block|{     }
elseif|else
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|SSSE3
argument_list|)
condition|)
block|{
name|rgb888ToRgb32ConverterPtr
operator|=
name|qt_convert_rgb888_to_rgb32_ssse3
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_COMPILER_SUPPORTS_SSSE3
if|#
directive|if
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_MIPS_DSPR2
argument_list|)
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|DSPR2
argument_list|)
condition|)
block|{
name|rgb888ToRgb32ConverterPtr
operator|=
name|qt_convert_rgb888_to_rgb32_mips_dspr2_asm
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_COMPILER_SUPPORTS_DSPR2
block|}
end_constructor
begin_destructor
DECL|function|~QJpegHandler
name|QJpegHandler
operator|::
name|~
name|QJpegHandler
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|canRead
name|bool
name|QJpegHandler
operator|::
name|canRead
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|QJpegHandlerPrivate
operator|::
name|Ready
operator|&&
operator|!
name|canRead
argument_list|(
name|device
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QJpegHandlerPrivate
operator|::
name|Error
condition|)
block|{
name|setFormat
argument_list|(
literal|"jpeg"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canRead
name|bool
name|QJpegHandler
operator|::
name|canRead
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QJpegHandler::canRead() called with no device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|char
name|buffer
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|peek
argument_list|(
name|buffer
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
return|return
literal|false
return|;
return|return
name|uchar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0xff
operator|&&
name|uchar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0xd8
return|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QJpegHandler
operator|::
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|canRead
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|read
argument_list|(
name|image
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write
name|bool
name|QJpegHandler
operator|::
name|write
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
return|return
name|write_jpeg_image
argument_list|(
name|image
argument_list|,
name|device
argument_list|()
argument_list|,
name|d
operator|->
name|quality
argument_list|,
name|d
operator|->
name|description
argument_list|,
name|d
operator|->
name|optimize
argument_list|,
name|d
operator|->
name|progressive
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|supportsOption
name|bool
name|QJpegHandler
operator|::
name|supportsOption
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
return|return
name|option
operator|==
name|Quality
operator|||
name|option
operator|==
name|ScaledSize
operator|||
name|option
operator|==
name|ScaledClipRect
operator|||
name|option
operator|==
name|ClipRect
operator|||
name|option
operator|==
name|Description
operator|||
name|option
operator|==
name|Size
operator|||
name|option
operator|==
name|ImageFormat
operator|||
name|option
operator|==
name|OptimizedWrite
operator|||
name|option
operator|==
name|ProgressiveScanWrite
return|;
block|}
end_function
begin_function
DECL|function|option
name|QVariant
name|QJpegHandler
operator|::
name|option
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|Quality
case|:
return|return
name|d
operator|->
name|quality
return|;
case|case
name|ScaledSize
case|:
return|return
name|d
operator|->
name|scaledSize
return|;
case|case
name|ScaledClipRect
case|:
return|return
name|d
operator|->
name|scaledClipRect
return|;
case|case
name|ClipRect
case|:
return|return
name|d
operator|->
name|clipRect
return|;
case|case
name|Description
case|:
name|d
operator|->
name|readJpegHeader
argument_list|(
name|device
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|description
return|;
case|case
name|Size
case|:
name|d
operator|->
name|readJpegHeader
argument_list|(
name|device
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|size
return|;
case|case
name|ImageFormat
case|:
name|d
operator|->
name|readJpegHeader
argument_list|(
name|device
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|format
return|;
case|case
name|OptimizedWrite
case|:
return|return
name|d
operator|->
name|optimize
return|;
case|case
name|ProgressiveScanWrite
case|:
return|return
name|d
operator|->
name|progressive
return|;
default|default:
break|break;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setOption
name|void
name|QJpegHandler
operator|::
name|setOption
parameter_list|(
name|ImageOption
name|option
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|Quality
case|:
name|d
operator|->
name|quality
operator|=
name|value
operator|.
name|toInt
argument_list|()
expr_stmt|;
break|break;
case|case
name|ScaledSize
case|:
name|d
operator|->
name|scaledSize
operator|=
name|value
operator|.
name|toSize
argument_list|()
expr_stmt|;
break|break;
case|case
name|ScaledClipRect
case|:
name|d
operator|->
name|scaledClipRect
operator|=
name|value
operator|.
name|toRect
argument_list|()
expr_stmt|;
break|break;
case|case
name|ClipRect
case|:
name|d
operator|->
name|clipRect
operator|=
name|value
operator|.
name|toRect
argument_list|()
expr_stmt|;
break|break;
case|case
name|Description
case|:
name|d
operator|->
name|description
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
case|case
name|OptimizedWrite
case|:
name|d
operator|->
name|optimize
operator|=
name|value
operator|.
name|toBool
argument_list|()
expr_stmt|;
break|break;
case|case
name|ProgressiveScanWrite
case|:
name|d
operator|->
name|progressive
operator|=
name|value
operator|.
name|toBool
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QJpegHandler
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"jpeg"
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
