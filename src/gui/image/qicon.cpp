begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qicon.h"
end_include
begin_include
include|#
directive|include
file|"qicon_p.h"
end_include
begin_include
include|#
directive|include
file|"qiconengine.h"
end_include
begin_include
include|#
directive|include
file|"qiconengineplugin.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"private/qfactoryloader_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qiconloader_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qcache.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qpalette.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qt_mac_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qt_cocoa_helpers_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qhexstring_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qpa/qplatformtheme.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ICON
end_ifndef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \enum QIcon::Mode      This enum type describes the mode for which a pixmap is intended     to be used. The currently defined modes are:      \value Normal          Display the pixmap when the user is         not interacting with the icon, but the         functionality represented by the icon is available.     \value Disabled          Display the pixmap when the         functionality represented by the icon is not available.     \value Active          Display the pixmap when the         functionality represented by the icon is available and         the user is interacting with the icon, for example, moving the         mouse over it or clicking it.    \value Selected         Display the pixmap when the item represented by the icon is         selected. */
comment|/*!   \enum QIcon::State    This enum describes the state for which a pixmap is intended to be   used. The \e state can be:    \value Off  Display the pixmap when the widget is in an "off" state   \value On  Display the pixmap when the widget is in an "on" state */
DECL|variable|serialNumCounter
specifier|static
name|QBasicAtomicInt
name|serialNumCounter
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|qt_cleanup_icon_cache
parameter_list|()
function_decl|;
end_function_decl
begin_namespace
namespace|namespace
block|{
DECL|struct|IconCache
struct|struct
name|IconCache
super|:
specifier|public
name|QCache
argument_list|<
name|QString
argument_list|,
name|QIcon
argument_list|>
block|{
DECL|function|IconCache
name|IconCache
parameter_list|()
block|{
comment|// ### note: won't readd if QApplication is re-created!
name|qAddPostRoutine
argument_list|(
name|qt_cleanup_icon_cache
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
block|}
end_namespace
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|IconCache
argument_list|,
argument|qtIconCache
argument_list|)
end_macro
begin_function
DECL|function|qt_cleanup_icon_cache
specifier|static
name|void
name|qt_cleanup_icon_cache
parameter_list|()
block|{
name|qtIconCache
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Returns the effective device pixel ratio, using     the provided window pointer if possible.      if Qt::AA_UseHighDpiPixmaps is not set this function     returns 1.0 to keep non-hihdpi aware code working. */
end_comment
begin_function
DECL|function|qt_effective_device_pixel_ratio
specifier|static
name|qreal
name|qt_effective_device_pixel_ratio
parameter_list|(
name|QWindow
modifier|*
name|window
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qApp
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_UseHighDpiPixmaps
argument_list|)
condition|)
return|return
name|qreal
argument_list|(
literal|1.0
argument_list|)
return|;
if|if
condition|(
name|window
condition|)
return|return
name|window
operator|->
name|devicePixelRatio
argument_list|()
return|;
return|return
name|qApp
operator|->
name|devicePixelRatio
argument_list|()
return|;
comment|// Don't know which window to target.
block|}
end_function
begin_constructor
DECL|function|QIconPrivate
name|QIconPrivate
operator|::
name|QIconPrivate
parameter_list|()
member_init_list|:
name|engine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|serialNum
argument_list|(
name|serialNumCounter
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
member_init_list|,
name|detach_no
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal     Computes the displayDevicePixelRatio for a pixmap.      If displayDevicePixelRatio is 1.0 the reurned value is 1.0, always.      For a displayDevicePixelRatio of 2.0 the returned value will be between     1.0 and 2.0, depending on requestedSize and actualsize:     * If actualsize< requestedSize        : 1.0 (not enough pixels for a normal-dpi pixmap)     * If actualsize == requestedSize * 2.0 : 2.0 (enough pixels for a high-dpi pixmap)     * else : a scaled value between 1.0 and 2.0. (pixel count is between normal-dpi and high-dpi) */
end_comment
begin_function
DECL|function|pixmapDevicePixelRatio
name|qreal
name|QIconPrivate
operator|::
name|pixmapDevicePixelRatio
parameter_list|(
name|qreal
name|displayDevicePixelRatio
parameter_list|,
specifier|const
name|QSize
modifier|&
name|requestedSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|actualSize
parameter_list|)
block|{
name|QSize
name|targetSize
init|=
name|requestedSize
operator|*
name|displayDevicePixelRatio
decl_stmt|;
name|qreal
name|scale
init|=
literal|0.5
operator|*
operator|(
name|qreal
argument_list|(
name|actualSize
operator|.
name|width
argument_list|()
argument_list|)
operator|/
name|qreal
argument_list|(
name|targetSize
operator|.
name|width
argument_list|()
argument_list|)
operator|+
name|qreal
argument_list|(
name|actualSize
operator|.
name|height
argument_list|()
operator|/
name|qreal
argument_list|(
name|targetSize
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
operator|)
decl_stmt|;
return|return
name|qMax
argument_list|(
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|displayDevicePixelRatio
operator|*
name|scale
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|QPixmapIconEngine
name|QPixmapIconEngine
operator|::
name|QPixmapIconEngine
parameter_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|QPixmapIconEngine
name|QPixmapIconEngine
operator|::
name|QPixmapIconEngine
parameter_list|(
specifier|const
name|QPixmapIconEngine
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QIconEngine
argument_list|(
name|other
argument_list|)
member_init_list|,
name|pixmaps
argument_list|(
name|other
operator|.
name|pixmaps
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QPixmapIconEngine
name|QPixmapIconEngine
operator|::
name|~
name|QPixmapIconEngine
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|paint
name|void
name|QPixmapIconEngine
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
name|QSize
name|pixmapSize
init|=
name|rect
operator|.
name|size
argument_list|()
operator|*
name|qt_effective_device_pixel_ratio
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QPixmap
name|px
init|=
name|pixmap
argument_list|(
name|pixmapSize
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|rect
argument_list|,
name|px
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|area
specifier|static
specifier|inline
name|int
name|area
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|width
argument_list|()
operator|*
name|s
operator|.
name|height
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// returns the smallest of the two that is still larger than or equal to size.
end_comment
begin_function
DECL|function|bestSizeMatch
specifier|static
name|QPixmapIconEngineEntry
modifier|*
name|bestSizeMatch
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QPixmapIconEngineEntry
modifier|*
name|pa
parameter_list|,
name|QPixmapIconEngineEntry
modifier|*
name|pb
parameter_list|)
block|{
name|int
name|s
init|=
name|area
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
operator|->
name|size
operator|==
name|QSize
argument_list|()
operator|&&
name|pa
operator|->
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pa
operator|->
name|pixmap
operator|=
name|QPixmap
argument_list|(
name|pa
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|pa
operator|->
name|size
operator|=
name|pa
operator|->
name|pixmap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|int
name|a
init|=
name|area
argument_list|(
name|pa
operator|->
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|size
operator|==
name|QSize
argument_list|()
operator|&&
name|pb
operator|->
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pb
operator|->
name|pixmap
operator|=
name|QPixmap
argument_list|(
name|pb
operator|->
name|fileName
argument_list|)
expr_stmt|;
name|pb
operator|->
name|size
operator|=
name|pb
operator|->
name|pixmap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|int
name|b
init|=
name|area
argument_list|(
name|pb
operator|->
name|size
argument_list|)
decl_stmt|;
name|int
name|res
init|=
name|a
decl_stmt|;
if|if
condition|(
name|qMin
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|>=
name|s
condition|)
name|res
operator|=
name|qMin
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|qMax
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|a
condition|)
return|return
name|pa
return|;
return|return
name|pb
return|;
block|}
end_function
begin_function
DECL|function|tryMatch
name|QPixmapIconEngineEntry
modifier|*
name|QPixmapIconEngine
operator|::
name|tryMatch
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
name|QPixmapIconEngineEntry
modifier|*
name|pe
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pixmaps
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mode
operator|==
name|mode
operator|&&
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|state
operator|==
name|state
condition|)
block|{
if|if
condition|(
name|pe
condition|)
name|pe
operator|=
name|bestSizeMatch
argument_list|(
name|size
argument_list|,
operator|&
name|pixmaps
index|[
name|i
index|]
argument_list|,
name|pe
argument_list|)
expr_stmt|;
else|else
name|pe
operator|=
operator|&
name|pixmaps
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|pe
return|;
block|}
end_function
begin_function
DECL|function|bestMatch
name|QPixmapIconEngineEntry
modifier|*
name|QPixmapIconEngine
operator|::
name|bestMatch
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|,
name|bool
name|sizeOnly
parameter_list|)
block|{
name|QPixmapIconEngineEntry
modifier|*
name|pe
init|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|pe
condition|)
block|{
name|QIcon
operator|::
name|State
name|oppositeState
init|=
operator|(
name|state
operator|==
name|QIcon
operator|::
name|On
operator|)
condition|?
name|QIcon
operator|::
name|Off
else|:
name|QIcon
operator|::
name|On
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QIcon
operator|::
name|Disabled
operator|||
name|mode
operator|==
name|QIcon
operator|::
name|Selected
condition|)
block|{
name|QIcon
operator|::
name|Mode
name|oppositeMode
init|=
operator|(
name|mode
operator|==
name|QIcon
operator|::
name|Disabled
operator|)
condition|?
name|QIcon
operator|::
name|Selected
else|:
name|QIcon
operator|::
name|Disabled
decl_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Normal
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Active
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Normal
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Active
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|oppositeMode
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|oppositeMode
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
name|QIcon
operator|::
name|Mode
name|oppositeMode
init|=
operator|(
name|mode
operator|==
name|QIcon
operator|::
name|Normal
operator|)
condition|?
name|QIcon
operator|::
name|Active
else|:
name|QIcon
operator|::
name|Normal
decl_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|oppositeMode
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|oppositeMode
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Disabled
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Selected
argument_list|,
name|state
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Disabled
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|tryMatch
argument_list|(
name|size
argument_list|,
name|QIcon
operator|::
name|Selected
argument_list|,
name|oppositeState
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|pe
condition|)
return|return
name|pe
return|;
block|}
if|if
condition|(
name|sizeOnly
condition|?
operator|(
name|pe
operator|->
name|size
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|pe
operator|->
name|size
operator|.
name|isValid
argument_list|()
operator|)
else|:
name|pe
operator|->
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pe
operator|->
name|pixmap
operator|=
name|QPixmap
argument_list|(
name|pe
operator|->
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pe
operator|->
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
name|pe
operator|->
name|size
operator|=
name|pe
operator|->
name|pixmap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|pe
return|;
block|}
end_function
begin_function
DECL|function|pixmap
name|QPixmap
name|QPixmapIconEngine
operator|::
name|pixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
name|QPixmap
name|pm
decl_stmt|;
name|QPixmapIconEngineEntry
modifier|*
name|pe
init|=
name|bestMatch
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
condition|)
name|pm
operator|=
name|pe
operator|->
name|pixmap
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|int
name|idx
init|=
name|pixmaps
operator|.
name|count
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|idx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pe
operator|==
operator|&
name|pixmaps
index|[
name|idx
index|]
condition|)
block|{
name|pixmaps
operator|.
name|remove
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pixmaps
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|pm
return|;
else|else
return|return
name|pixmap
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
return|;
block|}
name|QSize
name|actualSize
init|=
name|pm
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|actualSize
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
name|actualSize
operator|.
name|width
argument_list|()
operator|>
name|size
operator|.
name|width
argument_list|()
operator|||
name|actualSize
operator|.
name|height
argument_list|()
operator|>
name|size
operator|.
name|height
argument_list|()
operator|)
condition|)
name|actualSize
operator|.
name|scale
argument_list|(
name|size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
expr_stmt|;
name|QString
name|key
init|=
name|QLatin1String
argument_list|(
literal|"qt_"
argument_list|)
operator|%
name|HexString
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|pm
operator|.
name|cacheKey
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|pe
operator|->
name|mode
argument_list|)
operator|%
name|HexString
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|QGuiApplication
operator|::
name|palette
argument_list|()
operator|.
name|cacheKey
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|actualSize
operator|.
name|width
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|actualSize
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QIcon
operator|::
name|Active
condition|)
block|{
if|if
condition|(
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|mode
argument_list|)
argument_list|,
name|pm
argument_list|)
condition|)
return|return
name|pm
return|;
comment|// horray
if|if
condition|(
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|QIcon
operator|::
name|Normal
argument_list|)
argument_list|,
name|pm
argument_list|)
condition|)
block|{
name|QPixmap
name|active
init|=
name|pm
decl_stmt|;
if|if
condition|(
name|QGuiApplication
modifier|*
name|guiApp
init|=
name|qobject_cast
argument_list|<
name|QGuiApplication
operator|*
argument_list|>
argument_list|(
name|qApp
argument_list|)
condition|)
name|active
operator|=
cast|static_cast
argument_list|<
name|QGuiApplicationPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|guiApp
argument_list|)
argument_list|)
operator|->
name|applyQIconStyleHelper
argument_list|(
name|QIcon
operator|::
name|Active
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|cacheKey
argument_list|()
operator|==
name|active
operator|.
name|cacheKey
argument_list|()
condition|)
return|return
name|pm
return|;
block|}
block|}
if|if
condition|(
operator|!
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|mode
argument_list|)
argument_list|,
name|pm
argument_list|)
condition|)
block|{
if|if
condition|(
name|pm
operator|.
name|size
argument_list|()
operator|!=
name|actualSize
condition|)
name|pm
operator|=
name|pm
operator|.
name|scaled
argument_list|(
name|actualSize
argument_list|,
name|Qt
operator|::
name|IgnoreAspectRatio
argument_list|,
name|Qt
operator|::
name|SmoothTransformation
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|mode
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|QIcon
operator|::
name|Normal
condition|)
block|{
name|QPixmap
name|generated
init|=
name|pm
decl_stmt|;
if|if
condition|(
name|QGuiApplication
modifier|*
name|guiApp
init|=
name|qobject_cast
argument_list|<
name|QGuiApplication
operator|*
argument_list|>
argument_list|(
name|qApp
argument_list|)
condition|)
name|generated
operator|=
cast|static_cast
argument_list|<
name|QGuiApplicationPrivate
operator|*
argument_list|>
argument_list|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|guiApp
argument_list|)
argument_list|)
operator|->
name|applyQIconStyleHelper
argument_list|(
name|mode
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generated
operator|.
name|isNull
argument_list|()
condition|)
name|pm
operator|=
name|generated
expr_stmt|;
block|}
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|key
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|mode
argument_list|)
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
return|return
name|pm
return|;
block|}
end_function
begin_function
DECL|function|actualSize
name|QSize
name|QPixmapIconEngine
operator|::
name|actualSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
name|QSize
name|actualSize
decl_stmt|;
if|if
condition|(
name|QPixmapIconEngineEntry
modifier|*
name|pe
init|=
name|bestMatch
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|,
literal|true
argument_list|)
condition|)
name|actualSize
operator|=
name|pe
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|actualSize
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|actualSize
return|;
if|if
condition|(
operator|!
name|actualSize
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
name|actualSize
operator|.
name|width
argument_list|()
operator|>
name|size
operator|.
name|width
argument_list|()
operator|||
name|actualSize
operator|.
name|height
argument_list|()
operator|>
name|size
operator|.
name|height
argument_list|()
operator|)
condition|)
name|actualSize
operator|.
name|scale
argument_list|(
name|size
argument_list|,
name|Qt
operator|::
name|KeepAspectRatio
argument_list|)
expr_stmt|;
return|return
name|actualSize
return|;
block|}
end_function
begin_function
DECL|function|addPixmap
name|void
name|QPixmapIconEngine
operator|::
name|addPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QPixmapIconEngineEntry
modifier|*
name|pe
init|=
name|tryMatch
argument_list|(
name|pixmap
operator|.
name|size
argument_list|()
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|&&
name|pe
operator|->
name|size
operator|==
name|pixmap
operator|.
name|size
argument_list|()
condition|)
block|{
name|pe
operator|->
name|pixmap
operator|=
name|pixmap
expr_stmt|;
name|pe
operator|->
name|fileName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pixmaps
operator|+=
name|QPixmapIconEngineEntry
argument_list|(
name|pixmap
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|// Read out original image depth as set by ICOReader
end_comment
begin_function
DECL|function|origIcoDepth
specifier|static
specifier|inline
name|int
name|origIcoDepth
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
specifier|const
name|QString
name|s
init|=
name|image
operator|.
name|text
argument_list|(
name|QStringLiteral
argument_list|(
literal|"_q_icoOrigDepth"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|s
operator|.
name|isEmpty
argument_list|()
condition|?
literal|32
else|:
name|s
operator|.
name|toInt
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|findBySize
specifier|static
specifier|inline
name|int
name|findBySize
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QImage
argument_list|>
modifier|&
name|images
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|images
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|images
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|// Convenience class providing a bool read() function.
end_comment
begin_namespace
namespace|namespace
block|{
DECL|class|ImageReader
class|class
name|ImageReader
block|{
public|public:
DECL|function|ImageReader
name|ImageReader
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
member_init_list|:
name|m_reader
argument_list|(
name|fileName
argument_list|)
member_init_list|,
name|m_atEnd
argument_list|(
literal|false
argument_list|)
block|{}
DECL|function|format
name|QByteArray
name|format
parameter_list|()
specifier|const
block|{
return|return
name|m_reader
operator|.
name|format
argument_list|()
return|;
block|}
DECL|function|read
name|bool
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
name|m_atEnd
condition|)
return|return
literal|false
return|;
operator|*
name|image
operator|=
name|m_reader
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|->
name|size
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|m_atEnd
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|m_atEnd
operator|=
operator|!
name|m_reader
operator|.
name|jumpToNextImage
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
private|private:
DECL|member|m_reader
name|QImageReader
name|m_reader
decl_stmt|;
DECL|member|m_atEnd
name|bool
name|m_atEnd
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_function
DECL|function|addFile
name|void
name|QPixmapIconEngine
operator|::
name|addFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QIcon
operator|::
name|Mode
name|mode
parameter_list|,
name|QIcon
operator|::
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|QString
name|abs
init|=
name|fileName
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|?
name|fileName
else|:
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|absoluteFilePath
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|ignoreSize
init|=
operator|!
name|size
operator|.
name|isValid
argument_list|()
decl_stmt|;
name|ImageReader
name|imageReader
argument_list|(
name|abs
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|format
init|=
name|imageReader
operator|.
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// Device failed to open or unsupported format.
return|return;
name|QImage
name|image
decl_stmt|;
if|if
condition|(
name|format
operator|!=
literal|"ico"
condition|)
block|{
if|if
condition|(
name|ignoreSize
condition|)
block|{
comment|// No size specified: Add all images.
while|while
condition|(
name|imageReader
operator|.
name|read
argument_list|(
operator|&
name|image
argument_list|)
condition|)
name|pixmaps
operator|+=
name|QPixmapIconEngineEntry
argument_list|(
name|abs
argument_list|,
name|image
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Try to match size. If that fails, add a placeholder with the filename and empty pixmap for the size.
while|while
condition|(
name|imageReader
operator|.
name|read
argument_list|(
operator|&
name|image
argument_list|)
operator|&&
name|image
operator|.
name|size
argument_list|()
operator|!=
name|size
condition|)
block|{}
name|pixmaps
operator|+=
name|image
operator|.
name|size
argument_list|()
operator|==
name|size
condition|?
name|QPixmapIconEngineEntry
argument_list|(
name|abs
argument_list|,
name|image
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
else|:
name|QPixmapIconEngineEntry
argument_list|(
name|abs
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Special case for reading Windows ".ico" files. Historically (QTBUG-39287),
comment|// these files may contain low-resolution images. As this information is lost,
comment|// ICOReader sets the original format as an image text key value. Read all matching
comment|// images into a list trying to find the highest quality per size.
name|QList
argument_list|<
name|QImage
argument_list|>
name|icoImages
decl_stmt|;
while|while
condition|(
name|imageReader
operator|.
name|read
argument_list|(
operator|&
name|image
argument_list|)
condition|)
block|{
if|if
condition|(
name|ignoreSize
operator|||
name|image
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
block|{
specifier|const
name|int
name|position
init|=
name|findBySize
argument_list|(
name|icoImages
argument_list|,
name|image
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|position
operator|>=
literal|0
condition|)
block|{
comment|// Higher quality available? -> replace.
if|if
condition|(
name|origIcoDepth
argument_list|(
name|image
argument_list|)
operator|>
name|origIcoDepth
argument_list|(
name|icoImages
operator|.
name|at
argument_list|(
name|position
argument_list|)
argument_list|)
condition|)
name|icoImages
index|[
name|position
index|]
operator|=
name|image
expr_stmt|;
block|}
else|else
block|{
name|icoImages
operator|.
name|append
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
block|}
foreach|foreach
control|(
specifier|const
name|QImage
modifier|&
name|i
decl|,
name|icoImages
control|)
name|pixmaps
operator|+=
name|QPixmapIconEngineEntry
argument_list|(
name|abs
argument_list|,
name|i
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|icoImages
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ignoreSize
condition|)
comment|// Add placeholder with the filename and empty pixmap for the size.
name|pixmaps
operator|+=
name|QPixmapIconEngineEntry
argument_list|(
name|abs
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|key
name|QString
name|QPixmapIconEngine
operator|::
name|key
parameter_list|()
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
literal|"QPixmapIconEngine"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clone
name|QIconEngine
modifier|*
name|QPixmapIconEngine
operator|::
name|clone
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QPixmapIconEngine
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QPixmapIconEngine
operator|::
name|read
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|)
block|{
name|int
name|num_entries
decl_stmt|;
name|QPixmap
name|pm
decl_stmt|;
name|QString
name|fileName
decl_stmt|;
name|QSize
name|sz
decl_stmt|;
name|uint
name|mode
decl_stmt|;
name|uint
name|state
decl_stmt|;
name|in
operator|>>
name|num_entries
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|in
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|pixmaps
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|in
operator|>>
name|pm
expr_stmt|;
name|in
operator|>>
name|fileName
expr_stmt|;
name|in
operator|>>
name|sz
expr_stmt|;
name|in
operator|>>
name|mode
expr_stmt|;
name|in
operator|>>
name|state
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|addFile
argument_list|(
name|fileName
argument_list|,
name|sz
argument_list|,
name|QIcon
operator|::
name|Mode
argument_list|(
name|mode
argument_list|)
argument_list|,
name|QIcon
operator|::
name|State
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPixmapIconEngineEntry
name|pe
argument_list|(
name|fileName
argument_list|,
name|sz
argument_list|,
name|QIcon
operator|::
name|Mode
argument_list|(
name|mode
argument_list|)
argument_list|,
name|QIcon
operator|::
name|State
argument_list|(
name|state
argument_list|)
argument_list|)
decl_stmt|;
name|pe
operator|.
name|pixmap
operator|=
name|pm
expr_stmt|;
name|pixmaps
operator|+=
name|pe
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|write
name|bool
name|QPixmapIconEngine
operator|::
name|write
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|)
specifier|const
block|{
name|int
name|num_entries
init|=
name|pixmaps
operator|.
name|size
argument_list|()
decl_stmt|;
name|out
operator|<<
name|num_entries
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
name|out
operator|<<
name|QPixmap
argument_list|(
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|fileName
argument_list|)
expr_stmt|;
else|else
name|out
operator|<<
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pixmap
expr_stmt|;
name|out
operator|<<
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|fileName
expr_stmt|;
name|out
operator|<<
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|size
expr_stmt|;
name|out
operator|<<
operator|(
name|uint
operator|)
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mode
expr_stmt|;
name|out
operator|<<
operator|(
name|uint
operator|)
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|state
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|virtual_hook
name|void
name|QPixmapIconEngine
operator|::
name|virtual_hook
parameter_list|(
name|int
name|id
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|QIconEngine
operator|::
name|AvailableSizesHook
case|:
block|{
name|QIconEngine
operator|::
name|AvailableSizesArgument
modifier|&
name|arg
init|=
operator|*
cast|reinterpret_cast
argument_list|<
name|QIconEngine
operator|::
name|AvailableSizesArgument
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|arg
operator|.
name|sizes
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pixmaps
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPixmapIconEngineEntry
modifier|&
name|pe
init|=
name|pixmaps
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|size
operator|==
name|QSize
argument_list|()
operator|&&
name|pe
operator|.
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pe
operator|.
name|pixmap
operator|=
name|QPixmap
argument_list|(
name|pe
operator|.
name|fileName
argument_list|)
expr_stmt|;
name|pe
operator|.
name|size
operator|=
name|pe
operator|.
name|pixmap
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|.
name|mode
operator|==
name|arg
operator|.
name|mode
operator|&&
name|pe
operator|.
name|state
operator|==
name|arg
operator|.
name|state
operator|&&
operator|!
name|pe
operator|.
name|size
operator|.
name|isEmpty
argument_list|()
condition|)
name|arg
operator|.
name|sizes
operator|.
name|push_back
argument_list|(
name|pe
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|QIconEngine
operator|::
name|virtual_hook
argument_list|(
name|id
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QFactoryLoader
argument_list|,
argument|loader
argument_list|,
argument|(QIconEngineFactoryInterface_iid, QLatin1String(
literal|"/iconengines"
argument|), Qt::CaseInsensitive)
argument_list|)
end_macro
begin_function
DECL|function|qt_iconEngineFactoryLoader
name|QFactoryLoader
modifier|*
name|qt_iconEngineFactoryLoader
parameter_list|()
block|{
return|return
name|loader
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \class QIcon    \brief The QIcon class provides scalable icons in different modes   and states.    \ingroup painting   \ingroup shared   \inmodule QtGui    A QIcon can generate smaller, larger, active, and disabled pixmaps   from the set of pixmaps it is given. Such pixmaps are used by Qt   widgets to show an icon representing a particular action.    The simplest use of QIcon is to create one from a QPixmap file or   resource, and then use it, allowing Qt to work out all the required   icon styles and sizes. For example:    \snippet code/src_gui_image_qicon.cpp 0    To undo a QIcon, simply set a null icon in its place:    \snippet code/src_gui_image_qicon.cpp 1    Use the QImageReader::supportedImageFormats() and   QImageWriter::supportedImageFormats() functions to retrieve a   complete list of the supported file formats.    When you retrieve a pixmap using pixmap(QSize, Mode, State), and no   pixmap for this given size, mode and state has been added with   addFile() or addPixmap(), then QIcon will generate one on the   fly. This pixmap generation happens in a QIconEngineV2. The default   engine scales pixmaps down if required, but never up, and it uses   the current style to calculate a disabled appearance. By using   custom icon engines, you can customize every aspect of generated   icons. With QIconEnginePluginV2 it is possible to register different   icon engines for different file suffixes, making it possible for   third parties to provide additional icon engines to those included   with Qt.    \note Since Qt 4.2, an icon engine that supports SVG is included.    \section1 Making Classes that Use QIcon    If you write your own widgets that have an option to set a small   pixmap, consider allowing a QIcon to be set for that pixmap.  The   Qt class QToolButton is an example of such a widget.    Provide a method to set a QIcon, and when you draw the icon, choose   whichever pixmap is appropriate for the current state of your widget.   For example:   \snippet code/src_gui_image_qicon.cpp 2    You might also make use of the \c Active mode, perhaps making your   widget \c Active when the mouse is over the widget (see \l   QWidget::enterEvent()), while the mouse is pressed pending the   release that will activate the function, or when it is the currently   selected item. If the widget can be toggled, the "On" mode might be   used to draw a different icon.    \image icon.png QIcon    \sa {fowler}{GUI Design Handbook: Iconic Label}, {Icons Example} */
end_comment
begin_comment
comment|/*!   Constructs a null icon. */
end_comment
begin_constructor
DECL|function|QIcon
name|QIcon
operator|::
name|QIcon
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Constructs an icon from a \a pixmap.  */
end_comment
begin_constructor
DECL|function|QIcon
name|QIcon
operator|::
name|QIcon
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
name|addPixmap
argument_list|(
name|pixmap
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Constructs a copy of \a other. This is very fast. */
end_comment
begin_constructor
DECL|function|QIcon
name|QIcon
operator|::
name|QIcon
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an icon from the file with the given \a fileName. The     file will be loaded on demand.      If \a fileName contains a relative path (e.g. the filename only)     the relevant file must be found relative to the runtime working     directory.      The file name can be either refer to an actual file on disk or to     one of the application's embedded resources.  See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      Use the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions to retrieve a     complete list of the supported file formats. */
end_comment
begin_constructor
DECL|function|QIcon
name|QIcon
operator|::
name|QIcon
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
name|addFile
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates an icon with a specific icon \a engine. The icon takes     ownership of the engine. */
end_comment
begin_constructor
DECL|function|QIcon
name|QIcon
operator|::
name|QIcon
parameter_list|(
name|QIconEngine
modifier|*
name|engine
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QIconPrivate
argument_list|)
block|{
name|d
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the icon. */
end_comment
begin_destructor
DECL|function|~QIcon
name|QIcon
operator|::
name|~
name|QIcon
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns the \a other icon to this icon and returns a reference to     this icon. */
end_comment
begin_function
DECL|function|operator =
name|QIcon
modifier|&
name|QIcon
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QIcon
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d
condition|)
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QIcon&QIcon::operator=(QIcon&&other)      Move-assigns \a other to this QIcon instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn void QIcon::swap(QIcon&other)     \since 4.8      Swaps icon \a other with this icon. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!    Returns the icon as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QIcon
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Icon
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QIcon::serialNumber() const     \obsolete      Returns a number that identifies the contents of this     QIcon object. Distinct QIcon objects can have     the same serial number if they refer to the same contents     (but they don't have to). Also, the serial number of     a QIcon object may change during its lifetime.      Use cacheKey() instead.      A null icon always has a serial number of 0.      Serial numbers are mostly useful in conjunction with caching.      \sa QPixmap::serialNumber() */
end_comment
begin_comment
comment|/*!     Returns a number that identifies the contents of this QIcon     object. Distinct QIcon objects can have the same key if     they refer to the same contents.     \since 4.3      The cacheKey() will change when the icon is altered via     addPixmap() or addFile().      Cache keys are mostly useful in conjunction with caching.      \sa QPixmap::cacheKey() */
end_comment
begin_function
DECL|function|cacheKey
name|qint64
name|QIcon
operator|::
name|cacheKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
operator|(
name|qint64
operator|)
name|d
operator|->
name|serialNum
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|qint64
call|)
argument_list|(
name|d
operator|->
name|detach_no
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a pixmap with the requested \a size, \a mode, and \a   state, generating one if necessary. The pixmap might be smaller than   requested, but never larger.    Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this   function to return pixmaps that are larger than the requested size. Such   images will have a devicePixelRatio larger than 1.    \sa actualSize(), paint() */
end_comment
begin_function
DECL|function|pixmap
name|QPixmap
name|QIcon
operator|::
name|pixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QPixmap
argument_list|()
return|;
return|return
name|pixmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QIcon::pixmap(int w, int h, Mode mode = Normal, State state = Off) const      \overload      Returns a pixmap of size QSize(\a w, \a h). The pixmap might be smaller than     requested, but never larger.      Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this     function to return pixmaps that are larger than the requested size. Such     images will have a devicePixelRatio larger than 1. */
end_comment
begin_comment
comment|/*!     \fn QPixmap QIcon::pixmap(int extent, Mode mode = Normal, State state = Off) const      \overload      Returns a pixmap of size QSize(\a extent, \a extent). The pixmap might be smaller     than requested, but never larger.      Setting the Qt::AA_UseHighDpiPixmaps application attribute enables this     function to return pixmaps that are larger than the requested size. Such     images will have a devicePixelRatio larger than 1. */
end_comment
begin_comment
comment|/*!  Returns the actual size of the icon for the requested \a size, \a   mode, and \a state. The result might be smaller than requested, but   never larger. The returned size is in device-independent pixels (This   is relevant for high-dpi pixmaps.)    \sa pixmap(), paint() */
end_comment
begin_function
DECL|function|actualSize
name|QSize
name|QIcon
operator|::
name|actualSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QSize
argument_list|()
return|;
return|return
name|actualSize
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.1    Returns a pixmap with the requested \a window \a size, \a mode, and \a   state, generating one if necessary.    The pixmap can be smaller than the requested size. If \a window is on   a high-dpi display the pixmap can be larger. In that case it will have   a devicePixelRatio larger than 1.    \sa  actualSize(), paint() */
end_comment
begin_function
DECL|function|pixmap
name|QPixmap
name|QIcon
operator|::
name|pixmap
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|qreal
name|devicePixelRatio
init|=
name|qt_effective_device_pixel_ratio
argument_list|(
name|window
argument_list|)
decl_stmt|;
comment|// Handle the simple normal-dpi case:
if|if
condition|(
operator|!
operator|(
name|devicePixelRatio
operator|>
literal|1.0
operator|)
condition|)
return|return
name|d
operator|->
name|engine
operator|->
name|pixmap
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
return|;
comment|// Try get a pixmap that is big enough to be displayed at device pixel resolution.
name|QPixmap
name|pixmap
init|=
name|d
operator|->
name|engine
operator|->
name|pixmap
argument_list|(
name|size
operator|*
name|devicePixelRatio
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|pixmap
operator|.
name|setDevicePixelRatio
argument_list|(
name|d
operator|->
name|pixmapDevicePixelRatio
argument_list|(
name|devicePixelRatio
argument_list|,
name|size
argument_list|,
name|pixmap
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.1    Returns the actual size of the icon for the requested \a window  \a size, \a   mode, and \a state.    The pixmap can be smaller than the requested size. The returned size   is in device-independent pixels (This is relevant for high-dpi pixmaps.)    \sa actualSize(), pixmap(), paint() */
end_comment
begin_function
DECL|function|actualSize
name|QSize
name|QIcon
operator|::
name|actualSize
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QSize
argument_list|()
return|;
name|qreal
name|devicePixelRatio
init|=
name|qt_effective_device_pixel_ratio
argument_list|(
name|window
argument_list|)
decl_stmt|;
comment|// Handle the simple normal-dpi case:
if|if
condition|(
operator|!
operator|(
name|devicePixelRatio
operator|>
literal|1.0
operator|)
condition|)
return|return
name|d
operator|->
name|engine
operator|->
name|actualSize
argument_list|(
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
return|;
name|QSize
name|actualSize
init|=
name|d
operator|->
name|engine
operator|->
name|actualSize
argument_list|(
name|size
operator|*
name|devicePixelRatio
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
return|return
name|actualSize
operator|/
name|d
operator|->
name|pixmapDevicePixelRatio
argument_list|(
name|devicePixelRatio
argument_list|,
name|size
argument_list|,
name|actualSize
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Uses the \a painter to paint the icon with specified \a alignment,     required \a mode, and \a state into the rectangle \a rect.      \sa actualSize(), pixmap() */
end_comment
begin_function
DECL|function|paint
name|void
name|QIcon
operator|::
name|paint
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|Alignment
name|alignment
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|painter
condition|)
return|return;
comment|// Copy of QStyle::alignedRect
specifier|const
name|QSize
name|size
init|=
name|d
operator|->
name|engine
operator|->
name|actualSize
argument_list|(
name|rect
operator|.
name|size
argument_list|()
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|alignment
operator|=
name|QGuiApplicationPrivate
operator|::
name|visualAlignment
argument_list|(
name|painter
operator|->
name|layoutDirection
argument_list|()
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|int
name|x
init|=
name|rect
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|rect
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignVCenter
operator|)
operator|==
name|Qt
operator|::
name|AlignVCenter
condition|)
name|y
operator|+=
name|rect
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
operator|/
literal|2
operator|-
name|h
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignBottom
operator|)
operator|==
name|Qt
operator|::
name|AlignBottom
condition|)
name|y
operator|+=
name|rect
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
operator|-
name|h
expr_stmt|;
if|if
condition|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignRight
operator|)
operator|==
name|Qt
operator|::
name|AlignRight
condition|)
name|x
operator|+=
name|rect
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
operator|-
name|w
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|alignment
operator|&
name|Qt
operator|::
name|AlignHCenter
operator|)
operator|==
name|Qt
operator|::
name|AlignHCenter
condition|)
name|x
operator|+=
name|rect
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
operator|/
literal|2
operator|-
name|w
operator|/
literal|2
expr_stmt|;
name|QRect
name|alignedRect
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|d
operator|->
name|engine
operator|->
name|paint
argument_list|(
name|painter
argument_list|,
name|alignedRect
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QIcon::paint(QPainter *painter, int x, int y, int w, int h, Qt::Alignment alignment,                           Mode mode, State state) const      \overload      Paints the icon into the rectangle QRect(\a x, \a y, \a w, \a h). */
end_comment
begin_comment
comment|/*!     Returns \c true if the icon is empty; otherwise returns \c false.      An icon is empty if it has neither a pixmap nor a filename.      Note: Even a non-null icon might not be able to create valid     pixmaps, eg. if the file does not exist or cannot be read. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QIcon
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
return|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QIcon
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QIcon
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QIconPrivate
modifier|*
name|x
init|=
operator|new
name|QIconPrivate
decl_stmt|;
name|x
operator|->
name|engine
operator|=
name|d
operator|->
name|engine
operator|->
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|detach_no
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Adds \a pixmap to the icon, as a specialization for \a mode and     \a state.      Custom icon engines are free to ignore additionally added     pixmaps.      \sa addFile() */
end_comment
begin_function
DECL|function|addPixmap
name|void
name|QIcon
operator|::
name|addPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
name|pixmap
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|d
operator|->
name|engine
operator|=
operator|new
name|QPixmapIconEngine
expr_stmt|;
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|addPixmap
argument_list|(
name|pixmap
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Adds an image from the file with the given \a fileName to the      icon, as a specialization for \a size, \a mode and \a state. The      file will be loaded on demand. Note: custom icon engines are free      to ignore additionally added pixmaps.       If \a fileName contains a relative path (e.g. the filename only)      the relevant file must be found relative to the runtime working      directory.      The file name can be either refer to an actual file on disk or to     one of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      Use the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions to retrieve a     complete list of the supported file formats.      Note: When you add a non-empty filename to a QIcon, the icon becomes     non-null, even if the file doesn't exist or points to a corrupt file.      \sa addPixmap()  */
end_comment
begin_function
DECL|function|addFile
name|void
name|QIcon
operator|::
name|addFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|d
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|QFileInfo
name|info
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QString
name|suffix
init|=
name|info
operator|.
name|suffix
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|suffix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// first try version 2 engines..
specifier|const
name|int
name|index
init|=
name|loader
argument_list|()
operator|->
name|indexOf
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QIconEnginePlugin
modifier|*
name|factory
init|=
name|qobject_cast
argument_list|<
name|QIconEnginePlugin
operator|*
argument_list|>
argument_list|(
name|loader
argument_list|()
operator|->
name|instance
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|QIconEngine
modifier|*
name|engine
init|=
name|factory
operator|->
name|create
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|d
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|// ...then fall back to the default engine
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|d
operator|->
name|engine
operator|=
operator|new
name|QPixmapIconEngine
expr_stmt|;
block|}
block|}
else|else
block|{
name|detach
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|engine
operator|->
name|addFile
argument_list|(
name|fileName
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|// Check if a "@2x" file exists and add it.
specifier|static
name|bool
name|disable2xImageLoading
init|=
operator|!
name|qgetenv
argument_list|(
literal|"QT_HIGHDPI_DISABLE_2X_IMAGE_LOADING"
argument_list|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|disable2xImageLoading
operator|&&
name|qApp
operator|->
name|devicePixelRatio
argument_list|()
operator|>
literal|1.0
condition|)
block|{
name|int
name|dotIndex
init|=
name|fileName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|at2xfileName
init|=
name|fileName
decl_stmt|;
name|at2xfileName
operator|.
name|insert
argument_list|(
name|dotIndex
argument_list|,
name|QStringLiteral
argument_list|(
literal|"@2x"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|at2xfileName
argument_list|)
condition|)
name|d
operator|->
name|engine
operator|->
name|addFile
argument_list|(
name|at2xfileName
argument_list|,
name|size
argument_list|,
name|mode
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns a list of available icon sizes for the specified \a mode and     \a state. */
end_comment
begin_function
DECL|function|availableSizes
name|QList
argument_list|<
name|QSize
argument_list|>
name|QIcon
operator|::
name|availableSizes
parameter_list|(
name|Mode
name|mode
parameter_list|,
name|State
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|engine
condition|)
return|return
name|QList
argument_list|<
name|QSize
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|engine
operator|->
name|availableSizes
argument_list|(
name|mode
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the name used to create the icon, if available.      Depending on the way the icon was created, it may have an associated     name. This is the case for icons created with fromTheme() or icons     using a QIconEngine which supports the QIconEngineV2::IconNameHook.      \sa fromTheme(), QIconEngine */
end_comment
begin_function
DECL|function|name
name|QString
name|QIcon
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|engine
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|engine
operator|->
name|iconName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the search paths for icon themes to \a paths.     \sa themeSearchPaths(), fromTheme(), setThemeName() */
end_comment
begin_function
DECL|function|setThemeSearchPaths
name|void
name|QIcon
operator|::
name|setThemeSearchPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|)
block|{
name|QIconLoader
operator|::
name|instance
argument_list|()
operator|->
name|setThemeSearchPath
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Returns the search paths for icon themes.    The default value will depend on the platform:    On X11, the search path will use the XDG_DATA_DIRS environment   variable if available.    By default all platforms will have the resource directory   \c{:\icons} as a fallback. You can use "rcc -project" to generate a   resource file from your icon theme.    \sa setThemeSearchPaths(), fromTheme(), setThemeName() */
end_comment
begin_function
DECL|function|themeSearchPaths
name|QStringList
name|QIcon
operator|::
name|themeSearchPaths
parameter_list|()
block|{
return|return
name|QIconLoader
operator|::
name|instance
argument_list|()
operator|->
name|themeSearchPaths
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the current icon theme to \a name.      The \a name should correspond to a directory name in the     themeSearchPath() containing an index.theme     file describing it's contents.      \sa themeSearchPaths(), themeName() */
end_comment
begin_function
DECL|function|setThemeName
name|void
name|QIcon
operator|::
name|setThemeName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QIconLoader
operator|::
name|instance
argument_list|()
operator|->
name|setThemeName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the name of the current icon theme.      On X11, the current icon theme depends on your desktop     settings. On other platforms it is not set by default.      \sa setThemeName(), themeSearchPaths(), fromTheme(),     hasThemeIcon() */
end_comment
begin_function
DECL|function|themeName
name|QString
name|QIcon
operator|::
name|themeName
parameter_list|()
block|{
return|return
name|QIconLoader
operator|::
name|instance
argument_list|()
operator|->
name|themeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the QIcon corresponding to \a name in the current     icon theme. If no such icon is found in the current theme     \a fallback is returned instead.      The latest version of the freedesktop icon specification and naming     specification can be obtained here:      \list     \li \l{http://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html}     \li \l{http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html}     \endlist      To fetch an icon from the current icon theme:      \snippet code/src_gui_image_qicon.cpp 3      Or if you want to provide a guaranteed fallback for platforms that     do not support theme icons, you can use the second argument:      \snippet code/src_gui_image_qicon.cpp 4      \note By default, only X11 will support themed icons. In order to     use themed icons on Mac and Windows, you will have to bundle a     compliant theme in one of your themeSearchPaths() and set the     appropriate themeName().      \sa themeName(), setThemeName(), themeSearchPaths() */
end_comment
begin_function
DECL|function|fromTheme
name|QIcon
name|QIcon
operator|::
name|fromTheme
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QIcon
modifier|&
name|fallback
parameter_list|)
block|{
name|QIcon
name|icon
decl_stmt|;
if|if
condition|(
name|qtIconCache
argument_list|()
operator|->
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|icon
operator|=
operator|*
name|qtIconCache
argument_list|()
operator|->
name|object
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPlatformTheme
modifier|*
specifier|const
name|platformTheme
init|=
name|QGuiApplicationPrivate
operator|::
name|platformTheme
argument_list|()
decl_stmt|;
name|QIconEngine
modifier|*
specifier|const
name|engine
init|=
name|platformTheme
condition|?
name|platformTheme
operator|->
name|createIconEngine
argument_list|(
name|name
argument_list|)
else|:
operator|new
name|QIconLoaderEngine
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|QIcon
modifier|*
name|cachedIcon
init|=
operator|new
name|QIcon
argument_list|(
name|engine
argument_list|)
decl_stmt|;
name|qtIconCache
argument_list|()
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cachedIcon
argument_list|)
expr_stmt|;
name|icon
operator|=
operator|*
name|cachedIcon
expr_stmt|;
block|}
comment|// Note the qapp check is to allow lazy loading of static icons
comment|// Supporting fallbacks will not work for this case.
if|if
condition|(
name|qApp
operator|&&
name|icon
operator|.
name|availableSizes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|fallback
return|;
return|return
name|icon
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns \c true if there is an icon available for \a name in the     current icon theme, otherwise returns \c false.      \sa themeSearchPaths(), fromTheme(), setThemeName() */
end_comment
begin_function
DECL|function|hasThemeIcon
name|bool
name|QIcon
operator|::
name|hasThemeIcon
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QIcon
name|icon
init|=
name|fromTheme
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
operator|!
name|icon
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QIcon stream functions  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
end_if
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QIcon&icon)     \relates QIcon     \since 4.2      Writes the given \a icon to the given \a stream as a PNG     image. If the icon contains more than one image, all images will     be written to the stream. Note that writing the stream to a file     will not produce a valid image file. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
block|{
if|if
condition|(
name|icon
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
name|QString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|s
operator|<<
name|icon
operator|.
name|d
operator|->
name|engine
operator|->
name|key
argument_list|()
expr_stmt|;
name|icon
operator|.
name|d
operator|->
name|engine
operator|->
name|write
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_4_2
condition|)
block|{
if|if
condition|(
name|icon
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
literal|0
expr_stmt|;
block|}
else|else
block|{
name|QPixmapIconEngine
modifier|*
name|engine
init|=
cast|static_cast
argument_list|<
name|QPixmapIconEngine
operator|*
argument_list|>
argument_list|(
name|icon
operator|.
name|d
operator|->
name|engine
argument_list|)
decl_stmt|;
name|int
name|num_entries
init|=
name|engine
operator|->
name|pixmaps
operator|.
name|size
argument_list|()
decl_stmt|;
name|s
operator|<<
name|num_entries
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|<<
name|engine
operator|->
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|pixmap
expr_stmt|;
name|s
operator|<<
name|engine
operator|->
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|fileName
expr_stmt|;
name|s
operator|<<
name|engine
operator|->
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|size
expr_stmt|;
name|s
operator|<<
operator|(
name|uint
operator|)
name|engine
operator|->
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mode
expr_stmt|;
name|s
operator|<<
operator|(
name|uint
operator|)
name|engine
operator|->
name|pixmaps
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|state
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|s
operator|<<
name|QPixmap
argument_list|(
name|icon
operator|.
name|pixmap
argument_list|(
literal|22
argument_list|,
literal|22
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QIcon&icon)     \relates QIcon     \since 4.2      Reads an image, or a set of images, from the given \a stream into     the given \a icon. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QIcon
modifier|&
name|icon
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_3
condition|)
block|{
name|icon
operator|=
name|QIcon
argument_list|()
expr_stmt|;
name|QString
name|key
decl_stmt|;
name|s
operator|>>
name|key
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"QPixmapIconEngine"
argument_list|)
condition|)
block|{
name|icon
operator|.
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|QIconEngine
modifier|*
name|engine
init|=
operator|new
name|QPixmapIconEngine
decl_stmt|;
name|icon
operator|.
name|d
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
name|engine
operator|->
name|read
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"QIconLoaderEngine"
argument_list|)
condition|)
block|{
name|icon
operator|.
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|QIconEngine
modifier|*
name|engine
init|=
operator|new
name|QIconLoaderEngine
argument_list|()
decl_stmt|;
name|icon
operator|.
name|d
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
name|engine
operator|->
name|read
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
block|}
else|else
block|{
specifier|const
name|int
name|index
init|=
name|loader
argument_list|()
operator|->
name|indexOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|QIconEnginePlugin
modifier|*
name|factory
init|=
name|qobject_cast
argument_list|<
name|QIconEnginePlugin
operator|*
argument_list|>
argument_list|(
name|loader
argument_list|()
operator|->
name|instance
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|QIconEngine
modifier|*
name|engine
init|=
name|factory
operator|->
name|create
argument_list|()
condition|)
block|{
name|icon
operator|.
name|d
operator|=
operator|new
name|QIconPrivate
expr_stmt|;
name|icon
operator|.
name|d
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
name|engine
operator|->
name|read
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// factory
block|}
comment|// instance
block|}
comment|// index
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_4_2
condition|)
block|{
name|icon
operator|=
name|QIcon
argument_list|()
expr_stmt|;
name|int
name|num_entries
decl_stmt|;
name|QPixmap
name|pm
decl_stmt|;
name|QString
name|fileName
decl_stmt|;
name|QSize
name|sz
decl_stmt|;
name|uint
name|mode
decl_stmt|;
name|uint
name|state
decl_stmt|;
name|s
operator|>>
name|num_entries
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|>>
name|pm
expr_stmt|;
name|s
operator|>>
name|fileName
expr_stmt|;
name|s
operator|>>
name|sz
expr_stmt|;
name|s
operator|>>
name|mode
expr_stmt|;
name|s
operator|>>
name|state
expr_stmt|;
if|if
condition|(
name|pm
operator|.
name|isNull
argument_list|()
condition|)
name|icon
operator|.
name|addFile
argument_list|(
name|fileName
argument_list|,
name|sz
argument_list|,
name|QIcon
operator|::
name|Mode
argument_list|(
name|mode
argument_list|)
argument_list|,
name|QIcon
operator|::
name|State
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|icon
operator|.
name|addPixmap
argument_list|(
name|pm
argument_list|,
name|QIcon
operator|::
name|Mode
argument_list|(
name|mode
argument_list|)
argument_list|,
name|QIcon
operator|::
name|State
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPixmap
name|pm
decl_stmt|;
name|s
operator|>>
name|pm
expr_stmt|;
name|icon
operator|.
name|addPixmap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QIcon
modifier|&
name|i
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QIcon("
operator|<<
name|i
operator|.
name|name
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn DataPtr&QIcon::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     \typedef QIcon::DataPtr     \internal */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_ICON
end_comment
end_unit
