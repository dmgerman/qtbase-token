begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtiffhandler_p.h"
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qimage.h>
end_include
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|"tiffio.h"
block|}
end_extern
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qtiffReadProc
name|tsize_t
name|qtiffReadProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
name|QIODevice
modifier|*
name|device
init|=
cast|static_cast
argument_list|<
name|QTiffHandler
operator|*
argument_list|>
argument_list|(
name|fd
argument_list|)
operator|->
name|device
argument_list|()
decl_stmt|;
return|return
name|device
operator|->
name|isReadable
argument_list|()
condition|?
name|device
operator|->
name|read
argument_list|(
cast|static_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
argument_list|,
name|size
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|qtiffWriteProc
name|tsize_t
name|qtiffWriteProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|,
name|tdata_t
name|buf
parameter_list|,
name|tsize_t
name|size
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|QTiffHandler
operator|*
argument_list|>
argument_list|(
name|fd
argument_list|)
operator|->
name|device
argument_list|()
operator|->
name|write
argument_list|(
cast|static_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|buf
argument_list|)
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qtiffSeekProc
name|toff_t
name|qtiffSeekProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|,
name|toff_t
name|off
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|QIODevice
modifier|*
name|device
init|=
cast|static_cast
argument_list|<
name|QTiffHandler
operator|*
argument_list|>
argument_list|(
name|fd
argument_list|)
operator|->
name|device
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|device
operator|->
name|seek
argument_list|(
name|off
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|device
operator|->
name|seek
argument_list|(
name|device
operator|->
name|pos
argument_list|()
operator|+
name|off
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|device
operator|->
name|seek
argument_list|(
name|device
operator|->
name|size
argument_list|()
operator|+
name|off
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|device
operator|->
name|pos
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qtiffCloseProc
name|int
name|qtiffCloseProc
parameter_list|(
name|thandle_t
comment|/*fd*/
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qtiffSizeProc
name|toff_t
name|qtiffSizeProc
parameter_list|(
name|thandle_t
name|fd
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|QTiffHandler
operator|*
argument_list|>
argument_list|(
name|fd
argument_list|)
operator|->
name|device
argument_list|()
operator|->
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qtiffMapProc
name|int
name|qtiffMapProc
parameter_list|(
name|thandle_t
comment|/*fd*/
parameter_list|,
name|tdata_t
modifier|*
comment|/*pbase*/
parameter_list|,
name|toff_t
modifier|*
comment|/*psize*/
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|qtiffUnmapProc
name|void
name|qtiffUnmapProc
parameter_list|(
name|thandle_t
comment|/*fd*/
parameter_list|,
name|tdata_t
comment|/*base*/
parameter_list|,
name|toff_t
comment|/*size*/
parameter_list|)
block|{ }
end_function
begin_comment
comment|// for 32 bits images
end_comment
begin_function
DECL|function|rotate_right_mirror_horizontal
specifier|inline
name|void
name|rotate_right_mirror_horizontal
parameter_list|(
name|QImage
modifier|*
specifier|const
name|image
parameter_list|)
comment|// rotate right->mirrored horizontal
block|{
specifier|const
name|int
name|height
init|=
name|image
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|image
operator|->
name|width
argument_list|()
decl_stmt|;
name|QImage
name|generated
argument_list|(
comment|/* width = */
name|height
argument_list|,
comment|/* height = */
name|width
argument_list|,
name|image
operator|->
name|format
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|uint32
modifier|*
name|originalPixel
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint32
operator|*
argument_list|>
argument_list|(
name|image
operator|->
name|bits
argument_list|()
argument_list|)
decl_stmt|;
name|uint32
modifier|*
specifier|const
name|generatedPixels
init|=
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|generated
operator|.
name|bits
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
operator|++
name|col
control|)
block|{
name|int
name|idx
init|=
name|col
operator|*
name|height
operator|+
name|row
decl_stmt|;
name|generatedPixels
index|[
name|idx
index|]
operator|=
operator|*
name|originalPixel
expr_stmt|;
operator|++
name|originalPixel
expr_stmt|;
block|}
block|}
operator|*
name|image
operator|=
name|generated
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rotate_right_mirror_vertical
specifier|inline
name|void
name|rotate_right_mirror_vertical
parameter_list|(
name|QImage
modifier|*
specifier|const
name|image
parameter_list|)
comment|// rotate right->mirrored vertical
block|{
specifier|const
name|int
name|height
init|=
name|image
operator|->
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|image
operator|->
name|width
argument_list|()
decl_stmt|;
name|QImage
name|generated
argument_list|(
comment|/* width = */
name|height
argument_list|,
comment|/* height = */
name|width
argument_list|,
name|image
operator|->
name|format
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|lastCol
init|=
name|width
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|lastRow
init|=
name|height
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint32
modifier|*
name|pixel
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint32
operator|*
argument_list|>
argument_list|(
name|image
operator|->
name|bits
argument_list|()
argument_list|)
decl_stmt|;
name|uint32
modifier|*
specifier|const
name|generatedBits
init|=
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|generated
operator|.
name|bits
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|height
condition|;
operator|++
name|row
control|)
block|{
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|width
condition|;
operator|++
name|col
control|)
block|{
name|int
name|idx
init|=
operator|(
name|lastCol
operator|-
name|col
operator|)
operator|*
name|height
operator|+
operator|(
name|lastRow
operator|-
name|row
operator|)
decl_stmt|;
name|generatedBits
index|[
name|idx
index|]
operator|=
operator|*
name|pixel
expr_stmt|;
operator|++
name|pixel
expr_stmt|;
block|}
block|}
operator|*
name|image
operator|=
name|generated
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QTiffHandler
name|QTiffHandler
operator|::
name|QTiffHandler
parameter_list|()
member_init_list|:
name|QImageIOHandler
argument_list|()
block|{
name|compression
operator|=
name|NoCompression
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|canRead
name|bool
name|QTiffHandler
operator|::
name|canRead
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|canRead
argument_list|(
name|device
argument_list|()
argument_list|)
condition|)
block|{
name|setFormat
argument_list|(
literal|"tiff"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canRead
name|bool
name|QTiffHandler
operator|::
name|canRead
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTiffHandler::canRead() called with no device"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// current implementation uses TIFFClientOpen which needs to be
comment|// able to seek, so sequential devices are not supported
name|QByteArray
name|header
init|=
name|device
operator|->
name|peek
argument_list|(
literal|4
argument_list|)
decl_stmt|;
return|return
name|header
operator|==
name|QByteArray
operator|::
name|fromRawData
argument_list|(
literal|"\x49\x49\x2A\x00"
argument_list|,
literal|4
argument_list|)
operator|||
name|header
operator|==
name|QByteArray
operator|::
name|fromRawData
argument_list|(
literal|"\x4D\x4D\x00\x2A"
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read
name|bool
name|QTiffHandler
operator|::
name|read
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|canRead
argument_list|()
condition|)
return|return
literal|false
return|;
name|TIFF
modifier|*
specifier|const
name|tiff
init|=
name|TIFFClientOpen
argument_list|(
literal|"foo"
argument_list|,
literal|"r"
argument_list|,
name|this
argument_list|,
name|qtiffReadProc
argument_list|,
name|qtiffWriteProc
argument_list|,
name|qtiffSeekProc
argument_list|,
name|qtiffCloseProc
argument_list|,
name|qtiffSizeProc
argument_list|,
name|qtiffMapProc
argument_list|,
name|qtiffUnmapProc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tiff
condition|)
block|{
return|return
literal|false
return|;
block|}
name|uint32
name|width
decl_stmt|;
name|uint32
name|height
decl_stmt|;
name|uint16
name|photometric
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGEWIDTH
argument_list|,
operator|&
name|width
argument_list|)
operator|||
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGELENGTH
argument_list|,
operator|&
name|height
argument_list|)
operator|||
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
operator|&
name|photometric
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// BitsPerSample defaults to 1 according to the TIFF spec.
name|uint16
name|bitPerSample
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
operator|&
name|bitPerSample
argument_list|)
condition|)
name|bitPerSample
operator|=
literal|1
expr_stmt|;
name|uint16
name|samplesPerPixel
decl_stmt|;
comment|// they may be e.g. grayscale with 2 samples per pixel
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
operator|&
name|samplesPerPixel
argument_list|)
condition|)
name|samplesPerPixel
operator|=
literal|1
expr_stmt|;
name|bool
name|grayscale
init|=
name|photometric
operator|==
name|PHOTOMETRIC_MINISBLACK
operator|||
name|photometric
operator|==
name|PHOTOMETRIC_MINISWHITE
decl_stmt|;
if|if
condition|(
name|grayscale
operator|&&
name|bitPerSample
operator|==
literal|1
operator|&&
name|samplesPerPixel
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|image
operator|->
name|size
argument_list|()
operator|!=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|||
name|image
operator|->
name|format
argument_list|()
operator|!=
name|QImage
operator|::
name|Format_Mono
condition|)
operator|*
name|image
operator|=
name|QImage
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|QImage
operator|::
name|Format_Mono
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colortable
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|photometric
operator|==
name|PHOTOMETRIC_MINISBLACK
condition|)
block|{
name|colortable
index|[
literal|0
index|]
operator|=
literal|0xff000000
expr_stmt|;
name|colortable
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|colortable
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|colortable
index|[
literal|1
index|]
operator|=
literal|0xff000000
expr_stmt|;
block|}
name|image
operator|->
name|setColorTable
argument_list|(
name|colortable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|->
name|isNull
argument_list|()
condition|)
block|{
for|for
control|(
name|uint32
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|TIFFReadScanline
argument_list|(
name|tiff
argument_list|,
name|image
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|grayscale
operator|||
name|photometric
operator|==
name|PHOTOMETRIC_PALETTE
operator|)
operator|&&
name|bitPerSample
operator|==
literal|8
operator|&&
name|samplesPerPixel
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|image
operator|->
name|size
argument_list|()
operator|!=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|||
name|image
operator|->
name|format
argument_list|()
operator|!=
name|QImage
operator|::
name|Format_Indexed8
condition|)
operator|*
name|image
operator|=
name|QImage
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|->
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|uint16
name|tableSize
init|=
literal|256
decl_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|qtColorTable
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|grayscale
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|c
init|=
operator|(
name|photometric
operator|==
name|PHOTOMETRIC_MINISBLACK
operator|)
condition|?
name|i
else|:
operator|(
literal|255
operator|-
name|i
operator|)
decl_stmt|;
name|qtColorTable
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|c
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// create the color table
name|uint16
modifier|*
name|redTable
init|=
literal|0
decl_stmt|;
name|uint16
modifier|*
name|greenTable
init|=
literal|0
decl_stmt|;
name|uint16
modifier|*
name|blueTable
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COLORMAP
argument_list|,
operator|&
name|redTable
argument_list|,
operator|&
name|greenTable
argument_list|,
operator|&
name|blueTable
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|redTable
operator|||
operator|!
name|greenTable
operator|||
operator|!
name|blueTable
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|red
init|=
name|redTable
index|[
name|i
index|]
operator|/
literal|257
decl_stmt|;
specifier|const
name|int
name|green
init|=
name|greenTable
index|[
name|i
index|]
operator|/
literal|257
decl_stmt|;
specifier|const
name|int
name|blue
init|=
name|blueTable
index|[
name|i
index|]
operator|/
literal|257
decl_stmt|;
name|qtColorTable
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
expr_stmt|;
block|}
block|}
name|image
operator|->
name|setColorTable
argument_list|(
name|qtColorTable
argument_list|)
expr_stmt|;
for|for
control|(
name|uint32
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|TIFFReadScanline
argument_list|(
name|tiff
argument_list|,
name|image
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// free redTable, greenTable and greenTable done by libtiff
block|}
block|}
else|else
block|{
if|if
condition|(
name|image
operator|->
name|size
argument_list|()
operator|!=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
operator|||
name|image
operator|->
name|format
argument_list|()
operator|!=
name|QImage
operator|::
name|Format_ARGB32
condition|)
operator|*
name|image
operator|=
name|QImage
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|->
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|int
name|stopOnError
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|TIFFReadRGBAImageOriented
argument_list|(
name|tiff
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|image
operator|->
name|bits
argument_list|()
argument_list|)
argument_list|,
name|ORIENTATION_TOPLEFT
argument_list|,
name|stopOnError
argument_list|)
condition|)
block|{
for|for
control|(
name|uint32
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
name|convert32BitOrder
argument_list|(
name|image
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|image
operator|->
name|isNull
argument_list|()
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|float
name|resX
init|=
literal|0
decl_stmt|;
name|float
name|resY
init|=
literal|0
decl_stmt|;
name|uint16
name|resUnit
init|=
name|RESUNIT_NONE
decl_stmt|;
if|if
condition|(
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_RESOLUTIONUNIT
argument_list|,
operator|&
name|resUnit
argument_list|)
operator|&&
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_XRESOLUTION
argument_list|,
operator|&
name|resX
argument_list|)
operator|&&
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_YRESOLUTION
argument_list|,
operator|&
name|resY
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|resUnit
condition|)
block|{
case|case
name|RESUNIT_CENTIMETER
case|:
name|image
operator|->
name|setDotsPerMeterX
argument_list|(
name|qRound
argument_list|(
name|resX
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|setDotsPerMeterY
argument_list|(
name|qRound
argument_list|(
name|resY
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUNIT_INCH
case|:
name|image
operator|->
name|setDotsPerMeterX
argument_list|(
name|qRound
argument_list|(
name|resX
operator|*
operator|(
literal|100
operator|/
literal|2.54
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|setDotsPerMeterY
argument_list|(
name|qRound
argument_list|(
name|resY
operator|*
operator|(
literal|100
operator|/
literal|2.54
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// do nothing as defaults have already
comment|// been set within the QImage class
break|break;
block|}
block|}
comment|// rotate the image if the orientation is defined in the file
name|uint16
name|orientationTag
decl_stmt|;
if|if
condition|(
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_ORIENTATION
argument_list|,
operator|&
name|orientationTag
argument_list|)
condition|)
block|{
if|if
condition|(
name|image
operator|->
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_ARGB32
condition|)
block|{
comment|// TIFFReadRGBAImageOriented() flip the image but does not rotate them
switch|switch
condition|(
name|orientationTag
condition|)
block|{
case|case
literal|5
case|:
name|rotate_right_mirror_horizontal
argument_list|(
name|image
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|rotate_right_mirror_vertical
argument_list|(
name|image
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|rotate_right_mirror_horizontal
argument_list|(
name|image
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|rotate_right_mirror_vertical
argument_list|(
name|image
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|orientationTag
condition|)
block|{
case|case
literal|1
case|:
comment|// default orientation
break|break;
case|case
literal|2
case|:
comment|// mirror horizontal
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// mirror both
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|// mirror vertical
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|// rotate right mirror horizontal
block|{
name|QMatrix
name|transformation
decl_stmt|;
name|transformation
operator|.
name|rotate
argument_list|(
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|6
case|:
comment|// rotate right
block|{
name|QMatrix
name|transformation
decl_stmt|;
name|transformation
operator|.
name|rotate
argument_list|(
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|7
case|:
comment|// rotate right, mirror vertical
block|{
name|QMatrix
name|transformation
decl_stmt|;
name|transformation
operator|.
name|rotate
argument_list|(
literal|90
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|mirrored
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|8
case|:
comment|// rotate left
block|{
name|QMatrix
name|transformation
decl_stmt|;
name|transformation
operator|.
name|rotate
argument_list|(
literal|270
argument_list|)
expr_stmt|;
operator|*
name|image
operator|=
name|image
operator|->
name|transformed
argument_list|(
name|transformation
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|checkGrayscale
specifier|static
name|bool
name|checkGrayscale
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|colorTable
parameter_list|)
block|{
if|if
condition|(
name|colorTable
operator|.
name|size
argument_list|()
operator|!=
literal|256
condition|)
return|return
literal|false
return|;
specifier|const
name|bool
name|increasing
init|=
operator|(
name|colorTable
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|0xff000000
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|increasing
operator|&&
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|increasing
operator|&&
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|qRgb
argument_list|(
literal|255
operator|-
name|i
argument_list|,
literal|255
operator|-
name|i
argument_list|,
literal|255
operator|-
name|i
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|write
name|bool
name|QTiffHandler
operator|::
name|write
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
argument_list|()
operator|->
name|isWritable
argument_list|()
condition|)
return|return
literal|false
return|;
name|TIFF
modifier|*
specifier|const
name|tiff
init|=
name|TIFFClientOpen
argument_list|(
literal|"foo"
argument_list|,
literal|"w"
argument_list|,
name|this
argument_list|,
name|qtiffReadProc
argument_list|,
name|qtiffWriteProc
argument_list|,
name|qtiffSeekProc
argument_list|,
name|qtiffCloseProc
argument_list|,
name|qtiffSizeProc
argument_list|,
name|qtiffMapProc
argument_list|,
name|qtiffUnmapProc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tiff
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|width
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGEWIDTH
argument_list|,
name|width
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGELENGTH
argument_list|,
name|height
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PLANARCONFIG
argument_list|,
name|PLANARCONFIG_CONTIG
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// set the resolution
name|bool
name|resolutionSet
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|dotPerMeterX
init|=
name|image
operator|.
name|dotsPerMeterX
argument_list|()
decl_stmt|;
specifier|const
name|int
name|dotPerMeterY
init|=
name|image
operator|.
name|dotsPerMeterY
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|dotPerMeterX
operator|%
literal|100
operator|)
operator|==
literal|0
operator|&&
operator|(
name|dotPerMeterY
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
name|resolutionSet
operator|=
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_RESOLUTIONUNIT
argument_list|,
name|RESUNIT_CENTIMETER
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_XRESOLUTION
argument_list|,
name|dotPerMeterX
operator|/
literal|100.0
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_YRESOLUTION
argument_list|,
name|dotPerMeterY
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resolutionSet
operator|=
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_RESOLUTIONUNIT
argument_list|,
name|RESUNIT_INCH
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_XRESOLUTION
argument_list|,
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|image
operator|.
name|logicalDpiX
argument_list|()
argument_list|)
argument_list|)
operator|&&
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_YRESOLUTION
argument_list|,
cast|static_cast
argument_list|<
name|float
argument_list|>
argument_list|(
name|image
operator|.
name|logicalDpiY
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resolutionSet
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// configure image depth
specifier|const
name|QImage
operator|::
name|Format
name|format
init|=
name|image
operator|.
name|format
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
name|uint16
name|photometric
init|=
name|PHOTOMETRIC_MINISBLACK
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|colorTable
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|photometric
operator|=
name|PHOTOMETRIC_MINISWHITE
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
name|photometric
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|compression
operator|==
name|NoCompression
condition|?
name|COMPRESSION_NONE
else|:
name|COMPRESSION_CCITTRLE
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// try to do the conversion in chunks no greater than 16 MB
name|int
name|chunks
init|=
operator|(
name|width
operator|*
name|height
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|16
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|chunkHeight
init|=
name|qMax
argument_list|(
name|height
operator|/
name|chunks
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|height
condition|)
block|{
name|QImage
name|chunk
init|=
name|image
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|qMin
argument_list|(
name|chunkHeight
argument_list|,
name|height
operator|-
name|y
argument_list|)
argument_list|)
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_Mono
argument_list|)
decl_stmt|;
name|int
name|chunkStart
init|=
name|y
decl_stmt|;
name|int
name|chunkEnd
init|=
name|y
operator|+
name|chunk
operator|.
name|height
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|chunkEnd
condition|)
block|{
if|if
condition|(
name|TIFFWriteScanline
argument_list|(
name|tiff
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|chunk
operator|.
name|scanLine
argument_list|(
name|y
operator|-
name|chunkStart
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
name|y
expr_stmt|;
block|}
block|}
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colorTable
init|=
name|image
operator|.
name|colorTable
argument_list|()
decl_stmt|;
name|bool
name|isGrayscale
init|=
name|checkGrayscale
argument_list|(
name|colorTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|isGrayscale
condition|)
block|{
name|uint16
name|photometric
init|=
name|PHOTOMETRIC_MINISBLACK
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|colorTable
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|photometric
operator|=
name|PHOTOMETRIC_MINISWHITE
expr_stmt|;
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
name|photometric
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|compression
operator|==
name|NoCompression
condition|?
name|COMPRESSION_NONE
else|:
name|COMPRESSION_PACKBITS
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
name|PHOTOMETRIC_PALETTE
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|compression
operator|==
name|NoCompression
condition|?
name|COMPRESSION_NONE
else|:
name|COMPRESSION_PACKBITS
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|//// write the color table
comment|// allocate the color tables
name|uint16
modifier|*
name|redTable
init|=
cast|static_cast
argument_list|<
name|uint16
operator|*
argument_list|>
argument_list|(
name|qMalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|uint16
modifier|*
name|greenTable
init|=
cast|static_cast
argument_list|<
name|uint16
operator|*
argument_list|>
argument_list|(
name|qMalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|uint16
modifier|*
name|blueTable
init|=
cast|static_cast
argument_list|<
name|uint16
operator|*
argument_list|>
argument_list|(
name|qMalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uint16
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|redTable
operator|||
operator|!
name|greenTable
operator|||
operator|!
name|blueTable
condition|)
block|{
name|qFree
argument_list|(
name|redTable
argument_list|)
expr_stmt|;
name|qFree
argument_list|(
name|greenTable
argument_list|)
expr_stmt|;
name|qFree
argument_list|(
name|blueTable
argument_list|)
expr_stmt|;
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// set the color table
specifier|const
name|int
name|tableSize
init|=
name|colorTable
operator|.
name|size
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|tableSize
operator|<=
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRgb
name|color
init|=
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|redTable
index|[
name|i
index|]
operator|=
name|qRed
argument_list|(
name|color
argument_list|)
operator|*
literal|257
expr_stmt|;
name|greenTable
index|[
name|i
index|]
operator|=
name|qGreen
argument_list|(
name|color
argument_list|)
operator|*
literal|257
expr_stmt|;
name|blueTable
index|[
name|i
index|]
operator|=
name|qBlue
argument_list|(
name|color
argument_list|)
operator|*
literal|257
expr_stmt|;
block|}
specifier|const
name|bool
name|setColorTableSuccess
init|=
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COLORMAP
argument_list|,
name|redTable
argument_list|,
name|greenTable
argument_list|,
name|blueTable
argument_list|)
decl_stmt|;
name|qFree
argument_list|(
name|redTable
argument_list|)
expr_stmt|;
name|qFree
argument_list|(
name|greenTable
argument_list|)
expr_stmt|;
name|qFree
argument_list|(
name|blueTable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setColorTableSuccess
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|//// write the data
comment|// try to do the conversion in chunks no greater than 16 MB
name|int
name|chunks
init|=
operator|(
name|width
operator|*
name|height
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|16
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|chunkHeight
init|=
name|qMax
argument_list|(
name|height
operator|/
name|chunks
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|height
condition|)
block|{
name|QImage
name|chunk
init|=
name|image
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|qMin
argument_list|(
name|chunkHeight
argument_list|,
name|height
operator|-
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|chunkStart
init|=
name|y
decl_stmt|;
name|int
name|chunkEnd
init|=
name|y
operator|+
name|chunk
operator|.
name|height
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|chunkEnd
condition|)
block|{
if|if
condition|(
name|TIFFWriteScanline
argument_list|(
name|tiff
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|chunk
operator|.
name|scanLine
argument_list|(
name|y
operator|-
name|chunkStart
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
name|y
expr_stmt|;
block|}
block|}
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_PHOTOMETRIC
argument_list|,
name|PHOTOMETRIC_RGB
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_COMPRESSION
argument_list|,
name|compression
operator|==
name|NoCompression
condition|?
name|COMPRESSION_NONE
else|:
name|COMPRESSION_LZW
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_SAMPLESPERPIXEL
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|TIFFSetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_BITSPERSAMPLE
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// try to do the ARGB32 conversion in chunks no greater than 16 MB
name|int
name|chunks
init|=
operator|(
name|width
operator|*
name|height
operator|*
literal|4
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|16
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|chunkHeight
init|=
name|qMax
argument_list|(
name|height
operator|/
name|chunks
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|height
condition|)
block|{
name|QImage
name|chunk
init|=
name|image
operator|.
name|copy
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|qMin
argument_list|(
name|chunkHeight
argument_list|,
name|height
operator|-
name|y
argument_list|)
argument_list|)
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
decl_stmt|;
name|int
name|chunkStart
init|=
name|y
decl_stmt|;
name|int
name|chunkEnd
init|=
name|y
operator|+
name|chunk
operator|.
name|height
argument_list|()
decl_stmt|;
while|while
condition|(
name|y
operator|<
name|chunkEnd
condition|)
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|LittleEndian
condition|)
name|convert32BitOrder
argument_list|(
name|chunk
operator|.
name|scanLine
argument_list|(
name|y
operator|-
name|chunkStart
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
else|else
name|convert32BitOrderBigEndian
argument_list|(
name|chunk
operator|.
name|scanLine
argument_list|(
name|y
operator|-
name|chunkStart
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIFFWriteScanline
argument_list|(
name|tiff
argument_list|,
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|chunk
operator|.
name|scanLine
argument_list|(
name|y
operator|-
name|chunkStart
argument_list|)
argument_list|)
argument_list|,
name|y
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|++
name|y
expr_stmt|;
block|}
block|}
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QTiffHandler
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"tiff"
return|;
block|}
end_function
begin_function
DECL|function|option
name|QVariant
name|QTiffHandler
operator|::
name|option
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|option
operator|==
name|Size
operator|&&
name|canRead
argument_list|()
condition|)
block|{
name|QSize
name|imageSize
decl_stmt|;
name|qint64
name|pos
init|=
name|device
argument_list|()
operator|->
name|pos
argument_list|()
decl_stmt|;
name|TIFF
modifier|*
name|tiff
init|=
name|TIFFClientOpen
argument_list|(
literal|"foo"
argument_list|,
literal|"r"
argument_list|,
cast|const_cast
argument_list|<
name|QTiffHandler
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|qtiffReadProc
argument_list|,
name|qtiffWriteProc
argument_list|,
name|qtiffSeekProc
argument_list|,
name|qtiffCloseProc
argument_list|,
name|qtiffSizeProc
argument_list|,
name|qtiffMapProc
argument_list|,
name|qtiffUnmapProc
argument_list|)
decl_stmt|;
if|if
condition|(
name|tiff
condition|)
block|{
name|uint32
name|width
init|=
literal|0
decl_stmt|;
name|uint32
name|height
init|=
literal|0
decl_stmt|;
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGEWIDTH
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
name|TIFFGetField
argument_list|(
name|tiff
argument_list|,
name|TIFFTAG_IMAGELENGTH
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
name|imageSize
operator|=
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|TIFFClose
argument_list|(
name|tiff
argument_list|)
expr_stmt|;
block|}
name|device
argument_list|()
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|imageSize
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|imageSize
return|;
block|}
elseif|else
if|if
condition|(
name|option
operator|==
name|CompressionRatio
condition|)
block|{
return|return
name|compression
return|;
block|}
elseif|else
if|if
condition|(
name|option
operator|==
name|ImageFormat
condition|)
block|{
return|return
name|QImage
operator|::
name|Format_ARGB32
return|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setOption
name|void
name|QTiffHandler
operator|::
name|setOption
parameter_list|(
name|ImageOption
name|option
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|option
operator|==
name|CompressionRatio
operator|&&
name|value
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Int
condition|)
name|compression
operator|=
name|value
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|supportsOption
name|bool
name|QTiffHandler
operator|::
name|supportsOption
parameter_list|(
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
return|return
name|option
operator|==
name|CompressionRatio
operator|||
name|option
operator|==
name|Size
operator|||
name|option
operator|==
name|ImageFormat
return|;
block|}
end_function
begin_function
DECL|function|convert32BitOrder
name|void
name|QTiffHandler
operator|::
name|convert32BitOrder
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|uint32
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
for|for
control|(
name|int32
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|uint32
name|p
init|=
name|target
index|[
name|x
index|]
decl_stmt|;
comment|// convert between ARGB and ABGR
name|target
index|[
name|x
index|]
operator|=
operator|(
name|p
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|p
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|p
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|p
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convert32BitOrderBigEndian
name|void
name|QTiffHandler
operator|::
name|convert32BitOrderBigEndian
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|uint32
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|uint32
operator|*
argument_list|>
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
for|for
control|(
name|int32
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
block|{
name|uint32
name|p
init|=
name|target
index|[
name|x
index|]
decl_stmt|;
name|target
index|[
name|x
index|]
operator|=
operator|(
name|p
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
operator||
operator|(
name|p
operator|&
literal|0x00ff0000
operator|)
operator|<<
literal|8
operator||
operator|(
name|p
operator|&
literal|0x0000ff00
operator|)
operator|<<
literal|8
operator||
operator|(
name|p
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
