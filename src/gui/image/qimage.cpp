begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qtransform.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"qimagewriter.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qimagepixmapcleanuphooks_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformpixmap.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmemrotate_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimagescale_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qsimd_p.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimage_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isLocked
specifier|static
specifier|inline
name|bool
name|isLocked
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|)
block|{
return|return
name|data
operator|!=
literal|0
operator|&&
name|data
operator|->
name|is_locked
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_DEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha
argument_list|)
operator|&&
operator|(
name|__DECCXX_VER
operator|-
literal|0
operator|>=
literal|50190001
operator|)
end_if
begin_pragma
pragma|#
directive|pragma
name|message
name|disable
name|narrowptr
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QIMAGE_SANITYCHECK_MEMORY
define|#
directive|define
name|QIMAGE_SANITYCHECK_MEMORY
parameter_list|(
name|image
parameter_list|)
define|\
value|if ((image).isNull()) { \         qWarning("QImage: out of memory, returning null image"); \         return QImage(); \     }
end_define
begin_function_decl
specifier|static
name|QImage
name|rotated90
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QImage
name|rotated180
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QImage
name|rotated270
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|qimage_serial_number
name|QBasicAtomicInt
name|qimage_serial_number
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QImageData
name|QImageData
operator|::
name|QImageData
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|width
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|height
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|depth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|nbytes
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|devicePixelRatio
argument_list|(
literal|1.0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|format
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
member_init_list|,
name|bytes_per_line
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ser_no
argument_list|(
name|qimage_serial_number
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
member_init_list|,
name|detach_no
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dpmx
argument_list|(
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|dpmy
argument_list|(
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|own_data
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|ro_data
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_alpha_clut
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|is_cached
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|is_locked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cleanupFunction
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cleanupInfo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|paintEngine
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \fn QImageData * QImageData::create(const QSize&size, QImage::Format format)      \internal      Creates a new image data.     Returns 0 if invalid parameters are give or anything else failed. */
end_comment
begin_function
DECL|function|create
name|QImageData
modifier|*
name|QImageData
operator|::
name|create
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|size
operator|.
name|isValid
argument_list|()
operator|||
name|format
operator|==
name|QImage
operator|::
name|Format_Invalid
condition|)
return|return
literal|0
return|;
comment|// invalid parameter(s)
name|uint
name|width
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|uint
name|height
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|uint
name|depth
init|=
name|qt_depthForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
specifier|const
name|int
name|bytes_per_line
init|=
operator|(
operator|(
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
comment|// bytes per scanline (must be multiple of 4)
comment|// sanity check for potential overflows
if|if
condition|(
name|INT_MAX
operator|/
name|depth
operator|<
name|width
operator|||
name|bytes_per_line
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|bytes_per_line
argument_list|)
operator|<
name|height
operator|||
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
condition|)
return|return
literal|0
return|;
name|QScopedPointer
argument_list|<
name|QImageData
argument_list|>
name|d
argument_list|(
operator|new
name|QImageData
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|d
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|colortable
index|[
literal|0
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
name|d
operator|->
name|colortable
index|[
literal|1
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|d
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|d
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|d
operator|->
name|has_alpha_clut
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|is_cached
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|bytes_per_line
operator|=
name|bytes_per_line
expr_stmt|;
name|d
operator|->
name|nbytes
operator|=
name|d
operator|->
name|bytes_per_line
operator|*
name|height
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|data
condition|)
block|{
return|return
literal|0
return|;
block|}
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
name|d
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_destructor
DECL|function|~QImageData
name|QImageData
operator|::
name|~
name|QImageData
parameter_list|()
block|{
if|if
condition|(
name|cleanupFunction
condition|)
name|cleanupFunction
argument_list|(
name|cleanupInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executeImageHooks
argument_list|(
operator|(
operator|(
operator|(
name|qint64
operator|)
name|ser_no
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|qint64
operator|)
name|detach_no
operator|)
argument_list|)
expr_stmt|;
operator|delete
name|paintEngine
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|own_data
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|checkForAlphaPixels
name|bool
name|QImageData
operator|::
name|checkForAlphaPixels
parameter_list|()
specifier|const
block|{
name|bool
name|has_alpha_pixels
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|has_alpha_pixels
operator|=
name|has_alpha_clut
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Alpha8
case|:
name|has_alpha_pixels
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|has_alpha_pixels
operator||=
operator|(
operator|(
operator|(
name|uint
operator|*
operator|)
name|bits
operator|)
index|[
name|x
index|]
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0xff000000
expr_stmt|;
name|bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_RGBA8888
case|:
case|case
name|QImage
operator|::
name|Format_RGBA8888_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|has_alpha_pixels
operator||=
name|bits
index|[
name|x
operator|*
literal|4
operator|+
literal|3
index|]
operator|!=
literal|0xff
expr_stmt|;
name|bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_A2BGR30_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_A2RGB30_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|has_alpha_pixels
operator||=
operator|(
operator|(
operator|(
name|uint
operator|*
operator|)
name|bits
operator|)
index|[
name|x
index|]
operator|&
literal|0xc0000000
operator|)
operator|!=
literal|0xc0000000
expr_stmt|;
name|bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
name|bits
index|[
literal|0
index|]
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|3
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
operator|(
name|bits
index|[
literal|0
index|]
operator|&
literal|0xfc
operator|)
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|3
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
operator|(
name|bits
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|2
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
case|case
name|QImage
operator|::
name|Format_Grayscale8
case|:
break|break;
case|case
name|QImage
operator|::
name|Format_Invalid
case|:
case|case
name|QImage
operator|::
name|NImageFormats
case|:
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|has_alpha_pixels
return|;
block|}
end_function
begin_comment
comment|/*!     \class QImage      \inmodule QtGui     \ingroup painting     \ingroup shared      \reentrant      \brief The QImage class provides a hardware-independent image     representation that allows direct access to the pixel data, and     can be used as a paint device.      Qt provides four classes for handling image data: QImage, QPixmap,     QBitmap and QPicture.  QImage is designed and optimized for I/O,     and for direct pixel access and manipulation, while QPixmap is     designed and optimized for showing images on screen. QBitmap is     only a convenience class that inherits QPixmap, ensuring a     depth of 1. Finally, the QPicture class is a paint device that     records and replays QPainter commands.      Because QImage is a QPaintDevice subclass, QPainter can be used to     draw directly onto images.  When using QPainter on a QImage, the     painting can be performed in another thread than the current GUI     thread.      The QImage class supports several image formats described by the     \l Format enum. These include monochrome, 8-bit, 32-bit and     alpha-blended images which are available in all versions of Qt     4.x.      QImage provides a collection of functions that can be used to     obtain a variety of information about the image. There are also     several functions that enables transformation of the image.      QImage objects can be passed around by value since the QImage     class uses \l{Implicit Data Sharing}{implicit data     sharing}. QImage objects can also be streamed and compared.      \note If you would like to load QImage objects in a static build of Qt,     refer to the \l{How to Create Qt Plugins}{Plugin HowTo}.      \warning Painting on a QImage with the format     QImage::Format_Indexed8 is not supported.      \tableofcontents      \section1 Reading and Writing Image Files      QImage provides several ways of loading an image file: The file     can be loaded when constructing the QImage object, or by using the     load() or loadFromData() functions later on. QImage also provides     the static fromData() function, constructing a QImage from the     given data.  When loading an image, the file name can either refer     to an actual file on disk or to one of the application's embedded     resources. See \l{The Qt Resource System} overview for details     on how to embed images and other resource files in the     application's executable.      Simply call the save() function to save a QImage object.      The complete list of supported file formats are available through     the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions. New file formats     can be added as plugins. By default, Qt supports the following     formats:      \table     \header \li Format \li Description                      \li Qt's support     \row    \li BMP    \li Windows Bitmap                   \li Read/write     \row    \li GIF    \li Graphic Interchange Format (optional) \li Read     \row    \li JPG    \li Joint Photographic Experts Group \li Read/write     \row    \li JPEG   \li Joint Photographic Experts Group \li Read/write     \row    \li PNG    \li Portable Network Graphics        \li Read/write     \row    \li PBM    \li Portable Bitmap                  \li Read     \row    \li PGM    \li Portable Graymap                 \li Read     \row    \li PPM    \li Portable Pixmap                  \li Read/write     \row    \li XBM    \li X11 Bitmap                       \li Read/write     \row    \li XPM    \li X11 Pixmap                       \li Read/write     \endtable      \section1 Image Information      QImage provides a collection of functions that can be used to     obtain a variety of information about the image:      \table     \header     \li \li Available Functions      \row     \li Geometry     \li      The size(), width(), height(), dotsPerMeterX(), and     dotsPerMeterY() functions provide information about the image size     and aspect ratio.      The rect() function returns the image's enclosing rectangle. The     valid() function tells if a given pair of coordinates is within     this rectangle. The offset() function returns the number of pixels     by which the image is intended to be offset by when positioned     relative to other images, which also can be manipulated using the     setOffset() function.      \row     \li Colors     \li      The color of a pixel can be retrieved by passing its coordinates     to the pixel() function.  The pixel() function returns the color     as a QRgb value indepedent of the image's format.      In case of monochrome and 8-bit images, the colorCount() and     colorTable() functions provide information about the color     components used to store the image data: The colorTable() function     returns the image's entire color table. To obtain a single entry,     use the pixelIndex() function to retrieve the pixel index for a     given pair of coordinates, then use the color() function to     retrieve the color. Note that if you create an 8-bit image     manually, you have to set a valid color table on the image as     well.      The hasAlphaChannel() function tells if the image's format     respects the alpha channel, or not. The allGray() and     isGrayscale() functions tell whether an image's colors are all     shades of gray.      See also the \l {QImage#Pixel Manipulation}{Pixel Manipulation}     and \l {QImage#Image Transformations}{Image Transformations}     sections.      \row     \li Text     \li      The text() function returns the image text associated with the     given text key. An image's text keys can be retrieved using the     textKeys() function. Use the setText() function to alter an     image's text.      \row     \li Low-level information     \li      The depth() function returns the depth of the image. The supported     depths are 1 (monochrome), 8, 16, 24 and 32 bits. The     bitPlaneCount() function tells how many of those bits that are     used. For more information see the     \l {QImage#Image Formats}{Image Formats} section.      The format(), bytesPerLine(), and byteCount() functions provide     low-level information about the data stored in the image.      The cacheKey() function returns a number that uniquely     identifies the contents of this QImage object.     \endtable      \section1 Pixel Manipulation      The functions used to manipulate an image's pixels depend on the     image format. The reason is that monochrome and 8-bit images are     index-based and use a color lookup table, while 32-bit images     store ARGB values directly. For more information on image formats,     see the \l {Image Formats} section.      In case of a 32-bit image, the setPixel() function can be used to     alter the color of the pixel at the given coordinates to any other     color specified as an ARGB quadruplet. To make a suitable QRgb     value, use the qRgb() (adding a default alpha component to the     given RGB values, i.e. creating an opaque color) or qRgba()     function. For example:      \table     \header     \li {2,1}32-bit     \row     \li \inlineimage qimage-32bit_scaled.png     \li     \snippet code/src_gui_image_qimage.cpp 0     \endtable      In case of a 8-bit and monchrome images, the pixel value is only     an index from the image's color table. So the setPixel() function     can only be used to alter the color of the pixel at the given     coordinates to a predefined color from the image's color table,     i.e. it can only change the pixel's index value. To alter or add a     color to an image's color table, use the setColor() function.      An entry in the color table is an ARGB quadruplet encoded as an     QRgb value. Use the qRgb() and qRgba() functions to make a     suitable QRgb value for use with the setColor() function. For     example:      \table     \header     \li {2,1} 8-bit     \row     \li \inlineimage qimage-8bit_scaled.png     \li     \snippet code/src_gui_image_qimage.cpp 1     \endtable      For images with more than 8-bit per color-channel. The methods     setPixelColor() and pixelColor() can be used to set and get     with QColor values.      QImage also provide the scanLine() function which returns a     pointer to the pixel data at the scanline with the given index,     and the bits() function which returns a pointer to the first pixel     data (this is equivalent to \c scanLine(0)).      \section1 Image Formats      Each pixel stored in a QImage is represented by an integer. The     size of the integer varies depending on the format. QImage     supports several image formats described by the \l Format     enum.      Monochrome images are stored using 1-bit indexes into a color table     with at most two colors. There are two different types of     monochrome images: big endian (MSB first) or little endian (LSB     first) bit order.      8-bit images are stored using 8-bit indexes into a color table,     i.e.  they have a single byte per pixel. The color table is a     QVector<QRgb>, and the QRgb typedef is equivalent to an unsigned     int containing an ARGB quadruplet on the format 0xAARRGGBB.      32-bit images have no color table; instead, each pixel contains an     QRgb value. There are three different types of 32-bit images     storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB     values respectively. In the premultiplied format the red, green,     and blue channels are multiplied by the alpha component divided by     255.      An image's format can be retrieved using the format()     function. Use the convertToFormat() functions to convert an image     into another format. The allGray() and isGrayscale() functions     tell whether a color image can safely be converted to a grayscale     image.      \section1 Image Transformations      QImage supports a number of functions for creating a new image     that is a transformed version of the original: The     createAlphaMask() function builds and returns a 1-bpp mask from     the alpha buffer in this image, and the createHeuristicMask()     function creates and returns a 1-bpp heuristic mask for this     image. The latter function works by selecting a color from one of     the corners, then chipping away pixels of that color starting at     all the edges.      The mirrored() function returns a mirror of the image in the     desired direction, the scaled() returns a copy of the image scaled     to a rectangle of the desired measures, and the rgbSwapped() function     constructs a BGR image from a RGB image.      The scaledToWidth() and scaledToHeight() functions return scaled     copies of the image.      The transformed() function returns a copy of the image that is     transformed with the given transformation matrix and     transformation mode: Internally, the transformation matrix is     adjusted to compensate for unwanted translation,     i.e. transformed() returns the smallest image containing all     transformed points of the original image. The static trueMatrix()     function returns the actual matrix used for transforming the     image.      There are also functions for changing attributes of an image     in-place:      \table     \header \li Function \li Description     \row     \li setDotsPerMeterX()     \li Defines the aspect ratio by setting the number of pixels that fit     horizontally in a physical meter.     \row     \li setDotsPerMeterY()     \li Defines the aspect ratio by setting the number of pixels that fit     vertically in a physical meter.     \row     \li fill()     \li Fills the entire image with the given pixel value.     \row     \li invertPixels()     \li Inverts all pixel values in the image using the given InvertMode value.     \row     \li setColorTable()     \li Sets the color table used to translate color indexes. Only     monochrome and 8-bit formats.     \row     \li setColorCount()     \li Resizes the color table. Only monochrome and 8-bit formats.      \endtable      \target qimage-legalese     \section1 Legal Information      For smooth scaling, the transformed() functions use code based on     smooth scaling algorithm by Daniel M. Duley.      \badcode      Copyright (C) 2004, 2005 Daniel M. Duley       Redistribution and use in source and binary forms, with or without         modification, are permitted provided that the following conditions         are met:       1. Redistributions of source code must retain the above copyright         notice, this list of conditions and the following disclaimer.      2. Redistributions in binary form must reproduce the above copyright         notice, this list of conditions and the following disclaimer in the         documentation and/or other materials provided with the distribution.       THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR      IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES      OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.      IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT      NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     \endcode      \sa QImageReader, QImageWriter, QPixmap, QSvgRenderer, {Image Composition Example},         {Image Viewer Example}, {Scribble Example}, {Pixelator Example} */
end_comment
begin_comment
comment|/*!     \fn QImage::QImage(QImage&&other)      Move-constructs a QImage instance, making it point at the same     object that \a other was pointing to.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn QImage&QImage::operator=(QImage&&other)      Move-assigns \a other to this QImage instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \typedef QImageCleanupFunction     \relates QImage     \since 5.0      A function with the following signature that can be used to     implement basic image memory management:      \code     void myImageCleanupHandler(void *info);     \endcode */
end_comment
begin_comment
comment|/*!     \enum QImage::InvertMode      This enum type is used to describe how pixel values should be     inverted in the invertPixels() function.      \value InvertRgb    Invert only the RGB values and leave the alpha                         channel unchanged.      \value InvertRgba   Invert all channels, including the alpha channel.      \sa invertPixels() */
end_comment
begin_comment
comment|/*!     \enum QImage::Format      The following image formats are available in Qt. Values from Format_ARGB8565_Premultiplied     to Format_ARGB4444_Premultiplied were added in Qt 4.4. Values Format_RGBX8888, Format_RGBA8888     and Format_RGBA8888_Premultiplied were added in Qt 5.2. Values Format_BGR30, Format_A2BGR30_Premultiplied,     Format_RGB30, Format_A2RGB30_Premultiplied were added in Qt 5.4. Format_Alpha8 and Format_Grayscale8     were added in Qt 5.5.     See the notes after the table.      \value Format_Invalid   The image is invalid.     \value Format_Mono      The image is stored using 1-bit per pixel. Bytes are                             packed with the most significant bit (MSB) first.     \value Format_MonoLSB   The image is stored using 1-bit per pixel. Bytes are                             packed with the less significant bit (LSB) first.      \value Format_Indexed8  The image is stored using 8-bit indexes                             into a colormap.      \value Format_RGB32     The image is stored using a 32-bit RGB format (0xffRRGGBB).      \value Format_ARGB32    The image is stored using a 32-bit ARGB                             format (0xAARRGGBB).      \value Format_ARGB32_Premultiplied  The image is stored using a premultiplied 32-bit                             ARGB format (0xAARRGGBB), i.e. the red,                             green, and blue channels are multiplied                             by the alpha component divided by 255. (If RR, GG, or BB                             has a higher value than the alpha channel, the results are                             undefined.) Certain operations (such as image composition                             using alpha blending) are faster using premultiplied ARGB32                             than with plain ARGB32.      \value Format_RGB16     The image is stored using a 16-bit RGB format (5-6-5).      \value Format_ARGB8565_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (8-5-6-5).     \value Format_RGB666    The image is stored using a 24-bit RGB format (6-6-6).                             The unused most significant bits is always zero.     \value Format_ARGB6666_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (6-6-6-6).     \value Format_RGB555    The image is stored using a 16-bit RGB format (5-5-5).                             The unused most significant bit is always zero.     \value Format_ARGB8555_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (8-5-5-5).     \value Format_RGB888    The image is stored using a 24-bit RGB format (8-8-8).     \value Format_RGB444    The image is stored using a 16-bit RGB format (4-4-4).                             The unused bits are always zero.     \value Format_ARGB4444_Premultiplied  The image is stored using a                             premultiplied 16-bit ARGB format (4-4-4-4).     \value Format_RGBX8888   The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8).                              This is the same as the Format_RGBA8888 except alpha must always be 255.     \value Format_RGBA8888   The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8).                              Unlike ARGB32 this is a byte-ordered format, which means the 32bit                              encoding differs between big endian and little endian architectures,                              being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors                              is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA.     \value Format_RGBA8888_Premultiplied    The image is stored using a                             premultiplied 32-bit byte-ordered RGBA format (8-8-8-8).     \value Format_BGR30      The image is stored using a 32-bit BGR format (x-10-10-10).     \value Format_A2BGR30_Premultiplied    The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10).     \value Format_RGB30      The image is stored using a 32-bit RGB format (x-10-10-10).     \value Format_A2RGB30_Premultiplied    The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10).     \value Format_Alpha8     The image is stored using an 8-bit alpha only format.     \value Format_Grayscale8 The image is stored using an 8-bit grayscale format.      \note Drawing into a QImage with QImage::Format_Indexed8 is not     supported.      \note Do not render into ARGB32 images using QPainter.  Using     QImage::Format_ARGB32_Premultiplied is significantly faster.      \note Formats with more than 8 bit per color channel will only be processed by the raster engine using 8 bit     per color.      \sa format(), convertToFormat() */
end_comment
begin_comment
comment|/*****************************************************************************   QImage member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Constructs a null image.      \sa isNull() */
end_comment
begin_constructor
name|QImage
operator|::
name|QImage
parameter_list|()
name|Q_DECL_NOEXCEPT
constructor|:
DECL|function|QPaintDevice
name|QPaintDevice
constructor|(
end_constructor
begin_block
unit|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format.      A \l{isNull()}{null} image will be returned if memory cannot be allocated.      \warning This will create a QImage with uninitialized data. Call     fill() to fill the image with an appropriate pixel value before     drawing onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a size and \a format.      A \l{isNull()}{null} image is returned if memory cannot be allocated.      \warning This will create a QImage with uninitialized data. Call     fill() to fill the image with an appropriate pixel value before     drawing onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Format
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|size
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|create
name|QImageData
modifier|*
name|QImageData
operator|::
name|create
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpl
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|,
name|bool
name|readOnly
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
block|{
name|QImageData
modifier|*
name|d
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Invalid
condition|)
return|return
name|d
return|;
specifier|const
name|int
name|depth
init|=
name|qt_depthForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
specifier|const
name|int
name|calc_bytes_per_line
init|=
operator|(
operator|(
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|/
literal|32
operator|)
operator|*
literal|4
decl_stmt|;
specifier|const
name|int
name|min_bytes_per_line
init|=
operator|(
name|width
operator|*
name|depth
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|bpl
operator|<=
literal|0
condition|)
name|bpl
operator|=
name|calc_bytes_per_line
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
operator|!
name|data
operator|||
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|depth
argument_list|)
operator|<
name|uint
argument_list|(
name|width
argument_list|)
operator|||
name|bpl
operator|<=
literal|0
operator|||
name|bpl
operator|<
name|min_bytes_per_line
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|bpl
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
condition|)
return|return
name|d
return|;
comment|// invalid parameter(s)
name|d
operator|=
operator|new
name|QImageData
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|->
name|own_data
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|ro_data
operator|=
name|readOnly
expr_stmt|;
name|d
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|d
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|d
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|d
operator|->
name|bytes_per_line
operator|=
name|bpl
expr_stmt|;
name|d
operator|->
name|nbytes
operator|=
name|d
operator|->
name|bytes_per_line
operator|*
name|height
expr_stmt|;
name|d
operator|->
name|cleanupFunction
operator|=
name|cleanupFunction
expr_stmt|;
name|d
operator|->
name|cleanupInfo
operator|=
name|cleanupInfo
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|d
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|colortable
index|[
literal|0
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
name|d
operator|->
name|colortable
index|[
literal|1
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels, \a data must be 32-bit aligned,     and each scanline of data in the image must also be 32-bit aligned.      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|data
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
literal|false
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing read-only memory buffer, \a     data. The \a width and \a height must be specified in pixels, \a     data must be 32-bit aligned, and each scanline of data in the     image must also be 32-bit aligned.      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used.      Unlike the similar QImage constructor that takes a non-const data buffer,     this version will never alter the contents of the buffer.  For example,     calling QImage::bits() will return a deep copy of the image, rather than     the buffer passed to the constructor.  This allows for the efficiency of     constructing a QImage from raw data, without the possibility of the raw     data being changed. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
literal|true
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels. \a bytesPerLine     specifies the number of bytes per line (stride).      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bytesPerLine
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|data
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bytesPerLine
argument_list|,
name|format
argument_list|,
literal|false
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels. \a bytesPerLine     specifies the number of bytes per line (stride).      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used.      Unlike the similar QImage constructor that takes a non-const data buffer,     this version will never alter the contents of the buffer.  For example,     calling QImage::bits() will return a deep copy of the image, rather than     the buffer passed to the constructor.  This allows for the efficiency of     constructing a QImage from raw data, without the possibility of the raw     data being changed. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bytesPerLine
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bytesPerLine
argument_list|,
name|format
argument_list|,
literal|true
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image and tries to load the image from the file with     the given \a fileName.      The loader attempts to read the image using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      If the loading of the image failed, this object is a null image.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      \sa isNull(), {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
literal|0
expr_stmt|;
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
end_ifndef
begin_function_decl
specifier|extern
name|bool
name|qt_read_xpm_image_or_array
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|source
parameter_list|,
name|QImage
modifier|&
name|image
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     Constructs an image from the given \a xpm image.      Make sure that the image is a valid XPM image. Errors are silently     ignored.      Note that it's possible to squeeze the XPM variable a little bit     by using an unusual declaration:      \snippet code/src_gui_image_qimage.cpp 2      The extra \c const makes the entire definition read-only, which is     slightly more efficient (e.g., when the code is in a shared     library) and able to be stored in ROM with the application. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|xpm
index|[]
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xpm
condition|)
return|return;
if|if
condition|(
operator|!
name|qt_read_xpm_image_or_array
argument_list|(
literal|0
argument_list|,
name|xpm
argument_list|,
operator|*
name|this
argument_list|)
condition|)
comment|// Issue: Warning because the constructor may be ambigious
name|qWarning
argument_list|(
literal|"QImage::QImage(), XPM is not supported"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IMAGEFORMAT_XPM
end_comment
begin_comment
comment|/*!     Constructs a shallow copy of the given \a image.      For more information about shallow copies, see the \l {Implicit     Data Sharing} documentation.      \sa copy() */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
name|image
operator|.
name|paintingActive
argument_list|()
operator|||
name|isLocked
argument_list|(
name|image
operator|.
name|d
argument_list|)
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
name|image
operator|.
name|copy
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|image
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Destroys the image and cleans up. */
end_comment
begin_destructor
DECL|function|~QImage
name|QImage
operator|::
name|~
name|QImage
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns a shallow copy of the given \a image to this image and     returns a reference to this image.      For more information about shallow copies, see the \l {Implicit     Data Sharing} documentation.      \sa copy(), QImage() */
end_comment
begin_function
DECL|function|operator =
name|QImage
modifier|&
name|QImage
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|paintingActive
argument_list|()
operator|||
name|isLocked
argument_list|(
name|image
operator|.
name|d
argument_list|)
condition|)
block|{
name|operator
name|=
argument_list|(
name|image
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|image
operator|.
name|d
condition|)
name|image
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|image
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::swap(QImage&other)     \since 4.8      Swaps image \a other with this image. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QImage
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Image
return|;
block|}
end_function
begin_comment
comment|/*!    Returns the image as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QImage
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Image
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      If multiple images share common data, this image makes a copy of     the data and detaches itself from the sharing mechanism, making     sure that this image is the only one referring to the data.      Nothing is done if there is just a single reference.      \sa copy(), isDetached(), {Implicit Data Sharing} */
end_comment
begin_function
DECL|function|detach
name|void
name|QImage
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|is_cached
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executeImageHooks
argument_list|(
name|cacheKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
operator|||
name|d
operator|->
name|ro_data
condition|)
operator|*
name|this
operator|=
name|copy
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
operator|++
name|d
operator|->
name|detach_no
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copyMetadata
specifier|static
name|void
name|copyMetadata
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|)
block|{
comment|// Doesn't copy colortable and alpha_clut, or offset.
name|dst
operator|->
name|dpmx
operator|=
name|src
operator|->
name|dpmx
expr_stmt|;
name|dst
operator|->
name|dpmy
operator|=
name|src
operator|->
name|dpmy
expr_stmt|;
name|dst
operator|->
name|devicePixelRatio
operator|=
name|src
operator|->
name|devicePixelRatio
expr_stmt|;
name|dst
operator|->
name|text
operator|=
name|src
operator|->
name|text
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::copy(int x, int y, int width, int height) const     \overload      The returned image is copied from the position (\a x, \a y) in     this image, and will always have the given \a width and \a height.     In areas beyond this image, pixels are set to 0.  */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::copy(const QRect& rectangle) const      Returns a sub-area of the image as a new image.      The returned image is copied from the position (\a     {rectangle}.x(), \a{rectangle}.y()) in this image, and will always     have the size of the given \a rectangle.      In areas beyond this image, pixels are set to 0. For 32-bit RGB     images, this means black; for 32-bit ARGB images, this means     transparent black; for 8-bit images, this means the color with     index 0 in the color table which can be anything; for 1-bit     images, this means Qt::color0.      If the given \a rectangle is a null rectangle the entire image is     copied.      \sa QImage() */
end_comment
begin_function
DECL|function|copy
name|QImage
name|QImage
operator|::
name|copy
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|image
return|;
comment|// Qt for Embedded Linux can create images with non-default bpl
comment|// make sure we don't crash.
if|if
condition|(
name|image
operator|.
name|d
operator|->
name|nbytes
operator|!=
name|d
operator|->
name|nbytes
condition|)
block|{
name|int
name|bpl
init|=
name|qMin
argument_list|(
name|bytesPerLine
argument_list|()
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
argument_list|()
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|scanLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|,
name|bits
argument_list|()
argument_list|,
name|d
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|d
operator|->
name|offset
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
name|copyMetadata
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
name|int
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|dy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|image
return|;
if|if
condition|(
name|x
argument_list|<
literal|0
operator|||
name|y
argument_list|<
literal|0
operator|||
name|x
operator|+
name|w
argument_list|>
name|d
operator|->
name|width
operator|||
name|y
operator|+
name|h
argument_list|>
name|d
operator|->
name|height
condition|)
block|{
comment|// bitBlt will not cover entire image - clear it.
name|image
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|x
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|y
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|image
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|int
name|pixels_to_copy
init|=
name|qMax
argument_list|(
name|w
operator|-
name|dx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|d
operator|->
name|width
condition|)
name|pixels_to_copy
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixels_to_copy
operator|>
name|d
operator|->
name|width
operator|-
name|x
condition|)
name|pixels_to_copy
operator|=
name|d
operator|->
name|width
operator|-
name|x
expr_stmt|;
name|int
name|lines_to_copy
init|=
name|qMax
argument_list|(
name|h
operator|-
name|dy
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|>
name|d
operator|->
name|height
condition|)
name|lines_to_copy
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|lines_to_copy
operator|>
name|d
operator|->
name|height
operator|-
name|y
condition|)
name|lines_to_copy
operator|=
name|d
operator|->
name|height
operator|-
name|y
expr_stmt|;
name|bool
name|byteAligned
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Mono
operator|||
name|d
operator|->
name|format
operator|==
name|Format_MonoLSB
condition|)
name|byteAligned
operator|=
operator|!
operator|(
name|dx
operator|&
literal|7
operator|)
operator|&&
operator|!
operator|(
name|x
operator|&
literal|7
operator|)
operator|&&
operator|!
operator|(
name|pixels_to_copy
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|byteAligned
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
operator|(
operator|(
name|x
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
operator|)
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
operator|(
operator|(
name|dx
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
operator|)
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
specifier|const
name|int
name|bytes_to_copy
init|=
operator|(
name|pixels_to_copy
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Mono
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pixels_to_copy
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|src
index|[
operator|(
name|x
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|x
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Format_MonoLSB
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|format
operator|==
name|Format_MonoLSB
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pixels_to_copy
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|src
index|[
operator|(
name|x
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|x
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
name|copyMetadata
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|offset
argument_list|()
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::isNull() const      Returns \c true if it is a null image, otherwise returns \c false.      A null image has all parameters set to zero and no allocated data. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QImage
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::width() const      Returns the width of the image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|width
name|int
name|QImage
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|width
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::height() const      Returns the height of the image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|height
name|int
name|QImage
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|height
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QImage::size() const      Returns the size of the image, i.e. its width() and height().      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|size
name|QSize
name|QImage
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QImage::rect() const      Returns the enclosing rectangle (0, 0, width(), height()) of the     image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|rect
name|QRect
name|QImage
operator|::
name|rect
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
else|:
name|QRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the depth of the image.      The image depth is the number of bits used to store a single     pixel, also called bits per pixel (bpp).      The supported depths are 1, 8, 16, 24 and 32.      \sa bitPlaneCount(), convertToFormat(), {QImage#Image Formats}{Image Formats},     {QImage#Image Information}{Image Information}  */
end_comment
begin_function
DECL|function|depth
name|int
name|QImage
operator|::
name|depth
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|depth
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \fn int QImage::numColors() const      Returns the size of the color table for the image.      \sa setColorCount() */
end_comment
begin_comment
comment|/*!     \since 4.6     \fn int QImage::colorCount() const      Returns the size of the color table for the image.      Notice that colorCount() returns 0 for 32-bpp images because these     images do not use color tables, but instead encode pixel values as     ARGB quadruplets.      \sa setColorCount(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|colorCount
name|int
name|QImage
operator|::
name|colorCount
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the color table used to translate color indexes to QRgb     values, to the specified \a colors.      When the image is used, the color table must be large enough to     have entries for all the pixel/index values present in the image,     otherwise the results are undefined.      \sa colorTable(), setColor(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|6
operator|,
literal|0
operator|,
literal|0
argument_list|)
end_if
begin_decl_stmt
DECL|function|setColorTable
name|void
name|QImage
operator|::
name|setColorTable
argument_list|(
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
operator|&
name|colors
argument_list|)
else|#
directive|else
name|void
name|QImage
operator|::
name|setColorTable
argument_list|(
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colors
argument_list|)
endif|#
directive|endif
argument_list|{     if
operator|(
operator|!
name|d
operator|)
return|return;
end_decl_stmt
begin_expr_stmt
name|detach
argument_list|()
expr_stmt|;
end_expr_stmt
begin_comment
comment|// In case detach() ran out of memory
end_comment
begin_if
if|if
condition|(
operator|!
name|d
condition|)
return|return;
end_if
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|6
operator|,
literal|0
operator|,
literal|0
argument_list|)
end_if
begin_expr_stmt
name|d
operator|->
name|colortable
operator|=
name|colors
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|d
operator|->
name|colortable
operator|=
name|qMove
argument_list|(
cast|const_cast
argument_list|<
name|QVector
argument_list|<
name|QRgb
argument_list|>
operator|&
argument_list|>
argument_list|(
name|colors
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|d
operator|->
name|has_alpha_clut
operator|=
literal|false
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qAlpha
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|255
condition|)
block|{
name|d
operator|->
name|has_alpha_clut
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
end_for
begin_comment
unit|}
comment|/*!     Returns a list of the colors contained in the image's color table,     or an empty list if the image does not have a color table      \sa setColorTable(), colorCount(), color() */
end_comment
begin_expr_stmt
unit|QVector
DECL|function|colorTable
operator|<
name|QRgb
operator|>
name|QImage
operator|::
name|colorTable
operator|(
operator|)
specifier|const
block|{
return|return
name|d
operator|?
name|d
operator|->
name|colortable
operator|:
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     Returns the device pixel ratio for the image. This is the     ratio between \e{device pixels} and \e{device independent pixels}.      Use this function when calculating layout geometry based on     the image size: QSize layoutSize = image.size() / image.devicePixelRatio()      The default value is 1.0.      \sa setDevicePixelRatio(), QImageReader */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QImage
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|1.0
return|;
return|return
name|d
operator|->
name|devicePixelRatio
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the device pixel ratio for the image. This is the     ratio between image pixels and device-independent pixels.      The default \a scaleFactor is 1.0. Setting it to something else has     two effects:      QPainters that are opened on the image will be scaled. For     example, painting on a 200x200 image if with a ratio of 2.0     will result in effective (device-independent) painting bounds     of 100x100.      Code paths in Qt that calculate layout geometry based on the     image size will take the ratio into account:     QSize layoutSize = image.size() / image.devicePixelRatio()     The net effect of this is that the image is displayed as     high-DPI image rather than a large image     (see \l{Drawing High Resolution Versions of Pixmaps and Images}).      \sa devicePixelRatio() */
end_comment
begin_function
DECL|function|setDevicePixelRatio
name|void
name|QImage
operator|::
name|setDevicePixelRatio
parameter_list|(
name|qreal
name|scaleFactor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|scaleFactor
operator|==
name|d
operator|->
name|devicePixelRatio
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|devicePixelRatio
operator|=
name|scaleFactor
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the number of bytes occupied by the image data.      \sa bytesPerLine(), bits(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|byteCount
name|int
name|QImage
operator|::
name|byteCount
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|nbytes
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bytes per image scanline.      This is equivalent to byteCount() / height().      \sa scanLine() */
end_comment
begin_function
DECL|function|bytesPerLine
name|int
name|QImage
operator|::
name|bytesPerLine
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|&&
name|d
operator|->
name|height
operator|)
condition|?
name|d
operator|->
name|nbytes
operator|/
name|d
operator|->
name|height
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the color in the color table at index \a i. The first     color is at index 0.      The colors in an image's color table are specified as ARGB     quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and     qBlue() functions to get the color value components.      \sa setColor(), pixelIndex(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_function
DECL|function|color
name|QRgb
name|QImage
operator|::
name|color
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|<
name|colorCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
condition|?
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
else|:
name|QRgb
argument_list|(
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setColor(int index, QRgb colorValue)      Sets the color at the given \a index in the color table, to the     given to \a colorValue. The color value is an ARGB quadruplet.      If \a index is outside the current size of the color table, it is     expanded with setColorCount().      \sa color(), colorCount(), setColorTable(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_function
DECL|function|setColor
name|void
name|QImage
operator|::
name|setColor
parameter_list|(
name|int
name|i
parameter_list|,
name|QRgb
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|i
argument_list|<
literal|0
operator|||
name|d
operator|->
name|depth
argument_list|>
literal|8
operator|||
name|i
operator|>=
literal|1
operator|<<
name|d
operator|->
name|depth
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setColor: Index out of bound %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() run out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|i
operator|>=
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
name|setColorCount
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|has_alpha_clut
operator||=
operator|(
name|qAlpha
argument_list|(
name|c
argument_list|)
operator|!=
literal|255
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the pixel data at the scanline with index \a     i. The first scanline is at index 0.      The scanline data is aligned on a 32-bit boundary.      \warning If you are accessing 32-bpp image data, cast the returned     pointer to \c{QRgb*} (QRgb has a 32-bit size) and use it to     read/write the pixel value. You cannot use the \c{uchar*} pointer     directly, because the pixel format depends on the byte order on     the underlying platform. Use qRed(), qGreen(), qBlue(), and     qAlpha() to access the pixels.      \sa bytesPerLine(), bits(), {QImage#Pixel Manipulation}{Pixel     Manipulation}, constScanLine() */
end_comment
begin_function
DECL|function|scanLine
name|uchar
modifier|*
name|QImage
operator|::
name|scanLine
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|scanLine
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|scanLine
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the pixel data at the scanline with index \a     i. The first scanline is at index 0.      The scanline data is aligned on a 32-bit boundary.      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const.      \sa scanLine(), constBits()     \since 4.7 */
end_comment
begin_function
DECL|function|constScanLine
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|constScanLine
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the first pixel data. This is equivalent to     scanLine(0).      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}. This function performs a deep copy of the shared pixel     data, thus ensuring that this QImage is the only one using the     current return value.      \sa scanLine(), byteCount(), constBits() */
end_comment
begin_function
DECL|function|bits
name|uchar
modifier|*
name|QImage
operator|::
name|bits
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach ran out of memory...
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const. */
end_comment
begin_function
DECL|function|bits
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|bits
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|data
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the first pixel data.      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const.      \sa bits(), constScanLine()     \since 4.7 */
end_comment
begin_function
DECL|function|constBits
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|constBits
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|data
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(uint pixelValue)      Fills the entire image with the given \a pixelValue.      If the depth of this image is 1, only the lowest bit is used. If     you say fill(0), fill(2), etc., the image is filled with 0s. If     you say fill(1), fill(3), etc., the image is filled with 1s. If     the depth is 8, the lowest 8 bits are used and if the depth is 16     the lowest 16 bits are used.      Note: QImage::pixel() returns the color of the pixel at the given     coordinates while QColor::pixel() returns the pixel value of the     underlying window system (essentially an index value), so normally     you will want to use QImage::pixel() to use a color from an     existing image or QColor::rgb() to use a specific color.      \sa depth(), {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
name|uint
name|pixel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
operator|||
name|d
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pixel
operator|&
literal|1
condition|)
name|pixel
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|pixel
operator|=
literal|0
expr_stmt|;
name|w
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|pixel
operator|&=
literal|0xff
expr_stmt|;
block|}
name|qt_rectfill
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|16
condition|)
block|{
name|qt_rectfill
argument_list|<
name|quint16
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|24
condition|)
block|{
name|qt_rectfill
argument_list|<
name|quint24
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_RGB32
condition|)
name|pixel
operator||=
literal|0xff000000
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_RGBX8888
condition|)
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
name|pixel
operator||=
literal|0xff000000
expr_stmt|;
else|#
directive|else
name|pixel
operator||=
literal|0x000000ff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_BGR30
operator|||
name|d
operator|->
name|format
operator|==
name|Format_RGB30
condition|)
name|pixel
operator||=
literal|0xc0000000
expr_stmt|;
name|qt_rectfill
argument_list|<
name|uint
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(Qt::GlobalColor color)     \overload     \since 4.8      Fills the image with the given \a color, described as a standard global     color.  */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
name|Qt
operator|::
name|GlobalColor
name|color
parameter_list|)
block|{
name|fill
argument_list|(
name|QColor
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(const QColor&color)      \overload      Fills the entire image with the given \a color.      If the depth of the image is 1, the image will be filled with 1 if     \a color equals Qt::color1; it will otherwise be filled with 0.      If the depth of the image is 8, the image will be filled with the     index corresponding the \a color in the color table if present; it     will otherwise be filled with 0.      \since 4.8 */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case we run out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
name|fill
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|fill
argument_list|(
name|qPremultiply
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
name|fill
argument_list|(
name|ARGB2RGBA
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
operator||
literal|0xff000000
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGBA8888
case|:
name|fill
argument_list|(
name|ARGB2RGBA
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGBA8888_Premultiplied
case|:
name|fill
argument_list|(
name|ARGB2RGBA
argument_list|(
name|qPremultiply
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_A2BGR30_Premultiplied
case|:
name|fill
argument_list|(
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
name|color
operator|.
name|rgba64
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
case|case
name|QImage
operator|::
name|Format_A2RGB30_Premultiplied
case|:
name|fill
argument_list|(
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
name|color
operator|.
name|rgba64
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|fill
argument_list|(
operator|(
name|uint
operator|)
name|qConvertRgb32To16
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
block|{
name|uint
name|pixel
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|color
operator|.
name|rgba
argument_list|()
operator|==
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|pixel
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|fill
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
if|if
condition|(
name|color
operator|==
name|Qt
operator|::
name|color1
condition|)
name|fill
argument_list|(
operator|(
name|uint
operator|)
literal|1
argument_list|)
expr_stmt|;
else|else
name|fill
argument_list|(
operator|(
name|uint
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|rect
argument_list|()
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Inverts all pixel values in the image.      The given invert \a mode only have a meaning when the image's     depth is 32. The default \a mode is InvertRgb, which leaves the     alpha channel unchanged. If the \a mode is InvertRgba, the alpha     bits are also inverted.      Inverting an 8-bit image means to replace all pixels using color     index \e i with a pixel using color index 255 minus \e i. The same     is the case for a 1-bit image. Note that the color table is \e not     changed.      If the image has a premultiplied alpha channel, the image is first     converted to ARGB32 to be inverted and then converted back.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|invertPixels
name|void
name|QImage
operator|::
name|invertPixels
parameter_list|(
name|InvertMode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|QImage
operator|::
name|Format
name|originalFormat
init|=
name|d
operator|->
name|format
decl_stmt|;
comment|// Inverting premultiplied pixels would produce invalid image data.
if|if
condition|(
name|hasAlphaChannel
argument_list|()
operator|&&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
operator|.
name|premultiplied
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|convertInPlace
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|this
operator|=
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
argument_list|()
operator|<
literal|32
condition|)
block|{
comment|// This assumes no alpha-channel as the only formats with non-premultipled alpha are 32bit.
name|int
name|bpl
init|=
operator|(
name|d
operator|->
name|width
operator|*
name|d
operator|->
name|depth
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|pad
init|=
name|d
operator|->
name|bytes_per_line
operator|-
name|bpl
decl_stmt|;
name|uchar
modifier|*
name|sl
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|bpl
condition|;
operator|++
name|x
control|)
operator|*
name|sl
operator|++
operator|^=
literal|0xff
expr_stmt|;
name|sl
operator|+=
name|pad
expr_stmt|;
block|}
block|}
else|else
block|{
name|quint32
modifier|*
name|p
init|=
operator|(
name|quint32
operator|*
operator|)
name|d
operator|->
name|data
decl_stmt|;
name|quint32
modifier|*
name|end
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|d
operator|->
name|nbytes
operator|)
decl_stmt|;
name|quint32
name|xorbits
init|=
literal|0xffffffff
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGBA8888
case|:
if|if
condition|(
name|mode
operator|==
name|InvertRgba
condition|)
break|break;
comment|// no break
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
name|xorbits
operator|=
literal|0xffffff00
expr_stmt|;
break|break;
else|#
directive|else
name|xorbits
operator|=
literal|0x00ffffff
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
if|if
condition|(
name|mode
operator|==
name|InvertRgba
condition|)
break|break;
comment|// no break
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|xorbits
operator|=
literal|0x00ffffff
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
name|xorbits
operator|=
literal|0x3fffffff
expr_stmt|;
break|break;
default|default:
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
name|xorbits
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|^=
name|xorbits
expr_stmt|;
block|}
if|if
condition|(
name|originalFormat
operator|!=
name|d
operator|->
name|format
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|convertInPlace
argument_list|(
name|originalFormat
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|this
operator|=
name|convertToFormat
argument_list|(
name|originalFormat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Windows defines these
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|write
argument_list|)
end_if
begin_undef
DECL|macro|write
undef|#
directive|undef
name|write
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|close
argument_list|)
end_if
begin_undef
DECL|macro|close
undef|#
directive|undef
name|close
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|read
argument_list|)
end_if
begin_undef
DECL|macro|read
undef|#
directive|undef
name|read
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.6     Resizes the color table to contain \a colorCount entries.      If the color table is expanded, all the extra colors will be set to     transparent (i.e qRgba(0, 0, 0, 0)).      When the image is used, the color table must be large enough to     have entries for all the pixel/index values present in the image,     otherwise the results are undefined.      \sa colorCount(), colorTable(), setColor(), {QImage#Image     Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|setColorCount
name|void
name|QImage
operator|::
name|setColorCount
parameter_list|(
name|int
name|colorCount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setColorCount: null image"
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|colorCount
operator|==
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
return|return;
if|if
condition|(
name|colorCount
operator|<=
literal|0
condition|)
block|{
comment|// use no color table
name|d
operator|->
name|colortable
operator|=
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
expr_stmt|;
return|return;
block|}
name|int
name|nc
init|=
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
decl_stmt|;
name|d
operator|->
name|colortable
operator|.
name|resize
argument_list|(
name|colorCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nc
init|;
name|i
operator|<
name|colorCount
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of the image.      \sa {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|format
name|QImage
operator|::
name|Format
name|QImage
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|format
else|:
name|Format_Invalid
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::convertToFormat(Format format, Qt::ImageConversionFlags flags) const      Returns a copy of the image in the given \a format.      The specified image conversion \a flags control how the image data     is handled during the conversion process.      \sa {Image Formats} */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|convertToFormat_helper
name|QImage
name|QImage
operator|::
name|convertToFormat_helper
parameter_list|(
name|Format
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|format
operator|==
name|format
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|format
operator|==
name|Format_Invalid
operator|||
name|d
operator|->
name|format
operator|==
name|Format_Invalid
condition|)
return|return
name|QImage
argument_list|()
return|;
name|Image_Converter
name|converter
init|=
name|qimage_converter_map
index|[
name|d
operator|->
name|format
index|]
index|[
name|format
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|converter
operator|&&
name|format
operator|>
name|QImage
operator|::
name|Format_Indexed8
operator|&&
name|d
operator|->
name|format
operator|>
name|QImage
operator|::
name|Format_Indexed8
condition|)
name|converter
operator|=
name|convert_generic
expr_stmt|;
if|if
condition|(
name|converter
condition|)
block|{
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|offset
argument_list|()
expr_stmt|;
name|copyMetadata
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|converter
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
comment|// Convert indexed formats over ARGB32 or RGB32 to the final format.
name|Q_ASSERT
argument_list|(
name|format
operator|!=
name|QImage
operator|::
name|Format_ARGB32
operator|&&
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|format
operator|!=
name|QImage
operator|::
name|Format_ARGB32
operator|&&
name|d
operator|->
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
return|return
name|convertToFormat
argument_list|(
name|Format_RGB32
argument_list|,
name|flags
argument_list|)
operator|.
name|convertToFormat
argument_list|(
name|format
argument_list|,
name|flags
argument_list|)
return|;
return|return
name|convertToFormat
argument_list|(
name|Format_ARGB32
argument_list|,
name|flags
argument_list|)
operator|.
name|convertToFormat
argument_list|(
name|format
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|convertToFormat_inplace
name|bool
name|QImage
operator|::
name|convertToFormat_inplace
parameter_list|(
name|Format
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|convertInPlace
argument_list|(
name|format
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|pixel_distance
specifier|static
specifier|inline
name|int
name|pixel_distance
parameter_list|(
name|QRgb
name|p1
parameter_list|,
name|QRgb
name|p2
parameter_list|)
block|{
name|int
name|r1
init|=
name|qRed
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|qGreen
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|qBlue
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|a1
init|=
name|qAlpha
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|qRed
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|qGreen
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|qBlue
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|a2
init|=
name|qAlpha
argument_list|(
name|p2
argument_list|)
decl_stmt|;
return|return
name|abs
argument_list|(
name|r1
operator|-
name|r2
argument_list|)
operator|+
name|abs
argument_list|(
name|g1
operator|-
name|g2
argument_list|)
operator|+
name|abs
argument_list|(
name|b1
operator|-
name|b2
argument_list|)
operator|+
name|abs
argument_list|(
name|a1
operator|-
name|a2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|closestMatch
specifier|static
specifier|inline
name|int
name|closestMatch
parameter_list|(
name|QRgb
name|pixel
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|clut
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|current_distance
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clut
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|dist
init|=
name|pixel_distance
argument_list|(
name|pixel
argument_list|,
name|clut
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|<
name|current_distance
condition|)
block|{
name|current_distance
operator|=
name|dist
expr_stmt|;
name|idx
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|idx
return|;
block|}
end_function
begin_function
DECL|function|convertWithPalette
specifier|static
name|QImage
name|convertWithPalette
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|clut
parameter_list|)
block|{
name|QImage
name|dest
argument_list|(
name|src
operator|.
name|size
argument_list|()
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|dest
operator|.
name|setColorTable
argument_list|(
name|clut
argument_list|)
expr_stmt|;
name|QString
name|textsKeys
init|=
name|src
operator|.
name|text
argument_list|()
decl_stmt|;
specifier|const
specifier|auto
name|textKeyList
init|=
name|textsKeys
operator|.
name|splitRef
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|textKey
range|:
name|textKeyList
control|)
block|{
specifier|const
specifier|auto
name|textKeySplitted
init|=
name|textKey
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|.
name|setText
argument_list|(
name|textKeySplitted
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
argument_list|,
name|textKeySplitted
index|[
literal|1
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|h
init|=
name|src
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|src
operator|.
name|width
argument_list|()
decl_stmt|;
name|QHash
argument_list|<
name|QRgb
argument_list|,
name|int
argument_list|>
name|cache
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src_pixels
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|dest_pixels
init|=
operator|(
name|uchar
operator|*
operator|)
name|dest
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|src_pixel
init|=
name|src_pixels
index|[
name|x
index|]
decl_stmt|;
name|int
name|value
init|=
name|cache
operator|.
name|value
argument_list|(
name|src_pixel
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|value
operator|=
name|closestMatch
argument_list|(
name|src_pixel
argument_list|,
name|clut
argument_list|)
expr_stmt|;
name|cache
operator|.
name|insert
argument_list|(
name|src_pixel
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|dest_pixels
index|[
name|x
index|]
operator|=
operator|(
name|uchar
operator|)
name|value
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|table
init|=
name|clut
decl_stmt|;
name|table
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src_pixels
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|src_pixel
init|=
name|src_pixels
index|[
name|x
index|]
decl_stmt|;
name|int
name|value
init|=
name|cache
operator|.
name|value
argument_list|(
name|src_pixel
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|value
operator|=
name|closestMatch
argument_list|(
name|src_pixel
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|cache
operator|.
name|insert
argument_list|(
name|src_pixel
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|dest
operator|.
name|setPixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|dest
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a copy of the image converted to the given \a format,     using the specified \a colorTable.      Conversion from 32 bit to 8 bit indexed is a slow operation and     will use a straightforward nearest color approach, with no     dithering. */
end_comment
begin_function
DECL|function|convertToFormat
name|QImage
name|QImage
operator|::
name|convertToFormat
parameter_list|(
name|Format
name|format
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|colorTable
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|format
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|format
operator|<=
name|QImage
operator|::
name|Format_Indexed8
operator|&&
name|depth
argument_list|()
operator|==
literal|32
condition|)
block|{
return|return
name|convertWithPalette
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|,
name|colorTable
argument_list|)
return|;
block|}
specifier|const
name|Image_Converter
modifier|*
name|converterPtr
init|=
operator|&
name|qimage_converter_map
index|[
name|d
operator|->
name|format
index|]
index|[
name|format
index|]
decl_stmt|;
name|Image_Converter
name|converter
init|=
operator|*
name|converterPtr
decl_stmt|;
if|if
condition|(
operator|!
name|converter
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|offset
argument_list|()
expr_stmt|;
name|copyMetadata
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|converter
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::valid(const QPoint&pos) const      Returns \c true if \a pos is a valid coordinate pair within the     image; otherwise returns \c false.      \sa rect(), QRect::contains() */
end_comment
begin_comment
comment|/*!     \overload      Returns \c true if QPoint(\a x, \a y) is a valid coordinate pair     within the image; otherwise returns \c false. */
end_comment
begin_function
DECL|function|valid
name|bool
name|QImage
operator|::
name|valid
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|&&
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
name|d
operator|->
name|width
operator|&&
name|y
operator|>=
literal|0
operator|&&
name|y
operator|<
name|d
operator|->
name|height
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::pixelIndex(const QPoint&position) const      Returns the pixel index at the given \a position.      If \a position is not valid, or if the image is not a paletted     image (depth()> 8), the results are undefined.      \sa valid(), depth(), {QImage#Pixel Manipulation}{Pixel Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Returns the pixel index at (\a x, \a y). */
end_comment
begin_function
DECL|function|pixelIndex
name|int
name|QImage
operator|::
name|pixelIndex
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|d
operator|->
name|width
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::pixelIndex: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|-
literal|12345
return|;
block|}
specifier|const
name|uchar
modifier|*
name|s
init|=
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
return|return
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|&
literal|1
return|;
case|case
name|Format_MonoLSB
case|:
return|return
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
return|;
case|case
name|Format_Indexed8
case|:
return|return
operator|(
name|int
operator|)
name|s
index|[
name|x
index|]
return|;
default|default:
name|qWarning
argument_list|(
literal|"QImage::pixelIndex: Not applicable for %d-bpp images (no palette)"
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRgb QImage::pixel(const QPoint&position) const      Returns the color of the pixel at the given \a position.      If the \a position is not valid, the results are undefined.      \warning This function is expensive when used for massive pixel     manipulations. Use constBits() or constScanLine() when many     pixels needs to be read.      \sa setPixel(), valid(), constBits(), constScanLine(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Returns the color of the pixel at coordinates (\a x, \a y). */
end_comment
begin_function
DECL|function|pixel
name|QRgb
name|QImage
operator|::
name|pixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|d
operator|->
name|width
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|d
operator|->
name|height
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::pixel: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
literal|12345
return|;
block|}
specifier|const
name|uchar
modifier|*
name|s
init|=
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
operator|~
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
argument_list|)
return|;
case|case
name|Format_MonoLSB
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
argument_list|)
return|;
case|case
name|Format_Indexed8
case|:
block|{
name|int
name|index
init|=
operator|(
name|int
operator|)
name|s
index|[
name|x
index|]
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|index
argument_list|)
return|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QImage::pixel: color table index %d out of range."
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
case|case
name|Format_RGB32
case|:
return|return
literal|0xff000000
operator||
cast|reinterpret_cast
argument_list|<
specifier|const
name|QRgb
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
return|;
case|case
name|Format_ARGB32
case|:
comment|// Keep old behaviour.
case|case
name|Format_ARGB32_Premultiplied
case|:
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QRgb
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
return|;
case|case
name|Format_RGBX8888
case|:
case|case
name|Format_RGBA8888
case|:
comment|// Match ARGB32 behavior.
case|case
name|Format_RGBA8888_Premultiplied
case|:
return|return
name|RGBA2ARGB
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
return|;
case|case
name|Format_BGR30
case|:
case|case
name|Format_A2BGR30_Premultiplied
case|:
return|return
name|qConvertA2rgb30ToArgb32
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
return|;
case|case
name|Format_RGB30
case|:
case|case
name|Format_A2RGB30_Premultiplied
case|:
return|return
name|qConvertA2rgb30ToArgb32
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
return|;
case|case
name|Format_RGB16
case|:
return|return
name|qConvertRgb16To32
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|uint
name|result
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
operator|(
operator|&
name|result
expr|,
name|s
expr|,
name|x
expr|,
literal|1
operator|)
decl_stmt|;
return|return
operator|*
name|layout
operator|->
name|convertToARGB32PM
argument_list|(
operator|&
name|result
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setPixel(const QPoint&position, uint index_or_rgb)      Sets the pixel index or color at the given \a position to \a     index_or_rgb.      If the image's format is either monochrome or paletted, the given \a     index_or_rgb value must be an index in the image's color table,     otherwise the parameter must be a QRgb value.      If \a position is not a valid coordinate pair in the image, or if     \a index_or_rgb>= colorCount() in the case of monochrome and     paletted images, the result is undefined.      \warning This function is expensive due to the call of the internal     \c{detach()} function called within; if performance is a concern, we     recommend the use of scanLine() or bits() to access pixel data directly.      \sa pixel(), {QImage#Pixel Manipulation}{Pixel Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Sets the pixel index or color at (\a x, \a y) to \a index_or_rgb. */
end_comment
begin_function
DECL|function|setPixel
name|void
name|QImage
operator|::
name|setPixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|uint
name|index_or_rgb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|width
argument_list|()
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// detach is called from within scanLine
name|uchar
modifier|*
name|s
init|=
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
if|if
condition|(
name|index_or_rgb
operator|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: Index %d out of range"
argument_list|,
name|index_or_rgb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
argument_list|()
operator|==
name|Format_MonoLSB
condition|)
block|{
if|if
condition|(
name|index_or_rgb
operator|==
literal|0
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index_or_rgb
operator|==
literal|0
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
expr_stmt|;
block|}
return|return;
case|case
name|Format_Indexed8
case|:
if|if
condition|(
name|index_or_rgb
operator|>=
operator|(
name|uint
operator|)
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: Index %d out of range"
argument_list|,
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
index|[
name|x
index|]
operator|=
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_RGB32
case|:
comment|//make sure alpha is 255, we depend on it in qdrawhelper for cases
comment|// when image is set as a texture pattern on a qbrush
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
literal|0xff000000
operator||
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_RGB16
case|:
operator|(
operator|(
name|quint16
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb32To16
argument_list|(
name|qUnpremultiply
argument_list|(
name|index_or_rgb
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_RGBX8888
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|ARGB2RGBA
argument_list|(
literal|0xff000000
operator||
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_RGBA8888
case|:
case|case
name|Format_RGBA8888_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|ARGB2RGBA
argument_list|(
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_BGR30
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb32ToRgb30
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_A2BGR30_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertArgb32ToA2rgb30
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_RGB30
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb32ToRgb30
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_A2RGB30_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertArgb32ToA2rgb30
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_Invalid
case|:
case|case
name|NImageFormats
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|uint
name|result
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|layout
operator|->
name|convertFromARGB32PM
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|index_or_rgb
argument_list|,
literal|1
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|qStorePixels
index|[
name|layout
operator|->
name|bpp
index|]
operator|(
name|s
operator|,
name|ptr
operator|,
name|x
operator|,
literal|1
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QColor QImage::pixelColor(const QPoint&position) const     \since 5.6      Returns the color of the pixel at the given \a position as a QColor.      If the \a position is not valid, an invalid QColor is returned.      \warning This function is expensive when used for massive pixel     manipulations. Use constBits() or constScanLine() when many     pixels needs to be read.      \sa setPixel(), valid(), constBits(), constScanLine(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_comment
comment|/*!     \overload     \since 5.6      Returns the color of the pixel at coordinates (\a x, \a y) as a QColor. */
end_comment
begin_function
DECL|function|pixelColor
name|QColor
name|QImage
operator|::
name|pixelColor
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|d
operator|->
name|width
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::pixelColor: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|QColor
argument_list|()
return|;
block|}
name|QRgba64
name|c
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|s
init|=
name|constScanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_BGR30
case|:
case|case
name|Format_A2BGR30_Premultiplied
case|:
name|c
operator|=
name|qConvertA2rgb30ToRgb64
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|Format_RGB30
case|:
case|case
name|Format_A2RGB30_Premultiplied
case|:
name|c
operator|=
name|qConvertA2rgb30ToRgb64
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|c
operator|=
name|QRgba64
operator|::
name|fromArgb32
argument_list|(
name|pixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// QColor is always unpremultiplied
if|if
condition|(
name|hasAlphaChannel
argument_list|()
operator|&&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
operator|.
name|premultiplied
condition|)
name|c
operator|=
name|c
operator|.
name|unpremultiplied
argument_list|()
expr_stmt|;
return|return
name|QColor
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setPixelColor(const QPoint&position, const QColor&color)     \since 5.6      Sets the color at the given \a position to \a color.      If \a position is not a valid coordinate pair in the image, or     the image's format is either monochrome or paletted, the result is undefined.      \warning This function is expensive due to the call of the internal     \c{detach()} function called within; if performance is a concern, we     recommend the use of scanLine() or bits() to access pixel data directly.      \sa pixel(), bits(), scanLine(), {QImage#Pixel Manipulation}{Pixel Manipulation} */
end_comment
begin_comment
comment|/*!     \overload     \since 5.6      Sets the pixel color at (\a x, \a y) to \a color. */
end_comment
begin_function
DECL|function|setPixelColor
name|void
name|QImage
operator|::
name|setPixelColor
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|width
argument_list|()
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
operator|||
operator|!
name|color
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixelColor: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// QColor is always unpremultiplied
name|QRgba64
name|c
init|=
name|color
operator|.
name|rgba64
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
name|c
operator|.
name|setAlpha
argument_list|(
literal|65535
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
operator|.
name|premultiplied
condition|)
name|c
operator|=
name|c
operator|.
name|premultiplied
argument_list|()
expr_stmt|;
comment|// detach is called from within scanLine
name|uchar
modifier|*
name|s
init|=
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
name|qWarning
argument_list|(
literal|"QImage::setPixelColor: called on monochrome or indexed format"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_BGR30
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
name|c
argument_list|)
operator||
literal|0xc0000000
expr_stmt|;
return|return;
case|case
name|Format_A2BGR30_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderBGR
argument_list|>
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_RGB30
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
name|c
argument_list|)
operator||
literal|0xc0000000
expr_stmt|;
return|return;
case|case
name|Format_A2RGB30_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb64ToRgb30
argument_list|<
name|PixelOrderRGB
argument_list|>
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
default|default:
name|setPixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|c
operator|.
name|toArgb32
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if all the colors in the image are shades of gray     (i.e. their red, green and blue components are equal); otherwise     false.      Note that this function is slow for images without color table.      \sa isGrayscale() */
end_comment
begin_function
DECL|function|allGray
name|bool
name|QImage
operator|::
name|allGray
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|Format_Alpha8
case|:
return|return
literal|false
return|;
case|case
name|Format_Grayscale8
case|:
return|return
literal|true
return|;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
case|case
name|Format_RGBX8888
case|:
case|case
name|Format_RGBA8888
case|:
case|case
name|Format_RGBA8888_Premultiplied
case|:
endif|#
directive|endif
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|b
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|Format_RGB16
case|:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|quint16
modifier|*
name|b
init|=
operator|(
specifier|const
name|quint16
operator|*
operator|)
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|qConvertRgb16To32
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
default|default:
break|break;
block|}
specifier|const
name|int
name|buffer_size
init|=
literal|2048
decl_stmt|;
name|uint
name|buffer
index|[
name|buffer_size
index|]
decl_stmt|;
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|FetchPixelsFunc
name|fetch
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|uchar
modifier|*
name|b
init|=
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|d
operator|->
name|width
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|d
operator|->
name|width
operator|-
name|x
argument_list|,
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|fetch
argument_list|(
name|buffer
argument_list|,
name|b
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|layout
operator|->
name|convertToARGB32PM
argument_list|(
name|buffer
argument_list|,
name|ptr
argument_list|,
name|l
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|x
operator|+=
name|l
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     For 32-bit images, this function is equivalent to allGray().      For color indexed images, this function returns \c true if     color(i) is QRgb(i, i, i) for all indexes of the color table;     otherwise returns \c false.      \sa allGray(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|isGrayscale
name|bool
name|QImage
operator|::
name|isGrayscale
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Alpha8
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Grayscale8
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|depth
argument_list|()
condition|)
block|{
case|case
literal|32
case|:
case|case
literal|24
case|:
case|case
literal|16
case|:
return|return
name|allGray
argument_list|()
return|;
case|case
literal|8
case|:
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colorCount
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode,                              Qt::TransformationMode transformMode) const     \overload      Returns a copy of the image scaled to a rectangle with the given     \a width and \a height according to the given \a aspectRatioMode     and \a transformMode.      If either the \a width or the \a height is zero or negative, this     function returns a null image. */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::scaled(const QSize&size, Qt::AspectRatioMode aspectRatioMode,                              Qt::TransformationMode transformMode) const      Returns a copy of the image scaled to a rectangle defined by the     given \a size according to the given \a aspectRatioMode and \a     transformMode.      \image qimage-scaling.png      \list     \li If \a aspectRatioMode is Qt::IgnoreAspectRatio, the image        is scaled to \a size.     \li If \a aspectRatioMode is Qt::KeepAspectRatio, the image is        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.     \li If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,        the image is scaled to a rectangle as small as possible        outside \a size, preserving the aspect ratio.     \endlist      If the given \a size is empty, this function returns a null image.      \sa isNull(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|scaled
name|QImage
name|QImage
operator|::
name|scaled
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectMode
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaled: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QSize
name|newSize
init|=
name|size
argument_list|()
decl_stmt|;
name|newSize
operator|.
name|scale
argument_list|(
name|s
argument_list|,
name|aspectMode
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rwidth
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|width
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rheight
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|height
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newSize
operator|==
name|size
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|()
argument_list|,
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|height
argument_list|()
operator|/
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QImage
name|img
init|=
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
decl_stmt|;
return|return
name|img
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaledToWidth(int width, Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a width using the specified transformation \a     mode.      This function automatically calculates the height of the image so     that its aspect ratio is preserved.      If the given \a width is 0 or negative, a null image is returned.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|scaledToWidth
name|QImage
name|QImage
operator|::
name|scaledToWidth
parameter_list|(
name|int
name|w
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaleWidth: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|w
operator|/
name|width
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaledToHeight(int height, Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a height using the specified transformation \a     mode.      This function automatically calculates the width of the image so that     the ratio of the image is preserved.      If the given \a height is 0 or negative, a null image is returned.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|scaledToHeight
name|QImage
name|QImage
operator|::
name|scaledToHeight
parameter_list|(
name|int
name|h
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaleHeight: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|h
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|h
operator|/
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix QImage::trueMatrix(const QMatrix&matrix, int width, int height)      Returns the actual matrix used for transforming an image with the     given \a width, \a height and \a matrix.      When transforming an image using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     image containing all transformed points of the original image.     This function returns the modified matrix, which maps points     correctly from the original image into the new image.      \sa transformed(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QMatrix
name|QImage
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|trueMatrix
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the image that is transformed using the given     transformation \a matrix and transformation \a mode.      The transformation \a matrix is internally adjusted to compensate     for unwanted translation; i.e. the image produced is the smallest     image that contains all the transformed points of the original     image. Use the trueMatrix() function to retrieve the actual matrix     used for transforming an image.      \sa trueMatrix(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QImage
name|QImage
operator|::
name|transformed
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
return|return
name|transformed
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Builds and returns a 1-bpp mask from the alpha buffer in this     image. Returns a null image if the image's format is     QImage::Format_RGB32.      The \a flags argument is a bitwise-OR of the     Qt::ImageConversionFlags, and controls the conversion     process. Passing 0 for flags sets all the default options.      The returned image has little-endian bit order (i.e. the image's     format is QImage::Format_MonoLSB), which you can convert to     big-endian (QImage::Format_Mono) using the convertToFormat()     function.      \sa createHeuristicMask(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|createAlphaMask
name|QImage
name|QImage
operator|::
name|createAlphaMask
parameter_list|(
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
comment|// A monochrome pixmap, with alpha channels on those two colors.
comment|// Pretty unlikely, so use less efficient solution.
return|return
name|convertToFormat
argument_list|(
name|Format_Indexed8
argument_list|,
name|flags
argument_list|)
operator|.
name|createAlphaMask
argument_list|(
name|flags
argument_list|)
return|;
block|}
name|QImage
name|mask
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|Format_MonoLSB
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mask
operator|.
name|isNull
argument_list|()
condition|)
name|dither_to_Mono
argument_list|(
name|mask
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGE_HEURISTIC_MASK
end_ifndef
begin_comment
comment|/*!     Creates and returns a 1-bpp heuristic mask for this image.      The function works by selecting a color from one of the corners,     then chipping away pixels of that color starting at all the edges.     The four corners vote for which color is to be masked away. In     case of a draw (this generally means that this function is not     applicable to the image), the result is arbitrary.      The returned image has little-endian bit order (i.e. the image's     format is QImage::Format_MonoLSB), which you can convert to     big-endian (QImage::Format_Mono) using the convertToFormat()     function.      If \a clipTight is true (the default) the mask is just large     enough to cover the pixels; otherwise, the mask is larger than the     data pixels.      Note that this function disregards the alpha buffer.      \sa createAlphaMask(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|createHeuristicMask
name|QImage
name|QImage
operator|::
name|createHeuristicMask
parameter_list|(
name|bool
name|clipTight
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|depth
operator|!=
literal|32
condition|)
block|{
name|QImage
name|img32
init|=
name|convertToFormat
argument_list|(
name|Format_RGB32
argument_list|)
decl_stmt|;
return|return
name|img32
operator|.
name|createHeuristicMask
argument_list|(
name|clipTight
argument_list|)
return|;
block|}
DECL|macro|PIX
define|#
directive|define
name|PIX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(*((const QRgb*)scanLine(y)+x)& 0x00ffffff)
name|int
name|w
init|=
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|height
argument_list|()
decl_stmt|;
name|QImage
name|m
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|fill
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|QRgb
name|background
init|=
name|PIX
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
condition|)
block|{
name|background
operator|=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|==
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
condition|)
block|{
name|background
operator|=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|uchar
modifier|*
name|ypp
decl_stmt|,
modifier|*
name|ypc
decl_stmt|,
modifier|*
name|ypn
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|ypn
operator|=
name|m
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ypc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|ypp
operator|=
name|ypc
expr_stmt|;
name|ypc
operator|=
name|ypn
expr_stmt|;
name|ypn
operator|=
operator|(
name|y
operator|==
name|h
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|m
operator|.
name|scanLine
argument_list|(
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
comment|// slowness here - it's possible to do six of these tests
comment|// together in one go. oh well.
if|if
condition|(
operator|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
operator|||
name|x
operator|==
name|w
operator|-
literal|1
operator|||
name|y
operator|==
name|h
operator|-
literal|1
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypp
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypn
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|*
name|p
operator|&
literal|0x00ffffff
operator|)
operator|==
name|background
operator|)
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
operator|*
operator|(
name|ypc
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|clipTight
condition|)
block|{
name|ypn
operator|=
name|m
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ypc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|ypp
operator|=
name|ypc
expr_stmt|;
name|ypc
operator|=
name|ypn
expr_stmt|;
name|ypn
operator|=
operator|(
name|y
operator|==
name|h
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|m
operator|.
name|scanLine
argument_list|(
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x00ffffff
operator|)
operator|!=
name|background
condition|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
condition|)
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|w
operator|-
literal|1
condition|)
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
operator|*
operator|(
name|ypp
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|h
operator|-
literal|1
condition|)
operator|*
operator|(
name|ypn
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|macro|PIX
undef|#
directive|undef
name|PIX
return|return
name|m
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_IMAGE_HEURISTIC_MASK
end_comment
begin_comment
comment|/*!     Creates and returns a mask for this image based on the given \a     color value. If the \a mode is MaskInColor (the default value),     all pixels matching \a color will be opaque pixels in the mask. If     \a mode is MaskOutColor, all pixels matching the given color will     be transparent.      \sa createAlphaMask(), createHeuristicMask() */
end_comment
begin_function
DECL|function|createMaskFromColor
name|QImage
name|QImage
operator|::
name|createMaskFromColor
parameter_list|(
name|QRgb
name|color
parameter_list|,
name|Qt
operator|::
name|MaskMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|maskImage
argument_list|(
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|maskImage
argument_list|)
expr_stmt|;
name|maskImage
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|s
init|=
name|maskImage
operator|.
name|bits
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
name|d
operator|->
name|height
condition|;
name|h
operator|++
control|)
block|{
specifier|const
name|uint
modifier|*
name|sl
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|scanLine
argument_list|(
name|h
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|d
operator|->
name|width
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
name|sl
index|[
name|w
index|]
operator|==
name|color
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|w
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|w
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|s
operator|+=
name|maskImage
operator|.
name|bytesPerLine
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
name|d
operator|->
name|height
condition|;
name|h
operator|++
control|)
block|{
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|d
operator|->
name|width
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|pixel
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|==
name|color
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|w
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|w
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|s
operator|+=
name|maskImage
operator|.
name|bytesPerLine
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|MaskOutColor
condition|)
name|maskImage
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
return|return
name|maskImage
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::mirrored(bool horizontal = false, bool vertical = true) const     Returns a mirror of the image, mirrored in the horizontal and/or     the vertical direction depending on whether \a horizontal and \a     vertical are set to true or false.      Note that the original image is not changed.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|do_mirror_data
template|template
parameter_list|<
name|class
name|T
parameter_list|>
specifier|inline
name|void
name|do_mirror_data
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
name|QImageData
modifier|*
name|src
parameter_list|,
name|int
name|dstX0
parameter_list|,
name|int
name|dstY0
parameter_list|,
name|int
name|dstXIncr
parameter_list|,
name|int
name|dstYIncr
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|==
name|src
condition|)
block|{
comment|// When mirroring in-place, stop in the middle for one of the directions, since we
comment|// are swapping the bytes instead of merely copying.
specifier|const
name|int
name|srcXEnd
init|=
operator|(
name|dstX0
operator|&&
operator|!
name|dstY0
operator|)
condition|?
name|w
operator|/
literal|2
else|:
name|w
decl_stmt|;
specifier|const
name|int
name|srcYEnd
init|=
name|dstY0
condition|?
name|h
operator|/
literal|2
else|:
name|h
decl_stmt|;
for|for
control|(
name|int
name|srcY
init|=
literal|0
init|,
name|dstY
init|=
name|dstY0
init|;
name|srcY
operator|<
name|srcYEnd
condition|;
operator|++
name|srcY
operator|,
name|dstY
operator|+=
name|dstYIncr
control|)
block|{
name|T
modifier|*
name|srcPtr
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|src
operator|->
name|data
operator|+
name|srcY
operator|*
name|src
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|T
modifier|*
name|dstPtr
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|dst
operator|->
name|data
operator|+
name|dstY
operator|*
name|dst
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
for|for
control|(
name|int
name|srcX
init|=
literal|0
init|,
name|dstX
init|=
name|dstX0
init|;
name|srcX
operator|<
name|srcXEnd
condition|;
operator|++
name|srcX
operator|,
name|dstX
operator|+=
name|dstXIncr
control|)
name|std
operator|::
name|swap
argument_list|(
name|srcPtr
index|[
name|srcX
index|]
argument_list|,
name|dstPtr
index|[
name|dstX
index|]
argument_list|)
expr_stmt|;
block|}
comment|// If mirroring both ways, the middle line needs to be mirrored horizontally only.
if|if
condition|(
name|dstX0
operator|&&
name|dstY0
operator|&&
operator|(
name|h
operator|&
literal|1
operator|)
condition|)
block|{
name|int
name|srcY
init|=
name|h
operator|/
literal|2
decl_stmt|;
name|int
name|srcXEnd2
init|=
name|w
operator|/
literal|2
decl_stmt|;
name|T
modifier|*
name|srcPtr
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|src
operator|->
name|data
operator|+
name|srcY
operator|*
name|src
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
for|for
control|(
name|int
name|srcX
init|=
literal|0
init|,
name|dstX
init|=
name|dstX0
init|;
name|srcX
operator|<
name|srcXEnd2
condition|;
operator|++
name|srcX
operator|,
name|dstX
operator|+=
name|dstXIncr
control|)
name|std
operator|::
name|swap
argument_list|(
name|srcPtr
index|[
name|srcX
index|]
argument_list|,
name|srcPtr
index|[
name|dstX
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|srcY
init|=
literal|0
init|,
name|dstY
init|=
name|dstY0
init|;
name|srcY
operator|<
name|h
condition|;
operator|++
name|srcY
operator|,
name|dstY
operator|+=
name|dstYIncr
control|)
block|{
name|T
modifier|*
name|srcPtr
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|src
operator|->
name|data
operator|+
name|srcY
operator|*
name|src
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|T
modifier|*
name|dstPtr
init|=
operator|(
name|T
operator|*
operator|)
operator|(
name|dst
operator|->
name|data
operator|+
name|dstY
operator|*
name|dst
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
for|for
control|(
name|int
name|srcX
init|=
literal|0
init|,
name|dstX
init|=
name|dstX0
init|;
name|srcX
operator|<
name|w
condition|;
operator|++
name|srcX
operator|,
name|dstX
operator|+=
name|dstXIncr
control|)
name|dstPtr
index|[
name|dstX
index|]
operator|=
name|srcPtr
index|[
name|srcX
index|]
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|do_mirror
specifier|inline
name|void
name|do_mirror
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
name|QImageData
modifier|*
name|src
parameter_list|,
name|bool
name|horizontal
parameter_list|,
name|bool
name|vertical
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dst
operator|->
name|width
operator|&&
name|src
operator|->
name|height
operator|==
name|dst
operator|->
name|height
operator|&&
name|src
operator|->
name|depth
operator|==
name|dst
operator|->
name|depth
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|src
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|src
operator|->
name|height
decl_stmt|;
name|int
name|depth
init|=
name|src
operator|->
name|depth
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
name|w
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|// byte aligned width
name|depth
operator|=
literal|8
expr_stmt|;
block|}
name|int
name|dstX0
init|=
literal|0
decl_stmt|,
name|dstXIncr
init|=
literal|1
decl_stmt|;
name|int
name|dstY0
init|=
literal|0
decl_stmt|,
name|dstYIncr
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|horizontal
condition|)
block|{
comment|// 0 -> w-1, 1 -> w-2, 2 -> w-3, ...
name|dstX0
operator|=
name|w
operator|-
literal|1
expr_stmt|;
name|dstXIncr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vertical
condition|)
block|{
comment|// 0 -> h-1, 1 -> h-2, 2 -> h-3, ...
name|dstY0
operator|=
name|h
operator|-
literal|1
expr_stmt|;
name|dstYIncr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|32
case|:
name|do_mirror_data
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstXIncr
argument_list|,
name|dstYIncr
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|do_mirror_data
argument_list|<
name|quint24
argument_list|>
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstXIncr
argument_list|,
name|dstYIncr
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|do_mirror_data
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstXIncr
argument_list|,
name|dstYIncr
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|do_mirror_data
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dstX0
argument_list|,
name|dstY0
argument_list|,
name|dstXIncr
argument_list|,
name|dstYIncr
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// The bytes are now all in the correct place. In addition, the bits in the individual
comment|// bytes have to be flipped too when horizontally mirroring a 1 bit-per-pixel image.
if|if
condition|(
name|horizontal
operator|&&
name|dst
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
specifier|const
name|int
name|shift
init|=
literal|8
operator|-
operator|(
name|dst
operator|->
name|width
operator|%
literal|8
operator|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|bitflip
init|=
name|qt_get_bitflip_array
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|uchar
modifier|*
name|begin
init|=
name|dst
operator|->
name|data
operator|+
name|y
operator|*
name|dst
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|end
init|=
name|begin
operator|+
name|dst
operator|->
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|uchar
modifier|*
name|p
init|=
name|begin
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
operator|*
name|p
operator|=
name|bitflip
index|[
operator|*
name|p
index|]
expr_stmt|;
comment|// When the data is non-byte aligned, an extra bit shift (of the number of
comment|// unused bits at the end) is needed for the entire scanline.
if|if
condition|(
name|shift
operator|!=
literal|8
operator|&&
name|p
operator|!=
name|begin
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shift
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|<<=
literal|1
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator||=
operator|(
operator|*
name|p
operator|&
operator|(
literal|128
operator|>>
name|i
operator|)
operator|)
operator|>>
operator|(
literal|7
operator|-
name|i
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shift
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|>>=
literal|1
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator||=
operator|(
operator|*
name|p
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|shift
operator|!=
literal|8
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
name|end
index|[
operator|-
literal|1
index|]
operator|<<=
name|shift
expr_stmt|;
else|else
name|end
index|[
operator|-
literal|1
index|]
operator|>>=
name|shift
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mirrored_helper
name|QImage
name|QImage
operator|::
name|mirrored_helper
parameter_list|(
name|bool
name|horizontal
parameter_list|,
name|bool
name|vertical
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|width
operator|<=
literal|1
operator|&&
name|d
operator|->
name|height
operator|<=
literal|1
operator|)
operator|||
operator|(
operator|!
name|horizontal
operator|&&
operator|!
name|vertical
operator|)
condition|)
return|return
operator|*
name|this
return|;
comment|// Create result image, copy colormap
name|QImage
name|result
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// check if we ran out of of memory..
if|if
condition|(
operator|!
name|result
operator|.
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|result
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
name|copyMetadata
argument_list|(
name|result
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|do_mirror
argument_list|(
name|result
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|horizontal
argument_list|,
name|vertical
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|mirrored_inplace
name|void
name|QImage
operator|::
name|mirrored_inplace
parameter_list|(
name|bool
name|horizontal
parameter_list|,
name|bool
name|vertical
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|(
name|d
operator|->
name|width
operator|<=
literal|1
operator|&&
name|d
operator|->
name|height
operator|<=
literal|1
operator|)
operator|||
operator|(
operator|!
name|horizontal
operator|&&
operator|!
name|vertical
operator|)
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|do_mirror
argument_list|(
name|d
argument_list|,
name|d
argument_list|,
name|horizontal
argument_list|,
name|vertical
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::rgbSwapped() const     Returns a QImage in which the values of the red and blue     components of all pixels have been swapped, effectively converting     an RGB image to an BGR image.      The original QImage is not changed.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|rgbSwapped_generic
specifier|inline
name|void
name|rgbSwapped_generic
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
specifier|const
name|QImage
modifier|*
name|src
parameter_list|,
name|QImage
modifier|*
name|dst
parameter_list|,
specifier|const
name|QPixelLayout
modifier|*
name|layout
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|layout
operator|->
name|redWidth
operator|==
name|layout
operator|->
name|blueWidth
argument_list|)
expr_stmt|;
name|FetchPixelsFunc
name|fetch
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
name|StorePixelsFunc
name|store
init|=
name|qStorePixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
specifier|const
name|uint
name|redBlueMask
init|=
operator|(
literal|1
operator|<<
name|layout
operator|->
name|redWidth
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint
name|alphaGreenMask
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
name|layout
operator|->
name|alphaWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|layout
operator|->
name|alphaShift
operator|)
operator||
operator|(
operator|(
operator|(
literal|1
operator|<<
name|layout
operator|->
name|greenWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|layout
operator|->
name|greenShift
operator|)
decl_stmt|;
specifier|const
name|int
name|buffer_size
init|=
literal|2048
decl_stmt|;
name|uint
name|buffer
index|[
name|buffer_size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
operator|++
name|i
control|)
block|{
name|uchar
modifier|*
name|q
init|=
name|dst
operator|->
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|p
init|=
name|src
operator|->
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|width
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|width
operator|-
name|x
argument_list|,
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|fetch
argument_list|(
name|buffer
argument_list|,
name|p
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
condition|;
operator|++
name|j
control|)
block|{
name|uint
name|red
init|=
operator|(
name|ptr
index|[
name|j
index|]
operator|>>
name|layout
operator|->
name|redShift
operator|)
operator|&
name|redBlueMask
decl_stmt|;
name|uint
name|blue
init|=
operator|(
name|ptr
index|[
name|j
index|]
operator|>>
name|layout
operator|->
name|blueShift
operator|)
operator|&
name|redBlueMask
decl_stmt|;
name|buffer
index|[
name|j
index|]
operator|=
operator|(
name|ptr
index|[
name|j
index|]
operator|&
name|alphaGreenMask
operator|)
operator||
operator|(
name|red
operator|<<
name|layout
operator|->
name|blueShift
operator|)
operator||
operator|(
name|blue
operator|<<
name|layout
operator|->
name|redShift
operator|)
expr_stmt|;
block|}
name|store
argument_list|(
name|q
argument_list|,
name|buffer
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|x
operator|+=
name|l
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rgbSwapped_helper
name|QImage
name|QImage
operator|::
name|rgbSwapped_helper
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QImage
name|res
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Invalid
case|:
case|case
name|NImageFormats
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|Format_Alpha8
case|:
case|case
name|Format_Grayscale8
case|:
return|return
operator|*
name|this
return|;
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
name|res
operator|=
name|copy
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QRgb
name|c
init|=
name|res
operator|.
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|res
operator|.
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|QRgb
argument_list|(
operator|(
operator|(
name|c
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|c
operator|&
literal|0xff00ff00
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
case|case
name|Format_RGBX8888
case|:
case|case
name|Format_RGBA8888
case|:
case|case
name|Format_RGBA8888_Premultiplied
case|:
endif|#
directive|endif
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|c
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
name|c
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|c
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Format_RGB16
case|:
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|ushort
modifier|*
name|q
init|=
operator|(
name|ushort
operator|*
operator|)
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|ushort
name|c
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
name|c
operator|<<
literal|11
operator|)
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|c
operator|&
literal|0x07e0
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Format_BGR30
case|:
case|case
name|Format_A2BGR30_Premultiplied
case|:
case|case
name|Format_RGB30
case|:
case|case
name|Format_A2RGB30_Premultiplied
case|:
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
name|qRgbSwapRgb30
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|rgbSwapped_generic
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|this
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|copyMetadata
argument_list|(
name|res
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rgbSwapped_inplace
name|void
name|QImage
operator|::
name|rgbSwapped_inplace
parameter_list|()
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Invalid
case|:
case|case
name|NImageFormats
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|Format_Alpha8
case|:
case|case
name|Format_Grayscale8
case|:
return|return;
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QRgb
name|c
init|=
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|QRgb
argument_list|(
operator|(
operator|(
name|c
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|c
operator|&
literal|0xff00ff00
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
case|case
name|Format_RGBX8888
case|:
case|case
name|Format_RGBA8888
case|:
case|case
name|Format_RGBA8888_Premultiplied
case|:
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|c
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|(
name|c
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|c
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Format_RGB16
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|ushort
modifier|*
name|p
init|=
operator|(
name|ushort
operator|*
operator|)
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|ushort
name|c
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|(
name|c
operator|<<
literal|11
operator|)
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|c
operator|&
literal|0x07e0
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Format_BGR30
case|:
case|case
name|Format_A2BGR30_Premultiplied
case|:
case|case
name|Format_RGB30
case|:
case|case
name|Format_A2RGB30_Premultiplied
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|p
operator|=
name|qRgbSwapRgb30
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|rgbSwapped_generic
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|this
argument_list|,
name|this
argument_list|,
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Loads an image from the file with the given \a fileName. Returns \c true if     the image was successfully loaded; otherwise invalidates the image     and returns \c false.      The loader attempts to read the image using the specified \a format, e.g.,     PNG or JPG. If \a format is not specified (which is the default), the     loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|load
name|bool
name|QImage
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|QImageReader
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads a QImage from the given \a device. This can,     for example, be used to load an image directly into a QByteArray. */
end_comment
begin_function
DECL|function|load
name|bool
name|QImage
operator|::
name|load
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|QImageReader
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::loadFromData(const uchar *data, int len, const char *format)      Loads an image from the first \a len bytes of the given binary \a     data. Returns \c true if the image was successfully loaded; otherwise     invalidates the image and returns \c false.      The loader attempts to read the image using the specified \a format, e.g.,     PNG or JPG. If \a format is not specified (which is the default), the     loader probes the file for a header to guess the file format.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|loadFromData
name|bool
name|QImage
operator|::
name|loadFromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|fromData
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::loadFromData(const QByteArray&data, const char *format)      \overload      Loads an image from the given QByteArray \a data. */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::fromData(const uchar *data, int size, const char *format)      Constructs a QImage from the first \a size bytes of the given     binary \a data. The loader attempts to read the image using the     specified \a format. If \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.     binary \a data. The loader attempts to read the image, either using the     optional image \a format specified or by determining the image format from     the data.      If \a format is not specified (which is the default), the loader probes the     file for a header to determine the file format. If \a format is specified,     it must be one of the values returned by QImageReader::supportedImageFormats().      If the loading of the image fails, the image returned will be a null image.      \sa load(), save(), {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}  */
end_comment
begin_function
DECL|function|fromData
name|QImage
name|QImage
operator|::
name|fromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QByteArray
name|a
init|=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|QBuffer
name|b
decl_stmt|;
name|b
operator|.
name|setData
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
return|return
name|QImageReader
argument_list|(
operator|&
name|b
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::fromData(const QByteArray&data, const char *format)      \overload      Loads an image from the given QByteArray \a data. */
end_comment
begin_comment
comment|/*!     Saves the image to the file with the given \a fileName, using the     given image file \a format and \a quality factor. If \a format is     0, QImage will attempt to guess the format by looking at \a fileName's     suffix.      The \a quality factor must be in the range 0 to 100 or -1. Specify     0 to obtain small compressed files, 100 for large uncompressed     files, and -1 (the default) to use the default settings.      Returns \c true if the image was successfully saved; otherwise     returns \c false.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_function
DECL|function|save
name|bool
name|QImage
operator|::
name|save
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
name|QImageWriter
name|writer
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|doImageIO
argument_list|(
name|this
argument_list|,
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function writes a QImage to the given \a device.      This can, for example, be used to save an image directly into a     QByteArray:      \snippet image/image.cpp 0 */
end_comment
begin_function
DECL|function|save
name|bool
name|QImage
operator|::
name|save
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|doImageIO
argument_list|(
name|this
argument_list|,
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* \internal */
end_comment
begin_function
DECL|function|doImageIO
name|bool
name|QImageData
operator|::
name|doImageIO
parameter_list|(
specifier|const
name|QImage
modifier|*
name|image
parameter_list|,
name|QImageWriter
modifier|*
name|writer
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|quality
operator|>
literal|100
operator|||
name|quality
operator|<
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QPixmap::save: Quality out of range [-1, 100]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|>=
literal|0
condition|)
name|writer
operator|->
name|setQuality
argument_list|(
name|qMin
argument_list|(
name|quality
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|writer
operator|->
name|write
argument_list|(
operator|*
name|image
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QImage stream functions  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
end_if
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QImage&image)     \relates QImage      Writes the given \a image to the given \a stream as a PNG image,     or as a BMP image if the stream's version is 1. Note that writing     the stream to a file will not produce a valid image file.      \sa QImage::save(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
literal|5
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
operator|(
name|qint32
operator|)
literal|0
expr_stmt|;
comment|// null image marker
return|return
name|s
return|;
block|}
else|else
block|{
name|s
operator|<<
operator|(
name|qint32
operator|)
literal|1
expr_stmt|;
comment|// continue ...
block|}
block|}
name|QImageWriter
name|writer
argument_list|(
name|s
operator|.
name|device
argument_list|()
argument_list|,
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|?
literal|"bmp"
else|:
literal|"png"
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QImage&image)     \relates QImage      Reads an image from the given \a stream and stores it in the given     \a image.      \sa QImage::load(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
literal|5
condition|)
block|{
name|qint32
name|nullMarker
decl_stmt|;
name|s
operator|>>
name|nullMarker
expr_stmt|;
if|if
condition|(
operator|!
name|nullMarker
condition|)
block|{
name|image
operator|=
name|QImage
argument_list|()
expr_stmt|;
comment|// null image
return|return
name|s
return|;
block|}
block|}
name|image
operator|=
name|QImageReader
argument_list|(
name|s
operator|.
name|device
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|.
name|read
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \fn bool QImage::operator==(const QImage& image) const      Returns \c true if this image and the given \a image have the same     contents; otherwise returns \c false.      The comparison can be slow, unless there is some obvious     difference (e.g. different size or format), in which case the     function will return quickly.      \sa operator=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QImage
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
comment|// same object, or shared?
if|if
condition|(
name|i
operator|.
name|d
operator|==
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|i
operator|.
name|d
operator|||
operator|!
name|d
condition|)
return|return
literal|false
return|;
comment|// obviously different stuff?
if|if
condition|(
name|i
operator|.
name|d
operator|->
name|height
operator|!=
name|d
operator|->
name|height
operator|||
name|i
operator|.
name|d
operator|->
name|width
operator|!=
name|d
operator|->
name|width
operator|||
name|i
operator|.
name|d
operator|->
name|format
operator|!=
name|d
operator|->
name|format
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|format
operator|!=
name|Format_RGB32
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|>=
name|Format_ARGB32
condition|)
block|{
comment|// all bits defined
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|width
operator|*
name|d
operator|->
name|depth
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|d
operator|->
name|bytes_per_line
operator|&&
name|n
operator|==
name|i
operator|.
name|d
operator|->
name|bytes_per_line
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|bits
argument_list|()
argument_list|,
name|i
operator|.
name|bits
argument_list|()
argument_list|,
name|d
operator|->
name|nbytes
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|i
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|n
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|int
name|w
init|=
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|height
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|colortable
init|=
name|d
operator|->
name|colortable
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|icolortable
init|=
name|i
operator|.
name|d
operator|->
name|colortable
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|colortable
index|[
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
index|]
operator|!=
name|icolortable
index|[
name|i
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
index|]
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|//alpha channel undefined, so we must mask it out
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|d
operator|->
name|height
condition|;
name|l
operator|++
control|)
block|{
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p1
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint
operator|*
argument_list|>
argument_list|(
name|scanLine
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p2
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|scanLine
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|++
operator|&
literal|0x00ffffff
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|++
operator|&
literal|0x00ffffff
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::operator!=(const QImage& image) const      Returns \c true if this image and the given \a image have different     contents; otherwise returns \c false.      The comparison can be slow, unless there is some obvious     difference, such as different widths, in which case the function     will return quickly.      \sa operator=() */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QImage
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|i
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of pixels that fit horizontally in a physical     meter. Together with dotsPerMeterY(), this number defines the     intended scale and aspect ratio of the image.      \sa setDotsPerMeterX(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|dotsPerMeterX
name|int
name|QImage
operator|::
name|dotsPerMeterX
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|qRound
argument_list|(
name|d
operator|->
name|dpmx
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of pixels that fit vertically in a physical     meter. Together with dotsPerMeterX(), this number defines the     intended scale and aspect ratio of the image.      \sa setDotsPerMeterY(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|dotsPerMeterY
name|int
name|QImage
operator|::
name|dotsPerMeterY
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|qRound
argument_list|(
name|d
operator|->
name|dpmy
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of pixels that fit horizontally in a physical     meter, to \a x.      Together with dotsPerMeterY(), this number defines the intended     scale and aspect ratio of the image, and determines the scale     at which QPainter will draw graphics on the image. It does not     change the scale or aspect ratio of the image when it is rendered     on other paint devices.      \sa dotsPerMeterX(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setDotsPerMeterX
name|void
name|QImage
operator|::
name|setDotsPerMeterX
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|x
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|dpmx
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of pixels that fit vertically in a physical meter,     to \a y.      Together with dotsPerMeterX(), this number defines the intended     scale and aspect ratio of the image, and determines the scale     at which QPainter will draw graphics on the image. It does not     change the scale or aspect ratio of the image when it is rendered     on other paint devices.      \sa dotsPerMeterY(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setDotsPerMeterY
name|void
name|QImage
operator|::
name|setDotsPerMeterY
parameter_list|(
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|y
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|dpmy
operator|=
name|y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QImage::offset() const      Returns the number of pixels by which the image is intended to be     offset by when positioning relative to other images.      \sa setOffset(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|offset
name|QPoint
name|QImage
operator|::
name|offset
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|offset
else|:
name|QPoint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setOffset(const QPoint& offset)      Sets the number of pixels by which the image is intended to be     offset by when positioning relative to other images, to \a offset.      \sa offset(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setOffset
name|void
name|QImage
operator|::
name|setOffset
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|offset
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the text keys for this image.      You can use these keys with text() to list the image text for a     certain key.      \sa text() */
end_comment
begin_function
DECL|function|textKeys
name|QStringList
name|QImage
operator|::
name|textKeys
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QStringList
argument_list|(
name|d
operator|->
name|text
operator|.
name|keys
argument_list|()
argument_list|)
else|:
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the image text associated with the given \a key. If the     specified \a key is an empty string, the whole image text is     returned, with each key-text pair separated by a newline.      \sa setText(), textKeys() */
end_comment
begin_function
DECL|function|text
name|QString
name|QImage
operator|::
name|text
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|text
operator|.
name|value
argument_list|(
name|key
argument_list|)
return|;
name|QString
name|tmp
decl_stmt|;
for|for
control|(
name|auto
name|it
init|=
name|d
operator|->
name|text
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|d
operator|->
name|text
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|tmp
operator|+=
name|it
operator|.
name|key
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
operator|+
name|it
operator|.
name|value
argument_list|()
operator|.
name|simplified
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|tmp
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// remove final \n\n
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setText(const QString&key, const QString&text)      Sets the image text to the given \a text and associate it with the     given \a key.      If you just want to store a single text block (i.e., a "comment"     or just a description), you can either pass an empty key, or use a     generic key like "Description".      The image text is embedded into the image data when you     call save() or QImageWriter::write().      Not all image formats support embedded text. You can find out     if a specific image or format supports embedding text     by using QImageWriter::supportsOption(). We give an example:      \snippet image/supportedformat.cpp 0      You can use QImageWriter::supportedImageFormats() to find out     which image formats are available to you.      \sa text(), textKeys() */
end_comment
begin_function
DECL|function|setText
name|void
name|QImage
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|text
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QImage::text(const char* key, const char* language) const     \obsolete      Returns the text recorded for the given \a key in the given \a     language, or in a default language if \a language is 0.      Use text() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation. */
end_comment
begin_comment
comment|/*!     \fn QString QImage::text(const QImageTextKeyLang& keywordAndLanguage) const     \overload     \obsolete      Returns the text recorded for the given \a keywordAndLanguage.      Use text() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation. */
end_comment
begin_comment
comment|/*!     \fn void QImage::setText(const char* key, const char* language, const QString& text)     \obsolete      Sets the image text to the given \a text and associate it with the     given \a key. The text is recorded in the specified \a language,     or in a default language if \a language is 0.      Use setText() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation.      \omit     Records string \a  for the keyword \a key. The \a key should be     a portable keyword recognizable by other software - some suggested     values can be found in     \l{http://www.libpng.org/pub/png/spec/1.2/png-1.2-pdg.html#C.Anc-text}     {the PNG specification}. \a s can be any text. \a lang should     specify the language code (see     \l{http://www.rfc-editor.org/rfc/rfc1766.txt}{RFC 1766}) or 0.     \endomit */
end_comment
begin_comment
comment|/*     Sets the image bits to the \a pixmap contents and returns a     reference to the image.      If the image shares data with other images, it will first     dereference the shared data.      Makes a call to QPixmap::convertToImage(). */
end_comment
begin_comment
comment|/*!     \internal      Used by QPainter to retrieve a paint engine for the image. */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QImage
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|paintEngine
condition|)
block|{
name|QPaintDevice
modifier|*
name|paintDevice
init|=
cast|const_cast
argument_list|<
name|QImage
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QPaintEngine
modifier|*
name|paintEngine
init|=
literal|0
decl_stmt|;
name|QPlatformIntegration
modifier|*
name|platformIntegration
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
decl_stmt|;
if|if
condition|(
name|platformIntegration
condition|)
name|paintEngine
operator|=
name|platformIntegration
operator|->
name|createImagePaintEngine
argument_list|(
name|paintDevice
argument_list|)
expr_stmt|;
name|d
operator|->
name|paintEngine
operator|=
name|paintEngine
condition|?
name|paintEngine
else|:
operator|new
name|QRasterPaintEngine
argument_list|(
name|paintDevice
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|paintEngine
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the size for the specified \a metric on the device. */
end_comment
begin_function
DECL|function|metric
name|int
name|QImage
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmWidth
case|:
return|return
name|d
operator|->
name|width
return|;
case|case
name|PdmHeight
case|:
return|return
name|d
operator|->
name|height
return|;
case|case
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|width
operator|*
literal|1000
operator|/
name|d
operator|->
name|dpmx
argument_list|)
return|;
case|case
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|height
operator|*
literal|1000
operator|/
name|d
operator|->
name|dpmy
argument_list|)
return|;
case|case
name|PdmNumColors
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
return|;
case|case
name|PdmDepth
case|:
return|return
name|d
operator|->
name|depth
return|;
case|case
name|PdmDpiX
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmDpiY
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmPhysicalDpiX
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmx
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmPhysicalDpiY
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmy
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmDevicePixelRatio
case|:
return|return
name|d
operator|->
name|devicePixelRatio
return|;
break|break;
case|case
name|PdmDevicePixelRatioScaled
case|:
return|return
name|d
operator|->
name|devicePixelRatio
operator|*
name|QPaintDevice
operator|::
name|devicePixelRatioFScale
argument_list|()
return|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QImage::metric(): Unhandled metric type %d"
argument_list|,
name|metric
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPixmap (and QImage) helper functions  *****************************************************************************/
end_comment
begin_comment
comment|/*   This internal function contains the common (i.e. platform independent) code   to do a transformation of pixel data. It is used by QPixmap::transform() and by   QImage::transform().    \a trueMat is the true transformation matrix (see QPixmap::trueMatrix()) and   \a xoffset is an offset to the matrix.    \a msbfirst specifies for 1bpp images, if the MSB or LSB comes first and \a   depth specifies the colordepth of the data.    \a dptr is a pointer to the destination data, \a dbpl specifies the bits per   line for the destination data, \a p_inc is the offset that we advance for   every scanline and \a dHeight is the height of the destination image.    \a sprt is the pointer to the source data, \a sbpl specifies the bits per   line of the source data, \a sWidth and \a sHeight are the width and height of   the source data. */
end_comment
begin_undef
DECL|macro|IWX_MSB
undef|#
directive|undef
name|IWX_MSB
end_undef
begin_define
DECL|macro|IWX_MSB
define|#
directive|define
name|IWX_MSB
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if (*(sptr+sbpl*(trigy>>12)+(trigx>>15))&                      \                                  (1<< (7-((trigx>>12)&7))))                              \                                 *dptr |= b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_undef
DECL|macro|IWX_LSB
undef|#
directive|undef
name|IWX_LSB
end_undef
begin_define
DECL|macro|IWX_LSB
define|#
directive|define
name|IWX_LSB
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if (*(sptr+sbpl*(trigy>>12)+(trigx>>15))&                      \                                  (1<< ((trigx>>12)&7)))                              \                                 *dptr |= b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_undef
DECL|macro|IWX_PIX
undef|#
directive|undef
name|IWX_PIX
end_undef
begin_define
DECL|macro|IWX_PIX
define|#
directive|define
name|IWX_PIX
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if ((*(sptr+sbpl*(trigy>>12)+(trigx>>15))&              \                                  (1<< (7-((trigx>>12)&7)))) == 0)                      \                                 *dptr&= ~b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_function
DECL|function|qt_xForm_helper
name|bool
name|qt_xForm_helper
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|trueMat
parameter_list|,
name|int
name|xoffset
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|depth
parameter_list|,
name|uchar
modifier|*
name|dptr
parameter_list|,
name|int
name|dbpl
parameter_list|,
name|int
name|p_inc
parameter_list|,
name|int
name|dHeight
parameter_list|,
specifier|const
name|uchar
modifier|*
name|sptr
parameter_list|,
name|int
name|sbpl
parameter_list|,
name|int
name|sWidth
parameter_list|,
name|int
name|sHeight
parameter_list|)
block|{
name|int
name|m11
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m11
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m12
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m12
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m21
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m21
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m22
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m22
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|dx
init|=
name|qRound
argument_list|(
name|trueMat
operator|.
name|dx
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|dy
init|=
name|qRound
argument_list|(
name|trueMat
operator|.
name|dy
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m21ydx
init|=
name|dx
operator|+
operator|(
name|xoffset
operator|<<
literal|16
operator|)
operator|+
operator|(
name|m11
operator|+
name|m21
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|m22ydy
init|=
name|dy
operator|+
operator|(
name|m12
operator|+
name|m22
operator|)
operator|/
literal|2
decl_stmt|;
name|uint
name|trigx
decl_stmt|;
name|uint
name|trigy
decl_stmt|;
name|uint
name|maxws
init|=
name|sWidth
operator|<<
literal|12
decl_stmt|;
name|uint
name|maxhs
init|=
name|sHeight
operator|<<
literal|12
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dHeight
condition|;
name|y
operator|++
control|)
block|{
comment|// for each target scanline
name|trigx
operator|=
name|m21ydx
expr_stmt|;
name|trigy
operator|=
name|m22ydy
expr_stmt|;
name|uchar
modifier|*
name|maxp
init|=
name|dptr
operator|+
name|dbpl
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|1
condition|)
block|{
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|8
case|:
comment|// 8 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
name|dptr
operator|=
operator|*
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
comment|// 16 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|dptr
operator|)
operator|=
operator|*
operator|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
comment|// 24 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|p2
init|=
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|*
literal|3
operator|)
decl_stmt|;
name|dptr
index|[
literal|0
index|]
operator|=
name|p2
index|[
literal|0
index|]
expr_stmt|;
name|dptr
index|[
literal|1
index|]
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
name|dptr
index|[
literal|2
index|]
operator|=
name|p2
index|[
literal|2
index|]
expr_stmt|;
block|}
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
comment|// 32 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
operator|(
operator|(
name|uint
operator|*
operator|)
name|dptr
operator|)
operator|=
operator|*
operator|(
operator|(
specifier|const
name|uint
operator|*
operator|)
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QT_XFORM_TYPE_MSBFIRST
case|:
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
name|IWX_MSB
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|QT_XFORM_TYPE_LSBFIRST
case|:
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
name|IWX_LSB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
name|m21ydx
operator|+=
name|m21
expr_stmt|;
name|m22ydy
operator|+=
name|m22
expr_stmt|;
name|dptr
operator|+=
name|p_inc
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_undef
DECL|macro|IWX_MSB
undef|#
directive|undef
name|IWX_MSB
end_undef
begin_undef
DECL|macro|IWX_LSB
undef|#
directive|undef
name|IWX_LSB
end_undef
begin_undef
DECL|macro|IWX_PIX
undef|#
directive|undef
name|IWX_PIX
end_undef
begin_comment
comment|/*! \fn int QImage::serialNumber() const     \obsolete     Returns a number that identifies the contents of this     QImage object. Distinct QImage objects can only have the same     serial number if they refer to the same contents (but they don't     have to).      Use cacheKey() instead.      \warning The serial number doesn't necessarily change when the     image is altered. This means that it may be dangerous to use     it as a cache key.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns a number that identifies the contents of this QImage     object. Distinct QImage objects can only have the same key if they     refer to the same contents.      The key will change when the image is altered. */
end_comment
begin_function
DECL|function|cacheKey
name|qint64
name|QImage
operator|::
name|cacheKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
operator|(
operator|(
name|qint64
operator|)
name|d
operator|->
name|ser_no
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|qint64
operator|)
name|d
operator|->
name|detach_no
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns \c true if the image is detached; otherwise returns \c false.      \sa detach(), {Implicit Data Sharing} */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QImage
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     Sets the alpha channel of this image to the given \a alphaChannel.      If \a alphaChannel is an 8 bit grayscale image, the intensity values are     written into this buffer directly. Otherwise, \a alphaChannel is converted     to 32 bit and the intensity of the RGB pixel values is used.      Note that the image will be converted to the Format_ARGB32_Premultiplied     format if the function succeeds.      Use one of the composition modes in QPainter::CompositionMode instead.      \warning This function is expensive.      \sa alphaChannel(), {QImage#Image Transformations}{Image     Transformations}, {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|setAlphaChannel
name|void
name|QImage
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QImage
modifier|&
name|alphaChannel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|height
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|alphaChannel
operator|.
name|d
operator|->
name|width
operator|||
name|h
operator|!=
name|alphaChannel
operator|.
name|d
operator|->
name|height
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setAlphaChannel: "
literal|"Alpha channel must have same dimensions as the target image"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|paintEngine
operator|&&
name|d
operator|->
name|paintEngine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setAlphaChannel: "
literal|"Unable to set alpha channel while image is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
name|detach
argument_list|()
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
comment|// Slight optimization since alphachannels are returned as 8-bit grays.
if|if
condition|(
name|alphaChannel
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Alpha8
operator|||
operator|(
name|alphaChannel
operator|.
name|d
operator|->
name|depth
operator|==
literal|8
operator|&&
name|alphaChannel
operator|.
name|isGrayscale
argument_list|()
operator|)
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|alphaChannel
operator|.
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|src_data
decl_stmt|;
name|QRgb
modifier|*
name|dest
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|alpha
init|=
operator|*
name|src
decl_stmt|;
name|int
name|destAlpha
init|=
name|qt_div_255
argument_list|(
name|alpha
operator|*
name|qAlpha
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|(
name|destAlpha
operator|<<
literal|24
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|alphaChannel
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|QImage
name|sourceImage
init|=
name|alphaChannel
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|sourceImage
operator|.
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
name|QRgb
modifier|*
name|dest
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|alpha
init|=
name|qGray
argument_list|(
operator|*
name|src
argument_list|)
decl_stmt|;
name|int
name|destAlpha
init|=
name|qt_div_255
argument_list|(
name|alpha
operator|*
name|qAlpha
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|(
name|destAlpha
operator|<<
literal|24
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|sourceImage
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns the alpha channel of the image as a new grayscale QImage in which     each pixel's red, green, and blue values are given the alpha value of the     original image. The color depth of the returned image is 8-bit.      You can see an example of use of this function in QPixmap's     \l{QPixmap::}{alphaChannel()}, which works in the same way as     this function on QPixmaps.      Most usecases for this function can be replaced with QPainter and     using composition modes.      Note this returns a color-indexed image if you want the alpha channel in     the alpha8 format instead use convertToFormat(Format_Alpha8) on the source     image.      \warning This is an expensive function.      \sa setAlphaChannel(), hasAlphaChannel(), convertToFormat(),     {QPixmap#Pixmap Information}{Pixmap},     {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|alphaChannel
name|QImage
name|QImage
operator|::
name|alphaChannel
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|height
decl_stmt|;
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|Format_Indexed8
argument_list|)
decl_stmt|;
name|image
operator|.
name|setColorCount
argument_list|(
literal|256
argument_list|)
expr_stmt|;
comment|// set up gray scale table.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|image
operator|.
name|setColor
argument_list|(
name|i
argument_list|,
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|image
operator|.
name|fill
argument_list|(
literal|255
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Indexed8
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|image
operator|.
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|src_data
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
name|dest
operator|=
name|qAlpha
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Alpha8
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|image
operator|.
name|d
operator|->
name|data
decl_stmt|;
name|memcpy
argument_list|(
name|dest_data
argument_list|,
name|src_data
argument_list|,
name|d
operator|->
name|bytes_per_line
operator|*
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QImage
name|alpha32
init|=
operator|*
name|this
decl_stmt|;
name|bool
name|canSkipConversion
init|=
operator|(
name|d
operator|->
name|format
operator|==
name|Format_ARGB32
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB32_Premultiplied
operator|)
decl_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
name|canSkipConversion
operator|=
name|canSkipConversion
operator|||
operator|(
name|d
operator|->
name|format
operator|==
name|Format_RGBA8888
operator|||
name|d
operator|->
name|format
operator|==
name|Format_RGBA8888_Premultiplied
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|canSkipConversion
condition|)
name|alpha32
operator|=
name|convertToFormat
argument_list|(
name|Format_ARGB32
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|alpha32
operator|.
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|image
operator|.
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
name|dest
operator|=
name|qAlpha
argument_list|(
operator|*
name|src
argument_list|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|alpha32
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the image has a format that respects the alpha     channel, otherwise returns \c false.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QImage
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
specifier|const
name|QPixelFormat
name|format
init|=
name|pixelFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|alphaUsage
argument_list|()
operator|==
name|QPixelFormat
operator|::
name|UsesAlpha
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|format
operator|.
name|colorModel
argument_list|()
operator|==
name|QPixelFormat
operator|::
name|Indexed
condition|)
return|return
name|d
operator|->
name|has_alpha_clut
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the number of bit planes in the image.      The number of bit planes is the number of bits of color and     transparency information for each pixel. This is different from     (i.e. smaller than) the depth when the image format contains     unused bits.      \sa depth(), format(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|bitPlaneCount
name|int
name|QImage
operator|::
name|bitPlaneCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|int
name|bpc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Invalid
case|:
break|break;
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
name|bpc
operator|=
literal|30
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
name|bpc
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
name|bpc
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
name|bpc
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
name|bpc
operator|=
literal|23
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|bpc
operator|=
name|qt_depthForFormat
argument_list|(
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|bpc
return|;
block|}
end_function
begin_comment
comment|/*!    Returns a smoothly scaled copy of the image. The returned image has a size    of width \a w by height \a h pixels. */
end_comment
begin_function
DECL|function|smoothScaled
name|QImage
name|QImage
operator|::
name|smoothScaled
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
specifier|const
block|{
name|QImage
name|src
init|=
operator|*
name|this
decl_stmt|;
switch|switch
condition|(
name|src
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
endif|#
directive|endif
case|case
name|QImage
operator|::
name|Format_RGBA8888_Premultiplied
case|:
break|break;
default|default:
if|if
condition|(
name|src
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|src
operator|=
name|src
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|src
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|qSmoothScaleImage
argument_list|(
name|src
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src
operator|.
name|isNull
argument_list|()
condition|)
name|copyMetadata
argument_list|(
name|src
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
end_function
begin_function
DECL|function|rotated90
specifier|static
name|QImage
name|rotated90
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QImage
name|out
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|.
name|setDotsPerMeterX
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|setDotsPerMeterY
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|>
literal|0
condition|)
name|out
operator|.
name|setColorTable
argument_list|(
name|image
operator|.
name|colorTable
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
case|case
name|QImage
operator|::
name|Format_RGBA8888
case|:
case|case
name|QImage
operator|::
name|Format_RGBA8888_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_A2BGR30_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
case|case
name|QImage
operator|::
name|Format_A2RGB30_Premultiplied
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint24
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Alpha8
case|:
case|case
name|QImage
operator|::
name|Format_Grayscale8
case|:
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint8
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
condition|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|h
operator|-
name|y
operator|-
literal|1
argument_list|,
name|x
argument_list|,
name|image
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|h
operator|-
name|y
operator|-
literal|1
argument_list|,
name|x
argument_list|,
name|image
operator|.
name|pixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|rotated180
specifier|static
name|QImage
name|rotated180
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
return|return
name|image
operator|.
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rotated270
specifier|static
name|QImage
name|rotated270
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QImage
name|out
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|.
name|setDotsPerMeterX
argument_list|(
name|image
operator|.
name|dotsPerMeterY
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|setDotsPerMeterY
argument_list|(
name|image
operator|.
name|dotsPerMeterX
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|>
literal|0
condition|)
name|out
operator|.
name|setColorTable
argument_list|(
name|image
operator|.
name|colorTable
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGBX8888
case|:
case|case
name|QImage
operator|::
name|Format_RGBA8888
case|:
case|case
name|QImage
operator|::
name|Format_RGBA8888_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_BGR30
case|:
case|case
name|QImage
operator|::
name|Format_A2BGR30_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB30
case|:
case|case
name|QImage
operator|::
name|Format_A2RGB30_Premultiplied
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint24
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Alpha8
case|:
case|case
name|QImage
operator|::
name|Format_Grayscale8
case|:
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint8
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
condition|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|y
argument_list|,
name|w
operator|-
name|x
operator|-
literal|1
argument_list|,
name|image
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|y
argument_list|,
name|w
operator|-
name|x
operator|-
literal|1
argument_list|,
name|image
operator|.
name|pixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the image that is transformed using the given     transformation \a matrix and transformation \a mode.      The transformation \a matrix is internally adjusted to compensate     for unwanted translation; i.e. the image produced is the smallest     image that contains all the transformed points of the original     image. Use the trueMatrix() function to retrieve the actual matrix     used for transforming an image.      Unlike the other overload, this function can be used to perform perspective     transformations on images.      \sa trueMatrix(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QImage
name|QImage
operator|::
name|transformed
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// source image data
name|int
name|ws
init|=
name|width
argument_list|()
decl_stmt|;
name|int
name|hs
init|=
name|height
argument_list|()
decl_stmt|;
comment|// target image data
name|int
name|wd
decl_stmt|;
name|int
name|hd
decl_stmt|;
comment|// compute size of target image
name|QTransform
name|mat
init|=
name|trueMatrix
argument_list|(
name|matrix
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
decl_stmt|;
name|bool
name|complex_xform
init|=
literal|false
decl_stmt|;
name|bool
name|scale_xform
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxNone
condition|)
comment|// identity matrix
return|return
operator|*
name|this
return|;
elseif|else
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|==
operator|-
literal|1.
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|==
operator|-
literal|1.
condition|)
return|return
name|rotated180
argument_list|(
operator|*
name|this
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|FastTransformation
condition|)
block|{
name|hd
operator|=
name|qRound
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m22
argument_list|()
argument_list|)
operator|*
name|hs
argument_list|)
expr_stmt|;
name|wd
operator|=
name|qRound
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m11
argument_list|()
argument_list|)
operator|*
name|ws
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hd
operator|=
name|int
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m22
argument_list|()
argument_list|)
operator|*
name|hs
operator|+
literal|0.9999
argument_list|)
expr_stmt|;
name|wd
operator|=
name|int
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m11
argument_list|()
argument_list|)
operator|*
name|ws
operator|+
literal|0.9999
argument_list|)
expr_stmt|;
block|}
name|scale_xform
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxRotate
operator|&&
name|mat
operator|.
name|m11
argument_list|()
operator|==
literal|0
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|m12
argument_list|()
operator|==
literal|1.
operator|&&
name|mat
operator|.
name|m21
argument_list|()
operator|==
operator|-
literal|1.
condition|)
return|return
name|rotated90
argument_list|(
operator|*
name|this
argument_list|)
return|;
elseif|else
if|if
condition|(
name|mat
operator|.
name|m12
argument_list|()
operator|==
operator|-
literal|1.
operator|&&
name|mat
operator|.
name|m21
argument_list|()
operator|==
literal|1.
condition|)
return|return
name|rotated270
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|QPolygonF
name|a
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|mat
operator|.
name|map
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|a
operator|.
name|boundingRect
argument_list|()
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|wd
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|hd
operator|=
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
name|complex_xform
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|wd
operator|==
literal|0
operator|||
name|hd
operator|==
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// Make use of the optimized algorithm when we're scaling
if|if
condition|(
name|scale_xform
operator|&&
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|<
literal|0.0F
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// horizontal/vertical flip
return|return
name|smoothScaled
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|)
operator|.
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// horizontal flip
return|return
name|smoothScaled
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|)
operator|.
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mat
operator|.
name|m22
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// vertical flip
return|return
name|smoothScaled
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|)
operator|.
name|mirrored
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
comment|// no flipping
return|return
name|smoothScaled
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|)
return|;
block|}
block|}
name|int
name|bpp
init|=
name|depth
argument_list|()
decl_stmt|;
name|int
name|sbpl
init|=
name|bytesPerLine
argument_list|()
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
name|bits
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|target_format
init|=
name|d
operator|->
name|format
decl_stmt|;
if|if
condition|(
name|complex_xform
operator|||
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|<
name|QImage
operator|::
name|Format_RGB32
operator|||
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|target_format
operator|=
name|qt_alphaVersion
argument_list|(
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
block|}
name|QImage
name|dImage
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|,
name|target_format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|dImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
operator|||
name|target_format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|target_format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|dImage
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
operator||
name|complex_xform
expr_stmt|;
block|}
comment|// initizialize the data
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
if|if
condition|(
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|<
literal|256
condition|)
block|{
comment|// colors are left in the color table, so pick that one as transparent
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|append
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
literal|0x00
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_format
operator|>=
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
comment|// Prevent QPainter from applying devicePixelRatio corrections
specifier|const
name|QImage
name|sImage
init|=
operator|(
name|devicePixelRatio
argument_list|()
operator|!=
literal|1
operator|)
condition|?
name|QImage
argument_list|(
name|constBits
argument_list|()
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
name|format
argument_list|()
argument_list|)
else|:
operator|*
name|this
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|sImage
operator|.
name|devicePixelRatio
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sImage
operator|.
name|devicePixelRatio
argument_list|()
operator|==
name|dImage
operator|.
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|dImage
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|setTransform
argument_list|(
name|mat
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawImage
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sImage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|invertible
decl_stmt|;
name|mat
operator|=
name|mat
operator|.
name|inverted
argument_list|(
operator|&
name|invertible
argument_list|)
expr_stmt|;
comment|// invert matrix
if|if
condition|(
operator|!
name|invertible
condition|)
comment|// error, return null image
return|return
name|QImage
argument_list|()
return|;
comment|// create target image (some of the code is from QImage::copy())
name|int
name|type
init|=
name|format
argument_list|()
operator|==
name|Format_Mono
condition|?
name|QT_XFORM_TYPE_MSBFIRST
else|:
name|QT_XFORM_TYPE_LSBFIRST
decl_stmt|;
name|int
name|dbpl
init|=
name|dImage
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|qt_xForm_helper
argument_list|(
name|mat
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|bpp
argument_list|,
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
name|dbpl
argument_list|,
literal|0
argument_list|,
name|hd
argument_list|,
name|sptr
argument_list|,
name|sbpl
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
expr_stmt|;
block|}
name|copyMetadata
argument_list|(
name|dImage
operator|.
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|dImage
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform QImage::trueMatrix(const QTransform&matrix, int width, int height)      Returns the actual matrix used for transforming an image with the     given \a width, \a height and \a matrix.      When transforming an image using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     image containing all transformed points of the original image.     This function returns the modified matrix, which maps points     correctly from the original image into the new image.      Unlike the other overload, this function creates transformation     matrices that can be used to perform perspective     transformations on images.      \sa transformed(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QTransform
name|QImage
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|const
name|QRectF
name|rect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|mapped
init|=
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|delta
init|=
name|mapped
operator|.
name|topLeft
argument_list|()
decl_stmt|;
return|return
name|matrix
operator|*
name|QTransform
argument_list|()
operator|.
name|translate
argument_list|(
operator|-
name|delta
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|delta
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertInPlace
name|bool
name|QImageData
operator|::
name|convertInPlace
parameter_list|(
name|QImage
operator|::
name|Format
name|newFormat
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|newFormat
condition|)
return|return
literal|true
return|;
comment|// No in-place conversion if we have to detach
if|if
condition|(
name|ref
operator|.
name|load
argument_list|()
operator|>
literal|1
operator|||
name|ro_data
condition|)
return|return
literal|false
return|;
name|InPlace_Image_Converter
name|converter
init|=
name|qimage_inplace_converter_map
index|[
name|format
index|]
index|[
name|newFormat
index|]
decl_stmt|;
if|if
condition|(
name|converter
condition|)
return|return
name|converter
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
elseif|else
if|if
condition|(
name|format
operator|>
name|QImage
operator|::
name|Format_Indexed8
operator|&&
name|newFormat
operator|>
name|QImage
operator|::
name|Format_Indexed8
operator|&&
operator|!
name|qimage_converter_map
index|[
name|format
index|]
index|[
name|newFormat
index|]
condition|)
comment|// Convert inplace generic, but only if there are no direct converters,
comment|// any direct ones are probably better even if not inplace.
return|return
name|convert_generic_inplace
argument_list|(
name|this
argument_list|,
name|newFormat
argument_list|,
name|flags
argument_list|)
return|;
else|else
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QImage::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr& QImage::data_ptr()     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|dbg
argument_list|)
decl_stmt|;
name|dbg
operator|.
name|resetFormat
argument_list|()
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
expr_stmt|;
name|dbg
operator|<<
literal|"QImage("
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|dbg
operator|<<
literal|"null"
expr_stmt|;
block|}
else|else
block|{
name|dbg
operator|<<
name|i
operator|.
name|size
argument_list|()
operator|<<
literal|",format="
operator|<<
name|i
operator|.
name|format
argument_list|()
operator|<<
literal|",depth="
operator|<<
name|i
operator|.
name|depth
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|colorCount
argument_list|()
condition|)
name|dbg
operator|<<
literal|",colorCount="
operator|<<
name|i
operator|.
name|colorCount
argument_list|()
expr_stmt|;
name|dbg
operator|<<
literal|",devicePixelRatio="
operator|<<
name|i
operator|.
name|devicePixelRatio
argument_list|()
operator|<<
literal|",bytesPerLine="
operator|<<
name|i
operator|.
name|bytesPerLine
argument_list|()
operator|<<
literal|",byteCount="
operator|<<
name|i
operator|.
name|byteCount
argument_list|()
expr_stmt|;
block|}
name|dbg
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QImage::setNumColors(int n)     \obsolete      Resizes the color table to contain \a n entries.      \sa setColorCount()  */
end_comment
begin_comment
comment|/*!     \fn int QImage::numBytes() const     \obsolete      Returns the number of bytes occupied by the image data.      \sa byteCount()  */
end_comment
begin_comment
comment|/*!     \fn QStringList QImage::textLanguages() const     \obsolete      Returns the language identifiers for which some texts are recorded.     Note that if you want to iterate over the list, you should iterate over a copy.      The language the text is recorded in is no longer relevant since the text is     always set using QString and UTF-8 representation.      \sa textKeys()  */
end_comment
begin_comment
comment|/*!     \fn QList<QImageTextKeyLang> QImage::textList() const     \obsolete      Returns a list of QImageTextKeyLang objects that enumerate all the texts     key/language pairs set for this image.      The language the text is recorded in is no longer relevant since the text     is always set using QString and UTF-8 representation.      \sa textKeys()  */
end_comment
begin_decl_stmt
DECL|variable|pixelformats
specifier|static
name|Q_CONSTEXPR
name|QPixelFormat
name|pixelformats
index|[]
init|=
block|{
comment|//QImage::Format_Invalid:
name|QPixelFormat
argument_list|()
block|,
comment|//QImage::Format_Mono:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|Indexed
argument_list|,
comment|/*RED*/
literal|1
argument_list|,
comment|/*GREEN*/
literal|0
argument_list|,
comment|/*BLUE*/
literal|0
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_MonoLSB:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|Indexed
argument_list|,
comment|/*RED*/
literal|1
argument_list|,
comment|/*GREEN*/
literal|0
argument_list|,
comment|/*BLUE*/
literal|0
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_Indexed8:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|Indexed
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|0
argument_list|,
comment|/*BLUE*/
literal|0
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB32:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB32:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB32_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB16:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|5
argument_list|,
comment|/*GREEN*/
literal|6
argument_list|,
comment|/*BLUE*/
literal|5
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedShort
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB8565_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|5
argument_list|,
comment|/*GREEN*/
literal|6
argument_list|,
comment|/*BLUE*/
literal|5
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB666:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|6
argument_list|,
comment|/*GREEN*/
literal|6
argument_list|,
comment|/*BLUE*/
literal|6
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB6666_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|6
argument_list|,
comment|/*GREEN*/
literal|6
argument_list|,
comment|/*BLUE*/
literal|6
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|6
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtEnd
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB555:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|5
argument_list|,
comment|/*GREEN*/
literal|5
argument_list|,
comment|/*BLUE*/
literal|5
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedShort
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB8555_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|5
argument_list|,
comment|/*GREEN*/
literal|5
argument_list|,
comment|/*BLUE*/
literal|5
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB888:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB444:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|4
argument_list|,
comment|/*GREEN*/
literal|4
argument_list|,
comment|/*BLUE*/
literal|4
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedShort
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_ARGB4444_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|4
argument_list|,
comment|/*GREEN*/
literal|4
argument_list|,
comment|/*BLUE*/
literal|4
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|4
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtEnd
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedShort
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGBX8888:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtEnd
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGBA8888:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtEnd
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGBA8888_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|8
argument_list|,
comment|/*GREEN*/
literal|8
argument_list|,
comment|/*BLUE*/
literal|8
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtEnd
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_BGR30:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|BGR
argument_list|,
comment|/*RED*/
literal|10
argument_list|,
comment|/*GREEN*/
literal|10
argument_list|,
comment|/*BLUE*/
literal|10
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|2
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_A2BGR30_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|BGR
argument_list|,
comment|/*RED*/
literal|10
argument_list|,
comment|/*GREEN*/
literal|10
argument_list|,
comment|/*BLUE*/
literal|10
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|2
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_RGB30:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|10
argument_list|,
comment|/*GREEN*/
literal|10
argument_list|,
comment|/*BLUE*/
literal|10
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|2
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_A2RGB30_Premultiplied:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|RGB
argument_list|,
comment|/*RED*/
literal|10
argument_list|,
comment|/*GREEN*/
literal|10
argument_list|,
comment|/*BLUE*/
literal|10
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|2
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedInteger
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_Alpha8:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|Alpha
argument_list|,
comment|/*First*/
literal|0
argument_list|,
comment|/*SECOND*/
literal|0
argument_list|,
comment|/*THIRD*/
literal|0
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|8
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|UsesAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|Premultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|,
comment|//QImage::Format_Grayscale8:
name|QPixelFormat
argument_list|(
name|QPixelFormat
operator|::
name|Grayscale
argument_list|,
comment|/*GRAY*/
literal|8
argument_list|,
comment|/*SECOND*/
literal|0
argument_list|,
comment|/*THIRD*/
literal|0
argument_list|,
comment|/*FOURTH*/
literal|0
argument_list|,
comment|/*FIFTH*/
literal|0
argument_list|,
comment|/*ALPHA*/
literal|0
argument_list|,
comment|/*ALPHA USAGE*/
name|QPixelFormat
operator|::
name|IgnoresAlpha
argument_list|,
comment|/*ALPHA POSITION*/
name|QPixelFormat
operator|::
name|AtBeginning
argument_list|,
comment|/*PREMULTIPLIED*/
name|QPixelFormat
operator|::
name|NotPremultiplied
argument_list|,
comment|/*INTERPRETATION*/
name|QPixelFormat
operator|::
name|UnsignedByte
argument_list|,
comment|/*BYTE ORDER*/
name|QPixelFormat
operator|::
name|CurrentSystemEndian
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt
begin_expr_stmt
DECL|member|NImageFormats
name|Q_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|pixelformats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pixelformats
argument_list|)
operator|==
name|QImage
operator|::
name|NImageFormats
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*!     Returns the QImage::Format as a QPixelFormat */
end_comment
begin_function
name|QPixelFormat
name|QImage
operator|::
name|pixelFormat
parameter_list|()
specifier|const
name|Q_DECL_NOTHROW
block|{
return|return
name|toPixelFormat
argument_list|(
name|format
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts \a format into a QPixelFormat */
end_comment
begin_function
name|QPixelFormat
name|QImage
operator|::
name|toPixelFormat
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|Q_ASSERT
argument_list|(
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|format
argument_list|)
operator|<
name|NImageFormats
argument_list|)
expr_stmt|;
return|return
name|pixelformats
index|[
name|format
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Converts \a format into a QImage::Format */
end_comment
begin_function
name|QImage
operator|::
name|Format
name|QImage
operator|::
name|toImageFormat
parameter_list|(
name|QPixelFormat
name|format
parameter_list|)
name|Q_DECL_NOTHROW
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NImageFormats
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
operator|==
name|pixelformats
index|[
name|i
index|]
condition|)
return|return
name|Format
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
name|Format_Invalid
return|;
block|}
end_function
begin_function
DECL|function|qt_imageTransform
name|Q_GUI_EXPORT
name|void
name|qt_imageTransform
parameter_list|(
name|QImage
modifier|&
name|src
parameter_list|,
name|QImageIOHandler
operator|::
name|Transformations
name|orient
parameter_list|)
block|{
if|if
condition|(
name|orient
operator|==
name|QImageIOHandler
operator|::
name|TransformationNone
condition|)
return|return;
if|if
condition|(
name|orient
operator|==
name|QImageIOHandler
operator|::
name|TransformationRotate270
condition|)
block|{
name|src
operator|=
name|rotated270
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|qMove
argument_list|(
name|src
argument_list|)
operator|.
name|mirrored
argument_list|(
name|orient
operator|&
name|QImageIOHandler
operator|::
name|TransformationMirror
argument_list|,
name|orient
operator|&
name|QImageIOHandler
operator|::
name|TransformationFlip
argument_list|)
expr_stmt|;
if|if
condition|(
name|orient
operator|&
name|QImageIOHandler
operator|::
name|TransformationRotate90
condition|)
name|src
operator|=
name|rotated90
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
