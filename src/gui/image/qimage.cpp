begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qmatrix.h"
end_include
begin_include
include|#
directive|include
file|"qtransform.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"qimagewriter.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qimagepixmapcleanuphooks_p.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformpixmap.h>
end_include
begin_include
include|#
directive|include
file|<private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmemrotate_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimagescale_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qsimd_p.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_raster_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qimage_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isLocked
specifier|static
specifier|inline
name|bool
name|isLocked
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|)
block|{
return|return
name|data
operator|!=
literal|0
operator|&&
name|data
operator|->
name|is_locked
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_DEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha
argument_list|)
operator|&&
operator|(
name|__DECCXX_VER
operator|-
literal|0
operator|>=
literal|50190001
operator|)
end_if
begin_pragma
pragma|#
directive|pragma
name|message
name|disable
name|narrowptr
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QIMAGE_SANITYCHECK_MEMORY
define|#
directive|define
name|QIMAGE_SANITYCHECK_MEMORY
parameter_list|(
name|image
parameter_list|)
define|\
value|if ((image).isNull()) { \         qWarning("QImage: out of memory, returning null image"); \         return QImage(); \     }
end_define
begin_function_decl
specifier|static
name|QImage
name|rotated90
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QImage
name|rotated180
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QImage
name|rotated270
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|qimage_serial_number
name|QBasicAtomicInt
name|qimage_serial_number
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QImageData
name|QImageData
operator|::
name|QImageData
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|width
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|height
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|depth
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|nbytes
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|devicePixelRatio
argument_list|(
literal|1.0
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|format
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
member_init_list|,
name|bytes_per_line
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ser_no
argument_list|(
name|qimage_serial_number
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
member_init_list|,
name|detach_no
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ldpmx
argument_list|(
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|ldpmy
argument_list|(
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|dpmx
argument_list|(
name|qt_defaultDpiX
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|dpmy
argument_list|(
name|qt_defaultDpiY
argument_list|()
operator|*
literal|100
operator|/
name|qreal
argument_list|(
literal|2.54
argument_list|)
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|own_data
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|ro_data
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_alpha_clut
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|is_cached
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|is_locked
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cleanupFunction
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cleanupInfo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|paintEngine
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \fn QImageData * QImageData::create(const QSize&size, QImage::Format format, int numColors)      \internal      Creates a new image data.     Returns 0 if invalid parameters are give or anything else failed. */
end_comment
begin_function
DECL|function|create
name|QImageData
modifier|*
name|QImageData
operator|::
name|create
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|,
name|int
name|numColors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|size
operator|.
name|isValid
argument_list|()
operator|||
name|numColors
operator|<
literal|0
operator|||
name|format
operator|==
name|QImage
operator|::
name|Format_Invalid
condition|)
return|return
literal|0
return|;
comment|// invalid parameter(s)
name|uint
name|width
init|=
name|size
operator|.
name|width
argument_list|()
decl_stmt|;
name|uint
name|height
init|=
name|size
operator|.
name|height
argument_list|()
decl_stmt|;
name|uint
name|depth
init|=
name|qt_depthForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|numColors
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|numColors
operator|=
name|qBound
argument_list|(
literal|0
argument_list|,
name|numColors
argument_list|,
literal|256
argument_list|)
expr_stmt|;
break|break;
default|default:
name|numColors
operator|=
literal|0
expr_stmt|;
break|break;
block|}
specifier|const
name|int
name|bytes_per_line
init|=
operator|(
operator|(
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
comment|// bytes per scanline (must be multiple of 4)
comment|// sanity check for potential overflows
if|if
condition|(
name|INT_MAX
operator|/
name|depth
operator|<
name|width
operator|||
name|bytes_per_line
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|bytes_per_line
argument_list|)
operator|<
name|height
operator|||
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
condition|)
return|return
literal|0
return|;
name|QScopedPointer
argument_list|<
name|QImageData
argument_list|>
name|d
argument_list|(
operator|new
name|QImageData
argument_list|)
decl_stmt|;
name|d
operator|->
name|colortable
operator|.
name|resize
argument_list|(
name|numColors
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|colortable
index|[
literal|0
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|black
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
name|d
operator|->
name|colortable
index|[
literal|1
index|]
operator|=
name|QColor
argument_list|(
name|Qt
operator|::
name|white
argument_list|)
operator|.
name|rgba
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numColors
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|d
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|d
operator|->
name|has_alpha_clut
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|is_cached
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|bytes_per_line
operator|=
name|bytes_per_line
expr_stmt|;
name|d
operator|->
name|nbytes
operator|=
name|d
operator|->
name|bytes_per_line
operator|*
name|height
expr_stmt|;
name|d
operator|->
name|data
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|data
condition|)
block|{
return|return
literal|0
return|;
block|}
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
name|d
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_destructor
DECL|function|~QImageData
name|QImageData
operator|::
name|~
name|QImageData
parameter_list|()
block|{
if|if
condition|(
name|cleanupFunction
condition|)
name|cleanupFunction
argument_list|(
name|cleanupInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executeImageHooks
argument_list|(
operator|(
operator|(
operator|(
name|qint64
operator|)
name|ser_no
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|qint64
operator|)
name|detach_no
operator|)
argument_list|)
expr_stmt|;
operator|delete
name|paintEngine
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|own_data
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|checkForAlphaPixels
name|bool
name|QImageData
operator|::
name|checkForAlphaPixels
parameter_list|()
specifier|const
block|{
name|bool
name|has_alpha_pixels
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|has_alpha_pixels
operator|=
name|has_alpha_clut
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|has_alpha_pixels
operator||=
operator|(
operator|(
operator|(
name|uint
operator|*
operator|)
name|bits
operator|)
index|[
name|x
index|]
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0xff000000
expr_stmt|;
name|bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
name|bits
index|[
literal|0
index|]
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|3
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
operator|(
name|bits
index|[
literal|0
index|]
operator|&
literal|0xfc
operator|)
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|3
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
block|{
name|uchar
modifier|*
name|bits
init|=
name|data
decl_stmt|;
name|uchar
modifier|*
name|end_bits
init|=
name|data
operator|+
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
operator|&&
operator|!
name|has_alpha_pixels
condition|;
operator|++
name|y
control|)
block|{
while|while
condition|(
name|bits
operator|<
name|end_bits
condition|)
block|{
name|has_alpha_pixels
operator||=
operator|(
name|bits
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
expr_stmt|;
name|bits
operator|+=
literal|2
expr_stmt|;
block|}
name|bits
operator|=
name|end_bits
expr_stmt|;
name|end_bits
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|has_alpha_pixels
return|;
block|}
end_function
begin_comment
comment|/*!     \class QImage      \inmodule QtGui     \ingroup painting     \ingroup shared      \reentrant      \brief The QImage class provides a hardware-independent image     representation that allows direct access to the pixel data, and     can be used as a paint device.      Qt provides four classes for handling image data: QImage, QPixmap,     QBitmap and QPicture.  QImage is designed and optimized for I/O,     and for direct pixel access and manipulation, while QPixmap is     designed and optimized for showing images on screen. QBitmap is     only a convenience class that inherits QPixmap, ensuring a     depth of 1. Finally, the QPicture class is a paint device that     records and replays QPainter commands.      Because QImage is a QPaintDevice subclass, QPainter can be used to     draw directly onto images.  When using QPainter on a QImage, the     painting can be performed in another thread than the current GUI     thread.      The QImage class supports several image formats described by the     \l Format enum. These include monochrome, 8-bit, 32-bit and     alpha-blended images which are available in all versions of Qt     4.x.      QImage provides a collection of functions that can be used to     obtain a variety of information about the image. There are also     several functions that enables transformation of the image.      QImage objects can be passed around by value since the QImage     class uses \l{Implicit Data Sharing}{implicit data     sharing}. QImage objects can also be streamed and compared.      \note If you would like to load QImage objects in a static build of Qt,     refer to the \l{How To Create Qt Plugins#Static Plugins}{Plugin HowTo}.      \warning Painting on a QImage with the format     QImage::Format_Indexed8 is not supported.      \tableofcontents      \section1 Reading and Writing Image Files      QImage provides several ways of loading an image file: The file     can be loaded when constructing the QImage object, or by using the     load() or loadFromData() functions later on. QImage also provides     the static fromData() function, constructing a QImage from the     given data.  When loading an image, the file name can either refer     to an actual file on disk or to one of the application's embedded     resources. See \l{The Qt Resource System} overview for details     on how to embed images and other resource files in the     application's executable.      Simply call the save() function to save a QImage object.      The complete list of supported file formats are available through     the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions. New file formats     can be added as plugins. By default, Qt supports the following     formats:      \table     \header \li Format \li Description                      \li Qt's support     \row    \li BMP    \li Windows Bitmap                   \li Read/write     \row    \li GIF    \li Graphic Interchange Format (optional) \li Read     \row    \li JPG    \li Joint Photographic Experts Group \li Read/write     \row    \li JPEG   \li Joint Photographic Experts Group \li Read/write     \row    \li PNG    \li Portable Network Graphics        \li Read/write     \row    \li PBM    \li Portable Bitmap                  \li Read     \row    \li PGM    \li Portable Graymap                 \li Read     \row    \li PPM    \li Portable Pixmap                  \li Read/write     \row    \li XBM    \li X11 Bitmap                       \li Read/write     \row    \li XPM    \li X11 Pixmap                       \li Read/write     \endtable      \section1 Image Information      QImage provides a collection of functions that can be used to     obtain a variety of information about the image:      \table     \header     \li \li Available Functions      \row     \li Geometry     \li      The size(), width(), height(), dotsPerMeterX(), and     dotsPerMeterY() functions provide information about the image size     and aspect ratio.      The rect() function returns the image's enclosing rectangle. The     valid() function tells if a given pair of coordinates is within     this rectangle. The offset() function returns the number of pixels     by which the image is intended to be offset by when positioned     relative to other images, which also can be manipulated using the     setOffset() function.      \row     \li Colors     \li      The color of a pixel can be retrieved by passing its coordinates     to the pixel() function.  The pixel() function returns the color     as a QRgb value indepedent of the image's format.      In case of monochrome and 8-bit images, the colorCount() and     colorTable() functions provide information about the color     components used to store the image data: The colorTable() function     returns the image's entire color table. To obtain a single entry,     use the pixelIndex() function to retrieve the pixel index for a     given pair of coordinates, then use the color() function to     retrieve the color. Note that if you create an 8-bit image     manually, you have to set a valid color table on the image as     well.      The hasAlphaChannel() function tells if the image's format     respects the alpha channel, or not. The allGray() and     isGrayscale() functions tell whether an image's colors are all     shades of gray.      See also the \l {QImage#Pixel Manipulation}{Pixel Manipulation}     and \l {QImage#Image Transformations}{Image Transformations}     sections.      \row     \li Text     \li      The text() function returns the image text associated with the     given text key. An image's text keys can be retrieved using the     textKeys() function. Use the setText() function to alter an     image's text.      \row     \li Low-level information     \li      The depth() function returns the depth of the image. The supported     depths are 1 (monochrome), 8, 16, 24 and 32 bits. The     bitPlaneCount() function tells how many of those bits that are     used. For more information see the     \l {QImage#Image Formats}{Image Formats} section.      The format(), bytesPerLine(), and byteCount() functions provide     low-level information about the data stored in the image.      The cacheKey() function returns a number that uniquely     identifies the contents of this QImage object.     \endtable      \section1 Pixel Manipulation      The functions used to manipulate an image's pixels depend on the     image format. The reason is that monochrome and 8-bit images are     index-based and use a color lookup table, while 32-bit images     store ARGB values directly. For more information on image formats,     see the \l {Image Formats} section.      In case of a 32-bit image, the setPixel() function can be used to     alter the color of the pixel at the given coordinates to any other     color specified as an ARGB quadruplet. To make a suitable QRgb     value, use the qRgb() (adding a default alpha component to the     given RGB values, i.e. creating an opaque color) or qRgba()     function. For example:      \table     \header     \li {2,1}32-bit     \row     \li \inlineimage qimage-32bit_scaled.png     \li     \snippet code/src_gui_image_qimage.cpp 0     \endtable      In case of a 8-bit and monchrome images, the pixel value is only     an index from the image's color table. So the setPixel() function     can only be used to alter the color of the pixel at the given     coordinates to a predefined color from the image's color table,     i.e. it can only change the pixel's index value. To alter or add a     color to an image's color table, use the setColor() function.      An entry in the color table is an ARGB quadruplet encoded as an     QRgb value. Use the qRgb() and qRgba() functions to make a     suitable QRgb value for use with the setColor() function. For     example:      \table     \header     \li {2,1} 8-bit     \row     \li \inlineimage qimage-8bit_scaled.png     \li     \snippet code/src_gui_image_qimage.cpp 1     \endtable      QImage also provide the scanLine() function which returns a     pointer to the pixel data at the scanline with the given index,     and the bits() function which returns a pointer to the first pixel     data (this is equivalent to \c scanLine(0)).      \section1 Image Formats      Each pixel stored in a QImage is represented by an integer. The     size of the integer varies depending on the format. QImage     supports several image formats described by the \l Format     enum.      Monochrome images are stored using 1-bit indexes into a color table     with at most two colors. There are two different types of     monochrome images: big endian (MSB first) or little endian (LSB     first) bit order.      8-bit images are stored using 8-bit indexes into a color table,     i.e.  they have a single byte per pixel. The color table is a     QVector<QRgb>, and the QRgb typedef is equivalent to an unsigned     int containing an ARGB quadruplet on the format 0xAARRGGBB.      32-bit images have no color table; instead, each pixel contains an     QRgb value. There are three different types of 32-bit images     storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB     values respectively. In the premultiplied format the red, green,     and blue channels are multiplied by the alpha component divided by     255.      An image's format can be retrieved using the format()     function. Use the convertToFormat() functions to convert an image     into another format. The allGray() and isGrayscale() functions     tell whether a color image can safely be converted to a grayscale     image.      \section1 Image Transformations      QImage supports a number of functions for creating a new image     that is a transformed version of the original: The     createAlphaMask() function builds and returns a 1-bpp mask from     the alpha buffer in this image, and the createHeuristicMask()     function creates and returns a 1-bpp heuristic mask for this     image. The latter function works by selecting a color from one of     the corners, then chipping away pixels of that color starting at     all the edges.      The mirrored() function returns a mirror of the image in the     desired direction, the scaled() returns a copy of the image scaled     to a rectangle of the desired measures, and the rgbSwapped() function     constructs a BGR image from a RGB image.      The scaledToWidth() and scaledToHeight() functions return scaled     copies of the image.      The transformed() function returns a copy of the image that is     transformed with the given transformation matrix and     transformation mode: Internally, the transformation matrix is     adjusted to compensate for unwanted translation,     i.e. transformed() returns the smallest image containing all     transformed points of the original image. The static trueMatrix()     function returns the actual matrix used for transforming the     image.      There are also functions for changing attributes of an image     in-place:      \table     \header \li Function \li Description     \row     \li setDotsPerMeterX()     \li Defines the aspect ratio by setting the number of pixels that fit     horizontally in a physical meter.     \row     \li setDotsPerMeterY()     \li Defines the aspect ratio by setting the number of pixels that fit     vertically in a physical meter.     \row     \li fill()     \li Fills the entire image with the given pixel value.     \row     \li invertPixels()     \li Inverts all pixel values in the image using the given InvertMode value.     \row     \li setColorTable()     \li Sets the color table used to translate color indexes. Only     monochrome and 8-bit formats.     \row     \li setColorCount()     \li Resizes the color table. Only monochrome and 8-bit formats.      \endtable      \section1 Legal Information      For smooth scaling, the transformed() functions use code based on     smooth scaling algorithm by Daniel M. Duley.      \legalese      Copyright (C) 2004, 2005 Daniel M. Duley       Redistribution and use in source and binary forms, with or without         modification, are permitted provided that the following conditions         are met:       1. Redistributions of source code must retain the above copyright         notice, this list of conditions and the following disclaimer.      2. Redistributions in binary form must reproduce the above copyright         notice, this list of conditions and the following disclaimer in the         documentation and/or other materials provided with the distribution.       THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR      IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES      OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.      IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,      INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT      NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     \endlegalese      \sa QImageReader, QImageWriter, QPixmap, QSvgRenderer, {Image Composition Example},         {Image Viewer Example}, {Scribble Example}, {Pixelator Example} */
end_comment
begin_comment
comment|/*!     \typedef QImageCleanupFunction     \relates QImage     \since 5.0      A function with the following signature that can be used to     implement basic image memory management:      \code     void myImageCleanupHandler(void *info);     \endcode */
end_comment
begin_comment
comment|/*!     \enum QImage::InvertMode      This enum type is used to describe how pixel values should be     inverted in the invertPixels() function.      \value InvertRgb    Invert only the RGB values and leave the alpha                         channel unchanged.      \value InvertRgba   Invert all channels, including the alpha channel.      \sa invertPixels() */
end_comment
begin_comment
comment|/*!     \enum QImage::Format      The following image formats are available in Qt. Values greater     than QImage::Format_RGB16 were added in Qt 4.4. See the notes     after the table.      \value Format_Invalid   The image is invalid.     \value Format_Mono      The image is stored using 1-bit per pixel. Bytes are                             packed with the most significant bit (MSB) first.     \value Format_MonoLSB   The image is stored using 1-bit per pixel. Bytes are                             packed with the less significant bit (LSB) first.      \value Format_Indexed8  The image is stored using 8-bit indexes                             into a colormap.      \value Format_RGB32     The image is stored using a 32-bit RGB format (0xffRRGGBB).      \value Format_ARGB32    The image is stored using a 32-bit ARGB                             format (0xAARRGGBB).      \value Format_ARGB32_Premultiplied  The image is stored using a premultiplied 32-bit                             ARGB format (0xAARRGGBB), i.e. the red,                             green, and blue channels are multiplied                             by the alpha component divided by 255. (If RR, GG, or BB                             has a higher value than the alpha channel, the results are                             undefined.) Certain operations (such as image composition                             using alpha blending) are faster using premultiplied ARGB32                             than with plain ARGB32.      \value Format_RGB16     The image is stored using a 16-bit RGB format (5-6-5).      \value Format_ARGB8565_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (8-5-6-5).     \value Format_RGB666    The image is stored using a 24-bit RGB format (6-6-6).                             The unused most significant bits is always zero.     \value Format_ARGB6666_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (6-6-6-6).     \value Format_RGB555    The image is stored using a 16-bit RGB format (5-5-5).                             The unused most significant bit is always zero.     \value Format_ARGB8555_Premultiplied  The image is stored using a                             premultiplied 24-bit ARGB format (8-5-5-5).     \value Format_RGB888    The image is stored using a 24-bit RGB format (8-8-8).     \value Format_RGB444    The image is stored using a 16-bit RGB format (4-4-4).                             The unused bits are always zero.     \value Format_ARGB4444_Premultiplied  The image is stored using a                             premultiplied 16-bit ARGB format (4-4-4-4).      \note Drawing into a QImage with QImage::Format_Indexed8 is not     supported.      \note Do not render into ARGB32 images using QPainter.  Using     QImage::Format_ARGB32_Premultiplied is significantly faster.      \sa format(), convertToFormat() */
end_comment
begin_comment
comment|/*****************************************************************************   QImage member functions  *****************************************************************************/
end_comment
begin_comment
comment|// table to flip bits
end_comment
begin_decl_stmt
DECL|variable|bitflip
specifier|static
specifier|const
name|uchar
name|bitflip
index|[
literal|256
index|]
init|=
block|{
comment|/*         open OUT, "| fmt";         for $i (0..255) {             print OUT (($i>> 7)& 0x01) | (($i>> 5)& 0x02) |                       (($i>> 3)& 0x04) | (($i>> 1)& 0x08) |                       (($i<< 7)& 0x80) | (($i<< 5)& 0x40) |                       (($i<< 3)& 0x20) | (($i<< 1)& 0x10), ", ";         }         close OUT;     */
literal|0
block|,
literal|128
block|,
literal|64
block|,
literal|192
block|,
literal|32
block|,
literal|160
block|,
literal|96
block|,
literal|224
block|,
literal|16
block|,
literal|144
block|,
literal|80
block|,
literal|208
block|,
literal|48
block|,
literal|176
block|,
literal|112
block|,
literal|240
block|,
literal|8
block|,
literal|136
block|,
literal|72
block|,
literal|200
block|,
literal|40
block|,
literal|168
block|,
literal|104
block|,
literal|232
block|,
literal|24
block|,
literal|152
block|,
literal|88
block|,
literal|216
block|,
literal|56
block|,
literal|184
block|,
literal|120
block|,
literal|248
block|,
literal|4
block|,
literal|132
block|,
literal|68
block|,
literal|196
block|,
literal|36
block|,
literal|164
block|,
literal|100
block|,
literal|228
block|,
literal|20
block|,
literal|148
block|,
literal|84
block|,
literal|212
block|,
literal|52
block|,
literal|180
block|,
literal|116
block|,
literal|244
block|,
literal|12
block|,
literal|140
block|,
literal|76
block|,
literal|204
block|,
literal|44
block|,
literal|172
block|,
literal|108
block|,
literal|236
block|,
literal|28
block|,
literal|156
block|,
literal|92
block|,
literal|220
block|,
literal|60
block|,
literal|188
block|,
literal|124
block|,
literal|252
block|,
literal|2
block|,
literal|130
block|,
literal|66
block|,
literal|194
block|,
literal|34
block|,
literal|162
block|,
literal|98
block|,
literal|226
block|,
literal|18
block|,
literal|146
block|,
literal|82
block|,
literal|210
block|,
literal|50
block|,
literal|178
block|,
literal|114
block|,
literal|242
block|,
literal|10
block|,
literal|138
block|,
literal|74
block|,
literal|202
block|,
literal|42
block|,
literal|170
block|,
literal|106
block|,
literal|234
block|,
literal|26
block|,
literal|154
block|,
literal|90
block|,
literal|218
block|,
literal|58
block|,
literal|186
block|,
literal|122
block|,
literal|250
block|,
literal|6
block|,
literal|134
block|,
literal|70
block|,
literal|198
block|,
literal|38
block|,
literal|166
block|,
literal|102
block|,
literal|230
block|,
literal|22
block|,
literal|150
block|,
literal|86
block|,
literal|214
block|,
literal|54
block|,
literal|182
block|,
literal|118
block|,
literal|246
block|,
literal|14
block|,
literal|142
block|,
literal|78
block|,
literal|206
block|,
literal|46
block|,
literal|174
block|,
literal|110
block|,
literal|238
block|,
literal|30
block|,
literal|158
block|,
literal|94
block|,
literal|222
block|,
literal|62
block|,
literal|190
block|,
literal|126
block|,
literal|254
block|,
literal|1
block|,
literal|129
block|,
literal|65
block|,
literal|193
block|,
literal|33
block|,
literal|161
block|,
literal|97
block|,
literal|225
block|,
literal|17
block|,
literal|145
block|,
literal|81
block|,
literal|209
block|,
literal|49
block|,
literal|177
block|,
literal|113
block|,
literal|241
block|,
literal|9
block|,
literal|137
block|,
literal|73
block|,
literal|201
block|,
literal|41
block|,
literal|169
block|,
literal|105
block|,
literal|233
block|,
literal|25
block|,
literal|153
block|,
literal|89
block|,
literal|217
block|,
literal|57
block|,
literal|185
block|,
literal|121
block|,
literal|249
block|,
literal|5
block|,
literal|133
block|,
literal|69
block|,
literal|197
block|,
literal|37
block|,
literal|165
block|,
literal|101
block|,
literal|229
block|,
literal|21
block|,
literal|149
block|,
literal|85
block|,
literal|213
block|,
literal|53
block|,
literal|181
block|,
literal|117
block|,
literal|245
block|,
literal|13
block|,
literal|141
block|,
literal|77
block|,
literal|205
block|,
literal|45
block|,
literal|173
block|,
literal|109
block|,
literal|237
block|,
literal|29
block|,
literal|157
block|,
literal|93
block|,
literal|221
block|,
literal|61
block|,
literal|189
block|,
literal|125
block|,
literal|253
block|,
literal|3
block|,
literal|131
block|,
literal|67
block|,
literal|195
block|,
literal|35
block|,
literal|163
block|,
literal|99
block|,
literal|227
block|,
literal|19
block|,
literal|147
block|,
literal|83
block|,
literal|211
block|,
literal|51
block|,
literal|179
block|,
literal|115
block|,
literal|243
block|,
literal|11
block|,
literal|139
block|,
literal|75
block|,
literal|203
block|,
literal|43
block|,
literal|171
block|,
literal|107
block|,
literal|235
block|,
literal|27
block|,
literal|155
block|,
literal|91
block|,
literal|219
block|,
literal|59
block|,
literal|187
block|,
literal|123
block|,
literal|251
block|,
literal|7
block|,
literal|135
block|,
literal|71
block|,
literal|199
block|,
literal|39
block|,
literal|167
block|,
literal|103
block|,
literal|231
block|,
literal|23
block|,
literal|151
block|,
literal|87
block|,
literal|215
block|,
literal|55
block|,
literal|183
block|,
literal|119
block|,
literal|247
block|,
literal|15
block|,
literal|143
block|,
literal|79
block|,
literal|207
block|,
literal|47
block|,
literal|175
block|,
literal|111
block|,
literal|239
block|,
literal|31
block|,
literal|159
block|,
literal|95
block|,
literal|223
block|,
literal|63
block|,
literal|191
block|,
literal|127
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_get_bitflip_array
specifier|const
name|uchar
modifier|*
name|qt_get_bitflip_array
parameter_list|()
comment|// called from QPixmap code
block|{
return|return
name|bitflip
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a null image.      \sa isNull() */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|()
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format.      A \l{isNull()}{null} image will be returned if memory cannot be allocated.      \warning This will create a QImage with uninitialized data. Call     fill() to fill the image with an appropriate pixel value before     drawing onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|QSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|,
name|format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a size and \a format.      A \l{isNull()}{null} image is returned if memory cannot be allocated.      \warning This will create a QImage with uninitialized data. Call     fill() to fill the image with an appropriate pixel value before     drawing onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|,
name|Format
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|size
argument_list|,
name|format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|create
name|QImageData
modifier|*
name|QImageData
operator|::
name|create
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bpl
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|,
name|bool
name|readOnly
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
block|{
name|QImageData
modifier|*
name|d
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Invalid
condition|)
return|return
name|d
return|;
specifier|const
name|int
name|depth
init|=
name|qt_depthForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
specifier|const
name|int
name|calc_bytes_per_line
init|=
operator|(
operator|(
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|/
literal|32
operator|)
operator|*
literal|4
decl_stmt|;
specifier|const
name|int
name|min_bytes_per_line
init|=
operator|(
name|width
operator|*
name|depth
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|bpl
operator|<=
literal|0
condition|)
name|bpl
operator|=
name|calc_bytes_per_line
expr_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
operator|!
name|data
operator|||
name|INT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|uchar
operator|*
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|depth
argument_list|)
operator|<
name|uint
argument_list|(
name|width
argument_list|)
operator|||
name|bpl
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
operator|||
name|bpl
operator|<
name|min_bytes_per_line
operator|||
name|INT_MAX
operator|/
name|uint
argument_list|(
name|bpl
argument_list|)
operator|<
name|uint
argument_list|(
name|height
argument_list|)
condition|)
return|return
name|d
return|;
comment|// invalid parameter(s)
name|d
operator|=
operator|new
name|QImageData
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|->
name|own_data
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|ro_data
operator|=
name|readOnly
expr_stmt|;
name|d
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|d
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|d
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|d
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|d
operator|->
name|bytes_per_line
operator|=
name|bpl
expr_stmt|;
name|d
operator|->
name|nbytes
operator|=
name|d
operator|->
name|bytes_per_line
operator|*
name|height
expr_stmt|;
name|d
operator|->
name|cleanupFunction
operator|=
name|cleanupFunction
expr_stmt|;
name|d
operator|->
name|cleanupInfo
operator|=
name|cleanupInfo
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels, \a data must be 32-bit aligned,     and each scanline of data in the image must also be 32-bit aligned.      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|data
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
literal|false
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing read-only memory buffer, \a     data. The \a width and \a height must be specified in pixels, \a     data must be 32-bit aligned, and each scanline of data in the     image must also be 32-bit aligned.      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used.      Unlike the similar QImage constructor that takes a non-const data buffer,     this version will never alter the contents of the buffer.  For example,     calling QImage::bits() will return a deep copy of the image, rather than     the buffer passed to the constructor.  This allows for the efficiency of     constructing a QImage from raw data, without the possibility of the raw     data being changed. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
literal|true
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels. \a bytesPerLine     specifies the number of bytes per line (stride).      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bytesPerLine
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
name|data
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bytesPerLine
argument_list|,
name|format
argument_list|,
literal|false
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image with the given \a width, \a height and \a     format, that uses an existing memory buffer, \a data. The \a width     and \a height must be specified in pixels. \a bytesPerLine     specifies the number of bytes per line (stride).      The buffer must remain valid throughout the life of the QImage and     all copies that have not been modified or otherwise detached from     the original buffer. The image does not delete the buffer at destruction.     You can provide a function pointer \a cleanupFunction along with an     extra pointer \a cleanupInfo that will be called when the last copy     is destroyed.      If \a format is an indexed color format, the image color table is     initially empty and must be sufficiently expanded with     setColorCount() or setColorTable() before the image is used.      Unlike the similar QImage constructor that takes a non-const data buffer,     this version will never alter the contents of the buffer.  For example,     calling QImage::bits() will return a deep copy of the image, rather than     the buffer passed to the constructor.  This allows for the efficiency of     constructing a QImage from raw data, without the possibility of the raw     data being changed. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bytesPerLine
parameter_list|,
name|Format
name|format
parameter_list|,
name|QImageCleanupFunction
name|cleanupFunction
parameter_list|,
name|void
modifier|*
name|cleanupInfo
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
name|QImageData
operator|::
name|create
argument_list|(
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bytesPerLine
argument_list|,
name|format
argument_list|,
literal|true
argument_list|,
name|cleanupFunction
argument_list|,
name|cleanupInfo
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an image and tries to load the image from the file with     the given \a fileName.      The loader attempts to read the image using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      If the loading of the image failed, this object is a null image.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      \sa isNull(), {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
literal|0
expr_stmt|;
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
end_ifndef
begin_function_decl
specifier|extern
name|bool
name|qt_read_xpm_image_or_array
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|source
parameter_list|,
name|QImage
modifier|&
name|image
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     Constructs an image from the given \a xpm image.      Make sure that the image is a valid XPM image. Errors are silently     ignored.      Note that it's possible to squeeze the XPM variable a little bit     by using an unusual declaration:      \snippet code/src_gui_image_qimage.cpp 2      The extra \c const makes the entire definition read-only, which is     slightly more efficient (e.g., when the code is in a shared     library) and able to be stored in ROM with the application. */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|xpm
index|[]
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xpm
condition|)
return|return;
if|if
condition|(
operator|!
name|qt_read_xpm_image_or_array
argument_list|(
literal|0
argument_list|,
name|xpm
argument_list|,
operator|*
name|this
argument_list|)
condition|)
comment|// Issue: Warning because the constructor may be ambigious
name|qWarning
argument_list|(
literal|"QImage::QImage(), XPM is not supported"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IMAGEFORMAT_XPM
end_comment
begin_comment
comment|/*!     Constructs a shallow copy of the given \a image.      For more information about shallow copies, see the \l {Implicit     Data Sharing} documentation.      \sa copy() */
end_comment
begin_constructor
DECL|function|QImage
name|QImage
operator|::
name|QImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
name|image
operator|.
name|paintingActive
argument_list|()
operator|||
name|isLocked
argument_list|(
name|image
operator|.
name|d
argument_list|)
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
name|image
operator|.
name|copy
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|image
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Destroys the image and cleans up. */
end_comment
begin_destructor
DECL|function|~QImage
name|QImage
operator|::
name|~
name|QImage
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns a shallow copy of the given \a image to this image and     returns a reference to this image.      For more information about shallow copies, see the \l {Implicit     Data Sharing} documentation.      \sa copy(), QImage() */
end_comment
begin_function
DECL|function|operator =
name|QImage
modifier|&
name|QImage
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|paintingActive
argument_list|()
operator|||
name|isLocked
argument_list|(
name|image
operator|.
name|d
argument_list|)
condition|)
block|{
name|operator
name|=
argument_list|(
name|image
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|image
operator|.
name|d
condition|)
name|image
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|image
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::swap(QImage&other)     \since 4.8      Swaps image \a other with this image. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QImage
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Image
return|;
block|}
end_function
begin_comment
comment|/*!    Returns the image as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QImage
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Image
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      If multiple images share common data, this image makes a copy of     the data and detaches itself from the sharing mechanism, making     sure that this image is the only one referring to the data.      Nothing is done if there is just a single reference.      \sa copy(), isDetached(), {Implicit Data Sharing} */
end_comment
begin_function
DECL|function|detach
name|void
name|QImage
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|is_cached
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executeImageHooks
argument_list|(
name|cacheKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
operator|||
name|d
operator|->
name|ro_data
condition|)
operator|*
name|this
operator|=
name|copy
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
operator|++
name|d
operator|->
name|detach_no
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::copy(int x, int y, int width, int height) const     \overload      The returned image is copied from the position (\a x, \a y) in     this image, and will always have the given \a width and \a height.     In areas beyond this image, pixels are set to 0.  */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::copy(const QRect& rectangle) const      Returns a sub-area of the image as a new image.      The returned image is copied from the position (\a     {rectangle}.x(), \a{rectangle}.y()) in this image, and will always     have the size of the given \a rectangle.      In areas beyond this image, pixels are set to 0. For 32-bit RGB     images, this means black; for 32-bit ARGB images, this means     transparent black; for 8-bit images, this means the color with     index 0 in the color table which can be anything; for 1-bit     images, this means Qt::color0.      If the given \a rectangle is a null rectangle the entire image is     copied.      \sa QImage() */
end_comment
begin_function
DECL|function|copy
name|QImage
name|QImage
operator|::
name|copy
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|image
return|;
comment|// Qt for Embedded Linux can create images with non-default bpl
comment|// make sure we don't crash.
if|if
condition|(
name|image
operator|.
name|d
operator|->
name|nbytes
operator|!=
name|d
operator|->
name|nbytes
condition|)
block|{
name|int
name|bpl
init|=
name|qMin
argument_list|(
name|bytesPerLine
argument_list|()
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|height
argument_list|()
condition|;
name|i
operator|++
control|)
name|memcpy
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|scanLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|,
name|bits
argument_list|()
argument_list|,
name|d
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|dpmx
operator|=
name|d
operator|->
name|dpmx
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|dpmy
operator|=
name|d
operator|->
name|dpmy
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|d
operator|->
name|offset
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|text
operator|=
name|d
operator|->
name|text
expr_stmt|;
return|return
name|image
return|;
block|}
name|int
name|x
init|=
name|r
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|r
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|dx
init|=
literal|0
decl_stmt|;
name|int
name|dy
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|image
return|;
if|if
condition|(
name|x
argument_list|<
literal|0
operator|||
name|y
argument_list|<
literal|0
operator|||
name|x
operator|+
name|w
argument_list|>
name|d
operator|->
name|width
operator|||
name|y
operator|+
name|h
argument_list|>
name|d
operator|->
name|height
condition|)
block|{
comment|// bitBlt will not cover entire image - clear it.
name|image
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|x
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|y
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|image
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|int
name|pixels_to_copy
init|=
name|qMax
argument_list|(
name|w
operator|-
name|dx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|d
operator|->
name|width
condition|)
name|pixels_to_copy
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pixels_to_copy
operator|>
name|d
operator|->
name|width
operator|-
name|x
condition|)
name|pixels_to_copy
operator|=
name|d
operator|->
name|width
operator|-
name|x
expr_stmt|;
name|int
name|lines_to_copy
init|=
name|qMax
argument_list|(
name|h
operator|-
name|dy
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|>
name|d
operator|->
name|height
condition|)
name|lines_to_copy
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|lines_to_copy
operator|>
name|d
operator|->
name|height
operator|-
name|y
condition|)
name|lines_to_copy
operator|=
name|d
operator|->
name|height
operator|-
name|y
expr_stmt|;
name|bool
name|byteAligned
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Mono
operator|||
name|d
operator|->
name|format
operator|==
name|Format_MonoLSB
condition|)
name|byteAligned
operator|=
operator|!
operator|(
name|dx
operator|&
literal|7
operator|)
operator|&&
operator|!
operator|(
name|x
operator|&
literal|7
operator|)
operator|&&
operator|!
operator|(
name|pixels_to_copy
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|byteAligned
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
operator|(
operator|(
name|x
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
operator|)
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
operator|(
operator|(
name|dx
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
operator|)
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
specifier|const
name|int
name|bytes_to_copy
init|=
operator|(
name|pixels_to_copy
operator|*
name|d
operator|->
name|depth
operator|)
operator|>>
literal|3
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Mono
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pixels_to_copy
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|src
index|[
operator|(
name|x
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|x
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x80
operator|>>
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Format_MonoLSB
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|format
operator|==
name|Format_MonoLSB
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|image
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|image
operator|.
name|d
operator|->
name|bytes_per_line
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines_to_copy
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|pixels_to_copy
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|src
index|[
operator|(
name|x
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|x
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|dest
index|[
operator|(
name|dx
operator|+
name|j
operator|)
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
operator|(
operator|(
name|dx
operator|+
name|j
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|src
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
name|image
operator|.
name|d
operator|->
name|dpmx
operator|=
name|dotsPerMeterX
argument_list|()
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|dpmy
operator|=
name|dotsPerMeterY
argument_list|()
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|devicePixelRatio
operator|=
name|devicePixelRatio
argument_list|()
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|offset
operator|=
name|offset
argument_list|()
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|text
operator|=
name|d
operator|->
name|text
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::isNull() const      Returns true if it is a null image, otherwise returns false.      A null image has all parameters set to zero and no allocated data. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QImage
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::width() const      Returns the width of the image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|width
name|int
name|QImage
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|width
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::height() const      Returns the height of the image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|height
name|int
name|QImage
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|height
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QImage::size() const      Returns the size of the image, i.e. its width() and height().      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|size
name|QSize
name|QImage
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QSize
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QImage::rect() const      Returns the enclosing rectangle (0, 0, width(), height()) of the     image.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|rect
name|QRect
name|QImage
operator|::
name|rect
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|)
else|:
name|QRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the depth of the image.      The image depth is the number of bits used to store a single     pixel, also called bits per pixel (bpp).      The supported depths are 1, 8, 16, 24 and 32.      \sa bitPlaneCount(), convertToFormat(), {QImage#Image Formats}{Image Formats},     {QImage#Image Information}{Image Information}  */
end_comment
begin_function
DECL|function|depth
name|int
name|QImage
operator|::
name|depth
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|depth
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \fn int QImage::numColors() const      Returns the size of the color table for the image.      \sa setColorCount() */
end_comment
begin_comment
comment|/*!     \since 4.6     \fn int QImage::colorCount() const      Returns the size of the color table for the image.      Notice that colorCount() returns 0 for 32-bpp images because these     images do not use color tables, but instead encode pixel values as     ARGB quadruplets.      \sa setColorCount(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|colorCount
name|int
name|QImage
operator|::
name|colorCount
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the color table used to translate color indexes to QRgb     values, to the specified \a colors.      When the image is used, the color table must be large enough to     have entries for all the pixel/index values present in the image,     otherwise the results are undefined.      \sa colorTable(), setColor(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|setColorTable
name|void
name|QImage
operator|::
name|setColorTable
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|d
operator|->
name|colortable
operator|=
name|colors
expr_stmt|;
name|d
operator|->
name|has_alpha_clut
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|qAlpha
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|255
condition|)
block|{
name|d
operator|->
name|has_alpha_clut
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a list of the colors contained in the image's color table,     or an empty list if the image does not have a color table      \sa setColorTable(), colorCount(), color() */
end_comment
begin_function
DECL|function|colorTable
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|QImage
operator|::
name|colorTable
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|colortable
else|:
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the device pixel ratio for the image. This is the     ratio between image pixels and device-independent pixels.      Use this function when calculating layout geometry based on     the image size: QSize layoutSize = image.size() / image.devicePixelRatio()      The default value is 1.0.      \sa setDevicePixelRatio() */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QImage
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|1.0
return|;
return|return
name|d
operator|->
name|devicePixelRatio
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the the device pixel ratio for the image. This is the     ratio between image pixels and device-independent pixels.      The default value is 1.0. Setting it to something else has     two effects:      QPainters that are opened on the image will be scaled. For     example, painting on a 200x200 image if with a ratio of 2.0     will result in effective (device-independent) painting bounds     of 100x100.      Code paths in Qt that calculate layout geometry based on the     image size will take the ratio into account:     QSize layoutSize = image.size() / image.devicePixelRatio()     The net effect of this is that the image is displayed as     high-dpi image rather than a large image.      \sa devicePixelRatio() */
end_comment
begin_function
DECL|function|setDevicePixelRatio
name|void
name|QImage
operator|::
name|setDevicePixelRatio
parameter_list|(
name|qreal
name|scaleFactor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|devicePixelRatio
operator|=
name|scaleFactor
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the number of bytes occupied by the image data.      \sa bytesPerLine(), bits(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|byteCount
name|int
name|QImage
operator|::
name|byteCount
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|nbytes
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bytes per image scanline.      This is equivalent to byteCount() / height().      \sa scanLine() */
end_comment
begin_function
DECL|function|bytesPerLine
name|int
name|QImage
operator|::
name|bytesPerLine
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|d
operator|&&
name|d
operator|->
name|height
operator|)
condition|?
name|d
operator|->
name|nbytes
operator|/
name|d
operator|->
name|height
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the color in the color table at index \a i. The first     color is at index 0.      The colors in an image's color table are specified as ARGB     quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and     qBlue() functions to get the color value components.      \sa setColor(), pixelIndex(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_function
DECL|function|color
name|QRgb
name|QImage
operator|::
name|color
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|i
operator|<
name|colorCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
condition|?
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
else|:
name|QRgb
argument_list|(
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setColor(int index, QRgb colorValue)      Sets the color at the given \a index in the color table, to the     given to \a colorValue. The color value is an ARGB quadruplet.      If \a index is outside the current size of the color table, it is     expanded with setColorCount().      \sa color(), colorCount(), setColorTable(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_function
DECL|function|setColor
name|void
name|QImage
operator|::
name|setColor
parameter_list|(
name|int
name|i
parameter_list|,
name|QRgb
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|i
argument_list|<
literal|0
operator|||
name|d
operator|->
name|depth
argument_list|>
literal|8
operator|||
name|i
operator|>=
literal|1
operator|<<
name|d
operator|->
name|depth
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setColor: Index out of bound %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() run out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|i
operator|>=
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
name|setColorCount
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|has_alpha_clut
operator||=
operator|(
name|qAlpha
argument_list|(
name|c
argument_list|)
operator|!=
literal|255
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the pixel data at the scanline with index \a     i. The first scanline is at index 0.      The scanline data is aligned on a 32-bit boundary.      \warning If you are accessing 32-bpp image data, cast the returned     pointer to \c{QRgb*} (QRgb has a 32-bit size) and use it to     read/write the pixel value. You cannot use the \c{uchar*} pointer     directly, because the pixel format depends on the byte order on     the underlying platform. Use qRed(), qGreen(), qBlue(), and     qAlpha() to access the pixels.      \sa bytesPerLine(), bits(), {QImage#Pixel Manipulation}{Pixel     Manipulation}, constScanLine() */
end_comment
begin_function
DECL|function|scanLine
name|uchar
modifier|*
name|QImage
operator|::
name|scanLine
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|scanLine
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|scanLine
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the pixel data at the scanline with index \a     i. The first scanline is at index 0.      The scanline data is aligned on a 32-bit boundary.      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const.      \sa scanLine(), constBits()     \since 4.7 */
end_comment
begin_function
DECL|function|constScanLine
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|constScanLine
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|data
operator|+
name|i
operator|*
name|d
operator|->
name|bytes_per_line
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the first pixel data. This is equivalent to     scanLine(0).      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}. This function performs a deep copy of the shared pixel     data, thus ensuring that this QImage is the only one using the     current return value.      \sa scanLine(), byteCount(), constBits() */
end_comment
begin_function
DECL|function|bits
name|uchar
modifier|*
name|QImage
operator|::
name|bits
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach ran out of memory...
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const. */
end_comment
begin_function
DECL|function|bits
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|bits
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|data
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the first pixel data.      Note that QImage uses \l{Implicit Data Sharing} {implicit data     sharing}, but this function does \e not perform a deep copy of the     shared pixel data, because the returned data is const.      \sa bits(), constScanLine()     \since 4.7 */
end_comment
begin_function
DECL|function|constBits
specifier|const
name|uchar
modifier|*
name|QImage
operator|::
name|constBits
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|data
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(uint pixelValue)      Fills the entire image with the given \a pixelValue.      If the depth of this image is 1, only the lowest bit is used. If     you say fill(0), fill(2), etc., the image is filled with 0s. If     you say fill(1), fill(3), etc., the image is filled with 1s. If     the depth is 8, the lowest 8 bits are used and if the depth is 16     the lowest 16 bits are used.      Note: QImage::pixel() returns the color of the pixel at the given     coordinates while QColor::pixel() returns the pixel value of the     underlying window system (essentially an index value), so normally     you will want to use QImage::pixel() to use a color from an     existing image or QColor::rgb() to use a specific color.      \sa depth(), {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
name|uint
name|pixel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
operator|||
name|d
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pixel
operator|&
literal|1
condition|)
name|pixel
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|pixel
operator|=
literal|0
expr_stmt|;
name|w
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|pixel
operator|&=
literal|0xff
expr_stmt|;
block|}
name|qt_rectfill
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|16
condition|)
block|{
name|qt_rectfill
argument_list|<
name|quint16
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|24
condition|)
block|{
name|qt_rectfill
argument_list|<
name|quint24
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_RGB32
condition|)
name|pixel
operator||=
literal|0xff000000
expr_stmt|;
name|qt_rectfill
argument_list|<
name|uint
argument_list|>
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|)
argument_list|,
name|pixel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(Qt::GlobalColor color)     \overload     \since 4.8      Fills the image with the given \a color, described as a standard global     color.  */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
name|Qt
operator|::
name|GlobalColor
name|color
parameter_list|)
block|{
name|fill
argument_list|(
name|QColor
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::fill(const QColor&color)      \overload      Fills the entire image with the given \a color.      If the depth of the image is 1, the image will be filled with 1 if     \a color equals Qt::color1; it will otherwise be filled with 0.      If the depth of the image is 8, the image will be filled with the     index corresponding the \a color in the color table if present; it     will otherwise be filled with 0.      \since 4.8 */
end_comment
begin_function
DECL|function|fill
name|void
name|QImage
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case we run out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|32
condition|)
block|{
name|uint
name|pixel
init|=
name|color
operator|.
name|rgba
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
name|pixel
operator|=
name|PREMUL
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
name|fill
argument_list|(
operator|(
name|uint
operator|)
name|pixel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB16
condition|)
block|{
name|fill
argument_list|(
operator|(
name|uint
operator|)
name|qConvertRgb32To16
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|color
operator|==
name|Qt
operator|::
name|color1
condition|)
name|fill
argument_list|(
operator|(
name|uint
operator|)
literal|1
argument_list|)
expr_stmt|;
else|else
name|fill
argument_list|(
operator|(
name|uint
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
name|uint
name|pixel
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|color
operator|.
name|rgba
argument_list|()
operator|==
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|pixel
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|fill
argument_list|(
name|pixel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPainter
name|p
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|p
operator|.
name|fillRect
argument_list|(
name|rect
argument_list|()
argument_list|,
name|color
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Inverts all pixel values in the image.      The given invert \a mode only have a meaning when the image's     depth is 32. The default \a mode is InvertRgb, which leaves the     alpha channel unchanged. If the \a mode is InvertRgba, the alpha     bits are also inverted.      Inverting an 8-bit image means to replace all pixels using color     index \e i with a pixel using color index 255 minus \e i. The same     is the case for a 1-bit image. Note that the color table is \e not     changed.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|invertPixels
name|void
name|QImage
operator|::
name|invertPixels
parameter_list|(
name|InvertMode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|depth
argument_list|()
operator|!=
literal|32
condition|)
block|{
comment|// number of used bytes pr line
name|int
name|bpl
init|=
operator|(
name|d
operator|->
name|width
operator|*
name|d
operator|->
name|depth
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|int
name|pad
init|=
name|d
operator|->
name|bytes_per_line
operator|-
name|bpl
decl_stmt|;
name|uchar
modifier|*
name|sl
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|bpl
condition|;
operator|++
name|x
control|)
operator|*
name|sl
operator|++
operator|^=
literal|0xff
expr_stmt|;
name|sl
operator|+=
name|pad
expr_stmt|;
block|}
block|}
else|else
block|{
name|quint32
modifier|*
name|p
init|=
operator|(
name|quint32
operator|*
operator|)
name|d
operator|->
name|data
decl_stmt|;
name|quint32
modifier|*
name|end
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|d
operator|->
name|nbytes
operator|)
decl_stmt|;
name|uint
name|xorbits
init|=
operator|(
name|mode
operator|==
name|InvertRgba
operator|)
condition|?
literal|0xffffffff
else|:
literal|0x00ffffff
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|^=
name|xorbits
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Windows defines these
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|write
argument_list|)
end_if
begin_undef
DECL|macro|write
undef|#
directive|undef
name|write
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|close
argument_list|)
end_if
begin_undef
DECL|macro|close
undef|#
directive|undef
name|close
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|read
argument_list|)
end_if
begin_undef
DECL|macro|read
undef|#
directive|undef
name|read
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.6     Resizes the color table to contain \a colorCount entries.      If the color table is expanded, all the extra colors will be set to     transparent (i.e qRgba(0, 0, 0, 0)).      When the image is used, the color table must be large enough to     have entries for all the pixel/index values present in the image,     otherwise the results are undefined.      \sa colorCount(), colorTable(), setColor(), {QImage#Image     Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|setColorCount
name|void
name|QImage
operator|::
name|setColorCount
parameter_list|(
name|int
name|colorCount
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setColorCount: null image"
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
comment|// In case detach() ran out of memory
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|colorCount
operator|==
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
return|return;
if|if
condition|(
name|colorCount
operator|<=
literal|0
condition|)
block|{
comment|// use no color table
name|d
operator|->
name|colortable
operator|=
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
expr_stmt|;
return|return;
block|}
name|int
name|nc
init|=
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
decl_stmt|;
name|d
operator|->
name|colortable
operator|.
name|resize
argument_list|(
name|colorCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nc
init|;
name|i
operator|<
name|colorCount
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of the image.      \sa {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|format
name|QImage
operator|::
name|Format
name|QImage
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|format
else|:
name|Format_Invalid
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Internal routines for converting image depth.  *****************************************************************************/
end_comment
begin_typedef
DECL|typedef|Image_Converter
typedef|typedef
name|void
function_decl|(
modifier|*
name|Image_Converter
function_decl|)
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|InPlace_Image_Converter
typedef|typedef
name|bool
function_decl|(
modifier|*
name|InPlace_Image_Converter
function_decl|)
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
function_decl|;
end_typedef
begin_function
DECL|function|convert_ARGB_to_ARGB_PM
specifier|static
name|void
name|convert_ARGB_to_ARGB_PM
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
specifier|const
name|int
name|src_pad
init|=
operator|(
name|src
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|src
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dest
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|dest
operator|->
name|width
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|src_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|src
operator|->
name|data
decl_stmt|;
name|QRgb
modifier|*
name|dest_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|src_data
operator|+
name|src
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|src_data
operator|<
name|end
condition|)
block|{
operator|*
name|dest_data
operator|=
name|PREMUL
argument_list|(
operator|*
name|src_data
argument_list|)
expr_stmt|;
operator|++
name|src_data
expr_stmt|;
operator|++
name|dest_data
expr_stmt|;
block|}
name|src_data
operator|+=
name|src_pad
expr_stmt|;
name|dest_data
operator|+=
name|dest_pad
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convert_ARGB_to_ARGB_PM_inplace
specifier|static
name|bool
name|convert_ARGB_to_ARGB_PM_inplace
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pad
init|=
operator|(
name|data
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|data
operator|->
name|width
decl_stmt|;
name|QRgb
modifier|*
name|rgb_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|data
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|rgb_data
operator|+
name|data
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|rgb_data
operator|<
name|end
condition|)
block|{
operator|*
name|rgb_data
operator|=
name|PREMUL
argument_list|(
operator|*
name|rgb_data
argument_list|)
expr_stmt|;
operator|++
name|rgb_data
expr_stmt|;
block|}
name|rgb_data
operator|+=
name|pad
expr_stmt|;
block|}
name|data
operator|->
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|convert_indexed8_to_ARGB_PM_inplace
specifier|static
name|bool
name|convert_indexed8_to_ARGB_PM_inplace
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
specifier|const
name|int
name|depth
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|dst_bytes_per_line
init|=
operator|(
operator|(
name|data
operator|->
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|nbytes
init|=
name|dst_bytes_per_line
operator|*
name|data
operator|->
name|height
decl_stmt|;
name|uchar
modifier|*
specifier|const
name|newData
init|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newData
condition|)
return|return
literal|false
return|;
name|data
operator|->
name|data
operator|=
name|newData
expr_stmt|;
comment|// start converting from the end because the end image is bigger than the source
name|uchar
modifier|*
name|src_data
init|=
name|newData
operator|+
name|data
operator|->
name|nbytes
decl_stmt|;
comment|// end of src
name|quint32
modifier|*
name|dest_data
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|newData
operator|+
name|nbytes
operator|)
decl_stmt|;
comment|// end of dest> end of src
specifier|const
name|int
name|width
init|=
name|data
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|src_pad
init|=
name|data
operator|->
name|bytes_per_line
operator|-
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dst_bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|width
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|data
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|data
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|PREMUL
argument_list|(
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fill the rest of the table in case src_data> colortable.size()
specifier|const
name|int
name|oldSize
init|=
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|QRgb
name|lastColor
init|=
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|oldSize
operator|-
literal|1
argument_list|)
decl_stmt|;
name|data
operator|->
name|colortable
operator|.
name|insert
argument_list|(
name|oldSize
argument_list|,
literal|256
operator|-
name|oldSize
argument_list|,
name|lastColor
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
name|src_data
operator|-=
name|src_pad
expr_stmt|;
name|dest_data
operator|-=
name|dest_pad
expr_stmt|;
for|for
control|(
name|int
name|pixI
init|=
literal|0
init|;
name|pixI
operator|<
name|width
condition|;
operator|++
name|pixI
control|)
block|{
operator|--
name|src_data
expr_stmt|;
operator|--
name|dest_data
expr_stmt|;
operator|*
name|dest_data
operator|=
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|*
name|src_data
argument_list|)
expr_stmt|;
block|}
block|}
name|data
operator|->
name|colortable
operator|=
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
expr_stmt|;
name|data
operator|->
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
name|data
operator|->
name|bytes_per_line
operator|=
name|dst_bytes_per_line
expr_stmt|;
name|data
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|data
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|convert_indexed8_to_RGB_inplace
specifier|static
name|bool
name|convert_indexed8_to_RGB_inplace
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
specifier|const
name|int
name|depth
init|=
literal|32
decl_stmt|;
specifier|const
name|int
name|dst_bytes_per_line
init|=
operator|(
operator|(
name|data
operator|->
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|nbytes
init|=
name|dst_bytes_per_line
operator|*
name|data
operator|->
name|height
decl_stmt|;
name|uchar
modifier|*
specifier|const
name|newData
init|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newData
condition|)
return|return
literal|false
return|;
name|data
operator|->
name|data
operator|=
name|newData
expr_stmt|;
comment|// start converting from the end because the end image is bigger than the source
name|uchar
modifier|*
name|src_data
init|=
name|newData
operator|+
name|data
operator|->
name|nbytes
decl_stmt|;
name|quint32
modifier|*
name|dest_data
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|newData
operator|+
name|nbytes
operator|)
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|data
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|src_pad
init|=
name|data
operator|->
name|bytes_per_line
operator|-
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dst_bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|width
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|data
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Fill the rest of the table in case src_data> colortable.size()
specifier|const
name|int
name|oldSize
init|=
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|QRgb
name|lastColor
init|=
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|oldSize
operator|-
literal|1
argument_list|)
decl_stmt|;
name|data
operator|->
name|colortable
operator|.
name|insert
argument_list|(
name|oldSize
argument_list|,
literal|256
operator|-
name|oldSize
argument_list|,
name|lastColor
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
name|src_data
operator|-=
name|src_pad
expr_stmt|;
name|dest_data
operator|-=
name|dest_pad
expr_stmt|;
for|for
control|(
name|int
name|pixI
init|=
literal|0
init|;
name|pixI
operator|<
name|width
condition|;
operator|++
name|pixI
control|)
block|{
operator|--
name|src_data
expr_stmt|;
operator|--
name|dest_data
expr_stmt|;
operator|*
name|dest_data
operator|=
operator|(
name|quint32
operator|)
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|*
name|src_data
argument_list|)
expr_stmt|;
block|}
block|}
name|data
operator|->
name|colortable
operator|=
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
expr_stmt|;
name|data
operator|->
name|format
operator|=
name|QImage
operator|::
name|Format_RGB32
expr_stmt|;
name|data
operator|->
name|bytes_per_line
operator|=
name|dst_bytes_per_line
expr_stmt|;
name|data
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|data
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|convert_indexed8_to_RGB16_inplace
specifier|static
name|bool
name|convert_indexed8_to_RGB16_inplace
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
specifier|const
name|int
name|depth
init|=
literal|16
decl_stmt|;
specifier|const
name|int
name|dst_bytes_per_line
init|=
operator|(
operator|(
name|data
operator|->
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|nbytes
init|=
name|dst_bytes_per_line
operator|*
name|data
operator|->
name|height
decl_stmt|;
name|uchar
modifier|*
specifier|const
name|newData
init|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newData
condition|)
return|return
literal|false
return|;
name|data
operator|->
name|data
operator|=
name|newData
expr_stmt|;
comment|// start converting from the end because the end image is bigger than the source
name|uchar
modifier|*
name|src_data
init|=
name|newData
operator|+
name|data
operator|->
name|nbytes
decl_stmt|;
name|quint16
modifier|*
name|dest_data
init|=
operator|(
name|quint16
operator|*
operator|)
operator|(
name|newData
operator|+
name|nbytes
operator|)
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|data
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|src_pad
init|=
name|data
operator|->
name|bytes_per_line
operator|-
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dst_bytes_per_line
operator|>>
literal|1
operator|)
operator|-
name|width
decl_stmt|;
name|quint16
name|colorTableRGB16
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|colortable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|colorTableRGB16
index|[
name|i
index|]
operator|=
name|qConvertRgb32To16
argument_list|(
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 1) convert the existing colors to RGB16
specifier|const
name|int
name|tableSize
init|=
name|data
operator|->
name|colortable
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
operator|++
name|i
control|)
name|colorTableRGB16
index|[
name|i
index|]
operator|=
name|qConvertRgb32To16
argument_list|(
name|data
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|colortable
operator|=
name|QVector
argument_list|<
name|QRgb
argument_list|>
argument_list|()
expr_stmt|;
comment|// 2) fill the rest of the table in case src_data> colortable.size()
specifier|const
name|quint16
name|lastColor
init|=
name|colorTableRGB16
index|[
name|tableSize
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|tableSize
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|colorTableRGB16
index|[
name|i
index|]
operator|=
name|lastColor
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
name|src_data
operator|-=
name|src_pad
expr_stmt|;
name|dest_data
operator|-=
name|dest_pad
expr_stmt|;
for|for
control|(
name|int
name|pixI
init|=
literal|0
init|;
name|pixI
operator|<
name|width
condition|;
operator|++
name|pixI
control|)
block|{
operator|--
name|src_data
expr_stmt|;
operator|--
name|dest_data
expr_stmt|;
operator|*
name|dest_data
operator|=
name|colorTableRGB16
index|[
operator|*
name|src_data
index|]
expr_stmt|;
block|}
block|}
name|data
operator|->
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
name|data
operator|->
name|bytes_per_line
operator|=
name|dst_bytes_per_line
expr_stmt|;
name|data
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|data
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|convert_RGB_to_RGB16_inplace
specifier|static
name|bool
name|convert_RGB_to_RGB16_inplace
parameter_list|(
name|QImageData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
specifier|const
name|int
name|depth
init|=
literal|16
decl_stmt|;
specifier|const
name|int
name|dst_bytes_per_line
init|=
operator|(
operator|(
name|data
operator|->
name|width
operator|*
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|const
name|int
name|src_bytes_per_line
init|=
name|data
operator|->
name|bytes_per_line
decl_stmt|;
name|quint32
modifier|*
name|src_data
init|=
operator|(
name|quint32
operator|*
operator|)
name|data
operator|->
name|data
decl_stmt|;
name|quint16
modifier|*
name|dst_data
init|=
operator|(
name|quint16
operator|*
operator|)
name|data
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|data
operator|->
name|width
condition|;
operator|++
name|j
control|)
name|dst_data
index|[
name|j
index|]
operator|=
name|qConvertRgb32To16
argument_list|(
name|src_data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|src_data
operator|=
operator|(
name|quint32
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|src_data
operator|)
operator|+
name|src_bytes_per_line
operator|)
expr_stmt|;
name|dst_data
operator|=
operator|(
name|quint16
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dst_data
operator|)
operator|+
name|dst_bytes_per_line
operator|)
expr_stmt|;
block|}
name|data
operator|->
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
name|data
operator|->
name|bytes_per_line
operator|=
name|dst_bytes_per_line
expr_stmt|;
name|data
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|data
operator|->
name|nbytes
operator|=
name|dst_bytes_per_line
operator|*
name|data
operator|->
name|height
expr_stmt|;
name|uchar
modifier|*
specifier|const
name|newData
init|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|newData
condition|)
block|{
name|data
operator|->
name|data
operator|=
name|newData
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|convert_ARGB_PM_to_ARGB
specifier|static
name|void
name|convert_ARGB_PM_to_ARGB
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
specifier|const
name|int
name|src_pad
init|=
operator|(
name|src
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|src
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dest
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|dest
operator|->
name|width
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|src_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|src
operator|->
name|data
decl_stmt|;
name|QRgb
modifier|*
name|dest_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|src_data
operator|+
name|src
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|src_data
operator|<
name|end
condition|)
block|{
operator|*
name|dest_data
operator|=
name|INV_PREMUL
argument_list|(
operator|*
name|src_data
argument_list|)
expr_stmt|;
operator|++
name|src_data
expr_stmt|;
operator|++
name|dest_data
expr_stmt|;
block|}
name|src_data
operator|+=
name|src_pad
expr_stmt|;
name|dest_data
operator|+=
name|dest_pad
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convert_ARGB_PM_to_RGB
specifier|static
name|void
name|convert_ARGB_PM_to_RGB
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
specifier|const
name|int
name|src_pad
init|=
operator|(
name|src
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|src
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dest
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|dest
operator|->
name|width
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|src_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|src
operator|->
name|data
decl_stmt|;
name|QRgb
modifier|*
name|dest_data
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|src_data
operator|+
name|src
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|src_data
operator|<
name|end
condition|)
block|{
operator|*
name|dest_data
operator|=
literal|0xff000000
operator||
name|INV_PREMUL
argument_list|(
operator|*
name|src_data
argument_list|)
expr_stmt|;
operator|++
name|src_data
expr_stmt|;
operator|++
name|dest_data
expr_stmt|;
block|}
name|src_data
operator|+=
name|src_pad
expr_stmt|;
name|dest_data
operator|+=
name|dest_pad
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|swap_bit_order
specifier|static
name|void
name|swap_bit_order
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|nbytes
operator|==
name|dest
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|bytes_per_line
operator|==
name|dest
operator|->
name|bytes_per_line
argument_list|)
expr_stmt|;
name|dest
operator|->
name|colortable
operator|=
name|src
operator|->
name|colortable
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|src
operator|->
name|data
operator|+
name|src
operator|->
name|nbytes
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dest
operator|->
name|data
decl_stmt|;
while|while
condition|(
name|src_data
operator|<
name|end
condition|)
block|{
operator|*
name|dest_data
operator|=
name|bitflip
index|[
operator|*
name|src_data
index|]
expr_stmt|;
operator|++
name|src_data
expr_stmt|;
operator|++
name|dest_data
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mask_alpha_converter
specifier|static
name|void
name|mask_alpha_converter
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
specifier|const
name|int
name|src_pad
init|=
operator|(
name|src
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|src
operator|->
name|width
decl_stmt|;
specifier|const
name|int
name|dest_pad
init|=
operator|(
name|dest
operator|->
name|bytes_per_line
operator|>>
literal|2
operator|)
operator|-
name|dest
operator|->
name|width
decl_stmt|;
specifier|const
name|uint
modifier|*
name|src_data
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|src
operator|->
name|data
decl_stmt|;
name|uint
modifier|*
name|dest_data
init|=
operator|(
name|uint
operator|*
operator|)
name|dest
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint
modifier|*
name|end
init|=
name|src_data
operator|+
name|src
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|src_data
operator|<
name|end
condition|)
block|{
operator|*
name|dest_data
operator|=
operator|*
name|src_data
operator||
literal|0xff000000
expr_stmt|;
operator|++
name|src_data
expr_stmt|;
operator|++
name|dest_data
expr_stmt|;
block|}
name|src_data
operator|+=
name|src_pad
expr_stmt|;
name|dest_data
operator|+=
name|dest_pad
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fix_color_table
specifier|static
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|fix_color_table
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|ctbl
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colorTable
init|=
name|ctbl
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
comment|// check if the color table has alpha
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colorTable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|qAlpha
argument_list|(
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|0xff
argument_list|)
condition|)
name|colorTable
index|[
name|i
index|]
operator|=
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator||
literal|0xff000000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
block|{
comment|// check if the color table has alpha
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colorTable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|colorTable
index|[
name|i
index|]
operator|=
name|PREMUL
argument_list|(
name|colorTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|colorTable
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// dither_to_1:  Uses selected dithering algorithm.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|dither_to_Mono
specifier|static
name|void
name|dither_to_Mono
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|,
name|bool
name|fromalpha
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dst
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dst
operator|->
name|height
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|dst
operator|->
name|colortable
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dst
operator|->
name|colortable
operator|.
name|append
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|colortable
operator|.
name|append
argument_list|(
literal|0xff000000
argument_list|)
expr_stmt|;
enum|enum
block|{
name|Threshold
block|,
name|Ordered
block|,
name|Diffuse
block|}
name|dithermode
enum|;
if|if
condition|(
name|fromalpha
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|AlphaDither_Mask
operator|)
operator|==
name|Qt
operator|::
name|DiffuseAlphaDither
condition|)
name|dithermode
operator|=
name|Diffuse
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|AlphaDither_Mask
operator|)
operator|==
name|Qt
operator|::
name|OrderedAlphaDither
condition|)
name|dithermode
operator|=
name|Ordered
expr_stmt|;
else|else
name|dithermode
operator|=
name|Threshold
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|Dither_Mask
operator|)
operator|==
name|Qt
operator|::
name|ThresholdDither
condition|)
name|dithermode
operator|=
name|Threshold
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|Dither_Mask
operator|)
operator|==
name|Qt
operator|::
name|OrderedDither
condition|)
name|dithermode
operator|=
name|Ordered
expr_stmt|;
else|else
name|dithermode
operator|=
name|Diffuse
expr_stmt|;
block|}
name|int
name|w
init|=
name|src
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|src
operator|->
name|height
decl_stmt|;
name|int
name|d
init|=
name|src
operator|->
name|depth
decl_stmt|;
name|uchar
name|gray
index|[
literal|256
index|]
decl_stmt|;
comment|// gray map for 8 bit images
name|bool
name|use_gray
init|=
operator|(
name|d
operator|==
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|use_gray
condition|)
block|{
comment|// make gray map
if|if
condition|(
name|fromalpha
condition|)
block|{
comment|// Alpha 0x00 -> 0 pixels (white)
comment|// Alpha 0xFF -> 1 pixels (black)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|gray
index|[
name|i
index|]
operator|=
operator|(
literal|255
operator|-
operator|(
name|src
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|>>
literal|24
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Pixel 0x00 -> 1 pixels (black)
comment|// Pixel 0xFF -> 0 pixels (white)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|gray
index|[
name|i
index|]
operator|=
name|qGray
argument_list|(
name|src
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|uchar
modifier|*
name|dst_data
init|=
name|dst
operator|->
name|data
decl_stmt|;
name|int
name|dst_bpl
init|=
name|dst
operator|->
name|bytes_per_line
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|int
name|src_bpl
init|=
name|src
operator|->
name|bytes_per_line
decl_stmt|;
switch|switch
condition|(
name|dithermode
condition|)
block|{
case|case
name|Diffuse
case|:
block|{
name|QScopedArrayPointer
argument_list|<
name|int
argument_list|>
name|lineBuffer
argument_list|(
operator|new
name|int
index|[
name|w
operator|*
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
modifier|*
name|line1
init|=
name|lineBuffer
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
modifier|*
name|line2
init|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|w
decl_stmt|;
name|int
name|bmwidth
init|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|int
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
name|int
name|wbytes
init|=
name|w
operator|*
operator|(
name|d
operator|/
literal|8
operator|)
decl_stmt|;
specifier|register
specifier|const
name|uchar
modifier|*
name|p
init|=
name|src
operator|->
name|data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|p
operator|+
name|wbytes
decl_stmt|;
name|b2
operator|=
name|line2
expr_stmt|;
if|if
condition|(
name|use_gray
condition|)
block|{
comment|// 8 bit image
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|b2
operator|++
operator|=
name|gray
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// 32 bit image
if|if
condition|(
name|fromalpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|b2
operator|++
operator|=
literal|255
operator|-
operator|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|p
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|b2
operator|++
operator|=
name|qGray
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
comment|// for each scan line...
name|int
modifier|*
name|tmp
init|=
name|line1
decl_stmt|;
name|line1
operator|=
name|line2
expr_stmt|;
name|line2
operator|=
name|tmp
expr_stmt|;
name|bool
name|not_last_line
init|=
name|y
operator|<
name|h
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|not_last_line
condition|)
block|{
comment|// calc. grayvals for next line
name|p
operator|=
name|src
operator|->
name|data
operator|+
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|wbytes
expr_stmt|;
name|b2
operator|=
name|line2
expr_stmt|;
if|if
condition|(
name|use_gray
condition|)
block|{
comment|// 8 bit image
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|b2
operator|++
operator|=
name|gray
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// 24 bit image
if|if
condition|(
name|fromalpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|b2
operator|++
operator|=
literal|255
operator|-
operator|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|p
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|b2
operator|++
operator|=
name|qGray
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|err
decl_stmt|;
name|uchar
modifier|*
name|p
init|=
name|dst
operator|->
name|data
operator|+
name|y
operator|*
name|dst
operator|->
name|bytes_per_line
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|bmwidth
argument_list|)
expr_stmt|;
name|b1
operator|=
name|line1
expr_stmt|;
name|b2
operator|=
name|line2
expr_stmt|;
name|int
name|bit
init|=
literal|7
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|1
init|;
name|x
operator|<=
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|b1
operator|<
literal|128
condition|)
block|{
comment|// black pixel
name|err
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
operator|*
name|p
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
block|}
else|else
block|{
comment|// white pixel
name|err
operator|=
operator|*
name|b1
operator|++
operator|-
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
name|w
condition|)
operator|*
name|b1
operator|+=
operator|(
name|err
operator|*
literal|7
operator|)
operator|>>
literal|4
expr_stmt|;
comment|// spread error to right pixel
if|if
condition|(
name|not_last_line
condition|)
block|{
name|b2
index|[
literal|0
index|]
operator|+=
operator|(
name|err
operator|*
literal|5
operator|)
operator|>>
literal|4
expr_stmt|;
comment|// pixel below
if|if
condition|(
name|x
operator|>
literal|1
condition|)
name|b2
index|[
operator|-
literal|1
index|]
operator|+=
operator|(
name|err
operator|*
literal|3
operator|)
operator|>>
literal|4
expr_stmt|;
comment|// pixel below left
if|if
condition|(
name|x
operator|<
name|w
condition|)
name|b2
index|[
literal|1
index|]
operator|+=
name|err
operator|>>
literal|4
expr_stmt|;
comment|// pixel below right
block|}
name|b2
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Ordered
case|:
block|{
name|memset
argument_list|(
name|dst
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|dst
operator|->
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|uint
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|src_data
decl_stmt|;
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
name|uchar
modifier|*
name|m
init|=
name|dst_data
decl_stmt|;
name|int
name|bit
init|=
literal|7
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fromalpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|>>
literal|24
operator|)
operator|>=
name|qt_bayer_matrix
index|[
name|j
operator|++
operator|&
literal|15
index|]
index|[
name|i
operator|&
literal|15
index|]
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|qGray
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<
name|qt_bayer_matrix
index|[
name|j
operator|++
operator|&
literal|15
index|]
index|[
name|i
operator|&
literal|15
index|]
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
block|}
name|dst_data
operator|+=
name|dst_bpl
expr_stmt|;
name|src_data
operator|+=
name|src_bpl
expr_stmt|;
block|}
block|}
else|else
comment|/* (d == 8) */
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|uchar
modifier|*
name|p
init|=
name|src_data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
name|uchar
modifier|*
name|m
init|=
name|dst_data
decl_stmt|;
name|int
name|bit
init|=
literal|7
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|gray
index|[
operator|*
name|p
operator|++
index|]
operator|<
name|qt_bayer_matrix
index|[
name|j
operator|++
operator|&
literal|15
index|]
index|[
name|i
operator|&
literal|15
index|]
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
name|dst_data
operator|+=
name|dst_bpl
expr_stmt|;
name|src_data
operator|+=
name|src_bpl
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
block|{
comment|// Threshold:
name|memset
argument_list|(
name|dst
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|dst
operator|->
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|uint
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|src_data
decl_stmt|;
specifier|const
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
name|uchar
modifier|*
name|m
init|=
name|dst_data
decl_stmt|;
name|int
name|bit
init|=
literal|7
decl_stmt|;
if|if
condition|(
name|fromalpha
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|>>
literal|24
operator|)
operator|>=
literal|128
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
comment|// Set mask "on"
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|qGray
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|<
literal|128
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
comment|// Set pixel "black"
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
block|}
name|dst_data
operator|+=
name|dst_bpl
expr_stmt|;
name|src_data
operator|+=
name|src_bpl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|uchar
modifier|*
name|p
init|=
name|src_data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
name|uchar
modifier|*
name|m
init|=
name|dst_data
decl_stmt|;
name|int
name|bit
init|=
literal|7
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|gray
index|[
operator|*
name|p
operator|++
index|]
operator|<
literal|128
condition|)
operator|*
name|m
operator||=
literal|1
operator|<<
name|bit
expr_stmt|;
comment|// Set mask "on"/ pixel "black"
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
name|bit
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|--
expr_stmt|;
block|}
block|}
name|dst_data
operator|+=
name|dst_bpl
expr_stmt|;
name|src_data
operator|+=
name|src_bpl
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
condition|)
block|{
comment|// need to swap bit order
name|uchar
modifier|*
name|sl
init|=
name|dst
operator|->
name|data
decl_stmt|;
name|int
name|bpl
init|=
operator|(
name|dst
operator|->
name|width
operator|+
literal|7
operator|)
operator|*
name|dst
operator|->
name|depth
operator|/
literal|8
decl_stmt|;
name|int
name|pad
init|=
name|dst
operator|->
name|bytes_per_line
operator|-
name|bpl
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dst
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|bpl
condition|;
operator|++
name|x
control|)
block|{
operator|*
name|sl
operator|=
name|bitflip
index|[
operator|*
name|sl
index|]
expr_stmt|;
operator|++
name|sl
expr_stmt|;
block|}
name|sl
operator|+=
name|pad
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|convert_X_to_Mono
specifier|static
name|void
name|convert_X_to_Mono
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|dither_to_Mono
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|convert_ARGB_PM_to_Mono
specifier|static
name|void
name|convert_ARGB_PM_to_Mono
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QImageData
argument_list|>
name|tmp
argument_list|(
name|QImageData
operator|::
name|create
argument_list|(
name|QSize
argument_list|(
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|)
argument_list|,
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
argument_list|)
decl_stmt|;
name|convert_ARGB_PM_to_ARGB
argument_list|(
name|tmp
operator|.
name|data
argument_list|()
argument_list|,
name|src
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dither_to_Mono
argument_list|(
name|dst
argument_list|,
name|tmp
operator|.
name|data
argument_list|()
argument_list|,
name|flags
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// convert_32_to_8:  Converts a 32 bits depth (true color) to an 8 bit
end_comment
begin_comment
comment|// image with a colormap. If the 32 bit image has more than 256 colors,
end_comment
begin_comment
comment|// we convert the red,green and blue bytes into a single byte encoded
end_comment
begin_comment
comment|// as 6 shades of each of red, green and blue.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// if dithering is needed, only 1 color at most is available for alpha.
end_comment
begin_comment
comment|//
end_comment
begin_struct
DECL|struct|QRgbMap
struct|struct
name|QRgbMap
block|{
DECL|function|QRgbMap
specifier|inline
name|QRgbMap
parameter_list|()
member_init_list|:
name|used
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|member|pix
name|uchar
name|pix
decl_stmt|;
DECL|member|used
name|uchar
name|used
decl_stmt|;
DECL|member|rgb
name|QRgb
name|rgb
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|convert_RGB_to_Indexed8
specifier|static
name|void
name|convert_RGB_to_Indexed8
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
operator|||
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dst
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dst
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dst
operator|->
name|height
argument_list|)
expr_stmt|;
name|bool
name|do_quant
init|=
operator|(
name|flags
operator|&
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator|==
name|Qt
operator|::
name|PreferDither
operator|||
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
decl_stmt|;
name|uint
name|alpha_mask
init|=
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|?
literal|0xff000000
else|:
literal|0
decl_stmt|;
specifier|const
name|int
name|tablesize
init|=
literal|997
decl_stmt|;
comment|// prime
name|QRgbMap
name|table
index|[
name|tablesize
index|]
decl_stmt|;
name|int
name|pix
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dst
operator|->
name|colortable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|ctbl
init|=
name|dst
operator|->
name|colortable
decl_stmt|;
name|dst
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|256
argument_list|)
expr_stmt|;
comment|// Preload palette into table.
comment|// Almost same code as pixel insertion below
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// Find in table...
name|QRgb
name|p
init|=
name|ctbl
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator||
name|alpha_mask
decl_stmt|;
name|int
name|hash
init|=
name|p
operator|%
name|tablesize
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|.
name|used
condition|)
block|{
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|.
name|rgb
operator|==
name|p
condition|)
block|{
comment|// Found previous insertion - use it
break|break;
block|}
else|else
block|{
comment|// Keep searching...
if|if
condition|(
operator|++
name|hash
operator|==
name|tablesize
condition|)
name|hash
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Cannot be in table
name|Q_ASSERT
argument_list|(
name|pix
operator|!=
literal|256
argument_list|)
expr_stmt|;
comment|// too many colors
comment|// Insert into table at this unused position
name|dst
operator|->
name|colortable
index|[
name|pix
index|]
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|pix
operator|=
name|pix
operator|++
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|rgb
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|DitherMode_Mask
operator|)
operator|!=
name|Qt
operator|::
name|PreferDither
condition|)
block|{
name|dst
operator|->
name|colortable
operator|.
name|resize
argument_list|(
literal|256
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dst
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
comment|// check if<= 256 colors
specifier|const
name|QRgb
modifier|*
name|s
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
name|uchar
modifier|*
name|b
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|width
condition|;
operator|++
name|x
control|)
block|{
name|QRgb
name|p
init|=
name|s
index|[
name|x
index|]
operator||
name|alpha_mask
decl_stmt|;
name|int
name|hash
init|=
name|p
operator|%
name|tablesize
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|.
name|used
condition|)
block|{
if|if
condition|(
name|table
index|[
name|hash
index|]
operator|.
name|rgb
operator|==
operator|(
name|p
operator|)
condition|)
block|{
comment|// Found previous insertion - use it
break|break;
block|}
else|else
block|{
comment|// Keep searching...
if|if
condition|(
operator|++
name|hash
operator|==
name|tablesize
condition|)
name|hash
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Cannot be in table
if|if
condition|(
name|pix
operator|==
literal|256
condition|)
block|{
comment|// too many colors
name|do_quant
operator|=
literal|true
expr_stmt|;
comment|// Break right out
name|x
operator|=
name|src
operator|->
name|width
expr_stmt|;
name|y
operator|=
name|src
operator|->
name|height
expr_stmt|;
block|}
else|else
block|{
comment|// Insert into table at this unused position
name|dst
operator|->
name|colortable
index|[
name|pix
index|]
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|pix
operator|=
name|pix
operator|++
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|rgb
operator|=
name|p
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|b
operator|++
operator|=
name|table
index|[
name|hash
index|]
operator|.
name|pix
expr_stmt|;
comment|// May occur once incorrectly
block|}
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dst
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
name|int
name|numColors
init|=
name|do_quant
condition|?
literal|256
else|:
name|pix
decl_stmt|;
name|dst
operator|->
name|colortable
operator|.
name|resize
argument_list|(
name|numColors
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_quant
condition|)
block|{
comment|// quantization needed
DECL|macro|MAX_R
define|#
directive|define
name|MAX_R
value|5
DECL|macro|MAX_G
define|#
directive|define
name|MAX_G
value|5
DECL|macro|MAX_B
define|#
directive|define
name|MAX_B
value|5
DECL|macro|INDEXOF
define|#
directive|define
name|INDEXOF
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|(((r)*(MAX_G+1)+(g))*(MAX_B+1)+(b))
for|for
control|(
name|int
name|rc
init|=
literal|0
init|;
name|rc
operator|<=
name|MAX_R
condition|;
name|rc
operator|++
control|)
comment|// build 6x6x6 color cube
for|for
control|(
name|int
name|gc
init|=
literal|0
init|;
name|gc
operator|<=
name|MAX_G
condition|;
name|gc
operator|++
control|)
for|for
control|(
name|int
name|bc
init|=
literal|0
init|;
name|bc
operator|<=
name|MAX_B
condition|;
name|bc
operator|++
control|)
name|dst
operator|->
name|colortable
index|[
name|INDEXOF
argument_list|(
name|rc
argument_list|,
name|gc
argument_list|,
name|bc
argument_list|)
index|]
operator|=
literal|0xff000000
operator||
name|qRgb
argument_list|(
name|rc
operator|*
literal|255
operator|/
name|MAX_R
argument_list|,
name|gc
operator|*
literal|255
operator|/
name|MAX_G
argument_list|,
name|bc
operator|*
literal|255
operator|/
name|MAX_B
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dst
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|Dither_Mask
operator|)
operator|==
name|Qt
operator|::
name|ThresholdDither
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|p
operator|+
name|src
operator|->
name|width
decl_stmt|;
name|uchar
modifier|*
name|b
init|=
name|dest_data
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
DECL|macro|DITHER
define|#
directive|define
name|DITHER
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|)
value|((uchar) ((p * (m) + 127) / 255))
operator|*
name|b
operator|++
operator|=
name|INDEXOF
argument_list|(
name|DITHER
argument_list|(
name|qRed
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MAX_R
argument_list|)
argument_list|,
name|DITHER
argument_list|(
name|qGreen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MAX_G
argument_list|)
argument_list|,
name|DITHER
argument_list|(
name|qBlue
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|MAX_B
argument_list|)
argument_list|)
expr_stmt|;
DECL|macro|DITHER
undef|#
directive|undef
name|DITHER
name|p
operator|++
expr_stmt|;
block|}
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dst
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|Qt
operator|::
name|Dither_Mask
operator|)
operator|==
name|Qt
operator|::
name|DiffuseDither
condition|)
block|{
name|int
modifier|*
name|line1
index|[
literal|3
index|]
decl_stmt|;
name|int
modifier|*
name|line2
index|[
literal|3
index|]
decl_stmt|;
name|int
modifier|*
name|pv
index|[
literal|3
index|]
decl_stmt|;
name|QScopedArrayPointer
argument_list|<
name|int
argument_list|>
name|lineBuffer
argument_list|(
operator|new
name|int
index|[
name|src
operator|->
name|width
operator|*
literal|9
index|]
argument_list|)
decl_stmt|;
name|line1
index|[
literal|0
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
expr_stmt|;
name|line2
index|[
literal|0
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
expr_stmt|;
name|line1
index|[
literal|1
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|2
expr_stmt|;
name|line2
index|[
literal|1
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|3
expr_stmt|;
name|line1
index|[
literal|2
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|4
expr_stmt|;
name|line2
index|[
literal|2
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|5
expr_stmt|;
name|pv
index|[
literal|0
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|6
expr_stmt|;
name|pv
index|[
literal|1
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|7
expr_stmt|;
name|pv
index|[
literal|2
index|]
operator|=
name|lineBuffer
operator|.
name|data
argument_list|()
operator|+
name|src
operator|->
name|width
operator|*
literal|8
expr_stmt|;
name|int
name|endian
init|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|uchar
modifier|*
name|q
init|=
name|src_data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|q2
init|=
name|y
operator|<
name|src
operator|->
name|height
operator|-
literal|1
condition|?
name|q
operator|+
name|src
operator|->
name|bytes_per_line
else|:
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|b
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|chan
init|=
literal|0
init|;
name|chan
operator|<
literal|3
condition|;
name|chan
operator|++
control|)
block|{
name|int
modifier|*
name|l1
init|=
operator|(
name|y
operator|&
literal|1
operator|)
condition|?
name|line2
index|[
name|chan
index|]
else|:
name|line1
index|[
name|chan
index|]
decl_stmt|;
name|int
modifier|*
name|l2
init|=
operator|(
name|y
operator|&
literal|1
operator|)
condition|?
name|line1
index|[
name|chan
index|]
else|:
name|line2
index|[
name|chan
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|width
condition|;
name|i
operator|++
control|)
name|l1
index|[
name|i
index|]
operator|=
name|q
index|[
name|i
operator|*
literal|4
operator|+
name|chan
operator|+
name|endian
index|]
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|+
literal|1
operator|<
name|src
operator|->
name|height
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|width
condition|;
name|i
operator|++
control|)
name|l2
index|[
name|i
index|]
operator|=
name|q2
index|[
name|i
operator|*
literal|4
operator|+
name|chan
operator|+
name|endian
index|]
expr_stmt|;
block|}
comment|// Bi-directional error diffusion
if|if
condition|(
name|y
operator|&
literal|1
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
name|int
name|pix
init|=
name|qMax
argument_list|(
name|qMin
argument_list|(
literal|5
argument_list|,
operator|(
name|l1
index|[
name|x
index|]
operator|*
literal|5
operator|+
literal|128
operator|)
operator|/
literal|255
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|l1
index|[
name|x
index|]
operator|-
name|pix
operator|*
literal|255
operator|/
literal|5
decl_stmt|;
name|pv
index|[
name|chan
index|]
index|[
name|x
index|]
operator|=
name|pix
expr_stmt|;
comment|// Spread the error around...
if|if
condition|(
name|x
operator|+
literal|1
operator|<
name|src
operator|->
name|width
condition|)
block|{
name|l1
index|[
name|x
operator|+
literal|1
index|]
operator|+=
operator|(
name|err
operator|*
literal|7
operator|)
operator|>>
literal|4
expr_stmt|;
name|l2
index|[
name|x
operator|+
literal|1
index|]
operator|+=
name|err
operator|>>
literal|4
expr_stmt|;
block|}
name|l2
index|[
name|x
index|]
operator|+=
operator|(
name|err
operator|*
literal|5
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|1
condition|)
name|l2
index|[
name|x
operator|-
literal|1
index|]
operator|+=
operator|(
name|err
operator|*
literal|3
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
name|src
operator|->
name|width
init|;
name|x
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|int
name|pix
init|=
name|qMax
argument_list|(
name|qMin
argument_list|(
literal|5
argument_list|,
operator|(
name|l1
index|[
name|x
index|]
operator|*
literal|5
operator|+
literal|128
operator|)
operator|/
literal|255
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|l1
index|[
name|x
index|]
operator|-
name|pix
operator|*
literal|255
operator|/
literal|5
decl_stmt|;
name|pv
index|[
name|chan
index|]
index|[
name|x
index|]
operator|=
name|pix
expr_stmt|;
comment|// Spread the error around...
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|l1
index|[
name|x
operator|-
literal|1
index|]
operator|+=
operator|(
name|err
operator|*
literal|7
operator|)
operator|>>
literal|4
expr_stmt|;
name|l2
index|[
name|x
operator|-
literal|1
index|]
operator|+=
name|err
operator|>>
literal|4
expr_stmt|;
block|}
name|l2
index|[
name|x
index|]
operator|+=
operator|(
name|err
operator|*
literal|5
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|x
operator|+
literal|1
operator|<
name|src
operator|->
name|width
condition|)
name|l2
index|[
name|x
operator|+
literal|1
index|]
operator|+=
operator|(
name|err
operator|*
literal|3
operator|)
operator|>>
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|endian
condition|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|b
operator|++
operator|=
name|INDEXOF
argument_list|(
name|pv
index|[
literal|0
index|]
index|[
name|x
index|]
argument_list|,
name|pv
index|[
literal|1
index|]
index|[
name|x
index|]
argument_list|,
name|pv
index|[
literal|2
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|b
operator|++
operator|=
name|INDEXOF
argument_list|(
name|pv
index|[
literal|2
index|]
index|[
name|x
index|]
argument_list|,
name|pv
index|[
literal|1
index|]
index|[
name|x
index|]
argument_list|,
name|pv
index|[
literal|0
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dst
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// OrderedDither
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|p
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
specifier|const
name|QRgb
modifier|*
name|end
init|=
name|p
operator|+
name|src
operator|->
name|width
decl_stmt|;
name|uchar
modifier|*
name|b
init|=
name|dest_data
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|d
init|=
name|qt_bayer_matrix
index|[
name|y
operator|&
literal|15
index|]
index|[
name|x
operator|&
literal|15
index|]
operator|<<
literal|8
decl_stmt|;
DECL|macro|DITHER
define|#
directive|define
name|DITHER
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|,
name|m
parameter_list|)
value|((uchar) ((((256 * (m) + (m) + 1)) * (p) + (d))>> 16))
operator|*
name|b
operator|++
operator|=
name|INDEXOF
argument_list|(
name|DITHER
argument_list|(
name|qRed
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|d
argument_list|,
name|MAX_R
argument_list|)
argument_list|,
name|DITHER
argument_list|(
name|qGreen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|d
argument_list|,
name|MAX_G
argument_list|)
argument_list|,
name|DITHER
argument_list|(
name|qBlue
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|d
argument_list|,
name|MAX_B
argument_list|)
argument_list|)
expr_stmt|;
DECL|macro|DITHER
undef|#
directive|undef
name|DITHER
name|p
operator|++
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dst
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src
operator|->
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB32
operator|&&
name|src
operator|->
name|format
operator|!=
name|QImage
operator|::
name|Format_RGB16
condition|)
block|{
specifier|const
name|int
name|trans
init|=
literal|216
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dst
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|>
name|trans
argument_list|)
expr_stmt|;
name|dst
operator|->
name|colortable
index|[
name|trans
index|]
operator|=
literal|0
expr_stmt|;
name|QScopedPointer
argument_list|<
name|QImageData
argument_list|>
name|mask
argument_list|(
name|QImageData
operator|::
name|create
argument_list|(
name|QSize
argument_list|(
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|)
argument_list|,
name|QImage
operator|::
name|Format_Mono
argument_list|)
argument_list|)
decl_stmt|;
name|dither_to_Mono
argument_list|(
name|mask
operator|.
name|data
argument_list|()
argument_list|,
name|src
argument_list|,
name|flags
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|dst_data
init|=
name|dst
operator|->
name|data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|mask_data
init|=
name|mask
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|src
operator|->
name|width
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask_data
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
name|dst_data
index|[
name|x
index|]
operator|=
name|trans
expr_stmt|;
block|}
name|mask_data
operator|+=
name|mask
operator|->
name|bytes_per_line
expr_stmt|;
name|dst_data
operator|+=
name|dst
operator|->
name|bytes_per_line
expr_stmt|;
block|}
name|dst
operator|->
name|has_alpha_clut
operator|=
literal|true
expr_stmt|;
block|}
DECL|macro|MAX_R
undef|#
directive|undef
name|MAX_R
DECL|macro|MAX_G
undef|#
directive|undef
name|MAX_G
DECL|macro|MAX_B
undef|#
directive|undef
name|MAX_B
DECL|macro|INDEXOF
undef|#
directive|undef
name|INDEXOF
block|}
block|}
end_function
begin_function
DECL|function|convert_ARGB_PM_to_Indexed8
specifier|static
name|void
name|convert_ARGB_PM_to_Indexed8
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QImageData
argument_list|>
name|tmp
argument_list|(
name|QImageData
operator|::
name|create
argument_list|(
name|QSize
argument_list|(
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|)
argument_list|,
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
argument_list|)
decl_stmt|;
name|convert_ARGB_PM_to_ARGB
argument_list|(
name|tmp
operator|.
name|data
argument_list|()
argument_list|,
name|src
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|convert_RGB_to_Indexed8
argument_list|(
name|dst
argument_list|,
name|tmp
operator|.
name|data
argument_list|()
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|convert_ARGB_to_Indexed8
specifier|static
name|void
name|convert_ARGB_to_Indexed8
parameter_list|(
name|QImageData
modifier|*
name|dst
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|convert_RGB_to_Indexed8
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|convert_Indexed8_to_X32
specifier|static
name|void
name|convert_Indexed8_to_X32
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
operator|||
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
operator|||
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colorTable
init|=
name|fix_color_table
argument_list|(
name|src
operator|->
name|colortable
argument_list|,
name|dest
operator|->
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|colorTable
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|colorTable
operator|.
name|resize
argument_list|(
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|colorTable
index|[
name|i
index|]
operator|=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|w
init|=
name|src
operator|->
name|width
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dest
operator|->
name|data
decl_stmt|;
name|int
name|tableSize
init|=
name|colorTable
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|dest_data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|b
init|=
name|src_data
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|w
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|=
name|colorTable
operator|.
name|at
argument_list|(
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|tableSize
argument_list|,
operator|*
name|b
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convert_Mono_to_X32
specifier|static
name|void
name|convert_Mono_to_X32
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
operator|||
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32
operator|||
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|colorTable
init|=
name|fix_color_table
argument_list|(
name|src
operator|->
name|colortable
argument_list|,
name|dest
operator|->
name|format
argument_list|)
decl_stmt|;
comment|// Default to black / white colors
if|if
condition|(
name|colorTable
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|colorTable
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|colorTable
operator|<<
literal|0xff000000
expr_stmt|;
name|colorTable
operator|<<
literal|0xffffffff
expr_stmt|;
block|}
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dest
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dest
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|register
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|dest
operator|->
name|width
condition|;
name|x
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|colorTable
operator|.
name|at
argument_list|(
operator|(
name|src_data
index|[
name|x
operator|>>
literal|3
index|]
operator|>>
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dest
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|register
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|dest
operator|->
name|width
condition|;
name|x
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|colorTable
operator|.
name|at
argument_list|(
operator|(
name|src_data
index|[
name|x
operator|>>
literal|3
index|]
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|convert_Mono_to_Indexed8
specifier|static
name|void
name|convert_Mono_to_Indexed8
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|dest
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|width
operator|==
name|dest
operator|->
name|width
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|src
operator|->
name|height
operator|==
name|dest
operator|->
name|height
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|ctbl
init|=
name|src
operator|->
name|colortable
decl_stmt|;
if|if
condition|(
name|ctbl
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
name|ctbl
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctbl
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|ctbl
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
name|ctbl
operator|<<
literal|0xff000000
expr_stmt|;
name|ctbl
operator|<<
literal|0xffffffff
expr_stmt|;
block|}
name|dest
operator|->
name|colortable
operator|=
name|ctbl
expr_stmt|;
name|dest
operator|->
name|has_alpha_clut
operator|=
name|src
operator|->
name|has_alpha_clut
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|dest
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dest
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|register
name|uchar
modifier|*
name|p
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|dest
operator|->
name|width
condition|;
name|x
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
name|src_data
index|[
name|x
operator|>>
literal|3
index|]
operator|>>
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dest
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|register
name|uchar
modifier|*
name|p
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|dest
operator|->
name|width
condition|;
name|x
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|(
name|src_data
index|[
name|x
operator|>>
literal|3
index|]
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
name|src_data
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|// Cannot be used with indexed formats.
end_comment
begin_function
DECL|function|convert_generic
specifier|static
name|void
name|convert_generic
parameter_list|(
name|QImageData
modifier|*
name|dest
parameter_list|,
specifier|const
name|QImageData
modifier|*
name|src
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
parameter_list|)
block|{
specifier|const
name|int
name|buffer_size
init|=
literal|2048
decl_stmt|;
name|uint
name|buffer
index|[
name|buffer_size
index|]
decl_stmt|;
specifier|const
name|QPixelLayout
modifier|*
name|srcLayout
init|=
operator|&
name|qPixelLayouts
index|[
name|src
operator|->
name|format
index|]
decl_stmt|;
specifier|const
name|QPixelLayout
modifier|*
name|destLayout
init|=
operator|&
name|qPixelLayouts
index|[
name|dest
operator|->
name|format
index|]
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|srcData
init|=
name|src
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|destData
init|=
name|dest
operator|->
name|data
decl_stmt|;
name|FetchPixelsFunc
name|fetch
init|=
name|qFetchPixels
index|[
name|srcLayout
operator|->
name|bpp
index|]
decl_stmt|;
name|StorePixelsFunc
name|store
init|=
name|qStorePixels
index|[
name|destLayout
operator|->
name|bpp
index|]
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|src
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|src
operator|->
name|width
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|src
operator|->
name|width
operator|-
name|x
argument_list|,
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|fetch
argument_list|(
name|buffer
argument_list|,
name|srcData
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|srcLayout
operator|->
name|convertToARGB32PM
argument_list|(
name|buffer
argument_list|,
name|ptr
argument_list|,
name|l
argument_list|,
name|srcLayout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|destLayout
operator|->
name|convertFromARGB32PM
argument_list|(
name|buffer
argument_list|,
name|ptr
argument_list|,
name|l
argument_list|,
name|destLayout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|destData
argument_list|,
name|ptr
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|x
operator|+=
name|l
expr_stmt|;
block|}
name|srcData
operator|+=
name|src
operator|->
name|bytes_per_line
expr_stmt|;
name|destData
operator|+=
name|dest
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// first index source, second dest
end_comment
begin_decl_stmt
DECL|variable|converter_map
specifier|static
name|Image_Converter
name|converter_map
index|[
name|QImage
operator|::
name|NImageFormats
index|]
index|[
name|QImage
operator|::
name|NImageFormats
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|swap_bit_order
block|,
name|convert_Mono_to_Indexed8
block|,
name|convert_Mono_to_X32
block|,
name|convert_Mono_to_X32
block|,
name|convert_Mono_to_X32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_Mono
block|{
literal|0
block|,
name|swap_bit_order
block|,
literal|0
block|,
name|convert_Mono_to_Indexed8
block|,
name|convert_Mono_to_X32
block|,
name|convert_Mono_to_X32
block|,
name|convert_Mono_to_X32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_MonoLSB
block|{
literal|0
block|,
name|convert_X_to_Mono
block|,
name|convert_X_to_Mono
block|,
literal|0
block|,
name|convert_Indexed8_to_X32
block|,
name|convert_Indexed8_to_X32
block|,
name|convert_Indexed8_to_X32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_Indexed8
block|{
literal|0
block|,
name|convert_X_to_Mono
block|,
name|convert_X_to_Mono
block|,
name|convert_RGB_to_Indexed8
block|,
literal|0
block|,
name|mask_alpha_converter
block|,
name|mask_alpha_converter
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|}
block|,
comment|// Format_RGB32
block|{
literal|0
block|,
name|convert_X_to_Mono
block|,
name|convert_X_to_Mono
block|,
name|convert_ARGB_to_Indexed8
block|,
name|mask_alpha_converter
block|,
literal|0
block|,
name|convert_ARGB_to_ARGB_PM
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|}
block|,
comment|// Format_ARGB32
block|{
literal|0
block|,
name|convert_ARGB_PM_to_Mono
block|,
name|convert_ARGB_PM_to_Mono
block|,
name|convert_ARGB_PM_to_Indexed8
block|,
name|convert_ARGB_PM_to_RGB
block|,
name|convert_ARGB_PM_to_ARGB
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB32_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
if|#
directive|if
name|defined
argument_list|(
name|QT_QWS_DEPTH_15
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_QWS_DEPTH_16
argument_list|)
name|convert_generic
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB16
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB8565_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB666
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB6666_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
if|#
directive|if
name|defined
argument_list|(
name|QT_QWS_DEPTH_15
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_QWS_DEPTH_16
argument_list|)
name|convert_generic
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB555
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB8555_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB888
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB444
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_generic
block|,
name|convert_generic
block|,
name|convert_generic
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|// Format_ARGB4444_Premultiplied
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|inplace_converter_map
specifier|static
name|InPlace_Image_Converter
name|inplace_converter_map
index|[
name|QImage
operator|::
name|NImageFormats
index|]
index|[
name|QImage
operator|::
name|NImageFormats
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_Mono
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_MonoLSB
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_indexed8_to_RGB_inplace
block|,
name|convert_indexed8_to_ARGB_PM_inplace
block|,
name|convert_indexed8_to_RGB16_inplace
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,     }
block|,
comment|// Format_Indexed8
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_RGB_to_RGB16_inplace
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,     }
block|,
comment|// Format_ARGB32
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|convert_ARGB_to_ARGB_PM_inplace
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,     }
block|,
comment|// Format_ARGB32
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB32_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB16
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB8565_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB666
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB6666_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB555
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_ARGB8555_Premultiplied
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB888
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// Format_RGB444
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|// Format_ARGB4444_Premultiplied
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qInitImageConversions
name|void
name|qInitImageConversions
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_COMPILER_SUPPORTS_AVX
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|AVX
argument_list|)
condition|)
block|{
specifier|extern
name|bool
name|convert_ARGB_to_ARGB_PM_inplace_avx
argument_list|(
name|QImageData
operator|*
name|data
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|)
decl_stmt|;
name|inplace_converter_map
index|[
name|QImage
operator|::
name|Format_ARGB32
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
index|]
operator|=
name|convert_ARGB_to_ARGB_PM_inplace_avx
expr_stmt|;
specifier|extern
name|void
name|convert_RGB888_to_RGB32_avx
argument_list|(
name|QImageData
operator|*
name|dest
argument_list|,
specifier|const
name|QImageData
operator|*
name|src
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|)
decl_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_RGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_avx
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_avx
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
index|]
operator|=
name|convert_RGB888_to_RGB32_avx
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__AVX__
argument_list|)
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|SSE2
argument_list|)
condition|)
block|{
specifier|extern
name|bool
name|convert_ARGB_to_ARGB_PM_inplace_sse2
argument_list|(
name|QImageData
operator|*
name|data
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|)
decl_stmt|;
name|inplace_converter_map
index|[
name|QImage
operator|::
name|Format_ARGB32
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
index|]
operator|=
name|convert_ARGB_to_ARGB_PM_inplace_sse2
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_COMPILER_SUPPORTS_SSSE3
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|SSSE3
argument_list|)
condition|)
block|{
specifier|extern
name|void
name|convert_RGB888_to_RGB32_ssse3
argument_list|(
name|QImageData
operator|*
name|dest
argument_list|,
specifier|const
name|QImageData
operator|*
name|src
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|)
decl_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_RGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_ssse3
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_ssse3
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
index|]
operator|=
name|convert_RGB888_to_RGB32_ssse3
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
comment|// SSE2
ifdef|#
directive|ifdef
name|QT_COMPILER_SUPPORTS_NEON
if|if
condition|(
name|qCpuHasFeature
argument_list|(
name|NEON
argument_list|)
condition|)
block|{
specifier|extern
name|void
name|convert_RGB888_to_RGB32_neon
argument_list|(
name|QImageData
operator|*
name|dest
argument_list|,
specifier|const
name|QImageData
operator|*
name|src
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|)
decl_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_RGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_neon
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32
index|]
operator|=
name|convert_RGB888_to_RGB32_neon
expr_stmt|;
name|converter_map
index|[
name|QImage
operator|::
name|Format_RGB888
index|]
index|[
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
index|]
operator|=
name|convert_RGB888_to_RGB32_neon
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
end_function
begin_function_decl
specifier|extern
specifier|const
name|uchar
modifier|*
name|qt_pow_rgb_gamma
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qGamma_correct_back_to_linear_cs
name|void
name|qGamma_correct_back_to_linear_cs
parameter_list|(
name|QImage
modifier|*
name|image
parameter_list|)
block|{
specifier|const
name|QDrawHelperGammaTables
modifier|*
name|tables
init|=
name|QGuiApplicationPrivate
operator|::
name|instance
argument_list|()
operator|->
name|gammaTables
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tables
condition|)
return|return;
specifier|const
name|uchar
modifier|*
name|gamma
init|=
name|tables
operator|->
name|qt_pow_rgb_gamma
decl_stmt|;
comment|// gamma correct the pixels back to linear color space...
name|int
name|h
init|=
name|image
operator|->
name|height
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|image
operator|->
name|width
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|uint
modifier|*
name|pixels
init|=
operator|(
name|uint
operator|*
operator|)
name|image
operator|->
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|uint
name|p
init|=
name|pixels
index|[
name|x
index|]
decl_stmt|;
name|uint
name|r
init|=
name|gamma
index|[
name|qRed
argument_list|(
name|p
argument_list|)
index|]
decl_stmt|;
name|uint
name|g
init|=
name|gamma
index|[
name|qGreen
argument_list|(
name|p
argument_list|)
index|]
decl_stmt|;
name|uint
name|b
init|=
name|gamma
index|[
name|qBlue
argument_list|(
name|p
argument_list|)
index|]
decl_stmt|;
name|pixels
index|[
name|x
index|]
operator|=
operator|(
name|r
operator|<<
literal|16
operator|)
operator||
operator|(
name|g
operator|<<
literal|8
operator|)
operator||
name|b
operator||
literal|0xff000000
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the image in the given \a format.      The specified image conversion \a flags control how the image data     is handled during the conversion process.      \sa {QImage#Image Format}{Image Format} */
end_comment
begin_function
DECL|function|convertToFormat
name|QImage
name|QImage
operator|::
name|convertToFormat
parameter_list|(
name|Format
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|format
operator|==
name|format
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|format
operator|==
name|Format_Invalid
operator|||
name|d
operator|->
name|format
operator|==
name|Format_Invalid
condition|)
return|return
name|QImage
argument_list|()
return|;
specifier|const
name|Image_Converter
modifier|*
name|converterPtr
init|=
operator|&
name|converter_map
index|[
name|d
operator|->
name|format
index|]
index|[
name|format
index|]
decl_stmt|;
name|Image_Converter
name|converter
init|=
operator|*
name|converterPtr
decl_stmt|;
if|if
condition|(
name|converter
condition|)
block|{
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|.
name|setDotsPerMeterY
argument_list|(
name|dotsPerMeterY
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setDotsPerMeterX
argument_list|(
name|dotsPerMeterX
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|setDevicePixelRatio
argument_list|(
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|text
operator|=
name|d
operator|->
name|text
expr_stmt|;
name|converter
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
name|Q_ASSERT
argument_list|(
name|format
operator|!=
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|format
operator|!=
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|QImage
name|image
init|=
name|convertToFormat
argument_list|(
name|Format_ARGB32
argument_list|,
name|flags
argument_list|)
decl_stmt|;
return|return
name|image
operator|.
name|convertToFormat
argument_list|(
name|format
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|pixel_distance
specifier|static
specifier|inline
name|int
name|pixel_distance
parameter_list|(
name|QRgb
name|p1
parameter_list|,
name|QRgb
name|p2
parameter_list|)
block|{
name|int
name|r1
init|=
name|qRed
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|g1
init|=
name|qGreen
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|b1
init|=
name|qBlue
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|a1
init|=
name|qAlpha
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|qRed
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|g2
init|=
name|qGreen
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|b2
init|=
name|qBlue
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|a2
init|=
name|qAlpha
argument_list|(
name|p2
argument_list|)
decl_stmt|;
return|return
name|abs
argument_list|(
name|r1
operator|-
name|r2
argument_list|)
operator|+
name|abs
argument_list|(
name|g1
operator|-
name|g2
argument_list|)
operator|+
name|abs
argument_list|(
name|b1
operator|-
name|b2
argument_list|)
operator|+
name|abs
argument_list|(
name|a1
operator|-
name|a2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|closestMatch
specifier|static
specifier|inline
name|int
name|closestMatch
parameter_list|(
name|QRgb
name|pixel
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|clut
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|current_distance
init|=
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clut
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|dist
init|=
name|pixel_distance
argument_list|(
name|pixel
argument_list|,
name|clut
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|<
name|current_distance
condition|)
block|{
name|current_distance
operator|=
name|dist
expr_stmt|;
name|idx
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|idx
return|;
block|}
end_function
begin_function
DECL|function|convertWithPalette
specifier|static
name|QImage
name|convertWithPalette
parameter_list|(
specifier|const
name|QImage
modifier|&
name|src
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|clut
parameter_list|)
block|{
name|QImage
name|dest
argument_list|(
name|src
operator|.
name|size
argument_list|()
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|dest
operator|.
name|setColorTable
argument_list|(
name|clut
argument_list|)
expr_stmt|;
name|QString
name|textsKeys
init|=
name|src
operator|.
name|text
argument_list|()
decl_stmt|;
name|QStringList
name|textKeyList
init|=
name|textsKeys
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|textKey
decl|,
name|textKeyList
control|)
block|{
name|QStringList
name|textKeySplitted
init|=
name|textKey
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|.
name|setText
argument_list|(
name|textKeySplitted
index|[
literal|0
index|]
argument_list|,
name|textKeySplitted
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|int
name|h
init|=
name|src
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|src
operator|.
name|width
argument_list|()
decl_stmt|;
name|QHash
argument_list|<
name|QRgb
argument_list|,
name|int
argument_list|>
name|cache
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|QRgb
modifier|*
name|src_pixels
init|=
operator|(
name|QRgb
operator|*
operator|)
name|src
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|dest_pixels
init|=
operator|(
name|uchar
operator|*
operator|)
name|dest
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|src_pixel
init|=
name|src_pixels
index|[
name|x
index|]
decl_stmt|;
name|int
name|value
init|=
name|cache
operator|.
name|value
argument_list|(
name|src_pixel
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|value
operator|=
name|closestMatch
argument_list|(
name|src_pixel
argument_list|,
name|clut
argument_list|)
expr_stmt|;
name|cache
operator|.
name|insert
argument_list|(
name|src_pixel
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|dest_pixels
index|[
name|x
index|]
operator|=
operator|(
name|uchar
operator|)
name|value
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|QVector
argument_list|<
name|QRgb
argument_list|>
name|table
init|=
name|clut
decl_stmt|;
name|table
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
name|QRgb
modifier|*
name|src_pixels
init|=
operator|(
name|QRgb
operator|*
operator|)
name|src
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|src_pixel
init|=
name|src_pixels
index|[
name|x
index|]
decl_stmt|;
name|int
name|value
init|=
name|cache
operator|.
name|value
argument_list|(
name|src_pixel
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|value
operator|=
name|closestMatch
argument_list|(
name|src_pixel
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|cache
operator|.
name|insert
argument_list|(
name|src_pixel
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|dest
operator|.
name|setPixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|dest
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a copy of the image converted to the given \a format,     using the specified \a colorTable.      Conversion from 32 bit to 8 bit indexed is a slow operation and     will use a straightforward nearest color approach, with no     dithering. */
end_comment
begin_function
DECL|function|convertToFormat
name|QImage
name|QImage
operator|::
name|convertToFormat
parameter_list|(
name|Format
name|format
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|colorTable
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|format
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|format
operator|<=
name|QImage
operator|::
name|Format_Indexed8
operator|&&
name|depth
argument_list|()
operator|==
literal|32
condition|)
block|{
return|return
name|convertWithPalette
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|,
name|colorTable
argument_list|)
return|;
block|}
specifier|const
name|Image_Converter
modifier|*
name|converterPtr
init|=
operator|&
name|converter_map
index|[
name|d
operator|->
name|format
index|]
index|[
name|format
index|]
decl_stmt|;
name|Image_Converter
name|converter
init|=
operator|*
name|converterPtr
decl_stmt|;
if|if
condition|(
operator|!
name|converter
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|image
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|.
name|setDevicePixelRatio
argument_list|(
name|devicePixelRatio
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|.
name|d
operator|->
name|text
operator|=
name|d
operator|->
name|text
expr_stmt|;
name|converter
argument_list|(
name|image
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::valid(const QPoint&pos) const      Returns true if \a pos is a valid coordinate pair within the     image; otherwise returns false.      \sa rect(), QRect::contains() */
end_comment
begin_comment
comment|/*!     \overload      Returns true if QPoint(\a x, \a y) is a valid coordinate pair     within the image; otherwise returns false. */
end_comment
begin_function
DECL|function|valid
name|bool
name|QImage
operator|::
name|valid
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|&&
name|x
operator|>=
literal|0
operator|&&
name|x
operator|<
name|d
operator|->
name|width
operator|&&
name|y
operator|>=
literal|0
operator|&&
name|y
operator|<
name|d
operator|->
name|height
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QImage::pixelIndex(const QPoint&position) const      Returns the pixel index at the given \a position.      If \a position is not valid, or if the image is not a paletted     image (depth()> 8), the results are undefined.      \sa valid(), depth(), {QImage#Pixel Manipulation}{Pixel Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Returns the pixel index at (\a x, \a y). */
end_comment
begin_function
DECL|function|pixelIndex
name|int
name|QImage
operator|::
name|pixelIndex
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|d
operator|->
name|width
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::pixelIndex: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|-
literal|12345
return|;
block|}
specifier|const
name|uchar
modifier|*
name|s
init|=
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
return|return
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|&
literal|1
return|;
case|case
name|Format_MonoLSB
case|:
return|return
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
return|;
case|case
name|Format_Indexed8
case|:
return|return
operator|(
name|int
operator|)
name|s
index|[
name|x
index|]
return|;
default|default:
name|qWarning
argument_list|(
literal|"QImage::pixelIndex: Not applicable for %d-bpp images (no palette)"
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRgb QImage::pixel(const QPoint&position) const      Returns the color of the pixel at the given \a position.      If the \a position is not valid, the results are undefined.      \warning This function is expensive when used for massive pixel     manipulations.      \sa setPixel(), valid(), {QImage#Pixel Manipulation}{Pixel     Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Returns the color of the pixel at coordinates (\a x, \a y). */
end_comment
begin_function
DECL|function|pixel
name|QRgb
name|QImage
operator|::
name|pixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|d
operator|->
name|width
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::pixel: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
literal|12345
return|;
block|}
specifier|const
name|uchar
modifier|*
name|s
init|=
name|constScanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
operator|~
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
argument_list|)
return|;
case|case
name|Format_MonoLSB
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|(
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
argument_list|)
return|;
case|case
name|Format_Indexed8
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|(
name|int
operator|)
name|s
index|[
name|x
index|]
argument_list|)
return|;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
comment|// Keep old behaviour.
case|case
name|Format_ARGB32_Premultiplied
case|:
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QRgb
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
return|;
case|case
name|Format_RGB16
case|:
return|return
name|qConvertRgb16To32
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
index|[
name|x
index|]
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|uint
name|result
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
operator|(
operator|&
name|result
expr|,
name|s
expr|,
name|x
expr|,
literal|1
operator|)
decl_stmt|;
return|return
operator|*
name|layout
operator|->
name|convertToARGB32PM
argument_list|(
operator|&
name|result
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setPixel(const QPoint&position, uint index_or_rgb)      Sets the pixel index or color at the given \a position to \a     index_or_rgb.      If the image's format is either monochrome or 8-bit, the given \a     index_or_rgb value must be an index in the image's color table,     otherwise the parameter must be a QRgb value.      If \a position is not a valid coordinate pair in the image, or if     \a index_or_rgb>= colorCount() in the case of monochrome and     8-bit images, the result is undefined.      \warning This function is expensive due to the call of the internal     \c{detach()} function called within; if performance is a concern, we     recommend the use of \l{QImage::}{scanLine()} to access pixel data     directly.      \sa pixel(), {QImage#Pixel Manipulation}{Pixel Manipulation} */
end_comment
begin_comment
comment|/*!     \overload      Sets the pixel index or color at (\a x, \a y) to \a index_or_rgb. */
end_comment
begin_function
DECL|function|setPixel
name|void
name|QImage
operator|::
name|setPixel
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|uint
name|index_or_rgb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|width
argument_list|()
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: coordinate (%d,%d) out of range"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// detach is called from within scanLine
name|uchar
modifier|*
name|s
init|=
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
if|if
condition|(
name|index_or_rgb
operator|>
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: Index %d out of range"
argument_list|,
name|index_or_rgb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
argument_list|()
operator|==
name|Format_MonoLSB
condition|)
block|{
if|if
condition|(
name|index_or_rgb
operator|==
literal|0
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index_or_rgb
operator|==
literal|0
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
expr_stmt|;
else|else
operator|*
operator|(
name|s
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
expr_stmt|;
block|}
return|return;
case|case
name|Format_Indexed8
case|:
if|if
condition|(
name|index_or_rgb
operator|>=
operator|(
name|uint
operator|)
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setPixel: Index %d out of range"
argument_list|,
name|index_or_rgb
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
index|[
name|x
index|]
operator|=
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_RGB32
case|:
comment|//make sure alpha is 255, we depend on it in qdrawhelper for cases
comment|// when image is set as a texture pattern on a qbrush
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|uint
argument_list|(
literal|255
operator|<<
literal|24
argument_list|)
operator||
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
operator|(
operator|(
name|uint
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|index_or_rgb
expr_stmt|;
return|return;
case|case
name|Format_RGB16
case|:
operator|(
operator|(
name|quint16
operator|*
operator|)
name|s
operator|)
index|[
name|x
index|]
operator|=
name|qConvertRgb32To16
argument_list|(
name|INV_PREMUL
argument_list|(
name|index_or_rgb
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|Format_Invalid
case|:
case|case
name|NImageFormats
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|uint
name|result
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|layout
operator|->
name|convertFromARGB32PM
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|index_or_rgb
argument_list|,
literal|1
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|qStorePixels
index|[
name|layout
operator|->
name|bpp
index|]
operator|(
name|s
operator|,
name|ptr
operator|,
name|x
operator|,
literal|1
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if all the colors in the image are shades of gray     (i.e. their red, green and blue components are equal); otherwise     false.      Note that this function is slow for images without color table.      \sa isGrayscale() */
end_comment
begin_function
DECL|function|allGray
name|bool
name|QImage
operator|::
name|allGray
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|b
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
case|case
name|Format_RGB16
case|:
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|quint16
modifier|*
name|b
init|=
operator|(
specifier|const
name|quint16
operator|*
operator|)
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|width
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|qConvertRgb16To32
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
default|default:
break|break;
block|}
specifier|const
name|int
name|buffer_size
init|=
literal|2048
decl_stmt|;
name|uint
name|buffer
index|[
name|buffer_size
index|]
decl_stmt|;
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|FetchPixelsFunc
name|fetch
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|uchar
modifier|*
name|b
init|=
name|constScanLine
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|d
operator|->
name|width
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|d
operator|->
name|width
operator|-
name|x
argument_list|,
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|fetch
argument_list|(
name|buffer
argument_list|,
name|b
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|ptr
operator|=
name|layout
operator|->
name|convertToARGB32PM
argument_list|(
name|buffer
argument_list|,
name|ptr
argument_list|,
name|l
argument_list|,
name|layout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|qIsGray
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|x
operator|+=
name|l
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     For 32-bit images, this function is equivalent to allGray().      For 8-bpp images, this function returns true if color(i) is     QRgb(i, i, i) for all indexes of the color table; otherwise     returns false.      \sa allGray(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|isGrayscale
name|bool
name|QImage
operator|::
name|isGrayscale
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|depth
argument_list|()
condition|)
block|{
case|case
literal|32
case|:
case|case
literal|24
case|:
case|case
literal|16
case|:
return|return
name|allGray
argument_list|()
return|;
case|case
literal|8
case|:
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colorCount
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode,                              Qt::TransformationMode transformMode) const     \overload      Returns a copy of the image scaled to a rectangle with the given     \a width and \a height according to the given \a aspectRatioMode     and \a transformMode.      If either the \a width or the \a height is zero or negative, this     function returns a null image. */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::scaled(const QSize&size, Qt::AspectRatioMode aspectRatioMode,                              Qt::TransformationMode transformMode) const      Returns a copy of the image scaled to a rectangle defined by the     given \a size according to the given \a aspectRatioMode and \a     transformMode.      \image qimage-scaling.png      \list     \li If \a aspectRatioMode is Qt::IgnoreAspectRatio, the image        is scaled to \a size.     \li If \a aspectRatioMode is Qt::KeepAspectRatio, the image is        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.     \li If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,        the image is scaled to a rectangle as small as possible        outside \a size, preserving the aspect ratio.     \endlist      If the given \a size is empty, this function returns a null image.      \sa isNull(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|scaled
name|QImage
name|QImage
operator|::
name|scaled
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectMode
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaled: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QSize
name|newSize
init|=
name|size
argument_list|()
decl_stmt|;
name|newSize
operator|.
name|scale
argument_list|(
name|s
argument_list|,
name|aspectMode
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rwidth
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|width
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rheight
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|height
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newSize
operator|==
name|size
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|()
argument_list|,
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|height
argument_list|()
operator|/
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QImage
name|img
init|=
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
decl_stmt|;
return|return
name|img
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaledToWidth(int width, Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a width using the specified transformation \a     mode.      This function automatically calculates the height of the image so     that its aspect ratio is preserved.      If the given \a width is 0 or negative, a null image is returned.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|scaledToWidth
name|QImage
name|QImage
operator|::
name|scaledToWidth
parameter_list|(
name|int
name|w
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaleWidth: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|w
operator|/
name|width
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::scaledToHeight(int height, Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a height using the specified transformation \a     mode.      This function automatically calculates the width of the image so that     the ratio of the image is preserved.      If the given \a height is 0 or negative, a null image is returned.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|scaledToHeight
name|QImage
name|QImage
operator|::
name|scaledToHeight
parameter_list|(
name|int
name|h
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::scaleHeight: Image is a null image"
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
if|if
condition|(
name|h
operator|<=
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|h
operator|/
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix QImage::trueMatrix(const QMatrix&matrix, int width, int height)      Returns the actual matrix used for transforming an image with the     given \a width, \a height and \a matrix.      When transforming an image using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     image containing all transformed points of the original image.     This function returns the modified matrix, which maps points     correctly from the original image into the new image.      \sa transformed(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QMatrix
name|QImage
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|trueMatrix
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the image that is transformed using the given     transformation \a matrix and transformation \a mode.      The transformation \a matrix is internally adjusted to compensate     for unwanted translation; i.e. the image produced is the smallest     image that contains all the transformed points of the original     image. Use the trueMatrix() function to retrieve the actual matrix     used for transforming an image.      \sa trueMatrix(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QImage
name|QImage
operator|::
name|transformed
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
return|return
name|transformed
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Builds and returns a 1-bpp mask from the alpha buffer in this     image. Returns a null image if the image's format is     QImage::Format_RGB32.      The \a flags argument is a bitwise-OR of the     Qt::ImageConversionFlags, and controls the conversion     process. Passing 0 for flags sets all the default options.      The returned image has little-endian bit order (i.e. the image's     format is QImage::Format_MonoLSB), which you can convert to     big-endian (QImage::Format_Mono) using the convertToFormat()     function.      \sa createHeuristicMask(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|createAlphaMask
name|QImage
name|QImage
operator|::
name|createAlphaMask
parameter_list|(
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_RGB32
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
comment|// A monochrome pixmap, with alpha channels on those two colors.
comment|// Pretty unlikely, so use less efficient solution.
return|return
name|convertToFormat
argument_list|(
name|Format_Indexed8
argument_list|,
name|flags
argument_list|)
operator|.
name|createAlphaMask
argument_list|(
name|flags
argument_list|)
return|;
block|}
name|QImage
name|mask
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|Format_MonoLSB
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mask
operator|.
name|isNull
argument_list|()
condition|)
name|dither_to_Mono
argument_list|(
name|mask
operator|.
name|d
argument_list|,
name|d
argument_list|,
name|flags
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGE_HEURISTIC_MASK
end_ifndef
begin_comment
comment|/*!     Creates and returns a 1-bpp heuristic mask for this image.      The function works by selecting a color from one of the corners,     then chipping away pixels of that color starting at all the edges.     The four corners vote for which color is to be masked away. In     case of a draw (this generally means that this function is not     applicable to the image), the result is arbitrary.      The returned image has little-endian bit order (i.e. the image's     format is QImage::Format_MonoLSB), which you can convert to     big-endian (QImage::Format_Mono) using the convertToFormat()     function.      If \a clipTight is true (the default) the mask is just large     enough to cover the pixels; otherwise, the mask is larger than the     data pixels.      Note that this function disregards the alpha buffer.      \sa createAlphaMask(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|createHeuristicMask
name|QImage
name|QImage
operator|::
name|createHeuristicMask
parameter_list|(
name|bool
name|clipTight
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|depth
operator|!=
literal|32
condition|)
block|{
name|QImage
name|img32
init|=
name|convertToFormat
argument_list|(
name|Format_RGB32
argument_list|)
decl_stmt|;
return|return
name|img32
operator|.
name|createHeuristicMask
argument_list|(
name|clipTight
argument_list|)
return|;
block|}
DECL|macro|PIX
define|#
directive|define
name|PIX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(*((QRgb*)scanLine(y)+x)& 0x00ffffff)
name|int
name|w
init|=
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|height
argument_list|()
decl_stmt|;
name|QImage
name|m
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|.
name|fill
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|QRgb
name|background
init|=
name|PIX
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
condition|)
block|{
name|background
operator|=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|background
operator|!=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|background
operator|!=
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|&&
name|PIX
argument_list|(
literal|0
argument_list|,
name|h
operator|-
literal|1
argument_list|)
operator|==
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
condition|)
block|{
name|background
operator|=
name|PIX
argument_list|(
name|w
operator|-
literal|1
argument_list|,
name|h
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|uchar
modifier|*
name|ypp
decl_stmt|,
modifier|*
name|ypc
decl_stmt|,
modifier|*
name|ypn
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|ypn
operator|=
name|m
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ypc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|ypp
operator|=
name|ypc
expr_stmt|;
name|ypc
operator|=
name|ypn
expr_stmt|;
name|ypn
operator|=
operator|(
name|y
operator|==
name|h
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|m
operator|.
name|scanLine
argument_list|(
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QRgb
modifier|*
name|p
init|=
operator|(
name|QRgb
operator|*
operator|)
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
comment|// slowness here - it's possible to do six of these tests
comment|// together in one go. oh well.
if|if
condition|(
operator|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
operator|||
name|x
operator|==
name|w
operator|-
literal|1
operator|||
name|y
operator|==
name|h
operator|-
literal|1
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypp
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|ypn
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|*
operator|(
name|ypc
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|*
name|p
operator|&
literal|0x00ffffff
operator|)
operator|==
name|background
operator|)
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
operator|*
operator|(
name|ypc
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|clipTight
condition|)
block|{
name|ypn
operator|=
name|m
operator|.
name|scanLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ypc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
name|y
operator|++
control|)
block|{
name|ypp
operator|=
name|ypc
expr_stmt|;
name|ypc
operator|=
name|ypn
expr_stmt|;
name|ypn
operator|=
operator|(
name|y
operator|==
name|h
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|m
operator|.
name|scanLine
argument_list|(
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QRgb
modifier|*
name|p
init|=
operator|(
name|QRgb
operator|*
operator|)
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|&
literal|0x00ffffff
operator|)
operator|!=
name|background
condition|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
condition|)
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|w
operator|-
literal|1
condition|)
operator|*
operator|(
name|ypc
operator|+
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|x
operator|+
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
operator|*
operator|(
name|ypp
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|h
operator|-
literal|1
condition|)
operator|*
operator|(
name|ypn
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
DECL|macro|PIX
undef|#
directive|undef
name|PIX
return|return
name|m
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_IMAGE_HEURISTIC_MASK
end_comment
begin_comment
comment|/*!     Creates and returns a mask for this image based on the given \a     color value. If the \a mode is MaskInColor (the default value),     all pixels matching \a color will be opaque pixels in the mask. If     \a mode is MaskOutColor, all pixels matching the given color will     be transparent.      \sa createAlphaMask(), createHeuristicMask() */
end_comment
begin_function
DECL|function|createMaskFromColor
name|QImage
name|QImage
operator|::
name|createMaskFromColor
parameter_list|(
name|QRgb
name|color
parameter_list|,
name|Qt
operator|::
name|MaskMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|QImage
name|maskImage
argument_list|(
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|maskImage
argument_list|)
expr_stmt|;
name|maskImage
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|s
init|=
name|maskImage
operator|.
name|bits
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
name|d
operator|->
name|height
condition|;
name|h
operator|++
control|)
block|{
specifier|const
name|uint
modifier|*
name|sl
init|=
operator|(
name|uint
operator|*
operator|)
name|scanLine
argument_list|(
name|h
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|d
operator|->
name|width
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
name|sl
index|[
name|w
index|]
operator|==
name|color
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|w
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|w
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|s
operator|+=
name|maskImage
operator|.
name|bytesPerLine
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
name|d
operator|->
name|height
condition|;
name|h
operator|++
control|)
block|{
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|d
operator|->
name|width
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|uint
operator|)
name|pixel
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|==
name|color
condition|)
operator|*
operator|(
name|s
operator|+
operator|(
name|w
operator|>>
literal|3
operator|)
operator|)
operator||=
operator|(
literal|1
operator|<<
operator|(
name|w
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
name|s
operator|+=
name|maskImage
operator|.
name|bytesPerLine
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|MaskOutColor
condition|)
name|maskImage
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
return|return
name|maskImage
return|;
block|}
end_function
begin_comment
comment|/*   This code is contributed by Philipp Lang,   GeneriCom Software Germany (www.generi.com)   under the terms of the QPL, Version 1.0 */
end_comment
begin_comment
comment|/*!     Returns a mirror of the image, mirrored in the horizontal and/or     the vertical direction depending on whether \a horizontal and \a     vertical are set to true or false.      Note that the original image is not changed.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|mirrored
name|QImage
name|QImage
operator|::
name|mirrored
parameter_list|(
name|bool
name|horizontal
parameter_list|,
name|bool
name|vertical
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|width
operator|<=
literal|1
operator|&&
name|d
operator|->
name|height
operator|<=
literal|1
operator|)
operator|||
operator|(
operator|!
name|horizontal
operator|&&
operator|!
name|vertical
operator|)
condition|)
return|return
operator|*
name|this
return|;
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|height
decl_stmt|;
comment|// Create result image, copy colormap
name|QImage
name|result
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|// check if we ran out of of memory..
if|if
condition|(
operator|!
name|result
operator|.
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|result
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|devicePixelRatio
operator|=
name|d
operator|->
name|devicePixelRatio
expr_stmt|;
if|if
condition|(
name|depth
argument_list|()
operator|==
literal|1
condition|)
name|w
operator|=
operator|(
name|w
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|int
name|dxi
init|=
name|horizontal
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|int
name|dxs
init|=
name|horizontal
condition|?
name|w
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|dyi
init|=
name|vertical
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|int
name|dy
init|=
name|vertical
condition|?
name|h
operator|-
literal|1
else|:
literal|0
decl_stmt|;
comment|// 1 bit, 8 bit
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|1
operator|||
name|d
operator|->
name|depth
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|int
name|sy
init|=
literal|0
init|;
name|sy
operator|<
name|h
condition|;
name|sy
operator|++
operator|,
name|dy
operator|+=
name|dyi
control|)
block|{
name|quint8
modifier|*
name|ssl
init|=
operator|(
name|quint8
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|sy
operator|*
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|quint8
modifier|*
name|dsl
init|=
operator|(
name|quint8
operator|*
operator|)
operator|(
name|result
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|result
operator|.
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|int
name|dx
init|=
name|dxs
decl_stmt|;
for|for
control|(
name|int
name|sx
init|=
literal|0
init|;
name|sx
operator|<
name|w
condition|;
name|sx
operator|++
operator|,
name|dx
operator|+=
name|dxi
control|)
name|dsl
index|[
name|dx
index|]
operator|=
name|ssl
index|[
name|sx
index|]
expr_stmt|;
block|}
block|}
comment|// 16 bit
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|16
condition|)
block|{
for|for
control|(
name|int
name|sy
init|=
literal|0
init|;
name|sy
operator|<
name|h
condition|;
name|sy
operator|++
operator|,
name|dy
operator|+=
name|dyi
control|)
block|{
name|quint16
modifier|*
name|ssl
init|=
operator|(
name|quint16
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|sy
operator|*
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|quint16
modifier|*
name|dsl
init|=
operator|(
name|quint16
operator|*
operator|)
operator|(
name|result
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|result
operator|.
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|int
name|dx
init|=
name|dxs
decl_stmt|;
for|for
control|(
name|int
name|sx
init|=
literal|0
init|;
name|sx
operator|<
name|w
condition|;
name|sx
operator|++
operator|,
name|dx
operator|+=
name|dxi
control|)
name|dsl
index|[
name|dx
index|]
operator|=
name|ssl
index|[
name|sx
index|]
expr_stmt|;
block|}
block|}
comment|// 24 bit
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|24
condition|)
block|{
for|for
control|(
name|int
name|sy
init|=
literal|0
init|;
name|sy
operator|<
name|h
condition|;
name|sy
operator|++
operator|,
name|dy
operator|+=
name|dyi
control|)
block|{
name|quint24
modifier|*
name|ssl
init|=
operator|(
name|quint24
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|sy
operator|*
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|quint24
modifier|*
name|dsl
init|=
operator|(
name|quint24
operator|*
operator|)
operator|(
name|result
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|result
operator|.
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|int
name|dx
init|=
name|dxs
decl_stmt|;
for|for
control|(
name|int
name|sx
init|=
literal|0
init|;
name|sx
operator|<
name|w
condition|;
name|sx
operator|++
operator|,
name|dx
operator|+=
name|dxi
control|)
name|dsl
index|[
name|dx
index|]
operator|=
name|ssl
index|[
name|sx
index|]
expr_stmt|;
block|}
block|}
comment|// 32 bit
elseif|else
if|if
condition|(
name|d
operator|->
name|depth
operator|==
literal|32
condition|)
block|{
for|for
control|(
name|int
name|sy
init|=
literal|0
init|;
name|sy
operator|<
name|h
condition|;
name|sy
operator|++
operator|,
name|dy
operator|+=
name|dyi
control|)
block|{
name|quint32
modifier|*
name|ssl
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|d
operator|->
name|data
operator|+
name|sy
operator|*
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|quint32
modifier|*
name|dsl
init|=
operator|(
name|quint32
operator|*
operator|)
operator|(
name|result
operator|.
name|d
operator|->
name|data
operator|+
name|dy
operator|*
name|result
operator|.
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
name|int
name|dx
init|=
name|dxs
decl_stmt|;
for|for
control|(
name|int
name|sx
init|=
literal|0
init|;
name|sx
operator|<
name|w
condition|;
name|sx
operator|++
operator|,
name|dx
operator|+=
name|dxi
control|)
name|dsl
index|[
name|dx
index|]
operator|=
name|ssl
index|[
name|sx
index|]
expr_stmt|;
block|}
block|}
comment|// special handling of 1 bit images for horizontal mirroring
if|if
condition|(
name|horizontal
operator|&&
name|d
operator|->
name|depth
operator|==
literal|1
condition|)
block|{
name|int
name|shift
init|=
name|width
argument_list|()
operator|%
literal|8
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
name|h
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|y
operator|--
control|)
block|{
name|quint8
modifier|*
name|a0
init|=
operator|(
name|quint8
operator|*
operator|)
operator|(
name|result
operator|.
name|d
operator|->
name|data
operator|+
name|y
operator|*
name|d
operator|->
name|bytes_per_line
operator|)
decl_stmt|;
comment|// Swap bytes
name|quint8
modifier|*
name|a
init|=
name|a0
operator|+
name|dxs
decl_stmt|;
while|while
condition|(
name|a
operator|>=
name|a0
condition|)
block|{
operator|*
name|a
operator|=
name|bitflip
index|[
operator|*
name|a
index|]
expr_stmt|;
name|a
operator|--
expr_stmt|;
block|}
comment|// Shift bits if unaligned
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
name|a
operator|=
name|a0
operator|+
name|dxs
expr_stmt|;
name|quint8
name|c
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|format
argument_list|()
operator|==
name|Format_MonoLSB
condition|)
block|{
while|while
condition|(
name|a
operator|>=
name|a0
condition|)
block|{
name|quint8
name|nc
init|=
operator|*
name|a
operator|<<
name|shift
decl_stmt|;
operator|*
name|a
operator|=
operator|(
operator|*
name|a
operator|>>
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator||
name|c
expr_stmt|;
operator|--
name|a
expr_stmt|;
name|c
operator|=
name|nc
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|a
operator|>=
name|a0
condition|)
block|{
name|quint8
name|nc
init|=
operator|*
name|a
operator|>>
name|shift
decl_stmt|;
operator|*
name|a
operator|=
operator|(
operator|*
name|a
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator||
name|c
expr_stmt|;
operator|--
name|a
expr_stmt|;
name|c
operator|=
name|nc
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QImage in which the values of the red and blue     components of all pixels have been swapped, effectively converting     an RGB image to an BGR image.      The original QImage is not changed.      \sa {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|rgbSwapped
name|QImage
name|QImage
operator|::
name|rgbSwapped
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QImage
name|res
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|Format_Invalid
case|:
case|case
name|NImageFormats
case|:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
name|Format_Mono
case|:
case|case
name|Format_MonoLSB
case|:
case|case
name|Format_Indexed8
case|:
name|res
operator|=
name|copy
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QRgb
name|c
init|=
name|res
operator|.
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|res
operator|.
name|d
operator|->
name|colortable
index|[
name|i
index|]
operator|=
name|QRgb
argument_list|(
operator|(
operator|(
name|c
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|c
operator|&
literal|0xff00ff00
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
case|case
name|Format_RGB32
case|:
case|case
name|Format_ARGB32
case|:
case|case
name|Format_ARGB32_Premultiplied
case|:
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|uint
modifier|*
name|q
init|=
operator|(
name|uint
operator|*
operator|)
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|p
init|=
operator|(
name|uint
operator|*
operator|)
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|p
operator|&
literal|0xff00ff00
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
case|case
name|Format_RGB16
case|:
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
name|i
operator|++
control|)
block|{
name|ushort
modifier|*
name|q
init|=
operator|(
name|ushort
operator|*
operator|)
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|p
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|end
init|=
name|p
operator|+
name|d
operator|->
name|width
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|p
operator|<<
literal|11
operator|)
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
operator|*
name|p
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
operator|*
name|p
operator|&
literal|0x07e0
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
default|default:
break|break;
block|}
name|res
operator|=
name|QImage
argument_list|(
name|d
operator|->
name|width
argument_list|,
name|d
operator|->
name|height
argument_list|,
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|res
argument_list|)
expr_stmt|;
specifier|const
name|QPixelLayout
modifier|*
name|layout
init|=
operator|&
name|qPixelLayouts
index|[
name|d
operator|->
name|format
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|layout
operator|->
name|redWidth
operator|==
name|layout
operator|->
name|blueWidth
argument_list|)
expr_stmt|;
name|FetchPixelsFunc
name|fetch
init|=
name|qFetchPixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
name|StorePixelsFunc
name|store
init|=
name|qStorePixels
index|[
name|layout
operator|->
name|bpp
index|]
decl_stmt|;
specifier|const
name|uint
name|redBlueMask
init|=
operator|(
literal|1
operator|<<
name|layout
operator|->
name|redWidth
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint
name|alphaGreenMask
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
name|layout
operator|->
name|alphaWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|layout
operator|->
name|alphaShift
operator|)
operator||
operator|(
operator|(
operator|(
literal|1
operator|<<
name|layout
operator|->
name|greenWidth
operator|)
operator|-
literal|1
operator|)
operator|<<
name|layout
operator|->
name|greenShift
operator|)
decl_stmt|;
specifier|const
name|int
name|buffer_size
init|=
literal|2048
decl_stmt|;
name|uint
name|buffer
index|[
name|buffer_size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|i
control|)
block|{
name|uchar
modifier|*
name|q
init|=
name|res
operator|.
name|scanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|p
init|=
name|constScanLine
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|d
operator|->
name|width
condition|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|d
operator|->
name|width
operator|-
name|x
argument_list|,
name|buffer_size
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|ptr
init|=
name|fetch
argument_list|(
name|buffer
argument_list|,
name|p
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|l
condition|;
operator|++
name|j
control|)
block|{
name|uint
name|red
init|=
operator|(
name|ptr
index|[
name|j
index|]
operator|>>
name|layout
operator|->
name|redShift
operator|)
operator|&
name|redBlueMask
decl_stmt|;
name|uint
name|blue
init|=
operator|(
name|ptr
index|[
name|j
index|]
operator|>>
name|layout
operator|->
name|blueShift
operator|)
operator|&
name|redBlueMask
decl_stmt|;
name|buffer
index|[
name|j
index|]
operator|=
operator|(
name|ptr
index|[
name|j
index|]
operator|&
name|alphaGreenMask
operator|)
operator||
operator|(
name|red
operator|<<
name|layout
operator|->
name|blueShift
operator|)
operator||
operator|(
name|blue
operator|<<
name|layout
operator|->
name|redShift
operator|)
expr_stmt|;
block|}
name|store
argument_list|(
name|q
argument_list|,
name|buffer
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|x
operator|+=
name|l
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     Loads an image from the file with the given \a fileName. Returns true if     the image was successfully loaded; otherwise invalidates the image     and returns false.      The loader attempts to read the image using the specified \a format, e.g.,     PNG or JPG. If \a format is not specified (which is the default), the     loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed images and other resource files in the application's     executable.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|load
name|bool
name|QImage
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|QImageReader
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function reads a QImage from the given \a device. This can,     for example, be used to load an image directly into a QByteArray. */
end_comment
begin_function
DECL|function|load
name|bool
name|QImage
operator|::
name|load
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|QImageReader
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::loadFromData(const uchar *data, int len, const char *format)      Loads an image from the first \a len bytes of the given binary \a     data. Returns true if the image was successfully loaded; otherwise     invalidates the image and returns false.      The loader attempts to read the image using the specified \a format, e.g.,     PNG or JPG. If \a format is not specified (which is the default), the     loader probes the file for a header to guess the file format.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|loadFromData
name|bool
name|QImage
operator|::
name|loadFromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QImage
name|image
init|=
name|fromData
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|operator
name|=
parameter_list|(
name|image
parameter_list|)
function_decl|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::loadFromData(const QByteArray&data, const char *format)      \overload      Loads an image from the given QByteArray \a data. */
end_comment
begin_comment
comment|/*!     \fn QImage QImage::fromData(const uchar *data, int size, const char *format)      Constructs a QImage from the first \a size bytes of the given     binary \a data. The loader attempts to read the image using the     specified \a format. If \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.     binary \a data. The loader attempts to read the image, either using the     optional image \a format specified or by determining the image format from     the data.      If \a format is not specified (which is the default), the loader probes the     file for a header to determine the file format. If \a format is specified,     it must be one of the values returned by QImageReader::supportedImageFormats().      If the loading of the image fails, the image returned will be a null image.      \sa load(), save(), {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}  */
end_comment
begin_function
DECL|function|fromData
name|QImage
name|QImage
operator|::
name|fromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QByteArray
name|a
init|=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|QBuffer
name|b
decl_stmt|;
name|b
operator|.
name|setData
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
return|return
name|QImageReader
argument_list|(
operator|&
name|b
argument_list|,
name|format
argument_list|)
operator|.
name|read
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QImage::fromData(const QByteArray&data, const char *format)      \overload      Loads an image from the given QByteArray \a data. */
end_comment
begin_comment
comment|/*!     Saves the image to the file with the given \a fileName, using the     given image file \a format and \a quality factor. If \a format is     0, QImage will attempt to guess the format by looking at \a fileName's     suffix.      The \a quality factor must be in the range 0 to 100 or -1. Specify     0 to obtain small compressed files, 100 for large uncompressed     files, and -1 (the default) to use the default settings.      Returns true if the image was successfully saved; otherwise     returns false.      \sa {QImage#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_function
DECL|function|save
name|bool
name|QImage
operator|::
name|save
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
name|QImageWriter
name|writer
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|doImageIO
argument_list|(
name|this
argument_list|,
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function writes a QImage to the given \a device.      This can, for example, be used to save an image directly into a     QByteArray:      \snippet image/image.cpp 0 */
end_comment
begin_function
DECL|function|save
name|bool
name|QImage
operator|::
name|save
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|doImageIO
argument_list|(
name|this
argument_list|,
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* \internal */
end_comment
begin_function
DECL|function|doImageIO
name|bool
name|QImageData
operator|::
name|doImageIO
parameter_list|(
specifier|const
name|QImage
modifier|*
name|image
parameter_list|,
name|QImageWriter
modifier|*
name|writer
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|quality
operator|>
literal|100
operator|||
name|quality
operator|<
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QPixmap::save: Quality out of range [-1, 100]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|>=
literal|0
condition|)
name|writer
operator|->
name|setQuality
argument_list|(
name|qMin
argument_list|(
name|quality
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|writer
operator|->
name|write
argument_list|(
operator|*
name|image
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QImage stream functions  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
end_if
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QImage&image)     \relates QImage      Writes the given \a image to the given \a stream as a PNG image,     or as a BMP image if the stream's version is 1. Note that writing     the stream to a file will not produce a valid image file.      \sa QImage::save(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
literal|5
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|s
operator|<<
operator|(
name|qint32
operator|)
literal|0
expr_stmt|;
comment|// null image marker
return|return
name|s
return|;
block|}
else|else
block|{
name|s
operator|<<
operator|(
name|qint32
operator|)
literal|1
expr_stmt|;
comment|// continue ...
block|}
block|}
name|QImageWriter
name|writer
argument_list|(
name|s
operator|.
name|device
argument_list|()
argument_list|,
name|s
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|?
literal|"bmp"
else|:
literal|"png"
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QImage&image)     \relates QImage      Reads an image from the given \a stream and stores it in the given     \a image.      \sa QImage::load(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
literal|5
condition|)
block|{
name|qint32
name|nullMarker
decl_stmt|;
name|s
operator|>>
name|nullMarker
expr_stmt|;
if|if
condition|(
operator|!
name|nullMarker
condition|)
block|{
name|image
operator|=
name|QImage
argument_list|()
expr_stmt|;
comment|// null image
return|return
name|s
return|;
block|}
block|}
name|image
operator|=
name|QImageReader
argument_list|(
name|s
operator|.
name|device
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|.
name|read
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \fn bool QImage::operator==(const QImage& image) const      Returns true if this image and the given \a image have the same     contents; otherwise returns false.      The comparison can be slow, unless there is some obvious     difference (e.g. different size or format), in which case the     function will return quickly.      \sa operator=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QImage
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
comment|// same object, or shared?
if|if
condition|(
name|i
operator|.
name|d
operator|==
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|i
operator|.
name|d
operator|||
operator|!
name|d
condition|)
return|return
literal|false
return|;
comment|// obviously different stuff?
if|if
condition|(
name|i
operator|.
name|d
operator|->
name|height
operator|!=
name|d
operator|->
name|height
operator|||
name|i
operator|.
name|d
operator|->
name|width
operator|!=
name|d
operator|->
name|width
operator|||
name|i
operator|.
name|d
operator|->
name|format
operator|!=
name|d
operator|->
name|format
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|format
operator|!=
name|Format_RGB32
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|>=
name|Format_ARGB32
condition|)
block|{
comment|// all bits defined
specifier|const
name|int
name|n
init|=
name|d
operator|->
name|width
operator|*
name|d
operator|->
name|depth
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|d
operator|->
name|bytes_per_line
operator|&&
name|n
operator|==
name|i
operator|.
name|d
operator|->
name|bytes_per_line
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|bits
argument_list|()
argument_list|,
name|i
operator|.
name|bits
argument_list|()
argument_list|,
name|d
operator|->
name|nbytes
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|d
operator|->
name|height
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|i
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|,
name|n
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|int
name|w
init|=
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|height
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|colortable
init|=
name|d
operator|->
name|colortable
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QRgb
argument_list|>
modifier|&
name|icolortable
init|=
name|i
operator|.
name|d
operator|->
name|colortable
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|colortable
index|[
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
index|]
operator|!=
name|icolortable
index|[
name|i
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
index|]
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|//alpha channel undefined, so we must mask it out
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|d
operator|->
name|height
condition|;
name|l
operator|++
control|)
block|{
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p1
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint
operator|*
argument_list|>
argument_list|(
name|scanLine
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uint
modifier|*
name|p2
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uint
operator|*
argument_list|>
argument_list|(
name|i
operator|.
name|scanLine
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p1
operator|++
operator|&
literal|0x00ffffff
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|++
operator|&
literal|0x00ffffff
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QImage::operator!=(const QImage& image) const      Returns true if this image and the given \a image have different     contents; otherwise returns false.      The comparison can be slow, unless there is some obvious     difference, such as different widths, in which case the function     will return quickly.      \sa operator=() */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QImage
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|i
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of pixels that fit horizontally in a physical     meter. Together with dotsPerMeterY(), this number defines the     intended scale and aspect ratio of the image.      \sa setDotsPerMeterX(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|dotsPerMeterX
name|int
name|QImage
operator|::
name|dotsPerMeterX
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|qRound
argument_list|(
name|d
operator|->
name|dpmx
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of pixels that fit vertically in a physical     meter. Together with dotsPerMeterX(), this number defines the     intended scale and aspect ratio of the image.      \sa setDotsPerMeterY(), {QImage#Image Information}{Image     Information} */
end_comment
begin_function
DECL|function|dotsPerMeterY
name|int
name|QImage
operator|::
name|dotsPerMeterY
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|qRound
argument_list|(
name|d
operator|->
name|dpmy
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of pixels that fit horizontally in a physical     meter, to \a x.      Together with dotsPerMeterY(), this number defines the intended     scale and aspect ratio of the image, and determines the scale     at which QPainter will draw graphics on the image. It does not     change the scale or aspect ratio of the image when it is rendered     on other paint devices.      \sa dotsPerMeterX(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setDotsPerMeterX
name|void
name|QImage
operator|::
name|setDotsPerMeterX
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|x
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|dpmx
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the number of pixels that fit vertically in a physical meter,     to \a y.      Together with dotsPerMeterX(), this number defines the intended     scale and aspect ratio of the image, and determines the scale     at which QPainter will draw graphics on the image. It does not     change the scale or aspect ratio of the image when it is rendered     on other paint devices.      \sa dotsPerMeterY(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setDotsPerMeterY
name|void
name|QImage
operator|::
name|setDotsPerMeterY
parameter_list|(
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|y
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|dpmy
operator|=
name|y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPoint QImage::offset() const      Returns the number of pixels by which the image is intended to be     offset by when positioning relative to other images.      \sa setOffset(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|offset
name|QPoint
name|QImage
operator|::
name|offset
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|offset
else|:
name|QPoint
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setOffset(const QPoint& offset)      Sets the number of pixels by which the image is intended to be     offset by when positioning relative to other images, to \a offset.      \sa offset(), {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|setOffset
name|void
name|QImage
operator|::
name|setOffset
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|offset
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the text keys for this image.      You can use these keys with text() to list the image text for a     certain key.      \sa text() */
end_comment
begin_function
DECL|function|textKeys
name|QStringList
name|QImage
operator|::
name|textKeys
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|QStringList
argument_list|(
name|d
operator|->
name|text
operator|.
name|keys
argument_list|()
argument_list|)
else|:
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the image text associated with the given \a key. If the     specified \a key is an empty string, the whole image text is     returned, with each key-text pair separated by a newline.      \sa setText(), textKeys() */
end_comment
begin_function
DECL|function|text
name|QString
name|QImage
operator|::
name|text
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
operator|!
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|text
operator|.
name|value
argument_list|(
name|key
argument_list|)
return|;
name|QString
name|tmp
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|key
decl|,
name|d
operator|->
name|text
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|tmp
operator|+=
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|key
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
operator|+
name|d
operator|->
name|text
operator|.
name|value
argument_list|(
name|key
argument_list|)
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QImage::setText(const QString&key, const QString&text)      Sets the image text to the given \a text and associate it with the     given \a key.      If you just want to store a single text block (i.e., a "comment"     or just a description), you can either pass an empty key, or use a     generic key like "Description".      The image text is embedded into the image data when you     call save() or QImageWriter::write().      Not all image formats support embedded text. You can find out     if a specific image or format supports embedding text     by using QImageWriter::supportsOption(). We give an example:      \snippet image/supportedformat.cpp 0      You can use QImageWriter::supportedImageFormats() to find out     which image formats are available to you.      \sa text(), textKeys() */
end_comment
begin_function
DECL|function|setText
name|void
name|QImage
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|text
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QImage::text(const char* key, const char* language) const     \obsolete      Returns the text recorded for the given \a key in the given \a     language, or in a default language if \a language is 0.      Use text() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation. */
end_comment
begin_comment
comment|/*!     \fn QString QImage::text(const QImageTextKeyLang& keywordAndLanguage) const     \overload     \obsolete      Returns the text recorded for the given \a keywordAndLanguage.      Use text() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation. */
end_comment
begin_comment
comment|/*!     \fn void QImage::setText(const char* key, const char* language, const QString& text)     \obsolete      Sets the image text to the given \a text and associate it with the     given \a key. The text is recorded in the specified \a language,     or in a default language if \a language is 0.      Use setText() instead.      The language the text is recorded in is no longer relevant since     the text is always set using QString and UTF-8 representation.      \omit     Records string \a  for the keyword \a key. The \a key should be     a portable keyword recognizable by other software - some suggested     values can be found in     \l{http://www.libpng.org/pub/png/spec/1.2/png-1.2-pdg.html#C.Anc-text}     {the PNG specification}. \a s can be any text. \a lang should     specify the language code (see     \l{http://www.rfc-editor.org/rfc/rfc1766.txt}{RFC 1766}) or 0.     \endomit */
end_comment
begin_comment
comment|/*     Sets the image bits to the \a pixmap contents and returns a     reference to the image.      If the image shares data with other images, it will first     dereference the shared data.      Makes a call to QPixmap::convertToImage(). */
end_comment
begin_comment
comment|/*!     \internal      Used by QPainter to retrieve a paint engine for the image. */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QImage
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|paintEngine
condition|)
block|{
name|QPaintDevice
modifier|*
name|paintDevice
init|=
cast|const_cast
argument_list|<
name|QImage
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QPaintEngine
modifier|*
name|paintEngine
init|=
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createImagePaintEngine
argument_list|(
name|paintDevice
argument_list|)
decl_stmt|;
name|d
operator|->
name|paintEngine
operator|=
name|paintEngine
condition|?
name|paintEngine
else|:
operator|new
name|QRasterPaintEngine
argument_list|(
name|paintDevice
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|paintEngine
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the size for the specified \a metric on the device. */
end_comment
begin_function
DECL|function|metric
name|int
name|QImage
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|metric
condition|)
block|{
case|case
name|PdmWidth
case|:
return|return
name|d
operator|->
name|width
return|;
case|case
name|PdmHeight
case|:
return|return
name|d
operator|->
name|height
return|;
case|case
name|PdmWidthMM
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|width
operator|*
literal|1000
operator|/
name|d
operator|->
name|dpmx
argument_list|)
return|;
case|case
name|PdmHeightMM
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|height
operator|*
literal|1000
operator|/
name|d
operator|->
name|dpmy
argument_list|)
return|;
case|case
name|PdmNumColors
case|:
return|return
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
return|;
case|case
name|PdmDepth
case|:
return|return
name|d
operator|->
name|depth
return|;
case|case
name|PdmDpiX
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|ldpmx
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmDpiY
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|ldpmy
operator|*
literal|0.0254
argument_list|)
return|;
break|break;
case|case
name|PdmPhysicalDpiX
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmx
operator|*
literal|0.0254
operator|*
name|d
operator|->
name|devicePixelRatio
argument_list|)
return|;
break|break;
case|case
name|PdmPhysicalDpiY
case|:
return|return
name|qRound
argument_list|(
name|d
operator|->
name|dpmy
operator|*
literal|0.0254
operator|*
name|d
operator|->
name|devicePixelRatio
argument_list|)
return|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QImage::metric(): Unhandled metric type %d"
argument_list|,
name|metric
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPixmap (and QImage) helper functions  *****************************************************************************/
end_comment
begin_comment
comment|/*   This internal function contains the common (i.e. platform independent) code   to do a transformation of pixel data. It is used by QPixmap::transform() and by   QImage::transform().    \a trueMat is the true transformation matrix (see QPixmap::trueMatrix()) and   \a xoffset is an offset to the matrix.    \a msbfirst specifies for 1bpp images, if the MSB or LSB comes first and \a   depth specifies the colordepth of the data.    \a dptr is a pointer to the destination data, \a dbpl specifies the bits per   line for the destination data, \a p_inc is the offset that we advance for   every scanline and \a dHeight is the height of the destination image.    \a sprt is the pointer to the source data, \a sbpl specifies the bits per   line of the source data, \a sWidth and \a sHeight are the width and height of   the source data. */
end_comment
begin_undef
DECL|macro|IWX_MSB
undef|#
directive|undef
name|IWX_MSB
end_undef
begin_define
DECL|macro|IWX_MSB
define|#
directive|define
name|IWX_MSB
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if (*(sptr+sbpl*(trigy>>12)+(trigx>>15))&                      \                                  (1<< (7-((trigx>>12)&7))))                              \                                 *dptr |= b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_undef
DECL|macro|IWX_LSB
undef|#
directive|undef
name|IWX_LSB
end_undef
begin_define
DECL|macro|IWX_LSB
define|#
directive|define
name|IWX_LSB
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if (*(sptr+sbpl*(trigy>>12)+(trigx>>15))&                      \                                  (1<< ((trigx>>12)&7)))                              \                                 *dptr |= b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_undef
DECL|macro|IWX_PIX
undef|#
directive|undef
name|IWX_PIX
end_undef
begin_define
DECL|macro|IWX_PIX
define|#
directive|define
name|IWX_PIX
parameter_list|(
name|b
parameter_list|)
value|if (trigx< maxws&& trigy< maxhs) {                              \                             if ((*(sptr+sbpl*(trigy>>12)+(trigx>>15))&              \                                  (1<< (7-((trigx>>12)&7)))) == 0)                      \                                 *dptr&= ~b;                                              \                         }                                                              \                         trigx += m11;                                                      \                         trigy += m12;
end_define
begin_comment
comment|// END OF MACRO
end_comment
begin_function
DECL|function|qt_xForm_helper
name|bool
name|qt_xForm_helper
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|trueMat
parameter_list|,
name|int
name|xoffset
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|depth
parameter_list|,
name|uchar
modifier|*
name|dptr
parameter_list|,
name|int
name|dbpl
parameter_list|,
name|int
name|p_inc
parameter_list|,
name|int
name|dHeight
parameter_list|,
specifier|const
name|uchar
modifier|*
name|sptr
parameter_list|,
name|int
name|sbpl
parameter_list|,
name|int
name|sWidth
parameter_list|,
name|int
name|sHeight
parameter_list|)
block|{
name|int
name|m11
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m11
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m12
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m12
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m21
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m21
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m22
init|=
name|int
argument_list|(
name|trueMat
operator|.
name|m22
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|dx
init|=
name|qRound
argument_list|(
name|trueMat
operator|.
name|dx
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|dy
init|=
name|qRound
argument_list|(
name|trueMat
operator|.
name|dy
argument_list|()
operator|*
literal|4096.0
argument_list|)
decl_stmt|;
name|int
name|m21ydx
init|=
name|dx
operator|+
operator|(
name|xoffset
operator|<<
literal|16
operator|)
operator|+
operator|(
name|m11
operator|+
name|m21
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|m22ydy
init|=
name|dy
operator|+
operator|(
name|m12
operator|+
name|m22
operator|)
operator|/
literal|2
decl_stmt|;
name|uint
name|trigx
decl_stmt|;
name|uint
name|trigy
decl_stmt|;
name|uint
name|maxws
init|=
name|sWidth
operator|<<
literal|12
decl_stmt|;
name|uint
name|maxhs
init|=
name|sHeight
operator|<<
literal|12
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|dHeight
condition|;
name|y
operator|++
control|)
block|{
comment|// for each target scanline
name|trigx
operator|=
name|m21ydx
expr_stmt|;
name|trigy
operator|=
name|m22ydy
expr_stmt|;
name|uchar
modifier|*
name|maxp
init|=
name|dptr
operator|+
name|dbpl
decl_stmt|;
if|if
condition|(
name|depth
operator|!=
literal|1
condition|)
block|{
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|8
case|:
comment|// 8 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
name|dptr
operator|=
operator|*
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
comment|// 16 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|dptr
operator|)
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
comment|// 24 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|p2
init|=
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|*
literal|3
operator|)
decl_stmt|;
name|dptr
index|[
literal|0
index|]
operator|=
name|p2
index|[
literal|0
index|]
expr_stmt|;
name|dptr
index|[
literal|1
index|]
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
name|dptr
index|[
literal|2
index|]
operator|=
name|p2
index|[
literal|2
index|]
expr_stmt|;
block|}
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
comment|// 32 bpp transform
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
if|if
condition|(
name|trigx
operator|<
name|maxws
operator|&&
name|trigy
operator|<
name|maxhs
condition|)
operator|*
operator|(
operator|(
name|uint
operator|*
operator|)
name|dptr
operator|)
operator|=
operator|*
operator|(
operator|(
name|uint
operator|*
operator|)
operator|(
name|sptr
operator|+
name|sbpl
operator|*
operator|(
name|trigy
operator|>>
literal|12
operator|)
operator|+
operator|(
operator|(
name|trigx
operator|>>
literal|12
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|)
expr_stmt|;
name|trigx
operator|+=
name|m11
expr_stmt|;
name|trigy
operator|+=
name|m12
expr_stmt|;
name|dptr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QT_XFORM_TYPE_MSBFIRST
case|:
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
name|IWX_MSB
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IWX_MSB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|QT_XFORM_TYPE_LSBFIRST
case|:
while|while
condition|(
name|dptr
operator|<
name|maxp
condition|)
block|{
name|IWX_LSB
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|64
argument_list|)
expr_stmt|;
name|IWX_LSB
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|dptr
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
name|m21ydx
operator|+=
name|m21
expr_stmt|;
name|m22ydy
operator|+=
name|m22
expr_stmt|;
name|dptr
operator|+=
name|p_inc
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_undef
DECL|macro|IWX_MSB
undef|#
directive|undef
name|IWX_MSB
end_undef
begin_undef
DECL|macro|IWX_LSB
undef|#
directive|undef
name|IWX_LSB
end_undef
begin_undef
DECL|macro|IWX_PIX
undef|#
directive|undef
name|IWX_PIX
end_undef
begin_comment
comment|/*! \fn int QImage::serialNumber() const     \obsolete     Returns a number that identifies the contents of this     QImage object. Distinct QImage objects can only have the same     serial number if they refer to the same contents (but they don't     have to).      Use cacheKey() instead.      \warning The serial number doesn't necessarily change when the     image is altered. This means that it may be dangerous to use     it as a cache key.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns a number that identifies the contents of this QImage     object. Distinct QImage objects can only have the same key if they     refer to the same contents.      The key will change when the image is altered. */
end_comment
begin_function
DECL|function|cacheKey
name|qint64
name|QImage
operator|::
name|cacheKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
operator|(
operator|(
name|qint64
operator|)
name|d
operator|->
name|ser_no
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|qint64
operator|)
name|d
operator|->
name|detach_no
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns true if the image is detached; otherwise returns false.      \sa detach(), {Implicit Data Sharing} */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QImage
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     Sets the alpha channel of this image to the given \a alphaChannel.      If \a alphaChannel is an 8 bit grayscale image, the intensity values are     written into this buffer directly. Otherwise, \a alphaChannel is converted     to 32 bit and the intensity of the RGB pixel values is used.      Note that the image will be converted to the Format_ARGB32_Premultiplied     format if the function succeeds.      Use one of the composition modes in QPainter::CompositionMode instead.      \warning This function is expensive.      \sa alphaChannel(), {QImage#Image Transformations}{Image     Transformations}, {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|setAlphaChannel
name|void
name|QImage
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QImage
modifier|&
name|alphaChannel
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|height
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|alphaChannel
operator|.
name|d
operator|->
name|width
operator|||
name|h
operator|!=
name|alphaChannel
operator|.
name|d
operator|->
name|height
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setAlphaChannel: "
literal|"Alpha channel must have same dimensions as the target image"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|paintEngine
operator|&&
name|d
operator|->
name|paintEngine
operator|->
name|isActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QImage::setAlphaChannel: "
literal|"Unable to set alpha channel while image is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
condition|)
name|detach
argument_list|()
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
comment|// Slight optimization since alphachannels are returned as 8-bit grays.
if|if
condition|(
name|alphaChannel
operator|.
name|d
operator|->
name|depth
operator|==
literal|8
operator|&&
name|alphaChannel
operator|.
name|isGrayscale
argument_list|()
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|alphaChannel
operator|.
name|d
operator|->
name|data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|dest_data
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|src_data
decl_stmt|;
name|QRgb
modifier|*
name|dest
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|alpha
init|=
operator|*
name|src
decl_stmt|;
name|int
name|destAlpha
init|=
name|qt_div_255
argument_list|(
name|alpha
operator|*
name|qAlpha
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|(
name|destAlpha
operator|<<
literal|24
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|alphaChannel
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|QImage
name|sourceImage
init|=
name|alphaChannel
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|sourceImage
operator|.
name|d
operator|->
name|data
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|dest_data
init|=
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
name|QRgb
modifier|*
name|dest
init|=
operator|(
name|QRgb
operator|*
operator|)
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
name|int
name|alpha
init|=
name|qGray
argument_list|(
operator|*
name|src
argument_list|)
decl_stmt|;
name|int
name|destAlpha
init|=
name|qt_div_255
argument_list|(
name|alpha
operator|*
name|qAlpha
argument_list|(
operator|*
name|dest
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|(
name|destAlpha
operator|<<
literal|24
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qRed
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qGreen
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|qt_div_255
argument_list|(
name|qBlue
argument_list|(
operator|*
name|dest
argument_list|)
operator|*
name|alpha
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|sourceImage
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns the alpha channel of the image as a new grayscale QImage in which     each pixel's red, green, and blue values are given the alpha value of the     original image. The color depth of the returned image is 8-bit.      You can see an example of use of this function in QPixmap's     \l{QPixmap::}{alphaChannel()}, which works in the same way as     this function on QPixmaps.      Most usecases for this function can be replaced with QPainter and     using composition modes.      \warning This is an expensive function.      \sa setAlphaChannel(), hasAlphaChannel(),     {QPixmap#Pixmap Information}{Pixmap},     {QImage#Image Transformations}{Image Transformations} */
end_comment
begin_function
DECL|function|alphaChannel
name|QImage
name|QImage
operator|::
name|alphaChannel
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
name|int
name|w
init|=
name|d
operator|->
name|width
decl_stmt|;
name|int
name|h
init|=
name|d
operator|->
name|height
decl_stmt|;
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|Format_Indexed8
argument_list|)
decl_stmt|;
name|image
operator|.
name|setColorCount
argument_list|(
literal|256
argument_list|)
expr_stmt|;
comment|// set up gray scale table.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
name|image
operator|.
name|setColor
argument_list|(
name|i
argument_list|,
name|qRgb
argument_list|(
name|i
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|image
operator|.
name|fill
argument_list|(
literal|255
argument_list|)
expr_stmt|;
return|return
name|image
return|;
block|}
if|if
condition|(
name|d
operator|->
name|format
operator|==
name|Format_Indexed8
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|image
operator|.
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|src
init|=
name|src_data
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
name|dest
operator|=
name|qAlpha
argument_list|(
name|d
operator|->
name|colortable
operator|.
name|at
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
else|else
block|{
name|QImage
name|alpha32
init|=
operator|*
name|this
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|!=
name|Format_ARGB32
operator|&&
name|d
operator|->
name|format
operator|!=
name|Format_ARGB32_Premultiplied
condition|)
name|alpha32
operator|=
name|convertToFormat
argument_list|(
name|Format_ARGB32
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|src_data
init|=
name|alpha32
operator|.
name|d
operator|->
name|data
decl_stmt|;
name|uchar
modifier|*
name|dest_data
init|=
name|image
operator|.
name|d
operator|->
name|data
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src
init|=
operator|(
specifier|const
name|QRgb
operator|*
operator|)
name|src_data
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|dest_data
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
operator|*
name|dest
operator|=
name|qAlpha
argument_list|(
operator|*
name|src
argument_list|)
expr_stmt|;
operator|++
name|dest
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
name|src_data
operator|+=
name|alpha32
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
name|dest_data
operator|+=
name|image
operator|.
name|d
operator|->
name|bytes_per_line
expr_stmt|;
block|}
block|}
return|return
name|image
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the image has a format that respects the alpha     channel, otherwise returns false.      \sa {QImage#Image Information}{Image Information} */
end_comment
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QImage
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
operator|(
name|d
operator|->
name|format
operator|==
name|Format_ARGB32_Premultiplied
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB32
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB8565_Premultiplied
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB8555_Premultiplied
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB6666_Premultiplied
operator|||
name|d
operator|->
name|format
operator|==
name|Format_ARGB4444_Premultiplied
operator|||
operator|(
name|d
operator|->
name|has_alpha_clut
operator|&&
operator|(
name|d
operator|->
name|format
operator|==
name|Format_Indexed8
operator|||
name|d
operator|->
name|format
operator|==
name|Format_Mono
operator|||
name|d
operator|->
name|format
operator|==
name|Format_MonoLSB
operator|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the number of bit planes in the image.      The number of bit planes is the number of bits of color and     transparency information for each pixel. This is different from     (i.e. smaller than) the depth when the image format contains     unused bits.      \sa depth(), format(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|bitPlaneCount
name|int
name|QImage
operator|::
name|bitPlaneCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|int
name|bpc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Invalid
case|:
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|bpc
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
name|bpc
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
name|bpc
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
name|bpc
operator|=
literal|23
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|bpc
operator|=
literal|12
expr_stmt|;
break|break;
default|default:
name|bpc
operator|=
name|qt_depthForFormat
argument_list|(
name|d
operator|->
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|bpc
return|;
block|}
end_function
begin_function
DECL|function|smoothScaled
specifier|static
name|QImage
name|smoothScaled
parameter_list|(
specifier|const
name|QImage
modifier|&
name|source
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|QImage
name|src
init|=
name|source
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_ARGB32
condition|)
name|src
operator|=
name|src
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|.
name|depth
argument_list|()
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|src
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|src
operator|=
name|src
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|src
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
block|}
return|return
name|qSmoothScaleImage
argument_list|(
name|src
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rotated90
specifier|static
name|QImage
name|rotated90
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QImage
name|out
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|>
literal|0
condition|)
name|out
operator|.
name|setColorTable
argument_list|(
name|image
operator|.
name|colorTable
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint24
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|qt_memrotate270
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint8
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
condition|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|h
operator|-
name|y
operator|-
literal|1
argument_list|,
name|x
argument_list|,
name|image
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|h
operator|-
name|y
operator|-
literal|1
argument_list|,
name|x
argument_list|,
name|image
operator|.
name|pixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|rotated180
specifier|static
name|QImage
name|rotated180
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
return|return
name|image
operator|.
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rotated270
specifier|static
name|QImage
name|rotated270
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|QImage
name|out
argument_list|(
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
operator|>
literal|0
condition|)
name|out
operator|.
name|setColorTable
argument_list|(
name|image
operator|.
name|colorTable
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint32
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
case|case
name|QImage
operator|::
name|Format_ARGB6666_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8565_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_ARGB8555_Premultiplied
case|:
case|case
name|QImage
operator|::
name|Format_RGB888
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint24
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint24
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint16
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
name|qt_memrotate90
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|quint8
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|quint8
operator|*
argument_list|>
argument_list|(
name|out
operator|.
name|bits
argument_list|()
argument_list|)
argument_list|,
name|out
operator|.
name|bytesPerLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
if|if
condition|(
name|image
operator|.
name|colorCount
argument_list|()
condition|)
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|y
argument_list|,
name|w
operator|-
name|x
operator|-
literal|1
argument_list|,
name|image
operator|.
name|pixelIndex
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
name|out
operator|.
name|setPixel
argument_list|(
name|y
argument_list|,
name|w
operator|-
name|x
operator|-
literal|1
argument_list|,
name|image
operator|.
name|pixel
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the image that is transformed using the given     transformation \a matrix and transformation \a mode.      The transformation \a matrix is internally adjusted to compensate     for unwanted translation; i.e. the image produced is the smallest     image that contains all the transformed points of the original     image. Use the trueMatrix() function to retrieve the actual matrix     used for transforming an image.      Unlike the other overload, this function can be used to perform perspective     transformations on images.      \sa trueMatrix(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QImage
name|QImage
operator|::
name|transformed
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// source image data
name|int
name|ws
init|=
name|width
argument_list|()
decl_stmt|;
name|int
name|hs
init|=
name|height
argument_list|()
decl_stmt|;
comment|// target image data
name|int
name|wd
decl_stmt|;
name|int
name|hd
decl_stmt|;
comment|// compute size of target image
name|QTransform
name|mat
init|=
name|trueMatrix
argument_list|(
name|matrix
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
decl_stmt|;
name|bool
name|complex_xform
init|=
literal|false
decl_stmt|;
name|bool
name|scale_xform
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|==
name|QTransform
operator|::
name|TxNone
condition|)
comment|// identity matrix
return|return
operator|*
name|this
return|;
elseif|else
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|==
operator|-
literal|1.
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|==
operator|-
literal|1.
condition|)
return|return
name|rotated180
argument_list|(
operator|*
name|this
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|FastTransformation
condition|)
block|{
name|hd
operator|=
name|qRound
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m22
argument_list|()
argument_list|)
operator|*
name|hs
argument_list|)
expr_stmt|;
name|wd
operator|=
name|qRound
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m11
argument_list|()
argument_list|)
operator|*
name|ws
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hd
operator|=
name|int
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m22
argument_list|()
argument_list|)
operator|*
name|hs
operator|+
literal|0.9999
argument_list|)
expr_stmt|;
name|wd
operator|=
name|int
argument_list|(
name|qAbs
argument_list|(
name|mat
operator|.
name|m11
argument_list|()
argument_list|)
operator|*
name|ws
operator|+
literal|0.9999
argument_list|)
expr_stmt|;
block|}
name|scale_xform
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mat
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxRotate
operator|&&
name|mat
operator|.
name|m11
argument_list|()
operator|==
literal|0
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|m12
argument_list|()
operator|==
literal|1.
operator|&&
name|mat
operator|.
name|m21
argument_list|()
operator|==
operator|-
literal|1.
condition|)
return|return
name|rotated90
argument_list|(
operator|*
name|this
argument_list|)
return|;
elseif|else
if|if
condition|(
name|mat
operator|.
name|m12
argument_list|()
operator|==
operator|-
literal|1.
operator|&&
name|mat
operator|.
name|m21
argument_list|()
operator|==
literal|1.
condition|)
return|return
name|rotated270
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
name|QPolygonF
name|a
argument_list|(
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
argument_list|)
decl_stmt|;
name|a
operator|=
name|mat
operator|.
name|map
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|QRect
name|r
init|=
name|a
operator|.
name|boundingRect
argument_list|()
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
name|wd
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|hd
operator|=
name|r
operator|.
name|height
argument_list|()
expr_stmt|;
name|complex_xform
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|wd
operator|==
literal|0
operator|||
name|hd
operator|==
literal|0
condition|)
return|return
name|QImage
argument_list|()
return|;
comment|// Make use of the optimized algorithm when we're scaling
if|if
condition|(
name|scale_xform
operator|&&
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|<
literal|0.0F
operator|&&
name|mat
operator|.
name|m22
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// horizontal/vertical flip
return|return
name|smoothScaled
argument_list|(
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
argument_list|,
name|wd
argument_list|,
name|hd
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mat
operator|.
name|m11
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// horizontal flip
return|return
name|smoothScaled
argument_list|(
name|mirrored
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|,
name|wd
argument_list|,
name|hd
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mat
operator|.
name|m22
argument_list|()
operator|<
literal|0.0F
condition|)
block|{
comment|// vertical flip
return|return
name|smoothScaled
argument_list|(
name|mirrored
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
argument_list|,
name|wd
argument_list|,
name|hd
argument_list|)
return|;
block|}
else|else
block|{
comment|// no flipping
return|return
name|smoothScaled
argument_list|(
operator|*
name|this
argument_list|,
name|wd
argument_list|,
name|hd
argument_list|)
return|;
block|}
block|}
name|int
name|bpp
init|=
name|depth
argument_list|()
decl_stmt|;
name|int
name|sbpl
init|=
name|bytesPerLine
argument_list|()
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
name|bits
argument_list|()
decl_stmt|;
name|QImage
operator|::
name|Format
name|target_format
init|=
name|d
operator|->
name|format
decl_stmt|;
if|if
condition|(
name|complex_xform
operator|||
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|<
name|QImage
operator|::
name|Format_RGB32
operator|||
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|d
operator|->
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|target_format
operator|=
name|Format_ARGB8565_Premultiplied
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB555
case|:
name|target_format
operator|=
name|Format_ARGB8555_Premultiplied
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB666
case|:
name|target_format
operator|=
name|Format_ARGB6666_Premultiplied
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB444
case|:
name|target_format
operator|=
name|Format_ARGB4444_Premultiplied
expr_stmt|;
break|break;
default|default:
name|target_format
operator|=
name|Format_ARGB32_Premultiplied
expr_stmt|;
break|break;
block|}
block|}
block|}
name|QImage
name|dImage
argument_list|(
name|wd
argument_list|,
name|hd
argument_list|,
name|target_format
argument_list|)
decl_stmt|;
name|QIMAGE_SANITYCHECK_MEMORY
argument_list|(
name|dImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_format
operator|==
name|QImage
operator|::
name|Format_MonoLSB
operator|||
name|target_format
operator|==
name|QImage
operator|::
name|Format_Mono
operator|||
name|target_format
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|=
name|d
operator|->
name|colortable
expr_stmt|;
name|dImage
operator|.
name|d
operator|->
name|has_alpha_clut
operator|=
name|d
operator|->
name|has_alpha_clut
operator||
name|complex_xform
expr_stmt|;
block|}
name|dImage
operator|.
name|d
operator|->
name|dpmx
operator|=
name|dotsPerMeterX
argument_list|()
expr_stmt|;
name|dImage
operator|.
name|d
operator|->
name|dpmy
operator|=
name|dotsPerMeterY
argument_list|()
expr_stmt|;
name|dImage
operator|.
name|d
operator|->
name|devicePixelRatio
operator|=
name|devicePixelRatio
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
comment|// initizialize the data
case|case
literal|8
case|:
if|if
condition|(
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|<
literal|256
condition|)
block|{
comment|// colors are left in the color table, so pick that one as transparent
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|append
argument_list|(
literal|0x0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
name|dImage
operator|.
name|d
operator|->
name|colortable
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
case|case
literal|16
case|:
case|case
literal|24
case|:
case|case
literal|32
case|:
name|memset
argument_list|(
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
literal|0x00
argument_list|,
name|dImage
operator|.
name|byteCount
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|target_format
operator|>=
name|QImage
operator|::
name|Format_RGB32
condition|)
block|{
name|QPainter
name|p
argument_list|(
operator|&
name|dImage
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|SmoothTransformation
condition|)
block|{
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|)
expr_stmt|;
name|p
operator|.
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
expr_stmt|;
block|}
name|p
operator|.
name|setTransform
argument_list|(
name|mat
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawImage
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|invertible
decl_stmt|;
name|mat
operator|=
name|mat
operator|.
name|inverted
argument_list|(
operator|&
name|invertible
argument_list|)
expr_stmt|;
comment|// invert matrix
if|if
condition|(
operator|!
name|invertible
condition|)
comment|// error, return null image
return|return
name|QImage
argument_list|()
return|;
comment|// create target image (some of the code is from QImage::copy())
name|int
name|type
init|=
name|format
argument_list|()
operator|==
name|Format_Mono
condition|?
name|QT_XFORM_TYPE_MSBFIRST
else|:
name|QT_XFORM_TYPE_LSBFIRST
decl_stmt|;
name|int
name|dbpl
init|=
name|dImage
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|qt_xForm_helper
argument_list|(
name|mat
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|bpp
argument_list|,
name|dImage
operator|.
name|bits
argument_list|()
argument_list|,
name|dbpl
argument_list|,
literal|0
argument_list|,
name|hd
argument_list|,
name|sptr
argument_list|,
name|sbpl
argument_list|,
name|ws
argument_list|,
name|hs
argument_list|)
expr_stmt|;
block|}
return|return
name|dImage
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTransform QImage::trueMatrix(const QTransform&matrix, int width, int height)      Returns the actual matrix used for transforming an image with the     given \a width, \a height and \a matrix.      When transforming an image using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     image containing all transformed points of the original image.     This function returns the modified matrix, which maps points     correctly from the original image into the new image.      Unlike the other overload, this function creates transformation     matrices that can be used to perform perspective     transformations on images.      \sa transformed(), {QImage#Image Transformations}{Image     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QTransform
name|QImage
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|matrix
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|const
name|QRectF
name|rect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|mapped
init|=
name|matrix
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toAlignedRect
argument_list|()
decl_stmt|;
specifier|const
name|QPoint
name|delta
init|=
name|mapped
operator|.
name|topLeft
argument_list|()
decl_stmt|;
return|return
name|matrix
operator|*
name|QTransform
argument_list|()
operator|.
name|translate
argument_list|(
operator|-
name|delta
operator|.
name|x
argument_list|()
argument_list|,
operator|-
name|delta
operator|.
name|y
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertInPlace
name|bool
name|QImageData
operator|::
name|convertInPlace
parameter_list|(
name|QImage
operator|::
name|Format
name|newFormat
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|newFormat
condition|)
return|return
literal|true
return|;
comment|// No in-place conversion if we have to detach
if|if
condition|(
name|ref
operator|.
name|load
argument_list|()
operator|>
literal|1
condition|)
return|return
literal|false
return|;
specifier|const
name|InPlace_Image_Converter
modifier|*
specifier|const
name|converterPtr
init|=
operator|&
name|inplace_converter_map
index|[
name|format
index|]
index|[
name|newFormat
index|]
decl_stmt|;
name|InPlace_Image_Converter
name|converter
init|=
operator|*
name|converterPtr
decl_stmt|;
if|if
condition|(
name|converter
condition|)
return|return
name|converter
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
else|else
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QImage::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr& QImage::data_ptr()     \internal */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QImage
modifier|&
name|i
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QImage("
operator|<<
name|i
operator|.
name|size
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QImage::setNumColors(int n)     \obsolete      Resizes the color table to contain \a n entries.      \sa setColorCount()  */
end_comment
begin_comment
comment|/*!     \fn int QImage::numBytes() const     \obsolete      Returns the number of bytes occupied by the image data.      \sa byteCount()  */
end_comment
begin_comment
comment|/*!     \fn QStringList QImage::textLanguages() const     \obsolete      Returns the language identifiers for which some texts are recorded.     Note that if you want to iterate over the list, you should iterate over a copy.      The language the text is recorded in is no longer relevant since the text is     always set using QString and UTF-8 representation.      \sa textKeys()  */
end_comment
begin_comment
comment|/*!     \fn QList<QImageTextKeyLang> QImage::textList() const     \obsolete      Returns a list of QImageTextKeyLang objects that enumerate all the texts     key/language pairs set for this image.      The language the text is recorded in is no longer relevant since the text     is always set using QString and UTF-8 representation.      \sa textKeys()  */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
