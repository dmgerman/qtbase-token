begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformpixmap.h>
end_include
begin_include
include|#
directive|include
file|"qimagepixmapcleanuphooks_p.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"qimagewriter.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengine.h"
end_include
begin_include
include|#
directive|include
file|"qscreen.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qplatformintegration.h>
end_include
begin_include
include|#
directive|include
file|"qpixmap_raster_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qhexstring_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|qt_pixmap_thread_test
specifier|static
name|bool
name|qt_pixmap_thread_test
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
block|{
name|qFatal
argument_list|(
literal|"QPixmap: Must construct a QApplication before a QPaintDevice"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|qApp
operator|->
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|bool
name|fail
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedPixmaps
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Lighthouse plugin does not support threaded pixmaps!\n"
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap: It is not safe to use pixmaps outside the GUI thread"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|doInit
name|void
name|QPixmap
operator|::
name|doInit
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
operator|)
operator|||
name|type
operator|==
name|QPlatformPixmap
operator|::
name|BitmapType
condition|)
name|data
operator|=
name|QPlatformPixmap
operator|::
name|create
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|QPlatformPixmap
operator|::
name|PixelType
operator|)
name|type
argument_list|)
expr_stmt|;
else|else
name|data
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a null pixmap.      \sa isNull() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|()
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
operator|(
name|void
operator|)
name|qt_pixmap_thread_test
argument_list|()
expr_stmt|;
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QPixmap::QPixmap(int width, int height)      Constructs a pixmap with the given \a width and \a height. If     either \a width or \a height is zero, a null pixmap is     constructed.      \warning This will create a QPixmap with uninitialized data. Call     fill() to fill the pixmap with an appropriate color before drawing     onto it with QPainter.      \sa isNull() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
else|else
name|doInit
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \overload      Constructs a pixmap of the given \a size.      \warning This will create a QPixmap with uninitialized data. Call     fill() to fill the pixmap with an appropriate color before drawing     onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
else|else
name|doInit
argument_list|(
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|QPlatformPixmap
operator|::
name|PixelType
argument_list|>
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doInit
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QPlatformPixmap
operator|::
name|PixelType
argument_list|>
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
name|QPlatformPixmap
modifier|*
name|d
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
member_init_list|,
name|data
argument_list|(
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a pixmap from the file with the given \a fileName. If the     file does not exist or is of an unknown format, the pixmap becomes a     null pixmap.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to     one of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how     to embed images and other resource files in the application's     executable.      If the image needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a     flags to control the conversion.      The \a fileName, \a format and \a flags parameters are     passed on to load(). This means that the data in \a fileName is     not compiled into the binary. If \a fileName contains a relative     path (e.g. the filename only) the relevant file must be found     relative to the runtime working directory.      \sa {QPixmap#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
return|return;
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a pixmap that is a copy of the given \a pixmap.      \sa copy() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
block|{
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pixmap
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// make a deep copy
name|pixmap
operator|.
name|copy
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|pixmap
operator|.
name|data
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a pixmap from the given \a xpm data, which must be a     valid XPM image.      Errors are silently ignored.      Note that it's possible to squeeze the XPM variable a little bit     by using an unusual declaration:      \snippet code/src_gui_image_qpixmap.cpp 0      The extra \c const makes the entire definition read-only, which is     slightly more efficient (for example, when the code is in a shared     library) and ROMable when the application is to be stored in ROM. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
end_ifndef
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|xpm
index|[]
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|doInit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xpm
condition|)
return|return;
name|QImage
name|image
argument_list|(
name|xpm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|QPlatformPixmap
operator|::
name|BitmapType
condition|)
operator|*
name|this
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the pixmap. */
end_comment
begin_destructor
DECL|function|~QPixmap
name|QPixmap
operator|::
name|~
name|QPixmap
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|data
operator|||
name|data
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|// Catch if ref-counting changes again
block|}
end_destructor
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QPixmap
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Pixmap
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::copy(int x, int y, int width, int height) const     \overload      Returns a deep copy of the subset of the pixmap that is specified     by the rectangle QRect( \a x, \a y, \a width, \a height). */
end_comment
begin_comment
comment|/*!     \fn QPixmap QPixmap::copy(const QRect&rectangle) const      Returns a deep copy of the subset of the pixmap that is specified     by the given \a rectangle. For more information on deep copies,     see the \l {Implicit Data Sharing} documentation.      If the given \a rectangle is empty, the whole image is copied.      \sa operator=(), QPixmap(), {QPixmap#Pixmap     Transformations}{Pixmap Transformations} */
end_comment
begin_function
DECL|function|copy
name|QPixmap
name|QPixmap
operator|::
name|copy
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QRect
name|r
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
name|r
operator|=
name|r
operator|.
name|intersected
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|QPlatformPixmap
modifier|*
name|d
init|=
name|data
operator|->
name|createCompatiblePlatformPixmap
argument_list|()
decl_stmt|;
name|d
operator|->
name|copy
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap::scroll(int dx, int dy, int x, int y, int width, int height, QRegion *exposed)     \since 4.6      This convenience function is equivalent to calling QPixmap::scroll(\a dx,     \a dy, QRect(\a x, \a y, \a width, \a height), \a exposed).      \sa QWidget::scroll(), QGraphicsItem::scroll() */
end_comment
begin_comment
comment|/*!     \since 4.6      Scrolls the area \a rect of this pixmap by (\a dx, \a dy). The exposed     region is left unchanged. You can optionally pass a pointer to an empty     QRegion to get the region that is \a exposed by the scroll operation.      \snippet code/src_gui_image_qpixmap.cpp 2      You cannot scroll while there is an active painter on the pixmap.      \sa QWidget::scroll(), QGraphicsItem::scroll() */
end_comment
begin_function
DECL|function|scroll
name|void
name|QPixmap
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|QRegion
modifier|*
name|exposed
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|)
condition|)
return|return;
name|QRect
name|dest
init|=
name|rect
operator|&
name|this
operator|->
name|rect
argument_list|()
decl_stmt|;
name|QRect
name|src
init|=
name|dest
operator|.
name|translated
argument_list|(
operator|-
name|dx
argument_list|,
operator|-
name|dy
argument_list|)
operator|&
name|dest
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|exposed
condition|)
operator|*
name|exposed
operator|+=
name|dest
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|src
argument_list|)
condition|)
block|{
comment|// Fallback
name|QPixmap
name|pix
init|=
operator|*
name|this
decl_stmt|;
name|QPainter
name|painter
argument_list|(
operator|&
name|pix
argument_list|)
decl_stmt|;
name|painter
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawPixmap
argument_list|(
name|src
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|,
operator|*
name|this
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|painter
operator|.
name|end
argument_list|()
expr_stmt|;
operator|*
name|this
operator|=
name|pix
expr_stmt|;
block|}
if|if
condition|(
name|exposed
condition|)
block|{
operator|*
name|exposed
operator|+=
name|dest
expr_stmt|;
operator|*
name|exposed
operator|-=
name|src
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Assigns the given \a pixmap to this pixmap and returns a reference     to this pixmap.      \sa copy(), QPixmap() */
end_comment
begin_function
DECL|function|operator =
name|QPixmap
modifier|&
name|QPixmap
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::operator=: Cannot assign to pixmap during painting"
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
if|if
condition|(
name|pixmap
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// make a deep copy
name|pixmap
operator|.
name|copy
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|pixmap
operator|.
name|data
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPixmap::swap(QPixmap&other)     \since 4.8      Swaps pixmap \a other with this pixmap. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!    Returns the pixmap as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QPixmap
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Pixmap
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::operator!() const      Returns true if this is a null pixmap; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     Converts the pixmap to a QImage. Returns a null image if the     conversion fails.      If the pixmap has 1-bit depth, the returned image will also be 1     bit deep. Images with more bits will be returned in a format     closely represents the underlying system. Usually this will be     QImage::Format_ARGB32_Premultiplied for pixmaps with an alpha and     QImage::Format_RGB32 or QImage::Format_RGB16 for pixmaps without     alpha.      Note that for the moment, alpha masks on monochrome images are     ignored.      \sa fromImage(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QPixmap
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QImage
argument_list|()
return|;
return|return
name|data
operator|->
name|toImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix QPixmap::trueMatrix(const QTransform&matrix, int width, int height)      Returns the actual matrix used for transforming a pixmap with the     given \a width, \a height and \a matrix.      When transforming a pixmap using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     pixmap containing all transformed points of the original     pixmap. This function returns the modified matrix, which maps     points correctly from the original pixmap into the new pixmap.      \sa transformed(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QTransform
name|QPixmap
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|QImage
operator|::
name|trueMatrix
argument_list|(
name|m
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload    This convenience function loads the matrix \a m into a   QTransform and calls the overloaded function with the   QTransform and the width \a w and the height \a h.  */
end_comment
begin_function
DECL|function|trueMatrix
name|QMatrix
name|QPixmap
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|trueMatrix
argument_list|(
name|QTransform
argument_list|(
name|m
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::isQBitmap() const      Returns true if this is a QBitmap; otherwise returns false. */
end_comment
begin_function
DECL|function|isQBitmap
name|bool
name|QPixmap
operator|::
name|isQBitmap
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|->
name|type
operator|==
name|QPlatformPixmap
operator|::
name|BitmapType
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::isNull() const      Returns true if this is a null pixmap; otherwise returns false.      A null pixmap has zero width, zero height and no contents. You     cannot draw in a null pixmap. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QPixmap
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|data
operator|||
name|data
operator|->
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::width() const      Returns the width of the pixmap.      \sa size(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|width
name|int
name|QPixmap
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|width
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::height() const      Returns the height of the pixmap.      \sa size(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|height
name|int
name|QPixmap
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|height
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QPixmap::size() const      Returns the size of the pixmap.      \sa width(), height(), {QPixmap#Pixmap Information}{Pixmap     Information} */
end_comment
begin_function
DECL|function|size
name|QSize
name|QPixmap
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|QSize
argument_list|(
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QPixmap::rect() const      Returns the pixmap's enclosing rectangle.      \sa {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|rect
name|QRect
name|QPixmap
operator|::
name|rect
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
else|:
name|QRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::depth() const      Returns the depth of the pixmap.      The pixmap depth is also called bits per pixel (bpp) or bit planes     of a pixmap. A null pixmap has depth 0.      \sa defaultDepth(), {QPixmap#Pixmap Information}{Pixmap     Information} */
end_comment
begin_function
DECL|function|depth
name|int
name|QPixmap
operator|::
name|depth
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|depth
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets a mask bitmap.      This function merges the \a mask with the pixmap's alpha channel. A pixel     value of 1 on the mask means the pixmap's pixel is unchanged; a value of 0     means the pixel is transparent. The mask must have the same size as this     pixmap.      Setting a null mask resets the mask, leaving the previously transparent     pixels black. The effect of this function is undefined when the pixmap is     being painted on.      \warning This is potentially an expensive operation.      \sa mask(), {QPixmap#Pixmap Transformations}{Pixmap Transformations},     QBitmap */
end_comment
begin_function
DECL|function|setMask
name|void
name|QPixmap
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|mask
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setMask: Cannot set mask while pixmap is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mask
operator|.
name|isNull
argument_list|()
operator|&&
name|mask
operator|.
name|size
argument_list|()
operator|!=
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setMask() mask size differs from pixmap size"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QPixmap
operator|&
argument_list|>
argument_list|(
name|mask
argument_list|)
operator|.
name|data
operator|==
name|data
condition|)
comment|// trying to selfmask
return|return;
name|detach
argument_list|()
expr_stmt|;
name|QImage
name|image
init|=
name|data
operator|->
name|toImage
argument_list|()
decl_stmt|;
if|if
condition|(
name|mask
operator|.
name|size
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|!=
literal|1
condition|)
block|{
comment|// hw: ????
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|image
operator|.
name|depth
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
block|{
specifier|const
name|QImage
name|imageMask
init|=
name|mask
operator|.
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|mscan
init|=
name|imageMask
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|tscan
init|=
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|int
name|bytesPerLine
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytesPerLine
condition|;
operator|++
name|i
control|)
name|tscan
index|[
name|i
index|]
operator|&=
name|mscan
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
specifier|const
name|QImage
name|imageMask
init|=
name|mask
operator|.
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|mscan
init|=
name|imageMask
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|QRgb
modifier|*
name|tscan
init|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mscan
index|[
name|x
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
name|tscan
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the device pixel ratio for the pixmap. This is the     ratio between pixmap pixels and device-independent pixels.      Use this function when calculating layout geometry based on     the pixmap size: QSize layoutSize = image.size() / image.devicePixelRatio()      The default value is 1.0.      \sa setDevicePixelRatio() */
end_comment
begin_function
DECL|function|devicePixelRatio
name|qreal
name|QPixmap
operator|::
name|devicePixelRatio
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|qreal
argument_list|(
literal|1.0
argument_list|)
return|;
return|return
name|data
operator|->
name|devicePixelRatio
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the the device pixel ratio for the pixmap. This is the     ratio between image pixels and device-independent pixels.      The default value is 1.0. Setting it to something else has     two effects:      QPainters that are opened on the pixmap will be scaled. For     example, painting on a 200x200 image if with a ratio of 2.0     will result in effective (device-independent) painting bounds     of 100x100.      Code paths in Qt that calculate layout geometry based on the     pixmap size will take the ratio into account:     QSize layoutSize = pixmap.size() / pixmap.devicePixelRatio()     The net effect of this is that the pixmap is displayed as     high-dpi pixmap rather than a large pixmap.          \sa devicePixelRatio() */
end_comment
begin_function
DECL|function|setDevicePixelRatio
name|void
name|QPixmap
operator|::
name|setDevicePixelRatio
parameter_list|(
name|qreal
name|scaleFactor
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|data
operator|->
name|setDevicePixelRatio
argument_list|(
name|scaleFactor
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGE_HEURISTIC_MASK
end_ifndef
begin_comment
comment|/*!     Creates and returns a heuristic mask for this pixmap.      The function works by selecting a color from one of the corners     and then chipping away pixels of that color, starting at all the     edges.  If \a clipTight is true (the default) the mask is just     large enough to cover the pixels; otherwise, the mask is larger     than the data pixels.      The mask may not be perfect but it should be reasonable, so you     can do things such as the following:      \snippet code/src_gui_image_qpixmap.cpp 1      This function is slow because it involves converting to/from a     QImage, and non-trivial computations.      \sa QImage::createHeuristicMask(), createMaskFromColor() */
end_comment
begin_function
DECL|function|createHeuristicMask
name|QBitmap
name|QPixmap
operator|::
name|createHeuristicMask
parameter_list|(
name|bool
name|clipTight
parameter_list|)
specifier|const
block|{
name|QBitmap
name|m
init|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|toImage
argument_list|()
operator|.
name|createHeuristicMask
argument_list|(
name|clipTight
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Creates and returns a mask for this pixmap based on the given \a     maskColor. If the \a mode is Qt::MaskInColor, all pixels matching the     maskColor will be transparent. If \a mode is Qt::MaskOutColor, all pixels     matching the maskColor will be opaque.      This function is slow because it involves converting to/from a     QImage.      \sa createHeuristicMask(), QImage::createMaskFromColor() */
end_comment
begin_function
DECL|function|createMaskFromColor
name|QBitmap
name|QPixmap
operator|::
name|createMaskFromColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|maskColor
parameter_list|,
name|Qt
operator|::
name|MaskMode
name|mode
parameter_list|)
specifier|const
block|{
name|QImage
name|image
init|=
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
decl_stmt|;
return|return
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
operator|.
name|createMaskFromColor
argument_list|(
name|maskColor
operator|.
name|rgba
argument_list|()
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Loads a pixmap from the file with the given \a fileName. Returns     true if the pixmap was successfully loaded; otherwise invalidates     the pixmap and returns false.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed pixmaps and other resource files in the application's     executable.      If the data needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a flags to     control the conversion.      Note that QPixmaps are automatically added to the QPixmapCache     when loaded from a file; the key used is internal and can not     be acquired.      \sa loadFromData(), {QPixmap#Reading and Writing Image     Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|load
name|bool
name|QPixmap
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|data
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFileInfo
name|info
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QString
name|key
init|=
name|QLatin1String
argument_list|(
literal|"qt_pixmap"
argument_list|)
operator|%
name|info
operator|.
name|absoluteFilePath
argument_list|()
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|info
operator|.
name|lastModified
argument_list|()
operator|.
name|toTime_t
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|info
operator|.
name|size
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|data
condition|?
name|data
operator|->
name|pixelType
argument_list|()
else|:
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
comment|// Note: If no extension is provided, we try to match the
comment|// file against known plugin extensions
if|if
condition|(
operator|!
name|info
operator|.
name|completeSuffix
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|info
operator|.
name|exists
argument_list|()
condition|)
block|{
name|data
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
argument_list|,
name|this
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|data
condition|)
name|data
operator|=
name|QPlatformPixmap
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|fromFile
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|data
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::loadFromData(const uchar *data, uint len, const char *format, Qt::ImageConversionFlags flags)      Loads a pixmap from the \a len first bytes of the given binary \a     data.  Returns true if the pixmap was loaded successfully;     otherwise invalidates the pixmap and returns false.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      If the data needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a flags to     control the conversion.      \sa load(), {QPixmap#Reading and Writing Image Files}{Reading and     Writing Image Files} */
end_comment
begin_function
DECL|function|loadFromData
name|bool
name|QPixmap
operator|::
name|loadFromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|buf
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|data
condition|)
name|data
operator|=
name|QPlatformPixmap
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|fromData
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|true
return|;
name|data
operator|.
name|reset
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::loadFromData(const QByteArray&data, const char *format, Qt::ImageConversionFlags flags)      \overload      Loads a pixmap from the binary \a data using the specified \a     format and conversion \a flags. */
end_comment
begin_comment
comment|/*!     Saves the pixmap to the file with the given \a fileName using the     specified image file \a format and \a quality factor. Returns true     if successful; otherwise returns false.      The \a quality factor must be in the range [0,100] or -1. Specify     0 to obtain small compressed files, 100 for large uncompressed     files, and -1 to use the default settings.      If \a format is 0, an image format will be chosen from \a fileName's     suffix.      \sa {QPixmap#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_function
DECL|function|save
name|bool
name|QPixmap
operator|::
name|save
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|doImageIO
argument_list|(
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function writes a QPixmap to the given \a device using the     specified image file \a format and \a quality factor. This can be     used, for example, to save a pixmap directly into a QByteArray:      \snippet image/image.cpp 1 */
end_comment
begin_function
DECL|function|save
name|bool
name|QPixmap
operator|::
name|save
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|doImageIO
argument_list|(
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|doImageIO
name|bool
name|QPixmap
operator|::
name|doImageIO
parameter_list|(
name|QImageWriter
modifier|*
name|writer
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|quality
operator|>
literal|100
operator|||
name|quality
operator|<
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QPixmap::save: quality out of range [-1,100]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|>=
literal|0
condition|)
name|writer
operator|->
name|setQuality
argument_list|(
name|qMin
argument_list|(
name|quality
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|writer
operator|->
name|write
argument_list|(
name|toImage
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use QPainter or the fill(QColor) overload instead. */
end_comment
begin_function
DECL|function|fill
name|void
name|QPixmap
operator|::
name|fill
parameter_list|(
specifier|const
name|QPaintDevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|device
argument_list|)
name|Q_UNUSED
argument_list|(
argument|p
argument_list|)
name|qWarning
argument_list|(
literal|"%s is deprecated, ignored"
argument_list|,
name|Q_FUNC_INFO
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPixmap::fill(const QPaintDevice *device, int x, int y)     \obsolete      Use QPainter or the fill(QColor) overload instead. */
end_comment
begin_comment
comment|/*!     Fills the pixmap with the given \a color.      The effect of this function is undefined when the pixmap is     being painted on.      \sa {QPixmap#Pixmap Transformations}{Pixmap Transformations} */
end_comment
begin_function
DECL|function|fill
name|void
name|QPixmap
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
comment|// Some people are probably already calling fill while a painter is active, so to not break
comment|// their programs, only print a warning and return when the fill operation could cause a crash.
if|if
condition|(
name|paintingActive
argument_list|()
operator|&&
operator|(
name|color
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
operator|)
operator|&&
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::fill: Cannot fill while pixmap is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// detach() will also remove this pixmap from caches, so
comment|// it has to be called even when ref == 1.
name|detach
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Don't bother to make a copy of the data object, since
comment|// it will be filled with new pixel data anyway.
name|QPlatformPixmap
modifier|*
name|d
init|=
name|data
operator|->
name|createCompatiblePlatformPixmap
argument_list|()
decl_stmt|;
name|d
operator|->
name|resize
argument_list|(
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|=
name|d
expr_stmt|;
block|}
name|data
operator|->
name|fill
argument_list|(
name|color
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn int QPixmap::serialNumber() const     \obsolete     Returns a number that identifies the contents of this QPixmap     object. Distinct QPixmap objects can only have the same serial     number if they refer to the same contents (but they don't have     to).      Use cacheKey() instead.      \warning The serial number doesn't necessarily change when     the pixmap is altered. This means that it may be dangerous to use     it as a cache key. For caching pixmaps, we recommend using the     QPixmapCache class whenever possible. */
end_comment
begin_comment
comment|/*!     Returns a number that identifies this QPixmap. Distinct QPixmap     objects can only have the same cache key if they refer to the same     contents.      The cacheKey() will change when the pixmap is altered. */
end_comment
begin_function
DECL|function|cacheKey
name|qint64
name|QPixmap
operator|::
name|cacheKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|cacheKey
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void sendResizeEvents(QWidget *target) {     QResizeEvent e(target->size(), QSize());     QApplication::sendEvent(target,&e);      const QObjectList children = target->children();     for (int i = 0; i< children.size(); ++i) {         QWidget *child = static_cast<QWidget*>(children.at(i));         if (child->isWidgetType()&& !child->isWindow()&& child->testAttribute(Qt::WA_PendingResizeEvent))             sendResizeEvents(child);     } }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \obsolete      Use QWidget::grab() instead. */
end_comment
begin_function
DECL|function|grabWidget
name|QPixmap
name|QPixmap
operator|::
name|grabWidget
parameter_list|(
name|QObject
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rectangle
parameter_list|)
block|{
name|QPixmap
name|pixmap
decl_stmt|;
name|qWarning
argument_list|(
literal|"QPixmap::grabWidget is deprecated, use QWidget::grab() instead"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|pixmap
return|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|widget
argument_list|,
literal|"grab"
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|,
name|Q_RETURN_ARG
argument_list|(
name|QPixmap
argument_list|,
name|pixmap
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QRect
argument_list|,
name|rectangle
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pixmap
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::grabWidget(QObject *widget, int x, int y, int w, int h)     \obsolete      Use QWidget::grab() instead. */
end_comment
begin_comment
comment|/*****************************************************************************   QPixmap stream functions  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
end_if
begin_comment
comment|/*!     \relates QPixmap      Writes the given \a pixmap to the given \a stream as a PNG     image. Note that writing the stream to a file will not produce a     valid image file.      \sa QPixmap::save(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
return|return
name|stream
operator|<<
name|pixmap
operator|.
name|toImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QPixmap      Reads an image from the given \a stream into the given \a pixmap.      \sa QPixmap::load(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|QImage
name|image
decl_stmt|;
name|stream
operator|>>
name|image
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pixmap
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|pixmap
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pixmap
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QPixmap
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|&&
name|data
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces this pixmap's data with the given \a image using the     specified \a flags to control the conversion.  The \a flags     argument is a bitwise-OR of the \l{Qt::ImageConversionFlags}.     Passing 0 for \a flags sets all the default options. Returns true     if the result is that this pixmap is not null.      Note: this function was part of Qt 3 support in Qt 4.6 and earlier.     It has been promoted to official API status in 4.7 to support updating     the pixmap's image without creating a new QPixmap as fromImage() would.      \sa fromImage()     \since 4.7 */
end_comment
begin_function
DECL|function|convertFromImage
name|bool
name|QPixmap
operator|::
name|convertFromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|data
condition|)
operator|*
name|this
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaled(int width, int height,     Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode     transformMode) const      \overload      Returns a copy of the pixmap scaled to a rectangle with the given     \a width and \a height according to the given \a aspectRatioMode and     \a transformMode.      If either the \a width or the \a height is zero or negative, this     function returns a null pixmap. */
end_comment
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaled(const QSize&size, Qt::AspectRatioMode     aspectRatioMode, Qt::TransformationMode transformMode) const      Scales the pixmap to the given \a size, using the aspect ratio and     transformation modes specified by \a aspectRatioMode and \a     transformMode.      \image qimage-scaling.png      \list     \li If \a aspectRatioMode is Qt::IgnoreAspectRatio, the pixmap        is scaled to \a size.     \li If \a aspectRatioMode is Qt::KeepAspectRatio, the pixmap is        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.     \li If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,        the pixmap is scaled to a rectangle as small as possible        outside \a size, preserving the aspect ratio.     \endlist      If the given \a size is empty, this function returns a null     pixmap.       In some cases it can be more beneficial to draw the pixmap to a     painter with a scale set rather than scaling the pixmap. This is     the case when the painter is for instance based on OpenGL or when     the scale factor changes rapidly.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations}  */
end_comment
begin_function
DECL|function|scaled
name|QPixmap
name|QPixmap
operator|::
name|scaled
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectMode
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaled: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QSize
name|newSize
init|=
name|size
argument_list|()
decl_stmt|;
name|newSize
operator|.
name|scale
argument_list|(
name|s
argument_list|,
name|aspectMode
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rwidth
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|width
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newSize
operator|.
name|rheight
argument_list|()
operator|=
name|qMax
argument_list|(
name|newSize
operator|.
name|height
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newSize
operator|==
name|size
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|()
argument_list|,
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|height
argument_list|()
operator|/
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QPixmap
name|pix
init|=
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
decl_stmt|;
return|return
name|pix
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaledToWidth(int width, Qt::TransformationMode     mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a width using the specified transformation \a mode.     The height of the pixmap is automatically calculated so that the     aspect ratio of the pixmap is preserved.      If \a width is 0 or negative, a null pixmap is returned.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|scaledToWidth
name|QPixmap
name|QPixmap
operator|::
name|scaledToWidth
parameter_list|(
name|int
name|w
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaleWidth: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|copy
argument_list|()
return|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|w
operator|/
name|width
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaledToHeight(int height,     Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a height using the specified transformation \a mode.     The width of the pixmap is automatically calculated so that the     aspect ratio of the pixmap is preserved.      If \a height is 0 or negative, a null pixmap is returned.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|scaledToHeight
name|QPixmap
name|QPixmap
operator|::
name|scaledToHeight
parameter_list|(
name|int
name|h
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaleHeight: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|copy
argument_list|()
return|;
block|}
if|if
condition|(
name|h
operator|<=
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|h
operator|/
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the pixmap that is transformed using the given     transformation \a transform and transformation \a mode. The original     pixmap is not changed.      The transformation \a transform is internally adjusted to compensate     for unwanted translation; i.e. the pixmap produced is the smallest     pixmap that contains all the transformed points of the original     pixmap. Use the trueMatrix() function to retrieve the actual     matrix used for transforming the pixmap.      This function is slow because it involves transformation to a     QImage, non-trivial computations and a transformation back to a     QPixmap.      \sa trueMatrix(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QPixmap
name|QPixmap
operator|::
name|transformed
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|transform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
return|return
operator|*
name|this
return|;
return|return
name|data
operator|->
name|transformed
argument_list|(
name|transform
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload    This convenience function loads the \a matrix into a   QTransform and calls the overloaded function.  */
end_comment
begin_function
DECL|function|transformed
name|QPixmap
name|QPixmap
operator|::
name|transformed
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
return|return
name|transformed
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QPixmap     \inmodule QtGui      \brief The QPixmap class is an off-screen image representation     that can be used as a paint device.      \ingroup painting     \ingroup shared       Qt provides four classes for handling image data: QImage, QPixmap,     QBitmap and QPicture. QImage is designed and optimized for I/O,     and for direct pixel access and manipulation, while QPixmap is     designed and optimized for showing images on screen. QBitmap is     only a convenience class that inherits QPixmap, ensuring a depth     of 1. The isQBitmap() function returns true if a QPixmap object is     really a bitmap, otherwise returns false. Finally, the QPicture class     is a paint device that records and replays QPainter commands.      A QPixmap can easily be displayed on the screen using QLabel or     one of QAbstractButton's subclasses (such as QPushButton and     QToolButton). QLabel has a pixmap property, whereas     QAbstractButton has an icon property.      QPixmap objects can be passed around by value since the QPixmap     class uses implicit data sharing. For more information, see the \l     {Implicit Data Sharing} documentation. QPixmap objects can also be     streamed.      Note that the pixel data in a pixmap is internal and is managed by     the underlying window system. Because QPixmap is a QPaintDevice     subclass, QPainter can be used to draw directly onto pixmaps.     Pixels can only be accessed through QPainter functions or by     converting the QPixmap to a QImage. However, the fill() function     is available for initializing the entire pixmap with a given color.      There are functions to convert between QImage and     QPixmap. Typically, the QImage class is used to load an image     file, optionally manipulating the image data, before the QImage     object is converted into a QPixmap to be shown on     screen. Alternatively, if no manipulation is desired, the image     file can be loaded directly into a QPixmap. On Windows, the     QPixmap class also supports conversion between \c HBITMAP and     QPixmap.      QPixmap provides a collection of functions that can be used to     obtain a variety of information about the pixmap. In addition,     there are several functions that enables transformation of the     pixmap.      \tableofcontents      \section1 Reading and Writing Image Files      QPixmap provides several ways of reading an image file: The file     can be loaded when constructing the QPixmap object, or by using     the load() or loadFromData() functions later on. When loading an     image, the file name can either refer to an actual file on disk or     to one of the application's embedded resources. See \l{The Qt     Resource System} overview for details on how to embed images and     other resource files in the application's executable.      Simply call the save() function to save a QPixmap object.      The complete list of supported file formats are available through     the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions. New file formats     can be added as plugins. By default, Qt supports the following     formats:      \table     \header \li Format \li Description                      \li Qt's support     \row    \li BMP    \li Windows Bitmap                   \li Read/write     \row    \li GIF    \li Graphic Interchange Format (optional) \li Read     \row    \li JPG    \li Joint Photographic Experts Group \li Read/write     \row    \li JPEG   \li Joint Photographic Experts Group \li Read/write     \row    \li PNG    \li Portable Network Graphics        \li Read/write     \row    \li PBM    \li Portable Bitmap                  \li Read     \row    \li PGM    \li Portable Graymap                 \li Read     \row    \li PPM    \li Portable Pixmap                  \li Read/write     \row    \li XBM    \li X11 Bitmap                       \li Read/write     \row    \li XPM    \li X11 Pixmap                       \li Read/write     \endtable      \section1 Pixmap Information      QPixmap provides a collection of functions that can be used to     obtain a variety of information about the pixmap:      \table     \header     \li \li Available Functions     \row     \li Geometry     \li     The size(), width() and height() functions provide information     about the pixmap's size. The rect() function returns the image's     enclosing rectangle.      \row     \li Alpha component     \li      The hasAlphaChannel() returns true if the pixmap has a format that     respects the alpha channel, otherwise returns false. The hasAlpha(),     setMask() and mask() functions are legacy and should not be used.     They are potentially very slow.      The createHeuristicMask() function creates and returns a 1-bpp     heuristic mask (i.e. a QBitmap) for this pixmap. It works by     selecting a color from one of the corners and then chipping away     pixels of that color, starting at all the edges. The     createMaskFromColor() function creates and returns a mask (i.e. a     QBitmap) for the pixmap based on a given color.      \row     \li Low-level information     \li      The depth() function returns the depth of the pixmap. The     defaultDepth() function returns the default depth, i.e. the depth     used by the application on the given screen.      The cacheKey() function returns a number that uniquely     identifies the contents of the QPixmap object.      The x11Info() function returns information about the configuration     of the X display used by the screen to which the pixmap currently     belongs. The x11PictureHandle() function returns the X11 Picture     handle of the pixmap for XRender support. Note that the two latter     functions are only available on x11.      \endtable      \section1 Pixmap Conversion      A QPixmap object can be converted into a QImage using the     toImage() function. Likewise, a QImage can be converted into a     QPixmap using the fromImage(). If this is too expensive an     operation, you can use QBitmap::fromImage() instead.      In addition, on Windows, the QPixmap class supports conversion to     and from HBITMAP: the toWinHBITMAP() function creates a HBITMAP     equivalent to the QPixmap, based on the given HBitmapFormat, and     returns the HBITMAP handle. The fromWinHBITMAP() function returns     a QPixmap that is equivalent to the given bitmap which has the     specified format. The QPixmap class also supports conversion to     and from HICON: the toWinHICON() function creates a HICON equivalent     to the QPixmap, and returns the HICON handle. The fromWinHICON()     function returns a QPixmap that is equivalent to the given icon.      \section1 Pixmap Transformations      QPixmap supports a number of functions for creating a new pixmap     that is a transformed version of the original:      The scaled(), scaledToWidth() and scaledToHeight() functions     return scaled copies of the pixmap, while the copy() function     creates a QPixmap that is a plain copy of the original one.      The transformed() function returns a copy of the pixmap that is     transformed with the given transformation matrix and     transformation mode: Internally, the transformation matrix is     adjusted to compensate for unwanted translation,     i.e. transformed() returns the smallest pixmap containing all     transformed points of the original pixmap. The static trueMatrix()     function returns the actual matrix used for transforming the     pixmap.      \note When using the native X11 graphics system, the pixmap     becomes invalid when the QApplication instance is destroyed.      \sa QBitmap, QImage, QImageReader, QImageWriter */
end_comment
begin_comment
comment|/*!     \typedef QPixmap::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QPixmap::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     Returns true if this pixmap has an alpha channel, \e or has a     mask, otherwise returns false.      \sa hasAlphaChannel(), mask() */
end_comment
begin_function
DECL|function|hasAlpha
name|bool
name|QPixmap
operator|::
name|hasAlpha
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|&&
name|data
operator|->
name|hasAlphaChannel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the pixmap has a format that respects the alpha     channel, otherwise returns false.      \sa hasAlpha() */
end_comment
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QPixmap
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|&&
name|data
operator|->
name|hasAlphaChannel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|metric
name|int
name|QPixmap
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|metric
argument_list|(
name|metric
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QPixmap
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|paintEngine
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QBitmap QPixmap::mask() const      Extracts a bitmap mask from the pixmap's alpha channel.      \warning This is potentially an expensive operation. The mask of     the pixmap is extracted dynamically from the pixeldata.      \sa setMask(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|mask
name|QBitmap
name|QPixmap
operator|::
name|mask
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
return|return
name|QBitmap
argument_list|()
return|;
specifier|const
name|QImage
name|img
init|=
name|toImage
argument_list|()
decl_stmt|;
specifier|const
name|QImage
name|image
init|=
operator|(
name|img
operator|.
name|depth
argument_list|()
operator|<
literal|32
condition|?
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
else|:
name|img
operator|)
decl_stmt|;
specifier|const
name|int
name|w
init|=
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
specifier|const
name|int
name|h
init|=
name|image
operator|.
name|height
argument_list|()
decl_stmt|;
name|QImage
name|mask
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
operator|.
name|isNull
argument_list|()
condition|)
comment|// allocation failed
return|return
name|QBitmap
argument_list|()
return|;
name|mask
operator|.
name|setColorCount
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mask
operator|.
name|setColor
argument_list|(
literal|0
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color0
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
name|mask
operator|.
name|setColor
argument_list|(
literal|1
argument_list|,
name|QColor
argument_list|(
name|Qt
operator|::
name|color1
argument_list|)
operator|.
name|rgba
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|int
name|bpl
init|=
name|mask
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|QRgb
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QRgb
operator|*
argument_list|>
argument_list|(
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|dest
init|=
name|mask
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|w
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|qAlpha
argument_list|(
operator|*
name|src
argument_list|)
operator|>
literal|0
condition|)
name|dest
index|[
name|x
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
block|}
return|return
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|mask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the default pixmap depth used by the application.      On all platforms the depth of the primary screen will be returned.      \sa depth(), QColormap::depth(), {QPixmap#Pixmap Information}{Pixmap Information}  */
end_comment
begin_function
DECL|function|defaultDepth
name|int
name|QPixmap
operator|::
name|defaultDepth
parameter_list|()
block|{
return|return
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
operator|->
name|depth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Detaches the pixmap from shared pixmap data.      A pixmap is automatically detached by Qt whenever its contents are     about to change. This is done in almost all QPixmap member     functions that modify the pixmap (fill(), fromImage(),     load(), etc.), and in QPainter::begin() on a pixmap.      There are two exceptions in which detach() must be called     explicitly, that is when calling the handle() or the     x11PictureHandle() function (only available on X11). Otherwise,     any modifications done using system calls, will be performed on     the shared data.      The detach() function returns immediately if there is just a     single reference or if the pixmap has not been initialized yet. */
end_comment
begin_function
DECL|function|detach
name|void
name|QPixmap
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return;
comment|// QPixmap.data member may be QRuntimePlatformPixmap so use handle() function to get
comment|// the actual underlaying runtime pixmap data.
name|QPlatformPixmap
modifier|*
name|pd
init|=
name|handle
argument_list|()
decl_stmt|;
name|QPlatformPixmap
operator|::
name|ClassId
name|id
init|=
name|pd
operator|->
name|classId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|QPlatformPixmap
operator|::
name|RasterClass
condition|)
block|{
name|QRasterPlatformPixmap
modifier|*
name|rasterData
init|=
cast|static_cast
argument_list|<
name|QRasterPlatformPixmap
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|rasterData
operator|->
name|image
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|is_cached
operator|&&
name|data
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executePlatformPixmapModificationHooks
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
operator|*
name|this
operator|=
name|copy
argument_list|()
expr_stmt|;
block|}
operator|++
name|data
operator|->
name|detach_no
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::fromImage(const QImage&image, Qt::ImageConversionFlags flags)      Converts the given \a image to a pixmap using the specified \a     flags to control the conversion.  The \a flags argument is a     bitwise-OR of the \l{Qt::ImageConversionFlags}. Passing 0 for \a     flags sets all the default options.      In case of monochrome and 8-bit images, the image is first     converted to a 32-bit pixmap and then filled with the colors in     the color table. If this is too expensive an operation, you can     use QBitmap::fromImage() instead.      \sa fromImageReader(), toImage(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromImage
name|QPixmap
name|QPixmap
operator|::
name|fromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QScopedPointer
argument_list|<
name|QPlatformPixmap
argument_list|>
name|data
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformPixmap
argument_list|(
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::fromImageReader(QImageReader *imageReader, Qt::ImageConversionFlags flags)      Create a QPixmap from an image read directly from an \a imageReader.     The \a flags argument is a bitwise-OR of the \l{Qt::ImageConversionFlags}.     Passing 0 for \a flags sets all the default options.      On some systems, reading an image directly to QPixmap can use less memory than     reading a QImage to convert it to QPixmap.      \sa fromImage(), toImage(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromImageReader
name|QPixmap
name|QPixmap
operator|::
name|fromImageReader
parameter_list|(
name|QImageReader
modifier|*
name|imageReader
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|QScopedPointer
argument_list|<
name|QPlatformPixmap
argument_list|>
name|data
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|createPlatformPixmap
argument_list|(
name|QPlatformPixmap
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromImageReader
argument_list|(
name|imageReader
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::grabWindow(WId window, int x, int y, int     width, int height)      Creates and returns a pixmap constructed by grabbing the contents     of the given \a window restricted by QRect(\a x, \a y, \a width,     \a height).      The arguments (\a{x}, \a{y}) specify the offset in the window,     whereas (\a{width}, \a{height}) specify the area to be copied.  If     \a width is negative, the function copies everything to the right     border of the window. If \a height is negative, the function     copies everything to the bottom of the window.      The window system identifier (\c WId) can be retrieved using the     QWidget::winId() function. The rationale for using a window     identifier and not a QWidget, is to enable grabbing of windows     that are not part of the application, window system frames, and so     on.      The grabWindow() function grabs pixels from the screen, not from     the window, i.e. if there is another window partially or entirely     over the one you grab, you get pixels from the overlying window,     too. The mouse cursor is generally not grabbed.      Note on X11 that if the given \a window doesn't have the same depth     as the root window, and another window partially or entirely     obscures the one you grab, you will \e not get pixels from the     overlying window.  The contents of the obscured areas in the     pixmap will be undefined and uninitialized.      On Windows Vista and above grabbing a layered window, which is     created by setting the Qt::WA_TranslucentBackground attribute, will     not work. Instead grabbing the desktop widget should work.      \warning In general, grabbing an area outside the screen is not     safe. This depends on the underlying window system.      \warning The function is deprecated in Qt 5.0 since there might be     platform plugins in which window system identifiers (\c WId)     are local to a screen. Use QScreen::grabWindow() instead.      \sa grabWidget(), {Screenshot Example}     \sa QScreen     \deprecated */
end_comment
begin_function
DECL|function|grabWindow
name|QPixmap
name|QPixmap
operator|::
name|grabWindow
parameter_list|(
name|WId
name|window
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|qWarning
argument_list|(
literal|"%s is deprecated, use QScreen::grabWindow() instead."
literal|" Defaulting to primary screen."
argument_list|,
name|Q_FUNC_INFO
argument_list|)
expr_stmt|;
return|return
name|QGuiApplication
operator|::
name|primaryScreen
argument_list|()
operator|->
name|grabWindow
argument_list|(
name|window
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|handle
name|QPlatformPixmap
modifier|*
name|QPixmap
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|r
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QPixmap("
operator|<<
name|r
operator|.
name|size
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QPixmap QPixmap::alphaChannel() const      Most use cases for this can be achieved using a QPainter and QPainter::CompositionMode instead. */
end_comment
begin_comment
comment|/*!     \fn void QPixmap::setAlphaChannel(const QPixmap&p)      Most use cases for this can be achieved using \a p with QPainter and QPainter::CompositionMode instead. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
