begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapdata_p.h"
end_include
begin_include
include|#
directive|include
file|"qimagepixmapcleanuphooks_p.h"
end_include
begin_include
include|#
directive|include
file|"qbitmap.h"
end_include
begin_include
include|#
directive|include
file|"qcolormap.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qwidget.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"qapplication.h"
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicssystem_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwidget_p.h>
end_include
begin_include
include|#
directive|include
file|"qevent.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapcache.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qimagereader.h"
end_include
begin_include
include|#
directive|include
file|"qimagewriter.h"
end_include
begin_include
include|#
directive|include
file|"qpaintengine.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"private/qt_mac_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qpixmap_mac_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_WS_QPA
end_ifdef
begin_include
include|#
directive|include
file|"qplatformintegration_qpa.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qx11info_x11.h"
end_include
begin_include
include|#
directive|include
file|<private/qt_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_x11_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qt_s60_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qpixmap_raster_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qhexstring_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|// ### Qt 5: remove
DECL|function|qt_pixmap_id
name|Q_GUI_EXPORT
name|qint64
name|qt_pixmap_id
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
return|return
name|pixmap
operator|.
name|cacheKey
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qt_pixmap_thread_test
specifier|static
name|bool
name|qt_pixmap_thread_test
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qApp
condition|)
block|{
name|qFatal
argument_list|(
literal|"QPixmap: Must construct a QApplication before a QPaintDevice"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|qApp
operator|->
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|bool
name|fail
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
operator|!
name|QApplication
operator|::
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_X11InitThreads
argument_list|)
condition|)
name|fail
operator|=
literal|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
if|if
condition|(
operator|!
name|QApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|->
name|hasCapability
argument_list|(
name|QPlatformIntegration
operator|::
name|ThreadedPixmaps
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Lighthouse plugin does not support threaded pixmaps!\n"
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|true
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|QApplicationPrivate
operator|::
name|graphics_system_name
operator|!=
name|QLatin1String
argument_list|(
literal|"raster"
argument_list|)
condition|)
name|fail
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fail
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap: It is not safe to use pixmaps outside the GUI thread"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QPixmap
operator|::
name|init
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|init
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|int
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
specifier|extern
name|QApplication
operator|::
name|Type
name|qt_appType
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|init
name|void
name|QPixmap
operator|::
name|init
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|qt_appType
operator|==
name|QApplication
operator|::
name|Tty
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap: Cannot create a QPixmap when no GUI is being used"
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
operator|)
operator|||
name|type
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
name|data
operator|=
name|QPixmapData
operator|::
name|create
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|QPixmapData
operator|::
name|PixelType
operator|)
name|type
argument_list|)
expr_stmt|;
else|else
name|data
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QPixmap::ColorMode      \compat      This enum type defines the color modes that exist for converting     QImage objects to QPixmap.  It is provided here for compatibility     with earlier versions of Qt.      Use Qt::ImageConversionFlags instead.      \value Auto  Select \c Color or \c Mono on a case-by-case basis.     \value Color Always create colored pixmaps.     \value Mono  Always create bitmaps. */
end_comment
begin_comment
comment|/*!     Constructs a null pixmap.      \sa isNull() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|()
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
operator|(
name|void
operator|)
name|qt_pixmap_thread_test
argument_list|()
expr_stmt|;
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QPixmap::QPixmap(int width, int height)      Constructs a pixmap with the given \a width and \a height. If     either \a width or \a height is zero, a null pixmap is     constructed.      \warning This will create a QPixmap with uninitialized data. Call     fill() to fill the pixmap with an appropriate color before drawing     onto it with QPainter.      \sa isNull() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
else|else
name|init
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \overload      Constructs a pixmap of the given \a size.      \warning This will create a QPixmap with uninitialized data. Call     fill() to fill the pixmap with an appropriate color before drawing     onto it with QPainter. */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
else|else
name|init
argument_list|(
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|init
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
cast|static_cast
argument_list|<
name|QPixmapData
operator|::
name|PixelType
argument_list|>
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|init
argument_list|(
name|s
operator|.
name|width
argument_list|()
argument_list|,
name|s
operator|.
name|height
argument_list|()
argument_list|,
cast|static_cast
argument_list|<
name|QPixmapData
operator|::
name|PixelType
argument_list|>
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
name|QPixmapData
modifier|*
name|d
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
member_init_list|,
name|data
argument_list|(
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a pixmap from the file with the given \a fileName. If the     file does not exist or is of an unknown format, the pixmap becomes a     null pixmap.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to     one of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how     to embed images and other resource files in the application's     executable.      If the image needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a     flags to control the conversion.      The \a fileName, \a format and \a flags parameters are     passed on to load(). This means that the data in \a fileName is     not compiled into the binary. If \a fileName contains a relative     path (e.g. the filename only) the relevant file must be found     relative to the runtime working directory.      \sa {QPixmap#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
return|return;
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a pixmap that is a copy of the given \a pixmap.      \sa copy() */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
block|{
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pixmap
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// make a deep copy
name|operator
name|=
argument_list|(
name|pixmap
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|pixmap
operator|.
name|data
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a pixmap from the given \a xpm data, which must be a     valid XPM image.      Errors are silently ignored.      Note that it's possible to squeeze the XPM variable a little bit     by using an unusual declaration:      \snippet doc/src/snippets/code/src_gui_image_qpixmap.cpp 0      The extra \c const makes the entire definition read-only, which is     slightly more efficient (for example, when the code is in a shared     library) and ROMable when the application is to be stored in ROM. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
end_ifndef
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|xpm
index|[]
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xpm
condition|)
return|return;
name|QImage
name|image
argument_list|(
name|xpm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
operator|*
name|this
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the pixmap. */
end_comment
begin_destructor
DECL|function|~QPixmap
name|QPixmap
operator|::
name|~
name|QPixmap
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|data
operator|||
name|data
operator|->
name|ref
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|// Catch if ref-counting changes again
block|}
end_destructor
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QPixmap
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Pixmap
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::copy(int x, int y, int width, int height) const     \overload      Returns a deep copy of the subset of the pixmap that is specified     by the rectangle QRect( \a x, \a y, \a width, \a height). */
end_comment
begin_comment
comment|/*!     \fn QPixmap QPixmap::copy(const QRect&rectangle) const      Returns a deep copy of the subset of the pixmap that is specified     by the given \a rectangle. For more information on deep copies,     see the \l {Implicit Data Sharing} documentation.      If the given \a rectangle is empty, the whole image is copied.      \sa operator=(), QPixmap(), {QPixmap#Pixmap     Transformations}{Pixmap Transformations} */
end_comment
begin_function
DECL|function|copy
name|QPixmap
name|QPixmap
operator|::
name|copy
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QRect
name|r
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|.
name|isEmpty
argument_list|()
condition|)
name|r
operator|=
name|r
operator|.
name|intersected
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|QPixmapData
modifier|*
name|d
init|=
name|data
operator|->
name|createCompatiblePixmapData
argument_list|()
decl_stmt|;
name|d
operator|->
name|copy
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap::scroll(int dx, int dy, int x, int y, int width, int height, QRegion *exposed)     \since 4.6      This convenience function is equivalent to calling QPixmap::scroll(\a dx,     \a dy, QRect(\a x, \a y, \a width, \a height), \a exposed).      \sa QWidget::scroll(), QGraphicsItem::scroll() */
end_comment
begin_comment
comment|/*!     \since 4.6      Scrolls the area \a rect of this pixmap by (\a dx, \a dy). The exposed     region is left unchanged. You can optionally pass a pointer to an empty     QRegion to get the region that is \a exposed by the scroll operation.      \snippet doc/src/snippets/code/src_gui_image_qpixmap.cpp 2      You cannot scroll while there is an active painter on the pixmap.      \sa QWidget::scroll(), QGraphicsItem::scroll() */
end_comment
begin_function
DECL|function|scroll
name|void
name|QPixmap
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|QRegion
modifier|*
name|exposed
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
operator|)
condition|)
return|return;
name|QRect
name|dest
init|=
name|rect
operator|&
name|this
operator|->
name|rect
argument_list|()
decl_stmt|;
name|QRect
name|src
init|=
name|dest
operator|.
name|translated
argument_list|(
operator|-
name|dx
argument_list|,
operator|-
name|dy
argument_list|)
operator|&
name|dest
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|exposed
condition|)
operator|*
name|exposed
operator|+=
name|dest
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|scroll
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|src
argument_list|)
condition|)
block|{
comment|// Fallback
name|QPixmap
name|pix
init|=
operator|*
name|this
decl_stmt|;
name|QPainter
name|painter
argument_list|(
operator|&
name|pix
argument_list|)
decl_stmt|;
name|painter
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawPixmap
argument_list|(
name|src
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|,
operator|*
name|this
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|painter
operator|.
name|end
argument_list|()
expr_stmt|;
operator|*
name|this
operator|=
name|pix
expr_stmt|;
block|}
if|if
condition|(
name|exposed
condition|)
block|{
operator|*
name|exposed
operator|+=
name|dest
expr_stmt|;
operator|*
name|exposed
operator|-=
name|src
operator|.
name|translated
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Assigns the given \a pixmap to this pixmap and returns a reference     to this pixmap.      \sa copy(), QPixmap() */
end_comment
begin_function
DECL|function|operator =
name|QPixmap
modifier|&
name|QPixmap
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::operator=: Cannot assign to pixmap during painting"
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
if|if
condition|(
name|pixmap
operator|.
name|paintingActive
argument_list|()
condition|)
block|{
comment|// make a deep copy
operator|*
name|this
operator|=
name|pixmap
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|pixmap
operator|.
name|data
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPixmap::swap(QPixmap&other)     \since 4.8      Swaps pixmap \a other with this pixmap. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!    Returns the pixmap as a QVariant. */
end_comment
begin_function
DECL|function|operator QVariant
name|QPixmap
operator|::
name|operator
name|QVariant
parameter_list|()
specifier|const
block|{
return|return
name|QVariant
argument_list|(
name|QVariant
operator|::
name|Pixmap
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::operator!() const      Returns true if this is a null pixmap; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     \fn QPixmap::operator QImage() const      Returns the pixmap as a QImage.      Use the toImage() function instead. */
end_comment
begin_comment
comment|/*!     Converts the pixmap to a QImage. Returns a null image if the     conversion fails.      If the pixmap has 1-bit depth, the returned image will also be 1     bit deep. Images with more bits will be returned in a format     closely represents the underlying system. Usually this will be     QImage::Format_ARGB32_Premultiplied for pixmaps with an alpha and     QImage::Format_RGB32 or QImage::Format_RGB16 for pixmaps without     alpha.      Note that for the moment, alpha masks on monochrome images are     ignored.      \sa fromImage(), {QImage#Image Formats}{Image Formats} */
end_comment
begin_function
DECL|function|toImage
name|QImage
name|QPixmap
operator|::
name|toImage
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QImage
argument_list|()
return|;
return|return
name|data
operator|->
name|toImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMatrix QPixmap::trueMatrix(const QTransform&matrix, int width, int height)      Returns the actual matrix used for transforming a pixmap with the     given \a width, \a height and \a matrix.      When transforming a pixmap using the transformed() function, the     transformation matrix is internally adjusted to compensate for     unwanted translation, i.e. transformed() returns the smallest     pixmap containing all transformed points of the original     pixmap. This function returns the modified matrix, which maps     points correctly from the original pixmap into the new pixmap.      \sa transformed(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|trueMatrix
name|QTransform
name|QPixmap
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|m
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|QImage
operator|::
name|trueMatrix
argument_list|(
name|m
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload    This convenience function loads the matrix \a m into a   QTransform and calls the overloaded function with the   QTransform and the width \a w and the height \a h.  */
end_comment
begin_function
DECL|function|trueMatrix
name|QMatrix
name|QPixmap
operator|::
name|trueMatrix
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|m
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|trueMatrix
argument_list|(
name|QTransform
argument_list|(
name|m
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
operator|.
name|toAffine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::isQBitmap() const      Returns true if this is a QBitmap; otherwise returns false. */
end_comment
begin_function
DECL|function|isQBitmap
name|bool
name|QPixmap
operator|::
name|isQBitmap
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|->
name|type
operator|==
name|QPixmapData
operator|::
name|BitmapType
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::isNull() const      Returns true if this is a null pixmap; otherwise returns false.      A null pixmap has zero width, zero height and no contents. You     cannot draw in a null pixmap. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QPixmap
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|data
operator|||
name|data
operator|->
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::width() const      Returns the width of the pixmap.      \sa size(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|width
name|int
name|QPixmap
operator|::
name|width
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|width
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::height() const      Returns the height of the pixmap.      \sa size(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|height
name|int
name|QPixmap
operator|::
name|height
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|height
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QPixmap::size() const      Returns the size of the pixmap.      \sa width(), height(), {QPixmap#Pixmap Information}{Pixmap     Information} */
end_comment
begin_function
DECL|function|size
name|QSize
name|QPixmap
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|QSize
argument_list|(
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
else|:
name|QSize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QPixmap::rect() const      Returns the pixmap's enclosing rectangle.      \sa {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|rect
name|QRect
name|QPixmap
operator|::
name|rect
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
else|:
name|QRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPixmap::depth() const      Returns the depth of the pixmap.      The pixmap depth is also called bits per pixel (bpp) or bit planes     of a pixmap. A null pixmap has depth 0.      \sa defaultDepth(), {QPixmap#Pixmap Information}{Pixmap     Information} */
end_comment
begin_function
DECL|function|depth
name|int
name|QPixmap
operator|::
name|depth
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|depth
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPixmap::resize(const QSize&size)     \overload     \compat      Use QPixmap::copy() instead to get the pixmap with the new size.      \oldcode         pixmap.resize(size);     \newcode         pixmap = pixmap.copy(QRect(QPoint(0, 0), size));     \endcode */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_function
DECL|function|resize_helper
name|void
name|QPixmap
operator|::
name|resize_helper
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
block|{
name|int
name|w
init|=
name|s
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|s
operator|.
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|1
operator|||
name|h
operator|<
literal|1
condition|)
block|{
operator|*
name|this
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
argument_list|()
operator|==
name|s
condition|)
return|return;
comment|// QPixmap.data member may be QRuntimePixmapData so use pixmapData() function to get
comment|// the actual underlaying runtime pixmap data.
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmapData
argument_list|()
decl_stmt|;
comment|// Create new pixmap
name|QPixmap
name|pm
argument_list|(
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
argument_list|,
name|pd
condition|?
name|pd
operator|->
name|type
else|:
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|bool
name|uninit
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
name|QX11PixmapData
modifier|*
name|x11Data
init|=
name|pd
operator|&&
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|?
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|x11Data
condition|)
block|{
name|pm
operator|.
name|x11SetScreen
argument_list|(
name|x11Data
operator|->
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
expr_stmt|;
name|uninit
operator|=
name|x11Data
operator|->
name|flags
operator|&
name|QX11PixmapData
operator|::
name|Uninitialized
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QMacPixmapData
modifier|*
name|macData
init|=
name|pd
operator|&&
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|MacClass
condition|?
cast|static_cast
argument_list|<
name|QMacPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|macData
condition|)
name|uninit
operator|=
name|macData
operator|->
name|uninit
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|uninit
operator|&&
operator|!
name|isNull
argument_list|()
condition|)
block|{
comment|// Copy old pixmap
if|if
condition|(
name|hasAlphaChannel
argument_list|()
condition|)
name|pm
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|pm
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|*
name|this
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qMin
argument_list|(
name|width
argument_list|()
argument_list|,
name|w
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|height
argument_list|()
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|x11Data
operator|&&
name|x11Data
operator|->
name|x11_mask
condition|)
block|{
name|QPixmapData
modifier|*
name|newPd
init|=
name|pm
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
name|QX11PixmapData
modifier|*
name|pmData
init|=
operator|(
name|newPd
operator|&&
name|newPd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
operator|)
condition|?
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|newPd
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|pmData
condition|)
block|{
name|pmData
operator|->
name|x11_mask
operator|=
operator|(
name|Qt
operator|::
name|HANDLE
operator|)
name|XCreatePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|RootWindow
argument_list|(
name|x11Data
operator|->
name|xinfo
operator|.
name|display
argument_list|()
argument_list|,
name|x11Data
operator|->
name|xinfo
operator|.
name|screen
argument_list|()
argument_list|)
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GC
name|gc
init|=
name|XCreateGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|pmData
operator|->
name|x11_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XCopyArea
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|x11Data
operator|->
name|x11_mask
argument_list|,
name|pmData
operator|->
name|x11_mask
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qMin
argument_list|(
name|width
argument_list|()
argument_list|,
name|w
argument_list|)
argument_list|,
name|qMin
argument_list|(
name|height
argument_list|()
argument_list|,
name|h
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|gc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
operator|*
name|this
operator|=
name|pm
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QPixmap::resize(int width, int height)     \compat      Use QPixmap::copy() instead to get the pixmap with the new size.      \oldcode         pixmap.resize(10, 20);     \newcode         pixmap = pixmap.copy(0, 0, 10, 20);     \endcode */
end_comment
begin_comment
comment|/*!     \fn bool QPixmap::selfMask() const     \compat      Returns whether the pixmap is its own mask or not.      This function is no longer relevant since the concept of self     masking doesn't exists anymore. */
end_comment
begin_comment
comment|/*!     Sets a mask bitmap.      This function merges the \a mask with the pixmap's alpha channel. A pixel     value of 1 on the mask means the pixmap's pixel is unchanged; a value of 0     means the pixel is transparent. The mask must have the same size as this     pixmap.      Setting a null mask resets the mask, leaving the previously transparent     pixels black. The effect of this function is undefined when the pixmap is     being painted on.      \warning This is potentially an expensive operation.      \sa mask(), {QPixmap#Pixmap Transformations}{Pixmap Transformations},     QBitmap */
end_comment
begin_function
DECL|function|setMask
name|void
name|QPixmap
operator|::
name|setMask
parameter_list|(
specifier|const
name|QBitmap
modifier|&
name|mask
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setMask: Cannot set mask while pixmap is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mask
operator|.
name|isNull
argument_list|()
operator|&&
name|mask
operator|.
name|size
argument_list|()
operator|!=
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setMask() mask size differs from pixmap size"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
cast|static_cast
argument_list|<
specifier|const
name|QPixmap
operator|&
argument_list|>
argument_list|(
name|mask
argument_list|)
operator|.
name|data
operator|==
name|data
condition|)
comment|// trying to selfmask
return|return;
name|detach
argument_list|()
expr_stmt|;
name|data
operator|->
name|setMask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGE_HEURISTIC_MASK
end_ifndef
begin_comment
comment|/*!     Creates and returns a heuristic mask for this pixmap.      The function works by selecting a color from one of the corners     and then chipping away pixels of that color, starting at all the     edges.  If \a clipTight is true (the default) the mask is just     large enough to cover the pixels; otherwise, the mask is larger     than the data pixels.      The mask may not be perfect but it should be reasonable, so you     can do things such as the following:      \snippet doc/src/snippets/code/src_gui_image_qpixmap.cpp 1      This function is slow because it involves converting to/from a     QImage, and non-trivial computations.      \sa QImage::createHeuristicMask(), createMaskFromColor() */
end_comment
begin_function
DECL|function|createHeuristicMask
name|QBitmap
name|QPixmap
operator|::
name|createHeuristicMask
parameter_list|(
name|bool
name|clipTight
parameter_list|)
specifier|const
block|{
name|QBitmap
name|m
init|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|toImage
argument_list|()
operator|.
name|createHeuristicMask
argument_list|(
name|clipTight
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Creates and returns a mask for this pixmap based on the given \a     maskColor. If the \a mode is Qt::MaskInColor, all pixels matching the     maskColor will be transparent. If \a mode is Qt::MaskOutColor, all pixels     matching the maskColor will be opaque.      This function is slow because it involves converting to/from a     QImage.      \sa createHeuristicMask(), QImage::createMaskFromColor() */
end_comment
begin_function
DECL|function|createMaskFromColor
name|QBitmap
name|QPixmap
operator|::
name|createMaskFromColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|maskColor
parameter_list|,
name|Qt
operator|::
name|MaskMode
name|mode
parameter_list|)
specifier|const
block|{
name|QImage
name|image
init|=
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
decl_stmt|;
return|return
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
operator|.
name|createMaskFromColor
argument_list|(
name|maskColor
operator|.
name|rgba
argument_list|()
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Creates and returns a mask for this pixmap based on the given \a     maskColor. Same as calling createMaskFromColor(maskColor,     Qt::MaskInColor)      \sa createHeuristicMask(), QImage::createMaskFromColor() */
end_comment
begin_function
DECL|function|createMaskFromColor
name|QBitmap
name|QPixmap
operator|::
name|createMaskFromColor
parameter_list|(
specifier|const
name|QColor
modifier|&
name|maskColor
parameter_list|)
specifier|const
block|{
return|return
name|createMaskFromColor
argument_list|(
name|maskColor
argument_list|,
name|Qt
operator|::
name|MaskInColor
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Loads a pixmap from the file with the given \a fileName. Returns     true if the pixmap was successfully loaded; otherwise returns     false.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      The file name can either refer to an actual file on disk or to one     of the application's embedded resources. See the     \l{resources.html}{Resource System} overview for details on how to     embed pixmaps and other resource files in the application's     executable.      If the data needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a flags to     control the conversion.      Note that QPixmaps are automatically added to the QPixmapCache     when loaded from a file; the key used is internal and can not     be acquired.      \sa loadFromData(), {QPixmap#Reading and Writing Image     Files}{Reading and Writing Image Files} */
end_comment
begin_function
DECL|function|load
name|bool
name|QPixmap
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QFileInfo
name|info
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QString
name|key
init|=
name|QLatin1Literal
argument_list|(
literal|"qt_pixmap"
argument_list|)
operator|%
name|info
operator|.
name|absoluteFilePath
argument_list|()
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|info
operator|.
name|lastModified
argument_list|()
operator|.
name|toTime_t
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|info
operator|.
name|size
argument_list|()
argument_list|)
operator|%
name|HexString
argument_list|<
name|uint
argument_list|>
argument_list|(
name|data
condition|?
name|data
operator|->
name|pixelType
argument_list|()
else|:
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
comment|// Note: If no extension is provided, we try to match the
comment|// file against known plugin extensions
if|if
condition|(
operator|!
name|info
operator|.
name|completeSuffix
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|info
operator|.
name|exists
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QPixmapCache
operator|::
name|find
argument_list|(
name|key
argument_list|,
operator|*
name|this
argument_list|)
condition|)
return|return
literal|true
return|;
name|QScopedPointer
argument_list|<
name|QPixmapData
argument_list|>
name|tmp
argument_list|(
name|QPixmapData
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|data
condition|?
name|data
operator|->
name|type
else|:
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|->
name|fromFile
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|data
operator|=
name|tmp
operator|.
name|take
argument_list|()
expr_stmt|;
name|QPixmapCache
operator|::
name|insert
argument_list|(
name|key
argument_list|,
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::loadFromData(const uchar *data, uint len, const char *format, Qt::ImageConversionFlags flags)      Loads a pixmap from the \a len first bytes of the given binary \a     data.  Returns true if the pixmap was loaded successfully;     otherwise returns false.      The loader attempts to read the pixmap using the specified \a     format. If the \a format is not specified (which is the default),     the loader probes the file for a header to guess the file format.      If the data needs to be modified to fit in a lower-resolution     result (e.g. converting from 32-bit to 8-bit), use the \a flags to     control the conversion.      \sa load(), {QPixmap#Reading and Writing Image Files}{Reading and     Writing Image Files} */
end_comment
begin_function
DECL|function|loadFromData
name|bool
name|QPixmap
operator|::
name|loadFromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|buf
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|data
condition|)
name|data
operator|=
name|QPixmapData
operator|::
name|create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|fromData
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPixmap::loadFromData(const QByteArray&data, const char *format, Qt::ImageConversionFlags flags)      \overload      Loads a pixmap from the binary \a data using the specified \a     format and conversion \a flags. */
end_comment
begin_comment
comment|/*!     Saves the pixmap to the file with the given \a fileName using the     specified image file \a format and \a quality factor. Returns true     if successful; otherwise returns false.      The \a quality factor must be in the range [0,100] or -1. Specify     0 to obtain small compressed files, 100 for large uncompressed     files, and -1 to use the default settings.      If \a format is 0, an image format will be chosen from \a fileName's     suffix.      \sa {QPixmap#Reading and Writing Image Files}{Reading and Writing     Image Files} */
end_comment
begin_function
DECL|function|save
name|bool
name|QPixmap
operator|::
name|save
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|doImageIO
argument_list|(
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      This function writes a QPixmap to the given \a device using the     specified image file \a format and \a quality factor. This can be     used, for example, to save a pixmap directly into a QByteArray:      \snippet doc/src/snippets/image/image.cpp 1 */
end_comment
begin_function
DECL|function|save
name|bool
name|QPixmap
operator|::
name|save
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// nothing to save
name|QImageWriter
name|writer
argument_list|(
name|device
argument_list|,
name|format
argument_list|)
decl_stmt|;
return|return
name|doImageIO
argument_list|(
operator|&
name|writer
argument_list|,
name|quality
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|doImageIO
name|bool
name|QPixmap
operator|::
name|doImageIO
parameter_list|(
name|QImageWriter
modifier|*
name|writer
parameter_list|,
name|int
name|quality
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|quality
operator|>
literal|100
operator|||
name|quality
operator|<
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"QPixmap::save: quality out of range [-1,100]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|>=
literal|0
condition|)
name|writer
operator|->
name|setQuality
argument_list|(
name|qMin
argument_list|(
name|quality
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|writer
operator|->
name|write
argument_list|(
name|toImage
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// The implementation (and documentation) of
end_comment
begin_comment
comment|// QPixmap::fill(const QWidget *, const QPoint&)
end_comment
begin_comment
comment|// is in qwidget.cpp
end_comment
begin_comment
comment|/*!     \fn void QPixmap::fill(const QWidget *widget, int x, int y)     \overload      Fills the pixmap with the \a widget's background color or pixmap.     The given point, (\a x, \a y), defines an offset in widget     coordinates to which the pixmap's top-left pixel will be mapped     to. */
end_comment
begin_comment
comment|/*!     Fills the pixmap with the given \a color.      The effect of this function is undefined when the pixmap is     being painted on.      \sa {QPixmap#Pixmap Transformations}{Pixmap Transformations} */
end_comment
begin_function
DECL|function|fill
name|void
name|QPixmap
operator|::
name|fill
parameter_list|(
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
comment|// Some people are probably already calling fill while a painter is active, so to not break
comment|// their programs, only print a warning and return when the fill operation could cause a crash.
if|if
condition|(
name|paintingActive
argument_list|()
operator|&&
operator|(
name|color
operator|.
name|alpha
argument_list|()
operator|!=
literal|255
operator|)
operator|&&
operator|!
name|hasAlphaChannel
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::fill: Cannot fill while pixmap is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|ref
operator|==
literal|1
condition|)
block|{
comment|// detach() will also remove this pixmap from caches, so
comment|// it has to be called even when ref == 1.
name|detach
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Don't bother to make a copy of the data object, since
comment|// it will be filled with new pixel data anyway.
name|QPixmapData
modifier|*
name|d
init|=
name|data
operator|->
name|createCompatiblePixmapData
argument_list|()
decl_stmt|;
name|d
operator|->
name|resize
argument_list|(
name|data
operator|->
name|width
argument_list|()
argument_list|,
name|data
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|=
name|d
expr_stmt|;
block|}
name|data
operator|->
name|fill
argument_list|(
name|color
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \obsolete     Returns a number that identifies the contents of this QPixmap     object. Distinct QPixmap objects can only have the same serial     number if they refer to the same contents (but they don't have     to).      Use cacheKey() instead.      \warning The serial number doesn't necessarily change when     the pixmap is altered. This means that it may be dangerous to use     it as a cache key. For caching pixmaps, we recommend using the     QPixmapCache class whenever possible. */
end_comment
begin_function
DECL|function|serialNumber
name|int
name|QPixmap
operator|::
name|serialNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|data
operator|->
name|serialNumber
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a number that identifies this QPixmap. Distinct QPixmap     objects can only have the same cache key if they refer to the same     contents.      The cacheKey() will change when the pixmap is altered. */
end_comment
begin_function
DECL|function|cacheKey
name|qint64
name|QPixmap
operator|::
name|cacheKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|cacheKey
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|sendResizeEvents
specifier|static
name|void
name|sendResizeEvents
parameter_list|(
name|QWidget
modifier|*
name|target
parameter_list|)
block|{
name|QResizeEvent
name|e
argument_list|(
name|target
operator|->
name|size
argument_list|()
argument_list|,
name|QSize
argument_list|()
argument_list|)
decl_stmt|;
name|QApplication
operator|::
name|sendEvent
argument_list|(
name|target
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
specifier|const
name|QObjectList
name|children
init|=
name|target
operator|->
name|children
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|child
init|=
cast|static_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|isWidgetType
argument_list|()
operator|&&
operator|!
name|child
operator|->
name|isWindow
argument_list|()
operator|&&
name|child
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
condition|)
name|sendResizeEvents
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::grabWidget(QWidget * widget, const QRect&rectangle)      Creates a pixmap and paints the given \a widget, restricted by the     given \a rectangle, in it. If the \a widget has any children, then     they are also painted in the appropriate positions.      If no rectangle is specified (the default) the entire widget is     painted.      If \a widget is 0, the specified rectangle doesn't overlap the     widget's rectangle, or an error occurs, the function will return a     null QPixmap.  If the rectangle is a superset of the given \a     widget, the areas outside the \a widget are covered with the     widget's background.      This function actually asks \a widget to paint itself (and its     children to paint themselves) by calling paintEvent() with painter     redirection turned on. But QPixmap also provides the grabWindow()     function which is a bit faster by grabbing pixels directly off the     screen. In addition, if there are overlaying windows,     grabWindow(), unlike grabWidget(), will see them.      \warning Do not grab a widget from its QWidget::paintEvent().     However, it is safe to grab a widget from another widget's     \l {QWidget::}{paintEvent()}.      \sa grabWindow() */
end_comment
begin_function
DECL|function|grabWidget
name|QPixmap
name|QPixmap
operator|::
name|grabWidget
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|QPixmap
argument_list|()
return|;
if|if
condition|(
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_PendingResizeEvent
argument_list|)
operator|||
operator|!
name|widget
operator|->
name|testAttribute
argument_list|(
name|Qt
operator|::
name|WA_WState_Created
argument_list|)
condition|)
name|sendResizeEvents
argument_list|(
name|widget
argument_list|)
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|prepareToRender
argument_list|(
name|QRegion
argument_list|()
argument_list|,
name|QWidget
operator|::
name|DrawWindowBackground
operator||
name|QWidget
operator|::
name|DrawChildren
operator||
name|QWidget
operator|::
name|IgnoreMask
argument_list|)
expr_stmt|;
name|QRect
name|r
argument_list|(
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|width
argument_list|()
operator|<
literal|0
condition|)
name|r
operator|.
name|setWidth
argument_list|(
name|widget
operator|->
name|width
argument_list|()
operator|-
name|rect
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|height
argument_list|()
operator|<
literal|0
condition|)
name|r
operator|.
name|setHeight
argument_list|(
name|widget
operator|->
name|height
argument_list|()
operator|-
name|rect
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|intersects
argument_list|(
name|widget
operator|->
name|rect
argument_list|()
argument_list|)
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QPixmap
name|res
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qt_widget_private
argument_list|(
name|widget
argument_list|)
operator|->
name|isOpaque
condition|)
name|res
operator|.
name|fill
argument_list|(
name|Qt
operator|::
name|transparent
argument_list|)
expr_stmt|;
name|widget
operator|->
name|d_func
argument_list|()
operator|->
name|render
argument_list|(
operator|&
name|res
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|r
argument_list|,
name|QWidget
operator|::
name|DrawWindowBackground
operator||
name|QWidget
operator|::
name|DrawChildren
operator||
name|QWidget
operator|::
name|IgnoreMask
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::grabWidget(QWidget *widget, int x, int y, int     width, int height)      \overload      Creates a pixmap and paints the given \a widget, restricted by     QRect(\a x, \a y, \a width, \a height), in it.      \warning Do not grab a widget from its QWidget::paintEvent().     However, it is safe to grab a widget from another widget's     \l {QWidget::}{paintEvent()}. */
end_comment
begin_comment
comment|/*!     \since 4.5      \enum QPixmap::ShareMode      This enum type defines the share modes that are available when     creating a QPixmap object from a raw X11 Pixmap handle.      \value ImplicitlyShared  This mode will cause the QPixmap object to     create a copy of the internal data before it is modified, thus     keeping the original X11 pixmap intact.      \value ExplicitlyShared  In this mode, the pixmap data will \e not be     copied before it is modified, which in effect will change the     original X11 pixmap.      \warning This enum is only used for X11 specific functions; using     it is non-portable.      \sa QPixmap::fromX11Pixmap() */
end_comment
begin_comment
comment|/*!     \since 4.5      \fn QPixmap QPixmap::fromX11Pixmap(Qt::HANDLE pixmap, QPixmap::ShareMode mode)      Creates a QPixmap from the native X11 Pixmap handle \a pixmap,     using \a mode as the share mode. The default share mode is     QPixmap::ImplicitlyShared, which means that a copy of the pixmap is     made if someone tries to modify it by e.g. drawing onto it.      QPixmap does \e not take ownership of the \a pixmap handle, and     have to be deleted by the user.      \warning This function is X11 specific; using it is non-portable.      \sa QPixmap::ShareMode */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
end_if
begin_comment
comment|/*!     Returns the pixmap's handle to the device context.      Note that, since QPixmap make use of \l {Implicit Data     Sharing}{implicit data sharing}, the detach() function must be     called explicitly to ensure that only \e this pixmap's data is     modified if the pixmap data is shared.      \warning This function is X11 specific; using it is non-portable.      \warning Since 4.8, pixmaps do not have an X11 handle unless     created with \l {QPixmap::}{fromX11Pixmap()}, or if the native     graphics system is explicitly enabled.      \sa detach()     \sa QApplication::setGraphicsSystem() */
end_comment
begin_function
DECL|function|handle
name|Qt
operator|::
name|HANDLE
name|QPixmap
operator|::
name|handle
parameter_list|()
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
specifier|const
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
name|pd
condition|)
block|{
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
return|return
cast|static_cast
argument_list|<
specifier|const
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
operator|->
name|handle
argument_list|()
return|;
else|else
name|qWarning
argument_list|(
literal|"QPixmap::handle(): Pixmap is not an X11 class pixmap"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_function
DECL|function|colorModeToFlags
specifier|static
name|Qt
operator|::
name|ImageConversionFlags
name|colorModeToFlags
parameter_list|(
name|QPixmap
operator|::
name|ColorMode
name|mode
parameter_list|)
block|{
name|Qt
operator|::
name|ImageConversionFlags
name|flags
init|=
name|Qt
operator|::
name|AutoColor
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QPixmap
operator|::
name|Color
case|:
name|flags
operator||=
name|Qt
operator|::
name|ColorOnly
expr_stmt|;
break|break;
case|case
name|QPixmap
operator|::
name|Mono
case|:
name|flags
operator||=
name|Qt
operator|::
name|MonoOnly
expr_stmt|;
break|break;
default|default:
break|break;
comment|// Nothing.
block|}
return|return
name|flags
return|;
block|}
end_function
begin_comment
comment|/*!     Use the constructor that takes a Qt::ImageConversionFlag instead. */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|ColorMode
name|mode
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
return|return;
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|colorModeToFlags
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a pixmap from the QImage \a image.      Use the static fromImage() function instead. */
end_comment
begin_constructor
DECL|function|QPixmap
name|QPixmap
operator|::
name|QPixmap
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
block|{
name|init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_pixmap_thread_test
argument_list|()
condition|)
return|return;
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
operator|*
name|this
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \overload      Converts the given \a image to a pixmap that is assigned to this     pixmap.      Use the static fromImage() function instead. */
end_comment
begin_function
DECL|function|operator =
name|QPixmap
modifier|&
name|QPixmap
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
operator|*
name|this
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Use the load() function that takes a Qt::ImageConversionFlag instead. */
end_comment
begin_function
DECL|function|load
name|bool
name|QPixmap
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|ColorMode
name|mode
parameter_list|)
block|{
return|return
name|load
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|,
name|colorModeToFlags
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Use the loadFromData() function that takes a Qt::ImageConversionFlag instead. */
end_comment
begin_function
DECL|function|loadFromData
name|bool
name|QPixmap
operator|::
name|loadFromData
parameter_list|(
specifier|const
name|uchar
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|ColorMode
name|mode
parameter_list|)
block|{
return|return
name|loadFromData
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|colorModeToFlags
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Use the static fromImage() function instead. */
end_comment
begin_function
DECL|function|convertFromImage
name|bool
name|QPixmap
operator|::
name|convertFromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|ColorMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|pixelType
argument_list|()
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
operator|*
name|this
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|,
name|colorModeToFlags
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|this
operator|=
name|fromImage
argument_list|(
name|image
argument_list|,
name|colorModeToFlags
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*****************************************************************************   QPixmap stream functions  *****************************************************************************/
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
end_if
begin_comment
comment|/*!     \relates QPixmap      Writes the given \a pixmap to the given \a stream as a PNG     image. Note that writing the stream to a file will not produce a     valid image file.      \sa QPixmap::save(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
return|return
name|stream
operator|<<
name|pixmap
operator|.
name|toImage
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QPixmap      Reads an image from the given \a stream into the given \a pixmap.      \sa QPixmap::load(), {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QPixmap
modifier|&
name|pixmap
parameter_list|)
block|{
name|QImage
name|image
decl_stmt|;
name|stream
operator|>>
name|image
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|pixmap
operator|=
name|QPixmap
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
name|pixmap
operator|=
name|QBitmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pixmap
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_function
DECL|function|copyBlt
name|Q_GUI_EXPORT
name|void
name|copyBlt
parameter_list|(
name|QPixmap
modifier|*
name|dst
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QPixmap
modifier|*
name|src
parameter_list|,
name|int
name|sx
parameter_list|,
name|int
name|sy
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|sh
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|dst
argument_list|,
literal|"::copyBlt"
argument_list|,
literal|"Destination pixmap must be non-null"
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|src
argument_list|,
literal|"::copyBlt"
argument_list|,
literal|"Source pixmap must be non-null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|hasAlphaChannel
argument_list|()
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|paintEngine
argument_list|()
operator|->
name|hasFeature
argument_list|(
name|QPaintEngine
operator|::
name|PorterDuff
argument_list|)
condition|)
block|{
name|QPainter
name|p
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
operator|*
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QImage
name|image
init|=
name|dst
operator|->
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|QPainter
name|p
argument_list|(
operator|&
name|image
argument_list|)
decl_stmt|;
name|p
operator|.
name|setCompositionMode
argument_list|(
name|QPainter
operator|::
name|CompositionMode_Source
argument_list|)
expr_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
operator|*
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|p
operator|.
name|end
argument_list|()
expr_stmt|;
operator|*
name|dst
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|QPainter
name|p
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|p
operator|.
name|drawPixmap
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
operator|*
name|src
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|,
name|sw
argument_list|,
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isDetached
name|bool
name|QPixmap
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|&&
name|data
operator|->
name|ref
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \internal   ### Qt5 - remove me. */
end_comment
begin_function
DECL|function|deref
name|void
name|QPixmap
operator|::
name|deref
parameter_list|()
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QPixmap::deref()"
argument_list|,
literal|"Do not call this function anymore!"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QImage QPixmap::convertToImage() const      Use the toImage() function instead. */
end_comment
begin_comment
comment|/*!     Replaces this pixmap's data with the given \a image using the     specified \a flags to control the conversion.  The \a flags     argument is a bitwise-OR of the \l{Qt::ImageConversionFlags}.     Passing 0 for \a flags sets all the default options. Returns true     if the result is that this pixmap is not null.      Note: this function was part of Qt 3 support in Qt 4.6 and earlier.     It has been promoted to official API status in 4.7 to support updating     the pixmap's image without creating a new QPixmap as fromImage() would.      \sa fromImage()     \since 4.7 */
end_comment
begin_function
DECL|function|convertFromImage
name|bool
name|QPixmap
operator|::
name|convertFromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|data
condition|)
operator|*
name|this
operator|=
name|QPixmap
operator|::
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|!
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::xForm(const QMatrix&matrix) const      Use transformed() instead. */
end_comment
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaled(int width, int height,     Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode     transformMode) const      \overload      Returns a copy of the pixmap scaled to a rectangle with the given     \a width and \a height according to the given \a aspectRatioMode and     \a transformMode.      If either the \a width or the \a height is zero or negative, this     function returns a null pixmap. */
end_comment
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaled(const QSize&size, Qt::AspectRatioMode     aspectRatioMode, Qt::TransformationMode transformMode) const      Scales the pixmap to the given \a size, using the aspect ratio and     transformation modes specified by \a aspectRatioMode and \a     transformMode.      \image qimage-scaling.png      \list     \i If \a aspectRatioMode is Qt::IgnoreAspectRatio, the pixmap        is scaled to \a size.     \i If \a aspectRatioMode is Qt::KeepAspectRatio, the pixmap is        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.     \i If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,        the pixmap is scaled to a rectangle as small as possible        outside \a size, preserving the aspect ratio.     \endlist      If the given \a size is empty, this function returns a null     pixmap.       In some cases it can be more beneficial to draw the pixmap to a     painter with a scale set rather than scaling the pixmap. This is     the case when the painter is for instance based on OpenGL or when     the scale factor changes rapidly.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations}  */
end_comment
begin_function
DECL|function|scaled
name|QPixmap
name|QPixmap
operator|::
name|scaled
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|AspectRatioMode
name|aspectMode
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaled: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QSize
name|newSize
init|=
name|size
argument_list|()
decl_stmt|;
name|newSize
operator|.
name|scale
argument_list|(
name|s
argument_list|,
name|aspectMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|newSize
operator|==
name|size
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|width
argument_list|()
operator|/
name|width
argument_list|()
argument_list|,
operator|(
name|qreal
operator|)
name|newSize
operator|.
name|height
argument_list|()
operator|/
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QPixmap
name|pix
init|=
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
decl_stmt|;
return|return
name|pix
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaledToWidth(int width, Qt::TransformationMode     mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a width using the specified transformation \a mode.     The height of the pixmap is automatically calculated so that the     aspect ratio of the pixmap is preserved.      If \a width is 0 or negative, a null pixmap is returned.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|scaledToWidth
name|QPixmap
name|QPixmap
operator|::
name|scaledToWidth
parameter_list|(
name|int
name|w
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaleWidth: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|copy
argument_list|()
return|;
block|}
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|w
operator|/
name|width
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::scaledToHeight(int height,     Qt::TransformationMode mode) const      Returns a scaled copy of the image. The returned image is scaled     to the given \a height using the specified transformation \a mode.     The width of the pixmap is automatically calculated so that the     aspect ratio of the pixmap is preserved.      If \a height is 0 or negative, a null pixmap is returned.      \sa isNull(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|scaledToHeight
name|QPixmap
name|QPixmap
operator|::
name|scaledToHeight
parameter_list|(
name|int
name|h
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::scaleHeight: Pixmap is a null pixmap"
argument_list|)
expr_stmt|;
return|return
name|copy
argument_list|()
return|;
block|}
if|if
condition|(
name|h
operator|<=
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|qreal
name|factor
init|=
operator|(
name|qreal
operator|)
name|h
operator|/
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|wm
init|=
name|QTransform
operator|::
name|fromScale
argument_list|(
name|factor
argument_list|,
name|factor
argument_list|)
decl_stmt|;
return|return
name|transformed
argument_list|(
name|wm
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the pixmap that is transformed using the given     transformation \a transform and transformation \a mode. The original     pixmap is not changed.      The transformation \a transform is internally adjusted to compensate     for unwanted translation; i.e. the pixmap produced is the smallest     pixmap that contains all the transformed points of the original     pixmap. Use the trueMatrix() function to retrieve the actual     matrix used for transforming the pixmap.      This function is slow because it involves transformation to a     QImage, non-trivial computations and a transformation back to a     QPixmap.      \sa trueMatrix(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations} */
end_comment
begin_function
DECL|function|transformed
name|QPixmap
name|QPixmap
operator|::
name|transformed
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|transform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
return|return
operator|*
name|this
return|;
return|return
name|data
operator|->
name|transformed
argument_list|(
name|transform
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload    This convenience function loads the \a matrix into a   QTransform and calls the overloaded function.  */
end_comment
begin_function
DECL|function|transformed
name|QPixmap
name|QPixmap
operator|::
name|transformed
parameter_list|(
specifier|const
name|QMatrix
modifier|&
name|matrix
parameter_list|,
name|Qt
operator|::
name|TransformationMode
name|mode
parameter_list|)
specifier|const
block|{
return|return
name|transformed
argument_list|(
name|QTransform
argument_list|(
name|matrix
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QPixmap      \brief The QPixmap class is an off-screen image representation     that can be used as a paint device.      \ingroup painting     \ingroup shared       Qt provides four classes for handling image data: QImage, QPixmap,     QBitmap and QPicture. QImage is designed and optimized for I/O,     and for direct pixel access and manipulation, while QPixmap is     designed and optimized for showing images on screen. QBitmap is     only a convenience class that inherits QPixmap, ensuring a depth     of 1. The isQBitmap() function returns true if a QPixmap object is     really a bitmap, otherwise returns false. Finally, the QPicture class     is a paint device that records and replays QPainter commands.      A QPixmap can easily be displayed on the screen using QLabel or     one of QAbstractButton's subclasses (such as QPushButton and     QToolButton). QLabel has a pixmap property, whereas     QAbstractButton has an icon property.      In addition to the ordinary constructors, a QPixmap can be     constructed using the static grabWidget() and grabWindow()     functions which creates a QPixmap and paints the given widget, or     window, into it.      QPixmap objects can be passed around by value since the QPixmap     class uses implicit data sharing. For more information, see the \l     {Implicit Data Sharing} documentation. QPixmap objects can also be     streamed.      Note that the pixel data in a pixmap is internal and is managed by     the underlying window system. Because QPixmap is a QPaintDevice     subclass, QPainter can be used to draw directly onto pixmaps.     Pixels can only be accessed through QPainter functions or by     converting the QPixmap to a QImage. However, the fill() function     is available for initializing the entire pixmap with a given color.      There are functions to convert between QImage and     QPixmap. Typically, the QImage class is used to load an image     file, optionally manipulating the image data, before the QImage     object is converted into a QPixmap to be shown on     screen. Alternatively, if no manipulation is desired, the image     file can be loaded directly into a QPixmap. On Windows, the     QPixmap class also supports conversion between \c HBITMAP and     QPixmap. On Symbian, the QPixmap class also supports conversion     between CFbsBitmap and QPixmap.      QPixmap provides a collection of functions that can be used to     obtain a variety of information about the pixmap. In addition,     there are several functions that enables transformation of the     pixmap.      \tableofcontents      \section1 Reading and Writing Image Files      QPixmap provides several ways of reading an image file: The file     can be loaded when constructing the QPixmap object, or by using     the load() or loadFromData() functions later on. When loading an     image, the file name can either refer to an actual file on disk or     to one of the application's embedded resources. See \l{The Qt     Resource System} overview for details on how to embed images and     other resource files in the application's executable.      Simply call the save() function to save a QPixmap object.      The complete list of supported file formats are available through     the QImageReader::supportedImageFormats() and     QImageWriter::supportedImageFormats() functions. New file formats     can be added as plugins. By default, Qt supports the following     formats:      \table     \header \o Format \o Description                      \o Qt's support     \row    \o BMP    \o Windows Bitmap                   \o Read/write     \row    \o GIF    \o Graphic Interchange Format (optional) \o Read     \row    \o JPG    \o Joint Photographic Experts Group \o Read/write     \row    \o JPEG   \o Joint Photographic Experts Group \o Read/write     \row    \o PNG    \o Portable Network Graphics        \o Read/write     \row    \o PBM    \o Portable Bitmap                  \o Read     \row    \o PGM    \o Portable Graymap                 \o Read     \row    \o PPM    \o Portable Pixmap                  \o Read/write     \row    \o XBM    \o X11 Bitmap                       \o Read/write     \row    \o XPM    \o X11 Pixmap                       \o Read/write     \endtable      \section1 Pixmap Information      QPixmap provides a collection of functions that can be used to     obtain a variety of information about the pixmap:      \table     \header     \o \o Available Functions     \row     \o Geometry     \o     The size(), width() and height() functions provide information     about the pixmap's size. The rect() function returns the image's     enclosing rectangle.      \row     \o Alpha component     \o      The hasAlphaChannel() returns true if the pixmap has a format that     respects the alpha channel, otherwise returns false. The hasAlpha(),     setMask() and mask() functions are legacy and should not be used.     They are potentially very slow.      The createHeuristicMask() function creates and returns a 1-bpp     heuristic mask (i.e. a QBitmap) for this pixmap. It works by     selecting a color from one of the corners and then chipping away     pixels of that color, starting at all the edges. The     createMaskFromColor() function creates and returns a mask (i.e. a     QBitmap) for the pixmap based on a given color.      \row     \o Low-level information     \o      The depth() function returns the depth of the pixmap. The     defaultDepth() function returns the default depth, i.e. the depth     used by the application on the given screen.      The cacheKey() function returns a number that uniquely     identifies the contents of the QPixmap object.      The x11Info() function returns information about the configuration     of the X display used by the screen to which the pixmap currently     belongs. The x11PictureHandle() function returns the X11 Picture     handle of the pixmap for XRender support. Note that the two latter     functions are only available on x11.      \endtable      \section1 Pixmap Conversion      A QPixmap object can be converted into a QImage using the     toImage() function. Likewise, a QImage can be converted into a     QPixmap using the fromImage(). If this is too expensive an     operation, you can use QBitmap::fromImage() instead.      In addition, on Windows, the QPixmap class supports conversion to     and from HBITMAP: the toWinHBITMAP() function creates a HBITMAP     equivalent to the QPixmap, based on the given HBitmapFormat, and     returns the HBITMAP handle. The fromWinHBITMAP() function returns     a QPixmap that is equivalent to the given bitmap which has the     specified format. The QPixmap class also supports conversion to     and from HICON: the toWinHICON() function creates a HICON equivalent     to the QPixmap, and returns the HICON handle. The fromWinHICON()     function returns a QPixmap that is equivalent to the given icon.      In addition, on Symbian, the QPixmap class supports conversion to     and from CFbsBitmap: the toSymbianCFbsBitmap() function creates     CFbsBitmap equivalent to the QPixmap, based on given mode and returns     a CFbsBitmap object. The fromSymbianCFbsBitmap() function returns a     QPixmap that is equivalent to the given bitmap and given mode.      \section1 Pixmap Transformations      QPixmap supports a number of functions for creating a new pixmap     that is a transformed version of the original:      The scaled(), scaledToWidth() and scaledToHeight() functions     return scaled copies of the pixmap, while the copy() function     creates a QPixmap that is a plain copy of the original one.      The transformed() function returns a copy of the pixmap that is     transformed with the given transformation matrix and     transformation mode: Internally, the transformation matrix is     adjusted to compensate for unwanted translation,     i.e. transformed() returns the smallest pixmap containing all     transformed points of the original pixmap. The static trueMatrix()     function returns the actual matrix used for transforming the     pixmap.      \note When using the native X11 graphics system, the pixmap     becomes invalid when the QApplication instance is destroyed.      \sa QBitmap, QImage, QImageReader, QImageWriter */
end_comment
begin_comment
comment|/*!     \typedef QPixmap::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QPixmap::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     Returns true if this pixmap has an alpha channel, \e or has a     mask, otherwise returns false.      \sa hasAlphaChannel(), mask() */
end_comment
begin_function
DECL|function|hasAlpha
name|bool
name|QPixmap
operator|::
name|hasAlpha
parameter_list|()
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|hasAlphaChannel
argument_list|()
condition|)
return|return
literal|true
return|;
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
name|pd
operator|&&
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
block|{
name|QX11PixmapData
modifier|*
name|x11Data
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XRENDER
if|if
condition|(
name|x11Data
operator|->
name|picture
operator|&&
name|x11Data
operator|->
name|d
operator|==
literal|32
condition|)
return|return
literal|true
return|;
endif|#
directive|endif
if|if
condition|(
name|x11Data
operator|->
name|d
operator|==
literal|1
operator|||
name|x11Data
operator|->
name|x11_mask
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
else|#
directive|else
return|return
name|data
operator|&&
name|data
operator|->
name|hasAlphaChannel
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns true if the pixmap has a format that respects the alpha     channel, otherwise returns false.      \sa hasAlpha() */
end_comment
begin_function
DECL|function|hasAlphaChannel
name|bool
name|QPixmap
operator|::
name|hasAlphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|data
operator|&&
name|data
operator|->
name|hasAlphaChannel
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|metric
name|int
name|QPixmap
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|metric
parameter_list|)
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|metric
argument_list|(
name|metric
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPixmap::setAlphaChannel(const QPixmap&alphaChannel)     \obsolete      Sets the alpha channel of this pixmap to the given \a alphaChannel     by converting the \a alphaChannel into 32 bit and using the     intensity of the RGB pixel values.      The effect of this function is undefined when the pixmap is being     painted on.      \warning This is potentially an expensive operation. Most usecases     for this function are covered by QPainter and compositionModes     which will normally execute faster.      \sa alphaChannel(), {QPixmap#Pixmap Transformations}{Pixmap     Transformations}  */
end_comment
begin_function
DECL|function|setAlphaChannel
name|void
name|QPixmap
operator|::
name|setAlphaChannel
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|alphaChannel
parameter_list|)
block|{
if|if
condition|(
name|alphaChannel
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setAlphaChannel: "
literal|"Cannot set alpha channel while pixmap is being painted on"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|width
argument_list|()
operator|!=
name|alphaChannel
operator|.
name|width
argument_list|()
operator|&&
name|height
argument_list|()
operator|!=
name|alphaChannel
operator|.
name|height
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPixmap::setAlphaChannel: "
literal|"The pixmap and the alpha channel pixmap must have the same size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|detach
argument_list|()
expr_stmt|;
name|data
operator|->
name|setAlphaChannel
argument_list|(
name|alphaChannel
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns the alpha channel of the pixmap as a new grayscale QPixmap in which     each pixel's red, green, and blue values are given the alpha value of the     original pixmap. The color depth of the returned pixmap is the system depth     on X11 and 8-bit on Windows and Mac OS X.      You can use this function while debugging     to get a visible image of the alpha channel. If the pixmap doesn't have an     alpha channel, i.e., the alpha channel's value for all pixels equals     0xff), a null pixmap is returned. You can check this with the \c isNull()     function.      We show an example:      \snippet doc/src/snippets/alphachannel.cpp 0      \image alphachannelimage.png The pixmap and channelImage QPixmaps      \warning This is an expensive operation. The alpha channel of the     pixmap is extracted dynamically from the pixeldata. Most usecases of this     function are covered by QPainter and compositionModes which will normally     execute faster.      \sa setAlphaChannel(), {QPixmap#Pixmap Information}{Pixmap     Information} */
end_comment
begin_function
DECL|function|alphaChannel
name|QPixmap
name|QPixmap
operator|::
name|alphaChannel
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|alphaChannel
argument_list|()
else|:
name|QPixmap
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QPixmap
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|paintEngine
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QBitmap QPixmap::mask() const      Extracts a bitmap mask from the pixmap's alpha channel.      \warning This is potentially an expensive operation. The mask of     the pixmap is extracted dynamically from the pixeldata.      \sa setMask(), {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_function
DECL|function|mask
name|QBitmap
name|QPixmap
operator|::
name|mask
parameter_list|()
specifier|const
block|{
return|return
name|data
condition|?
name|data
operator|->
name|mask
argument_list|()
else|:
name|QBitmap
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the default pixmap depth used by the application.      On Windows and Mac, the default depth is always 32. On X11 and     embedded, the depth of the screen will be returned by this     function.      \sa depth(), QColormap::depth(), {QPixmap#Pixmap Information}{Pixmap Information}  */
end_comment
begin_function
DECL|function|defaultDepth
name|int
name|QPixmap
operator|::
name|defaultDepth
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
return|return
name|QScreen
operator|::
name|instance
argument_list|()
operator|->
name|depth
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
return|return
name|QX11Info
operator|::
name|appDepth
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_WINCE
argument_list|)
return|return
name|QColormap
operator|::
name|instance
argument_list|()
operator|.
name|depth
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
return|return
literal|32
return|;
comment|// XXX
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
return|return
literal|32
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
return|return
name|S60
operator|->
name|screenDepth
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
return|return
literal|32
return|;
comment|//LITE: use graphicssystem (we should do that in general)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Detaches the pixmap from shared pixmap data.      A pixmap is automatically detached by Qt whenever its contents are     about to change. This is done in almost all QPixmap member     functions that modify the pixmap (fill(), fromImage(),     load(), etc.), and in QPainter::begin() on a pixmap.      There are two exceptions in which detach() must be called     explicitly, that is when calling the handle() or the     x11PictureHandle() function (only available on X11). Otherwise,     any modifications done using system calls, will be performed on     the shared data.      The detach() function returns immediately if there is just a     single reference or if the pixmap has not been initialized yet. */
end_comment
begin_function
DECL|function|detach
name|void
name|QPixmap
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return;
comment|// QPixmap.data member may be QRuntimePixmapData so use pixmapData() function to get
comment|// the actual underlaying runtime pixmap data.
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmapData
argument_list|()
decl_stmt|;
name|QPixmapData
operator|::
name|ClassId
name|id
init|=
name|pd
operator|->
name|classId
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|QPixmapData
operator|::
name|RasterClass
condition|)
block|{
name|QRasterPixmapData
modifier|*
name|rasterData
init|=
cast|static_cast
argument_list|<
name|QRasterPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|rasterData
operator|->
name|image
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|is_cached
operator|&&
name|data
operator|->
name|ref
operator|==
literal|1
condition|)
name|QImagePixmapCleanupHooks
operator|::
name|executePixmapDataModificationHooks
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QMacPixmapData
modifier|*
name|macData
init|=
name|id
operator|==
name|QPixmapData
operator|::
name|MacClass
condition|?
cast|static_cast
argument_list|<
name|QMacPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|macData
condition|)
block|{
if|if
condition|(
name|macData
operator|->
name|cg_mask
condition|)
block|{
name|CGImageRelease
argument_list|(
name|macData
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
name|macData
operator|->
name|cg_mask
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|data
operator|->
name|ref
operator|!=
literal|1
condition|)
block|{
operator|*
name|this
operator|=
name|copy
argument_list|()
expr_stmt|;
block|}
operator|++
name|data
operator|->
name|detach_no
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
condition|)
block|{
name|QX11PixmapData
modifier|*
name|d
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|QX11PixmapData
operator|::
name|Uninitialized
expr_stmt|;
comment|// reset the cache data
if|if
condition|(
name|d
operator|->
name|hd2
condition|)
block|{
name|XFreePixmap
argument_list|(
name|X11
operator|->
name|display
argument_list|,
name|d
operator|->
name|hd2
argument_list|)
expr_stmt|;
name|d
operator|->
name|hd2
operator|=
literal|0
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
if|if
condition|(
name|macData
condition|)
block|{
name|macData
operator|->
name|macReleaseCGImageRef
argument_list|()
expr_stmt|;
name|macData
operator|->
name|uninit
operator|=
literal|false
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::fromImage(const QImage&image, Qt::ImageConversionFlags flags)      Converts the given \a image to a pixmap using the specified \a     flags to control the conversion.  The \a flags argument is a     bitwise-OR of the \l{Qt::ImageConversionFlags}. Passing 0 for \a     flags sets all the default options.      In case of monochrome and 8-bit images, the image is first     converted to a 32-bit pixmap and then filled with the colors in     the color table. If this is too expensive an operation, you can     use QBitmap::fromImage() instead.      \sa fromImageReader(), toImage(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromImage
name|QPixmap
name|QPixmap
operator|::
name|fromImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QPixmap
argument_list|()
return|;
name|QGraphicsSystem
modifier|*
name|gs
init|=
name|QApplicationPrivate
operator|::
name|graphicsSystem
argument_list|()
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QPixmapData
argument_list|>
name|data
argument_list|(
name|gs
condition|?
name|gs
operator|->
name|createPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
else|:
name|QGraphicsSystem
operator|::
name|createDefaultPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::fromImageReader(QImageReader *imageReader, Qt::ImageConversionFlags flags)      Create a QPixmap from an image read directly from an \a imageReader.     The \a flags argument is a bitwise-OR of the \l{Qt::ImageConversionFlags}.     Passing 0 for \a flags sets all the default options.      On some systems, reading an image directly to QPixmap can use less memory than     reading a QImage to convert it to QPixmap.      \sa fromImage(), toImage(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_function
DECL|function|fromImageReader
name|QPixmap
name|QPixmap
operator|::
name|fromImageReader
parameter_list|(
name|QImageReader
modifier|*
name|imageReader
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|QGraphicsSystem
modifier|*
name|gs
init|=
name|QApplicationPrivate
operator|::
name|graphicsSystem
argument_list|()
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QPixmapData
argument_list|>
name|data
argument_list|(
name|gs
condition|?
name|gs
operator|->
name|createPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
else|:
name|QGraphicsSystem
operator|::
name|createDefaultPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|fromImageReader
argument_list|(
name|imageReader
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|(
name|data
operator|.
name|take
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPixmap QPixmap::grabWindow(WId window, int x, int y, int     width, int height)      Creates and returns a pixmap constructed by grabbing the contents     of the given \a window restricted by QRect(\a x, \a y, \a width,     \a height).      The arguments (\a{x}, \a{y}) specify the offset in the window,     whereas (\a{width}, \a{height}) specify the area to be copied.  If     \a width is negative, the function copies everything to the right     border of the window. If \a height is negative, the function     copies everything to the bottom of the window.      The window system identifier (\c WId) can be retrieved using the     QWidget::winId() function. The rationale for using a window     identifier and not a QWidget, is to enable grabbing of windows     that are not part of the application, window system frames, and so     on.      The grabWindow() function grabs pixels from the screen, not from     the window, i.e. if there is another window partially or entirely     over the one you grab, you get pixels from the overlying window,     too. The mouse cursor is generally not grabbed.      Note on X11 that if the given \a window doesn't have the same depth     as the root window, and another window partially or entirely     obscures the one you grab, you will \e not get pixels from the     overlying window.  The contents of the obscured areas in the     pixmap will be undefined and uninitialized.      On Windows Vista and above grabbing a layered window, which is     created by setting the Qt::WA_TranslucentBackground attribute, will     not work. Instead grabbing the desktop widget should work.      \warning In general, grabbing an area outside the screen is not     safe. This depends on the underlying window system.      \sa grabWidget(), {Screenshot Example} */
end_comment
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|pixmapData
name|QPixmapData
modifier|*
name|QPixmap
operator|::
name|pixmapData
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|data
condition|)
block|{
name|QPixmapData
modifier|*
name|pm
init|=
name|data
operator|.
name|data
argument_list|()
decl_stmt|;
return|return
name|pm
operator|->
name|runtimeData
argument_list|()
condition|?
name|pm
operator|->
name|runtimeData
argument_list|()
else|:
name|pm
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QPixmap::HBitmapFormat      \bold{Win32 only:} This enum defines how the conversion between \c     HBITMAP and QPixmap is performed.      \warning This enum is only available on Windows.      \value NoAlpha The alpha channel is ignored and always treated as     being set to fully opaque. This is preferred if the \c HBITMAP is     used with standard GDI calls, such as \c BitBlt().      \value PremultipliedAlpha The \c HBITMAP is treated as having an     alpha channel and premultiplied colors. This is preferred if the     \c HBITMAP is accessed through the \c AlphaBlend() GDI function.      \value Alpha The \c HBITMAP is treated as having a plain alpha     channel. This is the preferred format if the \c HBITMAP is going     to be used as an application icon or systray icon.      \sa fromWinHBITMAP(), toWinHBITMAP() */
end_comment
begin_comment
comment|/*! \fn HBITMAP QPixmap::toWinHBITMAP(HBitmapFormat format) const     \bold{Win32 only:} Creates a \c HBITMAP equivalent to the QPixmap,     based on the given \a format. Returns the \c HBITMAP handle.      It is the caller's responsibility to free the \c HBITMAP data     after use.      \warning This function is only available on Windows.      \sa fromWinHBITMAP(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_comment
comment|/*! \fn QPixmap QPixmap::fromWinHBITMAP(HBITMAP bitmap, HBitmapFormat format)     \bold{Win32 only:} Returns a QPixmap that is equivalent to the     given \a bitmap. The conversion is based on the specified \a     format.      \warning This function is only available on Windows.      \sa toWinHBITMAP(), {QPixmap#Pixmap Conversion}{Pixmap Conversion}  */
end_comment
begin_comment
comment|/*! \fn HICON QPixmap::toWinHICON() const     \since 4.6      \bold{Win32 only:} Creates a \c HICON equivalent to the QPixmap.     Returns the \c HICON handle.      It is the caller's responsibility to free the \c HICON data after use.      \warning This function is only available on Windows.      \sa fromWinHICON(), {QPixmap#Pixmap Conversion}{Pixmap Conversion} */
end_comment
begin_comment
comment|/*! \fn QPixmap QPixmap::fromWinHICON(HICON icon)     \since 4.6      \bold{Win32 only:} Returns a QPixmap that is equivalent to the given     \a icon.      \warning This function is only available on Windows.      \sa toWinHICON(), {QPixmap#Pixmap Conversion}{Pixmap Conversion}  */
end_comment
begin_comment
comment|/*! \fn const QX11Info&QPixmap::x11Info() const     \bold{X11 only:} Returns information about the configuration of     the X display used by the screen to which the pixmap currently belongs.      \warning This function is only available on X11.      \sa {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_comment
comment|/*! \fn Qt::HANDLE QPixmap::x11PictureHandle() const     \bold{X11 only:} Returns the X11 Picture handle of the pixmap for     XRender support.      This function will return 0 if XRender support is not compiled     into Qt, if the XRender extension is not supported on the X11     display, or if the handle could not be created. Use of this     function is not portable.      \warning This function is only available on X11.      \sa {QPixmap#Pixmap Information}{Pixmap Information} */
end_comment
begin_comment
comment|/*! \fn int QPixmap::x11SetDefaultScreen(int screen)   \internal */
end_comment
begin_comment
comment|/*! \fn void QPixmap::x11SetScreen(int screen)   \internal */
end_comment
begin_comment
comment|/*! \fn QRgb* QPixmap::clut() const     \internal */
end_comment
begin_comment
comment|/*! \fn int QPixmap::numCols() const     \obsolete     \internal     \sa colorCount() */
end_comment
begin_comment
comment|/*! \fn int QPixmap::colorCount() const     \since 4.6     \internal */
end_comment
begin_comment
comment|/*! \fn const uchar* QPixmap::qwsBits() const     \internal     \since 4.1 */
end_comment
begin_comment
comment|/*! \fn int QPixmap::qwsBytesPerLine() const     \internal     \since 4.1 */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
