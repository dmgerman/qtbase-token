begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QImageWriter     \brief The QImageWriter class provides a format independent interface     for writing images to files or other devices.      \inmodule QtGui     \reentrant     \ingroup painting     \ingroup io      QImageWriter supports setting format specific options, such as the     gamma level, compression level and quality, prior to storing the     image. If you do not need such options, you can use QImage::save()     or QPixmap::save() instead.      To store an image, you start by constructing a QImageWriter     object.  Pass either a file name or a device pointer, and the     image format to QImageWriter's constructor. You can then set     several options, such as the gamma level (by calling setGamma())     and quality (by calling setQuality()). canWrite() returns true if     QImageWriter can write the image (i.e., the image format is     supported and the device is open for writing). Call write() to     write the image to the device.      If any error occurs when writing the image, write() will return     false. You can then call error() to find the type of error that     occurred, or errorString() to get a human readable description of     what went wrong.      Call supportedImageFormats() for a list of formats that     QImageWriter can write. QImageWriter supports all built-in image     formats, in addition to any image format plugins that support     writing.      \sa QImageReader, QImageIOHandler, QImageIOPlugin */
end_comment
begin_comment
comment|/*!     \enum QImageWriter::ImageWriterError      This enum describes errors that can occur when writing images with     QImageWriter.      \value DeviceError QImageWriter encountered a device error when     writing the image data. Consult your device for more details on     what went wrong.      \value UnsupportedFormatError Qt does not support the requested     image format.      \value UnknownError An unknown error occurred. If you get this     value after calling write(), it is most likely caused by a bug in     QImageWriter. */
end_comment
begin_include
include|#
directive|include
file|"qimagewriter.h"
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qimageiohandler.h>
end_include
begin_include
include|#
directive|include
file|<qjsonarray.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_comment
comment|// factory loader
end_comment
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_comment
comment|// image handlers
end_comment
begin_include
include|#
directive|include
file|<private/qbmphandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qppmhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qxbmhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qxpmhandler_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
end_ifndef
begin_include
include|#
directive|include
file|<private/qpnghandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
end_ifndef
begin_include
include|#
directive|include
file|<private/qjpeghandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
end_ifdef
begin_include
include|#
directive|include
file|<private/qgifhandler_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QFactoryLoader
argument_list|,
name|loader
argument_list|,
operator|(
name|QImageIOHandlerFactoryInterface_iid
operator|,
name|QLatin1String
argument_list|(
literal|"/imageformats"
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
decl|static
DECL|function|createWriteHandlerHelper
name|QImageIOHandler
modifier|*
name|createWriteHandlerHelper
argument_list|(
name|QIODevice
operator|*
name|device
argument_list|,
specifier|const
name|QByteArray
operator|&
name|format
argument_list|)
argument_list|{
name|QByteArray
name|form
operator|=
name|format
operator|.
name|toLower
argument_list|()
argument_list|;
name|QByteArray
name|suffix
argument_list|;
name|QImageIOHandler
operator|*
name|handler
operator|=
literal|0
argument_list|;
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
argument_list|typedef
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|PluginKeyMap
argument_list|;
comment|// check if any plugins can write the image
name|QFactoryLoader
operator|*
name|l
operator|=
name|loader
argument_list|()
argument_list|;
specifier|const
name|PluginKeyMap
name|keyMap
operator|=
name|l
operator|->
name|keyMap
argument_list|()
argument_list|;
name|int
name|suffixPluginIndex
operator|=
operator|-
literal|1
argument_list|;
endif|#
directive|endif
argument_list|if
operator|(
name|device
operator|&&
name|format
operator|.
name|isEmpty
argument_list|()
operator|)
block|{
comment|// if there's no format, see if \a device is a file, and if so, find
comment|// the file suffix and find support for that format among our plugins.
comment|// this allows plugins to override our built-in handlers.
if|if
condition|(
name|QFile
modifier|*
name|file
type|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
type|(
name|device
condition|)) {             if (!(suffix = QFileInfo(file->fileName()
argument_list|)
decl|.
name|suffix
argument_list|()
decl|.
name|toLower
argument_list|()
decl|.
name|toLatin1
argument_list|()
decl_stmt|).isEmpty(
end_decl_stmt
begin_block
unit|))
block|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
specifier|const
name|int
name|index
init|=
name|keyMap
operator|.
name|key
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|suffix
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|suffixPluginIndex
operator|=
name|index
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_decl_stmt
unit|}     }
name|QByteArray
name|testFormat
init|=
operator|!
name|form
operator|.
name|isEmpty
argument_list|()
condition|?
name|form
else|:
name|suffix
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
end_ifndef
begin_if
if|if
condition|(
name|suffixPluginIndex
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// when format is missing, check if we can find a plugin for the
comment|// suffix.
specifier|const
name|int
name|index
init|=
name|keyMap
operator|.
name|key
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|suffix
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
operator|(
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|suffix
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanWrite
operator|)
condition|)
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IMAGEFORMATPLUGIN
end_comment
begin_comment
comment|// check if any built-in handlers can write the image
end_comment
begin_if
if|if
condition|(
operator|!
name|handler
operator|&&
operator|!
name|testFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"png"
condition|)
block|{
name|handler
operator|=
operator|new
name|QPngHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"jpg"
operator|||
name|testFormat
operator|==
literal|"jpeg"
condition|)
block|{
name|handler
operator|=
operator|new
name|QJpegHandler
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILTIN_GIF_READER
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"gif"
condition|)
block|{
name|handler
operator|=
operator|new
name|QGifHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_BMP
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"bmp"
condition|)
block|{
name|handler
operator|=
operator|new
name|QBmpHandler
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"dib"
condition|)
block|{
name|handler
operator|=
operator|new
name|QBmpHandler
argument_list|(
name|QBmpHandler
operator|::
name|DibFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"xpm"
condition|)
block|{
name|handler
operator|=
operator|new
name|QXpmHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"xbm"
condition|)
block|{
name|handler
operator|=
operator|new
name|QXbmHandler
expr_stmt|;
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|SubType
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
block|}
elseif|else
if|if
condition|(
name|testFormat
operator|==
literal|"pbm"
operator|||
name|testFormat
operator|==
literal|"pbmraw"
operator|||
name|testFormat
operator|==
literal|"pgm"
operator|||
name|testFormat
operator|==
literal|"pgmraw"
operator|||
name|testFormat
operator|==
literal|"ppm"
operator|||
name|testFormat
operator|==
literal|"ppmraw"
condition|)
block|{
name|handler
operator|=
operator|new
name|QPpmHandler
expr_stmt|;
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|SubType
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
end_ifndef
begin_if
if|if
condition|(
operator|!
name|testFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|int
name|keyCount
init|=
name|keyMap
operator|.
name|keys
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyCount
condition|;
operator|++
name|i
control|)
block|{
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
operator|(
name|plugin
operator|->
name|capabilities
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
operator|&
name|QImageIOPlugin
operator|::
name|CanWrite
operator|)
condition|)
block|{
operator|delete
name|handler
expr_stmt|;
name|handler
operator|=
name|plugin
operator|->
name|create
argument_list|(
name|device
argument_list|,
name|testFormat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IMAGEFORMATPLUGIN
end_comment
begin_if
if|if
condition|(
operator|!
name|handler
condition|)
return|return
literal|0
return|;
end_if
begin_expr_stmt
name|handler
operator|->
name|setDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|testFormat
operator|.
name|isEmpty
argument_list|()
condition|)
name|handler
operator|->
name|setFormat
argument_list|(
name|testFormat
argument_list|)
expr_stmt|;
end_if
begin_return
return|return
name|handler
return|;
end_return
begin_macro
unit|}  class
DECL|class|QImageWriterPrivate
name|QImageWriterPrivate
end_macro
begin_block
block|{
public|public:
name|QImageWriterPrivate
parameter_list|(
name|QImageWriter
modifier|*
name|qq
parameter_list|)
constructor_decl|;
comment|// device
DECL|member|format
name|QByteArray
name|format
decl_stmt|;
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|deleteDevice
name|bool
name|deleteDevice
decl_stmt|;
DECL|member|handler
name|QImageIOHandler
modifier|*
name|handler
decl_stmt|;
comment|// image options
DECL|member|quality
name|int
name|quality
decl_stmt|;
DECL|member|compression
name|int
name|compression
decl_stmt|;
DECL|member|gamma
name|float
name|gamma
decl_stmt|;
DECL|member|description
name|QString
name|description
decl_stmt|;
DECL|member|text
name|QString
name|text
decl_stmt|;
comment|// error
DECL|member|imageWriterError
name|QImageWriter
operator|::
name|ImageWriterError
name|imageWriterError
decl_stmt|;
DECL|member|errorString
name|QString
name|errorString
decl_stmt|;
DECL|member|q
name|QImageWriter
modifier|*
name|q
decl_stmt|;
block|}
end_block
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QImageWriterPrivate
name|QImageWriterPrivate
operator|::
name|QImageWriterPrivate
parameter_list|(
name|QImageWriter
modifier|*
name|qq
parameter_list|)
block|{
name|device
operator|=
literal|0
expr_stmt|;
name|deleteDevice
operator|=
literal|false
expr_stmt|;
name|handler
operator|=
literal|0
expr_stmt|;
name|quality
operator|=
operator|-
literal|1
expr_stmt|;
name|compression
operator|=
literal|0
expr_stmt|;
name|gamma
operator|=
literal|0.0
expr_stmt|;
name|imageWriterError
operator|=
name|QImageWriter
operator|::
name|UnknownError
expr_stmt|;
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageWriter
argument_list|,
name|QLatin1String
argument_list|(
literal|"Unknown error"
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|qq
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an empty QImageWriter object. Before writing, you must     call setFormat() to set an image format, then setDevice() or     setFileName(). */
end_comment
begin_constructor
DECL|function|QImageWriter
name|QImageWriter
operator|::
name|QImageWriter
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QImageWriter object using the device \a device and     image format \a format. */
end_comment
begin_constructor
DECL|function|QImageWriter
name|QImageWriter
operator|::
name|QImageWriter
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QImageWriter objects that will write to a file with     the name \a fileName, using the image format \a format. If \a     format is not provided, QImageWriter will detect the image format     by inspecting the extension of \a fileName. */
end_comment
begin_constructor
DECL|function|QImageWriter
name|QImageWriter
operator|::
name|QImageWriter
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QImageWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|QFile
modifier|*
name|file
init|=
operator|new
name|QFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|d
operator|->
name|device
operator|=
name|file
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructs the QImageWriter object. */
end_comment
begin_destructor
DECL|function|~QImageWriter
name|QImageWriter
operator|::
name|~
name|QImageWriter
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
operator|delete
name|d
operator|->
name|device
expr_stmt|;
operator|delete
name|d
operator|->
name|handler
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Sets the format QImageWriter will use when writing images, to \a     format. \a format is a case insensitive text string. Example:      \snippet code/src_gui_image_qimagewriter.cpp 0      You can call supportedImageFormats() for the full list of formats     QImageWriter supports.      \sa format() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QImageWriter
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|)
block|{
name|d
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format QImageWriter uses for writing images.      \sa setFormat() */
end_comment
begin_function
DECL|function|format
name|QByteArray
name|QImageWriter
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Sets QImageWriter's device to \a device. If a device has already     been set, the old device is removed from QImageWriter and is     otherwise left unchanged.      If the device is not already open, QImageWriter will attempt to     open the device in \l QIODevice::WriteOnly mode by calling     open(). Note that this does not work for certain devices, such as     QProcess, QTcpSocket and QUdpSocket, where more logic is required     to open the device.      \sa device(), setFileName() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QImageWriter
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|device
operator|&&
name|d
operator|->
name|deleteDevice
condition|)
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
operator|delete
name|d
operator|->
name|handler
expr_stmt|;
name|d
operator|->
name|handler
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the device currently assigned to QImageWriter, or 0 if no     device has been assigned. */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QImageWriter
operator|::
name|device
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the file name of QImageWriter to \a fileName. Internally,     QImageWriter will create a QFile and open it in \l     QIODevice::WriteOnly mode, and use this file when writing images.      \sa fileName(), setDevice() */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QImageWriter
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|setDevice
argument_list|(
operator|new
name|QFile
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If the currently assigned device is a QFile, or if setFileName()     has been called, this function returns the name of the file     QImageWriter writes to. Otherwise (i.e., if no device has been     assigned or the device is not a QFile), an empty QString is     returned.      \sa setFileName(), setDevice() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QImageWriter
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
name|QFile
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|device
argument_list|)
decl_stmt|;
return|return
name|file
condition|?
name|file
operator|->
name|fileName
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This is an image format specific function that sets the quality     level of the image to \a quality. For image formats that do not     support setting the quality, this value is ignored.      The value range of \a quality depends on the image format. For     example, the "jpeg" format supports a quality range from 0 (low     quality, high compression) to 100 (high quality, low compression).      \sa quality() */
end_comment
begin_function
DECL|function|setQuality
name|void
name|QImageWriter
operator|::
name|setQuality
parameter_list|(
name|int
name|quality
parameter_list|)
block|{
name|d
operator|->
name|quality
operator|=
name|quality
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the quality level of the image.      \sa setQuality() */
end_comment
begin_function
DECL|function|quality
name|int
name|QImageWriter
operator|::
name|quality
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|quality
return|;
block|}
end_function
begin_comment
comment|/*!     This is an image format specific function that set the compression     of an image. For image formats that do not support setting the     compression, this value is ignored.      The value range of \a compression depends on the image format. For     example, the "tiff" format supports two values, 0(no compression) and     1(LZW-compression).      \sa compression() */
end_comment
begin_function
DECL|function|setCompression
name|void
name|QImageWriter
operator|::
name|setCompression
parameter_list|(
name|int
name|compression
parameter_list|)
block|{
name|d
operator|->
name|compression
operator|=
name|compression
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the compression of the image.      \sa setCompression() */
end_comment
begin_function
DECL|function|compression
name|int
name|QImageWriter
operator|::
name|compression
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|compression
return|;
block|}
end_function
begin_comment
comment|/*!     This is an image format specific function that sets the gamma     level of the image to \a gamma. For image formats that do not     support setting the gamma level, this value is ignored.      The value range of \a gamma depends on the image format. For     example, the "png" format supports a gamma range from 0.0 to 1.0.      \sa quality() */
end_comment
begin_function
DECL|function|setGamma
name|void
name|QImageWriter
operator|::
name|setGamma
parameter_list|(
name|float
name|gamma
parameter_list|)
block|{
name|d
operator|->
name|gamma
operator|=
name|gamma
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the gamma level of the image.      \sa setGamma() */
end_comment
begin_function
DECL|function|gamma
name|float
name|QImageWriter
operator|::
name|gamma
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|gamma
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use setText() instead.      This is an image format specific function that sets the     description of the image to \a description. For image formats that     do not support setting the description, this value is ignored.      The contents of \a description depends on the image format.      \sa description() */
end_comment
begin_function
DECL|function|setDescription
name|void
name|QImageWriter
operator|::
name|setDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|d
operator|->
name|description
operator|=
name|description
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use QImageReader::text() instead.      Returns the description of the image.      \sa setDescription() */
end_comment
begin_function
DECL|function|description
name|QString
name|QImageWriter
operator|::
name|description
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|description
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the image text associated with the key \a key to     \a text. This is useful for storing copyright information     or other information about the image. Example:      \snippet code/src_gui_image_qimagewriter.cpp 1      If you want to store a single block of data     (e.g., a comment), you can pass an empty key, or use     a generic key like "Description".      The key and text will be embedded into the     image data after calling write().      Support for this option is implemented through     QImageIOHandler::Description.      \sa QImage::setText(), QImageReader::text() */
end_comment
begin_function
DECL|function|setText
name|void
name|QImageWriter
operator|::
name|setText
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|description
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|description
operator|+=
name|QLatin1String
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|d
operator|->
name|description
operator|+=
name|key
operator|.
name|simplified
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
operator|+
name|text
operator|.
name|simplified
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if QImageWriter can write the image; i.e., the image     format is supported and the assigned device is open for reading.      \sa write(), setDevice(), setFormat() */
end_comment
begin_function
DECL|function|canWrite
name|bool
name|QImageWriter
operator|::
name|canWrite
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|device
operator|&&
operator|!
name|d
operator|->
name|handler
operator|&&
operator|(
name|d
operator|->
name|handler
operator|=
name|createWriteHandlerHelper
argument_list|(
name|d
operator|->
name|device
argument_list|,
name|d
operator|->
name|format
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|imageWriterError
operator|=
name|QImageWriter
operator|::
name|UnsupportedFormatError
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageWriter
argument_list|,
name|QLatin1String
argument_list|(
literal|"Unsupported image format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|device
operator|&&
operator|!
name|d
operator|->
name|device
operator|->
name|isOpen
argument_list|()
condition|)
name|d
operator|->
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|device
operator|||
operator|!
name|d
operator|->
name|device
operator|->
name|isWritable
argument_list|()
condition|)
block|{
name|d
operator|->
name|imageWriterError
operator|=
name|QImageWriter
operator|::
name|DeviceError
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageWriter
argument_list|,
name|QLatin1String
argument_list|(
literal|"Device not writable"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Writes the image \a image to the assigned device or file     name. Returns true on success; otherwise returns false. If the     operation fails, you can call error() to find the type of error     that occurred, or errorString() to get a human readable     description of the error.      \sa canWrite(), error(), errorString() */
end_comment
begin_function
DECL|function|write
name|bool
name|QImageWriter
operator|::
name|write
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
if|if
condition|(
operator|!
name|canWrite
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Quality
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|Quality
argument_list|,
name|d
operator|->
name|quality
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|CompressionRatio
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|CompressionRatio
argument_list|,
name|d
operator|->
name|compression
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Gamma
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|Gamma
argument_list|,
name|d
operator|->
name|gamma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|description
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|QImageIOHandler
operator|::
name|Description
argument_list|)
condition|)
name|d
operator|->
name|handler
operator|->
name|setOption
argument_list|(
name|QImageIOHandler
operator|::
name|Description
argument_list|,
name|d
operator|->
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|handler
operator|->
name|write
argument_list|(
name|image
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|QFile
modifier|*
name|file
init|=
name|qobject_cast
argument_list|<
name|QFile
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|device
argument_list|)
condition|)
name|file
operator|->
name|flush
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of error that last occurred.      \sa ImageWriterError, errorString() */
end_comment
begin_function
DECL|function|error
name|QImageWriter
operator|::
name|ImageWriterError
name|QImageWriter
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|imageWriterError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a human readable description of the last error that occurred.      \sa error() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QImageWriter
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns true if the writer supports \a option; otherwise returns     false.      Different image formats support different options. Call this function to     determine whether a certain option is supported by the current format. For     example, the PNG format allows you to embed text into the image's metadata     (see text()).      \snippet code/src_gui_image_qimagewriter.cpp 2      Options can be tested after the writer has been associated with a format.      \sa QImageReader::supportsOption(), setFormat() */
end_comment
begin_function
DECL|function|supportsOption
name|bool
name|QImageWriter
operator|::
name|supportsOption
parameter_list|(
name|QImageIOHandler
operator|::
name|ImageOption
name|option
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|handler
operator|&&
operator|(
name|d
operator|->
name|handler
operator|=
name|createWriteHandlerHelper
argument_list|(
name|d
operator|->
name|device
argument_list|,
name|d
operator|->
name|format
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|imageWriterError
operator|=
name|QImageWriter
operator|::
name|UnsupportedFormatError
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|QImageWriter
argument_list|,
name|QLatin1String
argument_list|(
literal|"Unsupported image format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|handler
operator|->
name|supportsOption
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
end_ifndef
begin_function
DECL|function|supportedImageHandlerFormats
name|void
name|supportedImageHandlerFormats
parameter_list|(
name|QFactoryLoader
modifier|*
name|loader
parameter_list|,
name|QImageIOPlugin
operator|::
name|Capability
name|cap
parameter_list|,
name|QSet
argument_list|<
name|QByteArray
argument_list|>
modifier|*
name|result
parameter_list|)
block|{
typedef|typedef
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|PluginKeyMap
typedef|;
typedef|typedef
name|PluginKeyMap
operator|::
name|const_iterator
name|PluginKeyMapConstIterator
typedef|;
specifier|const
name|PluginKeyMap
name|keyMap
init|=
name|loader
operator|->
name|keyMap
argument_list|()
decl_stmt|;
specifier|const
name|PluginKeyMapConstIterator
name|cend
init|=
name|keyMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|QImageIOPlugin
modifier|*
name|plugin
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PluginKeyMapConstIterator
name|it
init|=
name|keyMap
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|cend
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|.
name|key
argument_list|()
operator|!=
name|i
condition|)
block|{
name|i
operator|=
name|it
operator|.
name|key
argument_list|()
expr_stmt|;
name|plugin
operator|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|loader
operator|->
name|instance
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QByteArray
name|key
init|=
name|it
operator|.
name|value
argument_list|()
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|plugin
operator|&&
operator|(
name|plugin
operator|->
name|capabilities
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
operator|&
name|cap
operator|)
operator|!=
literal|0
condition|)
name|result
operator|->
name|insert
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|supportedImageHandlerMimeTypes
name|void
name|supportedImageHandlerMimeTypes
parameter_list|(
name|QFactoryLoader
modifier|*
name|loader
parameter_list|,
name|QImageIOPlugin
operator|::
name|Capability
name|cap
parameter_list|,
name|QSet
argument_list|<
name|QByteArray
argument_list|>
modifier|*
name|result
parameter_list|)
block|{
name|QList
argument_list|<
name|QJsonObject
argument_list|>
name|metaDataList
init|=
name|loader
operator|->
name|metaData
argument_list|()
decl_stmt|;
specifier|const
name|int
name|pluginCount
init|=
name|metaDataList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pluginCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QJsonObject
name|metaData
init|=
name|metaDataList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|value
argument_list|(
name|QStringLiteral
argument_list|(
literal|"MetaData"
argument_list|)
argument_list|)
operator|.
name|toObject
argument_list|()
decl_stmt|;
specifier|const
name|QJsonArray
name|keys
init|=
name|metaData
operator|.
name|value
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Keys"
argument_list|)
argument_list|)
operator|.
name|toArray
argument_list|()
decl_stmt|;
specifier|const
name|QJsonArray
name|mimeTypes
init|=
name|metaData
operator|.
name|value
argument_list|(
name|QStringLiteral
argument_list|(
literal|"MimeTypes"
argument_list|)
argument_list|)
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|QImageIOPlugin
modifier|*
name|plugin
init|=
name|qobject_cast
argument_list|<
name|QImageIOPlugin
operator|*
argument_list|>
argument_list|(
name|loader
operator|->
name|instance
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|keyCount
init|=
name|keys
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|keyCount
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|plugin
operator|&&
operator|(
name|plugin
operator|->
name|capabilities
argument_list|(
literal|0
argument_list|,
name|keys
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
operator|&
name|cap
operator|)
operator|!=
literal|0
condition|)
name|result
operator|->
name|insert
argument_list|(
name|mimeTypes
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_IMAGEFORMATPLUGIN
end_comment
begin_comment
comment|/*!     Returns the list of image formats supported by QImageWriter.      By default, Qt can write the following formats:      \table     \header \li Format \li MIME type                    \li Description     \row    \li BMP    \li image/bmp                    \li Windows Bitmap     \row    \li JPG    \li image/jpeg                   \li Joint Photographic Experts Group     \row    \li PNG    \li image/png                    \li Portable Network Graphics     \row    \li PBM    \li image/x-portable-bitmap      \li Portable Bitmap     \row    \li PGM    \li image/x-portable-graymap     \li Portable Graymap     \row    \li PPM    \li image/x-portable-pixmap      \li Portable Pixmap     \row    \li XBM    \li image/x-xbitmap              \li X11 Bitmap     \row    \li XPM    \li image/x-xpixmap              \li X11 Pixmap     \endtable      Reading and writing SVG files is supported through the \l{Qt SVG} module.     The \l{Qt Image Formats} module provides support for additional image formats.      Note that the QApplication instance must be created before this function is     called.      \sa setFormat(), QImageReader::supportedImageFormats(), QImageIOPlugin */
end_comment
begin_function
DECL|function|supportedImageFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QImageWriter
operator|::
name|supportedImageFormats
parameter_list|()
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|formats
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_BMP
name|formats
operator|<<
literal|"bmp"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
name|formats
operator|<<
literal|"pbm"
operator|<<
literal|"pgm"
operator|<<
literal|"ppm"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
name|formats
operator|<<
literal|"xbm"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
name|formats
operator|<<
literal|"xpm"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
name|formats
operator|<<
literal|"png"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
name|formats
operator|<<
literal|"jpg"
operator|<<
literal|"jpeg"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMATPLUGIN
name|supportedImageHandlerFormats
argument_list|(
name|loader
argument_list|()
argument_list|,
name|QImageIOPlugin
operator|::
name|CanWrite
argument_list|,
operator|&
name|formats
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_IMAGEFORMATPLUGIN
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|sortedFormats
decl_stmt|;
for|for
control|(
name|QSet
argument_list|<
name|QByteArray
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|formats
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|formats
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|sortedFormats
operator|<<
operator|*
name|it
expr_stmt|;
name|qSort
argument_list|(
name|sortedFormats
argument_list|)
expr_stmt|;
return|return
name|sortedFormats
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of MIME types supported by QImageWriter.      Note that the QApplication instance must be created before this function is     called.      \sa supportedImageFormats(), QImageReader::supportedMimeTypes() */
end_comment
begin_function
DECL|function|supportedMimeTypes
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QImageWriter
operator|::
name|supportedMimeTypes
parameter_list|()
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|mimeTypes
decl_stmt|;
name|mimeTypes
operator|<<
literal|"image/bmp"
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PPM
name|mimeTypes
operator|<<
literal|"image/x-portable-bitmap"
expr_stmt|;
name|mimeTypes
operator|<<
literal|"image/x-portable-graymap"
expr_stmt|;
name|mimeTypes
operator|<<
literal|"image/x-portable-pixmap"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XBM
name|mimeTypes
operator|<<
literal|"image/x-xbitmap"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_XPM
name|mimeTypes
operator|<<
literal|"image/x-xpixmap"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_PNG
name|mimeTypes
operator|<<
literal|"image/png"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_JPEG
name|mimeTypes
operator|<<
literal|"image/jpeg"
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|supportedImageHandlerMimeTypes
argument_list|(
name|loader
argument_list|()
argument_list|,
name|QImageIOPlugin
operator|::
name|CanWrite
argument_list|,
operator|&
name|mimeTypes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_LIBRARY
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|sortedMimeTypes
decl_stmt|;
for|for
control|(
name|QSet
argument_list|<
name|QByteArray
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|mimeTypes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|mimeTypes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|sortedMimeTypes
operator|<<
operator|*
name|it
expr_stmt|;
name|qSort
argument_list|(
name|sortedMimeTypes
argument_list|)
expr_stmt|;
return|return
name|sortedMimeTypes
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
