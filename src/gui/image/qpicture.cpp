begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpicture.h"
end_include
begin_include
include|#
directive|include
file|<private/qpicture_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PICTURE
end_ifndef
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpaintengine_pic_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfont_p.h>
end_include
begin_include
include|#
directive|include
file|<qguiapplication.h>
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qimage.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|"qpainterpath.h"
end_include
begin_include
include|#
directive|include
file|"qpixmap.h"
end_include
begin_include
include|#
directive|include
file|"qregion.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|void
name|qt_format_text
parameter_list|(
specifier|const
name|QFont
modifier|&
name|fnt
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|_r
parameter_list|,
name|int
name|tf
parameter_list|,
specifier|const
name|QTextOption
modifier|*
name|opt
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|QRectF
modifier|*
name|brect
parameter_list|,
name|int
name|tabstops
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
name|tabarraylen
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     \class QPicture     \brief The QPicture class is a paint device that records and     replays QPainter commands.      \inmodule QtGui     \ingroup shared       A picture serializes painter commands to an IO device in a     platform-independent format. They are sometimes referred to as meta-files.      Qt pictures use a proprietary binary format. Unlike native picture     (meta-file) formats on many window systems, Qt pictures have no     limitations regarding their contents. Everything that can be     painted on a widget or pixmap (e.g., fonts, pixmaps, regions,     transformed graphics, etc.)  can also be stored in a picture.      QPicture is resolution independent, i.e. a QPicture can be     displayed on different devices (for example svg, pdf, ps, printer     and screen) looking the same. This is, for instance, needed for     WYSIWYG print preview. QPicture runs in the default system dpi,     and scales the painter to match differences in resolution     depending on the window system.      Example of how to record a picture:     \snippet picture/picture.cpp 0      Note that the list of painter commands is reset on each call to     the QPainter::begin() function.      Example of how to replay a picture:     \snippet picture/picture.cpp 1      Pictures can also be drawn using play(). Some basic data about a     picture is available, for example, size(), isNull() and     boundingRect().      \sa QMovie */
end_comment
begin_decl_stmt
DECL|variable|qt_mfhdr_tag
specifier|const
name|char
modifier|*
name|qt_mfhdr_tag
init|=
literal|"QPIC"
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qt_mfhdr_tag
comment|// header tag
end_comment
begin_decl_stmt
DECL|variable|mfhdr_maj
specifier|static
specifier|const
name|quint16
name|mfhdr_maj
init|=
literal|11
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|mfhdr_maj
comment|// major version #
end_comment
begin_decl_stmt
DECL|variable|mfhdr_min
specifier|static
specifier|const
name|quint16
name|mfhdr_min
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|mfhdr_min
comment|// minor version #
end_comment
begin_comment
comment|/*!     Constructs an empty picture.      The \a formatVersion parameter may be used to \e create a QPicture     that can be read by applications that are compiled with earlier     versions of Qt.      Note that the default formatVersion is -1 which signifies the     current release, i.e. for Qt 4.0 a formatVersion of 7 is the same     as the default formatVersion of -1.      Reading pictures generated by earlier versions of Qt is not     supported in Qt 4.0. */
end_comment
begin_constructor
DECL|function|QPicture
name|QPicture
operator|::
name|QPicture
parameter_list|(
name|int
name|formatVersion
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
member_init_list|,
name|d_ptr
argument_list|(
operator|new
name|QPicturePrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QPicture
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatVersion
operator|==
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QPicture: invalid format version 0"
argument_list|)
expr_stmt|;
comment|// still accept the 0 default from before Qt 3.0.
if|if
condition|(
name|formatVersion
operator|>
literal|0
operator|&&
name|formatVersion
operator|!=
operator|(
name|int
operator|)
name|mfhdr_maj
condition|)
block|{
name|d
operator|->
name|formatMajor
operator|=
name|formatVersion
expr_stmt|;
name|d
operator|->
name|formatMinor
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|formatOk
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|resetFormat
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a pic.      This constructor is fast thanks to \l{implicit sharing}. */
end_comment
begin_constructor
DECL|function|QPicture
name|QPicture
operator|::
name|QPicture
parameter_list|(
specifier|const
name|QPicture
modifier|&
name|pic
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
member_init_list|,
name|d_ptr
argument_list|(
name|pic
operator|.
name|d_ptr
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal */
end_comment
begin_constructor
DECL|function|QPicture
name|QPicture
operator|::
name|QPicture
parameter_list|(
name|QPicturePrivate
modifier|&
name|dptr
parameter_list|)
member_init_list|:
name|QPaintDevice
argument_list|()
member_init_list|,
name|d_ptr
argument_list|(
operator|&
name|dptr
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the picture. */
end_comment
begin_destructor
DECL|function|~QPicture
name|QPicture
operator|::
name|~
name|QPicture
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|devType
name|int
name|QPicture
operator|::
name|devType
parameter_list|()
specifier|const
block|{
return|return
name|QInternal
operator|::
name|Picture
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPicture::isNull() const      Returns true if the picture contains no data; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn uint QPicture::size() const      Returns the size of the picture data.      \sa data() */
end_comment
begin_comment
comment|/*!     \fn const char* QPicture::data() const      Returns a pointer to the picture data. The pointer is only valid     until the next non-const function is called on this picture. The     returned pointer is 0 if the picture contains no data.      \sa size(), isNull() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QPicture
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|size
name|uint
name|QPicture
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|data
specifier|const
name|char
modifier|*
name|QPicture
operator|::
name|data
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|detach
name|void
name|QPicture
operator|::
name|detach
parameter_list|()
block|{
name|d_ptr
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isDetached
name|bool
name|QPicture
operator|::
name|isDetached
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture data directly from \a data and \a size. This     function copies the input data.      \sa data(), size() */
end_comment
begin_function
DECL|function|setData
name|void
name|QPicture
operator|::
name|setData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|setData
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|resetFormat
argument_list|()
expr_stmt|;
comment|// we'll have to check
block|}
end_function
begin_comment
comment|/*!     Loads a picture from the file specified by \a fileName and returns     true if successful; otherwise invalidates the picture and returns false.      Please note that the \a format parameter has been deprecated and     will have no effect.      \sa save() */
end_comment
begin_function
DECL|function|load
name|bool
name|QPicture
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QFile
name|f
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|operator
name|=
argument_list|(
name|QPicture
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|load
argument_list|(
operator|&
name|f
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a dev is the device to use for loading. */
end_comment
begin_function
DECL|function|load
name|bool
name|QPicture
operator|::
name|load
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_PICTUREIO
name|QPictureIO
name|io
argument_list|(
name|dev
argument_list|,
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|io
operator|.
name|read
argument_list|()
condition|)
block|{
name|operator
name|=
argument_list|(
name|io
operator|.
name|picture
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"QPicture::load: No such picture format: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|operator
name|=
argument_list|(
name|QPicture
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|detach
argument_list|()
expr_stmt|;
name|QByteArray
name|a
init|=
name|dev
operator|->
name|readAll
argument_list|()
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|setData
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// set byte array in buffer
return|return
name|d_func
argument_list|()
operator|->
name|checkFormat
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Saves a picture to the file specified by \a fileName and returns     true if successful; otherwise returns false.      Please note that the \a format parameter has been deprecated and     will have no effect.      \sa load() */
end_comment
begin_function
DECL|function|save
name|bool
name|QPicture
operator|::
name|save
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPicture::save: still being painted on. "
literal|"Call QPainter::end() first"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|format
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_PICTUREIO
name|QPictureIO
name|io
argument_list|(
name|fileName
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|io
operator|.
name|write
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|operator
name|=
argument_list|(
name|io
operator|.
name|picture
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
condition|)
else|#
directive|else
name|bool
name|result
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
block|{
name|qWarning
argument_list|(
literal|"QPicture::save: No such picture format: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|QFile
name|f
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|save
argument_list|(
operator|&
name|f
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a dev is the device to use for saving. */
end_comment
begin_function
DECL|function|save
name|bool
name|QPicture
operator|::
name|save
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
if|if
condition|(
name|paintingActive
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPicture::save: still being painted on. "
literal|"Call QPainter::end() first"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|format
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_PICTUREIO
name|QPictureIO
name|io
argument_list|(
name|dev
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|io
operator|.
name|write
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|operator
name|=
argument_list|(
name|io
operator|.
name|picture
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
condition|)
else|#
directive|else
name|bool
name|result
init|=
literal|false
decl_stmt|;
endif|#
directive|endif
block|{
name|qWarning
argument_list|(
literal|"QPicture::save: No such picture format: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|dev
operator|->
name|write
argument_list|(
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
argument_list|,
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the picture's bounding rectangle or an invalid rectangle     if the picture contains no data. */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QPicture
operator|::
name|boundingRect
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QPicture
argument_list|)
expr_stmt|;
comment|// Use override rect where possible.
if|if
condition|(
operator|!
name|d
operator|->
name|override_rect
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|override_rect
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|formatOk
condition|)
name|d_ptr
operator|->
name|checkFormat
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|brect
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture's bounding rectangle to \a r. The automatically     calculated value is overridden. */
end_comment
begin_function
DECL|function|setBoundingRect
name|void
name|QPicture
operator|::
name|setBoundingRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|override_rect
operator|=
name|r
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Replays the picture using \a painter, and returns true if     successful; otherwise returns false.      This function does exactly the same as QPainter::drawPicture()     with (x, y) = (0, 0). */
end_comment
begin_function
DECL|function|play
name|bool
name|QPicture
operator|::
name|play
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPicture
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pictb
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
comment|// nothing recorded
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|formatOk
operator|&&
operator|!
name|d
operator|->
name|checkFormat
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|pictb
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
comment|// open buffer device
name|QDataStream
name|s
decl_stmt|;
name|s
operator|.
name|setDevice
argument_list|(
operator|&
name|d
operator|->
name|pictb
argument_list|)
expr_stmt|;
comment|// attach data stream to buffer
name|s
operator|.
name|device
argument_list|()
operator|->
name|seek
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|// go directly to the data
name|s
operator|.
name|setVersion
argument_list|(
name|d
operator|->
name|formatMajor
operator|==
literal|4
condition|?
literal|3
else|:
name|d
operator|->
name|formatMajor
argument_list|)
expr_stmt|;
name|quint8
name|c
decl_stmt|,
name|clen
decl_stmt|;
name|quint32
name|nrecords
decl_stmt|;
name|s
operator|>>
name|c
operator|>>
name|clen
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|c
operator|==
name|QPicturePrivate
operator|::
name|PdcBegin
argument_list|)
expr_stmt|;
comment|// bounding rect was introduced in ver 4. Read in checkFormat().
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|>=
literal|4
condition|)
block|{
name|qint32
name|dummy
decl_stmt|;
name|s
operator|>>
name|dummy
operator|>>
name|dummy
operator|>>
name|dummy
operator|>>
name|dummy
expr_stmt|;
block|}
name|s
operator|>>
name|nrecords
expr_stmt|;
if|if
condition|(
operator|!
name|exec
argument_list|(
name|painter
argument_list|,
name|s
argument_list|,
name|nrecords
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPicture::play: Format error"
argument_list|)
expr_stmt|;
name|d
operator|->
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
comment|// no end-command
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// QFakeDevice is used to create fonts with a custom DPI
end_comment
begin_comment
comment|//
end_comment
begin_class
DECL|class|QFakeDevice
class|class
name|QFakeDevice
super|:
specifier|public
name|QPaintDevice
block|{
public|public:
DECL|function|QFakeDevice
name|QFakeDevice
parameter_list|()
block|{
name|dpi_x
operator|=
name|qt_defaultDpiX
argument_list|()
expr_stmt|;
name|dpi_y
operator|=
name|qt_defaultDpiY
argument_list|()
expr_stmt|;
block|}
DECL|function|setDpiX
name|void
name|setDpiX
parameter_list|(
name|int
name|dpi
parameter_list|)
block|{
name|dpi_x
operator|=
name|dpi
expr_stmt|;
block|}
DECL|function|setDpiY
name|void
name|setDpiY
parameter_list|(
name|int
name|dpi
parameter_list|)
block|{
name|dpi_y
operator|=
name|dpi
expr_stmt|;
block|}
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|paintEngine
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|metric
name|int
name|metric
parameter_list|(
name|PaintDeviceMetric
name|m
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|PdmPhysicalDpiX
case|:
case|case
name|PdmDpiX
case|:
return|return
name|dpi_x
return|;
case|case
name|PdmPhysicalDpiY
case|:
case|case
name|PdmDpiY
case|:
return|return
name|dpi_y
return|;
default|default:
return|return
name|QPaintDevice
operator|::
name|metric
argument_list|(
name|m
argument_list|)
return|;
block|}
block|}
private|private:
DECL|member|dpi_x
name|int
name|dpi_x
decl_stmt|;
DECL|member|dpi_y
name|int
name|dpi_y
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!   \internal   Iterates over the internal picture data and draws the picture using   \a painter. */
end_comment
begin_function
DECL|function|exec
name|bool
name|QPicture
operator|::
name|exec
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
name|QDataStream
modifier|&
name|s
parameter_list|,
name|int
name|nrecords
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QPicture
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|int
name|strm_pos
decl_stmt|;
endif|#
directive|endif
name|quint8
name|c
decl_stmt|;
comment|// command id
name|quint8
name|tiny_len
decl_stmt|;
comment|// 8-bit length descriptor
name|qint32
name|len
decl_stmt|;
comment|// 32-bit length descriptor
name|qint16
name|i_16
decl_stmt|,
name|i1_16
decl_stmt|,
name|i2_16
decl_stmt|;
comment|// parameters...
name|qint8
name|i_8
decl_stmt|;
name|quint32
name|ul
decl_stmt|;
name|double
name|dbl
decl_stmt|;
name|bool
name|bl
decl_stmt|;
name|QByteArray
name|str1
decl_stmt|;
name|QString
name|str
decl_stmt|;
name|QPointF
name|p
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|QPoint
name|ip
decl_stmt|,
name|ip1
decl_stmt|,
name|ip2
decl_stmt|;
name|QRect
name|ir
decl_stmt|;
name|QRectF
name|r
decl_stmt|;
name|QPolygonF
name|a
decl_stmt|;
name|QPolygon
name|ia
decl_stmt|;
name|QColor
name|color
decl_stmt|;
name|QFont
name|font
decl_stmt|;
name|QPen
name|pen
decl_stmt|;
name|QBrush
name|brush
decl_stmt|;
name|QRegion
name|rgn
decl_stmt|;
name|QMatrix
name|wmatrix
decl_stmt|;
name|QTransform
name|matrix
decl_stmt|;
name|QTransform
name|worldMatrix
init|=
name|painter
operator|->
name|transform
argument_list|()
decl_stmt|;
name|worldMatrix
operator|.
name|scale
argument_list|(
name|qreal
argument_list|(
name|painter
operator|->
name|device
argument_list|()
operator|->
name|logicalDpiX
argument_list|()
argument_list|)
operator|/
name|qreal
argument_list|(
name|qt_defaultDpiX
argument_list|()
argument_list|)
argument_list|,
name|qreal
argument_list|(
name|painter
operator|->
name|device
argument_list|()
operator|->
name|logicalDpiY
argument_list|()
argument_list|)
operator|/
name|qreal
argument_list|(
name|qt_defaultDpiY
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setTransform
argument_list|(
name|worldMatrix
argument_list|)
expr_stmt|;
while|while
condition|(
name|nrecords
operator|--
operator|&&
operator|!
name|s
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|s
operator|>>
name|c
expr_stmt|;
comment|// read cmd
name|s
operator|>>
name|tiny_len
expr_stmt|;
comment|// read param length
if|if
condition|(
name|tiny_len
operator|==
literal|255
condition|)
comment|// longer than 254 bytes
name|s
operator|>>
name|len
expr_stmt|;
else|else
name|len
operator|=
name|tiny_len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|strm_pos
operator|=
name|s
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
comment|// exec cmd
case|case
name|QPicturePrivate
operator|::
name|PdcNOP
case|:
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPoint
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ip
expr_stmt|;
name|painter
operator|->
name|drawPoint
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|p
expr_stmt|;
name|painter
operator|->
name|drawPoint
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPoints
case|:
comment|// ## implement me in the picture paint engine
comment|//                 s>> a>> i1_32>> i2_32;
comment|//                 painter->drawPoints(a.mid(i1_32, i2_32));
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPath
case|:
block|{
name|QPainterPath
name|path
decl_stmt|;
name|s
operator|>>
name|path
expr_stmt|;
name|painter
operator|->
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QPicturePrivate
operator|::
name|PdcDrawLine
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ip1
operator|>>
name|ip2
expr_stmt|;
name|painter
operator|->
name|drawLine
argument_list|(
name|ip1
argument_list|,
name|ip2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|p1
operator|>>
name|p2
expr_stmt|;
name|painter
operator|->
name|drawLine
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawRect
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
name|painter
operator|->
name|drawRect
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawRoundRect
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
operator|>>
name|i1_16
operator|>>
name|i2_16
expr_stmt|;
name|painter
operator|->
name|drawRoundedRect
argument_list|(
name|ir
argument_list|,
name|i1_16
argument_list|,
name|i2_16
argument_list|,
name|Qt
operator|::
name|RelativeSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
operator|>>
name|i1_16
operator|>>
name|i2_16
expr_stmt|;
name|painter
operator|->
name|drawRoundedRect
argument_list|(
name|r
argument_list|,
name|i1_16
argument_list|,
name|i2_16
argument_list|,
name|Qt
operator|::
name|RelativeSize
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawEllipse
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|painter
operator|->
name|drawEllipse
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
name|painter
operator|->
name|drawEllipse
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawArc
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|r
operator|=
name|ir
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
block|}
name|s
operator|>>
name|i1_16
operator|>>
name|i2_16
expr_stmt|;
name|painter
operator|->
name|drawArc
argument_list|(
name|r
argument_list|,
name|i1_16
argument_list|,
name|i2_16
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPie
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|r
operator|=
name|ir
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
block|}
name|s
operator|>>
name|i1_16
operator|>>
name|i2_16
expr_stmt|;
name|painter
operator|->
name|drawPie
argument_list|(
name|r
argument_list|,
name|i1_16
argument_list|,
name|i2_16
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawChord
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|r
operator|=
name|ir
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
block|}
name|s
operator|>>
name|i1_16
operator|>>
name|i2_16
expr_stmt|;
name|painter
operator|->
name|drawChord
argument_list|(
name|r
argument_list|,
name|i1_16
argument_list|,
name|i2_16
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawLineSegments
case|:
name|s
operator|>>
name|ia
expr_stmt|;
name|painter
operator|->
name|drawLines
argument_list|(
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPolyline
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ia
expr_stmt|;
name|painter
operator|->
name|drawPolyline
argument_list|(
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|a
expr_stmt|;
name|painter
operator|->
name|drawPolyline
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPolygon
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ia
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|drawPolygon
argument_list|(
name|ia
argument_list|,
name|i_8
condition|?
name|Qt
operator|::
name|WindingFill
else|:
name|Qt
operator|::
name|OddEvenFill
argument_list|)
expr_stmt|;
name|a
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|a
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|drawPolygon
argument_list|(
name|a
argument_list|,
name|i_8
condition|?
name|Qt
operator|::
name|WindingFill
else|:
name|Qt
operator|::
name|OddEvenFill
argument_list|)
expr_stmt|;
name|a
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawCubicBezier
case|:
block|{
name|s
operator|>>
name|ia
expr_stmt|;
name|QPainterPath
name|path
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|ia
operator|.
name|size
argument_list|()
operator|==
literal|4
argument_list|)
expr_stmt|;
name|path
operator|.
name|moveTo
argument_list|(
name|ia
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|.
name|cubicTo
argument_list|(
name|ia
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ia
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ia
operator|.
name|at
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|strokePath
argument_list|(
name|path
argument_list|,
name|painter
operator|->
name|pen
argument_list|()
argument_list|)
expr_stmt|;
name|a
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawText
case|:
name|s
operator|>>
name|ip
operator|>>
name|str1
expr_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|ip
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|str1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawTextFormatted
case|:
name|s
operator|>>
name|ir
operator|>>
name|i_16
operator|>>
name|str1
expr_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|ir
argument_list|,
name|i_16
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|str1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawText2
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ip
operator|>>
name|str
expr_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|ip
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|p
operator|>>
name|str
expr_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawText2Formatted
case|:
name|s
operator|>>
name|ir
expr_stmt|;
name|s
operator|>>
name|i_16
expr_stmt|;
name|s
operator|>>
name|str
expr_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|ir
argument_list|,
name|i_16
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawTextItem
case|:
block|{
name|s
operator|>>
name|p
operator|>>
name|str
operator|>>
name|font
operator|>>
name|ul
expr_stmt|;
comment|// the text layout direction is not used here because it's already
comment|// aligned when QPicturePaintEngine::drawTextItem() serializes the
comment|// drawText() call, therefore ul is unsed in this context
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|>=
literal|9
condition|)
block|{
name|s
operator|>>
name|dbl
expr_stmt|;
name|QFont
name|fnt
argument_list|(
name|font
argument_list|)
decl_stmt|;
if|if
condition|(
name|dbl
operator|!=
literal|1.0
condition|)
block|{
name|QFakeDevice
name|fake
decl_stmt|;
name|fake
operator|.
name|setDpiX
argument_list|(
name|qRound
argument_list|(
name|dbl
operator|*
name|qt_defaultDpiX
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fake
operator|.
name|setDpiY
argument_list|(
name|qRound
argument_list|(
name|dbl
operator|*
name|qt_defaultDpiY
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fnt
operator|=
name|QFont
argument_list|(
name|font
argument_list|,
operator|&
name|fake
argument_list|)
expr_stmt|;
block|}
name|qreal
name|justificationWidth
decl_stmt|;
name|s
operator|>>
name|justificationWidth
expr_stmt|;
name|int
name|flags
init|=
name|Qt
operator|::
name|TextSingleLine
operator||
name|Qt
operator|::
name|TextDontClip
operator||
name|Qt
operator|::
name|TextForceLeftToRight
decl_stmt|;
name|QSizeF
name|size
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|justificationWidth
operator|>
literal|0
condition|)
block|{
name|size
operator|.
name|setWidth
argument_list|(
name|justificationWidth
argument_list|)
expr_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|TextJustificationForced
expr_stmt|;
name|flags
operator||=
name|Qt
operator|::
name|AlignJustify
expr_stmt|;
block|}
name|QFontMetrics
name|fm
argument_list|(
name|fnt
argument_list|)
decl_stmt|;
name|QPointF
name|pt
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
operator|-
name|fm
operator|.
name|ascent
argument_list|()
argument_list|)
decl_stmt|;
name|qt_format_text
argument_list|(
name|fnt
argument_list|,
name|QRectF
argument_list|(
name|pt
argument_list|,
name|size
argument_list|)
argument_list|,
name|flags
argument_list|,
comment|/*opt*/
literal|0
argument_list|,
name|str
argument_list|,
comment|/*brect=*/
literal|0
argument_list|,
comment|/*tabstops=*/
literal|0
argument_list|,
comment|/*...*/
literal|0
argument_list|,
comment|/*tabarraylen=*/
literal|0
argument_list|,
name|painter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qt_format_text
argument_list|(
name|font
argument_list|,
name|QRectF
argument_list|(
name|p
argument_list|,
name|QSizeF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|TextSingleLine
operator||
name|Qt
operator|::
name|TextDontClip
argument_list|,
comment|/*opt*/
literal|0
argument_list|,
name|str
argument_list|,
comment|/*brect=*/
literal|0
argument_list|,
comment|/*tabstops=*/
literal|0
argument_list|,
comment|/*...*/
literal|0
argument_list|,
comment|/*tabarraylen=*/
literal|0
argument_list|,
name|painter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QPicturePrivate
operator|::
name|PdcDrawPixmap
case|:
block|{
name|QPixmap
name|pixmap
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<
literal|4
condition|)
block|{
name|s
operator|>>
name|ip
operator|>>
name|pixmap
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|ip
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
operator|>>
name|pixmap
expr_stmt|;
name|painter
operator|->
name|drawPixmap
argument_list|(
name|ir
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRectF
name|sr
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|in_memory_only
condition|)
block|{
name|int
name|index
decl_stmt|;
name|s
operator|>>
name|r
operator|>>
name|index
operator|>>
name|sr
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|d
operator|->
name|pixmap_list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|pixmap
operator|=
name|d
operator|->
name|pixmap_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
operator|>>
name|pixmap
operator|>>
name|sr
expr_stmt|;
block|}
name|painter
operator|->
name|drawPixmap
argument_list|(
name|r
argument_list|,
name|pixmap
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawTiledPixmap
case|:
block|{
name|QPixmap
name|pixmap
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|in_memory_only
condition|)
block|{
name|int
name|index
decl_stmt|;
name|s
operator|>>
name|r
operator|>>
name|index
operator|>>
name|p
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|d
operator|->
name|pixmap_list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|pixmap
operator|=
name|d
operator|->
name|pixmap_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
operator|>>
name|pixmap
operator|>>
name|p
expr_stmt|;
block|}
name|painter
operator|->
name|drawTiledPixmap
argument_list|(
name|r
argument_list|,
name|pixmap
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcDrawImage
case|:
block|{
name|QImage
name|image
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<
literal|4
condition|)
block|{
name|s
operator|>>
name|p
operator|>>
name|image
expr_stmt|;
name|painter
operator|->
name|drawImage
argument_list|(
name|p
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
operator|>>
name|image
expr_stmt|;
name|painter
operator|->
name|drawImage
argument_list|(
name|ir
argument_list|,
name|image
argument_list|,
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ir
operator|.
name|width
argument_list|()
argument_list|,
name|ir
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QRectF
name|sr
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|in_memory_only
condition|)
block|{
name|int
name|index
decl_stmt|;
name|s
operator|>>
name|r
operator|>>
name|index
operator|>>
name|sr
operator|>>
name|ul
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|d
operator|->
name|image_list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|image
operator|=
name|d
operator|->
name|image_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
operator|>>
name|image
operator|>>
name|sr
operator|>>
name|ul
expr_stmt|;
block|}
name|painter
operator|->
name|drawImage
argument_list|(
name|r
argument_list|,
name|image
argument_list|,
name|sr
argument_list|,
name|Qt
operator|::
name|ImageConversionFlags
argument_list|(
name|ul
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcBegin
case|:
name|s
operator|>>
name|ul
expr_stmt|;
comment|// number of records
if|if
condition|(
operator|!
name|exec
argument_list|(
name|painter
argument_list|,
name|s
argument_list|,
name|ul
argument_list|)
condition|)
return|return
literal|false
return|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcEnd
case|:
if|if
condition|(
name|nrecords
operator|==
literal|0
condition|)
return|return
literal|true
return|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSave
case|:
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcRestore
case|:
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetBkColor
case|:
name|s
operator|>>
name|color
expr_stmt|;
name|painter
operator|->
name|setBackground
argument_list|(
name|color
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetBkMode
case|:
name|s
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|setBackgroundMode
argument_list|(
operator|(
name|Qt
operator|::
name|BGMode
operator|)
name|i_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetROP
case|:
comment|// NOP
name|s
operator|>>
name|i_8
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetBrushOrigin
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ip
expr_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|p
expr_stmt|;
name|painter
operator|->
name|setBrushOrigin
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetFont
case|:
name|s
operator|>>
name|font
expr_stmt|;
name|painter
operator|->
name|setFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetPen
case|:
if|if
condition|(
name|d
operator|->
name|in_memory_only
condition|)
block|{
name|int
name|index
decl_stmt|;
name|s
operator|>>
name|index
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|d
operator|->
name|pen_list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|pen
operator|=
name|d
operator|->
name|pen_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|pen
expr_stmt|;
block|}
name|painter
operator|->
name|setPen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetBrush
case|:
if|if
condition|(
name|d
operator|->
name|in_memory_only
condition|)
block|{
name|int
name|index
decl_stmt|;
name|s
operator|>>
name|index
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|d
operator|->
name|brush_list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|brush
operator|=
name|d
operator|->
name|brush_list
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|brush
expr_stmt|;
block|}
name|painter
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetVXform
case|:
name|s
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|setViewTransformEnabled
argument_list|(
name|i_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetWindow
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|painter
operator|->
name|setWindow
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
name|painter
operator|->
name|setWindow
argument_list|(
name|r
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetViewport
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|<=
literal|5
condition|)
block|{
name|s
operator|>>
name|ir
expr_stmt|;
name|painter
operator|->
name|setViewport
argument_list|(
name|ir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|r
expr_stmt|;
name|painter
operator|->
name|setViewport
argument_list|(
name|r
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetWXform
case|:
name|s
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|setMatrixEnabled
argument_list|(
name|i_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetWMatrix
case|:
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|>=
literal|8
condition|)
block|{
name|s
operator|>>
name|matrix
operator|>>
name|i_8
expr_stmt|;
block|}
else|else
block|{
name|s
operator|>>
name|wmatrix
operator|>>
name|i_8
expr_stmt|;
name|matrix
operator|=
name|QTransform
argument_list|(
name|wmatrix
argument_list|)
expr_stmt|;
block|}
comment|// i_8 is always false due to updateXForm() in qpaintengine_pic.cpp
name|painter
operator|->
name|setTransform
argument_list|(
name|matrix
operator|*
name|worldMatrix
argument_list|,
name|i_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetClip
case|:
name|s
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|setClipping
argument_list|(
name|i_8
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetClipRegion
case|:
name|s
operator|>>
name|rgn
operator|>>
name|i_8
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|formatMajor
operator|>=
literal|9
condition|)
block|{
name|painter
operator|->
name|setClipRegion
argument_list|(
name|rgn
argument_list|,
name|Qt
operator|::
name|ClipOperation
argument_list|(
name|i_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|painter
operator|->
name|setClipRegion
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetClipPath
case|:
block|{
name|QPainterPath
name|path
decl_stmt|;
name|s
operator|>>
name|path
operator|>>
name|i_8
expr_stmt|;
name|painter
operator|->
name|setClipPath
argument_list|(
name|path
argument_list|,
name|Qt
operator|::
name|ClipOperation
argument_list|(
name|i_8
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QPicturePrivate
operator|::
name|PdcSetRenderHint
case|:
name|s
operator|>>
name|ul
expr_stmt|;
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|Antialiasing
argument_list|,
name|bool
argument_list|(
name|ul
operator|&
name|QPainter
operator|::
name|Antialiasing
argument_list|)
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setRenderHint
argument_list|(
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|,
name|bool
argument_list|(
name|ul
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetCompositionMode
case|:
name|s
operator|>>
name|ul
expr_stmt|;
name|painter
operator|->
name|setCompositionMode
argument_list|(
operator|(
name|QPainter
operator|::
name|CompositionMode
operator|)
name|ul
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetClipEnabled
case|:
name|s
operator|>>
name|bl
expr_stmt|;
name|painter
operator|->
name|setClipping
argument_list|(
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPicturePrivate
operator|::
name|PdcSetOpacity
case|:
name|s
operator|>>
name|dbl
expr_stmt|;
name|painter
operator|->
name|setOpacity
argument_list|(
name|qreal
argument_list|(
name|dbl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QPicture::play: Invalid command %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
comment|// skip unknown command
name|s
operator|.
name|device
argument_list|()
operator|->
name|seek
argument_list|(
name|s
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
comment|//qDebug("device->at(): %i, strm_pos: %i len: %i", (int)s.device()->pos(), strm_pos, len);
name|Q_ASSERT
argument_list|(
name|qint32
argument_list|(
name|s
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
operator|-
name|strm_pos
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Internal implementation of the virtual QPaintDevice::metric()     function.      A picture has the following hard-coded values: numcolors=16777216     and depth=24.      \a m is the metric to get. */
end_comment
begin_function
DECL|function|metric
name|int
name|QPicture
operator|::
name|metric
parameter_list|(
name|PaintDeviceMetric
name|m
parameter_list|)
specifier|const
block|{
name|int
name|val
decl_stmt|;
name|QRect
name|brect
init|=
name|boundingRect
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|PdmWidth
case|:
name|val
operator|=
name|brect
operator|.
name|width
argument_list|()
expr_stmt|;
break|break;
case|case
name|PdmHeight
case|:
name|val
operator|=
name|brect
operator|.
name|height
argument_list|()
expr_stmt|;
break|break;
case|case
name|PdmWidthMM
case|:
name|val
operator|=
name|int
argument_list|(
literal|25.4
operator|/
name|qt_defaultDpiX
argument_list|()
operator|*
name|brect
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PdmHeightMM
case|:
name|val
operator|=
name|int
argument_list|(
literal|25.4
operator|/
name|qt_defaultDpiY
argument_list|()
operator|*
name|brect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PdmDpiX
case|:
case|case
name|PdmPhysicalDpiX
case|:
name|val
operator|=
name|qt_defaultDpiX
argument_list|()
expr_stmt|;
break|break;
case|case
name|PdmDpiY
case|:
case|case
name|PdmPhysicalDpiY
case|:
name|val
operator|=
name|qt_defaultDpiY
argument_list|()
expr_stmt|;
break|break;
case|case
name|PdmNumColors
case|:
name|val
operator|=
literal|16777216
expr_stmt|;
break|break;
case|case
name|PdmDepth
case|:
name|val
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|PdmDevicePixelRatio
case|:
name|val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|val
operator|=
literal|0
expr_stmt|;
name|qWarning
argument_list|(
literal|"QPicture::metric: Invalid metric command"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPicture::detach()     \internal     Detaches from shared picture data and makes sure that this picture     is the only one referring to the data.      If multiple pictures share common data, this picture makes a copy     of the data and detaches itself from the sharing mechanism.     Nothing is done if there is just a single reference. */
end_comment
begin_comment
comment|/*! \fn bool QPicture::isDetached() const \internal */
end_comment
begin_comment
comment|/*!     Assigns picture \a p to this picture and returns a reference to     this picture. */
end_comment
begin_function
DECL|function|operator =
name|QPicture
modifier|&
name|QPicture
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QPicture
modifier|&
name|p
parameter_list|)
block|{
name|d_ptr
operator|=
name|p
operator|.
name|d_ptr
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QPicture::swap(QPicture&other)     \since 4.8      Swaps picture \a other with this picture. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!   \internal    Constructs a QPicturePrivate */
end_comment
begin_constructor
DECL|function|QPicturePrivate
name|QPicturePrivate
operator|::
name|QPicturePrivate
parameter_list|()
member_init_list|:
name|in_memory_only
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \internal    Copy-Constructs a QPicturePrivate. Needed when detaching. */
end_comment
begin_constructor
DECL|function|QPicturePrivate
name|QPicturePrivate
operator|::
name|QPicturePrivate
parameter_list|(
specifier|const
name|QPicturePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|trecs
argument_list|(
name|other
operator|.
name|trecs
argument_list|)
member_init_list|,
name|formatOk
argument_list|(
name|other
operator|.
name|formatOk
argument_list|)
member_init_list|,
name|formatMinor
argument_list|(
name|other
operator|.
name|formatMinor
argument_list|)
member_init_list|,
name|brect
argument_list|(
name|other
operator|.
name|brect
argument_list|)
member_init_list|,
name|override_rect
argument_list|(
name|other
operator|.
name|override_rect
argument_list|)
member_init_list|,
name|in_memory_only
argument_list|(
literal|false
argument_list|)
block|{
name|pictb
operator|.
name|setData
argument_list|(
name|other
operator|.
name|pictb
operator|.
name|data
argument_list|()
argument_list|,
name|other
operator|.
name|pictb
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|pictb
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|pictb
operator|.
name|open
argument_list|(
name|other
operator|.
name|pictb
operator|.
name|openMode
argument_list|()
argument_list|)
expr_stmt|;
name|pictb
operator|.
name|seek
argument_list|(
name|other
operator|.
name|pictb
operator|.
name|pos
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!   \internal    Sets formatOk to false and resets the format version numbers to default */
end_comment
begin_function
DECL|function|resetFormat
name|void
name|QPicturePrivate
operator|::
name|resetFormat
parameter_list|()
block|{
name|formatOk
operator|=
literal|false
expr_stmt|;
name|formatMajor
operator|=
name|mfhdr_maj
expr_stmt|;
name|formatMinor
operator|=
name|mfhdr_min
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Checks data integrity and format version number. Set formatOk to   true on success, to false otherwise. Returns the resulting formatOk   value. */
end_comment
begin_function
DECL|function|checkFormat
name|bool
name|QPicturePrivate
operator|::
name|checkFormat
parameter_list|()
block|{
name|resetFormat
argument_list|()
expr_stmt|;
comment|// can't check anything in an empty buffer
if|if
condition|(
name|pictb
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|pictb
operator|.
name|isOpen
argument_list|()
condition|)
return|return
literal|false
return|;
name|pictb
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
comment|// open buffer device
name|QDataStream
name|s
decl_stmt|;
name|s
operator|.
name|setDevice
argument_list|(
operator|&
name|pictb
argument_list|)
expr_stmt|;
comment|// attach data stream to buffer
name|char
name|mf_id
index|[
literal|4
index|]
decl_stmt|;
comment|// picture header tag
name|s
operator|.
name|readRawData
argument_list|(
name|mf_id
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// read actual tag
if|if
condition|(
name|memcmp
argument_list|(
name|mf_id
argument_list|,
name|qt_mfhdr_tag
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// wrong header id
name|qWarning
argument_list|(
literal|"QPicturePaintEngine::checkFormat: Incorrect header"
argument_list|)
expr_stmt|;
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|cs_start
init|=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
decl_stmt|;
comment|// pos of checksum word
name|int
name|data_start
init|=
name|cs_start
operator|+
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
decl_stmt|;
name|quint16
name|cs
decl_stmt|,
name|ccs
decl_stmt|;
name|QByteArray
name|buf
init|=
name|pictb
operator|.
name|buffer
argument_list|()
decl_stmt|;
comment|// pointer to data
name|s
operator|>>
name|cs
expr_stmt|;
comment|// read checksum
name|ccs
operator|=
operator|(
name|quint16
operator|)
name|qChecksum
argument_list|(
name|buf
operator|.
name|constData
argument_list|()
operator|+
name|data_start
argument_list|,
name|buf
operator|.
name|size
argument_list|()
operator|-
name|data_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccs
operator|!=
name|cs
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPicturePaintEngine::checkFormat: Invalid checksum %x, %x expected"
argument_list|,
name|ccs
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|quint16
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|s
operator|>>
name|major
operator|>>
name|minor
expr_stmt|;
comment|// read version number
if|if
condition|(
name|major
operator|>
name|mfhdr_maj
condition|)
block|{
comment|// new, incompatible version
name|qWarning
argument_list|(
literal|"QPicturePaintEngine::checkFormat: Incompatible version %d.%d"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|s
operator|.
name|setVersion
argument_list|(
name|major
operator|!=
literal|4
condition|?
name|major
else|:
literal|3
argument_list|)
expr_stmt|;
name|quint8
name|c
decl_stmt|,
name|clen
decl_stmt|;
name|s
operator|>>
name|c
operator|>>
name|clen
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|QPicturePrivate
operator|::
name|PdcBegin
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|major
operator|>=
literal|1
operator|&&
name|major
operator|<=
literal|3
operator|)
condition|)
block|{
name|qint32
name|l
decl_stmt|,
name|t
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|s
operator|>>
name|l
operator|>>
name|t
operator|>>
name|w
operator|>>
name|h
expr_stmt|;
name|brect
operator|=
name|QRect
argument_list|(
name|l
argument_list|,
name|t
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QPicturePaintEngine::checkFormat: Format error"
argument_list|)
expr_stmt|;
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|pictb
operator|.
name|close
argument_list|()
expr_stmt|;
name|formatOk
operator|=
literal|true
expr_stmt|;
comment|// picture seems to be ok
name|formatMajor
operator|=
name|major
expr_stmt|;
name|formatMinor
operator|=
name|minor
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|paintEngine
name|QPaintEngine
modifier|*
name|QPicture
operator|::
name|paintEngine
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|paintEngine
condition|)
cast|const_cast
argument_list|<
name|QPicture
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|d_func
argument_list|()
operator|->
name|paintEngine
operator|.
name|reset
argument_list|(
operator|new
name|QPicturePaintEngine
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|paintEngine
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPicture stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QPicture      Writes picture \a r to the stream \a s and returns a reference to     the stream. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QPicture
modifier|&
name|r
parameter_list|)
block|{
name|quint32
name|size
init|=
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|s
operator|<<
name|size
expr_stmt|;
comment|// null picture ?
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|s
return|;
comment|// just write the whole buffer to the stream
name|s
operator|.
name|writeRawData
argument_list|(
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
argument_list|,
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|buffer
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QPicture      Reads a picture from the stream \a s into picture \a r and returns     a reference to the stream. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QPicture
modifier|&
name|r
parameter_list|)
block|{
name|QDataStream
name|sr
decl_stmt|;
comment|// "init"; this code is similar to the beginning of QPicture::cmd()
name|sr
operator|.
name|setDevice
argument_list|(
operator|&
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|pictb
argument_list|)
expr_stmt|;
name|sr
operator|.
name|setVersion
argument_list|(
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|formatMajor
argument_list|)
expr_stmt|;
name|quint32
name|len
decl_stmt|;
name|s
operator|>>
name|len
expr_stmt|;
name|QByteArray
name|data
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|data
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|s
operator|.
name|readRawData
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|pictb
operator|.
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|r
operator|.
name|d_func
argument_list|()
operator|->
name|resetFormat
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PICTUREIO
end_ifndef
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qregexp.h"
include|#
directive|include
file|"qpictureformatplugin.h"
name|QT_END_INCLUDE_NAMESPACE
comment|/*!     \obsolete      Returns a string that specifies the picture format of the file \a     fileName, or 0 if the file cannot be read or if the format is not     recognized.      \sa load(), save() */
DECL|function|pictureFormat
specifier|const
name|char
modifier|*
name|QPicture
operator|::
name|pictureFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
return|return
name|QPictureIO
operator|::
name|pictureFormat
argument_list|(
name|fileName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns a list of picture formats that are supported for picture     input.      \sa outputFormats(), inputFormatList(), QPictureIO */
end_comment
begin_function
DECL|function|inputFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QPicture
operator|::
name|inputFormats
parameter_list|()
block|{
return|return
name|QPictureIO
operator|::
name|inputFormats
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qToStringList
specifier|static
name|QStringList
name|qToStringList
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|arr
parameter_list|)
block|{
name|QStringList
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|list
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|arr
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns a list of picture formats that are supported for picture     input.      Note that if you want to iterate over the list, you should iterate     over a copy, e.g.     \snippet picture/picture.cpp 2      \sa outputFormatList(), inputFormats(), QPictureIO */
end_comment
begin_function
DECL|function|inputFormatList
name|QStringList
name|QPicture
operator|::
name|inputFormatList
parameter_list|()
block|{
return|return
name|qToStringList
argument_list|(
name|QPictureIO
operator|::
name|inputFormats
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns a list of picture formats that are supported for picture     output.      Note that if you want to iterate over the list, you should iterate     over a copy, e.g.     \snippet picture/picture.cpp 3      \sa inputFormatList(), outputFormats(), QPictureIO */
end_comment
begin_function
DECL|function|outputFormatList
name|QStringList
name|QPicture
operator|::
name|outputFormatList
parameter_list|()
block|{
return|return
name|qToStringList
argument_list|(
name|QPictureIO
operator|::
name|outputFormats
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns a list of picture formats that are supported for picture     output.      \sa inputFormats(), outputFormatList(), QPictureIO */
end_comment
begin_function
DECL|function|outputFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QPicture
operator|::
name|outputFormats
parameter_list|()
block|{
return|return
name|QPictureIO
operator|::
name|outputFormats
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPictureIO member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \obsolete      \class QPictureIO      \brief The QPictureIO class contains parameters for loading and     saving pictures.      \ingroup painting     \ingroup io     \inmodule QtGui      QPictureIO contains a QIODevice object that is used for picture data     I/O. The programmer can install new picture file formats in addition     to those that Qt provides.      You don't normally need to use this class; QPicture::load(),     QPicture::save().      \sa QPicture, QPixmap, QFile */
end_comment
begin_struct
DECL|struct|QPictureIOData
struct|struct
name|QPictureIOData
block|{
DECL|member|pi
name|QPicture
name|pi
decl_stmt|;
comment|// picture
DECL|member|iostat
name|int
name|iostat
decl_stmt|;
comment|// IO status
DECL|member|frmt
name|QByteArray
name|frmt
decl_stmt|;
comment|// picture format
DECL|member|iodev
name|QIODevice
modifier|*
name|iodev
decl_stmt|;
comment|// IO device
DECL|member|fname
name|QString
name|fname
decl_stmt|;
comment|// file name
DECL|member|descr
name|QString
name|descr
decl_stmt|;
comment|// picture description
DECL|member|parameters
specifier|const
name|char
modifier|*
name|parameters
decl_stmt|;
DECL|member|quality
name|int
name|quality
decl_stmt|;
DECL|member|gamma
name|float
name|gamma
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     Constructs a QPictureIO object with all parameters set to zero. */
end_comment
begin_constructor
DECL|function|QPictureIO
name|QPictureIO
operator|::
name|QPictureIO
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QPictureIO object with the I/O device \a ioDevice and a     \a format tag. */
end_comment
begin_constructor
DECL|function|QPictureIO
name|QPictureIO
operator|::
name|QPictureIO
parameter_list|(
name|QIODevice
modifier|*
name|ioDevice
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|iodev
operator|=
name|ioDevice
expr_stmt|;
name|d
operator|->
name|frmt
operator|=
name|format
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QPictureIO object with the file name \a fileName and a     \a format tag. */
end_comment
begin_constructor
DECL|function|QPictureIO
name|QPictureIO
operator|::
name|QPictureIO
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|frmt
operator|=
name|format
expr_stmt|;
name|d
operator|->
name|fname
operator|=
name|fileName
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Contains initialization common to all QPictureIO constructors. */
end_comment
begin_function
DECL|function|init
name|void
name|QPictureIO
operator|::
name|init
parameter_list|()
block|{
name|d
operator|=
operator|new
name|QPictureIOData
argument_list|()
expr_stmt|;
name|d
operator|->
name|parameters
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|quality
operator|=
operator|-
literal|1
expr_stmt|;
comment|// default quality of the current format
name|d
operator|->
name|gamma
operator|=
literal|0.0f
expr_stmt|;
name|d
operator|->
name|iostat
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|iodev
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys the object and all related data. */
end_comment
begin_destructor
DECL|function|~QPictureIO
name|QPictureIO
operator|::
name|~
name|QPictureIO
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|parameters
condition|)
operator|delete
index|[]
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|parameters
expr_stmt|;
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*****************************************************************************   QPictureIO picture handler functions  *****************************************************************************/
end_comment
begin_class
DECL|class|QPictureHandler
class|class
name|QPictureHandler
block|{
public|public:
name|QPictureHandler
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|h
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|fl
parameter_list|,
name|picture_io_handler
name|r
parameter_list|,
name|picture_io_handler
name|w
parameter_list|)
constructor_decl|;
DECL|member|format
name|QByteArray
name|format
decl_stmt|;
comment|// picture format
DECL|member|header
name|QRegExp
name|header
decl_stmt|;
comment|// picture header pattern
DECL|enum|TMode
DECL|enumerator|Untranslated
DECL|enumerator|TranslateIn
DECL|enumerator|TranslateInOut
DECL|member|text_mode
enum|enum
name|TMode
block|{
name|Untranslated
init|=
literal|0
block|,
name|TranslateIn
block|,
name|TranslateInOut
block|}
name|text_mode
enum|;
DECL|member|read_picture
name|picture_io_handler
name|read_picture
decl_stmt|;
comment|// picture read function
DECL|member|write_picture
name|picture_io_handler
name|write_picture
decl_stmt|;
comment|// picture write function
DECL|member|obsolete
name|bool
name|obsolete
decl_stmt|;
comment|// support not "published"
block|}
class|;
end_class
begin_constructor
DECL|function|QPictureHandler
name|QPictureHandler
operator|::
name|QPictureHandler
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|h
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|fl
parameter_list|,
name|picture_io_handler
name|r
parameter_list|,
name|picture_io_handler
name|w
parameter_list|)
member_init_list|:
name|format
argument_list|(
name|f
argument_list|)
member_init_list|,
name|header
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|h
argument_list|)
argument_list|)
block|{
name|text_mode
operator|=
name|Untranslated
expr_stmt|;
if|if
condition|(
name|fl
operator|.
name|contains
argument_list|(
literal|'t'
argument_list|)
condition|)
name|text_mode
operator|=
name|TranslateIn
expr_stmt|;
elseif|else
if|if
condition|(
name|fl
operator|.
name|contains
argument_list|(
literal|'T'
argument_list|)
condition|)
name|text_mode
operator|=
name|TranslateInOut
expr_stmt|;
name|obsolete
operator|=
name|fl
operator|.
name|contains
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|read_picture
operator|=
name|r
expr_stmt|;
name|write_picture
operator|=
name|w
expr_stmt|;
block|}
end_constructor
begin_typedef
DECL|typedef|QPHList
typedef|typedef
name|QList
argument_list|<
name|QPictureHandler
modifier|*
argument_list|>
name|QPHList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QPHList
argument_list|,
argument|pictureHandlers
argument_list|)
end_macro
begin_function
DECL|function|qt_init_picture_plugins
name|void
name|qt_init_picture_plugins
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
typedef|typedef
name|QMultiMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|PluginKeyMap
typedef|;
typedef|typedef
name|PluginKeyMap
operator|::
name|const_iterator
name|PluginKeyMapConstIterator
typedef|;
specifier|static
name|QBasicMutex
name|mutex
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
specifier|static
name|QFactoryLoader
name|loader
argument_list|(
name|QPictureFormatInterface_iid
argument_list|,
name|QStringLiteral
argument_list|(
literal|"/pictureformats"
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|PluginKeyMap
name|keyMap
init|=
name|loader
operator|.
name|keyMap
argument_list|()
decl_stmt|;
specifier|const
name|PluginKeyMapConstIterator
name|cend
init|=
name|keyMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
name|PluginKeyMapConstIterator
name|it
init|=
name|keyMap
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|cend
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|QPictureFormatPlugin
modifier|*
name|format
init|=
name|qobject_cast
argument_list|<
name|QPictureFormatPlugin
operator|*
argument_list|>
argument_list|(
name|loader
operator|.
name|instance
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
argument_list|)
condition|)
name|format
operator|->
name|installIOHandler
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|cleanup
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
comment|// make sure that picture handlers are delete before plugin manager
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
name|qDeleteAll
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
name|list
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_init_picture_handlers
name|void
name|qt_init_picture_handlers
parameter_list|()
comment|// initialize picture handlers
block|{
specifier|static
name|QBasicAtomicInt
name|done
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
operator|.
name|testAndSetRelaxed
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|qAddPostRoutine
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|get_picture_handler
specifier|static
name|QPictureHandler
modifier|*
name|get_picture_handler
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
comment|// get pointer to handler
name|qt_init_picture_handlers
argument_list|()
expr_stmt|;
name|qt_init_picture_plugins
argument_list|()
expr_stmt|;
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|format
operator|==
name|format
condition|)
return|return
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|// no such handler
block|}
end_function
begin_comment
comment|/*!     Defines a picture I/O handler for the picture format called \a     format, which is recognized using the regular     expression defined in \a header, read using \a readPicture and     written using \a writePicture.      \a flags is a string of single-character flags for this format.     The only flag defined currently is T (upper case), so the only     legal value for \a flags are "T" and the empty string. The "T"     flag means that the picture file is a text file, and Qt should treat     all newline conventions as equivalent. (XPM files and some PPM     files are text files for example.)      \a format is used to select a handler to write a QPicture; \a header     is used to select a handler to read an picture file.      If \a readPicture is a null pointer, the QPictureIO will not be able     to read pictures in \a format. If \a writePicture is a null pointer,     the QPictureIO will not be able to write pictures in \a format. If     both are null, the QPictureIO object is valid but useless.      Example:     \snippet picture/picture.cpp 6     \codeline     \snippet picture/picture.cpp 7     \codeline     \snippet picture/picture.cpp 8      Before the regular expression test, all the 0 bytes in the file header are     converted to 1 bytes. This is done because when Qt was ASCII-based, QRegExp     could not handle 0 bytes in strings.      The regexp is only applied on the first 14 bytes of the file.      (Note that if one handlerIO supports writing a format and another     supports reading it, Qt supports both reading and writing. If two     handlers support the same operation, Qt chooses one arbitrarily.) */
end_comment
begin_function
DECL|function|defineIOHandler
name|void
name|QPictureIO
operator|::
name|defineIOHandler
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|flags
parameter_list|,
name|picture_io_handler
name|readPicture
parameter_list|,
name|picture_io_handler
name|writePicture
parameter_list|)
block|{
name|qt_init_picture_handlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
name|QPictureHandler
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|new
name|QPictureHandler
argument_list|(
name|format
argument_list|,
name|header
argument_list|,
name|QByteArray
argument_list|(
name|flags
argument_list|)
argument_list|,
name|readPicture
argument_list|,
name|writePicture
argument_list|)
expr_stmt|;
name|list
operator|->
name|prepend
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QPictureIO normal member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Returns the picture currently set.      \sa setPicture() */
end_comment
begin_function
DECL|function|picture
specifier|const
name|QPicture
modifier|&
name|QPictureIO
operator|::
name|picture
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|pi
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the picture's IO status. A non-zero value indicates an     error, whereas 0 means that the IO operation was successful.      \sa setStatus() */
end_comment
begin_function
DECL|function|status
name|int
name|QPictureIO
operator|::
name|status
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|iostat
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the picture format string or 0 if no format has been     explicitly set. */
end_comment
begin_function
DECL|function|format
specifier|const
name|char
modifier|*
name|QPictureIO
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|frmt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the IO device currently set.      \sa setIODevice() */
end_comment
begin_function
DECL|function|ioDevice
name|QIODevice
modifier|*
name|QPictureIO
operator|::
name|ioDevice
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|iodev
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file name currently set.      \sa setFileName() */
end_comment
begin_function
DECL|function|fileName
name|QString
name|QPictureIO
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|fname
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the picture description string.      \sa setDescription() */
end_comment
begin_function
DECL|function|description
name|QString
name|QPictureIO
operator|::
name|description
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|descr
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture to \a picture.      \sa picture() */
end_comment
begin_function
DECL|function|setPicture
name|void
name|QPictureIO
operator|::
name|setPicture
parameter_list|(
specifier|const
name|QPicture
modifier|&
name|picture
parameter_list|)
block|{
name|d
operator|->
name|pi
operator|=
name|picture
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture IO status to \a status. A non-zero value indicates     an error, whereas 0 means that the IO operation was successful.      \sa status() */
end_comment
begin_function
DECL|function|setStatus
name|void
name|QPictureIO
operator|::
name|setStatus
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|d
operator|->
name|iostat
operator|=
name|status
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture format to \a format for the picture to be read or     written.      It is necessary to specify a format before writing an picture, but     it is not necessary to specify a format before reading an picture.      If no format has been set, Qt guesses the picture format before     reading it. If a format is set the picture will only be read if it     has that format.      \sa read(), write(), format() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QPictureIO
operator|::
name|setFormat
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|d
operator|->
name|frmt
operator|=
name|format
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the IO device to be used for reading or writing an picture.      Setting the IO device allows pictures to be read/written to any     block-oriented QIODevice.      If \a ioDevice is not null, this IO device will override file name     settings.      \sa setFileName() */
end_comment
begin_function
DECL|function|setIODevice
name|void
name|QPictureIO
operator|::
name|setIODevice
parameter_list|(
name|QIODevice
modifier|*
name|ioDevice
parameter_list|)
block|{
name|d
operator|->
name|iodev
operator|=
name|ioDevice
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the name of the file to read or write an picture from to \a     fileName.      \sa setIODevice() */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QPictureIO
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|d
operator|->
name|fname
operator|=
name|fileName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the quality of the written picture, related to the     compression ratio.      \sa setQuality(), QPicture::save() */
end_comment
begin_function
DECL|function|quality
name|int
name|QPictureIO
operator|::
name|quality
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|quality
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the quality of the written picture to \a q, related to the     compression ratio.      \a q must be in the range -1..100. Specify 0 to obtain small     compressed files, 100 for large uncompressed files. (-1 signifies     the default compression.)      \sa quality(), QPicture::save() */
end_comment
begin_function
DECL|function|setQuality
name|void
name|QPictureIO
operator|::
name|setQuality
parameter_list|(
name|int
name|q
parameter_list|)
block|{
name|d
operator|->
name|quality
operator|=
name|q
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the picture's parameters string.      \sa setParameters() */
end_comment
begin_function
DECL|function|parameters
specifier|const
name|char
modifier|*
name|QPictureIO
operator|::
name|parameters
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|parameters
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture's parameter string to \a parameters. This is for     picture handlers that require special parameters.      Although the current picture formats supported by Qt ignore the     parameters string, it may be used in future extensions or by     contributions (for example, JPEG).      \sa parameters() */
end_comment
begin_function
DECL|function|setParameters
name|void
name|QPictureIO
operator|::
name|setParameters
parameter_list|(
specifier|const
name|char
modifier|*
name|parameters
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|parameters
condition|)
operator|delete
index|[]
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|parameters
expr_stmt|;
name|d
operator|->
name|parameters
operator|=
name|qstrdup
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the gamma value at which the picture will be viewed to \a     gamma. If the picture format stores a gamma value for which the     picture is intended to be used, then this setting will be used to     modify the picture. Setting to 0.0 will disable gamma correction     (i.e. any specification in the file will be ignored).      The default value is 0.0.      \sa gamma() */
end_comment
begin_function
DECL|function|setGamma
name|void
name|QPictureIO
operator|::
name|setGamma
parameter_list|(
name|float
name|gamma
parameter_list|)
block|{
name|d
operator|->
name|gamma
operator|=
name|gamma
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the gamma value at which the picture will be viewed.      \sa setGamma() */
end_comment
begin_function
DECL|function|gamma
name|float
name|QPictureIO
operator|::
name|gamma
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|gamma
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the picture description string for picture handlers that support     picture descriptions to \a description.      Currently, no picture format supported by Qt uses the description     string. */
end_comment
begin_function
DECL|function|setDescription
name|void
name|QPictureIO
operator|::
name|setDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|d
operator|->
name|descr
operator|=
name|description
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a string that specifies the picture format of the file \a     fileName, or null if the file cannot be read or if the format is     not recognized. */
end_comment
begin_function
DECL|function|pictureFormat
name|QByteArray
name|QPictureIO
operator|::
name|pictureFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|QByteArray
name|format
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|format
return|;
name|format
operator|=
name|pictureFormat
argument_list|(
operator|&
name|file
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a string that specifies the picture format of the picture read     from IO device \a d, or 0 if the device cannot be read or if the     format is not recognized.      Make sure that \a d is at the right position in the device (for     example, at the beginning of the file).      \sa QIODevice::at() */
end_comment
begin_function
DECL|function|pictureFormat
name|QByteArray
name|QPictureIO
operator|::
name|pictureFormat
parameter_list|(
name|QIODevice
modifier|*
name|d
parameter_list|)
block|{
comment|// if you change this change the documentation for defineIOHandler()
specifier|const
name|int
name|buflen
init|=
literal|14
decl_stmt|;
name|char
name|buf
index|[
name|buflen
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|buflen
index|]
decl_stmt|;
name|qt_init_picture_handlers
argument_list|()
expr_stmt|;
name|qt_init_picture_plugins
argument_list|()
expr_stmt|;
name|int
name|pos
init|=
name|d
operator|->
name|pos
argument_list|()
decl_stmt|;
comment|// save position
name|int
name|rdlen
init|=
name|d
operator|->
name|read
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
comment|// read a few bytes
name|QByteArray
name|format
decl_stmt|;
if|if
condition|(
name|rdlen
operator|!=
name|buflen
condition|)
return|return
name|format
return|;
name|memcpy
argument_list|(
name|buf2
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|rdlen
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|n
index|]
operator|==
literal|'\0'
condition|)
name|buf
index|[
name|n
index|]
operator|=
literal|'\001'
expr_stmt|;
if|if
condition|(
name|rdlen
operator|>
literal|0
condition|)
block|{
name|buf
index|[
name|rdlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|QString
name|bufStr
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|header
operator|.
name|indexIn
argument_list|(
name|bufStr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// try match with headers
name|format
operator|=
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|format
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|d
operator|->
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// restore position
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a sorted list of picture formats that are supported for     picture input. */
end_comment
begin_function
DECL|function|inputFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QPictureIO
operator|::
name|inputFormats
parameter_list|()
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|qt_init_picture_handlers
argument_list|()
expr_stmt|;
name|qt_init_picture_plugins
argument_list|()
expr_stmt|;
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPictureHandler
modifier|*
name|p
init|=
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|read_picture
operator|&&
operator|!
name|p
operator|->
name|obsolete
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|p
operator|->
name|format
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|p
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|result
operator|.
name|begin
argument_list|()
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a sorted list of picture formats that are supported for     picture output. */
end_comment
begin_function
DECL|function|outputFormats
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QPictureIO
operator|::
name|outputFormats
parameter_list|()
block|{
name|qt_init_picture_handlers
argument_list|()
expr_stmt|;
name|qt_init_picture_plugins
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|QPHList
modifier|*
name|list
init|=
name|pictureHandlers
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QPictureHandler
modifier|*
name|p
init|=
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|write_picture
operator|&&
operator|!
name|p
operator|->
name|obsolete
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|p
operator|->
name|format
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|p
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Reads an picture into memory and returns true if the picture was     successfully read; otherwise returns false.      Before reading an picture you must set an IO device or a file name.     If both an IO device and a file name have been set, the IO device     will be used.      Setting the picture file format string is optional.      Note that this function does \e not set the \l{format()}{format} used to read the picture. If you need that     information, use the pictureFormat() static functions.      Example:      \snippet picture/picture.cpp 4      \sa setIODevice(), setFileName(), setFormat(), write(), QPixmap::load() */
end_comment
begin_function
DECL|function|read
name|bool
name|QPictureIO
operator|::
name|read
parameter_list|()
block|{
name|QFile
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|picture_format
decl_stmt|;
name|QPictureHandler
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|iodev
condition|)
block|{
comment|// read from io device
comment|// ok, already open
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|fname
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// read from file
name|file
operator|.
name|setFileName
argument_list|(
name|d
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// cannot open file
name|d
operator|->
name|iodev
operator|=
operator|&
name|file
expr_stmt|;
block|}
else|else
block|{
comment|// no file name or io device
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|frmt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Try to guess format
name|picture_format
operator|=
name|pictureFormat
argument_list|(
name|d
operator|->
name|iodev
argument_list|)
expr_stmt|;
comment|// get picture format
if|if
condition|(
operator|!
name|picture_format
condition|)
block|{
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
comment|// unknown format
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|iodev
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|picture_format
operator|=
name|d
operator|->
name|frmt
expr_stmt|;
block|}
name|h
operator|=
name|get_picture_handler
argument_list|(
name|picture_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|text_mode
condition|)
block|{
comment|// reopen in translated mode
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// position to start
block|}
name|d
operator|->
name|iostat
operator|=
literal|1
expr_stmt|;
comment|// assume error
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|read_picture
condition|)
call|(
modifier|*
name|h
operator|->
name|read_picture
call|)
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
comment|// picture was read using file
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|iodev
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|d
operator|->
name|iostat
operator|==
literal|0
return|;
comment|// picture successfully read?
block|}
end_function
begin_comment
comment|/*!     Writes an picture to an IO device and returns true if the picture was     successfully written; otherwise returns false.      Before writing an picture you must set an IO device or a file name.     If both an IO device and a file name have been set, the IO device     will be used.      The picture will be written using the specified picture format.      Example:     \snippet picture/picture.cpp 5      \sa setIODevice(), setFileName(), setFormat(), read(), QPixmap::save() */
end_comment
begin_function
DECL|function|write
name|bool
name|QPictureIO
operator|::
name|write
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|frmt
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QPictureHandler
modifier|*
name|h
init|=
name|get_picture_handler
argument_list|(
name|d
operator|->
name|frmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
operator|!
name|h
operator|->
name|write_picture
condition|)
block|{
name|qWarning
argument_list|(
literal|"QPictureIO::write: No such picture format handler: %s"
argument_list|,
name|format
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QFile
name|file
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|iodev
operator|&&
operator|!
name|d
operator|->
name|fname
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|file
operator|.
name|setFileName
argument_list|(
name|d
operator|->
name|fname
argument_list|)
expr_stmt|;
name|bool
name|translate
init|=
name|h
operator|->
name|text_mode
operator|==
name|QPictureHandler
operator|::
name|TranslateInOut
decl_stmt|;
name|QIODevice
operator|::
name|OpenMode
name|fmode
init|=
name|translate
condition|?
name|QIODevice
operator|::
name|WriteOnly
operator||
name|QIODevice
operator|::
name|Text
else|:
name|QIODevice
operator|::
name|OpenMode
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|fmode
argument_list|)
condition|)
comment|// couldn't create file
return|return
literal|false
return|;
name|d
operator|->
name|iodev
operator|=
operator|&
name|file
expr_stmt|;
block|}
name|d
operator|->
name|iostat
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|write_picture
call|)
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
comment|// picture was written using file
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|iodev
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|d
operator|->
name|iostat
operator|==
literal|0
return|;
comment|// picture successfully written?
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_PICTUREIO
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PICTURE
end_comment
begin_comment
comment|/*!     \typedef QPicture::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QPicture::data_ptr()     \internal */
end_comment
end_unit
