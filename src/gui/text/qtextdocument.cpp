begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextdocument.h"
end_include
begin_include
include|#
directive|include
file|<qtextformat.h>
end_include
begin_include
include|#
directive|include
file|"qtextdocumentlayout_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocumentfragment.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocumentfragment_p.h"
end_include
begin_include
include|#
directive|include
file|"qtexttable.h"
end_include
begin_include
include|#
directive|include
file|"qtextlist.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|"qtexthtmlparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qpainter.h"
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|"qfont_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdataurl_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocument_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qabstracttextdocumentlayout_p.h>
end_include
begin_include
include|#
directive|include
file|"qpagedpaintdevice.h"
end_include
begin_include
include|#
directive|include
file|"private/qpagedpaintdevice_p.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_CORE_EXPORT
name|unsigned
name|int
name|qt_int_sqrt
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     Returns true if the string \a text is likely to be rich text;     otherwise returns false.      This function uses a fast and therefore simple heuristic. It     mainly checks whether there is something that looks like a tag     before the first line break. Although the result may be correct     for common cases, there is no guarantee.      This function is defined in the \c<QTextDocument> header file. */
end_comment
begin_function
DECL|function|mightBeRichText
name|bool
name|Qt
operator|::
name|mightBeRichText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|start
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|start
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
operator|++
name|start
expr_stmt|;
comment|// skip a leading<?xml ... ?> as for example with xhtml
if|if
condition|(
name|text
operator|.
name|mid
argument_list|(
name|start
argument_list|,
literal|5
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"<?xml"
argument_list|)
condition|)
block|{
while|while
condition|(
name|start
operator|<
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|at
argument_list|(
name|start
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
operator|&&
name|start
operator|+
literal|2
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|start
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
block|{
name|start
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
operator|++
name|start
expr_stmt|;
block|}
while|while
condition|(
name|start
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|start
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
operator|++
name|start
expr_stmt|;
block|}
if|if
condition|(
name|text
operator|.
name|mid
argument_list|(
name|start
argument_list|,
literal|5
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"<!doc"
argument_list|)
condition|)
return|return
literal|true
return|;
name|int
name|open
init|=
name|start
decl_stmt|;
while|while
condition|(
name|open
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|open
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
operator|&&
name|text
operator|.
name|at
argument_list|(
name|open
argument_list|)
operator|!=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|at
argument_list|(
name|open
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
operator|&&
name|text
operator|.
name|mid
argument_list|(
name|open
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"lt;"
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// support desperate attempt of user to see<...>
operator|++
name|open
expr_stmt|;
block|}
if|if
condition|(
name|open
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|open
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
block|{
specifier|const
name|int
name|close
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
argument_list|,
name|open
argument_list|)
decl_stmt|;
if|if
condition|(
name|close
operator|>
operator|-
literal|1
condition|)
block|{
name|QString
name|tag
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|open
operator|+
literal|1
init|;
name|i
operator|<
name|close
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|text
index|[
name|i
index|]
operator|.
name|isDigit
argument_list|()
operator|||
name|text
index|[
name|i
index|]
operator|.
name|isLetter
argument_list|()
condition|)
name|tag
operator|+=
name|text
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
operator|&&
name|text
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
operator|&&
name|text
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|==
name|close
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|text
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
operator|&&
operator|(
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
operator|||
name|text
index|[
name|i
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|'!'
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
comment|// that's not a tag
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
return|return
name|QTextHtmlParser
operator|::
name|lookupElement
argument_list|(
name|tag
operator|.
name|toLower
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
comment|// QT_NO_TEXTHTMLPARSER
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString Qt::convertFromPlainText(const QString&plain, WhiteSpaceMode mode)      Converts the plain text string \a plain to an HTML-formatted     paragraph while preserving most of its look.      \a mode defines how whitespace is handled.      This function is defined in the \c<QTextDocument> header file.      \sa escape(), mightBeRichText() */
end_comment
begin_function
DECL|function|convertFromPlainText
name|QString
name|Qt
operator|::
name|convertFromPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|plain
parameter_list|,
name|Qt
operator|::
name|WhiteSpaceMode
name|mode
parameter_list|)
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
name|QString
name|rich
decl_stmt|;
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|plain
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|plain
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|int
name|c
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|plain
operator|.
name|length
argument_list|()
operator|&&
name|plain
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|1
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"</p>\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>
literal|1
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
block|}
name|col
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|WhiteSpacePre
operator|&&
name|plain
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\t'
argument_list|)
condition|)
block|{
name|rich
operator|+=
name|QChar
argument_list|(
literal|0x00a0U
argument_list|)
expr_stmt|;
operator|++
name|col
expr_stmt|;
while|while
condition|(
name|col
operator|%
literal|8
condition|)
block|{
name|rich
operator|+=
name|QChar
argument_list|(
literal|0x00a0U
argument_list|)
expr_stmt|;
operator|++
name|col
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|WhiteSpacePre
operator|&&
name|plain
index|[
name|i
index|]
operator|.
name|isSpace
argument_list|()
condition|)
name|rich
operator|+=
name|QChar
argument_list|(
literal|0x00a0U
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|plain
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|plain
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|plain
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
else|else
name|rich
operator|+=
name|plain
index|[
name|i
index|]
expr_stmt|;
operator|++
name|col
expr_stmt|;
block|}
block|}
if|if
condition|(
name|col
operator|!=
literal|0
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
return|return
name|rich
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_comment
comment|/*!     \internal      This function is defined in the \c<QTextDocument> header file. */
end_comment
begin_function
DECL|function|codecForHtml
name|QTextCodec
modifier|*
name|Qt
operator|::
name|codecForHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|QTextCodec
operator|::
name|codecForHtml
argument_list|(
name|ba
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QTextDocument     \reentrant     \inmodule QtGui      \brief The QTextDocument class holds formatted text.      \ingroup richtext-processing       QTextDocument is a container for structured rich text documents, providing     support for styled text and various types of document elements, such as     lists, tables, frames, and images.     They can be created for use in a QTextEdit, or used independently.      Each document element is described by an associated format object. Each     format object is treated as a unique object by QTextDocuments, and can be     passed to objectForFormat() to obtain the document element that it is     applied to.      A QTextDocument can be edited programmatically using a QTextCursor, and     its contents can be examined by traversing the document structure. The     entire document structure is stored as a hierarchy of document elements     beneath the root frame, found with the rootFrame() function. Alternatively,     if you just want to iterate over the textual contents of the document you     can use begin(), end(), and findBlock() to retrieve text blocks that you     can examine and iterate over.      The layout of a document is determined by the documentLayout();     you can create your own QAbstractTextDocumentLayout subclass and     set it using setDocumentLayout() if you want to use your own     layout logic. The document's title and other meta-information can be     obtained by calling the metaInformation() function. For documents that     are exposed to users through the QTextEdit class, the document title     is also available via the QTextEdit::documentTitle() function.      The toPlainText() and toHtml() convenience functions allow you to retrieve the     contents of the document as plain text and HTML.     The document's text can be searched using the find() functions.      Undo/redo of operations performed on the document can be controlled using     the setUndoRedoEnabled() function. The undo/redo system can be controlled     by an editor widget through the undo() and redo() slots; the document also     provides contentsChanged(), undoAvailable(), and redoAvailable() signals     that inform connected editor widgets about the state of the undo/redo     system. The following are the undo/redo operations of a QTextDocument:      \list         \li Insertion or removal of characters. A sequence of insertions or removals            within the same text block are regarded as a single undo/redo operation.         \li Insertion or removal of text blocks. Sequences of insertion or removals            in a single operation (e.g., by selecting and then deleting text) are            regarded as a single undo/redo operation.         \li Text character format changes.         \li Text block format changes.         \li Text block group format changes.     \endlist      \sa QTextCursor, QTextEdit, {Rich Text Processing}, {Text Object Example} */
end_comment
begin_comment
comment|/*!     \property QTextDocument::defaultFont     \brief the default font used to display the document's text */
end_comment
begin_comment
comment|/*!     \property QTextDocument::defaultTextOption     \brief the default text option will be set on all \l{QTextLayout}s in the document.      When \l{QTextBlock}s are created, the defaultTextOption is set on their     QTextLayout. This allows setting global properties for the document such as the     default word wrap mode.  */
end_comment
begin_comment
comment|/*!     Constructs an empty QTextDocument with the given \a parent. */
end_comment
begin_constructor
DECL|function|QTextDocument
name|QTextDocument
operator|::
name|QTextDocument
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTextDocumentPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QTextDocument containing the plain (unformatted) \a text     specified, and with the given \a parent. */
end_comment
begin_constructor
DECL|function|QTextDocument
name|QTextDocument
operator|::
name|QTextDocument
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTextDocumentPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|QTextCursor
argument_list|(
name|this
argument_list|)
operator|.
name|insertText
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QTextDocument
name|QTextDocument
operator|::
name|QTextDocument
parameter_list|(
name|QTextDocumentPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the document. */
end_comment
begin_destructor
DECL|function|~QTextDocument
name|QTextDocument
operator|::
name|~
name|QTextDocument
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   Creates a new QTextDocument that is a copy of this text document. \a   parent is the parent of the returned text document. */
end_comment
begin_function
DECL|function|clone
name|QTextDocument
modifier|*
name|QTextDocument
operator|::
name|clone
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
name|QTextDocument
modifier|*
name|doc
init|=
operator|new
name|QTextDocument
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|QTextCursor
argument_list|(
name|doc
argument_list|)
operator|.
name|insertFragment
argument_list|(
name|QTextDocumentFragment
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|setFrameFormat
argument_list|(
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
argument_list|)
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|doc
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|priv
operator|->
name|title
operator|=
name|d
operator|->
name|title
expr_stmt|;
name|priv
operator|->
name|url
operator|=
name|d
operator|->
name|url
expr_stmt|;
name|priv
operator|->
name|pageSize
operator|=
name|d
operator|->
name|pageSize
expr_stmt|;
name|priv
operator|->
name|indentWidth
operator|=
name|d
operator|->
name|indentWidth
expr_stmt|;
name|priv
operator|->
name|defaultTextOption
operator|=
name|d
operator|->
name|defaultTextOption
expr_stmt|;
name|priv
operator|->
name|setDefaultFont
argument_list|(
name|d
operator|->
name|defaultFont
argument_list|()
argument_list|)
expr_stmt|;
name|priv
operator|->
name|resources
operator|=
name|d
operator|->
name|resources
expr_stmt|;
name|priv
operator|->
name|cachedResources
operator|.
name|clear
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CSSPARSER
name|priv
operator|->
name|defaultStyleSheet
operator|=
name|d
operator|->
name|defaultStyleSheet
expr_stmt|;
name|priv
operator|->
name|parsedDefaultStyleSheet
operator|=
name|d
operator|->
name|parsedDefaultStyleSheet
expr_stmt|;
endif|#
directive|endif
return|return
name|doc
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the document is empty; otherwise returns false. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QTextDocument
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
comment|/* because if we're empty we still have one single paragraph as      * one single fragment */
return|return
name|d
operator|->
name|length
argument_list|()
operator|<=
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   Clears the document. */
end_comment
begin_function
DECL|function|clear
name|void
name|QTextDocument
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|resources
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Undoes the last editing operation on the document if undo is     available. The provided \a cursor is positioned at the end of the     location where the edition operation was undone.      See the \l {Overview of Qt's Undo Framework}{Qt Undo Framework}     documentation for details.      \sa undoAvailable(), isUndoRedoEnabled() */
end_comment
begin_function
DECL|function|undo
name|void
name|QTextDocument
operator|::
name|undo
parameter_list|(
name|QTextCursor
modifier|*
name|cursor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pos
init|=
name|d
operator|->
name|undoRedo
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
operator|&&
name|pos
operator|>=
literal|0
condition|)
block|{
operator|*
name|cursor
operator|=
name|QTextCursor
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Redoes the last editing operation on the document if \l{QTextDocument::isRedoAvailable()}{redo is available}.      The provided \a cursor is positioned at the end of the location where     the edition operation was redone. */
end_comment
begin_function
DECL|function|redo
name|void
name|QTextDocument
operator|::
name|redo
parameter_list|(
name|QTextCursor
modifier|*
name|cursor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pos
init|=
name|d
operator|->
name|undoRedo
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
operator|&&
name|pos
operator|>=
literal|0
condition|)
block|{
operator|*
name|cursor
operator|=
name|QTextCursor
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \enum QTextDocument::Stacks    \value UndoStack              The undo stack.   \value RedoStack              The redo stack.   \value UndoAndRedoStacks      Both the undo and redo stacks. */
end_comment
begin_comment
comment|/*!     \since 4.7     Clears the stacks specified by \a stacksToClear.      This method clears any commands on the undo stack, the redo stack,     or both (the default). If commands are cleared, the appropriate     signals are emitted, QTextDocument::undoAvailable() or     QTextDocument::redoAvailable().      \sa QTextDocument::undoAvailable(), QTextDocument::redoAvailable() */
end_comment
begin_function
DECL|function|clearUndoRedoStacks
name|void
name|QTextDocument
operator|::
name|clearUndoRedoStacks
parameter_list|(
name|Stacks
name|stacksToClear
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearUndoRedoStacks
argument_list|(
name|stacksToClear
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload  */
end_comment
begin_function
DECL|function|undo
name|void
name|QTextDocument
operator|::
name|undo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|undoRedo
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload     Redoes the last editing operation on the document if \l{QTextDocument::isRedoAvailable()}{redo is available}. */
end_comment
begin_function
DECL|function|redo
name|void
name|QTextDocument
operator|::
name|redo
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|undoRedo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Appends a custom undo \a item to the undo stack. */
end_comment
begin_function
DECL|function|appendUndoItem
name|void
name|QTextDocument
operator|::
name|appendUndoItem
parameter_list|(
name|QAbstractUndoItem
modifier|*
name|item
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|appendUndoItem
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::undoRedoEnabled     \brief whether undo/redo are enabled for this document      This defaults to true. If disabled, the undo stack is cleared and     no items will be added to it. */
end_comment
begin_function
DECL|function|setUndoRedoEnabled
name|void
name|QTextDocument
operator|::
name|setUndoRedoEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|enableUndoRedo
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isUndoRedoEnabled
name|bool
name|QTextDocument
operator|::
name|isUndoRedoEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isUndoRedoEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::maximumBlockCount     \since 4.2     \brief Specifies the limit for blocks in the document.      Specifies the maximum number of blocks the document may have. If there are     more blocks in the document that specified with this property blocks are removed     from the beginning of the document.      A negative or zero value specifies that the document may contain an unlimited     amount of blocks.      The default value is 0.      Note that setting this property will apply the limit immediately to the document     contents.      Setting this property also disables the undo redo history.      This property is undefined in documents with tables or frames. */
end_comment
begin_function
DECL|function|maximumBlockCount
name|int
name|QTextDocument
operator|::
name|maximumBlockCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|maximumBlockCount
return|;
block|}
end_function
begin_function
DECL|function|setMaximumBlockCount
name|void
name|QTextDocument
operator|::
name|setMaximumBlockCount
parameter_list|(
name|int
name|maximum
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|maximumBlockCount
operator|=
name|maximum
expr_stmt|;
name|d
operator|->
name|ensureMaximumBlockCount
argument_list|()
expr_stmt|;
name|setUndoRedoEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      The default text option is used on all QTextLayout objects in the document.     This allows setting global properties for the document such as the default     word wrap mode. */
end_comment
begin_function
DECL|function|defaultTextOption
name|QTextOption
name|QTextDocument
operator|::
name|defaultTextOption
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultTextOption
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Sets the default text option. */
end_comment
begin_function
DECL|function|setDefaultTextOption
name|void
name|QTextDocument
operator|::
name|setDefaultTextOption
parameter_list|(
specifier|const
name|QTextOption
modifier|&
name|option
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultTextOption
operator|=
name|option
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      The default cursor movement style is used by all QTextCursor objects     created from the document. The default is Qt::LogicalMoveStyle. */
end_comment
begin_function
DECL|function|defaultCursorMoveStyle
name|Qt
operator|::
name|CursorMoveStyle
name|QTextDocument
operator|::
name|defaultCursorMoveStyle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultCursorMoveStyle
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Sets the default cursor movement style to the given \a style. */
end_comment
begin_function
DECL|function|setDefaultCursorMoveStyle
name|void
name|QTextDocument
operator|::
name|setDefaultCursorMoveStyle
parameter_list|(
name|Qt
operator|::
name|CursorMoveStyle
name|style
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultCursorMoveStyle
operator|=
name|style
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextDocument::markContentsDirty(int position, int length)      Marks the contents specified by the given \a position and \a length     as "dirty", informing the document that it needs to be laid out     again. */
end_comment
begin_function
DECL|function|markContentsDirty
name|void
name|QTextDocument
operator|::
name|markContentsDirty
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|documentChange
argument_list|(
name|from
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|inContentsChange
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|lout
condition|)
block|{
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
name|d
operator|->
name|docChangeFrom
argument_list|,
name|d
operator|->
name|docChangeOldLength
argument_list|,
name|d
operator|->
name|docChangeLength
argument_list|)
expr_stmt|;
name|d
operator|->
name|docChangeFrom
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::useDesignMetrics     \since 4.1     \brief whether the document uses design metrics of fonts to improve the accuracy of text layout      If this property is set to true, the layout will use design metrics.     Otherwise, the metrics of the paint device as set on     QAbstractTextDocumentLayout::setPaintDevice() will be used.      Using design metrics makes a layout have a width that is no longer dependent on hinting     and pixel-rounding. This means that WYSIWYG text layout becomes possible because the width     scales much more linearly based on paintdevice metrics than it would otherwise.      By default, this property is false. */
end_comment
begin_function
DECL|function|setUseDesignMetrics
name|void
name|QTextDocument
operator|::
name|setUseDesignMetrics
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|d
operator|->
name|defaultTextOption
operator|.
name|useDesignMetrics
argument_list|()
condition|)
return|return;
name|d
operator|->
name|defaultTextOption
operator|.
name|setUseDesignMetrics
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|useDesignMetrics
name|bool
name|QTextDocument
operator|::
name|useDesignMetrics
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultTextOption
operator|.
name|useDesignMetrics
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Draws the content of the document with painter \a p, clipped to \a rect.     If \a rect is a null rectangle (default) then the document is painted unclipped. */
end_comment
begin_function
DECL|function|drawContents
name|void
name|QTextDocument
operator|::
name|drawContents
parameter_list|(
name|QPainter
modifier|*
name|p
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|)
block|{
name|p
operator|->
name|save
argument_list|()
expr_stmt|;
name|QAbstractTextDocumentLayout
operator|::
name|PaintContext
name|ctx
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|p
operator|->
name|setClipRect
argument_list|(
name|rect
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|clip
operator|=
name|rect
expr_stmt|;
block|}
name|documentLayout
argument_list|()
operator|->
name|draw
argument_list|(
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|p
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::textWidth     \since 4.2      The text width specifies the preferred width for text in the document. If     the text (or content in general) is wider than the specified with it is broken     into multiple lines and grows vertically. If the text cannot be broken into multiple     lines to fit into the specified text width it will be larger and the size() and the     idealWidth() property will reflect that.      If the text width is set to -1 then the text will not be broken into multiple lines     unless it is enforced through an explicit line break or a new paragraph.      The default value is -1.      Setting the text width will also set the page height to -1, causing the document to     grow or shrink vertically in a continuous way. If you want the document layout to break     the text into multiple pages then you have to set the pageSize property instead.      \sa size(), idealWidth(), pageSize() */
end_comment
begin_function
DECL|function|setTextWidth
name|void
name|QTextDocument
operator|::
name|setTextWidth
parameter_list|(
name|qreal
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|QSizeF
name|sz
init|=
name|d
operator|->
name|pageSize
decl_stmt|;
name|sz
operator|.
name|setWidth
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|sz
operator|.
name|setHeight
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|setPageSize
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|textWidth
name|qreal
name|QTextDocument
operator|::
name|textWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pageSize
operator|.
name|width
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the ideal width of the text document. The ideal width is the actually used width     of the document without optional alignments taken into account. It is always<= size().width().      \sa adjustSize(), textWidth */
end_comment
begin_function
DECL|function|idealWidth
name|qreal
name|QTextDocument
operator|::
name|idealWidth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|QTextDocumentLayout
modifier|*
name|lout
init|=
name|qobject_cast
argument_list|<
name|QTextDocumentLayout
operator|*
argument_list|>
argument_list|(
name|documentLayout
argument_list|()
argument_list|)
condition|)
return|return
name|lout
operator|->
name|idealWidth
argument_list|()
return|;
return|return
name|textWidth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::documentMargin     \since 4.5       The margin around the document. The default is 4. */
end_comment
begin_function
DECL|function|documentMargin
name|qreal
name|QTextDocument
operator|::
name|documentMargin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|documentMargin
return|;
block|}
end_function
begin_function
DECL|function|setDocumentMargin
name|void
name|QTextDocument
operator|::
name|setDocumentMargin
parameter_list|(
name|qreal
name|margin
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|documentMargin
operator|!=
name|margin
condition|)
block|{
name|d
operator|->
name|documentMargin
operator|=
name|margin
expr_stmt|;
name|QTextFrame
modifier|*
name|root
init|=
name|rootFrame
argument_list|()
decl_stmt|;
name|QTextFrameFormat
name|format
init|=
name|root
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|format
operator|.
name|setMargin
argument_list|(
name|margin
argument_list|)
expr_stmt|;
name|root
operator|->
name|setFrameFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::indentWidth     \since 4.4      Returns the width used for text list and text block indenting.      The indent properties of QTextListFormat and QTextBlockFormat specify     multiples of this value. The default indent width is 40. */
end_comment
begin_function
DECL|function|indentWidth
name|qreal
name|QTextDocument
operator|::
name|indentWidth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|indentWidth
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the \a width used for text list and text block indenting.      The indent properties of QTextListFormat and QTextBlockFormat specify     multiples of this value. The default indent width is 40 .      \sa indentWidth() */
end_comment
begin_function
DECL|function|setIndentWidth
name|void
name|QTextDocument
operator|::
name|setIndentWidth
parameter_list|(
name|qreal
name|width
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|indentWidth
operator|!=
name|width
condition|)
block|{
name|d
operator|->
name|indentWidth
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Adjusts the document to a reasonable size.      \sa idealWidth(), textWidth, size */
end_comment
begin_function
DECL|function|adjustSize
name|void
name|QTextDocument
operator|::
name|adjustSize
parameter_list|()
block|{
comment|// Pull this private function in from qglobal.cpp
name|QFont
name|f
init|=
name|defaultFont
argument_list|()
decl_stmt|;
name|QFontMetrics
name|fm
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|int
name|mw
init|=
name|fm
operator|.
name|width
argument_list|(
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
argument_list|)
operator|*
literal|80
decl_stmt|;
name|int
name|w
init|=
name|mw
decl_stmt|;
name|setTextWidth
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|QSizeF
name|size
init|=
name|documentLayout
argument_list|()
operator|->
name|documentSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|.
name|width
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|w
operator|=
name|qt_int_sqrt
argument_list|(
call|(
name|uint
call|)
argument_list|(
literal|5
operator|*
name|size
operator|.
name|height
argument_list|()
operator|*
name|size
operator|.
name|width
argument_list|()
operator|/
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|setTextWidth
argument_list|(
name|qMin
argument_list|(
name|w
argument_list|,
name|mw
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|documentLayout
argument_list|()
operator|->
name|documentSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|*
literal|3
operator|<
literal|5
operator|*
name|size
operator|.
name|height
argument_list|()
condition|)
block|{
name|w
operator|=
name|qt_int_sqrt
argument_list|(
call|(
name|uint
call|)
argument_list|(
literal|2
operator|*
name|size
operator|.
name|height
argument_list|()
operator|*
name|size
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setTextWidth
argument_list|(
name|qMin
argument_list|(
name|w
argument_list|,
name|mw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|setTextWidth
argument_list|(
name|idealWidth
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::size     \since 4.2      Returns the actual size of the document.     This is equivalent to documentLayout()->documentSize();      The size of the document can be changed either by setting     a text width or setting an entire page size.      Note that the width is always>= pageSize().width().      By default, for a newly-created, empty document, this property contains     a configuration-dependent size.      \sa setTextWidth(), setPageSize(), idealWidth() */
end_comment
begin_function
DECL|function|size
name|QSizeF
name|QTextDocument
operator|::
name|size
parameter_list|()
specifier|const
block|{
return|return
name|documentLayout
argument_list|()
operator|->
name|documentSize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::blockCount     \since 4.2      Returns the number of text blocks in the document.      The value of this property is undefined in documents with tables or frames.      By default, if defined, this property contains a value of 1.     \sa lineCount(), characterCount() */
end_comment
begin_function
DECL|function|blockCount
name|int
name|QTextDocument
operator|::
name|blockCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|numNodes
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5    Returns the number of lines of this document (if the layout supports   this). Otherwise, this is identical to the number of blocks.    \sa blockCount(), characterCount()  */
end_comment
begin_function
DECL|function|lineCount
name|int
name|QTextDocument
operator|::
name|lineCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|length
argument_list|(
literal|2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5    Returns the number of characters of this document.    \sa blockCount(), characterAt()  */
end_comment
begin_function
DECL|function|characterCount
name|int
name|QTextDocument
operator|::
name|characterCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|length
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5    Returns the character at position \a pos, or a null character if the   position is out of range.    \sa characterCount()  */
end_comment
begin_function
DECL|function|characterAt
name|QChar
name|QTextDocument
operator|::
name|characterAt
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|d
operator|->
name|length
argument_list|()
condition|)
return|return
name|QChar
argument_list|()
return|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|fragIt
init|=
name|d
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|fragIt
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|const
name|int
name|offsetInFragment
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
name|fragIt
operator|.
name|position
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|text
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
operator|+
name|offsetInFragment
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::defaultStyleSheet     \since 4.2      The default style sheet is applied to all newly HTML formatted text that is     inserted into the document, for example using setHtml() or QTextCursor::insertHtml().      The style sheet needs to be compliant to CSS 2.1 syntax.      \b{Note:} Changing the default style sheet does not have any effect to the existing content     of the document.      \sa {Supported HTML Subset} */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CSSPARSER
end_ifndef
begin_function
DECL|function|setDefaultStyleSheet
name|void
name|QTextDocument
operator|::
name|setDefaultStyleSheet
parameter_list|(
specifier|const
name|QString
modifier|&
name|sheet
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|defaultStyleSheet
operator|=
name|sheet
expr_stmt|;
name|QCss
operator|::
name|Parser
name|parser
argument_list|(
name|sheet
argument_list|)
decl_stmt|;
name|d
operator|->
name|parsedDefaultStyleSheet
operator|=
name|QCss
operator|::
name|StyleSheet
argument_list|()
expr_stmt|;
name|d
operator|->
name|parsedDefaultStyleSheet
operator|.
name|origin
operator|=
name|QCss
operator|::
name|StyleSheetOrigin_UserAgent
expr_stmt|;
name|parser
operator|.
name|parse
argument_list|(
operator|&
name|d
operator|->
name|parsedDefaultStyleSheet
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|defaultStyleSheet
name|QString
name|QTextDocument
operator|::
name|defaultStyleSheet
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultStyleSheet
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CSSPARSER
end_comment
begin_comment
comment|/*!     \fn void QTextDocument::contentsChanged()      This signal is emitted whenever the document's content changes; for     example, when text is inserted or deleted, or when formatting is applied.      \sa contentsChange() */
end_comment
begin_comment
comment|/*!     \fn void QTextDocument::contentsChange(int position, int charsRemoved, int charsAdded)      This signal is emitted whenever the document's content changes; for     example, when text is inserted or deleted, or when formatting is applied.      Information is provided about the \a position of the character in the     document where the change occurred, the number of characters removed     (\a charsRemoved), and the number of characters added (\a charsAdded).      The signal is emitted before the document's layout manager is notified     about the change. This hook allows you to implement syntax highlighting     for the document.      \sa QAbstractTextDocumentLayout::documentChanged(), contentsChanged() */
end_comment
begin_comment
comment|/*!     \fn QTextDocument::undoAvailable(bool available);      This signal is emitted whenever undo operations become available     (\a available is true) or unavailable (\a available is false).      See the \l {Overview of Qt's Undo Framework}{Qt Undo Framework}     documentation for details.      \sa undo(), isUndoRedoEnabled() */
end_comment
begin_comment
comment|/*!     \fn QTextDocument::redoAvailable(bool available);      This signal is emitted whenever redo operations become available     (\a available is true) or unavailable (\a available is false). */
end_comment
begin_comment
comment|/*!     \fn QTextDocument::cursorPositionChanged(const QTextCursor&cursor);      This signal is emitted whenever the position of a cursor changed     due to an editing operation. The cursor that changed is passed in     \a cursor.  If the document is used with the QTextEdit class and you need a signal when the     cursor is moved with the arrow keys you can use the \l{QTextEdit::}{cursorPositionChanged()}     signal in QTextEdit. */
end_comment
begin_comment
comment|/*!     \fn QTextDocument::blockCountChanged(int newBlockCount);     \since 4.3      This signal is emitted when the total number of text blocks in the     document changes. The value passed in \a newBlockCount is the new     total. */
end_comment
begin_comment
comment|/*!     \fn QTextDocument::documentLayoutChanged();     \since 4.4      This signal is emitted when a new document layout is set.      \sa setDocumentLayout()  */
end_comment
begin_comment
comment|/*!     Returns true if undo is available; otherwise returns false.      \sa isRedoAvailable(), availableUndoSteps() */
end_comment
begin_function
DECL|function|isUndoAvailable
name|bool
name|QTextDocument
operator|::
name|isUndoAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isUndoAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if redo is available; otherwise returns false.      \sa isUndoAvailable(), availableRedoSteps() */
end_comment
begin_function
DECL|function|isRedoAvailable
name|bool
name|QTextDocument
operator|::
name|isRedoAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|isRedoAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.6      Returns the number of available undo steps.      \sa isUndoAvailable() */
end_comment
begin_function
DECL|function|availableUndoSteps
name|int
name|QTextDocument
operator|::
name|availableUndoSteps
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|availableUndoSteps
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.6      Returns the number of available redo steps.      \sa isRedoAvailable() */
end_comment
begin_function
DECL|function|availableRedoSteps
name|int
name|QTextDocument
operator|::
name|availableRedoSteps
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|availableRedoSteps
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.4      Returns the document's revision (if undo is enabled).      The revision is guaranteed to increase when a document that is not     modified is edited.      \sa QTextBlock::revision(), isModified()  */
end_comment
begin_function
DECL|function|revision
name|int
name|QTextDocument
operator|::
name|revision
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|revision
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the document to use the given \a layout. The previous layout     is deleted.      \sa documentLayoutChanged() */
end_comment
begin_function
DECL|function|setDocumentLayout
name|void
name|QTextDocument
operator|::
name|setDocumentLayout
parameter_list|(
name|QAbstractTextDocumentLayout
modifier|*
name|layout
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|setLayout
argument_list|(
name|layout
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the document layout for this document. */
end_comment
begin_function
DECL|function|documentLayout
name|QAbstractTextDocumentLayout
modifier|*
name|QTextDocument
operator|::
name|documentLayout
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|lout
condition|)
block|{
name|QTextDocument
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|d_func
argument_list|()
operator|->
name|setLayout
argument_list|(
operator|new
name|QTextDocumentLayout
argument_list|(
name|that
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|lout
return|;
block|}
end_function
begin_comment
comment|/*!     Returns meta information about the document of the type specified by     \a info.      \sa setMetaInformation() */
end_comment
begin_function
DECL|function|metaInformation
name|QString
name|QTextDocument
operator|::
name|metaInformation
parameter_list|(
name|MetaInformation
name|info
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|DocumentTitle
case|:
return|return
name|d
operator|->
name|title
return|;
case|case
name|DocumentUrl
case|:
return|return
name|d
operator|->
name|url
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the document's meta information of the type specified by \a info     to the given \a string.      \sa metaInformation() */
end_comment
begin_function
DECL|function|setMetaInformation
name|void
name|QTextDocument
operator|::
name|setMetaInformation
parameter_list|(
name|MetaInformation
name|info
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|DocumentTitle
case|:
name|d
operator|->
name|title
operator|=
name|string
expr_stmt|;
break|break;
case|case
name|DocumentUrl
case|:
name|d
operator|->
name|url
operator|=
name|string
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the plain text contained in the document. If you want     formatting information use a QTextCursor instead.      \sa toHtml() */
end_comment
begin_function
DECL|function|toPlainText
name|QString
name|QTextDocument
operator|::
name|toPlainText
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
name|QString
name|txt
init|=
name|d
operator|->
name|plainText
argument_list|()
decl_stmt|;
name|QChar
modifier|*
name|uc
init|=
name|txt
operator|.
name|data
argument_list|()
decl_stmt|;
name|QChar
modifier|*
name|e
init|=
name|uc
operator|+
name|txt
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|uc
operator|!=
name|e
condition|;
operator|++
name|uc
control|)
block|{
switch|switch
condition|(
name|uc
operator|->
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|0xfdd0
case|:
comment|// QTextBeginningOfFrame
case|case
literal|0xfdd1
case|:
comment|// QTextEndOfFrame
case|case
name|QChar
operator|::
name|ParagraphSeparator
case|:
case|case
name|QChar
operator|::
name|LineSeparator
case|:
operator|*
name|uc
operator|=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|QChar
operator|::
name|Nbsp
case|:
operator|*
name|uc
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
return|return
name|txt
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces the entire contents of the document with the given plain     \a text.      \sa setHtml() */
end_comment
begin_function
DECL|function|setPlainText
name|void
name|QTextDocument
operator|::
name|setPlainText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|bool
name|previousState
init|=
name|d
operator|->
name|isUndoRedoEnabled
argument_list|()
decl_stmt|;
name|d
operator|->
name|enableUndoRedo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QTextCursor
argument_list|(
name|this
argument_list|)
operator|.
name|insertText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|d
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|enableUndoRedo
argument_list|(
name|previousState
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Replaces the entire contents of the document with the given     HTML-formatted text in the \a html string.      The HTML formatting is respected as much as possible; for example,     "<b>bold</b> text" will produce text where the first word has a font     weight that gives it a bold appearance: "\b{bold} text".      \note It is the responsibility of the caller to make sure that the     text is correctly decoded when a QString containing HTML is created     and passed to setHtml().      \sa setPlainText(), {Supported HTML Subset} */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|setHtml
name|void
name|QTextDocument
operator|::
name|setHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|html
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|bool
name|previousState
init|=
name|d
operator|->
name|isUndoRedoEnabled
argument_list|()
decl_stmt|;
name|d
operator|->
name|enableUndoRedo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QTextHtmlImporter
argument_list|(
name|this
argument_list|,
name|html
argument_list|,
name|QTextHtmlImporter
operator|::
name|ImportToDocument
argument_list|)
operator|.
name|import
argument_list|()
expr_stmt|;
name|d
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|enableUndoRedo
argument_list|(
name|previousState
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     \enum QTextDocument::FindFlag      This enum describes the options available to QTextDocument's find function. The options     can be OR-ed together from the following list:      \value FindBackward Search backwards instead of forwards.     \value FindCaseSensitively By default find works case insensitive. Specifying this option     changes the behaviour to a case sensitive find operation.     \value FindWholeWords Makes find match only complete words. */
end_comment
begin_comment
comment|/*!     \enum QTextDocument::MetaInformation      This enum describes the different types of meta information that can be     added to a document.      \value DocumentTitle    The title of the document.     \value DocumentUrl      The url of the document. The loadResource() function uses                             this url as the base when loading relative resources.      \sa metaInformation(), setMetaInformation() */
end_comment
begin_comment
comment|/*!     \fn QTextCursor QTextDocument::find(const QString&subString, int position, FindFlags options) const      \overload      Finds the next occurrence of the string, \a subString, in the document.     The search starts at the given \a position, and proceeds forwards     through the document unless specified otherwise in the search options.     The \a options control the type of search performed.      Returns a cursor with the match selected if \a subString     was found; otherwise returns a null cursor.      If the \a position is 0 (the default) the search begins from the beginning     of the document; otherwise it begins at the specified position. */
end_comment
begin_function
DECL|function|find
name|QTextCursor
name|QTextDocument
operator|::
name|find
parameter_list|(
specifier|const
name|QString
modifier|&
name|subString
parameter_list|,
name|int
name|from
parameter_list|,
name|FindFlags
name|options
parameter_list|)
specifier|const
block|{
name|QRegExp
name|expr
argument_list|(
name|subString
argument_list|)
decl_stmt|;
name|expr
operator|.
name|setPatternSyntax
argument_list|(
name|QRegExp
operator|::
name|FixedString
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setCaseSensitivity
argument_list|(
operator|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindCaseSensitively
operator|)
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
expr_stmt|;
return|return
name|find
argument_list|(
name|expr
argument_list|,
name|from
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCursor QTextDocument::find(const QString&subString, const QTextCursor&cursor, FindFlags options) const      Finds the next occurrence of the string, \a subString, in the document.     The search starts at the position of the given \a cursor, and proceeds     forwards through the document unless specified otherwise in the search     options. The \a options control the type of search performed.      Returns a cursor with the match selected if \a subString was found; otherwise     returns a null cursor.      If the given \a cursor has a selection, the search begins after the     selection; otherwise it begins at the cursor's position.      By default the search is case-sensitive, and can match text anywhere in the     document. */
end_comment
begin_function
DECL|function|find
name|QTextCursor
name|QTextDocument
operator|::
name|find
parameter_list|(
specifier|const
name|QString
modifier|&
name|subString
parameter_list|,
specifier|const
name|QTextCursor
modifier|&
name|from
parameter_list|,
name|FindFlags
name|options
parameter_list|)
specifier|const
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindBackward
condition|)
name|pos
operator|=
name|from
operator|.
name|selectionStart
argument_list|()
expr_stmt|;
else|else
name|pos
operator|=
name|from
operator|.
name|selectionEnd
argument_list|()
expr_stmt|;
block|}
name|QRegExp
name|expr
argument_list|(
name|subString
argument_list|)
decl_stmt|;
name|expr
operator|.
name|setPatternSyntax
argument_list|(
name|QRegExp
operator|::
name|FixedString
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setCaseSensitivity
argument_list|(
operator|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindCaseSensitively
operator|)
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
expr_stmt|;
return|return
name|find
argument_list|(
name|expr
argument_list|,
name|pos
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findInBlock
specifier|static
name|bool
name|findInBlock
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|expression
parameter_list|,
name|int
name|offset
parameter_list|,
name|QTextDocument
operator|::
name|FindFlags
name|options
parameter_list|,
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|QRegExp
name|expr
argument_list|(
name|expression
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|block
operator|.
name|text
argument_list|()
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|QChar
operator|::
name|Nbsp
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<=
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|idx
operator|=
operator|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindBackward
operator|)
condition|?
name|expr
operator|.
name|lastIndexIn
argument_list|(
name|text
argument_list|,
name|offset
argument_list|)
else|:
name|expr
operator|.
name|indexIn
argument_list|(
name|text
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindWholeWords
condition|)
block|{
specifier|const
name|int
name|start
init|=
name|idx
decl_stmt|;
specifier|const
name|int
name|end
init|=
name|start
operator|+
name|expr
operator|.
name|matchedLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|!=
literal|0
operator|&&
name|text
operator|.
name|at
argument_list|(
name|start
operator|-
literal|1
argument_list|)
operator|.
name|isLetterOrNumber
argument_list|()
operator|)
operator|||
operator|(
name|end
operator|!=
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|end
argument_list|)
operator|.
name|isLetterOrNumber
argument_list|()
operator|)
condition|)
block|{
comment|//if this is not a whole word, continue the search in the string
name|offset
operator|=
operator|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindBackward
operator|)
condition|?
name|idx
operator|-
literal|1
else|:
name|end
operator|+
literal|1
expr_stmt|;
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|//we have a hit, return the cursor for that.
break|break;
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|cursor
operator|=
name|QTextCursor
argument_list|(
name|block
operator|.
name|docHandle
argument_list|()
argument_list|,
name|block
operator|.
name|position
argument_list|()
operator|+
name|idx
argument_list|)
expr_stmt|;
name|cursor
operator|.
name|setPosition
argument_list|(
name|cursor
operator|.
name|position
argument_list|()
operator|+
name|expr
operator|.
name|matchedLength
argument_list|()
argument_list|,
name|QTextCursor
operator|::
name|KeepAnchor
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCursor QTextDocument::find(const QRegExp& expr, int position, FindFlags options) const      \overload      Finds the next occurrence, matching the regular expression, \a expr, in the document.     The search starts at the given \a position, and proceeds forwards     through the document unless specified otherwise in the search options.     The \a options control the type of search performed. The FindCaseSensitively     option is ignored for this overload, use QRegExp::caseSensitivity instead.      Returns a cursor with the match selected if a match was found; otherwise     returns a null cursor.      If the \a position is 0 (the default) the search begins from the beginning     of the document; otherwise it begins at the specified position. */
end_comment
begin_function
DECL|function|find
name|QTextCursor
name|QTextDocument
operator|::
name|find
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|expr
parameter_list|,
name|int
name|from
parameter_list|,
name|FindFlags
name|options
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QTextCursor
argument_list|()
return|;
name|int
name|pos
init|=
name|from
decl_stmt|;
comment|//the cursor is positioned between characters, so for a backward search
comment|//do not include the character given in the position.
if|if
condition|(
name|options
operator|&
name|FindBackward
condition|)
block|{
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|QTextCursor
argument_list|()
return|;
block|}
name|QTextCursor
name|cursor
decl_stmt|;
name|QTextBlock
name|block
init|=
name|d
operator|->
name|blocksFind
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|FindBackward
operator|)
condition|)
block|{
name|int
name|blockOffset
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
name|block
operator|.
name|position
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|block
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|findInBlock
argument_list|(
name|block
argument_list|,
name|expr
argument_list|,
name|blockOffset
argument_list|,
name|options
argument_list|,
name|cursor
argument_list|)
condition|)
return|return
name|cursor
return|;
name|blockOffset
operator|=
literal|0
expr_stmt|;
name|block
operator|=
name|block
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|blockOffset
init|=
name|pos
operator|-
name|block
operator|.
name|position
argument_list|()
decl_stmt|;
while|while
condition|(
name|block
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|findInBlock
argument_list|(
name|block
argument_list|,
name|expr
argument_list|,
name|blockOffset
argument_list|,
name|options
argument_list|,
name|cursor
argument_list|)
condition|)
return|return
name|cursor
return|;
name|block
operator|=
name|block
operator|.
name|previous
argument_list|()
expr_stmt|;
name|blockOffset
operator|=
name|block
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|QTextCursor
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCursor QTextDocument::find(const QRegExp&expr, const QTextCursor&cursor, FindFlags options) const      Finds the next occurrence, matching the regular expression, \a expr, in the document.     The search starts at the position of the given \a cursor, and proceeds     forwards through the document unless specified otherwise in the search     options. The \a options control the type of search performed. The FindCaseSensitively     option is ignored for this overload, use QRegExp::caseSensitivity instead.      Returns a cursor with the match selected if a match was found; otherwise     returns a null cursor.      If the given \a cursor has a selection, the search begins after the     selection; otherwise it begins at the cursor's position.      By default the search is case-sensitive, and can match text anywhere in the     document. */
end_comment
begin_function
DECL|function|find
name|QTextCursor
name|QTextDocument
operator|::
name|find
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|expr
parameter_list|,
specifier|const
name|QTextCursor
modifier|&
name|from
parameter_list|,
name|FindFlags
name|options
parameter_list|)
specifier|const
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|from
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|QTextDocument
operator|::
name|FindBackward
condition|)
name|pos
operator|=
name|from
operator|.
name|selectionStart
argument_list|()
expr_stmt|;
else|else
name|pos
operator|=
name|from
operator|.
name|selectionEnd
argument_list|()
expr_stmt|;
block|}
return|return
name|find
argument_list|(
name|expr
argument_list|,
name|pos
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextObject *QTextDocument::createObject(const QTextFormat&format)      Creates and returns a new document object (a QTextObject), based     on the given \a format.      QTextObjects will always get created through this method, so you     must reimplement it if you use custom text objects inside your document. */
end_comment
begin_function
DECL|function|createObject
name|QTextObject
modifier|*
name|QTextDocument
operator|::
name|createObject
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|f
parameter_list|)
block|{
name|QTextObject
modifier|*
name|obj
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isListFormat
argument_list|()
condition|)
name|obj
operator|=
operator|new
name|QTextList
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|isTableFormat
argument_list|()
condition|)
name|obj
operator|=
operator|new
name|QTextTable
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|isFrameFormat
argument_list|()
condition|)
name|obj
operator|=
operator|new
name|QTextFrame
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the frame that contains the text cursor position \a pos. */
end_comment
begin_function
DECL|function|frameAt
name|QTextFrame
modifier|*
name|QTextDocument
operator|::
name|frameAt
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|frameAt
argument_list|(
name|pos
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document's root frame. */
end_comment
begin_function
DECL|function|rootFrame
name|QTextFrame
modifier|*
name|QTextDocument
operator|::
name|rootFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|rootFrame
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text object associated with the given \a objectIndex. */
end_comment
begin_function
DECL|function|object
name|QTextObject
modifier|*
name|QTextDocument
operator|::
name|object
parameter_list|(
name|int
name|objectIndex
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|objectForIndex
argument_list|(
name|objectIndex
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text object associated with the format \a f. */
end_comment
begin_function
DECL|function|objectForFormat
name|QTextObject
modifier|*
name|QTextDocument
operator|::
name|objectForFormat
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|f
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|objectForFormat
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text block that contains the \a{pos}-th character. */
end_comment
begin_function
DECL|function|findBlock
name|QTextBlock
name|QTextDocument
operator|::
name|findBlock
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|pos
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns the text block with the specified \a blockNumber.      \sa QTextBlock::blockNumber() */
end_comment
begin_function
DECL|function|findBlockByNumber
name|QTextBlock
name|QTextDocument
operator|::
name|findBlockByNumber
parameter_list|(
name|int
name|blockNumber
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|blockNumber
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Returns the text block that contains the specified \a lineNumber.      \sa QTextBlock::firstLineNumber() */
end_comment
begin_function
DECL|function|findBlockByLineNumber
name|QTextBlock
name|QTextDocument
operator|::
name|findBlockByLineNumber
parameter_list|(
name|int
name|lineNumber
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|lineNumber
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document's first text block.      \sa firstBlock() */
end_comment
begin_function
DECL|function|begin
name|QTextBlock
name|QTextDocument
operator|::
name|begin
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|begin
argument_list|()
operator|.
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This function returns a block to test for the end of the document     while iterating over it.      \snippet textdocumentendsnippet.cpp 0      The block returned is invalid and represents the block after the     last block in the document. You can use lastBlock() to retrieve the     last valid block of the document.      \sa lastBlock() */
end_comment
begin_function
DECL|function|end
name|QTextBlock
name|QTextDocument
operator|::
name|end
parameter_list|()
specifier|const
block|{
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns the document's first text block. */
end_comment
begin_function
DECL|function|firstBlock
name|QTextBlock
name|QTextDocument
operator|::
name|firstBlock
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|begin
argument_list|()
operator|.
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Returns the document's last (valid) text block. */
end_comment
begin_function
DECL|function|lastBlock
name|QTextBlock
name|QTextDocument
operator|::
name|lastBlock
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|QTextBlock
argument_list|(
name|docHandle
argument_list|()
argument_list|,
name|d
operator|->
name|blockMap
argument_list|()
operator|.
name|last
argument_list|()
operator|.
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTextDocument::pageSize     \brief the page size that should be used for laying out the document      By default, for a newly-created, empty document, this property contains     an undefined size.      \sa modificationChanged() */
end_comment
begin_function
DECL|function|setPageSize
name|void
name|QTextDocument
operator|::
name|setPageSize
parameter_list|(
specifier|const
name|QSizeF
modifier|&
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|pageSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pageSize
name|QSizeF
name|QTextDocument
operator|::
name|pageSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pageSize
return|;
block|}
end_function
begin_comment
comment|/*!   returns the number of pages in this document. */
end_comment
begin_function
DECL|function|pageCount
name|int
name|QTextDocument
operator|::
name|pageCount
parameter_list|()
specifier|const
block|{
return|return
name|documentLayout
argument_list|()
operator|->
name|pageCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the default \a font to use in the document layout. */
end_comment
begin_function
DECL|function|setDefaultFont
name|void
name|QTextDocument
operator|::
name|setDefaultFont
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDefaultFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|lout
condition|)
name|d
operator|->
name|lout
operator|->
name|documentChanged
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default font to be used in the document layout. */
end_comment
begin_function
DECL|function|defaultFont
name|QFont
name|QTextDocument
operator|::
name|defaultFont
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|defaultFont
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextDocument::modificationChanged(bool changed)      This signal is emitted whenever the content of the document     changes in a way that affects the modification state. If \a     changed is true, the document has been modified; otherwise it is     false.      For example, calling setModified(false) on a document and then     inserting text causes the signal to get emitted. If you undo that     operation, causing the document to return to its original     unmodified state, the signal will get emitted again. */
end_comment
begin_comment
comment|/*!     \property QTextDocument::modified     \brief whether the document has been modified by the user      By default, this property is false.      \sa modificationChanged() */
end_comment
begin_function
DECL|function|isModified
name|bool
name|QTextDocument
operator|::
name|isModified
parameter_list|()
specifier|const
block|{
return|return
name|docHandle
argument_list|()
operator|->
name|isModified
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setModified
name|void
name|QTextDocument
operator|::
name|setModified
parameter_list|(
name|bool
name|m
parameter_list|)
block|{
name|docHandle
argument_list|()
operator|->
name|setModified
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PRINTER
end_ifndef
begin_function
DECL|function|printPage
specifier|static
name|void
name|printPage
parameter_list|(
name|int
name|index
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QTextDocument
modifier|*
name|doc
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|body
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pageNumberPos
parameter_list|)
block|{
name|painter
operator|->
name|save
argument_list|()
expr_stmt|;
name|painter
operator|->
name|translate
argument_list|(
name|body
operator|.
name|left
argument_list|()
argument_list|,
name|body
operator|.
name|top
argument_list|()
operator|-
operator|(
name|index
operator|-
literal|1
operator|)
operator|*
name|body
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QRectF
name|view
argument_list|(
literal|0
argument_list|,
operator|(
name|index
operator|-
literal|1
operator|)
operator|*
name|body
operator|.
name|height
argument_list|()
argument_list|,
name|body
operator|.
name|width
argument_list|()
argument_list|,
name|body
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
name|QAbstractTextDocumentLayout
modifier|*
name|layout
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
decl_stmt|;
name|QAbstractTextDocumentLayout
operator|::
name|PaintContext
name|ctx
decl_stmt|;
name|painter
operator|->
name|setClipRect
argument_list|(
name|view
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|clip
operator|=
name|view
expr_stmt|;
comment|// don't use the system palette text as default text color, on HP/UX
comment|// for example that's white, and white text on white paper doesn't
comment|// look that nice
name|ctx
operator|.
name|palette
operator|.
name|setColor
argument_list|(
name|QPalette
operator|::
name|Text
argument_list|,
name|Qt
operator|::
name|black
argument_list|)
expr_stmt|;
name|layout
operator|->
name|draw
argument_list|(
name|painter
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pageNumberPos
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|painter
operator|->
name|setClipping
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|painter
operator|->
name|setFont
argument_list|(
name|QFont
argument_list|(
name|doc
operator|->
name|defaultFont
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|pageString
init|=
name|QString
operator|::
name|number
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|painter
operator|->
name|drawText
argument_list|(
name|qRound
argument_list|(
name|pageNumberPos
operator|.
name|x
argument_list|()
operator|-
name|painter
operator|->
name|fontMetrics
argument_list|()
operator|.
name|width
argument_list|(
name|pageString
argument_list|)
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|pageNumberPos
operator|.
name|y
argument_list|()
operator|+
name|view
operator|.
name|top
argument_list|()
argument_list|)
argument_list|,
name|pageString
argument_list|)
expr_stmt|;
block|}
name|painter
operator|->
name|restore
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Prints the document to the given \a printer. The QPageablePaintDevice must be     set up before being used with this function.      This is only a convenience method to print the whole document to the printer.      If the document is already paginated through a specified height in the pageSize()     property it is printed as-is.      If the document is not paginated, like for example a document used in a QTextEdit,     then a temporary copy of the document is created and the copy is broken into     multiple pages according to the size of the paint device's paperRect(). By default     a 2 cm margin is set around the document contents. In addition the current page     number is printed at the bottom of each page.      \sa QTextEdit::print() */
end_comment
begin_function
DECL|function|print
name|void
name|QTextDocument
operator|::
name|print
parameter_list|(
name|QPagedPaintDevice
modifier|*
name|printer
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|printer
condition|)
return|return;
name|bool
name|documentPaginated
init|=
name|d
operator|->
name|pageSize
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|pageSize
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|pageSize
operator|.
name|height
argument_list|()
operator|!=
name|INT_MAX
decl_stmt|;
name|QPagedPaintDevicePrivate
modifier|*
name|pd
init|=
name|QPagedPaintDevicePrivate
operator|::
name|get
argument_list|(
name|printer
argument_list|)
decl_stmt|;
comment|// ### set page size to paginated size?
name|QPagedPaintDevice
operator|::
name|Margins
name|m
init|=
name|printer
operator|->
name|margins
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|documentPaginated
operator|&&
name|m
operator|.
name|left
operator|==
literal|0.
operator|&&
name|m
operator|.
name|right
operator|==
literal|0.
operator|&&
name|m
operator|.
name|top
operator|==
literal|0.
operator|&&
name|m
operator|.
name|bottom
operator|==
literal|0.
condition|)
block|{
name|m
operator|.
name|left
operator|=
name|m
operator|.
name|right
operator|=
name|m
operator|.
name|top
operator|=
name|m
operator|.
name|bottom
operator|=
literal|2.
expr_stmt|;
name|printer
operator|->
name|setMargins
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|// ### use the margins correctly
name|QPainter
name|p
argument_list|(
name|printer
argument_list|)
decl_stmt|;
comment|// Check that there is a valid device to print to.
if|if
condition|(
operator|!
name|p
operator|.
name|isActive
argument_list|()
condition|)
return|return;
specifier|const
name|QTextDocument
modifier|*
name|doc
init|=
name|this
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QTextDocument
argument_list|>
name|clonedDoc
decl_stmt|;
operator|(
name|void
operator|)
name|doc
operator|->
name|documentLayout
argument_list|()
expr_stmt|;
comment|// make sure that there is a layout
name|QRectF
name|body
init|=
name|QRectF
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|d
operator|->
name|pageSize
argument_list|)
decl_stmt|;
name|QPointF
name|pageNumberPos
decl_stmt|;
if|if
condition|(
name|documentPaginated
condition|)
block|{
name|qreal
name|sourceDpiX
init|=
name|qt_defaultDpi
argument_list|()
decl_stmt|;
name|qreal
name|sourceDpiY
init|=
name|sourceDpiX
decl_stmt|;
name|QPaintDevice
modifier|*
name|dev
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
operator|->
name|paintDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
name|sourceDpiX
operator|=
name|dev
operator|->
name|logicalDpiX
argument_list|()
expr_stmt|;
name|sourceDpiY
operator|=
name|dev
operator|->
name|logicalDpiY
argument_list|()
expr_stmt|;
block|}
specifier|const
name|qreal
name|dpiScaleX
init|=
name|qreal
argument_list|(
name|printer
operator|->
name|logicalDpiX
argument_list|()
argument_list|)
operator|/
name|sourceDpiX
decl_stmt|;
specifier|const
name|qreal
name|dpiScaleY
init|=
name|qreal
argument_list|(
name|printer
operator|->
name|logicalDpiY
argument_list|()
argument_list|)
operator|/
name|sourceDpiY
decl_stmt|;
comment|// scale to dpi
name|p
operator|.
name|scale
argument_list|(
name|dpiScaleX
argument_list|,
name|dpiScaleY
argument_list|)
expr_stmt|;
name|QSizeF
name|scaledPageSize
init|=
name|d
operator|->
name|pageSize
decl_stmt|;
name|scaledPageSize
operator|.
name|rwidth
argument_list|()
operator|*=
name|dpiScaleX
expr_stmt|;
name|scaledPageSize
operator|.
name|rheight
argument_list|()
operator|*=
name|dpiScaleY
expr_stmt|;
specifier|const
name|QSizeF
name|printerPageSize
argument_list|(
name|printer
operator|->
name|width
argument_list|()
argument_list|,
name|printer
operator|->
name|height
argument_list|()
argument_list|)
decl_stmt|;
comment|// scale to page
name|p
operator|.
name|scale
argument_list|(
name|printerPageSize
operator|.
name|width
argument_list|()
operator|/
name|scaledPageSize
operator|.
name|width
argument_list|()
argument_list|,
name|printerPageSize
operator|.
name|height
argument_list|()
operator|/
name|scaledPageSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doc
operator|=
name|clone
argument_list|(
cast|const_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|clonedDoc
operator|.
name|reset
argument_list|(
cast|const_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|doc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|QTextBlock
name|srcBlock
init|=
name|firstBlock
argument_list|()
init|,
name|dstBlock
init|=
name|clonedDoc
operator|->
name|firstBlock
argument_list|()
init|;
name|srcBlock
operator|.
name|isValid
argument_list|()
operator|&&
name|dstBlock
operator|.
name|isValid
argument_list|()
condition|;
name|srcBlock
operator|=
name|srcBlock
operator|.
name|next
argument_list|()
operator|,
name|dstBlock
operator|=
name|dstBlock
operator|.
name|next
argument_list|()
control|)
block|{
name|dstBlock
operator|.
name|layout
argument_list|()
operator|->
name|setAdditionalFormats
argument_list|(
name|srcBlock
operator|.
name|layout
argument_list|()
operator|->
name|additionalFormats
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QAbstractTextDocumentLayout
modifier|*
name|layout
init|=
name|doc
operator|->
name|documentLayout
argument_list|()
decl_stmt|;
name|layout
operator|->
name|setPaintDevice
argument_list|(
name|p
operator|.
name|device
argument_list|()
argument_list|)
expr_stmt|;
comment|// copy the custom object handlers
name|layout
operator|->
name|d_func
argument_list|()
operator|->
name|handlers
operator|=
name|documentLayout
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|handlers
expr_stmt|;
name|int
name|dpiy
init|=
name|p
operator|.
name|device
argument_list|()
operator|->
name|logicalDpiY
argument_list|()
decl_stmt|;
name|int
name|margin
init|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|2
operator|/
literal|2.54
operator|)
operator|*
name|dpiy
argument_list|)
decl_stmt|;
comment|// 2 cm margins
name|QTextFrameFormat
name|fmt
init|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|fmt
operator|.
name|setMargin
argument_list|(
name|margin
argument_list|)
expr_stmt|;
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|setFrameFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|body
operator|=
name|QRectF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|printer
operator|->
name|width
argument_list|()
argument_list|,
name|printer
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|pageNumberPos
operator|=
name|QPointF
argument_list|(
name|body
operator|.
name|width
argument_list|()
operator|-
name|margin
argument_list|,
name|body
operator|.
name|height
argument_list|()
operator|-
name|margin
operator|+
name|QFontMetrics
argument_list|(
name|doc
operator|->
name|defaultFont
argument_list|()
argument_list|,
name|p
operator|.
name|device
argument_list|()
argument_list|)
operator|.
name|ascent
argument_list|()
operator|+
literal|5
operator|*
name|dpiy
operator|/
literal|72.0
argument_list|)
expr_stmt|;
name|clonedDoc
operator|->
name|setPageSize
argument_list|(
name|body
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|fromPage
init|=
name|pd
operator|->
name|fromPage
decl_stmt|;
name|int
name|toPage
init|=
name|pd
operator|->
name|toPage
decl_stmt|;
name|bool
name|ascending
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|fromPage
operator|==
literal|0
operator|&&
name|toPage
operator|==
literal|0
condition|)
block|{
name|fromPage
operator|=
literal|1
expr_stmt|;
name|toPage
operator|=
name|doc
operator|->
name|pageCount
argument_list|()
expr_stmt|;
block|}
comment|// paranoia check
name|fromPage
operator|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|fromPage
argument_list|)
expr_stmt|;
name|toPage
operator|=
name|qMin
argument_list|(
name|doc
operator|->
name|pageCount
argument_list|()
argument_list|,
name|toPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|toPage
operator|<
name|fromPage
condition|)
block|{
comment|// if the user entered a page range outside the actual number
comment|// of printable pages, just return
return|return;
block|}
comment|//    if (printer->pageOrder() == QPrinter::LastPageFirst) {
comment|//        int tmp = fromPage;
comment|//        fromPage = toPage;
comment|//        toPage = tmp;
comment|//        ascending = false;
comment|//    }
name|int
name|page
init|=
name|fromPage
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|printPage
argument_list|(
name|page
argument_list|,
operator|&
name|p
argument_list|,
name|doc
argument_list|,
name|body
argument_list|,
name|pageNumberPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|==
name|toPage
condition|)
break|break;
if|if
condition|(
name|ascending
condition|)
operator|++
name|page
expr_stmt|;
else|else
operator|--
name|page
expr_stmt|;
if|if
condition|(
operator|!
name|printer
operator|->
name|newPage
argument_list|()
condition|)
return|return;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \enum QTextDocument::ResourceType      This enum describes the types of resources that can be loaded by     QTextDocument's loadResource() function.      \value HtmlResource  The resource contains HTML.     \value ImageResource The resource contains image data.                          Currently supported data types are QVariant::Pixmap and                          QVariant::Image. If the corresponding variant is of type                          QVariant::ByteArray then Qt attempts to load the image using                          QImage::loadFromData. QVariant::Icon is currently not supported.                          The icon needs to be converted to one of the supported types first,                          for example using QIcon::pixmap.     \value StyleSheetResource The resource contains CSS.     \value UserResource  The first available value for user defined                          resource types.      \sa loadResource() */
end_comment
begin_comment
comment|/*!     Returns data of the specified \a type from the resource with the     given \a name.      This function is called by the rich text engine to request data that isn't     directly stored by QTextDocument, but still associated with it. For example,     images are referenced indirectly by the name attribute of a QTextImageFormat     object.      Resources are cached internally in the document. If a resource can     not be found in the cache, loadResource is called to try to load     the resource. loadResource should then use addResource to add the     resource to the cache.      \sa QTextDocument::ResourceType */
end_comment
begin_function
DECL|function|resource
name|QVariant
name|QTextDocument
operator|::
name|resource
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
name|QVariant
name|r
init|=
name|d
operator|->
name|resources
operator|.
name|value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|r
operator|=
name|d
operator|->
name|cachedResources
operator|.
name|value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|isValid
argument_list|()
condition|)
name|r
operator|=
cast|const_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|loadResource
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the resource \a resource to the resource cache, using \a     type and \a name as identifiers. \a type should be a value from     QTextDocument::ResourceType.      For example, you can add an image as a resource in order to reference it     from within the document:      \snippet textdocument-resources/main.cpp Adding a resource      The image can be inserted into the document using the QTextCursor API:      \snippet textdocument-resources/main.cpp Inserting an image with a cursor      Alternatively, you can insert images using the HTML \c img tag:      \snippet textdocument-resources/main.cpp Inserting an image using HTML */
end_comment
begin_function
DECL|function|addResource
name|void
name|QTextDocument
operator|::
name|addResource
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|resource
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|d
operator|->
name|resources
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Loads data of the specified \a type from the resource with the     given \a name.      This function is called by the rich text engine to request data that isn't     directly stored by QTextDocument, but still associated with it. For example,     images are referenced indirectly by the name attribute of a QTextImageFormat     object.      When called by Qt, \a type is one of the values of     QTextDocument::ResourceType.      If the QTextDocument is a child object of a QObject that has an invokable     loadResource method such as QTextEdit, QTextBrowser     or a QTextDocument itself then the default implementation tries     to retrieve the data from the parent. */
end_comment
begin_function
DECL|function|loadResource
name|QVariant
name|QTextDocument
operator|::
name|loadResource
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextDocument
argument_list|)
expr_stmt|;
name|QVariant
name|r
decl_stmt|;
name|QObject
modifier|*
name|p
init|=
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|me
init|=
name|p
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|me
operator|->
name|indexOfMethod
argument_list|(
literal|"loadResource(int,QUrl)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|QMetaMethod
name|loader
init|=
name|me
operator|->
name|method
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|loader
operator|.
name|invoke
argument_list|(
name|p
argument_list|,
name|Q_RETURN_ARG
argument_list|(
name|QVariant
argument_list|,
name|r
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|int
argument_list|,
name|type
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QUrl
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// handle data: URLs
if|if
condition|(
name|r
operator|.
name|isNull
argument_list|()
operator|&&
name|name
operator|.
name|scheme
argument_list|()
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"data"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|QString
name|mimetype
decl_stmt|;
name|QByteArray
name|payload
decl_stmt|;
if|if
condition|(
name|qDecodeDataUrl
argument_list|(
name|name
argument_list|,
name|mimetype
argument_list|,
name|payload
argument_list|)
condition|)
name|r
operator|=
name|payload
expr_stmt|;
block|}
comment|// if resource was not loaded try to load it here
if|if
condition|(
operator|!
name|qobject_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
operator|&&
name|r
operator|.
name|isNull
argument_list|()
operator|&&
name|name
operator|.
name|isRelative
argument_list|()
condition|)
block|{
name|QUrl
name|currentURL
init|=
name|d
operator|->
name|url
decl_stmt|;
name|QUrl
name|resourceUrl
init|=
name|name
decl_stmt|;
comment|// For the second case QUrl can merge "#someanchor" with "foo.html"
comment|// correctly to "foo.html#someanchor"
if|if
condition|(
operator|!
operator|(
name|currentURL
operator|.
name|isRelative
argument_list|()
operator|||
operator|(
name|currentURL
operator|.
name|scheme
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
operator|&&
operator|!
name|QFileInfo
argument_list|(
name|currentURL
operator|.
name|toLocalFile
argument_list|()
argument_list|)
operator|.
name|isAbsolute
argument_list|()
operator|)
operator|)
operator|||
operator|(
name|name
operator|.
name|hasFragment
argument_list|()
operator|&&
name|name
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|resourceUrl
operator|=
name|currentURL
operator|.
name|resolved
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this is our last resort when current url and new url are both relative
comment|// we try to resolve against the current working directory in the local
comment|// file system.
name|QFileInfo
name|fi
argument_list|(
name|currentURL
operator|.
name|toLocalFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|resourceUrl
operator|=
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|fi
operator|.
name|absolutePath
argument_list|()
operator|+
name|QDir
operator|::
name|separator
argument_list|()
argument_list|)
operator|.
name|resolved
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentURL
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resourceUrl
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|QString
name|s
init|=
name|resourceUrl
operator|.
name|toLocalFile
argument_list|()
decl_stmt|;
name|QFile
name|f
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|isEmpty
argument_list|()
operator|&&
name|f
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|r
operator|=
name|f
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|f
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|r
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ImageResource
operator|&&
name|r
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|ByteArray
condition|)
block|{
if|if
condition|(
name|qApp
operator|->
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// must use images in non-GUI threads
name|QImage
name|image
decl_stmt|;
name|image
operator|.
name|loadFromData
argument_list|(
name|r
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
condition|)
name|r
operator|=
name|image
expr_stmt|;
block|}
else|else
block|{
name|QPixmap
name|pm
decl_stmt|;
name|pm
operator|.
name|loadFromData
argument_list|(
name|r
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|.
name|isNull
argument_list|()
condition|)
name|r
operator|=
name|pm
expr_stmt|;
block|}
block|}
name|d
operator|->
name|cachedResources
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|formatDifference
specifier|static
name|QTextFormat
name|formatDifference
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|from
parameter_list|,
specifier|const
name|QTextFormat
modifier|&
name|to
parameter_list|)
block|{
name|QTextFormat
name|diff
init|=
name|to
decl_stmt|;
specifier|const
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|props
init|=
name|to
operator|.
name|properties
argument_list|()
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|props
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|props
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|==
name|from
operator|.
name|property
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
condition|)
name|diff
operator|.
name|clearProperty
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function
begin_function
DECL|function|colorValue
specifier|static
name|QString
name|colorValue
parameter_list|(
name|QColor
name|color
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|color
operator|.
name|alpha
argument_list|()
operator|==
literal|255
condition|)
block|{
name|result
operator|=
name|color
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|color
operator|.
name|alpha
argument_list|()
condition|)
block|{
name|QString
name|alphaValue
init|=
name|QString
operator|::
name|number
argument_list|(
name|color
operator|.
name|alphaF
argument_list|()
argument_list|,
literal|'f'
argument_list|,
literal|6
argument_list|)
operator|.
name|remove
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\.?0*$"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"rgba(%1,%2,%3,%4)"
argument_list|)
operator|.
name|arg
argument_list|(
name|color
operator|.
name|red
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|color
operator|.
name|green
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|color
operator|.
name|blue
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|alphaValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|QLatin1String
argument_list|(
literal|"transparent"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_constructor
DECL|function|QTextHtmlExporter
name|QTextHtmlExporter
operator|::
name|QTextHtmlExporter
parameter_list|(
specifier|const
name|QTextDocument
modifier|*
name|_doc
parameter_list|)
member_init_list|:
name|doc
argument_list|(
name|_doc
argument_list|)
member_init_list|,
name|fragmentMarkers
argument_list|(
literal|false
argument_list|)
block|{
specifier|const
name|QFont
name|defaultFont
init|=
name|doc
operator|->
name|defaultFont
argument_list|()
decl_stmt|;
name|defaultCharFormat
operator|.
name|setFont
argument_list|(
name|defaultFont
argument_list|)
expr_stmt|;
comment|// don't export those for the default font since we cannot turn them off with CSS
name|defaultCharFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|FontUnderline
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|FontOverline
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|FontStrikeOut
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|TextUnderlineStyle
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Returns the document in HTML format. The conversion may not be     perfect, especially for complex documents, due to the limitations     of HTML. */
end_comment
begin_function
DECL|function|toHtml
name|QString
name|QTextHtmlExporter
operator|::
name|toHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|encoding
parameter_list|,
name|ExportMode
name|mode
parameter_list|)
block|{
name|html
operator|=
name|QLatin1String
argument_list|(
literal|"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" "
literal|"\"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
literal|"<html><head><meta name=\"qrichtext\" content=\"1\" />"
argument_list|)
expr_stmt|;
name|html
operator|.
name|reserve
argument_list|(
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|fragmentMarkers
operator|=
operator|(
name|mode
operator|==
name|ExportFragment
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|.
name|isEmpty
argument_list|()
condition|)
name|html
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=%1\" />"
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|QString
name|title
init|=
name|doc
operator|->
name|metaInformation
argument_list|(
name|QTextDocument
operator|::
name|DocumentTitle
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|html
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"<title>"
argument_list|)
operator|+
name|title
operator|+
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"</title>"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<style type=\"text/css\">\n"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"p, li { white-space: pre-wrap; }\n"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</style>"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</head><body"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|ExportEntireDocument
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\""
argument_list|)
expr_stmt|;
name|emitFontFamily
argument_list|(
name|defaultCharFormat
operator|.
name|fontFamily
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultCharFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPointSize
argument_list|)
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-size:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|defaultCharFormat
operator|.
name|fontPointSize
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"pt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultCharFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPixelSize
argument_list|)
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-size:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|defaultCharFormat
operator|.
name|intProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPixelSize
argument_list|)
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
block|}
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-weight:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|defaultCharFormat
operator|.
name|fontWeight
argument_list|()
operator|*
literal|8
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-style:"
argument_list|)
expr_stmt|;
name|html
operator|+=
operator|(
name|defaultCharFormat
operator|.
name|fontItalic
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"italic"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"normal"
argument_list|)
operator|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
comment|// do not set text-decoration on the default font since those values are /always/ propagated
comment|// and cannot be turned off with CSS
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
specifier|const
name|QTextFrameFormat
name|fmt
init|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|emitBackgroundAttribute
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultCharFormat
operator|=
name|QTextCharFormat
argument_list|()
expr_stmt|;
block|}
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|QTextFrameFormat
name|rootFmt
init|=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
name|rootFmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
expr_stmt|;
name|QTextFrameFormat
name|defaultFmt
decl_stmt|;
name|defaultFmt
operator|.
name|setMargin
argument_list|(
name|doc
operator|->
name|documentMargin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootFmt
operator|==
name|defaultFmt
condition|)
name|emitFrame
argument_list|(
name|doc
operator|->
name|rootFrame
argument_list|()
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|emitTextFrame
argument_list|(
name|doc
operator|->
name|rootFrame
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</body></html>"
argument_list|)
expr_stmt|;
return|return
name|html
return|;
block|}
end_function
begin_function
DECL|function|emitAttribute
name|void
name|QTextHtmlExporter
operator|::
name|emitAttribute
parameter_list|(
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"=\""
argument_list|)
expr_stmt|;
name|html
operator|+=
name|value
operator|.
name|toHtmlEscaped
argument_list|()
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitCharFormatStyle
name|bool
name|QTextHtmlExporter
operator|::
name|emitCharFormatStyle
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|)
block|{
name|bool
name|attributesEmitted
init|=
literal|false
decl_stmt|;
block|{
specifier|const
name|QString
name|family
init|=
name|format
operator|.
name|fontFamily
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|family
operator|.
name|isEmpty
argument_list|()
operator|&&
name|family
operator|!=
name|defaultCharFormat
operator|.
name|fontFamily
argument_list|()
condition|)
block|{
name|emitFontFamily
argument_list|(
name|family
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPointSize
argument_list|)
operator|&&
name|format
operator|.
name|fontPointSize
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontPointSize
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-size:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|fontPointSize
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"pt;"
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontSizeAdjustment
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|sizeNames
index|[]
init|=
block|{
literal|"small"
block|,
literal|"medium"
block|,
literal|"large"
block|,
literal|"x-large"
block|,
literal|"xx-large"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|idx
init|=
name|format
operator|.
name|intProperty
argument_list|(
name|QTextFormat
operator|::
name|FontSizeAdjustment
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<=
literal|4
condition|)
block|{
name|name
operator|=
name|sizeNames
index|[
name|idx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-size:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPixelSize
argument_list|)
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-size:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|intProperty
argument_list|(
name|QTextFormat
operator|::
name|FontPixelSize
argument_list|)
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontWeight
argument_list|)
operator|&&
name|format
operator|.
name|fontWeight
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontWeight
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-weight:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|fontWeight
argument_list|()
operator|*
literal|8
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontItalic
argument_list|)
operator|&&
name|format
operator|.
name|fontItalic
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontItalic
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-style:"
argument_list|)
expr_stmt|;
name|html
operator|+=
operator|(
name|format
operator|.
name|fontItalic
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"italic"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"normal"
argument_list|)
operator|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
name|QLatin1String
name|decorationTag
argument_list|(
literal|" text-decoration:"
argument_list|)
decl_stmt|;
name|html
operator|+=
name|decorationTag
expr_stmt|;
name|bool
name|hasDecoration
init|=
literal|false
decl_stmt|;
name|bool
name|atLeastOneDecorationSet
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontUnderline
argument_list|)
operator|||
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TextUnderlineStyle
argument_list|)
operator|)
operator|&&
name|format
operator|.
name|fontUnderline
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontUnderline
argument_list|()
condition|)
block|{
name|hasDecoration
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|fontUnderline
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" underline"
argument_list|)
expr_stmt|;
name|atLeastOneDecorationSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontOverline
argument_list|)
operator|&&
name|format
operator|.
name|fontOverline
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontOverline
argument_list|()
condition|)
block|{
name|hasDecoration
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|fontOverline
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" overline"
argument_list|)
expr_stmt|;
name|atLeastOneDecorationSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FontStrikeOut
argument_list|)
operator|&&
name|format
operator|.
name|fontStrikeOut
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|fontStrikeOut
argument_list|()
condition|)
block|{
name|hasDecoration
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|fontStrikeOut
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" line-through"
argument_list|)
expr_stmt|;
name|atLeastOneDecorationSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasDecoration
condition|)
block|{
if|if
condition|(
operator|!
name|atLeastOneDecorationSet
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|html
operator|.
name|chop
argument_list|(
name|qstrlen
argument_list|(
name|decorationTag
operator|.
name|latin1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|foreground
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|foreground
argument_list|()
operator|&&
name|format
operator|.
name|foreground
argument_list|()
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" color:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|colorValue
argument_list|(
name|format
operator|.
name|foreground
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|background
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|background
argument_list|()
operator|&&
name|format
operator|.
name|background
argument_list|()
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" background-color:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|colorValue
argument_list|(
name|format
operator|.
name|background
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|verticalAlignment
argument_list|()
operator|!=
name|defaultCharFormat
operator|.
name|verticalAlignment
argument_list|()
operator|&&
name|format
operator|.
name|verticalAlignment
argument_list|()
operator|!=
name|QTextCharFormat
operator|::
name|AlignNormal
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" vertical-align:"
argument_list|)
expr_stmt|;
name|QTextCharFormat
operator|::
name|VerticalAlignment
name|valign
init|=
name|format
operator|.
name|verticalAlignment
argument_list|()
decl_stmt|;
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSubScript
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"sub"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignSuperScript
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"super"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignMiddle
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"middle"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignTop
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"top"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valign
operator|==
name|QTextCharFormat
operator|::
name|AlignBottom
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"bottom"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|fontCapitalization
argument_list|()
operator|!=
name|QFont
operator|::
name|MixedCase
condition|)
block|{
specifier|const
name|QFont
operator|::
name|Capitalization
name|caps
init|=
name|format
operator|.
name|fontCapitalization
argument_list|()
decl_stmt|;
if|if
condition|(
name|caps
operator|==
name|QFont
operator|::
name|AllUppercase
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" text-transform:uppercase;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|caps
operator|==
name|QFont
operator|::
name|AllLowercase
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" text-transform:lowercase;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|caps
operator|==
name|QFont
operator|::
name|SmallCaps
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-variant:small-caps;"
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|fontWordSpacing
argument_list|()
operator|!=
literal|0.0
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" word-spacing:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|fontWordSpacing
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
name|attributesEmitted
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|attributesEmitted
return|;
block|}
end_function
begin_function
DECL|function|emitTextLength
name|void
name|QTextHtmlExporter
operator|::
name|emitTextLength
parameter_list|(
specifier|const
name|char
modifier|*
name|attribute
parameter_list|,
specifier|const
name|QTextLength
modifier|&
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|.
name|type
argument_list|()
operator|==
name|QTextLength
operator|::
name|VariableLength
condition|)
comment|// default
return|return;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"=\""
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|length
operator|.
name|rawValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|.
name|type
argument_list|()
operator|==
name|QTextLength
operator|::
name|PercentageLength
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"%\""
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitAlignment
name|void
name|QTextHtmlExporter
operator|::
name|emitAlignment
parameter_list|(
name|Qt
operator|::
name|Alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignLeft
condition|)
return|return;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignRight
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" align=\"right\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignHCenter
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" align=\"center\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|&
name|Qt
operator|::
name|AlignJustify
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" align=\"justify\""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFloatStyle
name|void
name|QTextHtmlExporter
operator|::
name|emitFloatStyle
parameter_list|(
name|QTextFrameFormat
operator|::
name|Position
name|pos
parameter_list|,
name|StyleMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|==
name|QTextFrameFormat
operator|::
name|InFlow
condition|)
return|return;
if|if
condition|(
name|mode
operator|==
name|EmitStyleTag
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\"float:"
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" float:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|QTextFrameFormat
operator|::
name|FloatLeft
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" left;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|==
name|QTextFrameFormat
operator|::
name|FloatRight
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" right;"
argument_list|)
expr_stmt|;
else|else
name|Q_ASSERT_X
argument_list|(
literal|0
argument_list|,
literal|"QTextHtmlExporter::emitFloatStyle()"
argument_list|,
literal|"pos should be a valid enum type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|EmitStyleTag
condition|)
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitBorderStyle
name|void
name|QTextHtmlExporter
operator|::
name|emitBorderStyle
parameter_list|(
name|QTextFrameFormat
operator|::
name|BorderStyle
name|style
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|style
operator|<=
name|QTextFrameFormat
operator|::
name|BorderStyle_Outset
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" border-style:"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_None
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Dotted
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"dotted"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Dashed
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"dashed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Solid
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"solid"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Double
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_DotDash
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"dot-dash"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_DotDotDash
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"dot-dot-dash"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Groove
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"groove"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Ridge
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"ridge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Inset
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"inset"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextFrameFormat
operator|::
name|BorderStyle_Outset
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"outset"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitPageBreakPolicy
name|void
name|QTextHtmlExporter
operator|::
name|emitPageBreakPolicy
parameter_list|(
name|QTextFormat
operator|::
name|PageBreakFlags
name|policy
parameter_list|)
block|{
if|if
condition|(
name|policy
operator|&
name|QTextFormat
operator|::
name|PageBreak_AlwaysBefore
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" page-break-before:always;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|&
name|QTextFormat
operator|::
name|PageBreak_AlwaysAfter
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" page-break-after:always;"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFontFamily
name|void
name|QTextHtmlExporter
operator|::
name|emitFontFamily
parameter_list|(
specifier|const
name|QString
modifier|&
name|family
parameter_list|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" font-family:"
argument_list|)
expr_stmt|;
name|QLatin1String
name|quote
argument_list|(
literal|"\'"
argument_list|)
decl_stmt|;
if|if
condition|(
name|family
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
condition|)
name|quote
operator|=
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|quote
expr_stmt|;
name|html
operator|+=
name|family
operator|.
name|toHtmlEscaped
argument_list|()
expr_stmt|;
name|html
operator|+=
name|quote
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitMargins
name|void
name|QTextHtmlExporter
operator|::
name|emitMargins
parameter_list|(
specifier|const
name|QString
modifier|&
name|top
parameter_list|,
specifier|const
name|QString
modifier|&
name|bottom
parameter_list|,
specifier|const
name|QString
modifier|&
name|left
parameter_list|,
specifier|const
name|QString
modifier|&
name|right
parameter_list|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" margin-top:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|top
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" margin-bottom:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|bottom
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" margin-left:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|left
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" margin-right:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|right
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFragment
name|void
name|QTextHtmlExporter
operator|::
name|emitFragment
parameter_list|(
specifier|const
name|QTextFragment
modifier|&
name|fragment
parameter_list|)
block|{
specifier|const
name|QTextCharFormat
name|format
init|=
name|fragment
operator|.
name|charFormat
argument_list|()
decl_stmt|;
name|bool
name|closeAnchor
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|isAnchor
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|name
init|=
name|format
operator|.
name|anchorName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<a name=\""
argument_list|)
expr_stmt|;
name|html
operator|+=
name|name
operator|.
name|toHtmlEscaped
argument_list|()
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\"></a>"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QString
name|href
init|=
name|format
operator|.
name|anchorHref
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|href
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
name|html
operator|+=
name|href
operator|.
name|toHtmlEscaped
argument_list|()
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|closeAnchor
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|QString
name|txt
init|=
name|fragment
operator|.
name|text
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|isObject
init|=
name|txt
operator|.
name|contains
argument_list|(
name|QChar
operator|::
name|ObjectReplacementCharacter
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|isImage
init|=
name|isObject
operator|&&
name|format
operator|.
name|isImageFormat
argument_list|()
decl_stmt|;
name|QLatin1String
name|styleTag
argument_list|(
literal|"<span style=\""
argument_list|)
decl_stmt|;
name|html
operator|+=
name|styleTag
expr_stmt|;
name|bool
name|attributesEmitted
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|isImage
condition|)
name|attributesEmitted
operator|=
name|emitCharFormatStyle
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|attributesEmitted
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
else|else
name|html
operator|.
name|chop
argument_list|(
name|qstrlen
argument_list|(
name|styleTag
operator|.
name|latin1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isObject
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|isImage
operator|&&
name|i
operator|<
name|txt
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextImageFormat
name|imgFmt
init|=
name|format
operator|.
name|toImageFormat
argument_list|()
decl_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<img"
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgFmt
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ImageName
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"src"
argument_list|,
name|imgFmt
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgFmt
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ImageWidth
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"width"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|imgFmt
operator|.
name|width
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgFmt
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ImageHeight
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"height"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|imgFmt
operator|.
name|height
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgFmt
operator|.
name|verticalAlignment
argument_list|()
operator|==
name|QTextCharFormat
operator|::
name|AlignMiddle
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\"vertical-align: middle;\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imgFmt
operator|.
name|verticalAlignment
argument_list|()
operator|==
name|QTextCharFormat
operator|::
name|AlignTop
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\"vertical-align: top;\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|QTextFrame
modifier|*
name|imageFrame
init|=
name|qobject_cast
argument_list|<
name|QTextFrame
operator|*
argument_list|>
argument_list|(
name|doc
operator|->
name|objectForFormat
argument_list|(
name|imgFmt
argument_list|)
argument_list|)
condition|)
name|emitFloatStyle
argument_list|(
name|imageFrame
operator|->
name|frameFormat
argument_list|()
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" />"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|txt
operator|.
name|contains
argument_list|(
name|QChar
operator|::
name|ObjectReplacementCharacter
argument_list|)
argument_list|)
expr_stmt|;
name|txt
operator|=
name|txt
operator|.
name|toHtmlEscaped
argument_list|()
expr_stmt|;
comment|// split for [\n{LineSeparator}]
name|QString
name|forcedLineBreakRegExp
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"[\\na]"
argument_list|)
decl_stmt|;
name|forcedLineBreakRegExp
index|[
literal|3
index|]
operator|=
name|QChar
operator|::
name|LineSeparator
expr_stmt|;
specifier|const
name|QStringList
name|lines
init|=
name|txt
operator|.
name|split
argument_list|(
name|QRegExp
argument_list|(
name|forcedLineBreakRegExp
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lines
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<br />"
argument_list|)
expr_stmt|;
comment|// space on purpose for compatibility with Netscape, Lynx& Co.
name|html
operator|+=
name|lines
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attributesEmitted
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</span>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeAnchor
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isOrderedList
specifier|static
name|bool
name|isOrderedList
parameter_list|(
name|int
name|style
parameter_list|)
block|{
return|return
name|style
operator|==
name|QTextListFormat
operator|::
name|ListDecimal
operator|||
name|style
operator|==
name|QTextListFormat
operator|::
name|ListLowerAlpha
operator|||
name|style
operator|==
name|QTextListFormat
operator|::
name|ListUpperAlpha
operator|||
name|style
operator|==
name|QTextListFormat
operator|::
name|ListUpperRoman
operator|||
name|style
operator|==
name|QTextListFormat
operator|::
name|ListLowerRoman
return|;
block|}
end_function
begin_function
DECL|function|emitBlockAttributes
name|void
name|QTextHtmlExporter
operator|::
name|emitBlockAttributes
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
block|{
name|QTextBlockFormat
name|format
init|=
name|block
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
name|emitAlignment
argument_list|(
name|format
operator|.
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
comment|// assume default to not bloat the html too much
comment|// html += QLatin1String(" dir='ltr'");
if|if
condition|(
name|block
operator|.
name|textDirection
argument_list|()
operator|==
name|Qt
operator|::
name|RightToLeft
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" dir='rtl'"
argument_list|)
expr_stmt|;
name|QLatin1String
name|style
argument_list|(
literal|" style=\""
argument_list|)
decl_stmt|;
name|html
operator|+=
name|style
expr_stmt|;
specifier|const
name|bool
name|emptyBlock
init|=
name|block
operator|.
name|begin
argument_list|()
operator|.
name|atEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|emptyBlock
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"-qt-paragraph-type:empty;"
argument_list|)
expr_stmt|;
block|}
name|emitMargins
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|topMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|bottomMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|leftMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|rightMargin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" -qt-block-indent:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|indent
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" text-indent:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|textIndent
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"px;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|userState
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" -qt-user-state:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|block
operator|.
name|userState
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
name|emitPageBreakPolicy
argument_list|(
name|format
operator|.
name|pageBreakPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|QTextCharFormat
name|diff
decl_stmt|;
if|if
condition|(
name|emptyBlock
condition|)
block|{
comment|// only print character properties when we don't expect them to be repeated by actual text in the parag
specifier|const
name|QTextCharFormat
name|blockCharFmt
init|=
name|block
operator|.
name|charFormat
argument_list|()
decl_stmt|;
name|diff
operator|=
name|formatDifference
argument_list|(
name|defaultCharFormat
argument_list|,
name|blockCharFmt
argument_list|)
operator|.
name|toCharFormat
argument_list|()
expr_stmt|;
block|}
name|diff
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
condition|)
block|{
name|QBrush
name|bg
init|=
name|format
operator|.
name|background
argument_list|()
decl_stmt|;
if|if
condition|(
name|bg
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
name|diff
operator|.
name|setProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|,
name|format
operator|.
name|property
argument_list|(
name|QTextFormat
operator|::
name|BackgroundBrush
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|diff
operator|.
name|properties
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|emitCharFormatStyle
argument_list|(
name|diff
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitBlock
name|void
name|QTextHtmlExporter
operator|::
name|emitBlock
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
block|{
if|if
condition|(
name|block
operator|.
name|begin
argument_list|()
operator|.
name|atEnd
argument_list|()
condition|)
block|{
comment|// ### HACK, remove once QTextFrame::Iterator is fixed
name|int
name|p
init|=
name|block
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
operator|--
name|p
expr_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|frag
init|=
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|find
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|QChar
name|ch
init|=
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QTextBeginningOfFrame
operator|||
name|ch
operator|==
name|QTextEndOfFrame
condition|)
return|return;
block|}
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|// save and later restore, in case we 'change' the default format by
comment|// emitting block char format information
name|QTextCharFormat
name|oldDefaultCharFormat
init|=
name|defaultCharFormat
decl_stmt|;
name|QTextList
modifier|*
name|list
init|=
name|block
operator|.
name|textList
argument_list|()
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|itemNumber
argument_list|(
name|block
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// first item? emit<ul> or appropriate
specifier|const
name|QTextListFormat
name|format
init|=
name|list
operator|->
name|format
argument_list|()
decl_stmt|;
specifier|const
name|int
name|style
init|=
name|format
operator|.
name|style
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|QTextListFormat
operator|::
name|ListDecimal
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ol"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListDisc
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ul"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListCircle
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ul type=\"circle\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListSquare
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ul type=\"square\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListLowerAlpha
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ol type=\"a\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListUpperAlpha
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ol type=\"A\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListLowerRoman
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ol type=\"i\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextListFormat
operator|::
name|ListUpperRoman
case|:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ol type=\"I\""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<ul"
argument_list|)
expr_stmt|;
comment|// ### should not happen
block|}
name|QString
name|styleString
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px;"
argument_list|)
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ListIndent
argument_list|)
condition|)
block|{
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" -qt-list-indent: "
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|indent
argument_list|()
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ListNumberPrefix
argument_list|)
condition|)
block|{
name|QString
name|numberPrefix
init|=
name|format
operator|.
name|numberPrefix
argument_list|()
decl_stmt|;
name|numberPrefix
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\22"
argument_list|)
argument_list|)
expr_stmt|;
name|numberPrefix
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\27"
argument_list|)
argument_list|)
expr_stmt|;
comment|// FIXME: There's a problem in the CSS parser the prevents this from being correctly restored
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" -qt-list-number-prefix: "
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|numberPrefix
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|ListNumberSuffix
argument_list|)
condition|)
block|{
if|if
condition|(
name|format
operator|.
name|numberSuffix
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// this is our default
name|QString
name|numberSuffix
init|=
name|format
operator|.
name|numberSuffix
argument_list|()
decl_stmt|;
name|numberSuffix
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\22"
argument_list|)
argument_list|)
expr_stmt|;
name|numberSuffix
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"\\27"
argument_list|)
argument_list|)
expr_stmt|;
comment|// see above
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" -qt-list-number-suffix: "
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|numberSuffix
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\""
argument_list|)
expr_stmt|;
name|html
operator|+=
name|styleString
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
block|}
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<li"
argument_list|)
expr_stmt|;
specifier|const
name|QTextCharFormat
name|blockFmt
init|=
name|formatDifference
argument_list|(
name|defaultCharFormat
argument_list|,
name|block
operator|.
name|charFormat
argument_list|()
argument_list|)
operator|.
name|toCharFormat
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blockFmt
operator|.
name|properties
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\""
argument_list|)
expr_stmt|;
name|emitCharFormatStyle
argument_list|(
name|blockFmt
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|.
name|merge
argument_list|(
name|block
operator|.
name|charFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|QTextBlockFormat
name|blockFormat
init|=
name|block
operator|.
name|blockFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockTrailingHorizontalRulerWidth
argument_list|)
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<hr"
argument_list|)
expr_stmt|;
name|QTextLength
name|width
init|=
name|blockFormat
operator|.
name|lengthProperty
argument_list|(
name|QTextFormat
operator|::
name|BlockTrailingHorizontalRulerWidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|.
name|type
argument_list|()
operator|!=
name|QTextLength
operator|::
name|VariableLength
condition|)
name|emitTextLength
argument_list|(
literal|"width"
argument_list|,
name|width
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"/>"
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|bool
name|pre
init|=
name|blockFormat
operator|.
name|nonBreakableLines
argument_list|()
decl_stmt|;
if|if
condition|(
name|pre
condition|)
block|{
if|if
condition|(
name|list
condition|)
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<pre"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<p"
argument_list|)
expr_stmt|;
block|}
name|emitBlockAttributes
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|begin
argument_list|()
operator|.
name|atEnd
argument_list|()
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<br />"
argument_list|)
expr_stmt|;
name|QTextBlock
operator|::
name|Iterator
name|it
init|=
name|block
operator|.
name|begin
argument_list|()
decl_stmt|;
if|if
condition|(
name|fragmentMarkers
operator|&&
operator|!
name|it
operator|.
name|atEnd
argument_list|()
operator|&&
name|block
operator|==
name|doc
operator|->
name|begin
argument_list|()
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<!--StartFragment-->"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|it
operator|.
name|atEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|emitFragment
argument_list|(
name|it
operator|.
name|fragment
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragmentMarkers
operator|&&
name|block
operator|.
name|position
argument_list|()
operator|+
name|block
operator|.
name|length
argument_list|()
operator|==
name|doc
operator|->
name|docHandle
argument_list|()
operator|->
name|length
argument_list|()
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<!--EndFragment-->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</pre>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</li>"
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|itemNumber
argument_list|(
name|block
argument_list|)
operator|==
name|list
operator|->
name|count
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// last item? close list
if|if
condition|(
name|isOrderedList
argument_list|(
name|list
operator|->
name|format
argument_list|()
operator|.
name|style
argument_list|()
argument_list|)
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</ol>"
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</ul>"
argument_list|)
expr_stmt|;
block|}
block|}
name|defaultCharFormat
operator|=
name|oldDefaultCharFormat
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|extern
name|bool
name|qHasPixmapTexture
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|findUrlForImage
name|QString
name|QTextHtmlExporter
operator|::
name|findUrlForImage
parameter_list|(
specifier|const
name|QTextDocument
modifier|*
name|doc
parameter_list|,
name|qint64
name|cacheKey
parameter_list|,
name|bool
name|isPixmap
parameter_list|)
block|{
name|QString
name|url
decl_stmt|;
if|if
condition|(
operator|!
name|doc
condition|)
return|return
name|url
return|;
if|if
condition|(
name|QTextDocument
modifier|*
name|parent
init|=
name|qobject_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|doc
operator|->
name|parent
argument_list|()
argument_list|)
condition|)
return|return
name|findUrlForImage
argument_list|(
name|parent
argument_list|,
name|cacheKey
argument_list|,
name|isPixmap
argument_list|)
return|;
if|if
condition|(
name|doc
operator|&&
name|doc
operator|->
name|docHandle
argument_list|()
condition|)
block|{
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|doc
operator|->
name|docHandle
argument_list|()
decl_stmt|;
name|QMap
argument_list|<
name|QUrl
argument_list|,
name|QVariant
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|priv
operator|->
name|cachedResources
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|priv
operator|->
name|cachedResources
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QVariant
modifier|&
name|v
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Image
operator|&&
operator|!
name|isPixmap
condition|)
block|{
if|if
condition|(
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|v
argument_list|)
operator|.
name|cacheKey
argument_list|()
operator|==
name|cacheKey
condition|)
break|break;
block|}
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|Pixmap
operator|&&
name|isPixmap
condition|)
block|{
if|if
condition|(
name|qvariant_cast
argument_list|<
name|QPixmap
argument_list|>
argument_list|(
name|v
argument_list|)
operator|.
name|cacheKey
argument_list|()
operator|==
name|cacheKey
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|it
operator|!=
name|priv
operator|->
name|cachedResources
operator|.
name|constEnd
argument_list|()
condition|)
name|url
operator|=
name|it
operator|.
name|key
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_function
DECL|function|mergeCachedResources
name|void
name|QTextDocumentPrivate
operator|::
name|mergeCachedResources
parameter_list|(
specifier|const
name|QTextDocumentPrivate
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|priv
condition|)
return|return;
name|cachedResources
operator|.
name|unite
argument_list|(
name|priv
operator|->
name|cachedResources
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitBackgroundAttribute
name|void
name|QTextHtmlExporter
operator|::
name|emitBackgroundAttribute
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|BackgroundImageUrl
argument_list|)
condition|)
block|{
name|QString
name|url
init|=
name|format
operator|.
name|property
argument_list|(
name|QTextFormat
operator|::
name|BackgroundImageUrl
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|emitAttribute
argument_list|(
literal|"background"
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QBrush
modifier|&
name|brush
init|=
name|format
operator|.
name|background
argument_list|()
decl_stmt|;
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
name|emitAttribute
argument_list|(
literal|"bgcolor"
argument_list|,
name|colorValue
argument_list|(
name|brush
operator|.
name|color
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|TexturePattern
condition|)
block|{
specifier|const
name|bool
name|isPixmap
init|=
name|qHasPixmapTexture
argument_list|(
name|brush
argument_list|)
decl_stmt|;
specifier|const
name|qint64
name|cacheKey
init|=
name|isPixmap
condition|?
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|cacheKey
argument_list|()
else|:
name|brush
operator|.
name|textureImage
argument_list|()
operator|.
name|cacheKey
argument_list|()
decl_stmt|;
specifier|const
name|QString
name|url
init|=
name|findUrlForImage
argument_list|(
name|doc
argument_list|,
name|cacheKey
argument_list|,
name|isPixmap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|isEmpty
argument_list|()
condition|)
name|emitAttribute
argument_list|(
literal|"background"
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|emitTable
name|void
name|QTextHtmlExporter
operator|::
name|emitTable
parameter_list|(
specifier|const
name|QTextTable
modifier|*
name|table
parameter_list|)
block|{
name|QTextTableFormat
name|format
init|=
name|table
operator|->
name|format
argument_list|()
decl_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\n<table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameBorder
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"border"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|border
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitFrameStyle
argument_list|(
name|format
argument_list|,
name|TableFrame
argument_list|)
expr_stmt|;
name|emitAlignment
argument_list|(
name|format
operator|.
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
name|emitTextLength
argument_list|(
literal|"width"
argument_list|,
name|format
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellSpacing
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"cellspacing"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|cellSpacing
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellPadding
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"cellpadding"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|cellPadding
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitBackgroundAttribute
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
specifier|const
name|int
name|rows
init|=
name|table
operator|->
name|rows
argument_list|()
decl_stmt|;
specifier|const
name|int
name|columns
init|=
name|table
operator|->
name|columns
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QTextLength
argument_list|>
name|columnWidths
init|=
name|format
operator|.
name|columnWidthConstraints
argument_list|()
decl_stmt|;
if|if
condition|(
name|columnWidths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|columnWidths
operator|.
name|resize
argument_list|(
name|columns
argument_list|)
expr_stmt|;
name|columnWidths
operator|.
name|fill
argument_list|(
name|QTextLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|columnWidths
operator|.
name|count
argument_list|()
operator|==
name|columns
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|bool
argument_list|>
name|widthEmittedForColumn
argument_list|(
name|columns
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
condition|;
operator|++
name|i
control|)
name|widthEmittedForColumn
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|headerRowCount
init|=
name|qMin
argument_list|(
name|format
operator|.
name|headerRowCount
argument_list|()
argument_list|,
name|rows
argument_list|)
decl_stmt|;
if|if
condition|(
name|headerRowCount
operator|>
literal|0
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"<thead>"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|row
init|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
operator|++
name|row
control|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\n<tr>"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|columns
condition|;
operator|++
name|col
control|)
block|{
specifier|const
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
decl_stmt|;
comment|// for col/rowspans
if|if
condition|(
name|cell
operator|.
name|row
argument_list|()
operator|!=
name|row
condition|)
continue|continue;
if|if
condition|(
name|cell
operator|.
name|column
argument_list|()
operator|!=
name|col
condition|)
continue|continue;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\n<td"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|widthEmittedForColumn
index|[
name|col
index|]
operator|&&
name|cell
operator|.
name|columnSpan
argument_list|()
operator|==
literal|1
condition|)
block|{
name|emitTextLength
argument_list|(
literal|"width"
argument_list|,
name|columnWidths
operator|.
name|at
argument_list|(
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|widthEmittedForColumn
index|[
name|col
index|]
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|cell
operator|.
name|columnSpan
argument_list|()
operator|>
literal|1
condition|)
name|emitAttribute
argument_list|(
literal|"colspan"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|cell
operator|.
name|columnSpan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|.
name|rowSpan
argument_list|()
operator|>
literal|1
condition|)
name|emitAttribute
argument_list|(
literal|"rowspan"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|cell
operator|.
name|rowSpan
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QTextTableCellFormat
name|cellFormat
init|=
name|cell
operator|.
name|format
argument_list|()
operator|.
name|toTableCellFormat
argument_list|()
decl_stmt|;
name|emitBackgroundAttribute
argument_list|(
name|cellFormat
argument_list|)
expr_stmt|;
name|QTextCharFormat
name|oldDefaultCharFormat
init|=
name|defaultCharFormat
decl_stmt|;
name|QTextCharFormat
operator|::
name|VerticalAlignment
name|valign
init|=
name|cellFormat
operator|.
name|verticalAlignment
argument_list|()
decl_stmt|;
name|QString
name|styleString
decl_stmt|;
if|if
condition|(
name|valign
operator|>=
name|QTextCharFormat
operator|::
name|AlignMiddle
operator|&&
name|valign
operator|<=
name|QTextCharFormat
operator|::
name|AlignBottom
condition|)
block|{
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" vertical-align:"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|valign
condition|)
block|{
case|case
name|QTextCharFormat
operator|::
name|AlignMiddle
case|:
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|"middle"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCharFormat
operator|::
name|AlignTop
case|:
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|"top"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCharFormat
operator|::
name|AlignBottom
case|:
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|"bottom"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|styleString
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|QTextCharFormat
name|temp
decl_stmt|;
name|temp
operator|.
name|setVerticalAlignment
argument_list|(
name|valign
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|.
name|merge
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cellFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellLeftPadding
argument_list|)
condition|)
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" padding-left:"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|cellFormat
operator|.
name|leftPadding
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cellFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellRightPadding
argument_list|)
condition|)
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" padding-right:"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|cellFormat
operator|.
name|rightPadding
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cellFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellTopPadding
argument_list|)
condition|)
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" padding-top:"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|cellFormat
operator|.
name|topPadding
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cellFormat
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|TableCellBottomPadding
argument_list|)
condition|)
name|styleString
operator|+=
name|QLatin1String
argument_list|(
literal|" padding-bottom:"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|cellFormat
operator|.
name|bottomPadding
argument_list|()
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|styleString
operator|.
name|isEmpty
argument_list|()
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" style=\""
argument_list|)
operator|+
name|styleString
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|emitFrame
argument_list|(
name|cell
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</td>"
argument_list|)
expr_stmt|;
name|defaultCharFormat
operator|=
name|oldDefaultCharFormat
expr_stmt|;
block|}
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</tr>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|headerRowCount
operator|>
literal|0
operator|&&
name|row
operator|==
name|headerRowCount
operator|-
literal|1
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</thead>"
argument_list|)
expr_stmt|;
block|}
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</table>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFrame
name|void
name|QTextHtmlExporter
operator|::
name|emitFrame
parameter_list|(
name|QTextFrame
operator|::
name|Iterator
name|frameIt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|frameIt
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QTextFrame
operator|::
name|Iterator
name|next
init|=
name|frameIt
decl_stmt|;
operator|++
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|.
name|atEnd
argument_list|()
operator|&&
name|frameIt
operator|.
name|currentFrame
argument_list|()
operator|==
literal|0
operator|&&
name|frameIt
operator|.
name|parentFrame
argument_list|()
operator|!=
name|doc
operator|->
name|rootFrame
argument_list|()
operator|&&
name|frameIt
operator|.
name|currentBlock
argument_list|()
operator|.
name|begin
argument_list|()
operator|.
name|atEnd
argument_list|()
condition|)
return|return;
block|}
for|for
control|(
name|QTextFrame
operator|::
name|Iterator
name|it
init|=
name|frameIt
init|;
operator|!
name|it
operator|.
name|atEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|QTextFrame
modifier|*
name|f
init|=
name|it
operator|.
name|currentFrame
argument_list|()
condition|)
block|{
if|if
condition|(
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|emitTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emitTextFrame
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|it
operator|.
name|currentBlock
argument_list|()
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|emitBlock
argument_list|(
name|it
operator|.
name|currentBlock
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|emitTextFrame
name|void
name|QTextHtmlExporter
operator|::
name|emitTextFrame
parameter_list|(
specifier|const
name|QTextFrame
modifier|*
name|f
parameter_list|)
block|{
name|FrameType
name|frameType
init|=
name|f
operator|->
name|parentFrame
argument_list|()
condition|?
name|TextFrame
else|:
name|RootFrame
decl_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\n<table"
argument_list|)
expr_stmt|;
name|QTextFrameFormat
name|format
init|=
name|f
operator|->
name|frameFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameBorder
argument_list|)
condition|)
name|emitAttribute
argument_list|(
literal|"border"
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|border
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|emitFrameStyle
argument_list|(
name|format
argument_list|,
name|frameType
argument_list|)
expr_stmt|;
name|emitTextLength
argument_list|(
literal|"width"
argument_list|,
name|format
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|emitTextLength
argument_list|(
literal|"height"
argument_list|,
name|format
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
comment|// root frame's bcolor goes in the<body> tag
if|if
condition|(
name|frameType
operator|!=
name|RootFrame
condition|)
name|emitBackgroundAttribute
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"\n<tr>\n<td style=\"border: none;\">"
argument_list|)
expr_stmt|;
name|emitFrame
argument_list|(
name|f
operator|->
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"</td></tr></table>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFrameStyle
name|void
name|QTextHtmlExporter
operator|::
name|emitFrameStyle
parameter_list|(
specifier|const
name|QTextFrameFormat
modifier|&
name|format
parameter_list|,
name|FrameType
name|frameType
parameter_list|)
block|{
name|QLatin1String
name|styleAttribute
argument_list|(
literal|" style=\""
argument_list|)
decl_stmt|;
name|html
operator|+=
name|styleAttribute
expr_stmt|;
specifier|const
name|int
name|originalHtmlLength
init|=
name|html
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|frameType
operator|==
name|TextFrame
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"-qt-table-type: frame;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frameType
operator|==
name|RootFrame
condition|)
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|"-qt-table-type: root;"
argument_list|)
expr_stmt|;
specifier|const
name|QTextFrameFormat
name|defaultFormat
decl_stmt|;
name|emitFloatStyle
argument_list|(
name|format
operator|.
name|position
argument_list|()
argument_list|,
name|OmitStyleTag
argument_list|)
expr_stmt|;
name|emitPageBreakPolicy
argument_list|(
name|format
operator|.
name|pageBreakPolicy
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|borderBrush
argument_list|()
operator|!=
name|defaultFormat
operator|.
name|borderBrush
argument_list|()
condition|)
block|{
name|html
operator|+=
name|QLatin1String
argument_list|(
literal|" border-color:"
argument_list|)
expr_stmt|;
name|html
operator|+=
name|colorValue
argument_list|(
name|format
operator|.
name|borderBrush
argument_list|()
operator|.
name|color
argument_list|()
argument_list|)
expr_stmt|;
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|.
name|borderStyle
argument_list|()
operator|!=
name|defaultFormat
operator|.
name|borderStyle
argument_list|()
condition|)
name|emitBorderStyle
argument_list|(
name|format
operator|.
name|borderStyle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameMargin
argument_list|)
operator|||
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameLeftMargin
argument_list|)
operator|||
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameRightMargin
argument_list|)
operator|||
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameTopMargin
argument_list|)
operator|||
name|format
operator|.
name|hasProperty
argument_list|(
name|QTextFormat
operator|::
name|FrameBottomMargin
argument_list|)
condition|)
name|emitMargins
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|topMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|bottomMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|leftMargin
argument_list|()
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|format
operator|.
name|rightMargin
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|.
name|length
argument_list|()
operator|==
name|originalHtmlLength
condition|)
comment|// nothing emitted?
name|html
operator|.
name|chop
argument_list|(
name|qstrlen
argument_list|(
name|styleAttribute
operator|.
name|latin1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|html
operator|+=
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a string containing an HTML representation of the document.      The \a encoding parameter specifies the value for the charset attribute     in the html header. For example if 'utf-8' is specified then the     beginning of the generated html will look like this:     \snippet code/src_gui_text_qtextdocument.cpp 0      If no encoding is specified then no such meta information is generated.      If you later on convert the returned html string into a byte array for     transmission over a network or when saving to disk you should specify     the encoding you're going to use for the conversion to a byte array here.      \sa {Supported HTML Subset} */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|toHtml
name|QString
name|QTextDocument
operator|::
name|toHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|encoding
parameter_list|)
specifier|const
block|{
return|return
name|QTextHtmlExporter
argument_list|(
name|this
argument_list|)
operator|.
name|toHtml
argument_list|(
name|encoding
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     Returns a vector of text formats for all the formats used in the document. */
end_comment
begin_function
DECL|function|allFormats
name|QVector
argument_list|<
name|QTextFormat
argument_list|>
name|QTextDocument
operator|::
name|allFormats
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|formatCollection
argument_list|()
operator|->
name|formats
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    So that not all classes have to be friends of each other... */
end_comment
begin_function
DECL|function|docHandle
name|QTextDocumentPrivate
modifier|*
name|QTextDocument
operator|::
name|docHandle
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextDocument
argument_list|)
expr_stmt|;
return|return
cast|const_cast
argument_list|<
name|QTextDocumentPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     \fn QTextDocument::undoCommandAdded()      This signal is emitted  every time a new level of undo is added to the QTextDocument. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
