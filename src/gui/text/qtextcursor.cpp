begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextcursor.h"
end_include
begin_include
include|#
directive|include
file|"qtextcursor_p.h"
end_include
begin_include
include|#
directive|include
file|"qglobal.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocumentfragment.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocumentfragment_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextlist.h"
end_include
begin_include
include|#
directive|include
file|"qtexttable.h"
end_include
begin_include
include|#
directive|include
file|"qtexttable_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstracttextdocumentlayout.h"
end_include
begin_include
include|#
directive|include
file|<qtextlayout.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|AdjustPrev
name|AdjustPrev
init|=
literal|0x1
decl_stmt|,
DECL|enumerator|AdjustUp
name|AdjustUp
init|=
literal|0x3
decl_stmt|,
DECL|enumerator|AdjustNext
name|AdjustNext
init|=
literal|0x4
decl_stmt|,
DECL|enumerator|AdjustDown
name|AdjustDown
init|=
literal|0x12
end_decl_stmt
begin_constructor
DECL|enumerator|AdjustDown
unit|};
DECL|function|QTextCursorPrivate
name|QTextCursorPrivate
operator|::
name|QTextCursorPrivate
parameter_list|(
name|QTextDocumentPrivate
modifier|*
name|p
parameter_list|)
member_init_list|:
name|priv
argument_list|(
name|p
argument_list|)
member_init_list|,
name|x
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|position
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|anchor
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|adjusted_anchor
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentCharFormat
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|visualNavigation
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|keepPositionOnInsert
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|changed
argument_list|(
literal|false
argument_list|)
block|{
name|priv
operator|->
name|addCursor
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QTextCursorPrivate
name|QTextCursorPrivate
operator|::
name|QTextCursorPrivate
parameter_list|(
specifier|const
name|QTextCursorPrivate
modifier|&
name|rhs
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|rhs
argument_list|)
block|{
name|position
operator|=
name|rhs
operator|.
name|position
expr_stmt|;
name|anchor
operator|=
name|rhs
operator|.
name|anchor
expr_stmt|;
name|adjusted_anchor
operator|=
name|rhs
operator|.
name|adjusted_anchor
expr_stmt|;
name|priv
operator|=
name|rhs
operator|.
name|priv
expr_stmt|;
name|x
operator|=
name|rhs
operator|.
name|x
expr_stmt|;
name|currentCharFormat
operator|=
name|rhs
operator|.
name|currentCharFormat
expr_stmt|;
name|visualNavigation
operator|=
name|rhs
operator|.
name|visualNavigation
expr_stmt|;
name|keepPositionOnInsert
operator|=
name|rhs
operator|.
name|keepPositionOnInsert
expr_stmt|;
name|changed
operator|=
name|rhs
operator|.
name|changed
expr_stmt|;
name|priv
operator|->
name|addCursor
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QTextCursorPrivate
name|QTextCursorPrivate
operator|::
name|~
name|QTextCursorPrivate
parameter_list|()
block|{
if|if
condition|(
name|priv
condition|)
name|priv
operator|->
name|removeCursor
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|adjustPosition
name|QTextCursorPrivate
operator|::
name|AdjustResult
name|QTextCursorPrivate
operator|::
name|adjustPosition
parameter_list|(
name|int
name|positionOfChange
parameter_list|,
name|int
name|charsAddedOrRemoved
parameter_list|,
name|QTextUndoCommand
operator|::
name|Operation
name|op
parameter_list|)
block|{
name|QTextCursorPrivate
operator|::
name|AdjustResult
name|result
init|=
name|QTextCursorPrivate
operator|::
name|CursorMoved
decl_stmt|;
comment|// not(!)<= , so that inserting text adjusts the cursor correctly
if|if
condition|(
name|position
operator|<
name|positionOfChange
operator|||
operator|(
name|position
operator|==
name|positionOfChange
operator|&&
operator|(
name|op
operator|==
name|QTextUndoCommand
operator|::
name|KeepCursor
operator|||
name|keepPositionOnInsert
operator|)
operator|)
condition|)
block|{
name|result
operator|=
name|CursorUnchanged
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|charsAddedOrRemoved
operator|<
literal|0
operator|&&
name|position
operator|<
name|positionOfChange
operator|-
name|charsAddedOrRemoved
condition|)
name|position
operator|=
name|positionOfChange
expr_stmt|;
else|else
name|position
operator|+=
name|charsAddedOrRemoved
expr_stmt|;
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|anchor
operator|>=
name|positionOfChange
operator|&&
operator|(
name|anchor
operator|!=
name|positionOfChange
operator|||
name|op
operator|!=
name|QTextUndoCommand
operator|::
name|KeepCursor
operator|)
condition|)
block|{
if|if
condition|(
name|charsAddedOrRemoved
operator|<
literal|0
operator|&&
name|anchor
operator|<
name|positionOfChange
operator|-
name|charsAddedOrRemoved
condition|)
name|anchor
operator|=
name|positionOfChange
expr_stmt|;
else|else
name|anchor
operator|+=
name|charsAddedOrRemoved
expr_stmt|;
block|}
if|if
condition|(
name|adjusted_anchor
operator|>=
name|positionOfChange
operator|&&
operator|(
name|adjusted_anchor
operator|!=
name|positionOfChange
operator|||
name|op
operator|!=
name|QTextUndoCommand
operator|::
name|KeepCursor
operator|)
condition|)
block|{
if|if
condition|(
name|charsAddedOrRemoved
operator|<
literal|0
operator|&&
name|adjusted_anchor
operator|<
name|positionOfChange
operator|-
name|charsAddedOrRemoved
condition|)
name|adjusted_anchor
operator|=
name|positionOfChange
expr_stmt|;
else|else
name|adjusted_anchor
operator|+=
name|charsAddedOrRemoved
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|setX
name|void
name|QTextCursorPrivate
operator|::
name|setX
parameter_list|()
block|{
if|if
condition|(
name|priv
operator|->
name|isInEditBlock
argument_list|()
operator|||
name|priv
operator|->
name|inContentsChange
condition|)
block|{
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|// mark dirty
return|return;
block|}
name|QTextBlock
name|block
init|=
name|this
operator|->
name|block
argument_list|()
decl_stmt|;
specifier|const
name|QTextLayout
modifier|*
name|layout
init|=
name|blockLayout
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|position
operator|-
name|block
operator|.
name|position
argument_list|()
decl_stmt|;
name|QTextLine
name|line
init|=
name|layout
operator|->
name|lineForTextPosition
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|isValid
argument_list|()
condition|)
name|x
operator|=
name|line
operator|.
name|cursorToX
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|// delayed init.  Makes movePosition() call setX later on again.
block|}
end_function
begin_function
DECL|function|remove
name|void
name|QTextCursorPrivate
operator|::
name|remove
parameter_list|()
block|{
if|if
condition|(
name|anchor
operator|==
name|position
condition|)
return|return;
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|pos1
init|=
name|position
decl_stmt|;
name|int
name|pos2
init|=
name|adjusted_anchor
decl_stmt|;
name|QTextUndoCommand
operator|::
name|Operation
name|op
init|=
name|QTextUndoCommand
operator|::
name|KeepCursor
decl_stmt|;
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
block|{
name|pos1
operator|=
name|adjusted_anchor
expr_stmt|;
name|pos2
operator|=
name|position
expr_stmt|;
name|op
operator|=
name|QTextUndoCommand
operator|::
name|MoveCursor
expr_stmt|;
block|}
comment|// deleting inside table? -> delete only content
name|QTextTable
modifier|*
name|table
init|=
name|complexSelectionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|int
name|startRow
decl_stmt|,
name|startCol
decl_stmt|,
name|numRows
decl_stmt|,
name|numCols
decl_stmt|;
name|selectedTableCells
argument_list|(
operator|&
name|startRow
argument_list|,
operator|&
name|numRows
argument_list|,
operator|&
name|startCol
argument_list|,
operator|&
name|numCols
argument_list|)
expr_stmt|;
name|clearCells
argument_list|(
name|table
argument_list|,
name|startRow
argument_list|,
name|startCol
argument_list|,
name|numRows
argument_list|,
name|numCols
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|adjusted_anchor
operator|=
name|anchor
operator|=
name|position
expr_stmt|;
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|remove
argument_list|(
name|pos1
argument_list|,
name|pos2
operator|-
name|pos1
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|adjusted_anchor
operator|=
name|anchor
operator|=
name|position
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clearCells
name|void
name|QTextCursorPrivate
operator|::
name|clearCells
parameter_list|(
name|QTextTable
modifier|*
name|table
parameter_list|,
name|int
name|startRow
parameter_list|,
name|int
name|startCol
parameter_list|,
name|int
name|numRows
parameter_list|,
name|int
name|numCols
parameter_list|,
name|QTextUndoCommand
operator|::
name|Operation
name|op
parameter_list|)
block|{
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|row
init|=
name|startRow
init|;
name|row
operator|<
name|startRow
operator|+
name|numRows
condition|;
operator|++
name|row
control|)
for|for
control|(
name|int
name|col
init|=
name|startCol
init|;
name|col
operator|<
name|startCol
operator|+
name|numCols
condition|;
operator|++
name|col
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
decl_stmt|;
specifier|const
name|int
name|startPos
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
specifier|const
name|int
name|endPos
init|=
name|cell
operator|.
name|lastPosition
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|startPos
operator|<=
name|endPos
argument_list|)
expr_stmt|;
name|priv
operator|->
name|remove
argument_list|(
name|startPos
argument_list|,
name|endPos
operator|-
name|startPos
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|canDelete
name|bool
name|QTextCursorPrivate
operator|::
name|canDelete
parameter_list|(
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|fit
init|=
name|priv
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|priv
operator|->
name|formatCollection
argument_list|()
operator|->
name|charFormat
argument_list|(
operator|(
operator|*
name|fit
operator|)
operator|->
name|format
argument_list|)
decl_stmt|;
return|return
operator|(
name|fmt
operator|.
name|objectIndex
argument_list|()
operator|==
operator|-
literal|1
operator|||
name|fmt
operator|.
name|objectType
argument_list|()
operator|==
name|QTextFormat
operator|::
name|ImageObject
operator|)
return|;
block|}
end_function
begin_function
DECL|function|insertBlock
name|void
name|QTextCursorPrivate
operator|::
name|insertBlock
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|charFormat
parameter_list|)
block|{
name|QTextFormatCollection
modifier|*
name|formats
init|=
name|priv
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|formats
operator|->
name|indexForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|formats
operator|->
name|format
argument_list|(
name|idx
argument_list|)
operator|.
name|isBlockFormat
argument_list|()
argument_list|)
expr_stmt|;
name|priv
operator|->
name|insertBlock
argument_list|(
name|position
argument_list|,
name|idx
argument_list|,
name|formats
operator|->
name|indexForFormat
argument_list|(
name|charFormat
argument_list|)
argument_list|)
expr_stmt|;
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|adjustCursor
name|void
name|QTextCursorPrivate
operator|::
name|adjustCursor
parameter_list|(
name|QTextCursor
operator|::
name|MoveOperation
name|m
parameter_list|)
block|{
name|adjusted_anchor
operator|=
name|anchor
expr_stmt|;
if|if
condition|(
name|position
operator|==
name|anchor
condition|)
return|return;
name|QTextFrame
modifier|*
name|f_position
init|=
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|QTextFrame
modifier|*
name|f_anchor
init|=
name|priv
operator|->
name|frameAt
argument_list|(
name|adjusted_anchor
argument_list|)
decl_stmt|;
if|if
condition|(
name|f_position
operator|!=
name|f_anchor
condition|)
block|{
comment|// find common parent frame
name|QList
argument_list|<
name|QTextFrame
modifier|*
argument_list|>
name|positionChain
decl_stmt|;
name|QList
argument_list|<
name|QTextFrame
modifier|*
argument_list|>
name|anchorChain
decl_stmt|;
name|QTextFrame
modifier|*
name|f
init|=
name|f_position
decl_stmt|;
while|while
condition|(
name|f
condition|)
block|{
name|positionChain
operator|.
name|prepend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|parentFrame
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
name|f_anchor
expr_stmt|;
while|while
condition|(
name|f
condition|)
block|{
name|anchorChain
operator|.
name|prepend
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|parentFrame
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|positionChain
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|anchorChain
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|l
init|=
name|qMin
argument_list|(
name|positionChain
operator|.
name|size
argument_list|()
argument_list|,
name|anchorChain
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|positionChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|anchorChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|<=
name|QTextCursor
operator|::
name|WordLeft
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|positionChain
operator|.
name|size
argument_list|()
condition|)
name|position
operator|=
name|positionChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|firstPosition
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
name|positionChain
operator|.
name|size
argument_list|()
condition|)
name|position
operator|=
name|positionChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|lastPosition
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|position
operator|<
name|adjusted_anchor
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|anchorChain
operator|.
name|size
argument_list|()
condition|)
name|adjusted_anchor
operator|=
name|anchorChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|lastPosition
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
name|anchorChain
operator|.
name|size
argument_list|()
condition|)
name|adjusted_anchor
operator|=
name|anchorChain
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|firstPosition
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|f_position
operator|=
name|positionChain
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// same frame, either need to adjust to cell boundaries or return
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|f_position
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return;
name|QTextTableCell
name|c_position
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|QTextTableCell
name|c_anchor
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|adjusted_anchor
argument_list|)
decl_stmt|;
if|if
condition|(
name|c_position
operator|!=
name|c_anchor
condition|)
block|{
name|position
operator|=
name|c_position
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|position
operator|<
name|adjusted_anchor
condition|)
name|adjusted_anchor
operator|=
name|c_anchor
operator|.
name|lastPosition
argument_list|()
expr_stmt|;
else|else
name|adjusted_anchor
operator|=
name|c_anchor
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
block|}
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|aboutToRemoveCell
name|void
name|QTextCursorPrivate
operator|::
name|aboutToRemoveCell
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|from
operator|<=
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
name|anchor
condition|)
return|return;
name|QTextTable
modifier|*
name|t
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|QTextTableCell
name|removedCellFrom
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|QTextTableCell
name|removedCellEnd
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|to
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|removedCellFrom
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|removedCellEnd
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|int
name|curFrom
init|=
name|position
decl_stmt|;
name|int
name|curTo
init|=
name|adjusted_anchor
decl_stmt|;
if|if
condition|(
name|curTo
operator|<
name|curFrom
condition|)
name|qSwap
argument_list|(
name|curFrom
argument_list|,
name|curTo
argument_list|)
expr_stmt|;
name|QTextTableCell
name|cellStart
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|curFrom
argument_list|)
decl_stmt|;
name|QTextTableCell
name|cellEnd
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|curTo
argument_list|)
decl_stmt|;
if|if
condition|(
name|cellStart
operator|.
name|row
argument_list|()
operator|>=
name|removedCellFrom
operator|.
name|row
argument_list|()
operator|&&
name|cellEnd
operator|.
name|row
argument_list|()
operator|<=
name|removedCellEnd
operator|.
name|row
argument_list|()
operator|&&
name|cellStart
operator|.
name|column
argument_list|()
operator|>=
name|removedCellFrom
operator|.
name|column
argument_list|()
operator|&&
name|cellEnd
operator|.
name|column
argument_list|()
operator|<=
name|removedCellEnd
operator|.
name|column
argument_list|()
condition|)
block|{
comment|// selection is completely removed
comment|// find a new position, as close as possible to where we were.
name|QTextTableCell
name|cell
decl_stmt|;
if|if
condition|(
name|removedCellFrom
operator|.
name|row
argument_list|()
operator|==
literal|0
operator|&&
name|removedCellEnd
operator|.
name|row
argument_list|()
operator|==
name|t
operator|->
name|rows
argument_list|()
operator|-
literal|1
condition|)
comment|// removed n columns
name|cell
operator|=
name|t
operator|->
name|cellAt
argument_list|(
name|cellStart
operator|.
name|row
argument_list|()
argument_list|,
name|removedCellEnd
operator|.
name|column
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|removedCellFrom
operator|.
name|column
argument_list|()
operator|==
literal|0
operator|&&
name|removedCellEnd
operator|.
name|column
argument_list|()
operator|==
name|t
operator|->
name|columns
argument_list|()
operator|-
literal|1
condition|)
comment|// removed n rows
name|cell
operator|=
name|t
operator|->
name|cellAt
argument_list|(
name|removedCellEnd
operator|.
name|row
argument_list|()
operator|+
literal|1
argument_list|,
name|cellStart
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|newPosition
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|isValid
argument_list|()
condition|)
name|newPosition
operator|=
name|cell
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
else|else
name|newPosition
operator|=
name|t
operator|->
name|lastPosition
argument_list|()
operator|+
literal|1
expr_stmt|;
name|setPosition
argument_list|(
name|newPosition
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|newPosition
expr_stmt|;
name|adjusted_anchor
operator|=
name|newPosition
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cellStart
operator|.
name|row
argument_list|()
operator|>=
name|removedCellFrom
operator|.
name|row
argument_list|()
operator|&&
name|cellStart
operator|.
name|row
argument_list|()
operator|<=
name|removedCellEnd
operator|.
name|row
argument_list|()
operator|&&
name|cellEnd
operator|.
name|row
argument_list|()
operator|>
name|removedCellEnd
operator|.
name|row
argument_list|()
condition|)
block|{
name|int
name|newPosition
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|removedCellEnd
operator|.
name|row
argument_list|()
operator|+
literal|1
argument_list|,
name|cellStart
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|position
operator|<
name|anchor
condition|)
name|position
operator|=
name|newPosition
expr_stmt|;
else|else
name|anchor
operator|=
name|adjusted_anchor
operator|=
name|newPosition
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cellStart
operator|.
name|column
argument_list|()
operator|>=
name|removedCellFrom
operator|.
name|column
argument_list|()
operator|&&
name|cellStart
operator|.
name|column
argument_list|()
operator|<=
name|removedCellEnd
operator|.
name|column
argument_list|()
operator|&&
name|cellEnd
operator|.
name|column
argument_list|()
operator|>
name|removedCellEnd
operator|.
name|column
argument_list|()
condition|)
block|{
name|int
name|newPosition
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|cellStart
operator|.
name|row
argument_list|()
argument_list|,
name|removedCellEnd
operator|.
name|column
argument_list|()
operator|+
literal|1
argument_list|)
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|position
operator|<
name|anchor
condition|)
name|position
operator|=
name|newPosition
expr_stmt|;
else|else
name|anchor
operator|=
name|adjusted_anchor
operator|=
name|newPosition
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|movePosition
name|bool
name|QTextCursorPrivate
operator|::
name|movePosition
parameter_list|(
name|QTextCursor
operator|::
name|MoveOperation
name|op
parameter_list|,
name|QTextCursor
operator|::
name|MoveMode
name|mode
parameter_list|)
block|{
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
name|bool
name|adjustX
init|=
literal|true
decl_stmt|;
name|QTextBlock
name|blockIt
init|=
name|block
argument_list|()
decl_stmt|;
name|bool
name|visualMovement
init|=
name|priv
operator|->
name|defaultCursorMoveStyle
operator|==
name|Qt
operator|::
name|VisualMoveStyle
decl_stmt|;
if|if
condition|(
operator|!
name|blockIt
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|blockIt
operator|.
name|textDirection
argument_list|()
operator|==
name|Qt
operator|::
name|RightToLeft
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|WordLeft
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|NextWord
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|WordRight
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|PreviousWord
expr_stmt|;
if|if
condition|(
operator|!
name|visualMovement
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|Left
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|NextCharacter
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|Right
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|PreviousCharacter
expr_stmt|;
block|}
block|}
specifier|const
name|QTextLayout
modifier|*
name|layout
init|=
name|blockLayout
argument_list|(
name|blockIt
argument_list|)
decl_stmt|;
name|int
name|relativePos
init|=
name|position
operator|-
name|blockIt
operator|.
name|position
argument_list|()
decl_stmt|;
name|QTextLine
name|line
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|isInEditBlock
argument_list|()
condition|)
name|line
operator|=
name|layout
operator|->
name|lineForTextPosition
argument_list|(
name|relativePos
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
operator|==
name|priv
operator|->
name|frameAt
argument_list|(
name|adjusted_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|newPosition
init|=
name|position
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|KeepAnchor
operator|&&
name|complexSelectionTable
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|>=
name|QTextCursor
operator|::
name|EndOfLine
operator|&&
name|op
operator|<=
name|QTextCursor
operator|::
name|NextWord
operator|)
operator|||
operator|(
name|op
operator|>=
name|QTextCursor
operator|::
name|Right
operator|&&
name|op
operator|<=
name|QTextCursor
operator|::
name|WordRight
operator|)
condition|)
block|{
name|QTextTable
modifier|*
name|t
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// as we have already made sure we have a complex selection
name|QTextTableCell
name|cell_pos
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell_pos
operator|.
name|column
argument_list|()
operator|+
name|cell_pos
operator|.
name|columnSpan
argument_list|()
operator|!=
name|t
operator|->
name|columns
argument_list|()
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|NextCell
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|==
operator|-
literal|1
operator|&&
operator|!
name|priv
operator|->
name|isInEditBlock
argument_list|()
operator|&&
operator|(
name|op
operator|==
name|QTextCursor
operator|::
name|Up
operator|||
name|op
operator|==
name|QTextCursor
operator|::
name|Down
operator|)
condition|)
name|setX
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|QTextCursor
operator|::
name|NoMove
case|:
return|return
literal|true
return|;
case|case
name|QTextCursor
operator|::
name|Start
case|:
name|newPosition
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|StartOfLine
case|:
block|{
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|isValid
argument_list|()
condition|)
name|newPosition
operator|+=
name|line
operator|.
name|textStart
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|StartOfBlock
case|:
block|{
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|PreviousBlock
case|:
block|{
if|if
condition|(
name|blockIt
operator|==
name|priv
operator|->
name|blocksBegin
argument_list|()
condition|)
return|return
literal|false
return|;
name|blockIt
operator|=
name|blockIt
operator|.
name|previous
argument_list|()
expr_stmt|;
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|PreviousCharacter
case|:
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
operator|&&
name|position
operator|!=
name|adjusted_anchor
condition|)
name|newPosition
operator|=
name|qMin
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
expr_stmt|;
else|else
name|newPosition
operator|=
name|priv
operator|->
name|previousCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipCharacters
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|Left
case|:
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
operator|&&
name|position
operator|!=
name|adjusted_anchor
condition|)
name|newPosition
operator|=
name|visualMovement
condition|?
name|qMax
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
else|:
name|qMin
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
expr_stmt|;
else|else
name|newPosition
operator|=
name|visualMovement
condition|?
name|priv
operator|->
name|leftCursorPosition
argument_list|(
name|position
argument_list|)
else|:
name|priv
operator|->
name|previousCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipCharacters
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|StartOfWord
case|:
block|{
if|if
condition|(
name|relativePos
operator|==
literal|0
condition|)
break|break;
comment|// skip if already at word start
name|QTextEngine
modifier|*
name|engine
init|=
name|layout
operator|->
name|engine
argument_list|()
decl_stmt|;
name|engine
operator|->
name|attributes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|relativePos
operator|==
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|&&
operator|(
name|engine
operator|->
name|atSpace
argument_list|(
name|relativePos
operator|-
literal|1
argument_list|)
operator|||
name|engine
operator|->
name|atWordSeparator
argument_list|(
name|relativePos
operator|-
literal|1
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|relativePos
operator|<
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
operator|++
name|position
expr_stmt|;
comment|// FALL THROUGH!
block|}
case|case
name|QTextCursor
operator|::
name|PreviousWord
case|:
case|case
name|QTextCursor
operator|::
name|WordLeft
case|:
name|newPosition
operator|=
name|priv
operator|->
name|previousCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipWords
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|Up
case|:
block|{
name|int
name|i
init|=
name|line
operator|.
name|lineNumber
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|blockIt
operator|==
name|priv
operator|->
name|blocksBegin
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|blockPosition
init|=
name|blockIt
operator|.
name|position
argument_list|()
decl_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|blockPosition
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|blockPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|firstPosition
argument_list|()
operator|==
name|blockPosition
condition|)
block|{
name|int
name|row
init|=
name|cell
operator|.
name|row
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|row
operator|>=
literal|0
condition|)
block|{
name|blockPosition
operator|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|cell
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|lastPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// move to line above the table
name|blockPosition
operator|=
name|table
operator|->
name|firstPosition
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|blockIt
operator|=
name|priv
operator|->
name|blocksFind
argument_list|(
name|blockPosition
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blockIt
operator|=
name|blockIt
operator|.
name|previous
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|blockIt
operator|=
name|blockIt
operator|.
name|previous
argument_list|()
expr_stmt|;
block|}
name|layout
operator|=
name|blockLayout
argument_list|(
name|blockIt
argument_list|)
expr_stmt|;
name|i
operator|=
name|layout
operator|->
name|lineCount
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|layout
operator|->
name|lineCount
argument_list|()
condition|)
block|{
name|QTextLine
name|line
init|=
name|layout
operator|->
name|lineAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newPosition
operator|=
name|line
operator|.
name|xToCursor
argument_list|(
name|x
argument_list|)
operator|+
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
name|adjustX
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|End
case|:
name|newPosition
operator|=
name|priv
operator|->
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|EndOfLine
case|:
block|{
if|if
condition|(
operator|!
name|line
operator|.
name|isValid
argument_list|()
operator|||
name|line
operator|.
name|textLength
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|blockIt
operator|.
name|length
argument_list|()
operator|>=
literal|1
condition|)
comment|// position right before the block separator
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
operator|+
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
operator|+
name|line
operator|.
name|textStart
argument_list|()
operator|+
name|line
operator|.
name|textLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|newPosition
operator|>=
name|priv
operator|->
name|length
argument_list|()
condition|)
name|newPosition
operator|=
name|priv
operator|->
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|lineNumber
argument_list|()
operator|<
name|layout
operator|->
name|lineCount
argument_list|()
operator|-
literal|1
condition|)
block|{
specifier|const
name|QString
name|text
init|=
name|blockIt
operator|.
name|text
argument_list|()
decl_stmt|;
comment|// ###### this relies on spaces being the cause for linebreaks.
comment|// this doesn't work with japanese
if|if
condition|(
name|text
operator|.
name|at
argument_list|(
name|line
operator|.
name|textStart
argument_list|()
operator|+
name|line
operator|.
name|textLength
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
operator|--
name|newPosition
expr_stmt|;
block|}
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|EndOfWord
case|:
block|{
name|QTextEngine
modifier|*
name|engine
init|=
name|layout
operator|->
name|engine
argument_list|()
decl_stmt|;
name|engine
operator|->
name|attributes
argument_list|()
expr_stmt|;
specifier|const
name|int
name|len
init|=
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|relativePos
operator|>=
name|len
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|engine
operator|->
name|atWordSeparator
argument_list|(
name|relativePos
argument_list|)
condition|)
block|{
operator|++
name|relativePos
expr_stmt|;
while|while
condition|(
name|relativePos
operator|<
name|len
operator|&&
name|engine
operator|->
name|atWordSeparator
argument_list|(
name|relativePos
argument_list|)
condition|)
operator|++
name|relativePos
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|relativePos
operator|<
name|len
operator|&&
operator|!
name|engine
operator|->
name|atSpace
argument_list|(
name|relativePos
argument_list|)
operator|&&
operator|!
name|engine
operator|->
name|atWordSeparator
argument_list|(
name|relativePos
argument_list|)
condition|)
operator|++
name|relativePos
expr_stmt|;
block|}
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
operator|+
name|relativePos
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|EndOfBlock
case|:
if|if
condition|(
name|blockIt
operator|.
name|length
argument_list|()
operator|>=
literal|1
condition|)
comment|// position right before the block separator
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
operator|+
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|NextBlock
case|:
block|{
name|blockIt
operator|=
name|blockIt
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockIt
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|NextCharacter
case|:
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
operator|&&
name|position
operator|!=
name|adjusted_anchor
condition|)
name|newPosition
operator|=
name|qMax
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
expr_stmt|;
else|else
name|newPosition
operator|=
name|priv
operator|->
name|nextCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipCharacters
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|Right
case|:
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
operator|&&
name|position
operator|!=
name|adjusted_anchor
condition|)
name|newPosition
operator|=
name|visualMovement
condition|?
name|qMin
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
else|:
name|qMax
argument_list|(
name|position
argument_list|,
name|adjusted_anchor
argument_list|)
expr_stmt|;
else|else
name|newPosition
operator|=
name|visualMovement
condition|?
name|priv
operator|->
name|rightCursorPosition
argument_list|(
name|position
argument_list|)
else|:
name|priv
operator|->
name|nextCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipCharacters
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|NextWord
case|:
case|case
name|QTextCursor
operator|::
name|WordRight
case|:
name|newPosition
operator|=
name|priv
operator|->
name|nextCursorPosition
argument_list|(
name|position
argument_list|,
name|QTextLayout
operator|::
name|SkipWords
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTextCursor
operator|::
name|Down
case|:
block|{
name|int
name|i
init|=
name|line
operator|.
name|lineNumber
argument_list|()
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|layout
operator|->
name|lineCount
argument_list|()
condition|)
block|{
name|int
name|blockPosition
init|=
name|blockIt
operator|.
name|position
argument_list|()
operator|+
name|blockIt
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|blockPosition
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|blockPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|.
name|lastPosition
argument_list|()
operator|==
name|blockPosition
condition|)
block|{
name|int
name|row
init|=
name|cell
operator|.
name|row
argument_list|()
operator|+
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|row
operator|<
name|table
operator|->
name|rows
argument_list|()
condition|)
block|{
name|blockPosition
operator|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|cell
operator|.
name|column
argument_list|()
argument_list|)
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// move to line below the table
name|blockPosition
operator|=
name|table
operator|->
name|lastPosition
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
name|blockIt
operator|=
name|priv
operator|->
name|blocksFind
argument_list|(
name|blockPosition
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blockIt
operator|=
name|blockIt
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|blockIt
operator|=
name|blockIt
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockIt
operator|==
name|priv
operator|->
name|blocksEnd
argument_list|()
condition|)
return|return
literal|false
return|;
name|layout
operator|=
name|blockLayout
argument_list|(
name|blockIt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|layout
operator|->
name|lineCount
argument_list|()
condition|)
block|{
name|QTextLine
name|line
init|=
name|layout
operator|->
name|lineAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newPosition
operator|=
name|line
operator|.
name|xToCursor
argument_list|(
name|x
argument_list|)
operator|+
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newPosition
operator|=
name|blockIt
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
name|adjustX
operator|=
literal|false
expr_stmt|;
break|break;
block|}
case|case
name|QTextCursor
operator|::
name|NextCell
case|:
comment|// fall through
case|case
name|QTextCursor
operator|::
name|PreviousCell
case|:
comment|// fall through
case|case
name|QTextCursor
operator|::
name|NextRow
case|:
comment|// fall through
case|case
name|QTextCursor
operator|::
name|PreviousRow
case|:
block|{
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
literal|false
return|;
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|cell
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|column
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
name|int
name|row
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
specifier|const
name|int
name|currentRow
init|=
name|row
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|NextCell
operator|||
name|op
operator|==
name|QTextCursor
operator|::
name|NextRow
condition|)
block|{
do|do
block|{
name|column
operator|+=
name|cell
operator|.
name|columnSpan
argument_list|()
expr_stmt|;
if|if
condition|(
name|column
operator|>=
name|table
operator|->
name|columns
argument_list|()
condition|)
block|{
name|column
operator|=
literal|0
expr_stmt|;
operator|++
name|row
expr_stmt|;
block|}
name|cell
operator|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
comment|// note we also continue while we have not reached a cell thats not merged with one above us
block|}
do|while
condition|(
name|cell
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|(
name|op
operator|==
name|QTextCursor
operator|::
name|NextRow
operator|&&
name|currentRow
operator|==
name|cell
operator|.
name|row
argument_list|()
operator|)
operator|||
name|cell
operator|.
name|row
argument_list|()
operator|<
name|row
operator|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|QTextCursor
operator|::
name|PreviousCell
operator|||
name|op
operator|==
name|QTextCursor
operator|::
name|PreviousRow
condition|)
block|{
do|do
block|{
operator|--
name|column
expr_stmt|;
if|if
condition|(
name|column
operator|<
literal|0
condition|)
block|{
name|column
operator|=
name|table
operator|->
name|columns
argument_list|()
operator|-
literal|1
expr_stmt|;
operator|--
name|row
expr_stmt|;
block|}
name|cell
operator|=
name|table
operator|->
name|cellAt
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
comment|// note we also continue while we have not reached a cell thats not merged with one above us
block|}
do|while
condition|(
name|cell
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
operator|(
name|op
operator|==
name|QTextCursor
operator|::
name|PreviousRow
operator|&&
name|currentRow
operator|==
name|cell
operator|.
name|row
argument_list|()
operator|)
operator|||
name|cell
operator|.
name|row
argument_list|()
operator|<
name|row
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|cell
operator|.
name|isValid
argument_list|()
condition|)
name|newPosition
operator|=
name|cell
operator|.
name|firstPosition
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|KeepAnchor
condition|)
block|{
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|&&
operator|(
operator|(
name|op
operator|>=
name|QTextCursor
operator|::
name|PreviousBlock
operator|&&
name|op
operator|<=
name|QTextCursor
operator|::
name|WordLeft
operator|)
operator|||
operator|(
name|op
operator|>=
name|QTextCursor
operator|::
name|NextBlock
operator|&&
name|op
operator|<=
name|QTextCursor
operator|::
name|WordRight
operator|)
operator|)
condition|)
block|{
name|int
name|oldColumn
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
operator|.
name|column
argument_list|()
decl_stmt|;
specifier|const
name|QTextTableCell
name|otherCell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|newPosition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|otherCell
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|int
name|newColumn
init|=
name|otherCell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|oldColumn
operator|>
name|newColumn
operator|&&
name|op
operator|>=
name|QTextCursor
operator|::
name|End
operator|)
operator|||
operator|(
name|oldColumn
operator|<
name|newColumn
operator|&&
name|op
operator|<=
name|QTextCursor
operator|::
name|WordLeft
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
specifier|const
name|bool
name|moved
init|=
name|setPosition
argument_list|(
name|newPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
condition|)
block|{
name|anchor
operator|=
name|position
expr_stmt|;
name|adjusted_anchor
operator|=
name|position
expr_stmt|;
block|}
else|else
block|{
name|adjustCursor
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adjustX
condition|)
name|setX
argument_list|()
expr_stmt|;
return|return
name|moved
return|;
block|}
end_function
begin_function
DECL|function|complexSelectionTable
name|QTextTable
modifier|*
name|QTextCursorPrivate
operator|::
name|complexSelectionTable
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|position
operator|==
name|anchor
condition|)
return|return
literal|0
return|;
name|QTextTable
modifier|*
name|t
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|QTextTableCell
name|cell_pos
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|QTextTableCell
name|cell_anchor
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|adjusted_anchor
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|cell_anchor
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell_pos
operator|==
name|cell_anchor
condition|)
name|t
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|selectedTableCells
name|void
name|QTextCursorPrivate
operator|::
name|selectedTableCells
parameter_list|(
name|int
modifier|*
name|firstRow
parameter_list|,
name|int
modifier|*
name|numRows
parameter_list|,
name|int
modifier|*
name|firstColumn
parameter_list|,
name|int
modifier|*
name|numColumns
parameter_list|)
specifier|const
block|{
operator|*
name|firstRow
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|firstColumn
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|numRows
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|numColumns
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|position
operator|==
name|anchor
condition|)
return|return;
name|QTextTable
modifier|*
name|t
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|frameAt
argument_list|(
name|position
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|QTextTableCell
name|cell_pos
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|QTextTableCell
name|cell_anchor
init|=
name|t
operator|->
name|cellAt
argument_list|(
name|adjusted_anchor
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|cell_anchor
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell_pos
operator|==
name|cell_anchor
condition|)
return|return;
operator|*
name|firstRow
operator|=
name|qMin
argument_list|(
name|cell_pos
operator|.
name|row
argument_list|()
argument_list|,
name|cell_anchor
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|firstColumn
operator|=
name|qMin
argument_list|(
name|cell_pos
operator|.
name|column
argument_list|()
argument_list|,
name|cell_anchor
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|numRows
operator|=
name|qMax
argument_list|(
name|cell_pos
operator|.
name|row
argument_list|()
operator|+
name|cell_pos
operator|.
name|rowSpan
argument_list|()
argument_list|,
name|cell_anchor
operator|.
name|row
argument_list|()
operator|+
name|cell_anchor
operator|.
name|rowSpan
argument_list|()
argument_list|)
operator|-
operator|*
name|firstRow
expr_stmt|;
operator|*
name|numColumns
operator|=
name|qMax
argument_list|(
name|cell_pos
operator|.
name|column
argument_list|()
operator|+
name|cell_pos
operator|.
name|columnSpan
argument_list|()
argument_list|,
name|cell_anchor
operator|.
name|column
argument_list|()
operator|+
name|cell_anchor
operator|.
name|columnSpan
argument_list|()
argument_list|)
operator|-
operator|*
name|firstColumn
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setBlockCharFormatHelper
specifier|static
name|void
name|setBlockCharFormatHelper
parameter_list|(
name|QTextDocumentPrivate
modifier|*
name|priv
parameter_list|,
name|int
name|pos1
parameter_list|,
name|int
name|pos2
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|,
name|QTextDocumentPrivate
operator|::
name|FormatChangeMode
name|changeMode
parameter_list|)
block|{
name|QTextBlock
name|it
init|=
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos1
argument_list|)
decl_stmt|;
name|QTextBlock
name|end
init|=
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos2
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|.
name|isValid
argument_list|()
condition|)
name|end
operator|=
name|end
operator|.
name|next
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
name|it
operator|=
name|it
operator|.
name|next
argument_list|()
control|)
block|{
name|priv
operator|->
name|setCharFormat
argument_list|(
name|it
operator|.
name|position
argument_list|()
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setBlockCharFormat
name|void
name|QTextCursorPrivate
operator|::
name|setBlockCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|_format
parameter_list|,
name|QTextDocumentPrivate
operator|::
name|FormatChangeMode
name|changeMode
parameter_list|)
block|{
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|QTextCharFormat
name|format
init|=
name|_format
decl_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|complexSelectionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|int
name|row_start
decl_stmt|,
name|col_start
decl_stmt|,
name|num_rows
decl_stmt|,
name|num_cols
decl_stmt|;
name|selectedTableCells
argument_list|(
operator|&
name|row_start
argument_list|,
operator|&
name|num_rows
argument_list|,
operator|&
name|col_start
argument_list|,
operator|&
name|num_cols
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|row_start
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row_start
init|;
name|r
operator|<
name|row_start
operator|+
name|num_rows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|col_start
init|;
name|c
operator|<
name|col_start
operator|+
name|num_cols
condition|;
operator|++
name|c
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|int
name|rspan
init|=
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
name|int
name|cspan
init|=
name|cell
operator|.
name|columnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|rspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cr
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|cr
operator|!=
name|r
condition|)
continue|continue;
block|}
if|if
condition|(
name|cspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
name|c
condition|)
continue|continue;
block|}
name|int
name|pos1
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
name|int
name|pos2
init|=
name|cell
operator|.
name|lastPosition
argument_list|()
decl_stmt|;
name|setBlockCharFormatHelper
argument_list|(
name|priv
argument_list|,
name|pos1
argument_list|,
name|pos2
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|pos1
init|=
name|position
decl_stmt|;
name|int
name|pos2
init|=
name|adjusted_anchor
decl_stmt|;
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
block|{
name|pos1
operator|=
name|adjusted_anchor
expr_stmt|;
name|pos2
operator|=
name|position
expr_stmt|;
block|}
name|setBlockCharFormatHelper
argument_list|(
name|priv
argument_list|,
name|pos1
argument_list|,
name|pos2
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setBlockFormat
name|void
name|QTextCursorPrivate
operator|::
name|setBlockFormat
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|,
name|QTextDocumentPrivate
operator|::
name|FormatChangeMode
name|changeMode
parameter_list|)
block|{
name|QTextTable
modifier|*
name|table
init|=
name|complexSelectionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|int
name|row_start
decl_stmt|,
name|col_start
decl_stmt|,
name|num_rows
decl_stmt|,
name|num_cols
decl_stmt|;
name|selectedTableCells
argument_list|(
operator|&
name|row_start
argument_list|,
operator|&
name|num_rows
argument_list|,
operator|&
name|col_start
argument_list|,
operator|&
name|num_cols
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|row_start
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row_start
init|;
name|r
operator|<
name|row_start
operator|+
name|num_rows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|col_start
init|;
name|c
operator|<
name|col_start
operator|+
name|num_cols
condition|;
operator|++
name|c
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|int
name|rspan
init|=
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
name|int
name|cspan
init|=
name|cell
operator|.
name|columnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|rspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cr
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|cr
operator|!=
name|r
condition|)
continue|continue;
block|}
if|if
condition|(
name|cspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
name|c
condition|)
continue|continue;
block|}
name|int
name|pos1
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
name|int
name|pos2
init|=
name|cell
operator|.
name|lastPosition
argument_list|()
decl_stmt|;
name|priv
operator|->
name|setBlockFormat
argument_list|(
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos1
argument_list|)
argument_list|,
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos2
argument_list|)
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|pos1
init|=
name|position
decl_stmt|;
name|int
name|pos2
init|=
name|adjusted_anchor
decl_stmt|;
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
block|{
name|pos1
operator|=
name|adjusted_anchor
expr_stmt|;
name|pos2
operator|=
name|position
expr_stmt|;
block|}
name|priv
operator|->
name|setBlockFormat
argument_list|(
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos1
argument_list|)
argument_list|,
name|priv
operator|->
name|blocksFind
argument_list|(
name|pos2
argument_list|)
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setCharFormat
name|void
name|QTextCursorPrivate
operator|::
name|setCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|_format
parameter_list|,
name|QTextDocumentPrivate
operator|::
name|FormatChangeMode
name|changeMode
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|position
operator|!=
name|anchor
argument_list|)
expr_stmt|;
name|QTextCharFormat
name|format
init|=
name|_format
decl_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|complexSelectionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|int
name|row_start
decl_stmt|,
name|col_start
decl_stmt|,
name|num_rows
decl_stmt|,
name|num_cols
decl_stmt|;
name|selectedTableCells
argument_list|(
operator|&
name|row_start
argument_list|,
operator|&
name|num_rows
argument_list|,
operator|&
name|col_start
argument_list|,
operator|&
name|num_cols
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|row_start
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row_start
init|;
name|r
operator|<
name|row_start
operator|+
name|num_rows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|col_start
init|;
name|c
operator|<
name|col_start
operator|+
name|num_cols
condition|;
operator|++
name|c
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|int
name|rspan
init|=
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
name|int
name|cspan
init|=
name|cell
operator|.
name|columnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|rspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cr
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|cr
operator|!=
name|r
condition|)
continue|continue;
block|}
if|if
condition|(
name|cspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
name|c
condition|)
continue|continue;
block|}
name|int
name|pos1
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
decl_stmt|;
name|int
name|pos2
init|=
name|cell
operator|.
name|lastPosition
argument_list|()
decl_stmt|;
name|priv
operator|->
name|setCharFormat
argument_list|(
name|pos1
argument_list|,
name|pos2
operator|-
name|pos1
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|pos1
init|=
name|position
decl_stmt|;
name|int
name|pos2
init|=
name|adjusted_anchor
decl_stmt|;
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
block|{
name|pos1
operator|=
name|adjusted_anchor
expr_stmt|;
name|pos2
operator|=
name|position
expr_stmt|;
block|}
name|priv
operator|->
name|setCharFormat
argument_list|(
name|pos1
argument_list|,
name|pos2
operator|-
name|pos1
argument_list|,
name|format
argument_list|,
name|changeMode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|blockLayout
name|QTextLayout
modifier|*
name|QTextCursorPrivate
operator|::
name|blockLayout
parameter_list|(
name|QTextBlock
modifier|&
name|block
parameter_list|)
specifier|const
block|{
name|QTextLayout
modifier|*
name|tl
init|=
name|block
operator|.
name|layout
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tl
operator|->
name|lineCount
argument_list|()
operator|&&
name|priv
operator|->
name|layout
argument_list|()
condition|)
name|priv
operator|->
name|layout
argument_list|()
operator|->
name|blockBoundingRect
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|tl
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextCursor     \reentrant     \inmodule QtGui      \brief The QTextCursor class offers an API to access and modify QTextDocuments.      \ingroup richtext-processing     \ingroup shared      Text cursors are objects that are used to access and modify the     contents and underlying structure of text documents via a     programming interface that mimics the behavior of a cursor in a     text editor. QTextCursor contains information about both the     cursor's position within a QTextDocument and any selection that it     has made.      QTextCursor is modeled on the way a text cursor behaves in a text     editor, providing a programmatic means of performing standard     actions through the user interface. A document can be thought of     as a single string of characters. The cursor's current position()     then is always either \e between two consecutive characters in the     string, or else \e before the very first character or \e after the     very last character in the string.  Documents can also contain     tables, lists, images, and other objects in addition to text but,     from the developer's point of view, the document can be treated as     one long string.  Some portions of that string can be considered     to lie within particular blocks (e.g. paragraphs), or within a     table's cell, or a list's item, or other structural elements. When     we refer to "current character" we mean the character immediately     \e before the cursor position() in the document. Similarly, the     "current block" is the block that contains the cursor position().      A QTextCursor also has an anchor() position. The text that is     between the anchor() and the position() is the selection. If     anchor() == position() there is no selection.      The cursor position can be changed programmatically using     setPosition() and movePosition(); the latter can also be used to     select text. For selections see selectionStart(), selectionEnd(),     hasSelection(), clearSelection(), and removeSelectedText().      If the position() is at the start of a block, atBlockStart()     returns \c true; and if it is at the end of a block, atBlockEnd() returns     true. The format of the current character is returned by     charFormat(), and the format of the current block is returned by     blockFormat().      Formatting can be applied to the current text document using the     setCharFormat(), mergeCharFormat(), setBlockFormat() and     mergeBlockFormat() functions. The 'set' functions will replace the     cursor's current character or block format, while the 'merge'     functions add the given format properties to the cursor's current     format. If the cursor has a selection, the given format is applied     to the current selection. Note that when only a part of a block is     selected, the block format is applied to the entire block. The text     at the current character position can be turned into a list using     createList().      Deletions can be achieved using deleteChar(),     deletePreviousChar(), and removeSelectedText().      Text strings can be inserted into the document with the insertText()     function, blocks (representing new paragraphs) can be inserted with     insertBlock().      Existing fragments of text can be inserted with insertFragment() but,     if you want to insert pieces of text in various formats, it is usually     still easier to use insertText() and supply a character format.      Various types of higher-level structure can also be inserted into the     document with the cursor:      \list     \li Lists are ordered sequences of block elements that are decorated with        bullet points or symbols. These are inserted in a specified format        with insertList().     \li Tables are inserted with the insertTable() function, and can be        given an optional format. These contain an array of cells that can        be traversed using the cursor.     \li Inline images are inserted with insertImage(). The image to be        used can be specified in an image format, or by name.     \li Frames are inserted by calling insertFrame() with a specified format.     \endlist      Actions can be grouped (i.e. treated as a single action for     undo/redo) using beginEditBlock() and endEditBlock().      Cursor movements are limited to valid cursor positions. In Latin     writing this is between any two consecutive characters in the     text, before the first character, or after the last character. In     some other writing systems cursor movements are limited to     "clusters" (e.g. a syllable in Devanagari, or a base letter plus     diacritics).  Functions such as movePosition() and deleteChar()     limit cursor movement to these valid positions.      \sa {Rich Text Processing}  */
end_comment
begin_comment
comment|/*!     \enum QTextCursor::MoveOperation      \value NoMove Keep the cursor where it is      \value Start Move to the start of the document.     \value StartOfLine Move to the start of the current line.     \value StartOfBlock Move to the start of the current block.     \value StartOfWord Move to the start of the current word.     \value PreviousBlock Move to the start of the previous block.     \value PreviousCharacter Move to the previous character.     \value PreviousWord Move to the beginning of the previous word.     \value Up Move up one line.     \value Left Move left one character.     \value WordLeft Move left one word.      \value End Move to the end of the document.     \value EndOfLine Move to the end of the current line.     \value EndOfWord Move to the end of the current word.     \value EndOfBlock Move to the end of the current block.     \value NextBlock Move to the beginning of the next block.     \value NextCharacter Move to the next character.     \value NextWord Move to the next word.     \value Down Move down one line.     \value Right Move right one character.     \value WordRight Move right one word.      \value NextCell  Move to the beginning of the next table cell inside the            current table. If the current cell is the last cell in the row, the            cursor will move to the first cell in the next row.     \value PreviousCell  Move to the beginning of the previous table cell            inside the current table. If the current cell is the first cell in            the row, the cursor will move to the last cell in the previous row.     \value NextRow  Move to the first new cell of the next row in the current            table.     \value PreviousRow  Move to the last cell of the previous row in the            current table.      \sa movePosition() */
end_comment
begin_comment
comment|/*!     \enum QTextCursor::MoveMode      \value MoveAnchor Moves the anchor to the same position as the cursor itself.     \value KeepAnchor Keeps the anchor where it is.      If the anchor() is kept where it is and the position() is moved,     the text in between will be selected. */
end_comment
begin_comment
comment|/*!     \enum QTextCursor::SelectionType      This enum describes the types of selection that can be applied with the     select() function.      \value Document         Selects the entire document.     \value BlockUnderCursor Selects the block of text under the cursor.     \value LineUnderCursor  Selects the line of text under the cursor.     \value WordUnderCursor  Selects the word under the cursor. If the cursor            is not positioned within a string of selectable characters, no            text is selected. */
end_comment
begin_comment
comment|/*!     Constructs a null cursor.  */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a cursor pointing to the beginning of the \a document.  */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
name|QTextDocument
modifier|*
name|document
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QTextCursorPrivate
argument_list|(
name|document
operator|->
name|docHandle
argument_list|()
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a cursor pointing to the beginning of the \a frame. */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
name|QTextFrame
modifier|*
name|frame
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QTextCursorPrivate
argument_list|(
name|frame
operator|->
name|document
argument_list|()
operator|->
name|docHandle
argument_list|()
argument_list|)
argument_list|)
block|{
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
operator|=
name|frame
operator|->
name|firstPosition
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a cursor pointing to the beginning of the \a block. */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QTextCursorPrivate
argument_list|(
name|block
operator|.
name|docHandle
argument_list|()
argument_list|)
argument_list|)
block|{
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
operator|=
name|block
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal  */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
name|QTextDocumentPrivate
modifier|*
name|p
parameter_list|,
name|int
name|pos
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QTextCursorPrivate
argument_list|(
name|p
argument_list|)
argument_list|)
block|{
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
operator|=
name|pos
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
name|QTextCursorPrivate
modifier|*
name|d
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|this
operator|->
name|d
operator|=
name|d
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a new cursor that is a copy of \a cursor.  */
end_comment
begin_constructor
DECL|function|QTextCursor
name|QTextCursor
operator|::
name|QTextCursor
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|d
operator|=
name|cursor
operator|.
name|d
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Makes a copy of \a cursor and assigns it to this QTextCursor. Note     that QTextCursor is an \l{Implicitly Shared Classes}{implicitly     shared} class.   */
end_comment
begin_function
DECL|function|operator =
name|QTextCursor
modifier|&
name|QTextCursor
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
name|d
operator|=
name|cursor
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextCursor::swap(QTextCursor&other)     \since 5.0      Swaps this text cursor instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Destroys the QTextCursor.  */
end_comment
begin_destructor
DECL|function|~QTextCursor
name|QTextCursor
operator|::
name|~
name|QTextCursor
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns \c true if the cursor is null; otherwise returns \c false. A null     cursor is created by the default constructor.  */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QTextCursor
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
return|;
block|}
end_function
begin_comment
comment|/*!     Moves the cursor to the absolute position in the document specified by     \a pos using a \c MoveMode specified by \a m. The cursor is positioned     between characters.      \sa position(), movePosition(), anchor() */
end_comment
begin_function
DECL|function|setPosition
name|void
name|QTextCursor
operator|::
name|setPosition
parameter_list|(
name|int
name|pos
parameter_list|,
name|MoveMode
name|m
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|d
operator|->
name|priv
operator|->
name|length
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextCursor::setPosition: Position '%d' out of range"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|MoveAnchor
condition|)
block|{
name|d
operator|->
name|anchor
operator|=
name|pos
expr_stmt|;
name|d
operator|->
name|adjusted_anchor
operator|=
name|pos
expr_stmt|;
block|}
else|else
block|{
comment|// keep anchor
name|QTextCursor
operator|::
name|MoveOperation
name|op
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|d
operator|->
name|anchor
condition|)
name|op
operator|=
name|QTextCursor
operator|::
name|Left
expr_stmt|;
else|else
name|op
operator|=
name|QTextCursor
operator|::
name|Right
expr_stmt|;
name|d
operator|->
name|adjustCursor
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the absolute position of the cursor within the document.     The cursor is positioned between characters.      \sa setPosition(), movePosition(), anchor(), positionInBlock() */
end_comment
begin_function
DECL|function|position
name|int
name|QTextCursor
operator|::
name|position
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the relative position of the cursor within the block.     The cursor is positioned between characters.      This is equivalent to \c{ position() - block().position()}.      \sa position() */
end_comment
begin_function
DECL|function|positionInBlock
name|int
name|QTextCursor
operator|::
name|positionInBlock
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|position
operator|-
name|d
operator|->
name|block
argument_list|()
operator|.
name|position
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the anchor position; this is the same as position() unless     there is a selection in which case position() marks one end of the     selection and anchor() marks the other end. Just like the cursor     position, the anchor position is between characters.      \sa position(), setPosition(), movePosition(), selectionStart(), selectionEnd() */
end_comment
begin_function
DECL|function|anchor
name|int
name|QTextCursor
operator|::
name|anchor
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|anchor
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::movePosition(MoveOperation operation, MoveMode mode, int n)      Moves the cursor by performing the given \a operation \a n times, using the specified     \a mode, and returns \c true if all operations were completed successfully; otherwise     returns \c false.      For example, if this function is repeatedly used to seek to the end of the next     word, it will eventually fail when the end of the document is reached.      By default, the move operation is performed once (\a n = 1).      If \a mode is \c KeepAnchor, the cursor selects the text it moves     over. This is the same effect that the user achieves when they     hold down the Shift key and move the cursor with the cursor keys.      \sa setVisualNavigation() */
end_comment
begin_function
DECL|function|movePosition
name|bool
name|QTextCursor
operator|::
name|movePosition
parameter_list|(
name|MoveOperation
name|op
parameter_list|,
name|MoveMode
name|mode
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|false
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Start
case|:
case|case
name|StartOfLine
case|:
case|case
name|End
case|:
case|case
name|EndOfLine
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|int
name|previousPosition
init|=
name|d
operator|->
name|position
decl_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|movePosition
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|visualNavigation
operator|&&
operator|!
name|d
operator|->
name|block
argument_list|()
operator|.
name|isVisible
argument_list|()
condition|)
block|{
name|QTextBlock
name|b
init|=
name|d
operator|->
name|block
argument_list|()
decl_stmt|;
if|if
condition|(
name|previousPosition
operator|<
name|d
operator|->
name|position
condition|)
block|{
while|while
condition|(
operator|!
name|b
operator|.
name|next
argument_list|()
operator|.
name|isVisible
argument_list|()
condition|)
name|b
operator|=
name|b
operator|.
name|next
argument_list|()
expr_stmt|;
name|d
operator|->
name|setPosition
argument_list|(
name|b
operator|.
name|position
argument_list|()
operator|+
name|b
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|b
operator|.
name|previous
argument_list|()
operator|.
name|isVisible
argument_list|()
condition|)
name|b
operator|=
name|b
operator|.
name|previous
argument_list|()
expr_stmt|;
name|d
operator|->
name|setPosition
argument_list|(
name|b
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|QTextCursor
operator|::
name|MoveAnchor
condition|)
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|movePosition
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|block
argument_list|()
operator|.
name|isVisible
argument_list|()
condition|)
empty_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Returns \c true if the cursor does visual navigation; otherwise   returns \c false.    Visual navigation means skipping over hidden text paragraphs. The   default is false.    \sa setVisualNavigation(), movePosition()  */
end_comment
begin_function
DECL|function|visualNavigation
name|bool
name|QTextCursor
operator|::
name|visualNavigation
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|visualNavigation
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Sets visual navigation to \a b.    Visual navigation means skipping over hidden text paragraphs. The   default is false.    \sa visualNavigation(), movePosition()  */
end_comment
begin_function
DECL|function|setVisualNavigation
name|void
name|QTextCursor
operator|::
name|setVisualNavigation
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|visualNavigation
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Sets the visual x position for vertical cursor movements to \a x.    The vertical movement x position is cleared automatically when the cursor moves horizontally, and kept   unchanged when the cursor moves vertically. The mechanism allows the cursor to move up and down on a   visually straight line with proportional fonts, and to gently "jump" over short lines.    A value of -1 indicates no predefined x position. It will then be set automatically the next time the   cursor moves up or down.    \sa verticalMovementX()   */
end_comment
begin_function
DECL|function|setVerticalMovementX
name|void
name|QTextCursor
operator|::
name|setVerticalMovementX
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|x
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \since 4.7    Returns the visual x position for vertical cursor movements.    A value of -1 indicates no predefined x position. It will then be set automatically the next time the   cursor moves up or down.    \sa setVerticalMovementX()   */
end_comment
begin_function
DECL|function|verticalMovementX
name|int
name|QTextCursor
operator|::
name|verticalMovementX
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|x
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns whether the cursor should keep its current position when text gets inserted at the position of the   cursor.    The default is false;    \sa setKeepPositionOnInsert()  */
end_comment
begin_function
DECL|function|keepPositionOnInsert
name|bool
name|QTextCursor
operator|::
name|keepPositionOnInsert
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|keepPositionOnInsert
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Defines whether the cursor should keep its current position when text gets inserted at the current position of the   cursor.    If \a b is true, the cursor keeps its current position when text gets inserted at the positing of the cursor.   If \a b is false, the cursor moves along with the inserted text.    The default is false.    Note that a cursor always moves when text is inserted before the current position of the cursor, and it   always keeps its position when text is inserted after the current position of the cursor.    \sa keepPositionOnInsert()  */
end_comment
begin_function
DECL|function|setKeepPositionOnInsert
name|void
name|QTextCursor
operator|::
name|setKeepPositionOnInsert
parameter_list|(
name|bool
name|b
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|keepPositionOnInsert
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts \a text at the current position, using the current     character format.      If there is a selection, the selection is deleted and replaced by     \a text, for example:     \snippet code/src_gui_text_qtextcursor.cpp 0     This clears any existing selection, selects the word at the cursor     (i.e. from position() forward), and replaces the selection with     the phrase "Hello World".      Any ASCII linefeed characters (\\n) in the inserted text are transformed     into unicode block separators, corresponding to insertBlock() calls.      \sa charFormat(), hasSelection() */
end_comment
begin_function
DECL|function|insertText
name|void
name|QTextCursor
operator|::
name|insertText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
init|=
name|charFormat
argument_list|()
decl_stmt|;
name|fmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectType
argument_list|)
expr_stmt|;
name|insertText
argument_list|(
name|text
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextCursor::insertText(const QString&text, const QTextCharFormat&format)     \overload      Inserts \a text at the current position with the given \a format. */
end_comment
begin_function
DECL|function|insertText
name|void
name|QTextCursor
operator|::
name|insertText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|_format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|_format
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|QTextCharFormat
name|format
init|=
name|_format
decl_stmt|;
name|format
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|bool
name|hasEditBlock
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|anchor
operator|!=
name|d
operator|->
name|position
condition|)
block|{
name|hasEditBlock
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QTextFormatCollection
modifier|*
name|formats
init|=
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|int
name|formatIdx
init|=
name|formats
operator|->
name|indexForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|formats
operator|->
name|format
argument_list|(
name|formatIdx
argument_list|)
operator|.
name|isCharFormat
argument_list|()
argument_list|)
expr_stmt|;
name|QTextBlockFormat
name|blockFmt
init|=
name|blockFormat
argument_list|()
decl_stmt|;
name|int
name|textStart
init|=
name|d
operator|->
name|priv
operator|->
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|blockStart
init|=
literal|0
decl_stmt|;
name|d
operator|->
name|priv
operator|->
name|text
operator|+=
name|text
expr_stmt|;
name|int
name|textEnd
init|=
name|d
operator|->
name|priv
operator|->
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|text
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|int
name|blockEnd
init|=
name|i
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|text
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|ch
operator|=
name|text
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|||
name|ch
operator|==
name|QChar
operator|::
name|ParagraphSeparator
operator|||
name|ch
operator|==
name|QTextBeginningOfFrame
operator|||
name|ch
operator|==
name|QTextEndOfFrame
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hasEditBlock
condition|)
block|{
name|hasEditBlock
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blockEnd
operator|>
name|blockStart
condition|)
name|d
operator|->
name|priv
operator|->
name|insert
argument_list|(
name|d
operator|->
name|position
argument_list|,
name|textStart
operator|+
name|blockStart
argument_list|,
name|blockEnd
operator|-
name|blockStart
argument_list|,
name|formatIdx
argument_list|)
expr_stmt|;
name|d
operator|->
name|insertBlock
argument_list|(
name|blockFmt
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|blockStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textStart
operator|+
name|blockStart
operator|<
name|textEnd
condition|)
name|d
operator|->
name|priv
operator|->
name|insert
argument_list|(
name|d
operator|->
name|position
argument_list|,
name|textStart
operator|+
name|blockStart
argument_list|,
name|textEnd
operator|-
name|textStart
operator|-
name|blockStart
argument_list|,
name|formatIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasEditBlock
condition|)
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If there is no selected text, deletes the character \e at the     current cursor position; otherwise deletes the selected text.      \sa deletePreviousChar(), hasSelection(), clearSelection() */
end_comment
begin_function
DECL|function|deleteChar
name|void
name|QTextCursor
operator|::
name|deleteChar
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|position
operator|!=
name|d
operator|->
name|anchor
condition|)
block|{
name|removeSelectedText
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|canDelete
argument_list|(
name|d
operator|->
name|position
argument_list|)
condition|)
return|return;
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|priv
operator|->
name|nextCursorPosition
argument_list|(
name|d
operator|->
name|anchor
argument_list|,
name|QTextLayout
operator|::
name|SkipCharacters
argument_list|)
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If there is no selected text, deletes the character \e before the     current cursor position; otherwise deletes the selected text.      \sa deleteChar(), hasSelection(), clearSelection() */
end_comment
begin_function
DECL|function|deletePreviousChar
name|void
name|QTextCursor
operator|::
name|deletePreviousChar
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|position
operator|!=
name|d
operator|->
name|anchor
condition|)
block|{
name|removeSelectedText
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|anchor
operator|<
literal|1
operator|||
operator|!
name|d
operator|->
name|canDelete
argument_list|(
name|d
operator|->
name|anchor
operator|-
literal|1
argument_list|)
condition|)
return|return;
name|d
operator|->
name|anchor
operator|--
expr_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|fragIt
init|=
name|d
operator|->
name|priv
operator|->
name|find
argument_list|(
name|d
operator|->
name|anchor
argument_list|)
decl_stmt|;
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|fragIt
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|fpos
init|=
name|fragIt
operator|.
name|position
argument_list|()
decl_stmt|;
name|QChar
name|uc
init|=
name|d
operator|->
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|d
operator|->
name|anchor
operator|-
name|fpos
operator|+
name|frag
operator|->
name|stringPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|anchor
operator|>
name|fpos
operator|&&
name|uc
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
comment|// second half of a surrogate, check if we have the first half as well,
comment|// if yes delete both at once
name|uc
operator|=
name|d
operator|->
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|d
operator|->
name|anchor
operator|-
literal|1
operator|-
name|fpos
operator|+
name|frag
operator|->
name|stringPosition
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|.
name|isHighSurrogate
argument_list|()
condition|)
operator|--
name|d
operator|->
name|anchor
expr_stmt|;
block|}
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Selects text in the document according to the given \a selection. */
end_comment
begin_function
DECL|function|select
name|void
name|QTextCursor
operator|::
name|select
parameter_list|(
name|SelectionType
name|selection
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|clearSelection
argument_list|()
expr_stmt|;
specifier|const
name|QTextBlock
name|block
init|=
name|d
operator|->
name|block
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|selection
condition|)
block|{
case|case
name|LineUnderCursor
case|:
name|movePosition
argument_list|(
name|StartOfLine
argument_list|)
expr_stmt|;
name|movePosition
argument_list|(
name|EndOfLine
argument_list|,
name|KeepAnchor
argument_list|)
expr_stmt|;
break|break;
case|case
name|WordUnderCursor
case|:
name|movePosition
argument_list|(
name|StartOfWord
argument_list|)
expr_stmt|;
name|movePosition
argument_list|(
name|EndOfWord
argument_list|,
name|KeepAnchor
argument_list|)
expr_stmt|;
break|break;
case|case
name|BlockUnderCursor
case|:
if|if
condition|(
name|block
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
comment|// no content
break|break;
name|movePosition
argument_list|(
name|StartOfBlock
argument_list|)
expr_stmt|;
comment|// also select the paragraph separator
if|if
condition|(
name|movePosition
argument_list|(
name|PreviousBlock
argument_list|)
condition|)
block|{
name|movePosition
argument_list|(
name|EndOfBlock
argument_list|)
expr_stmt|;
name|movePosition
argument_list|(
name|NextBlock
argument_list|,
name|KeepAnchor
argument_list|)
expr_stmt|;
block|}
name|movePosition
argument_list|(
name|EndOfBlock
argument_list|,
name|KeepAnchor
argument_list|)
expr_stmt|;
break|break;
case|case
name|Document
case|:
name|movePosition
argument_list|(
name|Start
argument_list|)
expr_stmt|;
name|movePosition
argument_list|(
name|End
argument_list|,
name|KeepAnchor
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the cursor contains a selection; otherwise returns \c false. */
end_comment
begin_function
DECL|function|hasSelection
name|bool
name|QTextCursor
operator|::
name|hasSelection
parameter_list|()
specifier|const
block|{
return|return
operator|!
operator|!
name|d
operator|&&
name|d
operator|->
name|position
operator|!=
name|d
operator|->
name|anchor
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the cursor contains a selection that is not simply a     range from selectionStart() to selectionEnd(); otherwise returns \c false.      Complex selections are ones that span at least two cells in a table;     their extent is specified by selectedTableCells(). */
end_comment
begin_function
DECL|function|hasComplexSelection
name|bool
name|QTextCursor
operator|::
name|hasComplexSelection
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|complexSelectionTable
argument_list|()
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     If the selection spans over table cells, \a firstRow is populated     with the number of the first row in the selection, \a firstColumn     with the number of the first column in the selection, and \a     numRows and \a numColumns with the number of rows and columns in     the selection. If the selection does not span any table cells the     results are harmless but undefined. */
end_comment
begin_function
DECL|function|selectedTableCells
name|void
name|QTextCursor
operator|::
name|selectedTableCells
parameter_list|(
name|int
modifier|*
name|firstRow
parameter_list|,
name|int
modifier|*
name|numRows
parameter_list|,
name|int
modifier|*
name|firstColumn
parameter_list|,
name|int
modifier|*
name|numColumns
parameter_list|)
specifier|const
block|{
operator|*
name|firstRow
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|firstColumn
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|numRows
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|numColumns
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|anchor
condition|)
return|return;
name|d
operator|->
name|selectedTableCells
argument_list|(
name|firstRow
argument_list|,
name|numRows
argument_list|,
name|firstColumn
argument_list|,
name|numColumns
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the current selection by setting the anchor to the cursor position.      Note that it does \b{not} delete the text of the selection.      \sa removeSelectedText(), hasSelection() */
end_comment
begin_function
DECL|function|clearSelection
name|void
name|QTextCursor
operator|::
name|clearSelection
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
expr_stmt|;
name|d
operator|->
name|currentCharFormat
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If there is a selection, its content is deleted; otherwise does     nothing.      \sa hasSelection() */
end_comment
begin_function
DECL|function|removeSelectedText
name|void
name|QTextCursor
operator|::
name|removeSelectedText
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
operator|||
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|anchor
condition|)
return|return;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the start of the selection or position() if the     cursor doesn't have a selection.      \sa selectionEnd(), position(), anchor() */
end_comment
begin_function
DECL|function|selectionStart
name|int
name|QTextCursor
operator|::
name|selectionStart
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|qMin
argument_list|(
name|d
operator|->
name|position
argument_list|,
name|d
operator|->
name|adjusted_anchor
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the end of the selection or position() if the cursor     doesn't have a selection.      \sa selectionStart(), position(), anchor() */
end_comment
begin_function
DECL|function|selectionEnd
name|int
name|QTextCursor
operator|::
name|selectionEnd
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|qMax
argument_list|(
name|d
operator|->
name|position
argument_list|,
name|d
operator|->
name|adjusted_anchor
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getText
specifier|static
name|void
name|getText
parameter_list|(
name|QString
modifier|&
name|text
parameter_list|,
name|QTextDocumentPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QString
modifier|&
name|docText
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|end
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|fragIt
init|=
name|priv
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|fragIt
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|const
name|int
name|offsetInFragment
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
name|fragIt
operator|.
name|position
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|qMin
argument_list|(
name|int
argument_list|(
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
operator|-
name|offsetInFragment
argument_list|)
argument_list|,
name|end
operator|-
name|pos
argument_list|)
decl_stmt|;
name|text
operator|+=
name|QString
argument_list|(
name|docText
operator|.
name|constData
argument_list|()
operator|+
name|frag
operator|->
name|stringPosition
operator|+
name|offsetInFragment
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the current selection's text (which may be empty). This     only returns the text, with no rich text formatting information.     If you want a document fragment (i.e. formatted rich text) use     selection() instead.      \note If the selection obtained from an editor spans a line break,     the text will contain a Unicode U+2029 paragraph separator character     instead of a newline \c{\n} character. Use QString::replace() to     replace these characters with newlines. */
end_comment
begin_function
DECL|function|selectedText
name|QString
name|QTextCursor
operator|::
name|selectedText
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
operator|||
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|anchor
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|QString
name|docText
init|=
name|d
operator|->
name|priv
operator|->
name|buffer
argument_list|()
decl_stmt|;
name|QString
name|text
decl_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|d
operator|->
name|complexSelectionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|int
name|row_start
decl_stmt|,
name|col_start
decl_stmt|,
name|num_rows
decl_stmt|,
name|num_cols
decl_stmt|;
name|selectedTableCells
argument_list|(
operator|&
name|row_start
argument_list|,
operator|&
name|num_rows
argument_list|,
operator|&
name|col_start
argument_list|,
operator|&
name|num_cols
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|row_start
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row_start
init|;
name|r
operator|<
name|row_start
operator|+
name|num_rows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|col_start
init|;
name|c
operator|<
name|col_start
operator|+
name|num_cols
condition|;
operator|++
name|c
control|)
block|{
name|QTextTableCell
name|cell
init|=
name|table
operator|->
name|cellAt
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|int
name|rspan
init|=
name|cell
operator|.
name|rowSpan
argument_list|()
decl_stmt|;
name|int
name|cspan
init|=
name|cell
operator|.
name|columnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|rspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cr
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|cr
operator|!=
name|r
condition|)
continue|continue;
block|}
if|if
condition|(
name|cspan
operator|!=
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|cell
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|!=
name|c
condition|)
continue|continue;
block|}
name|getText
argument_list|(
name|text
argument_list|,
name|d
operator|->
name|priv
argument_list|,
name|docText
argument_list|,
name|cell
operator|.
name|firstPosition
argument_list|()
argument_list|,
name|cell
operator|.
name|lastPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|getText
argument_list|(
name|text
argument_list|,
name|d
operator|->
name|priv
argument_list|,
name|docText
argument_list|,
name|selectionStart
argument_list|()
argument_list|,
name|selectionEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current selection (which may be empty) with all its     formatting information. If you just want the selected text (i.e.     plain text) use selectedText() instead.      \note Unlike QTextDocumentFragment::toPlainText(),     selectedText() may include special unicode characters such as     QChar::ParagraphSeparator.      \sa QTextDocumentFragment::toPlainText() */
end_comment
begin_function
DECL|function|selection
name|QTextDocumentFragment
name|QTextCursor
operator|::
name|selection
parameter_list|()
specifier|const
block|{
return|return
name|QTextDocumentFragment
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the block that contains the cursor. */
end_comment
begin_function
DECL|function|block
name|QTextBlock
name|QTextCursor
operator|::
name|block
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
name|QTextBlock
argument_list|()
return|;
return|return
name|d
operator|->
name|block
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the block format of the block the cursor is in.      \sa setBlockFormat(), charFormat()  */
end_comment
begin_function
DECL|function|blockFormat
name|QTextBlockFormat
name|QTextCursor
operator|::
name|blockFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
name|QTextBlockFormat
argument_list|()
return|;
return|return
name|d
operator|->
name|block
argument_list|()
operator|.
name|blockFormat
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the block format of the current block (or all blocks that     are contained in the selection) to \a format.      \sa blockFormat(), mergeBlockFormat() */
end_comment
begin_function
DECL|function|setBlockFormat
name|void
name|QTextCursor
operator|::
name|setBlockFormat
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|setBlockFormat
argument_list|(
name|format
argument_list|,
name|QTextDocumentPrivate
operator|::
name|SetFormat
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Modifies the block format of the current block (or all blocks that     are contained in the selection) with the block format specified by     \a modifier.      \sa setBlockFormat(), blockFormat() */
end_comment
begin_function
DECL|function|mergeBlockFormat
name|void
name|QTextCursor
operator|::
name|mergeBlockFormat
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|modifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|setBlockFormat
argument_list|(
name|modifier
argument_list|,
name|QTextDocumentPrivate
operator|::
name|MergeFormat
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the block character format of the block the cursor is in.      The block char format is the format used when inserting text at the     beginning of an empty block.      \sa setBlockCharFormat()  */
end_comment
begin_function
DECL|function|blockCharFormat
name|QTextCharFormat
name|QTextCursor
operator|::
name|blockCharFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
name|QTextCharFormat
argument_list|()
return|;
return|return
name|d
operator|->
name|block
argument_list|()
operator|.
name|charFormat
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the block char format of the current block (or all blocks that     are contained in the selection) to \a format.      \sa blockCharFormat() */
end_comment
begin_function
DECL|function|setBlockCharFormat
name|void
name|QTextCursor
operator|::
name|setBlockCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|setBlockCharFormat
argument_list|(
name|format
argument_list|,
name|QTextDocumentPrivate
operator|::
name|SetFormatAndPreserveObjectIndices
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Modifies the block char format of the current block (or all blocks that     are contained in the selection) with the block format specified by     \a modifier.      \sa setBlockCharFormat() */
end_comment
begin_function
DECL|function|mergeBlockCharFormat
name|void
name|QTextCursor
operator|::
name|mergeBlockCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|modifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|setBlockCharFormat
argument_list|(
name|modifier
argument_list|,
name|QTextDocumentPrivate
operator|::
name|MergeFormat
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the format of the character immediately before the cursor     position(). If the cursor is positioned at the beginning of a text     block that is not empty then the format of the character     immediately after the cursor is returned.      \sa insertText(), blockFormat()  */
end_comment
begin_function
DECL|function|charFormat
name|QTextCharFormat
name|QTextCursor
operator|::
name|charFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
name|QTextCharFormat
argument_list|()
return|;
name|int
name|idx
init|=
name|d
operator|->
name|currentCharFormat
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|QTextBlock
name|block
init|=
name|d
operator|->
name|block
argument_list|()
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|position
operator|==
name|block
operator|.
name|position
argument_list|()
operator|&&
name|block
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|pos
operator|=
name|d
operator|->
name|position
expr_stmt|;
else|else
name|pos
operator|=
name|d
operator|->
name|position
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|idx
operator|=
name|d
operator|->
name|priv
operator|->
name|blockCharFormatIndex
argument_list|(
name|d
operator|->
name|priv
operator|->
name|blockMap
argument_list|()
operator|.
name|firstNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|<
name|d
operator|->
name|priv
operator|->
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
init|=
name|d
operator|->
name|priv
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|it
operator|.
name|atEnd
argument_list|()
argument_list|)
expr_stmt|;
name|idx
operator|=
name|it
operator|.
name|value
argument_list|()
operator|->
name|format
expr_stmt|;
block|}
block|}
name|QTextCharFormat
name|cfmt
init|=
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
operator|->
name|charFormat
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|cfmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|cfmt
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cfmt
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the cursor's current character format to the given \a     format. If the cursor has a selection, the given \a format is     applied to the current selection.      \sa hasSelection(), mergeCharFormat() */
end_comment
begin_function
DECL|function|setCharFormat
name|void
name|QTextCursor
operator|::
name|setCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|anchor
condition|)
block|{
name|d
operator|->
name|currentCharFormat
operator|=
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setCharFormat
argument_list|(
name|format
argument_list|,
name|QTextDocumentPrivate
operator|::
name|SetFormatAndPreserveObjectIndices
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Merges the cursor's current character format with the properties     described by format \a modifier. If the cursor has a selection,     this function applies all the properties set in \a modifier to all     the character formats that are part of the selection.      \sa hasSelection(), setCharFormat() */
end_comment
begin_function
DECL|function|mergeCharFormat
name|void
name|QTextCursor
operator|::
name|mergeCharFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|modifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|anchor
condition|)
block|{
name|QTextCharFormat
name|format
init|=
name|charFormat
argument_list|()
decl_stmt|;
name|format
operator|.
name|merge
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|currentCharFormat
operator|=
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|format
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|setCharFormat
argument_list|(
name|modifier
argument_list|,
name|QTextDocumentPrivate
operator|::
name|MergeFormat
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the cursor is at the start of a block; otherwise     returns \c false.      \sa atBlockEnd(), atStart() */
end_comment
begin_function
DECL|function|atBlockStart
name|bool
name|QTextCursor
operator|::
name|atBlockStart
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|block
argument_list|()
operator|.
name|position
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the cursor is at the end of a block; otherwise     returns \c false.      \sa atBlockStart(), atEnd() */
end_comment
begin_function
DECL|function|atBlockEnd
name|bool
name|QTextCursor
operator|::
name|atBlockEnd
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|block
argument_list|()
operator|.
name|position
argument_list|()
operator|+
name|d
operator|->
name|block
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the cursor is at the start of the document;     otherwise returns \c false.      \sa atBlockStart(), atEnd() */
end_comment
begin_function
DECL|function|atStart
name|bool
name|QTextCursor
operator|::
name|atStart
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|position
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns \c true if the cursor is at the end of the document;     otherwise returns \c false.      \sa atStart(), atBlockEnd() */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QTextCursor
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|position
operator|==
name|d
operator|->
name|priv
operator|->
name|length
argument_list|()
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts a new empty block at the cursor position() with the     current blockFormat() and charFormat().      \sa setBlockFormat() */
end_comment
begin_function
DECL|function|insertBlock
name|void
name|QTextCursor
operator|::
name|insertBlock
parameter_list|()
block|{
name|insertBlock
argument_list|(
name|blockFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Inserts a new empty block at the cursor position() with block     format \a format and the current charFormat() as block char format.      \sa setBlockFormat() */
end_comment
begin_function
DECL|function|insertBlock
name|void
name|QTextCursor
operator|::
name|insertBlock
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|)
block|{
name|QTextCharFormat
name|charFmt
init|=
name|charFormat
argument_list|()
decl_stmt|;
name|charFmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectType
argument_list|)
expr_stmt|;
name|insertBlock
argument_list|(
name|format
argument_list|,
name|charFmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextCursor::insertBlock(const QTextBlockFormat&format, const QTextCharFormat&charFormat)     \overload      Inserts a new empty block at the cursor position() with block     format \a format and \a charFormat as block char format.      \sa setBlockFormat() */
end_comment
begin_function
DECL|function|insertBlock
name|void
name|QTextCursor
operator|::
name|insertBlock
parameter_list|(
specifier|const
name|QTextBlockFormat
modifier|&
name|format
parameter_list|,
specifier|const
name|QTextCharFormat
modifier|&
name|_charFormat
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|QTextCharFormat
name|charFormat
init|=
name|_charFormat
decl_stmt|;
name|charFormat
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
name|d
operator|->
name|insertBlock
argument_list|(
name|format
argument_list|,
name|charFormat
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|setX
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts a new block at the current position and makes it the first     list item of a newly created list with the given \a format. Returns     the created list.      \sa currentList(), createList(), insertBlock()  */
end_comment
begin_function
DECL|function|insertList
name|QTextList
modifier|*
name|QTextCursor
operator|::
name|insertList
parameter_list|(
specifier|const
name|QTextListFormat
modifier|&
name|format
parameter_list|)
block|{
name|insertBlock
argument_list|()
expr_stmt|;
return|return
name|createList
argument_list|(
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Inserts a new block at the current position and makes it the first     list item of a newly created list with the given \a style. Returns     the created list.      \sa currentList(), createList(), insertBlock()  */
end_comment
begin_function
DECL|function|insertList
name|QTextList
modifier|*
name|QTextCursor
operator|::
name|insertList
parameter_list|(
name|QTextListFormat
operator|::
name|Style
name|style
parameter_list|)
block|{
name|insertBlock
argument_list|()
expr_stmt|;
return|return
name|createList
argument_list|(
name|style
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates and returns a new list with the given \a format, and makes the     current paragraph the cursor is in the first list item.      \sa insertList(), currentList()  */
end_comment
begin_function
DECL|function|createList
name|QTextList
modifier|*
name|QTextCursor
operator|::
name|createList
parameter_list|(
specifier|const
name|QTextListFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
name|QTextList
modifier|*
name|list
init|=
cast|static_cast
argument_list|<
name|QTextList
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|priv
operator|->
name|createObject
argument_list|(
name|format
argument_list|)
argument_list|)
decl_stmt|;
name|QTextBlockFormat
name|modifier
decl_stmt|;
name|modifier
operator|.
name|setObjectIndex
argument_list|(
name|list
operator|->
name|objectIndex
argument_list|()
argument_list|)
expr_stmt|;
name|mergeBlockFormat
argument_list|(
name|modifier
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Creates and returns a new list with the given \a style, making the     cursor's current paragraph the first list item.      The style to be used is defined by the QTextListFormat::Style enum.      \sa insertList(), currentList()  */
end_comment
begin_function
DECL|function|createList
name|QTextList
modifier|*
name|QTextCursor
operator|::
name|createList
parameter_list|(
name|QTextListFormat
operator|::
name|Style
name|style
parameter_list|)
block|{
name|QTextListFormat
name|fmt
decl_stmt|;
name|fmt
operator|.
name|setStyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
return|return
name|createList
argument_list|(
name|fmt
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current list if the cursor position() is inside a     block that is part of a list; otherwise returns 0.      \sa insertList(), createList()  */
end_comment
begin_function
DECL|function|currentList
name|QTextList
modifier|*
name|QTextCursor
operator|::
name|currentList
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
name|QTextBlockFormat
name|b
init|=
name|blockFormat
argument_list|()
decl_stmt|;
name|QTextObject
modifier|*
name|o
init|=
name|d
operator|->
name|priv
operator|->
name|objectForFormat
argument_list|(
name|b
argument_list|)
decl_stmt|;
return|return
name|qobject_cast
argument_list|<
name|QTextList
operator|*
argument_list|>
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextTable *QTextCursor::insertTable(int rows, int columns)      \overload      Creates a new table with the given number of \a rows and \a columns,     inserts it at the current cursor position() in the document, and returns     the table object. The cursor is moved to the beginning of the first cell.      There must be at least one row and one column in the table.      \sa currentTable()  */
end_comment
begin_function
DECL|function|insertTable
name|QTextTable
modifier|*
name|QTextCursor
operator|::
name|insertTable
parameter_list|(
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
return|return
name|insertTable
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|,
name|QTextTableFormat
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextTable *QTextCursor::insertTable(int rows, int columns, const QTextTableFormat&format)      Creates a new table with the given number of \a rows and \a columns     in the specified \a format, inserts it at the current cursor position()     in the document, and returns the table object. The cursor is moved to     the beginning of the first cell.      There must be at least one row and one column in the table.      \sa currentTable() */
end_comment
begin_function
DECL|function|insertTable
name|QTextTable
modifier|*
name|QTextCursor
operator|::
name|insertTable
parameter_list|(
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
specifier|const
name|QTextTableFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
operator|||
name|rows
operator|==
literal|0
operator|||
name|cols
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|int
name|pos
init|=
name|d
operator|->
name|position
decl_stmt|;
name|QTextTable
modifier|*
name|t
init|=
name|QTextTablePrivate
operator|::
name|createTable
argument_list|(
name|d
operator|->
name|priv
argument_list|,
name|d
operator|->
name|position
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|d
operator|->
name|setPosition
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// ##### what should we do if we have a selection?
name|d
operator|->
name|anchor
operator|=
name|d
operator|->
name|position
expr_stmt|;
name|d
operator|->
name|adjusted_anchor
operator|=
name|d
operator|->
name|anchor
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the current table if the cursor position()     is inside a block that is part of a table; otherwise returns 0.      \sa insertTable() */
end_comment
begin_function
DECL|function|currentTable
name|QTextTable
modifier|*
name|QTextCursor
operator|::
name|currentTable
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
name|QTextFrame
modifier|*
name|frame
init|=
name|d
operator|->
name|priv
operator|->
name|frameAt
argument_list|(
name|d
operator|->
name|position
argument_list|)
decl_stmt|;
while|while
condition|(
name|frame
condition|)
block|{
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
condition|)
return|return
name|table
return|;
name|frame
operator|=
name|frame
operator|->
name|parentFrame
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts a frame with the given \a format at the current cursor position(),     moves the cursor position() inside the frame, and returns the frame.      If the cursor holds a selection, the whole selection is moved inside the     frame.      \sa hasSelection() */
end_comment
begin_function
DECL|function|insertFrame
name|QTextFrame
modifier|*
name|QTextCursor
operator|::
name|insertFrame
parameter_list|(
specifier|const
name|QTextFrameFormat
modifier|&
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|priv
operator|->
name|insertFrame
argument_list|(
name|selectionStart
argument_list|()
argument_list|,
name|selectionEnd
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the current frame. Returns 0 if the cursor is invalid.      \sa insertFrame() */
end_comment
begin_function
DECL|function|currentFrame
name|QTextFrame
modifier|*
name|QTextCursor
operator|::
name|currentFrame
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|priv
operator|->
name|frameAt
argument_list|(
name|d
operator|->
name|position
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the text \a fragment at the current position(). */
end_comment
begin_function
DECL|function|insertFragment
name|void
name|QTextCursor
operator|::
name|insertFragment
parameter_list|(
specifier|const
name|QTextDocumentFragment
modifier|&
name|fragment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
operator|||
name|fragment
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
name|fragment
operator|.
name|d
operator|->
name|insert
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|fragment
operator|.
name|d
operator|&&
name|fragment
operator|.
name|d
operator|->
name|doc
condition|)
name|d
operator|->
name|priv
operator|->
name|mergeCachedResources
argument_list|(
name|fragment
operator|.
name|d
operator|->
name|doc
operator|->
name|docHandle
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Inserts the text \a html at the current position(). The text is interpreted as     HTML.      \note When using this function with a style sheet, the style sheet will     only apply to the current block in the document. In order to apply a style     sheet throughout a document, use QTextDocument::setDefaultStyleSheet()     instead. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTHTMLPARSER
end_ifndef
begin_function
DECL|function|insertHtml
name|void
name|QTextCursor
operator|::
name|insertHtml
parameter_list|(
specifier|const
name|QString
modifier|&
name|html
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|QTextDocumentFragment
name|fragment
init|=
name|QTextDocumentFragment
operator|::
name|fromHtml
argument_list|(
name|html
argument_list|,
name|d
operator|->
name|priv
operator|->
name|document
argument_list|()
argument_list|)
decl_stmt|;
name|insertFragment
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTHTMLPARSER
end_comment
begin_comment
comment|/*!     \overload     \since 4.2      Inserts the image defined by the given \a format at the cursor's current position     with the specified \a alignment.      \sa position() */
end_comment
begin_function
DECL|function|insertImage
name|void
name|QTextCursor
operator|::
name|insertImage
parameter_list|(
specifier|const
name|QTextImageFormat
modifier|&
name|format
parameter_list|,
name|QTextFrameFormat
operator|::
name|Position
name|alignment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|QTextFrameFormat
name|ffmt
decl_stmt|;
name|ffmt
operator|.
name|setPosition
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|QTextObject
modifier|*
name|obj
init|=
name|d
operator|->
name|priv
operator|->
name|createObject
argument_list|(
name|ffmt
argument_list|)
decl_stmt|;
name|QTextImageFormat
name|fmt
init|=
name|format
decl_stmt|;
name|fmt
operator|.
name|setObjectIndex
argument_list|(
name|obj
operator|->
name|objectIndex
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|d
operator|->
name|remove
argument_list|()
expr_stmt|;
specifier|const
name|int
name|idx
init|=
name|d
operator|->
name|priv
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|d
operator|->
name|priv
operator|->
name|insert
argument_list|(
name|d
operator|->
name|position
argument_list|,
name|QString
argument_list|(
name|QChar
argument_list|(
name|QChar
operator|::
name|ObjectReplacementCharacter
argument_list|)
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Inserts the image defined by \a format at the current position(). */
end_comment
begin_function
DECL|function|insertImage
name|void
name|QTextCursor
operator|::
name|insertImage
parameter_list|(
specifier|const
name|QTextImageFormat
modifier|&
name|format
parameter_list|)
block|{
name|insertText
argument_list|(
name|QString
argument_list|(
name|QChar
operator|::
name|ObjectReplacementCharacter
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Convenience method for inserting the image with the given \a name at the     current position().      \snippet code/src_gui_text_qtextcursor.cpp 1 */
end_comment
begin_function
DECL|function|insertImage
name|void
name|QTextCursor
operator|::
name|insertImage
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QTextImageFormat
name|format
decl_stmt|;
name|format
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|insertImage
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     \overload      Convenience function for inserting the given \a image with an optional     \a name at the current position(). */
end_comment
begin_function
DECL|function|insertImage
name|void
name|QTextCursor
operator|::
name|insertImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTextCursor::insertImage: attempt to add an invalid image"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|imageName
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
name|imageName
operator|=
name|QString
operator|::
name|number
argument_list|(
name|image
operator|.
name|cacheKey
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|document
argument_list|()
operator|->
name|addResource
argument_list|(
name|QTextDocument
operator|::
name|ImageResource
argument_list|,
name|QUrl
argument_list|(
name|imageName
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|QTextImageFormat
name|format
decl_stmt|;
name|format
operator|.
name|setName
argument_list|(
name|imageName
argument_list|)
expr_stmt|;
name|insertImage
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator!=(const QTextCursor&other) const      Returns \c true if the \a other cursor is at a different position in     the document as this cursor; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QTextCursor
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
return|return
operator|!
name|operator
name|==
argument_list|(
name|rhs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator<(const QTextCursor&other) const      Returns \c true if the \a other cursor is positioned later in the     document than this cursor; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QTextCursor
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|!
operator|!
name|rhs
operator|.
name|d
return|;
if|if
condition|(
operator|!
name|rhs
operator|.
name|d
condition|)
return|return
literal|false
return|;
name|Q_ASSERT_X
argument_list|(
name|d
operator|->
name|priv
operator|==
name|rhs
operator|.
name|d
operator|->
name|priv
argument_list|,
literal|"QTextCursor::operator<"
argument_list|,
literal|"cannot compare cursors attached to different documents"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|position
operator|<
name|rhs
operator|.
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator<=(const QTextCursor&other) const      Returns \c true if the \a other cursor is positioned later or at the     same position in the document as this cursor; otherwise returns     false. */
end_comment
begin_function
DECL|function|operator <=
name|bool
name|QTextCursor
operator|::
name|operator
name|<=
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|rhs
operator|.
name|d
condition|)
return|return
literal|false
return|;
name|Q_ASSERT_X
argument_list|(
name|d
operator|->
name|priv
operator|==
name|rhs
operator|.
name|d
operator|->
name|priv
argument_list|,
literal|"QTextCursor::operator<="
argument_list|,
literal|"cannot compare cursors attached to different documents"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|position
operator|<=
name|rhs
operator|.
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator==(const QTextCursor&other) const      Returns \c true if the \a other cursor is at the same position in the     document as this cursor; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QTextCursor
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|!
name|rhs
operator|.
name|d
return|;
if|if
condition|(
operator|!
name|rhs
operator|.
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|position
operator|==
name|rhs
operator|.
name|d
operator|->
name|position
operator|&&
name|d
operator|->
name|priv
operator|==
name|rhs
operator|.
name|d
operator|->
name|priv
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator>=(const QTextCursor&other) const      Returns \c true if the \a other cursor is positioned earlier or at the     same position in the document as this cursor; otherwise returns     false. */
end_comment
begin_function
DECL|function|operator >=
name|bool
name|QTextCursor
operator|::
name|operator
name|>=
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|rhs
operator|.
name|d
condition|)
return|return
literal|true
return|;
name|Q_ASSERT_X
argument_list|(
name|d
operator|->
name|priv
operator|==
name|rhs
operator|.
name|d
operator|->
name|priv
argument_list|,
literal|"QTextCursor::operator>="
argument_list|,
literal|"cannot compare cursors attached to different documents"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|position
operator|>=
name|rhs
operator|.
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextCursor::operator>(const QTextCursor&other) const      Returns \c true if the \a other cursor is positioned earlier in the     document than this cursor; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator >
name|bool
name|QTextCursor
operator|::
name|operator
name|>
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|rhs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|rhs
operator|.
name|d
condition|)
return|return
literal|true
return|;
name|Q_ASSERT_X
argument_list|(
name|d
operator|->
name|priv
operator|==
name|rhs
operator|.
name|d
operator|->
name|priv
argument_list|,
literal|"QTextCursor::operator>"
argument_list|,
literal|"cannot compare cursors attached to different documents"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|position
operator|>
name|rhs
operator|.
name|d
operator|->
name|position
return|;
block|}
end_function
begin_comment
comment|/*!     Indicates the start of a block of editing operations on the     document that should appear as a single operation from an     undo/redo point of view.      For example:      \snippet code/src_gui_text_qtextcursor.cpp 2      The call to undo() will cause both insertions to be undone,     causing both "World" and "Hello" to be removed.      It is possible to nest calls to beginEditBlock and endEditBlock. The     top-most pair will determine the scope of the undo/redo operation.      \sa endEditBlock()  */
end_comment
begin_function
DECL|function|beginEditBlock
name|void
name|QTextCursor
operator|::
name|beginEditBlock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|priv
operator|->
name|editBlock
operator|==
literal|0
condition|)
comment|// we are the initial edit block, store current cursor position for undo
name|d
operator|->
name|priv
operator|->
name|editBlockCursorPosition
operator|=
name|d
operator|->
name|position
expr_stmt|;
name|d
operator|->
name|priv
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Like beginEditBlock() indicates the start of a block of editing operations     that should appear as a single operation for undo/redo. However unlike     beginEditBlock() it does not start a new block but reverses the previous call to     endEditBlock() and therefore makes following operations part of the previous edit block created.      For example:      \snippet code/src_gui_text_qtextcursor.cpp 3      The call to undo() will cause all three insertions to be undone.      \sa beginEditBlock(), endEditBlock()  */
end_comment
begin_function
DECL|function|joinPreviousEditBlock
name|void
name|QTextCursor
operator|::
name|joinPreviousEditBlock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|priv
operator|->
name|joinPreviousEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Indicates the end of a block of editing operations on the document     that should appear as a single operation from an undo/redo point     of view.      \sa beginEditBlock()  */
end_comment
begin_function
DECL|function|endEditBlock
name|void
name|QTextCursor
operator|::
name|endEditBlock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return;
name|d
operator|->
name|priv
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this cursor and \a other are copies of each other, i.e.     one of them was created as a copy of the other and neither has moved since.     This is much stricter than equality.      \sa operator=(), operator==() */
end_comment
begin_function
DECL|function|isCopyOf
name|bool
name|QTextCursor
operator|::
name|isCopyOf
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns the number of the block the cursor is in, or 0 if the cursor is invalid.      Note that this function only makes sense in documents without complex objects such     as tables or frames. */
end_comment
begin_function
DECL|function|blockNumber
name|int
name|QTextCursor
operator|::
name|blockNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|block
argument_list|()
operator|.
name|blockNumber
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2     Returns the position of the cursor within its containing line.      Note that this is the column number relative to a wrapped line,     not relative to the block (i.e. the paragraph).      You probably want to call positionInBlock() instead.      \sa positionInBlock() */
end_comment
begin_function
DECL|function|columnNumber
name|int
name|QTextCursor
operator|::
name|columnNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|priv
condition|)
return|return
literal|0
return|;
name|QTextBlock
name|block
init|=
name|d
operator|->
name|block
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|block
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
specifier|const
name|QTextLayout
modifier|*
name|layout
init|=
name|d
operator|->
name|blockLayout
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|const
name|int
name|relativePos
init|=
name|d
operator|->
name|position
operator|-
name|block
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|layout
operator|->
name|lineCount
argument_list|()
operator|==
literal|0
condition|)
return|return
name|relativePos
return|;
name|QTextLine
name|line
init|=
name|layout
operator|->
name|lineForTextPosition
argument_list|(
name|relativePos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|relativePos
operator|-
name|line
operator|.
name|textStart
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Returns the document this cursor is associated with. */
end_comment
begin_function
DECL|function|document
name|QTextDocument
modifier|*
name|QTextCursor
operator|::
name|document
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|priv
condition|)
return|return
name|d
operator|->
name|priv
operator|->
name|document
argument_list|()
return|;
return|return
literal|0
return|;
comment|// document went away
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
