begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextobject.h"
end_include
begin_include
include|#
directive|include
file|"qtextobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocument.h"
end_include
begin_include
include|#
directive|include
file|"qtextformat_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextdocument_p.h"
end_include
begin_include
include|#
directive|include
file|"qtextcursor.h"
end_include
begin_include
include|#
directive|include
file|"qtextlist.h"
end_include
begin_include
include|#
directive|include
file|"qabstracttextdocumentlayout.h"
end_include
begin_include
include|#
directive|include
file|"qtextengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// ### DOC: We ought to explain the CONCEPT of objectIndexes if
end_comment
begin_comment
comment|// relevant to the public API
end_comment
begin_comment
comment|/*!     \class QTextObject     \reentrant      \brief The QTextObject class is a base class for different kinds     of objects that can group parts of a QTextDocument together.     \inmodule QtGui      \ingroup richtext-processing      The common grouping text objects are lists (QTextList), frames     (QTextFrame), and tables (QTextTable). A text object has an     associated format() and document().      There are essentially two kinds of text objects: those that are used     with blocks (block formats), and those that are used with characters     (character formats). The first kind are derived from QTextBlockGroup,     and the second kind from QTextFrame.      You rarely need to use this class directly. When creating custom text     objects, you will also need to reimplement QTextDocument::createObject()     which acts as a factory method for creating text objects.      \sa QTextDocument, {Text Object Example} */
end_comment
begin_comment
comment|/*!     \fn QTextObject::QTextObject(QTextDocument *document)      Creates a new QTextObject for the given \a document.      \warning This function should never be called directly, but only     from QTextDocument::createObject(). */
end_comment
begin_constructor
DECL|function|QTextObject
name|QTextObject
operator|::
name|QTextObject
parameter_list|(
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTextObjectPrivate
argument_list|(
name|doc
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \fn QTextObject::QTextObject(QTextObjectPrivate&p, QTextDocument *document)    \internal */
end_comment
begin_constructor
DECL|function|QTextObject
name|QTextObject
operator|::
name|QTextObject
parameter_list|(
name|QTextObjectPrivate
modifier|&
name|p
parameter_list|,
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the text object.      \warning Text objects are owned by the document, so you should     never destroy them yourself. */
end_comment
begin_destructor
DECL|function|~QTextObject
name|QTextObject
operator|::
name|~
name|QTextObject
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns the text object's format.      \sa setFormat(), document() */
end_comment
begin_function
DECL|function|format
name|QTextFormat
name|QTextObject
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pieceTable
operator|->
name|formatCollection
argument_list|()
operator|->
name|objectFormat
argument_list|(
name|d
operator|->
name|objectIndex
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the object's format in the document's internal     list of formats.      \sa QTextDocument::allFormats() */
end_comment
begin_function
DECL|function|formatIndex
name|int
name|QTextObject
operator|::
name|formatIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pieceTable
operator|->
name|formatCollection
argument_list|()
operator|->
name|objectFormatIndex
argument_list|(
name|d
operator|->
name|objectIndex
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the text object's \a format.      \sa format() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QTextObject
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QTextFormat
modifier|&
name|format
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextObject
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|d
operator|->
name|pieceTable
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|d
operator|->
name|pieceTable
operator|->
name|changeObjectFormat
argument_list|(
name|this
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the object index of this object. This can be used together with     QTextFormat::setObjectIndex(). */
end_comment
begin_function
DECL|function|objectIndex
name|int
name|QTextObject
operator|::
name|objectIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|objectIndex
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the document this object belongs to.      \sa format() */
end_comment
begin_function
DECL|function|document
name|QTextDocument
modifier|*
name|QTextObject
operator|::
name|document
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|docHandle
name|QTextDocumentPrivate
modifier|*
name|QTextObject
operator|::
name|docHandle
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QTextDocument
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
operator|->
name|docHandle
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextBlockGroup     \reentrant      \brief The QTextBlockGroup class provides a container for text blocks within     a QTextDocument.     \inmodule QtGui      \ingroup richtext-processing      Block groups can be used to organize blocks of text within a document.     They maintain an up-to-date list of the text blocks that belong to     them, even when text blocks are being edited.      Each group has a parent document which is specified when the group is     constructed.      Text blocks can be inserted into a group with blockInserted(), and removed     with blockRemoved(). If a block's format is changed, blockFormatChanged()     is called.      The list of blocks in the group is returned by blockList(). Note that the     blocks in the list are not necessarily adjacent elements in the document;     for example, the top-level items in a multi-level list will be separated     by the items in lower levels of the list.      \sa QTextBlock, QTextDocument */
end_comment
begin_function
DECL|function|markBlocksDirty
name|void
name|QTextBlockGroupPrivate
operator|::
name|markBlocksDirty
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTextBlock
modifier|&
name|block
init|=
name|blocks
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|pieceTable
operator|->
name|documentChange
argument_list|(
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|block
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QTextBlockGroup::QTextBlockGroup(QTextDocument *document)      Creates a new new block group for the given \a document.      \warning This function should only be called from     QTextDocument::createObject(). */
end_comment
begin_constructor
DECL|function|QTextBlockGroup
name|QTextBlockGroup
operator|::
name|QTextBlockGroup
parameter_list|(
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QTextObject
argument_list|(
operator|*
operator|new
name|QTextBlockGroupPrivate
argument_list|(
name|doc
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QTextBlockGroup
name|QTextBlockGroup
operator|::
name|QTextBlockGroup
parameter_list|(
name|QTextBlockGroupPrivate
modifier|&
name|p
parameter_list|,
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QTextObject
argument_list|(
name|p
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys this block group; the blocks are not deleted, they simply     don't belong to this block anymore. */
end_comment
begin_destructor
DECL|function|~QTextBlockGroup
name|QTextBlockGroup
operator|::
name|~
name|QTextBlockGroup
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|// ### DOC: Shouldn't this be insertBlock()?
end_comment
begin_comment
comment|/*!     Appends the given \a block to the end of the group.      \warning If you reimplement this function you must call the base     class implementation. */
end_comment
begin_function
DECL|function|blockInserted
name|void
name|QTextBlockGroup
operator|::
name|blockInserted
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBlockGroup
argument_list|)
expr_stmt|;
name|QTextBlockGroupPrivate
operator|::
name|BlockList
operator|::
name|Iterator
name|it
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|d
operator|->
name|blocks
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|blocks
operator|.
name|end
argument_list|()
argument_list|,
name|block
argument_list|)
decl_stmt|;
name|d
operator|->
name|blocks
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|d
operator|->
name|markBlocksDirty
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// ### DOC: Shouldn't this be removeBlock()?
end_comment
begin_comment
comment|/*!     Removes the given \a block from the group; the block itself is not     deleted, it simply isn't a member of this group anymore. */
end_comment
begin_function
DECL|function|blockRemoved
name|void
name|QTextBlockGroup
operator|::
name|blockRemoved
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
name|block
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextBlockGroup
argument_list|)
expr_stmt|;
name|d
operator|->
name|blocks
operator|.
name|removeAll
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|d
operator|->
name|markBlocksDirty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|blocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|document
argument_list|()
operator|->
name|docHandle
argument_list|()
operator|->
name|deleteObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_comment
comment|/*!     This function is called whenever the specified \a block of text is changed.     The text block is a member of this group.      The base class implementation does nothing. */
end_comment
begin_function
DECL|function|blockFormatChanged
name|void
name|QTextBlockGroup
operator|::
name|blockFormatChanged
parameter_list|(
specifier|const
name|QTextBlock
modifier|&
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     Returns a (possibly empty) list of all the blocks that are part of     the block group. */
end_comment
begin_function
DECL|function|blockList
name|QList
argument_list|<
name|QTextBlock
argument_list|>
name|QTextBlockGroup
operator|::
name|blockList
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextBlockGroup
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|blocks
return|;
block|}
end_function
begin_destructor
DECL|function|~QTextFrameLayoutData
name|QTextFrameLayoutData
operator|::
name|~
name|QTextFrameLayoutData
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \class QTextFrame     \reentrant      \brief The QTextFrame class represents a frame in a QTextDocument.     \inmodule QtGui      \ingroup richtext-processing      Text frames provide structure for the text in a document. They are used     as generic containers for other document elements.     Frames are usually created by using QTextCursor::insertFrame().      \omit     Each frame in a document consists of a frame start character,     QChar(0xFDD0), followed by the frame's contents, followed by a     frame end character, QChar(0xFDD1). The character formats of the     start and end character contain a reference to the frame object's     objectIndex.     \endomit      Frames can be used to create hierarchical structures in rich text documents.     Each document has a root frame (QTextDocument::rootFrame()), and each frame     beneath the root frame has a parent frame and a (possibly empty) list of     child frames. The parent frame can be found with parentFrame(), and the     childFrames() function provides a list of child frames.      Each frame contains at least one text block to enable text cursors to     insert new document elements within. As a result, the QTextFrame::iterator     class is used to traverse both the blocks and child frames within a given     frame. The first and last child elements in the frame can be found with     begin() and end().      A frame also has a format (specified using QTextFrameFormat) which can be set     with setFormat() and read with format().      Text cursors can be obtained that point to the first and last valid cursor     positions within a frame; use the firstCursorPosition() and     lastCursorPosition() functions for this. The frame's extent in the     document can be found with firstPosition() and lastPosition().      You can iterate over a frame's contents using the     QTextFrame::iterator class: this provides read-only access to its     internal list of text blocks and child frames.      \sa QTextCursor, QTextDocument */
end_comment
begin_comment
comment|/*!     \typedef QTextFrame::Iterator      Qt-style synonym for QTextFrame::iterator. */
end_comment
begin_comment
comment|/*!     \fn QTextFrame *QTextFrame::iterator::parentFrame() const      Returns the parent frame of the current frame.      \sa currentFrame(), QTextFrame::parentFrame() */
end_comment
begin_comment
comment|/*!     \fn bool QTextFrame::iterator::operator==(const iterator&other) const      Retuns true if the iterator is the same as the \a other iterator;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTextFrame::iterator::operator!=(const iterator&other) const      Retuns true if the iterator is different from the \a other iterator;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTextFrame::iterator QTextFrame::iterator::operator++(int)      The postfix ++ operator (\c{i++}) advances the iterator to the     next item in the text frame, and returns an iterator to the old item. */
end_comment
begin_comment
comment|/*!     \fn QTextFrame::iterator QTextFrame::iterator::operator--(int)      The postfix -- operator (\c{i--}) makes the preceding item in the     current frame, and returns an iterator to the old item. */
end_comment
begin_comment
comment|/*!     \fn void QTextFrame::setFrameFormat(const QTextFrameFormat&format)      Sets the frame's \a format.      \sa frameFormat() */
end_comment
begin_comment
comment|/*!     \fn QTextFrameFormat QTextFrame::frameFormat() const      Returns the frame's format.      \sa setFrameFormat() */
end_comment
begin_comment
comment|/*!     \fn QTextFrame::QTextFrame(QTextDocument *document)      Creates a new empty frame for the text \a document. */
end_comment
begin_constructor
DECL|function|QTextFrame
name|QTextFrame
operator|::
name|QTextFrame
parameter_list|(
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QTextObject
argument_list|(
operator|*
operator|new
name|QTextFramePrivate
argument_list|(
name|doc
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|// ### DOC: What does this do to child frames?
end_comment
begin_comment
comment|/*!     Destroys the frame, and removes it from the document's layout. */
end_comment
begin_destructor
DECL|function|~QTextFrame
name|QTextFrame
operator|::
name|~
name|QTextFrame
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTextFrame
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|layoutData
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QTextFrame
name|QTextFrame
operator|::
name|QTextFrame
parameter_list|(
name|QTextFramePrivate
modifier|&
name|p
parameter_list|,
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QTextObject
argument_list|(
name|p
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Returns a (possibly empty) list of the frame's child frames.      \sa parentFrame() */
end_comment
begin_function
DECL|function|childFrames
name|QList
argument_list|<
name|QTextFrame
modifier|*
argument_list|>
name|QTextFrame
operator|::
name|childFrames
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|childFrames
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the frame's parent frame. If the frame is the root frame of a     document, this will return 0.      \sa childFrames(), QTextDocument::rootFrame() */
end_comment
begin_function
DECL|function|parentFrame
name|QTextFrame
modifier|*
name|QTextFrame
operator|::
name|parentFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|parentFrame
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the first cursor position inside the frame.      \sa lastCursorPosition(), firstPosition(), lastPosition() */
end_comment
begin_function
DECL|function|firstCursorPosition
name|QTextCursor
name|QTextFrame
operator|::
name|firstCursorPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
return|return
name|QTextCursor
argument_list|(
name|d
operator|->
name|pieceTable
argument_list|,
name|firstPosition
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last cursor position inside the frame.      \sa firstCursorPosition(), firstPosition(), lastPosition() */
end_comment
begin_function
DECL|function|lastCursorPosition
name|QTextCursor
name|QTextFrame
operator|::
name|lastCursorPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
return|return
name|QTextCursor
argument_list|(
name|d
operator|->
name|pieceTable
argument_list|,
name|lastPosition
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the first document position inside the frame.      \sa lastPosition(), firstCursorPosition(), lastCursorPosition() */
end_comment
begin_function
DECL|function|firstPosition
name|int
name|QTextFrame
operator|::
name|firstPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fragment_start
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_start
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last document position inside the frame.      \sa firstPosition(), firstCursorPosition(), lastCursorPosition() */
end_comment
begin_function
DECL|function|lastPosition
name|int
name|QTextFrame
operator|::
name|lastPosition
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fragment_end
condition|)
return|return
name|d
operator|->
name|pieceTable
operator|->
name|length
argument_list|()
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_end
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|layoutData
name|QTextFrameLayoutData
modifier|*
name|QTextFrame
operator|::
name|layoutData
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextFrame
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|layoutData
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|setLayoutData
name|void
name|QTextFrame
operator|::
name|setLayoutData
parameter_list|(
name|QTextFrameLayoutData
modifier|*
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextFrame
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|layoutData
expr_stmt|;
name|d
operator|->
name|layoutData
operator|=
name|data
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fragmentAdded
name|void
name|QTextFramePrivate
operator|::
name|fragmentAdded
parameter_list|(
name|QChar
name|type
parameter_list|,
name|uint
name|fragment
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|QTextBeginningOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|fragment_start
argument_list|)
expr_stmt|;
name|fragment_start
operator|=
name|fragment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QTextEndOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|fragment_end
argument_list|)
expr_stmt|;
name|fragment_end
operator|=
name|fragment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QChar
operator|::
name|ObjectReplacementCharacter
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|fragment_start
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|fragment_end
argument_list|)
expr_stmt|;
name|fragment_start
operator|=
name|fragment
expr_stmt|;
name|fragment_end
operator|=
name|fragment
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fragmentRemoved
name|void
name|QTextFramePrivate
operator|::
name|fragmentRemoved
parameter_list|(
name|QChar
name|type
parameter_list|,
name|uint
name|fragment
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
comment|// --release warning
if|if
condition|(
name|type
operator|==
name|QTextBeginningOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|fragment_start
operator|==
name|fragment
argument_list|)
expr_stmt|;
name|fragment_start
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QTextEndOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|fragment_end
operator|==
name|fragment
argument_list|)
expr_stmt|;
name|fragment_end
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QChar
operator|::
name|ObjectReplacementCharacter
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|fragment_start
operator|==
name|fragment
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|fragment_end
operator|==
name|fragment
argument_list|)
expr_stmt|;
name|fragment_start
operator|=
literal|0
expr_stmt|;
name|fragment_end
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|remove_me
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_me
name|void
name|QTextFramePrivate
operator|::
name|remove_me
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTextFrame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragment_start
operator|==
literal|0
operator|&&
name|fragment_end
operator|==
literal|0
operator|&&
operator|!
name|parentFrame
condition|)
block|{
name|q
operator|->
name|document
argument_list|()
operator|->
name|docHandle
argument_list|()
operator|->
name|deleteObject
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|parentFrame
condition|)
return|return;
name|int
name|index
init|=
name|parentFrame
operator|->
name|d_func
argument_list|()
operator|->
name|childFrames
operator|.
name|indexOf
argument_list|(
name|q
argument_list|)
decl_stmt|;
comment|// iterator over all children and move them to the parent
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childFrames
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextFrame
modifier|*
name|c
init|=
name|childFrames
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|parentFrame
operator|->
name|d_func
argument_list|()
operator|->
name|childFrames
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|d_func
argument_list|()
operator|->
name|parentFrame
operator|=
name|parentFrame
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|parentFrame
operator|->
name|d_func
argument_list|()
operator|->
name|childFrames
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|==
name|q
argument_list|)
expr_stmt|;
name|parentFrame
operator|->
name|d_func
argument_list|()
operator|->
name|childFrames
operator|.
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|childFrames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parentFrame
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTextFrame::iterator     \reentrant      \brief The iterator class provides an iterator for reading     the contents of a QTextFrame.      \inmodule QtGui     \ingroup richtext-processing      A frame consists of an arbitrary sequence of \l{QTextBlock}s and     child \l{QTextFrame}s. This class provides a way to iterate over the     child objects of a frame, and read their contents. It does not provide     a way to modify the contents of the frame.  */
end_comment
begin_comment
comment|/*!     \fn bool QTextFrame::iterator::atEnd() const      Returns true if the current item is the last item in the text frame. */
end_comment
begin_comment
comment|/*!     Returns an iterator pointing to the first document element inside the frame.     Please see the document \l{STL-style-Iterators} for more information.      \sa end() */
end_comment
begin_function
DECL|function|begin
name|QTextFrame
operator|::
name|iterator
name|QTextFrame
operator|::
name|begin
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|docHandle
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|priv
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|firstPosition
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|priv
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|lastPosition
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|iterator
argument_list|(
cast|const_cast
argument_list|<
name|QTextFrame
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|b
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an iterator pointing to the position past the last document element inside the frame.     Please see the document \l{STL-Style Iterators} for more information.     \sa begin() */
end_comment
begin_function
DECL|function|end
name|QTextFrame
operator|::
name|iterator
name|QTextFrame
operator|::
name|end
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|docHandle
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|priv
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|firstPosition
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|priv
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|lastPosition
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|iterator
argument_list|(
cast|const_cast
argument_list|<
name|QTextFrame
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|,
name|e
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an invalid iterator. */
end_comment
begin_constructor
DECL|function|iterator
name|QTextFrame
operator|::
name|iterator
operator|::
name|iterator
parameter_list|()
block|{
name|f
operator|=
literal|0
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|iterator
name|QTextFrame
operator|::
name|iterator
operator|::
name|iterator
parameter_list|(
name|QTextFrame
modifier|*
name|frame
parameter_list|,
name|int
name|block
parameter_list|,
name|int
name|begin
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|f
operator|=
name|frame
expr_stmt|;
name|b
operator|=
name|begin
expr_stmt|;
name|e
operator|=
name|end
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
name|block
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Copy constructor. Constructs a copy of the \a other iterator. */
end_comment
begin_constructor
DECL|function|iterator
name|QTextFrame
operator|::
name|iterator
operator|::
name|iterator
parameter_list|(
specifier|const
name|iterator
modifier|&
name|other
parameter_list|)
block|{
name|f
operator|=
name|other
operator|.
name|f
expr_stmt|;
name|b
operator|=
name|other
operator|.
name|b
expr_stmt|;
name|e
operator|=
name|other
operator|.
name|e
expr_stmt|;
name|cf
operator|=
name|other
operator|.
name|cf
expr_stmt|;
name|cb
operator|=
name|other
operator|.
name|cb
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this iterator and returns a reference to     this iterator. */
end_comment
begin_function
DECL|function|operator =
name|QTextFrame
operator|::
name|iterator
modifier|&
name|QTextFrame
operator|::
name|iterator
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|iterator
modifier|&
name|other
parameter_list|)
block|{
name|f
operator|=
name|other
operator|.
name|f
expr_stmt|;
name|b
operator|=
name|other
operator|.
name|b
expr_stmt|;
name|e
operator|=
name|other
operator|.
name|e
expr_stmt|;
name|cf
operator|=
name|other
operator|.
name|cf
expr_stmt|;
name|cb
operator|=
name|other
operator|.
name|cb
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current frame pointed to by the iterator, or 0 if the     iterator currently points to a block.      \sa currentBlock() */
end_comment
begin_function
DECL|function|currentFrame
name|QTextFrame
modifier|*
name|QTextFrame
operator|::
name|iterator
operator|::
name|currentFrame
parameter_list|()
specifier|const
block|{
return|return
name|cf
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current block the iterator points to. If the iterator     points to a child frame, the returned block is invalid.      \sa currentFrame() */
end_comment
begin_function
DECL|function|currentBlock
name|QTextBlock
name|QTextFrame
operator|::
name|iterator
operator|::
name|currentBlock
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|f
condition|)
return|return
name|QTextBlock
argument_list|()
return|;
return|return
name|QTextBlock
argument_list|(
name|f
operator|->
name|docHandle
argument_list|()
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Moves the iterator to the next frame or block.      \sa currentBlock(), currentFrame() */
end_comment
begin_function
DECL|function|operator ++
name|QTextFrame
operator|::
name|iterator
modifier|&
name|QTextFrame
operator|::
name|iterator
operator|::
name|operator
name|++
parameter_list|()
block|{
specifier|const
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|f
operator|->
name|docHandle
argument_list|()
decl_stmt|;
specifier|const
name|QTextDocumentPrivate
operator|::
name|BlockMap
modifier|&
name|map
init|=
name|priv
operator|->
name|blockMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|cf
condition|)
block|{
name|int
name|end
init|=
name|cf
operator|->
name|lastPosition
argument_list|()
operator|+
literal|1
decl_stmt|;
name|cb
operator|=
name|map
operator|.
name|findNode
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
condition|)
block|{
name|cb
operator|=
name|map
operator|.
name|next
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|e
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
operator|!
name|f
operator|->
name|d_func
argument_list|()
operator|->
name|childFrames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|pos
init|=
name|map
operator|.
name|position
argument_list|(
name|cb
argument_list|)
decl_stmt|;
comment|// check if we entered a frame
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|frag
init|=
name|priv
operator|->
name|find
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|!=
name|QChar
operator|::
name|ParagraphSeparator
condition|)
block|{
name|QTextFrame
modifier|*
name|nf
init|=
name|qobject_cast
argument_list|<
name|QTextFrame
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|objectForFormat
argument_list|(
name|frag
operator|->
name|format
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nf
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|==
name|QTextBeginningOfFrame
operator|&&
name|nf
operator|!=
name|f
condition|)
block|{
name|cf
operator|=
name|nf
expr_stmt|;
name|cb
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|!=
name|QTextEndOfFrame
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Moves the iterator to the previous frame or block.      \sa currentBlock(), currentFrame() */
end_comment
begin_function
DECL|function|operator --
name|QTextFrame
operator|::
name|iterator
modifier|&
name|QTextFrame
operator|::
name|iterator
operator|::
name|operator
name|--
parameter_list|()
block|{
specifier|const
name|QTextDocumentPrivate
modifier|*
name|priv
init|=
name|f
operator|->
name|docHandle
argument_list|()
decl_stmt|;
specifier|const
name|QTextDocumentPrivate
operator|::
name|BlockMap
modifier|&
name|map
init|=
name|priv
operator|->
name|blockMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|cf
condition|)
block|{
name|int
name|start
init|=
name|cf
operator|->
name|firstPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
name|cb
operator|=
name|map
operator|.
name|findNode
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cb
operator|==
name|b
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|cb
operator|!=
name|e
condition|)
block|{
name|int
name|pos
init|=
name|map
operator|.
name|position
argument_list|(
name|cb
argument_list|)
decl_stmt|;
comment|// check if we have to enter a frame
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|frag
init|=
name|priv
operator|->
name|find
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|!=
name|QChar
operator|::
name|ParagraphSeparator
condition|)
block|{
name|QTextFrame
modifier|*
name|pf
init|=
name|qobject_cast
argument_list|<
name|QTextFrame
operator|*
argument_list|>
argument_list|(
name|priv
operator|->
name|objectForFormat
argument_list|(
name|frag
operator|->
name|format
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pf
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|==
name|QTextBeginningOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|pf
operator|==
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|buffer
argument_list|()
operator|.
name|at
argument_list|(
name|frag
operator|->
name|stringPosition
argument_list|)
operator|==
name|QTextEndOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|pf
operator|!=
name|f
argument_list|)
expr_stmt|;
name|cf
operator|=
name|pf
expr_stmt|;
name|cb
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
block|}
block|}
name|cb
operator|=
name|map
operator|.
name|previous
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
name|end
label|:
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextBlockUserData     \reentrant      \brief The QTextBlockUserData class is used to associate custom data with blocks of text.     \inmodule QtGui     \since 4.1      \ingroup richtext-processing      QTextBlockUserData provides an abstract interface for container classes that are used     to associate application-specific user data with text blocks in a QTextDocument.      Generally, subclasses of this class provide functions to allow data to be stored     and retrieved, and instances are attached to blocks of text using     QTextBlock::setUserData(). This makes it possible to store additional data per text     block in a way that can be retrieved safely by the application.      Each subclass should provide a reimplementation of the destructor to ensure that any     private data is automatically cleaned up when user data objects are deleted.      \sa QTextBlock */
end_comment
begin_comment
comment|/*!     Destroys the user data. */
end_comment
begin_destructor
DECL|function|~QTextBlockUserData
name|QTextBlockUserData
operator|::
name|~
name|QTextBlockUserData
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \class QTextBlock     \reentrant      \brief The QTextBlock class provides a container for text fragments in a     QTextDocument.     \inmodule QtGui      \ingroup richtext-processing      A text block encapsulates a block or paragraph of text in a QTextDocument.     QTextBlock provides read-only access to the block/paragraph structure of     QTextDocuments. It is mainly of use if you want to implement your own     layouts for the visual representation of a QTextDocument, or if you want to     iterate over a document and write out the contents in your own custom     format.      Text blocks are created by their parent documents. If you need to create     a new text block, or modify the contents of a document while examining its     contents, use the cursor-based interface provided by QTextCursor instead.      Each text block is located at a specific position() in a document().     The contents of the block can be obtained by using the text() function.     The length() function determines the block's size within the document     (including formatting characters).     The visual properties of the block are determined by its text layout(),     its charFormat(), and its blockFormat().      The next() and previous() functions enable iteration over consecutive     valid blocks in a document under the condition that the document is not     modified by other means during the iteration process. Note that, although     blocks are returned in sequence, adjacent blocks may come from different     places in the document structure. The validity of a block can be determined     by calling isValid().      QTextBlock provides comparison operators to make it easier to work with     blocks: \l operator==() compares two block for equality, \l operator!=()     compares two blocks for inequality, and \l operator<() determines whether     a block precedes another in the same document.      \image qtextblock-sequence.png      \sa QTextBlockFormat, QTextCharFormat, QTextFragment  */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::QTextBlock(QTextDocumentPrivate *priv, int b)      \internal */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::QTextBlock()      \internal */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::QTextBlock(const QTextBlock&other)      Copies the \a other text block's attributes to this text block. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::isValid() const      Returns true if this text block is valid; otherwise returns false. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTextBlock
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|p
operator|!=
literal|0
operator|&&
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|isValid
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextBlock&QTextBlock::operator=(const QTextBlock&other)      Assigns the \a other text block to this text block. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::operator==(const QTextBlock&other) const      Returns true if this text block is the same as the \a other text     block. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::operator!=(const QTextBlock&other) const      Returns true if this text block is different from the \a other     text block. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::operator<(const QTextBlock&other) const      Returns true if this text block occurs before the \a other text     block in the document. */
end_comment
begin_comment
comment|/*!     \class QTextBlock::iterator     \reentrant      \brief The QTextBlock::iterator class provides an iterator for reading     the contents of a QTextBlock.     \inmodule QtGui      \ingroup richtext-processing      A block consists of a sequence of text fragments. This class provides     a way to iterate over these, and read their contents. It does not provide     a way to modify the internal structure or contents of the block.      An iterator can be constructed and used to access the fragments within     a text block in the following way:      \snippet textblock-fragments/xmlwriter.cpp 4     \snippet textblock-fragments/xmlwriter.cpp 7      \sa QTextFragment */
end_comment
begin_comment
comment|/*!     \typedef QTextBlock::Iterator      Qt-style synonym for QTextBlock::iterator. */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::iterator::iterator()      Constructs an iterator for this text block. */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::iterator::iterator(const iterator&other)      Copy constructor. Constructs a copy of the \a other iterator. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::iterator::atEnd() const      Returns true if the current item is the last item in the text block. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::iterator::operator==(const iterator&other) const      Retuns true if this iterator is the same as the \a other iterator;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTextBlock::iterator::operator!=(const iterator&other) const      Retuns true if this iterator is different from the \a other iterator;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::iterator QTextBlock::iterator::operator++(int)      The postfix ++ operator (\c{i++}) advances the iterator to the     next item in the text block and returns an iterator to the old current     item. */
end_comment
begin_comment
comment|/*!     \fn QTextBlock::iterator QTextBlock::iterator::operator--(int)      The postfix -- operator (\c{i--}) makes the preceding item current and     returns an iterator to the old current item. */
end_comment
begin_comment
comment|/*!     \fn QTextDocumentPrivate *QTextBlock::docHandle() const      \internal */
end_comment
begin_comment
comment|/*!     \fn int QTextBlock::fragmentIndex() const      \internal */
end_comment
begin_comment
comment|/*!     Returns the index of the block's first character within the document.  */
end_comment
begin_function
DECL|function|position
name|int
name|QTextBlock
operator|::
name|position
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|position
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the block in characters.      \note The length returned includes all formatting characters,     for example, newline.      \sa text(), charFormat(), blockFormat()  */
end_comment
begin_function
DECL|function|length
name|int
name|QTextBlock
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|size
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the given \a position is located within the text     block; otherwise returns false.  */
end_comment
begin_function
DECL|function|contains
name|bool
name|QTextBlock
operator|::
name|contains
parameter_list|(
name|int
name|position
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|false
return|;
name|int
name|pos
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|position
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|size
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|position
operator|>=
name|pos
operator|&&
name|position
operator|<
name|pos
operator|+
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QTextLayout that is used to lay out and display the     block's contents.      Note that the returned QTextLayout object can only be modified from the     documentChanged implementation of a QAbstractTextDocumentLayout subclass.     Any changes applied from the outside cause undefined behavior.      \sa clearLayout()  */
end_comment
begin_function
DECL|function|layout
name|QTextLayout
modifier|*
name|QTextBlock
operator|::
name|layout
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|layout
condition|)
name|b
operator|->
name|layout
operator|=
operator|new
name|QTextLayout
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
return|return
name|b
operator|->
name|layout
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     Clears the QTextLayout that is used to lay out and display the     block's contents.      \sa layout()  */
end_comment
begin_function
DECL|function|clearLayout
name|void
name|QTextBlock
operator|::
name|clearLayout
parameter_list|()
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|layout
condition|)
name|b
operator|->
name|layout
operator|->
name|clearLayout
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the QTextBlockFormat that describes block-specific properties.      \sa charFormat()  */
end_comment
begin_function
DECL|function|blockFormat
name|QTextBlockFormat
name|QTextBlock
operator|::
name|blockFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QTextFormat
argument_list|()
operator|.
name|toBlockFormat
argument_list|()
return|;
return|return
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|blockFormat
argument_list|(
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an index into the document's internal list of block formats     for the text block's format.      \sa QTextDocument::allFormats() */
end_comment
begin_function
DECL|function|blockFormatIndex
name|int
name|QTextBlock
operator|::
name|blockFormatIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QTextCharFormat that describes the block's character     format. The block's character format is used when inserting text into     an empty block.      \sa blockFormat()  */
end_comment
begin_function
DECL|function|charFormat
name|QTextCharFormat
name|QTextBlock
operator|::
name|charFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QTextFormat
argument_list|()
operator|.
name|toCharFormat
argument_list|()
return|;
return|return
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|charFormat
argument_list|(
name|charFormatIndex
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an index into the document's internal list of character formats     for the text block's character format.      \sa QTextDocument::allFormats() */
end_comment
begin_function
DECL|function|charFormatIndex
name|int
name|QTextBlock
operator|::
name|charFormatIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|p
operator|->
name|blockCharFormatIndex
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns the resolved text direction.    If the block has no explicit direction set, it will resolve the   direction from the blocks content. Returns either Qt::LeftToRight   or Qt::RightToLeft.    \sa QTextFormat::layoutDirection(), QString::isRightToLeft(), Qt::LayoutDirection */
end_comment
begin_function
DECL|function|textDirection
name|Qt
operator|::
name|LayoutDirection
name|QTextBlock
operator|::
name|textDirection
parameter_list|()
specifier|const
block|{
name|Qt
operator|::
name|LayoutDirection
name|dir
init|=
name|blockFormat
argument_list|()
operator|.
name|layoutDirection
argument_list|()
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
name|Qt
operator|::
name|LayoutDirectionAuto
condition|)
return|return
name|dir
return|;
name|dir
operator|=
name|p
operator|->
name|defaultTextOption
operator|.
name|textDirection
argument_list|()
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|Qt
operator|::
name|LayoutDirectionAuto
condition|)
return|return
name|dir
return|;
specifier|const
name|QString
name|buffer
init|=
name|p
operator|->
name|buffer
argument_list|()
decl_stmt|;
specifier|const
name|int
name|pos
init|=
name|position
argument_list|()
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
init|=
name|p
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|end
init|=
name|p
operator|->
name|find
argument_list|(
name|pos
operator|+
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// -1 to omit the block separator char
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|p
init|=
name|buffer
operator|.
name|constData
argument_list|()
operator|+
name|frag
operator|->
name|stringPosition
decl_stmt|;
specifier|const
name|QChar
modifier|*
specifier|const
name|end
init|=
name|p
operator|+
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|ucs4
init|=
name|p
operator|->
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|p
operator|+
literal|1
operator|<
name|end
condition|)
block|{
name|ushort
name|low
init|=
name|p
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|QChar
operator|::
name|direction
argument_list|(
name|ucs4
argument_list|)
condition|)
block|{
case|case
name|QChar
operator|::
name|DirL
case|:
return|return
name|Qt
operator|::
name|LeftToRight
return|;
case|case
name|QChar
operator|::
name|DirR
case|:
case|case
name|QChar
operator|::
name|DirAL
case|:
return|return
name|Qt
operator|::
name|RightToLeft
return|;
default|default:
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
return|return
name|Qt
operator|::
name|LeftToRight
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the block's contents as plain text.      \sa length(), charFormat(), blockFormat()  */
end_comment
begin_function
DECL|function|text
name|QString
name|QTextBlock
operator|::
name|text
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|QString
name|buffer
init|=
name|p
operator|->
name|buffer
argument_list|()
decl_stmt|;
name|QString
name|text
decl_stmt|;
name|text
operator|.
name|reserve
argument_list|(
name|length
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|int
name|pos
init|=
name|position
argument_list|()
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
init|=
name|p
operator|->
name|find
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|end
init|=
name|p
operator|->
name|find
argument_list|(
name|pos
operator|+
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// -1 to omit the block separator char
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|text
operator|+=
name|QString
operator|::
name|fromRawData
argument_list|(
name|buffer
operator|.
name|constData
argument_list|()
operator|+
name|frag
operator|->
name|stringPosition
argument_list|,
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text document this text block belongs to, or 0 if the     text block does not belong to any document. */
end_comment
begin_function
DECL|function|document
specifier|const
name|QTextDocument
modifier|*
name|QTextBlock
operator|::
name|document
parameter_list|()
specifier|const
block|{
return|return
name|p
condition|?
name|p
operator|->
name|document
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     If the block represents a list item, returns the list that the item belongs     to; otherwise returns 0. */
end_comment
begin_function
DECL|function|textList
name|QTextList
modifier|*
name|QTextBlock
operator|::
name|textList
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
specifier|const
name|QTextBlockFormat
name|fmt
init|=
name|blockFormat
argument_list|()
decl_stmt|;
name|QTextObject
modifier|*
name|obj
init|=
name|p
operator|->
name|document
argument_list|()
operator|->
name|objectForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
return|return
name|qobject_cast
argument_list|<
name|QTextList
operator|*
argument_list|>
argument_list|(
name|obj
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns a pointer to a QTextBlockUserData object if previously set with     setUserData() or a null pointer. */
end_comment
begin_function
DECL|function|userData
name|QTextBlockUserData
modifier|*
name|QTextBlock
operator|::
name|userData
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|b
operator|->
name|userData
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Attaches the given \a data object to the text block.      QTextBlockUserData can be used to store custom settings.  The     ownership is passed to the underlying text document, i.e. the     provided QTextBlockUserData object will be deleted if the     corresponding text block gets deleted. The user data object is     not stored in the undo history, so it will not be available after     undoing the deletion of a text block.      For example, if you write a programming editor in an IDE, you may     want to let your user set breakpoints visually in your code for an     integrated debugger. In a programming editor a line of text     usually corresponds to one QTextBlock. The QTextBlockUserData     interface allows the developer to store data for each QTextBlock,     like for example in which lines of the source code the user has a     breakpoint set. Of course this could also be stored externally,     but by storing it inside the QTextDocument, it will for example be     automatically deleted when the user deletes the associated     line. It's really just a way to store custom information in the     QTextDocument without using custom properties in QTextFormat which     would affect the undo/redo stack. */
end_comment
begin_function
DECL|function|setUserData
name|void
name|QTextBlock
operator|::
name|setUserData
parameter_list|(
name|QTextBlockUserData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
name|b
operator|->
name|userData
condition|)
operator|delete
name|b
operator|->
name|userData
expr_stmt|;
name|b
operator|->
name|userData
operator|=
name|data
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the integer value previously set with setUserState() or -1. */
end_comment
begin_function
DECL|function|userState
name|int
name|QTextBlock
operator|::
name|userState
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|b
operator|->
name|userState
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Stores the specified \a state integer value in the text block. This may be     useful for example in a syntax highlighter to store a text parsing state. */
end_comment
begin_function
DECL|function|setUserState
name|void
name|QTextBlock
operator|::
name|setUserState
parameter_list|(
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|b
operator|->
name|userState
operator|=
name|state
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the blocks revision.      \sa setRevision(), QTextDocument::revision() */
end_comment
begin_function
DECL|function|revision
name|int
name|QTextBlock
operator|::
name|revision
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|b
operator|->
name|revision
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets a blocks revision to \a rev.      \sa revision(), QTextDocument::revision() */
end_comment
begin_function
DECL|function|setRevision
name|void
name|QTextBlock
operator|::
name|setRevision
parameter_list|(
name|int
name|rev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|b
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns true if the block is visible; otherwise returns false.      \sa setVisible() */
end_comment
begin_function
DECL|function|isVisible
name|bool
name|QTextBlock
operator|::
name|isVisible
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|true
return|;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
operator|!
name|b
operator|->
name|hidden
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the block's visibility to \a visible.      \sa isVisible() */
end_comment
begin_function
DECL|function|setVisible
name|void
name|QTextBlock
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
specifier|const
name|QTextBlockData
modifier|*
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|b
operator|->
name|hidden
operator|=
operator|!
name|visible
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \since 4.4      Returns the number of this block, or -1 if the block is invalid.      \sa QTextCursor::blockNumber()  */
end_comment
begin_function
DECL|function|blockNumber
name|int
name|QTextBlock
operator|::
name|blockNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|position
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.5      Returns the first line number of this block, or -1 if the block is invalid.     Unless the layout supports it, the line number is identical to the block number.      \sa QTextBlock::blockNumber()  */
end_comment
begin_function
DECL|function|firstLineNumber
name|int
name|QTextBlock
operator|::
name|firstLineNumber
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|position
argument_list|(
name|n
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.5  Sets the line count to \a count.  \sa lineCount() */
end_comment
begin_function
DECL|function|setLineCount
name|void
name|QTextBlock
operator|::
name|setLineCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return;
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|setSize
argument_list|(
name|n
argument_list|,
name|count
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \since 4.5  Returns the line count. Not all document layouts support this feature.  \sa setLineCount()  */
end_comment
begin_function
DECL|function|lineCount
name|int
name|QTextBlock
operator|::
name|lineCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|size
argument_list|(
name|n
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a text block iterator pointing to the beginning of the     text block.      \sa end() */
end_comment
begin_function
DECL|function|begin
name|QTextBlock
operator|::
name|iterator
name|QTextBlock
operator|::
name|begin
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|iterator
argument_list|()
return|;
name|int
name|pos
init|=
name|position
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// exclude the fragment that holds the paragraph separator
name|int
name|b
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|pos
operator|+
name|len
argument_list|)
decl_stmt|;
return|return
name|iterator
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|e
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a text block iterator pointing to the end of the text     block.      \sa begin(), next(), previous() */
end_comment
begin_function
DECL|function|end
name|QTextBlock
operator|::
name|iterator
name|QTextBlock
operator|::
name|end
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|iterator
argument_list|()
return|;
name|int
name|pos
init|=
name|position
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// exclude the fragment that holds the paragraph separator
name|int
name|b
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|pos
operator|+
name|len
argument_list|)
decl_stmt|;
return|return
name|iterator
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text block in the document after this block, or an empty     text block if this is the last one.      Note that the next block may be in a different frame or table to this block.      \sa previous(), begin(), end() */
end_comment
begin_function
DECL|function|next
name|QTextBlock
name|QTextBlock
operator|::
name|next
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QTextBlock
argument_list|()
return|;
return|return
name|QTextBlock
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|next
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text block in the document before this block, or an empty text     block if this is the first one.      Note that the next block may be in a different frame or table to this block.      \sa next(), begin(), end() */
end_comment
begin_function
DECL|function|previous
name|QTextBlock
name|QTextBlock
operator|::
name|previous
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|QTextBlock
argument_list|()
return|;
return|return
name|QTextBlock
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|previous
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text fragment the iterator currently points to. */
end_comment
begin_function
DECL|function|fragment
name|QTextFragment
name|QTextBlock
operator|::
name|iterator
operator|::
name|fragment
parameter_list|()
specifier|const
block|{
name|int
name|ne
init|=
name|n
decl_stmt|;
name|int
name|formatIndex
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
decl_stmt|;
do|do
block|{
name|ne
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|next
argument_list|(
name|ne
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ne
operator|!=
name|e
operator|&&
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|ne
argument_list|)
operator|->
name|format
operator|==
name|formatIndex
condition|)
do|;
return|return
name|QTextFragment
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|ne
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     The prefix ++ operator (\c{++i}) advances the iterator to the     next item in the hash and returns an iterator to the new current     item. */
end_comment
begin_function
DECL|function|operator ++
name|QTextBlock
operator|::
name|iterator
modifier|&
name|QTextBlock
operator|::
name|iterator
operator|::
name|operator
name|++
parameter_list|()
block|{
name|int
name|ne
init|=
name|n
decl_stmt|;
name|int
name|formatIndex
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
decl_stmt|;
do|do
block|{
name|ne
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|next
argument_list|(
name|ne
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ne
operator|!=
name|e
operator|&&
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|ne
argument_list|)
operator|->
name|format
operator|==
name|formatIndex
condition|)
do|;
name|n
operator|=
name|ne
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     The prefix -- operator (\c{--i}) makes the preceding item     current and returns an iterator pointing to the new current item. */
end_comment
begin_function
DECL|function|operator --
name|QTextBlock
operator|::
name|iterator
modifier|&
name|QTextBlock
operator|::
name|iterator
operator|::
name|operator
name|--
parameter_list|()
block|{
name|n
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|previous
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|b
condition|)
return|return
operator|*
name|this
return|;
name|int
name|formatIndex
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
decl_stmt|;
name|int
name|last
init|=
name|n
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|b
operator|&&
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
operator|->
name|format
operator|!=
name|formatIndex
condition|)
block|{
name|last
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|previous
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|last
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextFragment     \reentrant      \brief The QTextFragment class holds a piece of text in a     QTextDocument with a single QTextCharFormat.     \inmodule QtGui      \ingroup richtext-processing      A text fragment describes a piece of text that is stored with a single     character format. Text in which the character format changes can be     represented by sequences of text fragments with different formats.      If the user edits the text in a fragment and introduces a different     character format, the fragment's text will be split at each point where     the format changes, and new fragments will be created.     For example, changing the style of some text in the middle of a     sentence will cause the fragment to be broken into three separate fragments:     the first and third with the same format as before, and the second with     the new style. The first fragment will contain the text from the beginning     of the sentence, the second will contain the text from the middle, and the     third takes the text from the end of the sentence.      \image qtextfragment-split.png      A fragment's text and character format can be obtained with the text()     and charFormat() functions. The length() function gives the length of     the text in the fragment. position() gives the position in the document     of the start of the fragment. To determine whether the fragment contains     a particular position within the document, use the contains() function.      \sa QTextDocument, {Rich Text Document Structure} */
end_comment
begin_comment
comment|/*!     \fn QTextFragment::QTextFragment(const QTextDocumentPrivate *priv, int f, int fe)     \internal */
end_comment
begin_comment
comment|/*!     \fn QTextFragment::QTextFragment()      Creates a new empty text fragment. */
end_comment
begin_comment
comment|/*!     \fn QTextFragment::QTextFragment(const QTextFragment&other)      Copies the content (text and format) of the \a other text fragment     to this text fragment. */
end_comment
begin_comment
comment|/*!     \fn QTextFragment&QTextFragment::operator=(const QTextFragment&other)      Assigns the content (text and format) of the \a other text fragment     to this text fragment. */
end_comment
begin_comment
comment|/*!     \fn bool QTextFragment::isValid() const      Returns true if this is a valid text fragment (i.e. has a valid     position in a document); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTextFragment::operator==(const QTextFragment&other) const      Returns true if this text fragment is the same (at the same     position) as the \a other text fragment; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTextFragment::operator!=(const QTextFragment&other) const      Returns true if this text fragment is different (at a different     position) from the \a other text fragment; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QTextFragment::operator<(const QTextFragment&other) const      Returns true if this text fragment appears earlier in the document     than the \a other text fragment; otherwise returns false. */
end_comment
begin_comment
comment|/*!     Returns the glyphs corresponding to \a len characters of this text fragment starting at     position \a pos. The positions of the glyphs are relative to the position of the QTextBlock's     layout.      If \a pos is less than zero, it will default to the start of the QTextFragment. If \a len     is less than zero, it will default to the length of the fragment.      \sa QGlyphRun, QTextBlock::layout(), QTextLayout::position(), QPainter::drawGlyphRun() */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_RAWFONT
argument_list|)
end_if
begin_function
DECL|function|glyphRuns
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|QTextFragment
operator|::
name|glyphRuns
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
argument_list|()
return|;
name|int
name|blockNode
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|position
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QTextBlockData
modifier|*
name|blockData
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|blockNode
argument_list|)
decl_stmt|;
name|QTextLayout
modifier|*
name|layout
init|=
name|blockData
operator|->
name|layout
decl_stmt|;
name|int
name|blockPosition
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|position
argument_list|(
name|blockNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
name|position
argument_list|()
operator|-
name|blockPosition
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
argument_list|()
return|;
name|QList
argument_list|<
name|QGlyphRun
argument_list|>
name|ret
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|layout
operator|->
name|lineCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextLine
name|textLine
init|=
name|layout
operator|->
name|lineAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ret
operator|+=
name|textLine
operator|.
name|glyphRuns
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_RAWFONT
end_comment
begin_comment
comment|/*!     Returns the position of this text fragment in the document. */
end_comment
begin_function
DECL|function|position
name|int
name|QTextFragment
operator|::
name|position
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
comment|// ### -1 instead?
return|return
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of characters in the text fragment.      \sa text() */
end_comment
begin_function
DECL|function|length
name|int
name|QTextFragment
operator|::
name|length
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|0
return|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|f
init|=
name|n
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|ne
condition|)
block|{
name|len
operator|+=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|size
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|next
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the text fragment contains the text at the given     \a position in the document; otherwise returns false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QTextFragment
operator|::
name|contains
parameter_list|(
name|int
name|position
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
literal|false
return|;
name|int
name|pos
init|=
name|this
operator|->
name|position
argument_list|()
decl_stmt|;
return|return
name|position
operator|>=
name|pos
operator|&&
name|position
operator|<
name|pos
operator|+
name|length
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text fragment's character format.      \sa text() */
end_comment
begin_function
DECL|function|charFormat
name|QTextCharFormat
name|QTextFragment
operator|::
name|charFormat
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QTextCharFormat
argument_list|()
return|;
specifier|const
name|QTextFragmentData
modifier|*
name|data
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|charFormat
argument_list|(
name|data
operator|->
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an index into the document's internal list of character formats     for the text fragment's character format.      \sa QTextDocument::allFormats() */
end_comment
begin_function
DECL|function|charFormatIndex
name|int
name|QTextFragment
operator|::
name|charFormatIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|QTextFragmentData
modifier|*
name|data
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|n
argument_list|)
decl_stmt|;
return|return
name|data
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text fragment's as plain text.      \sa length(), charFormat() */
end_comment
begin_function
DECL|function|text
name|QString
name|QTextFragment
operator|::
name|text
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|n
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|result
decl_stmt|;
name|QString
name|buffer
init|=
name|p
operator|->
name|buffer
argument_list|()
decl_stmt|;
name|int
name|f
init|=
name|n
decl_stmt|;
while|while
condition|(
name|f
operator|!=
name|ne
condition|)
block|{
specifier|const
name|QTextFragmentData
modifier|*
specifier|const
name|frag
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|fragment
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QString
argument_list|(
name|buffer
operator|.
name|constData
argument_list|()
operator|+
name|frag
operator|->
name|stringPosition
argument_list|,
name|frag
operator|->
name|size_array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|next
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
