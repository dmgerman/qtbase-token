begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtexttable.h"
end_include
begin_include
include|#
directive|include
file|"qtextcursor.h"
end_include
begin_include
include|#
directive|include
file|"qtextformat.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qtexttable_p.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"private/qfunctions_p.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QTextTableCell     \reentrant      \brief The QTextTableCell class represents the properties of a     cell in a QTextTable.     \inmodule QtGui      \ingroup richtext-processing      Table cells are pieces of document structure that belong to a table.     The table orders cells into particular rows and columns; cells can     also span multiple columns and rows.      Cells are usually created when a table is inserted into a document with     QTextCursor::insertTable(), but they are also created and destroyed when     a table is resized.      Cells contain information about their location in a table; you can     obtain the row() and column() numbers of a cell, and its rowSpan()     and columnSpan().      The format() of a cell describes the default character format of its     contents. The firstCursorPosition() and lastCursorPosition() functions     are used to obtain the extent of the cell in the document.      \sa QTextTable, QTextTableFormat */
comment|/*!     \fn QTextTableCell::QTextTableCell()      Constructs an invalid table cell.      \sa isValid() */
comment|/*!     \fn QTextTableCell::QTextTableCell(const QTextTableCell&other)      Copy constructor. Creates a new QTextTableCell object based on the     \a other cell. */
comment|/*!     \fn QTextTableCell& QTextTableCell::operator=(const QTextTableCell&other)      Assigns the \a other table cell to this table cell. */
comment|/*!     \since 4.2      Sets the cell's character format to \a format. This can for example be used to change     the background color of the entire cell:      QTextTableCell cell = table->cellAt(2, 3);     QTextCharFormat format = cell.format();     format.setBackground(Qt::blue);     cell.setFormat(format);      Note that the cell's row or column span cannot be changed through this function. You have     to use QTextTable::mergeCells and QTextTable::splitCell instead.      \sa format() */
DECL|function|setFormat
name|void
name|QTextTableCell
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QTextCharFormat
modifier|&
name|format
parameter_list|)
block|{
name|QTextCharFormat
name|fmt
init|=
name|format
decl_stmt|;
name|fmt
operator|.
name|clearProperty
argument_list|(
name|QTextFormat
operator|::
name|ObjectIndex
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setObjectType
argument_list|(
name|QTextFormat
operator|::
name|TableCellObject
argument_list|)
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|frag
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|fragment
argument_list|)
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|QTextCharFormat
name|oldFormat
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|frag
operator|->
name|format
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
name|oldFormat
operator|.
name|tableCellRowSpan
argument_list|()
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
name|oldFormat
operator|.
name|tableCellColumnSpan
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|frag
operator|.
name|position
argument_list|()
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|QTextDocumentPrivate
operator|::
name|SetFormatAndPreserveObjectIndices
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the cell's character format. */
end_comment
begin_function
DECL|function|format
name|QTextCharFormat
name|QTextTableCell
operator|::
name|format
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|tableCellFormatIndex
argument_list|()
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setObjectType
argument_list|(
name|QTextFormat
operator|::
name|TableCellObject
argument_list|)
expr_stmt|;
return|return
name|fmt
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the index of the tableCell's format in the document's internal list of formats.      \sa QTextDocument::allFormats() */
end_comment
begin_function
DECL|function|tableCellFormatIndex
name|int
name|QTextTableCell
operator|::
name|tableCellFormatIndex
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
return|return
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|fragment
argument_list|)
operator|->
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of the row in the table that contains this cell.      \sa column() */
end_comment
begin_function
DECL|function|row
name|int
name|QTextTableCell
operator|::
name|row
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextTablePrivate
modifier|*
name|tp
init|=
name|table
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|dirty
condition|)
name|tp
operator|->
name|update
argument_list|()
expr_stmt|;
name|int
name|idx
init|=
name|tp
operator|->
name|findCellIndex
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
name|idx
return|;
return|return
name|tp
operator|->
name|cellIndices
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|/
name|tp
operator|->
name|nCols
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of the column in the table that contains this cell.      \sa row() */
end_comment
begin_function
DECL|function|column
name|int
name|QTextTableCell
operator|::
name|column
parameter_list|()
specifier|const
block|{
specifier|const
name|QTextTablePrivate
modifier|*
name|tp
init|=
name|table
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|dirty
condition|)
name|tp
operator|->
name|update
argument_list|()
expr_stmt|;
name|int
name|idx
init|=
name|tp
operator|->
name|findCellIndex
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
name|idx
return|;
return|return
name|tp
operator|->
name|cellIndices
operator|.
name|at
argument_list|(
name|idx
argument_list|)
operator|%
name|tp
operator|->
name|nCols
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of rows this cell spans. The default is 1.      \sa columnSpan() */
end_comment
begin_function
DECL|function|rowSpan
name|int
name|QTextTableCell
operator|::
name|rowSpan
parameter_list|()
specifier|const
block|{
return|return
name|format
argument_list|()
operator|.
name|tableCellRowSpan
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of columns this cell spans. The default is 1.      \sa rowSpan() */
end_comment
begin_function
DECL|function|columnSpan
name|int
name|QTextTableCell
operator|::
name|columnSpan
parameter_list|()
specifier|const
block|{
return|return
name|format
argument_list|()
operator|.
name|tableCellColumnSpan
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTextTableCell::isValid() const      Returns true if this is a valid table cell; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     Returns the first valid cursor position in this cell.      \sa lastCursorPosition() */
end_comment
begin_function
DECL|function|firstCursorPosition
name|QTextCursor
name|QTextTableCell
operator|::
name|firstCursorPosition
parameter_list|()
specifier|const
block|{
return|return
name|QTextCursor
argument_list|(
name|table
operator|->
name|d_func
argument_list|()
operator|->
name|pieceTable
argument_list|,
name|firstPosition
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the last valid cursor position in this cell.      \sa firstCursorPosition() */
end_comment
begin_function
DECL|function|lastCursorPosition
name|QTextCursor
name|QTextTableCell
operator|::
name|lastCursorPosition
parameter_list|()
specifier|const
block|{
return|return
name|QTextCursor
argument_list|(
name|table
operator|->
name|d_func
argument_list|()
operator|->
name|pieceTable
argument_list|,
name|lastPosition
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the first valid position in the document occupied by this cell. */
end_comment
begin_function
DECL|function|firstPosition
name|int
name|QTextTableCell
operator|::
name|firstPosition
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
return|return
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the last valid position in the document occupied by this cell. */
end_comment
begin_function
DECL|function|lastPosition
name|int
name|QTextTableCell
operator|::
name|lastPosition
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
specifier|const
name|QTextTablePrivate
modifier|*
name|td
init|=
name|table
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|table
operator|->
name|d_func
argument_list|()
operator|->
name|findCellIndex
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
name|int
name|f
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|f
operator|=
name|td
operator|->
name|cells
operator|.
name|value
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|td
operator|->
name|fragment_end
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|td
operator|->
name|fragment_end
expr_stmt|;
return|return
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a frame iterator pointing to the beginning of the table's cell.      \sa end() */
end_comment
begin_function
DECL|function|begin
name|QTextFrame
operator|::
name|iterator
name|QTextTableCell
operator|::
name|begin
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|firstPosition
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|lastPosition
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|QTextFrame
operator|::
name|iterator
argument_list|(
cast|const_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|table
argument_list|)
argument_list|,
name|b
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a frame iterator pointing to the end of the table's cell.      \sa begin() */
end_comment
begin_function
DECL|function|end
name|QTextFrame
operator|::
name|iterator
name|QTextTableCell
operator|::
name|end
parameter_list|()
specifier|const
block|{
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|table
operator|->
name|docHandle
argument_list|()
decl_stmt|;
name|int
name|b
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|firstPosition
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|findNode
argument_list|(
name|lastPosition
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|QTextFrame
operator|::
name|iterator
argument_list|(
cast|const_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|table
argument_list|)
argument_list|,
name|e
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCursor QTextTableCell::operator==(const QTextTableCell&other) const      Returns true if this cell object and the \a other cell object     describe the same cell; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTextCursor QTextTableCell::operator!=(const QTextTableCell&other) const      Returns true if this cell object and the \a other cell object     describe different cells; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTextTableCell::~QTextTableCell()      Destroys the table cell. */
end_comment
begin_destructor
DECL|function|~QTextTablePrivate
name|QTextTablePrivate
operator|::
name|~
name|QTextTablePrivate
parameter_list|()
block|{
if|if
condition|(
name|grid
condition|)
name|free
argument_list|(
name|grid
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|createTable
name|QTextTable
modifier|*
name|QTextTablePrivate
operator|::
name|createTable
parameter_list|(
name|QTextDocumentPrivate
modifier|*
name|pieceTable
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
specifier|const
name|QTextTableFormat
modifier|&
name|tableFormat
parameter_list|)
block|{
name|QTextTableFormat
name|fmt
init|=
name|tableFormat
decl_stmt|;
name|fmt
operator|.
name|setColumns
argument_list|(
name|cols
argument_list|)
expr_stmt|;
name|QTextTable
modifier|*
name|table
init|=
name|qobject_cast
argument_list|<
name|QTextTable
operator|*
argument_list|>
argument_list|(
name|pieceTable
operator|->
name|createObject
argument_list|(
name|fmt
argument_list|)
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|pieceTable
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
comment|//     qDebug("---> createTable: rows=%d, cols=%d at %d", rows, cols, pos);
comment|// add block after table
name|QTextCharFormat
name|charFmt
decl_stmt|;
name|charFmt
operator|.
name|setObjectIndex
argument_list|(
name|table
operator|->
name|objectIndex
argument_list|()
argument_list|)
expr_stmt|;
name|charFmt
operator|.
name|setObjectType
argument_list|(
name|QTextFormat
operator|::
name|TableCellObject
argument_list|)
expr_stmt|;
name|int
name|charIdx
init|=
name|pieceTable
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|charFmt
argument_list|)
decl_stmt|;
name|int
name|cellIdx
init|=
name|pieceTable
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|QTextBlockFormat
argument_list|()
argument_list|)
decl_stmt|;
name|QTextTablePrivate
modifier|*
name|d
init|=
name|table
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|blockFragmentUpdates
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|fragment_start
operator|=
name|pieceTable
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|pos
argument_list|,
name|cellIdx
argument_list|,
name|charIdx
argument_list|)
expr_stmt|;
name|d
operator|->
name|cells
operator|.
name|append
argument_list|(
name|d
operator|->
name|fragment_start
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rows
operator|*
name|cols
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|cells
operator|.
name|append
argument_list|(
name|pieceTable
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|pos
argument_list|,
name|cellIdx
argument_list|,
name|charIdx
argument_list|)
argument_list|)
expr_stmt|;
comment|// 	    qDebug("      addCell at %d", pos);
operator|++
name|pos
expr_stmt|;
block|}
name|d
operator|->
name|fragment_end
operator|=
name|pieceTable
operator|->
name|insertBlock
argument_list|(
name|QTextEndOfFrame
argument_list|,
name|pos
argument_list|,
name|cellIdx
argument_list|,
name|charIdx
argument_list|)
expr_stmt|;
comment|// 	qDebug("      addEOR at %d", pos);
operator|++
name|pos
expr_stmt|;
name|d
operator|->
name|blockFragmentUpdates
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|pieceTable
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
return|return
name|table
return|;
block|}
end_function
begin_struct
DECL|struct|QFragmentFindHelper
struct|struct
name|QFragmentFindHelper
block|{
DECL|function|QFragmentFindHelper
specifier|inline
name|QFragmentFindHelper
parameter_list|(
name|int
name|_pos
parameter_list|,
specifier|const
name|QTextDocumentPrivate
operator|::
name|FragmentMap
modifier|&
name|map
parameter_list|)
member_init_list|:
name|pos
argument_list|(
name|_pos
argument_list|)
member_init_list|,
name|fragmentMap
argument_list|(
name|map
argument_list|)
block|{}
DECL|member|pos
name|uint
name|pos
decl_stmt|;
DECL|member|fragmentMap
specifier|const
name|QTextDocumentPrivate
operator|::
name|FragmentMap
modifier|&
name|fragmentMap
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|operator <
name|Q_STATIC_GLOBAL_INLINE_OPERATOR
name|bool
name|operator
name|<
parameter_list|(
name|int
name|fragment
parameter_list|,
specifier|const
name|QFragmentFindHelper
modifier|&
name|helper
parameter_list|)
block|{
return|return
name|helper
operator|.
name|fragmentMap
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
operator|<
name|helper
operator|.
name|pos
return|;
block|}
end_function
begin_function
DECL|function|operator <
name|Q_STATIC_GLOBAL_INLINE_OPERATOR
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QFragmentFindHelper
modifier|&
name|helper
parameter_list|,
name|int
name|fragment
parameter_list|)
block|{
return|return
name|helper
operator|.
name|pos
operator|<
name|helper
operator|.
name|fragmentMap
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findCellIndex
name|int
name|QTextTablePrivate
operator|::
name|findCellIndex
parameter_list|(
name|int
name|fragment
parameter_list|)
specifier|const
block|{
name|QFragmentFindHelper
name|helper
argument_list|(
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
argument_list|,
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|qBinaryFind
argument_list|(
name|cells
operator|.
name|begin
argument_list|()
argument_list|,
name|cells
operator|.
name|end
argument_list|()
argument_list|,
name|helper
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|cells
operator|.
name|end
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|it
operator|-
name|cells
operator|.
name|begin
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|fragmentAdded
name|void
name|QTextTablePrivate
operator|::
name|fragmentAdded
parameter_list|(
name|QChar
name|type
parameter_list|,
name|uint
name|fragment
parameter_list|)
block|{
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|blockFragmentUpdates
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|QTextBeginningOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|cells
operator|.
name|indexOf
argument_list|(
name|fragment
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|uint
name|pos
init|=
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
name|QFragmentFindHelper
name|helper
argument_list|(
name|pos
argument_list|,
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|qLowerBound
argument_list|(
name|cells
operator|.
name|begin
argument_list|()
argument_list|,
name|cells
operator|.
name|end
argument_list|()
argument_list|,
name|helper
argument_list|)
decl_stmt|;
name|cells
operator|.
name|insert
argument_list|(
name|it
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fragment_start
operator|||
name|pos
operator|<
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|fragment_start
argument_list|)
condition|)
name|fragment_start
operator|=
name|fragment
expr_stmt|;
return|return;
block|}
name|QTextFramePrivate
operator|::
name|fragmentAdded
argument_list|(
name|type
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fragmentRemoved
name|void
name|QTextTablePrivate
operator|::
name|fragmentRemoved
parameter_list|(
name|QChar
name|type
parameter_list|,
name|uint
name|fragment
parameter_list|)
block|{
name|dirty
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|blockFragmentUpdates
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|QTextBeginningOfFrame
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|cells
operator|.
name|indexOf
argument_list|(
name|fragment
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cells
operator|.
name|removeAll
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragment_start
operator|==
name|fragment
operator|&&
name|cells
operator|.
name|size
argument_list|()
condition|)
block|{
name|fragment_start
operator|=
name|cells
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fragment_start
operator|!=
name|fragment
condition|)
return|return;
block|}
name|QTextFramePrivate
operator|::
name|fragmentRemoved
argument_list|(
name|type
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     /fn void QTextTablePrivate::update() const      This function is usually called when the table is "dirty".     It seems to update all kind of table information.  */
end_comment
begin_function
DECL|function|update
name|void
name|QTextTablePrivate
operator|::
name|update
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
name|nCols
operator|=
name|q
operator|->
name|format
argument_list|()
operator|.
name|columns
argument_list|()
expr_stmt|;
name|nRows
operator|=
operator|(
name|cells
operator|.
name|size
argument_list|()
operator|+
name|nCols
operator|-
literal|1
operator|)
operator|/
name|nCols
expr_stmt|;
comment|//     qDebug(">>>> QTextTablePrivate::update, nRows=%d, nCols=%d", nRows, nCols);
name|grid
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|grid
argument_list|,
name|nRows
operator|*
name|nCols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|grid
argument_list|,
literal|0
argument_list|,
name|nRows
operator|*
name|nCols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|cellIndices
operator|.
name|resize
argument_list|(
name|cells
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|cell
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cells
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|fragment
init|=
name|cells
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|fragment
argument_list|)
operator|->
name|format
argument_list|)
decl_stmt|;
name|int
name|rowspan
init|=
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
decl_stmt|;
name|int
name|colspan
init|=
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
decl_stmt|;
comment|// skip taken cells
while|while
condition|(
name|cell
operator|<
name|nRows
operator|*
name|nCols
operator|&&
name|grid
index|[
name|cell
index|]
condition|)
operator|++
name|cell
expr_stmt|;
name|int
name|r
init|=
name|cell
operator|/
name|nCols
decl_stmt|;
name|int
name|c
init|=
name|cell
operator|%
name|nCols
decl_stmt|;
name|cellIndices
index|[
name|i
index|]
operator|=
name|cell
expr_stmt|;
if|if
condition|(
name|r
operator|+
name|rowspan
operator|>
name|nRows
condition|)
block|{
name|grid
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|grid
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|r
operator|+
name|rowspan
operator|)
operator|*
name|nCols
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|grid
operator|+
operator|(
name|nRows
operator|*
name|nCols
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|r
operator|+
name|rowspan
operator|-
name|nRows
operator|)
operator|*
name|nCols
argument_list|)
expr_stmt|;
name|nRows
operator|=
name|r
operator|+
name|rowspan
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|c
operator|+
name|colspan
operator|<=
name|nCols
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|rowspan
condition|;
operator|++
name|ii
control|)
block|{
for|for
control|(
name|int
name|jj
init|=
literal|0
init|;
name|jj
operator|<
name|colspan
condition|;
operator|++
name|jj
control|)
block|{
name|Q_ASSERT
argument_list|(
name|grid
index|[
operator|(
name|r
operator|+
name|ii
operator|)
operator|*
name|nCols
operator|+
name|c
operator|+
name|jj
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|grid
index|[
operator|(
name|r
operator|+
name|ii
operator|)
operator|*
name|nCols
operator|+
name|c
operator|+
name|jj
index|]
operator|=
name|fragment
expr_stmt|;
comment|//  		    qDebug("    setting cell %d span=%d/%d at %d/%d", fragment, rowspan, colspan, r+ii, c+jj);
block|}
block|}
block|}
comment|//     qDebug("<<<< end: nRows=%d, nCols=%d", nRows, nCols);
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QTextTable     \reentrant      \brief The QTextTable class represents a table in a QTextDocument.     \inmodule QtGui      \ingroup richtext-processing      A table is a group of cells ordered into rows and columns. Each table     contains at least one row and one column. Each cell contains a block, and     is surrounded by a frame.      Tables are usually created and inserted into a document with the     QTextCursor::insertTable() function.     For example, we can insert a table with three rows and two columns at the     current cursor position in an editor using the following lines of code:      \snippet textdocument-tables/mainwindow.cpp 1     \codeline     \snippet textdocument-tables/mainwindow.cpp 3      The table format is either defined when the table is created or changed     later with setFormat().      The table currently being edited by the cursor is found with     QTextCursor::currentTable(). This allows its format or dimensions to be     changed after it has been inserted into a document.      A table's size can be changed with resize(), or by using     insertRows(), insertColumns(), removeRows(), or removeColumns().     Use cellAt() to retrieve table cells.      The starting and ending positions of table rows can be found by moving     a cursor within a table, and using the rowStart() and rowEnd() functions     to obtain cursors at the start and end of each row.      Rows and columns within a QTextTable can be merged and split using     the mergeCells() and splitCell() functions. However, only cells that span multiple     rows or columns can be split. (Merging or splitting does not increase or decrease     the number of rows and columns.)       Note that if you have merged multiple columns and rows into one cell, you will not     be able to split the merged cell into new cells spanning over more than one row      or column. To be able to split cells spanning over several rows and columns you      need to do this over several iterations.      \table 80%     \row         \li \inlineimage texttable-split.png Original Table         \li Suppose we have a 2x3 table of names and addresses. To merge both         columns in the first row we invoke mergeCells() with \a row = 0,         \a column = 0, \a numRows = 1 and \a numColumns = 2.         \snippet textdocument-texttable/main.cpp 0      \row         \li \inlineimage texttable-merge.png         \li  This gives us the following table. To split the first row of the table         back into two cells, we invoke the splitCell() function with \a numRows         and \a numCols = 1.         \snippet textdocument-texttable/main.cpp 1      \row         \li \inlineimage texttable-split.png Split Table         \li This results in the original table.     \endtable      \sa QTextTableFormat */
end_comment
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QTextTable
name|QTextTable
operator|::
name|QTextTable
parameter_list|(
name|QTextDocument
modifier|*
name|doc
parameter_list|)
member_init_list|:
name|QTextFrame
argument_list|(
operator|*
operator|new
name|QTextTablePrivate
argument_list|(
name|doc
argument_list|)
argument_list|,
name|doc
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal  Destroys the table.  */
end_comment
begin_destructor
DECL|function|~QTextTable
name|QTextTable
operator|::
name|~
name|QTextTable
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn QTextTableCell QTextTable::cellAt(int row, int column) const      Returns the table cell at the given \a row and \a column in the table.      \sa columns(), rows() */
end_comment
begin_function
DECL|function|cellAt
name|QTextTableCell
name|QTextTable
operator|::
name|cellAt
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|d
operator|->
name|nRows
operator|||
name|col
operator|<
literal|0
operator|||
name|col
operator|>=
name|d
operator|->
name|nCols
condition|)
return|return
name|QTextTableCell
argument_list|()
return|;
return|return
name|QTextTableCell
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|grid
index|[
name|row
operator|*
name|d
operator|->
name|nCols
operator|+
name|col
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the table cell that contains the character at the given \a position     in the document. */
end_comment
begin_function
DECL|function|cellAt
name|QTextTableCell
name|QTextTable
operator|::
name|cellAt
parameter_list|(
name|int
name|position
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
name|uint
name|pos
init|=
operator|(
name|uint
operator|)
name|position
decl_stmt|;
specifier|const
name|QTextDocumentPrivate
operator|::
name|FragmentMap
modifier|&
name|map
init|=
name|d
operator|->
name|pieceTable
operator|->
name|fragmentMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|position
operator|<
literal|0
operator|||
name|map
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_start
argument_list|)
operator|>=
name|pos
operator|||
name|map
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_end
argument_list|)
operator|<
name|pos
condition|)
return|return
name|QTextTableCell
argument_list|()
return|;
name|QFragmentFindHelper
name|helper
argument_list|(
name|position
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|qLowerBound
argument_list|(
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|cells
operator|.
name|end
argument_list|()
argument_list|,
name|helper
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
condition|)
operator|--
name|it
expr_stmt|;
return|return
name|QTextTableCell
argument_list|(
name|this
argument_list|,
operator|*
name|it
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextTableCell QTextTable::cellAt(const QTextCursor&cursor) const      \overload      Returns the table cell containing the given \a cursor. */
end_comment
begin_function
DECL|function|cellAt
name|QTextTableCell
name|QTextTable
operator|::
name|cellAt
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
return|return
name|cellAt
argument_list|(
name|c
operator|.
name|position
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::resize(int rows, int columns)      Resizes the table to contain the required number of \a rows and \a columns.      \sa insertRows(), insertColumns(), removeRows(), removeColumns() */
end_comment
begin_function
DECL|function|resize
name|void
name|QTextTable
operator|::
name|resize
parameter_list|(
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
name|int
name|nRows
init|=
name|this
operator|->
name|rows
argument_list|()
decl_stmt|;
name|int
name|nCols
init|=
name|this
operator|->
name|columns
argument_list|()
decl_stmt|;
if|if
condition|(
name|rows
operator|==
name|nRows
operator|&&
name|cols
operator|==
name|nCols
condition|)
return|return;
name|d
operator|->
name|pieceTable
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|nCols
operator|<
name|cols
condition|)
name|insertColumns
argument_list|(
name|nCols
argument_list|,
name|cols
operator|-
name|nCols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nCols
operator|>
name|cols
condition|)
name|removeColumns
argument_list|(
name|cols
argument_list|,
name|nCols
operator|-
name|cols
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRows
operator|<
name|rows
condition|)
name|insertRows
argument_list|(
name|nRows
argument_list|,
name|rows
operator|-
name|nRows
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nRows
operator|>
name|rows
condition|)
name|removeRows
argument_list|(
name|rows
argument_list|,
name|nRows
operator|-
name|rows
argument_list|)
expr_stmt|;
name|d
operator|->
name|pieceTable
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::insertRows(int index, int rows)      Inserts a number of \a rows before the row with the specified \a index.      \sa resize(), insertColumns(), removeRows(), removeColumns(), appendRows(), appendColumns() */
end_comment
begin_function
DECL|function|insertRows
name|void
name|QTextTable
operator|::
name|insertRows
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|d
operator|->
name|nRows
operator|||
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
name|d
operator|->
name|nRows
expr_stmt|;
comment|//     qDebug()<< "-------- insertRows"<< pos<< num;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|int
name|extended
init|=
literal|0
decl_stmt|;
name|int
name|insert_before
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<
name|d
operator|->
name|nRows
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nCols
condition|;
operator|++
name|i
control|)
block|{
name|int
name|cell
init|=
name|d
operator|->
name|grid
index|[
name|pos
operator|*
name|d
operator|->
name|nCols
operator|+
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cell
operator|==
name|d
operator|->
name|grid
index|[
operator|(
name|pos
operator|-
literal|1
operator|)
operator|*
name|d
operator|->
name|nCols
operator|+
name|i
index|]
condition|)
block|{
comment|// cell spans the insertion place, extend it
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|cell
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
operator|+
name|num
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|extended
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insert_before
condition|)
block|{
name|insert_before
operator|=
name|cell
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|insert_before
operator|=
operator|(
name|pos
operator|==
literal|0
condition|?
name|d
operator|->
name|grid
index|[
literal|0
index|]
else|:
name|d
operator|->
name|fragment_end
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extended
operator|<
name|d
operator|->
name|nCols
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|insert_before
argument_list|)
expr_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|insert_before
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|fmt
operator|.
name|objectIndex
argument_list|()
operator|==
name|objectIndex
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|it
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|cfmt
init|=
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|int
name|bfmt
init|=
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|QTextBlockFormat
argument_list|()
argument_list|)
decl_stmt|;
comment|//         qDebug("inserting %d cells, nCols=%d extended=%d", num*(d->nCols-extended), d->nCols, extended);
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
operator|*
operator|(
name|d
operator|->
name|nCols
operator|-
name|extended
operator|)
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|pos
argument_list|,
name|bfmt
argument_list|,
name|cfmt
argument_list|,
name|QTextUndoCommand
operator|::
name|MoveCursor
argument_list|)
expr_stmt|;
block|}
comment|//     qDebug()<< "-------- end insertRows"<< pos<< num;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::insertColumns(int index, int columns)      Inserts a number of \a columns before the column with the specified \a index.      \sa insertRows(), resize(), removeRows(), removeColumns(), appendRows(), appendColumns() */
end_comment
begin_function
DECL|function|insertColumns
name|void
name|QTextTable
operator|::
name|insertColumns
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|d
operator|->
name|nCols
operator|||
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
name|d
operator|->
name|nCols
expr_stmt|;
comment|//     qDebug()<< "-------- insertCols"<< pos<< num;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|extendedSpans
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nRows
condition|;
operator|++
name|i
control|)
block|{
name|int
name|cell
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|nRows
operator|-
literal|1
operator|&&
name|pos
operator|==
name|d
operator|->
name|nCols
condition|)
name|cell
operator|=
name|d
operator|->
name|fragment_end
expr_stmt|;
else|else
name|cell
operator|=
name|d
operator|->
name|grid
index|[
name|i
operator|*
name|d
operator|->
name|nCols
operator|+
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<
name|d
operator|->
name|nCols
operator|&&
name|cell
operator|==
name|d
operator|->
name|grid
index|[
name|i
operator|*
name|d
operator|->
name|nCols
operator|+
name|pos
operator|-
literal|1
index|]
condition|)
block|{
comment|// cell spans the insertion place, extend it
if|if
condition|(
operator|!
name|extendedSpans
operator|.
name|contains
argument_list|(
name|cell
argument_list|)
condition|)
block|{
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|cell
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
operator|+
name|num
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|extendedSpans
operator|<<
name|cell
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the next cell is spanned from the row above, we need to find the right position             to insert to */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|pos
operator|<
name|d
operator|->
name|nCols
operator|&&
name|cell
operator|==
name|d
operator|->
name|grid
index|[
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
name|d
operator|->
name|nCols
operator|+
name|pos
index|]
condition|)
block|{
name|int
name|gridIndex
init|=
name|i
operator|*
name|d
operator|->
name|nCols
operator|+
name|pos
decl_stmt|;
specifier|const
name|int
name|gridEnd
init|=
name|d
operator|->
name|nRows
operator|*
name|d
operator|->
name|nCols
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|gridIndex
operator|<
name|gridEnd
operator|&&
name|cell
operator|==
name|d
operator|->
name|grid
index|[
name|gridIndex
index|]
condition|)
block|{
operator|++
name|gridIndex
expr_stmt|;
block|}
if|if
condition|(
name|gridIndex
operator|==
name|gridEnd
condition|)
name|cell
operator|=
name|d
operator|->
name|fragment_end
expr_stmt|;
else|else
name|cell
operator|=
name|d
operator|->
name|grid
index|[
name|gridIndex
index|]
expr_stmt|;
block|}
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|cell
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|c
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|fmt
operator|.
name|objectIndex
argument_list|()
operator|==
name|objectIndex
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|position
init|=
name|it
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|cfmt
init|=
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|int
name|bfmt
init|=
name|p
operator|->
name|formatCollection
argument_list|()
operator|->
name|indexForFormat
argument_list|(
name|QTextBlockFormat
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|position
argument_list|,
name|bfmt
argument_list|,
name|cfmt
argument_list|,
name|QTextUndoCommand
operator|::
name|MoveCursor
argument_list|)
expr_stmt|;
block|}
block|}
name|QTextTableFormat
name|tfmt
init|=
name|format
argument_list|()
decl_stmt|;
name|tfmt
operator|.
name|setColumns
argument_list|(
name|tfmt
operator|.
name|columns
argument_list|()
operator|+
name|num
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QTextLength
argument_list|>
name|columnWidths
init|=
name|tfmt
operator|.
name|columnWidthConstraints
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|columnWidths
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|num
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|columnWidths
operator|.
name|insert
argument_list|(
name|pos
argument_list|,
name|columnWidths
index|[
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
literal|1
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|tfmt
operator|.
name|setColumnWidthConstraints
argument_list|(
name|columnWidths
argument_list|)
expr_stmt|;
name|QTextObject
operator|::
name|setFormat
argument_list|(
name|tfmt
argument_list|)
expr_stmt|;
comment|//     qDebug()<< "-------- end insertCols"<< pos<< num;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Appends \a count rows at the bottom of the table.      \sa insertColumns(), insertRows(), resize(), removeRows(), removeColumns(), appendColumns() */
end_comment
begin_function
DECL|function|appendRows
name|void
name|QTextTable
operator|::
name|appendRows
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|insertRows
argument_list|(
name|rows
argument_list|()
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Appends \a count columns at the right side of the table.      \sa insertColumns(), insertRows(), resize(), removeRows(), removeColumns(), appendRows() */
end_comment
begin_function
DECL|function|appendColumns
name|void
name|QTextTable
operator|::
name|appendColumns
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|insertColumns
argument_list|(
name|columns
argument_list|()
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::removeRows(int index, int rows)      Removes a number of \a rows starting with the row at the specified \a index.      \sa insertRows(), insertColumns(), resize(), removeColumns(), appendRows(), appendColumns() */
end_comment
begin_function
DECL|function|removeRows
name|void
name|QTextTable
operator|::
name|removeRows
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
comment|//     qDebug()<< "-------- removeRows"<< pos<< num;
if|if
condition|(
name|num
operator|<=
literal|0
operator|||
name|pos
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|d
operator|->
name|nRows
condition|)
return|return;
if|if
condition|(
name|pos
operator|+
name|num
operator|>
name|d
operator|->
name|nRows
condition|)
name|num
operator|=
name|d
operator|->
name|nRows
operator|-
name|pos
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|collection
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
comment|// delete whole table?
if|if
condition|(
name|pos
operator|==
literal|0
operator|&&
name|num
operator|==
name|d
operator|->
name|nRows
condition|)
block|{
specifier|const
name|int
name|pos
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_start
argument_list|)
decl_stmt|;
name|p
operator|->
name|remove
argument_list|(
name|pos
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_end
argument_list|)
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|aboutToRemoveCell
argument_list|(
name|cellAt
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
operator|.
name|firstPosition
argument_list|()
argument_list|,
name|cellAt
argument_list|(
name|pos
operator|+
name|num
operator|-
literal|1
argument_list|,
name|d
operator|->
name|nCols
operator|-
literal|1
argument_list|)
operator|.
name|lastPosition
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|touchedCells
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
name|pos
init|;
name|r
operator|<
name|pos
operator|+
name|num
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|d
operator|->
name|nCols
condition|;
operator|++
name|c
control|)
block|{
name|int
name|cell
init|=
name|d
operator|->
name|grid
index|[
name|r
operator|*
name|d
operator|->
name|nCols
operator|+
name|c
index|]
decl_stmt|;
if|if
condition|(
name|touchedCells
operator|.
name|contains
argument_list|(
name|cell
argument_list|)
condition|)
continue|continue;
name|touchedCells
operator|<<
name|cell
expr_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|cell
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|collection
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|int
name|span
init|=
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|>
literal|1
condition|)
block|{
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
name|span
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remove cell
name|int
name|index
init|=
name|d
operator|->
name|cells
operator|.
name|indexOf
argument_list|(
name|cell
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|f_end
init|=
name|index
operator|<
name|d
operator|->
name|cells
operator|.
name|size
argument_list|()
condition|?
name|d
operator|->
name|cells
operator|.
name|at
argument_list|(
name|index
argument_list|)
else|:
name|d
operator|->
name|fragment_end
decl_stmt|;
name|p
operator|->
name|remove
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|f_end
argument_list|)
operator|-
name|it
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
comment|//     qDebug()<< "-------- end removeRows"<< pos<< num;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::removeColumns(int index, int columns)      Removes a number of \a columns starting with the column at the specified     \a index.      \sa insertRows(), insertColumns(), removeRows(), resize(), appendRows(), appendColumns() */
end_comment
begin_function
DECL|function|removeColumns
name|void
name|QTextTable
operator|::
name|removeColumns
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
comment|//     qDebug()<< "-------- removeCols"<< pos<< num;
if|if
condition|(
name|num
operator|<=
literal|0
operator|||
name|pos
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|d
operator|->
name|nCols
condition|)
return|return;
if|if
condition|(
name|pos
operator|+
name|num
operator|>
name|d
operator|->
name|nCols
condition|)
name|pos
operator|=
name|d
operator|->
name|nCols
operator|-
name|num
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|collection
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
comment|// delete whole table?
if|if
condition|(
name|pos
operator|==
literal|0
operator|&&
name|num
operator|==
name|d
operator|->
name|nCols
condition|)
block|{
specifier|const
name|int
name|pos
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_start
argument_list|)
decl_stmt|;
name|p
operator|->
name|remove
argument_list|(
name|pos
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|d
operator|->
name|fragment_end
argument_list|)
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|aboutToRemoveCell
argument_list|(
name|cellAt
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
operator|.
name|firstPosition
argument_list|()
argument_list|,
name|cellAt
argument_list|(
name|d
operator|->
name|nRows
operator|-
literal|1
argument_list|,
name|pos
operator|+
name|num
operator|-
literal|1
argument_list|)
operator|.
name|lastPosition
argument_list|()
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|touchedCells
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|d
operator|->
name|nRows
condition|;
operator|++
name|r
control|)
block|{
for|for
control|(
name|int
name|c
init|=
name|pos
init|;
name|c
operator|<
name|pos
operator|+
name|num
condition|;
operator|++
name|c
control|)
block|{
name|int
name|cell
init|=
name|d
operator|->
name|grid
index|[
name|r
operator|*
name|d
operator|->
name|nCols
operator|+
name|c
index|]
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|cell
argument_list|)
decl_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|collection
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
name|int
name|span
init|=
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|touchedCells
operator|.
name|contains
argument_list|(
name|cell
argument_list|)
operator|&&
name|span
operator|<=
literal|1
condition|)
continue|continue;
name|touchedCells
operator|<<
name|cell
expr_stmt|;
if|if
condition|(
name|span
operator|>
literal|1
condition|)
block|{
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
name|span
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remove cell
name|int
name|index
init|=
name|d
operator|->
name|cells
operator|.
name|indexOf
argument_list|(
name|cell
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|f_end
init|=
name|index
operator|<
name|d
operator|->
name|cells
operator|.
name|size
argument_list|()
condition|?
name|d
operator|->
name|cells
operator|.
name|at
argument_list|(
name|index
argument_list|)
else|:
name|d
operator|->
name|fragment_end
decl_stmt|;
name|p
operator|->
name|remove
argument_list|(
name|it
operator|.
name|position
argument_list|()
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|f_end
argument_list|)
operator|-
name|it
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QTextTableFormat
name|tfmt
init|=
name|format
argument_list|()
decl_stmt|;
name|tfmt
operator|.
name|setColumns
argument_list|(
name|tfmt
operator|.
name|columns
argument_list|()
operator|-
name|num
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QTextLength
argument_list|>
name|columnWidths
init|=
name|tfmt
operator|.
name|columnWidthConstraints
argument_list|()
decl_stmt|;
if|if
condition|(
name|columnWidths
operator|.
name|count
argument_list|()
operator|>
name|pos
condition|)
block|{
name|columnWidths
operator|.
name|remove
argument_list|(
name|pos
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|tfmt
operator|.
name|setColumnWidthConstraints
argument_list|(
name|columnWidths
argument_list|)
expr_stmt|;
block|}
name|QTextObject
operator|::
name|setFormat
argument_list|(
name|tfmt
argument_list|)
expr_stmt|;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
comment|//     qDebug()<< "-------- end removeCols"<< pos<< num;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Merges the cell at the specified \a row and \a column with the adjacent cells     into one cell. The new cell will span \a numRows rows and \a numCols columns.     If \a numRows or \a numCols is less than the current number of rows or columns     the cell spans then this method does nothing.      \sa splitCell() */
end_comment
begin_function
DECL|function|mergeCells
name|void
name|QTextTable
operator|::
name|mergeCells
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|numRows
parameter_list|,
name|int
name|numCols
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|fc
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
specifier|const
name|QTextTableCell
name|cell
init|=
name|cellAt
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cell
operator|.
name|isValid
argument_list|()
operator|||
name|row
operator|!=
name|cell
operator|.
name|row
argument_list|()
operator|||
name|column
operator|!=
name|cell
operator|.
name|column
argument_list|()
condition|)
return|return;
name|QTextCharFormat
name|fmt
init|=
name|cell
operator|.
name|format
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rowSpan
init|=
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
decl_stmt|;
specifier|const
name|int
name|colSpan
init|=
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|qMin
argument_list|(
name|numRows
argument_list|,
name|rows
argument_list|()
operator|-
name|cell
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|numCols
operator|=
name|qMin
argument_list|(
name|numCols
argument_list|,
name|columns
argument_list|()
operator|-
name|cell
operator|.
name|column
argument_list|()
argument_list|)
expr_stmt|;
comment|// nothing to merge?
if|if
condition|(
name|numRows
operator|<
name|rowSpan
operator|||
name|numCols
operator|<
name|colSpan
condition|)
return|return;
comment|// check the edges of the merge rect to make sure no cell spans the edge
for|for
control|(
name|int
name|r
init|=
name|row
init|;
name|r
operator|<
name|row
operator|+
name|numRows
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|cellAt
argument_list|(
name|r
argument_list|,
name|column
argument_list|)
operator|==
name|cellAt
argument_list|(
name|r
argument_list|,
name|column
operator|-
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cellAt
argument_list|(
name|r
argument_list|,
name|column
operator|+
name|numCols
argument_list|)
operator|==
name|cellAt
argument_list|(
name|r
argument_list|,
name|column
operator|+
name|numCols
operator|-
literal|1
argument_list|)
condition|)
return|return;
block|}
for|for
control|(
name|int
name|c
init|=
name|column
init|;
name|c
operator|<
name|column
operator|+
name|numCols
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|cellAt
argument_list|(
name|row
argument_list|,
name|c
argument_list|)
operator|==
name|cellAt
argument_list|(
name|row
operator|-
literal|1
argument_list|,
name|c
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cellAt
argument_list|(
name|row
operator|+
name|numRows
argument_list|,
name|c
argument_list|)
operator|==
name|cellAt
argument_list|(
name|row
operator|+
name|numRows
operator|-
literal|1
argument_list|,
name|c
argument_list|)
condition|)
return|return;
block|}
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
specifier|const
name|int
name|origCellPosition
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|cellFragment
init|=
name|d
operator|->
name|grid
index|[
name|row
operator|*
name|d
operator|->
name|nCols
operator|+
name|column
index|]
decl_stmt|;
comment|// find the position at which to insert the contents of the merged cells
name|QFragmentFindHelper
name|helper
argument_list|(
name|origCellPosition
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|qBinaryFind
argument_list|(
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|cells
operator|.
name|end
argument_list|()
argument_list|,
name|helper
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|it
operator|!=
name|d
operator|->
name|cells
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|*
name|it
operator|==
name|cellFragment
argument_list|)
expr_stmt|;
specifier|const
name|int
name|insertCellIndex
init|=
name|it
operator|-
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
decl_stmt|;
name|int
name|insertFragment
init|=
name|d
operator|->
name|cells
operator|.
name|value
argument_list|(
name|insertCellIndex
operator|+
literal|1
argument_list|,
name|d
operator|->
name|fragment_end
argument_list|)
decl_stmt|;
name|uint
name|insertPos
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|insertFragment
argument_list|)
decl_stmt|;
name|d
operator|->
name|blockFragmentUpdates
operator|=
literal|true
expr_stmt|;
name|bool
name|rowHasText
init|=
name|cell
operator|.
name|firstCursorPosition
argument_list|()
operator|.
name|block
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|bool
name|needsParagraph
init|=
name|rowHasText
operator|&&
name|colSpan
operator|==
name|numCols
decl_stmt|;
comment|// find all cells that will be erased by the merge
for|for
control|(
name|int
name|r
init|=
name|row
init|;
name|r
operator|<
name|row
operator|+
name|numRows
condition|;
operator|++
name|r
control|)
block|{
name|int
name|firstColumn
init|=
name|r
operator|<
name|row
operator|+
name|rowSpan
condition|?
name|column
operator|+
name|colSpan
else|:
name|column
decl_stmt|;
comment|// don't recompute the cell index for the first row
name|int
name|firstCellIndex
init|=
name|r
operator|==
name|row
condition|?
name|insertCellIndex
operator|+
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|cellIndex
init|=
name|firstCellIndex
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
name|firstColumn
init|;
name|c
operator|<
name|column
operator|+
name|numCols
condition|;
operator|++
name|c
control|)
block|{
specifier|const
name|int
name|fragment
init|=
name|d
operator|->
name|grid
index|[
name|r
operator|*
name|d
operator|->
name|nCols
operator|+
name|c
index|]
decl_stmt|;
comment|// already handled?
if|if
condition|(
name|fragment
operator|==
name|cellFragment
condition|)
continue|continue;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|fragment
argument_list|)
decl_stmt|;
name|uint
name|pos
init|=
name|it
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstCellIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|QFragmentFindHelper
name|helper
argument_list|(
name|pos
argument_list|,
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|qBinaryFind
argument_list|(
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|cells
operator|.
name|end
argument_list|()
argument_list|,
name|helper
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|it
operator|!=
name|d
operator|->
name|cells
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|*
name|it
operator|==
name|fragment
argument_list|)
expr_stmt|;
name|firstCellIndex
operator|=
name|cellIndex
operator|=
name|it
operator|-
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
operator|++
name|cellIndex
expr_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|fc
operator|->
name|charFormat
argument_list|(
name|it
operator|->
name|format
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cellRowSpan
init|=
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
decl_stmt|;
specifier|const
name|int
name|cellColSpan
init|=
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
decl_stmt|;
comment|// update the grid for this cell
for|for
control|(
name|int
name|i
init|=
name|r
init|;
name|i
operator|<
name|r
operator|+
name|cellRowSpan
condition|;
operator|++
name|i
control|)
for|for
control|(
name|int
name|j
init|=
name|c
init|;
name|j
operator|<
name|c
operator|+
name|cellColSpan
condition|;
operator|++
name|j
control|)
name|d
operator|->
name|grid
index|[
name|i
operator|*
name|d
operator|->
name|nCols
operator|+
name|j
index|]
operator|=
name|cellFragment
expr_stmt|;
comment|// erase the cell marker
name|p
operator|->
name|remove
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|nextFragment
init|=
name|d
operator|->
name|cells
operator|.
name|value
argument_list|(
name|cellIndex
argument_list|,
name|d
operator|->
name|fragment_end
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|nextPos
init|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|nextFragment
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nextPos
operator|>=
name|pos
argument_list|)
expr_stmt|;
comment|// merge the contents of the cell (if not empty)
if|if
condition|(
name|nextPos
operator|>
name|pos
condition|)
block|{
if|if
condition|(
name|needsParagraph
condition|)
block|{
name|needsParagraph
operator|=
literal|false
expr_stmt|;
name|QTextCursor
argument_list|(
name|p
argument_list|,
name|insertPos
operator|++
argument_list|)
operator|.
name|insertBlock
argument_list|()
expr_stmt|;
name|p
operator|->
name|move
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|insertPos
argument_list|,
name|nextPos
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rowHasText
condition|)
block|{
name|QTextCursor
argument_list|(
name|p
argument_list|,
name|insertPos
operator|++
argument_list|)
operator|.
name|insertText
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|move
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|insertPos
argument_list|,
name|nextPos
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|move
argument_list|(
name|pos
argument_list|,
name|insertPos
argument_list|,
name|nextPos
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
name|insertPos
operator|+=
name|nextPos
operator|-
name|pos
expr_stmt|;
name|rowHasText
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rowHasText
condition|)
block|{
name|needsParagraph
operator|=
literal|true
expr_stmt|;
name|rowHasText
operator|=
literal|false
expr_stmt|;
block|}
comment|// erase cells from last row
if|if
condition|(
name|firstCellIndex
operator|>=
literal|0
condition|)
block|{
name|d
operator|->
name|cellIndices
operator|.
name|remove
argument_list|(
name|firstCellIndex
argument_list|,
name|cellIndex
operator|-
name|firstCellIndex
argument_list|)
expr_stmt|;
name|d
operator|->
name|cells
operator|.
name|erase
argument_list|(
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
operator|+
name|firstCellIndex
argument_list|,
name|d
operator|->
name|cells
operator|.
name|begin
argument_list|()
operator|+
name|cellIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|fragment_start
operator|=
name|d
operator|->
name|cells
operator|.
name|first
argument_list|()
expr_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
name|numRows
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
name|numCols
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|origCellPosition
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|d
operator|->
name|blockFragmentUpdates
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.1      Merges the cells selected by the provided \a cursor.      \sa splitCell() */
end_comment
begin_function
DECL|function|mergeCells
name|void
name|QTextTable
operator|::
name|mergeCells
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|cursor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cursor
operator|.
name|hasComplexSelection
argument_list|()
condition|)
return|return;
name|int
name|firstRow
decl_stmt|,
name|numRows
decl_stmt|,
name|firstColumn
decl_stmt|,
name|numColumns
decl_stmt|;
name|cursor
operator|.
name|selectedTableCells
argument_list|(
operator|&
name|firstRow
argument_list|,
operator|&
name|numRows
argument_list|,
operator|&
name|firstColumn
argument_list|,
operator|&
name|numColumns
argument_list|)
expr_stmt|;
name|mergeCells
argument_list|(
name|firstRow
argument_list|,
name|firstColumn
argument_list|,
name|numRows
argument_list|,
name|numColumns
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Splits the specified cell at \a row and \a column into an array of multiple     cells with dimensions specified by \a numRows and \a numCols.      \note It is only possible to split cells that span multiple rows or columns, such as rows     that have been merged using mergeCells().      \sa mergeCells() */
end_comment
begin_function
DECL|function|splitCell
name|void
name|QTextTable
operator|::
name|splitCell
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|numRows
parameter_list|,
name|int
name|numCols
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextFormatCollection
modifier|*
name|c
init|=
name|p
operator|->
name|formatCollection
argument_list|()
decl_stmt|;
specifier|const
name|QTextTableCell
name|cell
init|=
name|cellAt
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cell
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|row
operator|=
name|cell
operator|.
name|row
argument_list|()
expr_stmt|;
name|column
operator|=
name|cell
operator|.
name|column
argument_list|()
expr_stmt|;
name|QTextCharFormat
name|fmt
init|=
name|cell
operator|.
name|format
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rowSpan
init|=
name|fmt
operator|.
name|tableCellRowSpan
argument_list|()
decl_stmt|;
specifier|const
name|int
name|colSpan
init|=
name|fmt
operator|.
name|tableCellColumnSpan
argument_list|()
decl_stmt|;
comment|// nothing to split?
if|if
condition|(
name|numRows
operator|>
name|rowSpan
operator|||
name|numCols
operator|>
name|colSpan
condition|)
return|return;
name|p
operator|->
name|beginEditBlock
argument_list|()
expr_stmt|;
specifier|const
name|int
name|origCellPosition
init|=
name|cell
operator|.
name|firstPosition
argument_list|()
operator|-
literal|1
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|int
argument_list|>
name|rowPositions
argument_list|(
name|rowSpan
argument_list|)
decl_stmt|;
name|rowPositions
index|[
literal|0
index|]
operator|=
name|cell
operator|.
name|lastPosition
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|r
init|=
name|row
operator|+
literal|1
init|;
name|r
operator|<
name|row
operator|+
name|rowSpan
condition|;
operator|++
name|r
control|)
block|{
comment|// find the cell before which to insert the new cell markers
name|int
name|gridIndex
init|=
name|r
operator|*
name|d
operator|->
name|nCols
operator|+
name|column
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|iterator
name|it
init|=
name|qUpperBound
argument_list|(
name|d
operator|->
name|cellIndices
operator|.
name|begin
argument_list|()
argument_list|,
name|d
operator|->
name|cellIndices
operator|.
name|end
argument_list|()
argument_list|,
name|gridIndex
argument_list|)
decl_stmt|;
name|int
name|cellIndex
init|=
name|it
operator|-
name|d
operator|->
name|cellIndices
operator|.
name|begin
argument_list|()
decl_stmt|;
name|int
name|fragment
init|=
name|d
operator|->
name|cells
operator|.
name|value
argument_list|(
name|cellIndex
argument_list|,
name|d
operator|->
name|fragment_end
argument_list|)
decl_stmt|;
name|rowPositions
index|[
name|r
operator|-
name|row
index|]
operator|=
name|p
operator|->
name|fragmentMap
argument_list|()
operator|.
name|position
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|fmtIndex
init|=
name|c
operator|->
name|indexForFormat
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
specifier|const
name|int
name|blockIndex
init|=
name|p
operator|->
name|blockMap
argument_list|()
operator|.
name|find
argument_list|(
name|cell
operator|.
name|lastPosition
argument_list|()
argument_list|)
operator|->
name|format
decl_stmt|;
name|int
name|insertAdjustement
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRows
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|colSpan
operator|-
name|numCols
condition|;
operator|++
name|c
control|)
name|p
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|rowPositions
index|[
name|i
index|]
operator|+
name|insertAdjustement
operator|+
name|c
argument_list|,
name|blockIndex
argument_list|,
name|fmtIndex
argument_list|)
expr_stmt|;
name|insertAdjustement
operator|+=
name|colSpan
operator|-
name|numCols
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|numRows
init|;
name|i
operator|<
name|rowSpan
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|colSpan
condition|;
operator|++
name|c
control|)
name|p
operator|->
name|insertBlock
argument_list|(
name|QTextBeginningOfFrame
argument_list|,
name|rowPositions
index|[
name|i
index|]
operator|+
name|insertAdjustement
operator|+
name|c
argument_list|,
name|blockIndex
argument_list|,
name|fmtIndex
argument_list|)
expr_stmt|;
name|insertAdjustement
operator|+=
name|colSpan
expr_stmt|;
block|}
name|fmt
operator|.
name|setTableCellRowSpan
argument_list|(
name|numRows
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|setTableCellColumnSpan
argument_list|(
name|numCols
argument_list|)
expr_stmt|;
name|p
operator|->
name|setCharFormat
argument_list|(
name|origCellPosition
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|p
operator|->
name|endEditBlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of rows in the table.      \sa columns() */
end_comment
begin_function
DECL|function|rows
name|int
name|QTextTable
operator|::
name|rows
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|nRows
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of columns in the table.      \sa rows() */
end_comment
begin_function
DECL|function|columns
name|int
name|QTextTable
operator|::
name|columns
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dirty
condition|)
name|d
operator|->
name|update
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|nCols
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|void QTextTable::mergeCells(const QTextCursor&selection) { }
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QTextCursor QTextTable::rowStart(const QTextCursor&cursor) const      Returns a cursor pointing to the start of the row that contains the     given \a cursor.      \sa rowEnd() */
end_comment
begin_function
DECL|function|rowStart
name|QTextCursor
name|QTextTable
operator|::
name|rowStart
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
name|QTextTableCell
name|cell
init|=
name|cellAt
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cell
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QTextCursor
argument_list|()
return|;
name|int
name|row
init|=
name|cell
operator|.
name|row
argument_list|()
decl_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|d
operator|->
name|grid
index|[
name|row
operator|*
name|d
operator|->
name|nCols
index|]
argument_list|)
decl_stmt|;
return|return
name|QTextCursor
argument_list|(
name|p
argument_list|,
name|it
operator|.
name|position
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCursor QTextTable::rowEnd(const QTextCursor&cursor) const      Returns a cursor pointing to the end of the row that contains the given     \a cursor.      \sa rowStart() */
end_comment
begin_function
DECL|function|rowEnd
name|QTextCursor
name|QTextTable
operator|::
name|rowEnd
parameter_list|(
specifier|const
name|QTextCursor
modifier|&
name|c
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTextTable
argument_list|)
expr_stmt|;
name|QTextTableCell
name|cell
init|=
name|cellAt
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cell
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QTextCursor
argument_list|()
return|;
name|int
name|row
init|=
name|cell
operator|.
name|row
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|fragment
init|=
name|row
operator|<
name|d
operator|->
name|nRows
condition|?
name|d
operator|->
name|grid
index|[
name|row
operator|*
name|d
operator|->
name|nCols
index|]
else|:
name|d
operator|->
name|fragment_end
decl_stmt|;
name|QTextDocumentPrivate
modifier|*
name|p
init|=
name|d
operator|->
name|pieceTable
decl_stmt|;
name|QTextDocumentPrivate
operator|::
name|FragmentIterator
name|it
argument_list|(
operator|&
name|p
operator|->
name|fragmentMap
argument_list|()
argument_list|,
name|fragment
argument_list|)
decl_stmt|;
return|return
name|QTextCursor
argument_list|(
name|p
argument_list|,
name|it
operator|.
name|position
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QTextTable::setFormat(const QTextTableFormat&format)      Sets the table's \a format.      \sa format() */
end_comment
begin_function
DECL|function|setFormat
name|void
name|QTextTable
operator|::
name|setFormat
parameter_list|(
specifier|const
name|QTextTableFormat
modifier|&
name|format
parameter_list|)
block|{
name|QTextTableFormat
name|fmt
init|=
name|format
decl_stmt|;
comment|// don't try to change the number of table columns from here
name|fmt
operator|.
name|setColumns
argument_list|(
name|columns
argument_list|()
argument_list|)
expr_stmt|;
name|QTextObject
operator|::
name|setFormat
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextTableFormat QTextTable::format() const      Returns the table's format.      \sa setFormat() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
