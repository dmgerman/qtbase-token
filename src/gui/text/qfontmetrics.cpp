begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qfont.h"
end_include
begin_include
include|#
directive|include
file|"qpaintdevice.h"
end_include
begin_include
include|#
directive|include
file|"qfontmetrics.h"
end_include
begin_include
include|#
directive|include
file|"qfont_p.h"
end_include
begin_include
include|#
directive|include
file|"qfontengine_p.h"
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
specifier|extern
name|void
name|qt_format_text
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|_r
parameter_list|,
name|int
name|tf
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|QRectF
modifier|*
name|brect
parameter_list|,
name|int
name|tabStops
parameter_list|,
name|int
modifier|*
name|tabArray
parameter_list|,
name|int
name|tabArrayLen
parameter_list|,
name|QPainter
modifier|*
name|painter
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*****************************************************************************   QFontMetrics member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QFontMetrics     \reentrant     \inmodule QtGui      \brief The QFontMetrics class provides font metrics information.      \ingroup painting     \ingroup shared      QFontMetrics functions calculate the size of characters and     strings for a given font. There are three ways you can create a     QFontMetrics object:      \list 1     \li Calling the QFontMetrics constructor with a QFont creates a     font metrics object for a screen-compatible font, i.e. the font     cannot be a printer font. If the font is changed     later, the font metrics object is \e not updated.      (Note: If you use a printer font the values returned may be     inaccurate. Printer fonts are not always accessible so the nearest     screen font is used if a printer font is supplied.)      \li QWidget::fontMetrics() returns the font metrics for a widget's     font. This is equivalent to QFontMetrics(widget->font()). If the     widget's font is changed later, the font metrics object is \e not     updated.      \li QPainter::fontMetrics() returns the font metrics for a     painter's current font. If the painter's font is changed later, the     font metrics object is \e not updated.     \endlist      Once created, the object provides functions to access the     individual metrics of the font, its characters, and for strings     rendered in the font.      There are several functions that operate on the font: ascent(),     descent(), height(), leading() and lineSpacing() return the basic     size properties of the font. The underlinePos(), overlinePos(),     strikeOutPos() and lineWidth() functions, return the properties of     the line that underlines, overlines or strikes out the     characters. These functions are all fast.      There are also some functions that operate on the set of glyphs in     the font: minLeftBearing(), minRightBearing() and maxWidth().     These are by necessity slow, and we recommend avoiding them if     possible.      For each character, you can get its width(), leftBearing() and     rightBearing() and find out whether it is in the font using     inFont(). You can also treat the character as a string, and use     the string functions on it.      The string functions include width(), to return the width of a     string in pixels (or points, for a printer), boundingRect(), to     return a rectangle large enough to contain the rendered string,     and size(), to return the size of that rectangle.      Example:     \snippet code/src_gui_text_qfontmetrics.cpp 0      \sa QFont, QFontInfo, QFontDatabase, {Character Map Example} */
end_comment
begin_comment
comment|/*!     \fn QRect QFontMetrics::boundingRect(int x, int y, int width, int height,         int flags, const QString&text, int tabStops, int *tabArray) const     \overload      Returns the bounding rectangle for the given \a text within the     rectangle specified by the \a x and \a y coordinates, \a width, and     \a height.      If Qt::TextExpandTabs is set in \a flags and \a tabArray is     non-null, it specifies a 0-terminated sequence of pixel-positions     for tabs; otherwise, if \a tabStops is non-zero, it is used as the     tab spacing (in pixels). */
end_comment
begin_comment
comment|/*!     Constructs a font metrics object for \a font.      The font metrics will be compatible with the paintdevice used to     create \a font.      The font metrics object holds the information for the font that is     passed in the constructor at the time it is created, and is not     updated if the font's attributes are changed later.      Use QFontMetrics(const QFont&, QPaintDevice *) to get the font     metrics that are compatible with a certain paint device. */
end_comment
begin_constructor
DECL|function|QFontMetrics
name|QFontMetrics
operator|::
name|QFontMetrics
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|font
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a font metrics object for \a font and \a paintdevice.      The font metrics will be compatible with the paintdevice passed.     If the \a paintdevice is 0, the metrics will be screen-compatible,     ie. the metrics you get if you use the font for drawing text on a     \l{QWidget}{widgets} or \l{QPixmap}{pixmaps},     not on a QPicture or QPrinter.      The font metrics object holds the information for the font that is     passed in the constructor at the time it is created, and is not     updated if the font's attributes are changed later. */
end_comment
begin_constructor
DECL|function|QFontMetrics
name|QFontMetrics
operator|::
name|QFontMetrics
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
name|QPaintDevice
modifier|*
name|paintdevice
parameter_list|)
block|{
name|int
name|dpi
init|=
name|paintdevice
condition|?
name|paintdevice
operator|->
name|logicalDpiY
argument_list|()
else|:
name|qt_defaultDpi
argument_list|()
decl_stmt|;
specifier|const
name|int
name|screen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|font
operator|.
name|d
operator|->
name|dpi
operator|!=
name|dpi
operator|||
name|font
operator|.
name|d
operator|->
name|screen
operator|!=
name|screen
condition|)
block|{
name|d
operator|=
operator|new
name|QFontPrivate
argument_list|(
operator|*
name|font
operator|.
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|dpi
operator|=
name|dpi
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|font
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a fm. */
end_comment
begin_constructor
DECL|function|QFontMetrics
name|QFontMetrics
operator|::
name|QFontMetrics
parameter_list|(
specifier|const
name|QFontMetrics
modifier|&
name|fm
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|fm
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the font metrics object and frees all allocated     resources. */
end_comment
begin_destructor
DECL|function|~QFontMetrics
name|QFontMetrics
operator|::
name|~
name|QFontMetrics
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns the font metrics \a fm. */
end_comment
begin_function
DECL|function|operator =
name|QFontMetrics
modifier|&
name|QFontMetrics
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QFontMetrics
modifier|&
name|fm
parameter_list|)
block|{
name|d
operator|=
name|fm
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QFontMetrics::swap(QFontMetrics&other)     \since 5.0      Swaps this font metrics instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if \a other is equal to this object; otherwise     returns false.      Two font metrics are considered equal if they were constructed     from the same QFont and the paint devices they were constructed     for are considered compatible.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QFontMetrics
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QFontMetrics
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFontMetrics::operator !=(const QFontMetrics&other) const      Returns true if \a other is not equal to this object; otherwise returns false.      Two font metrics are considered equal if they were constructed     from the same QFont and the paint devices they were constructed     for are considered compatible.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns the ascent of the font.      The ascent of a font is the distance from the baseline to the     highest position characters extend to. In practice, some font     designers break this rule, e.g. when they put more than one accent     on top of a character, or to accommodate an unusual character in     an exotic language, so it is possible (though rare) that this     value will be too small.      \sa descent() */
end_comment
begin_function
DECL|function|ascent
name|int
name|QFontMetrics
operator|::
name|ascent
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|ascent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the descent of the font.      The descent is the distance from the base line to the lowest point     characters extend to. In practice, some font designers break this rule,     e.g. to accommodate an unusual character in an exotic language, so     it is possible (though rare) that this value will be too small.      \sa ascent() */
end_comment
begin_function
DECL|function|descent
name|int
name|QFontMetrics
operator|::
name|descent
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|descent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the height of the font.      This is always equal to ascent()+descent()+1 (the 1 is for the     base line).      \sa leading(), lineSpacing() */
end_comment
begin_function
DECL|function|height
name|int
name|QFontMetrics
operator|::
name|height
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|ascent
argument_list|()
argument_list|)
operator|+
name|qRound
argument_list|(
name|engine
operator|->
name|descent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the leading of the font.      This is the natural inter-line spacing.      \sa height(), lineSpacing() */
end_comment
begin_function
DECL|function|leading
name|int
name|QFontMetrics
operator|::
name|leading
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|leading
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from one base line to the next.      This value is always equal to leading()+height().      \sa height(), leading() */
end_comment
begin_function
DECL|function|lineSpacing
name|int
name|QFontMetrics
operator|::
name|lineSpacing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|leading
argument_list|()
argument_list|)
operator|+
name|qRound
argument_list|(
name|engine
operator|->
name|ascent
argument_list|()
argument_list|)
operator|+
name|qRound
argument_list|(
name|engine
operator|->
name|descent
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum left bearing of the font.      This is the smallest leftBearing(char) of all characters in the     font.      Note that this function can be very slow if the font is large.      \sa minRightBearing(), leftBearing() */
end_comment
begin_function
DECL|function|minLeftBearing
name|int
name|QFontMetrics
operator|::
name|minLeftBearing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|minLeftBearing
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum right bearing of the font.      This is the smallest rightBearing(char) of all characters in the     font.      Note that this function can be very slow if the font is large.      \sa minLeftBearing(), rightBearing() */
end_comment
begin_function
DECL|function|minRightBearing
name|int
name|QFontMetrics
operator|::
name|minRightBearing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|minRightBearing
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the widest character in the font. */
end_comment
begin_function
DECL|function|maxWidth
name|int
name|QFontMetrics
operator|::
name|maxWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|maxCharWidth
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the 'x' height of the font. This is often but not always     the same as the height of the character 'x'. */
end_comment
begin_function
DECL|function|xHeight
name|int
name|QFontMetrics
operator|::
name|xHeight
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
condition|)
return|return
name|qRound
argument_list|(
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
operator|->
name|ascent
argument_list|()
argument_list|)
return|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|xHeight
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the average width of glyphs in the font. */
end_comment
begin_function
DECL|function|averageCharWidth
name|int
name|QFontMetrics
operator|::
name|averageCharWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|averageCharWidth
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if character \a ch is a valid character in the font;     otherwise returns false. */
end_comment
begin_function
DECL|function|inFont
name|bool
name|QFontMetrics
operator|::
name|inFont
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|false
return|;
return|return
name|engine
operator|->
name|canRender
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    Returns true if the character \a ucs4 encoded in UCS-4/UTF-32 is a valid    character in the font; otherwise returns false. */
end_comment
begin_function
DECL|function|inFontUcs4
name|bool
name|QFontMetrics
operator|::
name|inFontUcs4
parameter_list|(
name|uint
name|ucs4
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|QChar
operator|::
name|script
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|false
return|;
return|return
name|engine
operator|->
name|canRender
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the left bearing of character \a ch in the font.      The left bearing is the right-ward distance of the left-most pixel     of the character from the logical origin of the character. This     value is negative if the pixels of the character extend to the     left of the logical origin.      See width(QChar) for a graphical description of this metric.      \sa rightBearing(), minLeftBearing(), width() */
end_comment
begin_function
DECL|function|leftBearing
name|int
name|QFontMetrics
operator|::
name|leftBearing
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
comment|// ### can nglyphs != 1 happen at all? Not currently I think
name|qreal
name|lb
decl_stmt|;
name|engine
operator|->
name|getGlyphBearings
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|lb
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the right bearing of character \a ch in the font.      The right bearing is the left-ward distance of the right-most     pixel of the character from the logical origin of a subsequent     character. This value is negative if the pixels of the character     extend to the right of the width() of the character.      See width() for a graphical description of this metric.      \sa leftBearing(), minRightBearing(), width() */
end_comment
begin_function
DECL|function|rightBearing
name|int
name|QFontMetrics
operator|::
name|rightBearing
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
comment|// ### can nglyphs != 1 happen at all? Not currently I think
name|qreal
name|rb
decl_stmt|;
name|engine
operator|->
name|getGlyphBearings
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|rb
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width in pixels of the first \a len characters of \a     text. If \a len is negative (the default), the entire string is     used.      Note that this value is \e not equal to boundingRect().width();     boundingRect() returns a rectangle describing the pixels this     string will cover whereas width() returns the distance to where     the next string should be drawn.      \sa boundingRect() */
end_comment
begin_function
DECL|function|width
name|int
name|QFontMetrics
operator|::
name|width
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|len
parameter_list|)
specifier|const
block|{
return|return
name|width
argument_list|(
name|text
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|width
name|int
name|QFontMetrics
operator|::
name|width
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
specifier|const
block|{
name|int
name|pos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|len
operator|=
operator|(
name|len
operator|<
literal|0
operator|)
condition|?
name|pos
else|:
name|qMin
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|len
operator|=
name|text
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|Qt
operator|::
name|TextBypassShaping
condition|)
block|{
comment|// Skip complex shaping, only use advances
name|int
name|numGlyphs
init|=
name|len
decl_stmt|;
name|QVarLengthGlyphLayoutArray
name|glyphs
argument_list|(
name|numGlyphs
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|engine
operator|->
name|stringToCMap
argument_list|(
name|text
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|numGlyphs
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|glyphs
operator|.
name|resize
argument_list|(
name|numGlyphs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|engine
operator|->
name|stringToCMap
argument_list|(
name|text
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|numGlyphs
argument_list|,
literal|0
argument_list|)
condition|)
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
name|Q_FUNC_INFO
argument_list|,
literal|"stringToCMap shouldn't fail twice"
argument_list|)
expr_stmt|;
block|}
name|QFixed
name|width
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numGlyphs
condition|;
operator|++
name|i
control|)
name|width
operator|+=
name|glyphs
operator|.
name|advances_x
index|[
name|i
index|]
expr_stmt|;
return|return
name|qRound
argument_list|(
name|width
argument_list|)
return|;
block|}
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
return|return
name|qRound
argument_list|(
name|layout
operator|.
name|width
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \image bearings.png Bearings      Returns the logical width of character \a ch in pixels. This is a     distance appropriate for drawing a subsequent character after \a     ch.      Some of the metrics are described in the image to the right. The     central dark rectangles cover the logical width() of each     character. The outer pale rectangles cover the leftBearing() and     rightBearing() of each character. Notice that the bearings of "f"     in this particular font are both negative, while the bearings of     "o" are both positive.      \warning This function will produce incorrect results for Arabic     characters or non-spacing marks in the middle of a string, as the     glyph shaping and positioning of marks that happens when     processing strings cannot be taken into account. When implementing     an interactive text control, use QTextLayout instead.      \sa boundingRect() */
end_comment
begin_function
DECL|function|width
name|int
name|QFontMetrics
operator|::
name|width
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|QChar
operator|::
name|category
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
operator|==
name|QChar
operator|::
name|Mark_NonSpacing
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|8
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|7
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|glyphs
operator|.
name|advances_x
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \obsolete      Returns the width of the character at position \a pos in the     string \a text.      The whole string is needed, as the glyph drawn may change     depending on the context (the letter before and after the current     one) for some languages (e.g. Arabic).      This function also takes non spacing marks and ligatures into     account. */
end_comment
begin_function
DECL|function|charWidth
name|int
name|QFontMetrics
operator|::
name|charWidth
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|pos
parameter_list|)
specifier|const
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
operator|(
name|int
operator|)
name|text
operator|.
name|length
argument_list|()
condition|)
return|return
name|width
return|;
name|QChar
name|ch
init|=
name|text
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
if|if
condition|(
name|script
operator|!=
name|QChar
operator|::
name|Script_Common
condition|)
block|{
comment|// complex script shaping. Have to do some hard work
name|int
name|from
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|pos
operator|-
literal|8
argument_list|)
decl_stmt|;
name|int
name|to
init|=
name|qMin
argument_list|(
name|text
operator|.
name|length
argument_list|()
argument_list|,
name|pos
operator|+
literal|8
argument_list|)
decl_stmt|;
name|QString
name|cstr
init|=
name|QString
operator|::
name|fromRawData
argument_list|(
name|text
operator|.
name|unicode
argument_list|()
operator|+
name|from
argument_list|,
name|to
operator|-
name|from
argument_list|)
decl_stmt|;
name|QStackTextEngine
name|layout
argument_list|(
name|cstr
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|width
operator|=
name|qRound
argument_list|(
name|layout
operator|.
name|width
argument_list|(
name|pos
operator|-
name|from
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|.
name|category
argument_list|()
operator|!=
name|QChar
operator|::
name|Mark_NonSpacing
condition|)
block|{
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|8
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|7
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|width
operator|=
name|qRound
argument_list|(
name|glyphs
operator|.
name|advances_x
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of the characters in the string     specified by \a text. The bounding rectangle always covers at least     the set of pixels the text would cover if drawn at (0, 0).      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the width of the returned     rectangle might be different than what the width() method returns.      If you want to know the advance width of the string (to layout     a set of strings next to each other), use width() instead.      Newline characters are processed as normal characters, \e not as     linebreaks.      The height of the bounding rectangle is at least as large as the     value returned by height().      \sa width(), height(), QPainter::boundingRect(), tightBoundingRect() */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QFontMetrics
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|layout
operator|.
name|boundingBox
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|gm
operator|.
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|y
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|width
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|height
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the rectangle that is covered by ink if character \a ch     were to be drawn at the origin of the coordinate system.      Note that the bounding rectangle may extend to the left of (0, 0)     (e.g., for italicized fonts), and that the text output may cover \e     all pixels in the bounding rectangle. For a space character the rectangle     will usually be empty.      Note that the rectangle usually extends both above and below the     base line.      \warning The width of the returned rectangle is not the advance width     of the character. Use boundingRect(const QString&) or width() instead.      \sa width() */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QFontMetrics
operator|::
name|boundingRect
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|engine
operator|->
name|boundingBox
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|gm
operator|.
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|y
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|width
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|height
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the bounding rectangle of the characters in the string     specified by \a text, which is the set of pixels the text would     cover if drawn at (0, 0). The drawing, and hence the bounding     rectangle, is constrained to the rectangle \a rect.      The \a flags argument is the bitwise OR of the following flags:     \list     \li Qt::AlignLeft aligns to the left border, except for           Arabic and Hebrew where it aligns to the right.     \li Qt::AlignRight aligns to the right border, except for           Arabic and Hebrew where it aligns to the left.     \li Qt::AlignJustify produces justified text.     \li Qt::AlignHCenter aligns horizontally centered.     \li Qt::AlignTop aligns to the top border.     \li Qt::AlignBottom aligns to the bottom border.     \li Qt::AlignVCenter aligns vertically centered     \li Qt::AlignCenter (== \c{Qt::AlignHCenter | Qt::AlignVCenter})     \li Qt::TextSingleLine ignores newline characters in the text.     \li Qt::TextExpandTabs expands tabs (see below)     \li Qt::TextShowMnemonic interprets "&x" as \underline{x}; i.e., underlined.     \li Qt::TextWordWrap breaks the text to fit the rectangle.     \endlist      Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical     alignment defaults to Qt::AlignTop.      If several of the horizontal or several of the vertical alignment     flags are set, the resulting alignment is undefined.      If Qt::TextExpandTabs is set in \a flags, then: if \a tabArray is     non-null, it specifies a 0-terminated sequence of pixel-positions     for tabs; otherwise if \a tabStops is non-zero, it is used as the     tab spacing (in pixels).      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the text output may cover \e     all pixels in the bounding rectangle.      Newline characters are processed as linebreaks.      Despite the different actual character heights, the heights of the     bounding rectangles of "Yes" and "yes" are the same.      The bounding rectangle returned by this function is somewhat larger     than that calculated by the simpler boundingRect() function. This     function uses the \l{minLeftBearing()}{maximum left} and     \l{minRightBearing()}{right} font bearings as is     necessary for multi-line text to align correctly. Also,     fontHeight() and lineSpacing() are used to calculate the height,     rather than individual character heights.      \sa width(), QPainter::boundingRect(), Qt::Alignment */
end_comment
begin_function
DECL|function|boundingRect
name|QRect
name|QFontMetrics
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|tabStops
parameter_list|,
name|int
modifier|*
name|tabArray
parameter_list|)
specifier|const
block|{
name|int
name|tabArrayLen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tabArray
condition|)
while|while
condition|(
name|tabArray
index|[
name|tabArrayLen
index|]
condition|)
name|tabArrayLen
operator|++
expr_stmt|;
name|QRectF
name|rb
decl_stmt|;
name|QRectF
name|rr
argument_list|(
name|rect
argument_list|)
decl_stmt|;
name|qt_format_text
argument_list|(
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
name|rr
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextDontPrint
argument_list|,
name|text
argument_list|,
operator|&
name|rb
argument_list|,
name|tabStops
argument_list|,
name|tabArray
argument_list|,
name|tabArrayLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rb
operator|.
name|toAlignedRect
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size in pixels of \a text.      The \a flags argument is the bitwise OR of the following flags:     \list     \li Qt::TextSingleLine ignores newline characters.     \li Qt::TextExpandTabs expands tabs (see below)     \li Qt::TextShowMnemonic interprets "&x" as \underline{x}; i.e., underlined.     \li Qt::TextWordBreak breaks the text to fit the rectangle.     \endlist      If Qt::TextExpandTabs is set in \a flags, then: if \a tabArray is     non-null, it specifies a 0-terminated sequence of pixel-positions     for tabs; otherwise if \a tabStops is non-zero, it is used as the     tab spacing (in pixels).      Newline characters are processed as linebreaks.      Despite the different actual character heights, the heights of the     bounding rectangles of "Yes" and "yes" are the same.      \sa boundingRect() */
end_comment
begin_function
DECL|function|size
name|QSize
name|QFontMetrics
operator|::
name|size
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|tabStops
parameter_list|,
name|int
modifier|*
name|tabArray
parameter_list|)
specifier|const
block|{
return|return
name|boundingRect
argument_list|(
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextLongestVariant
argument_list|,
name|text
argument_list|,
name|tabStops
argument_list|,
name|tabArray
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.3      Returns a tight bounding rectangle around the characters in the     string specified by \a text. The bounding rectangle always covers     at least the set of pixels the text would cover if drawn at (0,     0).      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the width of the returned     rectangle might be different than what the width() method returns.      If you want to know the advance width of the string (to layout     a set of strings next to each other), use width() instead.      Newline characters are processed as normal characters, \e not as     linebreaks.      \warning Calling this method is very slow on Windows.      \sa width(), height(), boundingRect() */
end_comment
begin_function
DECL|function|tightBoundingRect
name|QRect
name|QFontMetrics
operator|::
name|tightBoundingRect
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|layout
operator|.
name|tightBoundingBox
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QRect
argument_list|(
name|qRound
argument_list|(
name|gm
operator|.
name|x
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|y
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|width
argument_list|)
argument_list|,
name|qRound
argument_list|(
name|gm
operator|.
name|height
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      If the string \a text is wider than \a width, returns an elided     version of the string (i.e., a string with "..." in it).     Otherwise, returns the original string.      The \a mode parameter specifies whether the text is elided on the     left (e.g., "...tech"), in the middle (e.g., "Tr...ch"), or on     the right (e.g., "Trol...").      The \a width is specified in pixels, not characters.      The \a flags argument is optional and currently only supports     Qt::TextShowMnemonic as value.      The elide mark follows the \l{Qt::LayoutDirection}{layoutdirection}.     For example, it will be on the right side of the text for right-to-left     layouts if the \a mode is \c{Qt::ElideLeft}, and on the left side of the     text if the \a mode is \c{Qt::ElideRight}.  */
end_comment
begin_function
DECL|function|elidedText
name|QString
name|QFontMetrics
operator|::
name|elidedText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|Qt
operator|::
name|TextElideMode
name|mode
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|flags
parameter_list|)
specifier|const
block|{
name|QString
name|_text
init|=
name|text
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|Qt
operator|::
name|TextLongestVariant
operator|)
condition|)
block|{
name|int
name|posA
init|=
literal|0
decl_stmt|;
name|int
name|posB
init|=
name|_text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|posB
operator|>=
literal|0
condition|)
block|{
name|QString
name|portion
init|=
name|_text
operator|.
name|mid
argument_list|(
name|posA
argument_list|,
name|posB
operator|-
name|posA
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|flags
argument_list|,
name|portion
argument_list|)
operator|.
name|width
argument_list|()
operator|<=
name|width
condition|)
return|return
name|portion
return|;
name|posA
operator|=
name|posB
operator|+
literal|1
expr_stmt|;
name|posB
operator|=
name|_text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|,
name|posA
argument_list|)
expr_stmt|;
block|}
name|_text
operator|=
name|_text
operator|.
name|mid
argument_list|(
name|posA
argument_list|)
expr_stmt|;
block|}
name|QStackTextEngine
name|engine
argument_list|(
name|_text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|engine
operator|.
name|elidedText
argument_list|(
name|mode
argument_list|,
name|width
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where an underscore     should be drawn.      \sa overlinePos(), strikeOutPos(), lineWidth() */
end_comment
begin_function
DECL|function|underlinePos
name|int
name|QFontMetrics
operator|::
name|underlinePos
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|underlinePosition
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where an overline     should be drawn.      \sa underlinePos(), strikeOutPos(), lineWidth() */
end_comment
begin_function
DECL|function|overlinePos
name|int
name|QFontMetrics
operator|::
name|overlinePos
parameter_list|()
specifier|const
block|{
return|return
name|ascent
argument_list|()
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where the strikeout     line should be drawn.      \sa underlinePos(), overlinePos(), lineWidth() */
end_comment
begin_function
DECL|function|strikeOutPos
name|int
name|QFontMetrics
operator|::
name|strikeOutPos
parameter_list|()
specifier|const
block|{
name|int
name|pos
init|=
name|ascent
argument_list|()
operator|/
literal|3
decl_stmt|;
return|return
name|pos
operator|>
literal|0
condition|?
name|pos
else|:
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the underline and strikeout lines, adjusted     for the point size of the font.      \sa underlinePos(), overlinePos(), strikeOutPos() */
end_comment
begin_function
DECL|function|lineWidth
name|int
name|QFontMetrics
operator|::
name|lineWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|qRound
argument_list|(
name|engine
operator|->
name|lineThickness
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QFontMetricsF member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QFontMetricsF     \reentrant     \inmodule QtGui      \brief The QFontMetricsF class provides font metrics information.      \ingroup painting     \ingroup shared      QFontMetricsF functions calculate the size of characters and     strings for a given font. You can construct a QFontMetricsF object     with an existing QFont to obtain metrics for that font. If the     font is changed later, the font metrics object is \e not updated.      Once created, the object provides functions to access the     individual metrics of the font, its characters, and for strings     rendered in the font.      There are several functions that operate on the font: ascent(),     descent(), height(), leading() and lineSpacing() return the basic     size properties of the font. The underlinePos(), overlinePos(),     strikeOutPos() and lineWidth() functions, return the properties of     the line that underlines, overlines or strikes out the     characters. These functions are all fast.      There are also some functions that operate on the set of glyphs in     the font: minLeftBearing(), minRightBearing() and maxWidth().     These are by necessity slow, and we recommend avoiding them if     possible.      For each character, you can get its width(), leftBearing() and     rightBearing() and find out whether it is in the font using     inFont(). You can also treat the character as a string, and use     the string functions on it.      The string functions include width(), to return the width of a     string in pixels (or points, for a printer), boundingRect(), to     return a rectangle large enough to contain the rendered string,     and size(), to return the size of that rectangle.      Example:     \snippet code/src_gui_text_qfontmetrics.cpp 1      \sa QFont, QFontInfo, QFontDatabase */
end_comment
begin_comment
comment|/*!     \since 4.2      Constructs a font metrics object with floating point precision     from the given \a fontMetrics object. */
end_comment
begin_constructor
DECL|function|QFontMetricsF
name|QFontMetricsF
operator|::
name|QFontMetricsF
parameter_list|(
specifier|const
name|QFontMetrics
modifier|&
name|fontMetrics
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|fontMetrics
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \since 4.2      Assigns \a other to this object. */
end_comment
begin_function
DECL|function|operator =
name|QFontMetricsF
modifier|&
name|QFontMetricsF
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QFontMetrics
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QFontMetricsF::swap(QFontMetricsF&other)     \since 5.0      Swaps this font metrics instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Constructs a font metrics object for \a font.      The font metrics will be compatible with the paintdevice used to     create \a font.      The font metrics object holds the information for the font that is     passed in the constructor at the time it is created, and is not     updated if the font's attributes are changed later.      Use QFontMetricsF(const QFont&, QPaintDevice *) to get the font     metrics that are compatible with a certain paint device. */
end_comment
begin_constructor
DECL|function|QFontMetricsF
name|QFontMetricsF
operator|::
name|QFontMetricsF
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|font
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a font metrics object for \a font and \a paintdevice.      The font metrics will be compatible with the paintdevice passed.     If the \a paintdevice is 0, the metrics will be screen-compatible,     ie. the metrics you get if you use the font for drawing text on a     \l{QWidget}{widgets} or \l{QPixmap}{pixmaps},     not on a QPicture or QPrinter.      The font metrics object holds the information for the font that is     passed in the constructor at the time it is created, and is not     updated if the font's attributes are changed later. */
end_comment
begin_constructor
DECL|function|QFontMetricsF
name|QFontMetricsF
operator|::
name|QFontMetricsF
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
name|QPaintDevice
modifier|*
name|paintdevice
parameter_list|)
block|{
name|int
name|dpi
init|=
name|paintdevice
condition|?
name|paintdevice
operator|->
name|logicalDpiY
argument_list|()
else|:
name|qt_defaultDpi
argument_list|()
decl_stmt|;
specifier|const
name|int
name|screen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|font
operator|.
name|d
operator|->
name|dpi
operator|!=
name|dpi
operator|||
name|font
operator|.
name|d
operator|->
name|screen
operator|!=
name|screen
condition|)
block|{
name|d
operator|=
operator|new
name|QFontPrivate
argument_list|(
operator|*
name|font
operator|.
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|dpi
operator|=
name|dpi
expr_stmt|;
name|d
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|font
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a fm. */
end_comment
begin_constructor
DECL|function|QFontMetricsF
name|QFontMetricsF
operator|::
name|QFontMetricsF
parameter_list|(
specifier|const
name|QFontMetricsF
modifier|&
name|fm
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|fm
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the font metrics object and frees all allocated     resources. */
end_comment
begin_destructor
DECL|function|~QFontMetricsF
name|QFontMetricsF
operator|::
name|~
name|QFontMetricsF
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns the font metrics \a fm to this font metrics object. */
end_comment
begin_function
DECL|function|operator =
name|QFontMetricsF
modifier|&
name|QFontMetricsF
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QFontMetricsF
modifier|&
name|fm
parameter_list|)
block|{
name|d
operator|=
name|fm
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the font metrics are equal to the \a other font   metrics; otherwise returns false.    Two font metrics are considered equal if they were constructed from the   same QFont and the paint devices they were constructed for are   considered to be compatible. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QFontMetricsF
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QFontMetricsF
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFontMetricsF::operator !=(const QFontMetricsF&other) const     \overload      Returns true if the font metrics are not equal to the \a other font     metrics; otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns the ascent of the font.      The ascent of a font is the distance from the baseline to the     highest position characters extend to. In practice, some font     designers break this rule, e.g. when they put more than one accent     on top of a character, or to accommodate an unusual character in     an exotic language, so it is possible (though rare) that this     value will be too small.      \sa descent() */
end_comment
begin_function
DECL|function|ascent
name|qreal
name|QFontMetricsF
operator|::
name|ascent
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the descent of the font.      The descent is the distance from the base line to the lowest point     characters extend to. (Note that this is different from X, which     adds 1 pixel.) In practice, some font designers break this rule,     e.g. to accommodate an unusual character in an exotic language, so     it is possible (though rare) that this value will be too small.      \sa ascent() */
end_comment
begin_function
DECL|function|descent
name|qreal
name|QFontMetricsF
operator|::
name|descent
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|descent
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the height of the font.      This is always equal to ascent()+descent()+1 (the 1 is for the     base line).      \sa leading(), lineSpacing() */
end_comment
begin_function
DECL|function|height
name|qreal
name|QFontMetricsF
operator|::
name|height
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|engine
operator|->
name|ascent
argument_list|()
operator|+
name|engine
operator|->
name|descent
argument_list|()
operator|)
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the leading of the font.      This is the natural inter-line spacing.      \sa height(), lineSpacing() */
end_comment
begin_function
DECL|function|leading
name|qreal
name|QFontMetricsF
operator|::
name|leading
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|leading
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from one base line to the next.      This value is always equal to leading()+height().      \sa height(), leading() */
end_comment
begin_function
DECL|function|lineSpacing
name|qreal
name|QFontMetricsF
operator|::
name|lineSpacing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|engine
operator|->
name|leading
argument_list|()
operator|+
name|engine
operator|->
name|ascent
argument_list|()
operator|+
name|engine
operator|->
name|descent
argument_list|()
operator|)
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum left bearing of the font.      This is the smallest leftBearing(char) of all characters in the     font.      Note that this function can be very slow if the font is large.      \sa minRightBearing(), leftBearing() */
end_comment
begin_function
DECL|function|minLeftBearing
name|qreal
name|QFontMetricsF
operator|::
name|minLeftBearing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|minLeftBearing
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minimum right bearing of the font.      This is the smallest rightBearing(char) of all characters in the     font.      Note that this function can be very slow if the font is large.      \sa minLeftBearing(), rightBearing() */
end_comment
begin_function
DECL|function|minRightBearing
name|qreal
name|QFontMetricsF
operator|::
name|minRightBearing
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|minRightBearing
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the widest character in the font. */
end_comment
begin_function
DECL|function|maxWidth
name|qreal
name|QFontMetricsF
operator|::
name|maxWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|maxCharWidth
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the 'x' height of the font. This is often but not always     the same as the height of the character 'x'. */
end_comment
begin_function
DECL|function|xHeight
name|qreal
name|QFontMetricsF
operator|::
name|xHeight
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
condition|)
return|return
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
operator|->
name|ascent
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
return|return
name|engine
operator|->
name|xHeight
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the average width of glyphs in the font. */
end_comment
begin_function
DECL|function|averageCharWidth
name|qreal
name|QFontMetricsF
operator|::
name|averageCharWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|averageCharWidth
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if character \a ch is a valid character in the font;     otherwise returns false. */
end_comment
begin_function
DECL|function|inFont
name|bool
name|QFontMetricsF
operator|::
name|inFont
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|false
return|;
return|return
name|engine
operator|->
name|canRender
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QFontMetricsF::inFontUcs4(uint ch) const      Returns true if the character given by \a ch, encoded in UCS-4/UTF-32,     is a valid character in the font; otherwise returns false. */
end_comment
begin_function
DECL|function|inFontUcs4
name|bool
name|QFontMetricsF
operator|::
name|inFontUcs4
parameter_list|(
name|uint
name|ucs4
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|QChar
operator|::
name|script
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|false
return|;
return|return
name|engine
operator|->
name|canRender
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the left bearing of character \a ch in the font.      The left bearing is the right-ward distance of the left-most pixel     of the character from the logical origin of the character. This     value is negative if the pixels of the character extend to the     left of the logical origin.      See width(QChar) for a graphical description of this metric.      \sa rightBearing(), minLeftBearing(), width() */
end_comment
begin_function
DECL|function|leftBearing
name|qreal
name|QFontMetricsF
operator|::
name|leftBearing
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
comment|// ### can nglyphs != 1 happen at all? Not currently I think
name|qreal
name|lb
decl_stmt|;
name|engine
operator|->
name|getGlyphBearings
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
return|return
name|lb
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the right bearing of character \a ch in the font.      The right bearing is the left-ward distance of the right-most     pixel of the character from the logical origin of a subsequent     character. This value is negative if the pixels of the character     extend to the right of the width() of the character.      See width() for a graphical description of this metric.      \sa leftBearing(), minRightBearing(), width() */
end_comment
begin_function
DECL|function|rightBearing
name|qreal
name|QFontMetricsF
operator|::
name|rightBearing
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|type
argument_list|()
operator|==
name|QFontEngine
operator|::
name|Box
condition|)
return|return
literal|0
return|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
comment|// ### can nglyphs != 1 happen at all? Not currently I think
name|qreal
name|rb
decl_stmt|;
name|engine
operator|->
name|getGlyphBearings
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|rb
argument_list|)
expr_stmt|;
return|return
name|rb
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width in pixels of the characters in the given \a text.      Note that this value is \e not equal to the width returned by     boundingRect().width() because boundingRect() returns a rectangle     describing the pixels this string will cover whereas width()     returns the distance to where the next string should be drawn.      \sa boundingRect() */
end_comment
begin_function
DECL|function|width
name|qreal
name|QFontMetricsF
operator|::
name|width
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
name|int
name|pos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|pos
operator|!=
operator|-
literal|1
operator|)
condition|?
name|pos
else|:
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
return|return
name|layout
operator|.
name|width
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \image bearings.png Bearings      Returns the logical width of character \a ch in pixels. This is a     distance appropriate for drawing a subsequent character after \a     ch.      Some of the metrics are described in the image to the right. The     central dark rectangles cover the logical width() of each     character. The outer pale rectangles cover the leftBearing() and     rightBearing() of each character. Notice that the bearings of "f"     in this particular font are both negative, while the bearings of     "o" are both positive.      \warning This function will produce incorrect results for Arabic     characters or non-spacing marks in the middle of a string, as the     glyph shaping and positioning of marks that happens when     processing strings cannot be taken into account. When implementing     an interactive text control, use QTextLayout instead.      \sa boundingRect() */
end_comment
begin_function
DECL|function|width
name|qreal
name|QFontMetricsF
operator|::
name|width
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ch
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Mark_NonSpacing
condition|)
return|return
literal|0.
return|;
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|8
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|7
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|glyphs
operator|.
name|advances_x
index|[
literal|0
index|]
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of the characters in the string     specified by \a text. The bounding rectangle always covers at least     the set of pixels the text would cover if drawn at (0, 0).      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the width of the returned     rectangle might be different than what the width() method returns.      If you want to know the advance width of the string (to layout     a set of strings next to each other), use width() instead.      Newline characters are processed as normal characters, \e not as     linebreaks.      The height of the bounding rectangle is at least as large as the     value returned height().      \sa width(), height(), QPainter::boundingRect() */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QFontMetricsF
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
name|int
name|len
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|QRectF
argument_list|()
return|;
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|layout
operator|.
name|boundingBox
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|gm
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|height
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the bounding rectangle of the character \a ch relative to     the left-most point on the base line.      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the text output may cover \e     all pixels in the bounding rectangle.      Note that the rectangle usually extends both above and below the     base line.      \sa width() */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QFontMetricsF
operator|::
name|boundingRect
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|script
init|=
name|ch
operator|.
name|script
argument_list|()
decl_stmt|;
name|QFontEngine
modifier|*
name|engine
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|capital
operator|==
name|QFont
operator|::
name|SmallCaps
operator|&&
name|ch
operator|.
name|isLower
argument_list|()
condition|)
name|engine
operator|=
name|d
operator|->
name|smallCapsFontPrivate
argument_list|()
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
name|engine
operator|=
name|d
operator|->
name|engineForScript
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|alterCharForCapitalization
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|QGlyphLayoutArray
argument_list|<
literal|10
argument_list|>
name|glyphs
decl_stmt|;
name|int
name|nglyphs
init|=
literal|9
decl_stmt|;
name|engine
operator|->
name|stringToCMap
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|glyphs
argument_list|,
operator|&
name|nglyphs
argument_list|,
name|QFontEngine
operator|::
name|GlyphIndicesOnly
argument_list|)
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|engine
operator|->
name|boundingBox
argument_list|(
name|glyphs
operator|.
name|glyphs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|gm
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|height
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the bounding rectangle of the characters in the given \a text.     This is the set of pixels the text would cover if drawn when constrained     to the bounding rectangle specified by \a rect.      The \a flags argument is the bitwise OR of the following flags:     \list     \li Qt::AlignLeft aligns to the left border, except for           Arabic and Hebrew where it aligns to the right.     \li Qt::AlignRight aligns to the right border, except for           Arabic and Hebrew where it aligns to the left.     \li Qt::AlignJustify produces justified text.     \li Qt::AlignHCenter aligns horizontally centered.     \li Qt::AlignTop aligns to the top border.     \li Qt::AlignBottom aligns to the bottom border.     \li Qt::AlignVCenter aligns vertically centered     \li Qt::AlignCenter (== \c{Qt::AlignHCenter | Qt::AlignVCenter})     \li Qt::TextSingleLine ignores newline characters in the text.     \li Qt::TextExpandTabs expands tabs (see below)     \li Qt::TextShowMnemonic interprets "&x" as \underline{x}; i.e., underlined.     \li Qt::TextWordWrap breaks the text to fit the rectangle.     \endlist      Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical     alignment defaults to Qt::AlignTop.      If several of the horizontal or several of the vertical alignment     flags are set, the resulting alignment is undefined.      These flags are defined in \l{Qt::AlignmentFlag}.      If Qt::TextExpandTabs is set in \a flags, the following behavior is     used to interpret tab characters in the text:     \list     \li If \a tabArray is non-null, it specifies a 0-terminated sequence of        pixel-positions for tabs in the text.     \li If \a tabStops is non-zero, it is used as the tab spacing (in pixels).     \endlist      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts.      Newline characters are processed as line breaks.      Despite the different actual character heights, the heights of the     bounding rectangles of "Yes" and "yes" are the same.      The bounding rectangle returned by this function is somewhat larger     than that calculated by the simpler boundingRect() function. This     function uses the \l{minLeftBearing()}{maximum left} and     \l{minRightBearing()}{right} font bearings as is     necessary for multi-line text to align correctly. Also,     fontHeight() and lineSpacing() are used to calculate the height,     rather than individual character heights.      \sa width(), QPainter::boundingRect(), Qt::Alignment */
end_comment
begin_function
DECL|function|boundingRect
name|QRectF
name|QFontMetricsF
operator|::
name|boundingRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|tabStops
parameter_list|,
name|int
modifier|*
name|tabArray
parameter_list|)
specifier|const
block|{
name|int
name|tabArrayLen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tabArray
condition|)
while|while
condition|(
name|tabArray
index|[
name|tabArrayLen
index|]
condition|)
name|tabArrayLen
operator|++
expr_stmt|;
name|QRectF
name|rb
decl_stmt|;
name|qt_format_text
argument_list|(
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
name|rect
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextDontPrint
argument_list|,
name|text
argument_list|,
operator|&
name|rb
argument_list|,
name|tabStops
argument_list|,
name|tabArray
argument_list|,
name|tabArrayLen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rb
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size in pixels of the characters in the given \a text.      The \a flags argument is the bitwise OR of the following flags:     \list     \li Qt::TextSingleLine ignores newline characters.     \li Qt::TextExpandTabs expands tabs (see below)     \li Qt::TextShowMnemonic interprets "&x" as \underline{x}; i.e., underlined.     \li Qt::TextWordBreak breaks the text to fit the rectangle.     \endlist      These flags are defined in \l{Qt::TextFlags}.      If Qt::TextExpandTabs is set in \a flags, the following behavior is     used to interpret tab characters in the text:     \list     \li If \a tabArray is non-null, it specifies a 0-terminated sequence of        pixel-positions for tabs in the text.     \li If \a tabStops is non-zero, it is used as the tab spacing (in pixels).     \endlist      Newline characters are processed as line breaks.      Note: Despite the different actual character heights, the heights of the     bounding rectangles of "Yes" and "yes" are the same.      \sa boundingRect() */
end_comment
begin_function
DECL|function|size
name|QSizeF
name|QFontMetricsF
operator|::
name|size
parameter_list|(
name|int
name|flags
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|tabStops
parameter_list|,
name|int
modifier|*
name|tabArray
parameter_list|)
specifier|const
block|{
return|return
name|boundingRect
argument_list|(
name|QRectF
argument_list|()
argument_list|,
name|flags
operator||
name|Qt
operator|::
name|TextLongestVariant
argument_list|,
name|text
argument_list|,
name|tabStops
argument_list|,
name|tabArray
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.3      Returns a tight bounding rectangle around the characters in the     string specified by \a text. The bounding rectangle always covers     at least the set of pixels the text would cover if drawn at (0,     0).      Note that the bounding rectangle may extend to the left of (0, 0),     e.g. for italicized fonts, and that the width of the returned     rectangle might be different than what the width() method returns.      If you want to know the advance width of the string (to layout     a set of strings next to each other), use width() instead.      Newline characters are processed as normal characters, \e not as     linebreaks.      \warning Calling this method is very slow on Windows.      \sa width(), height(), boundingRect() */
end_comment
begin_function
DECL|function|tightBoundingRect
name|QRectF
name|QFontMetricsF
operator|::
name|tightBoundingRect
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QStackTextEngine
name|layout
argument_list|(
name|text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|layout
operator|.
name|ignoreBidi
operator|=
literal|true
expr_stmt|;
name|layout
operator|.
name|itemize
argument_list|()
expr_stmt|;
name|glyph_metrics_t
name|gm
init|=
name|layout
operator|.
name|tightBoundingBox
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|QRectF
argument_list|(
name|gm
operator|.
name|x
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|y
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|width
operator|.
name|toReal
argument_list|()
argument_list|,
name|gm
operator|.
name|height
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      If the string \a text is wider than \a width, returns an elided     version of the string (i.e., a string with "..." in it).     Otherwise, returns the original string.      The \a mode parameter specifies whether the text is elided on the     left (for example, "...tech"), in the middle (for example, "Tr...ch"), or     on the right (for example, "Trol...").      The \a width is specified in pixels, not characters.      The \a flags argument is optional and currently only supports     Qt::TextShowMnemonic as value.      The elide mark follows the \l{Qt::LayoutDirection}{layoutdirection}.     For example, it will be on the right side of the text for right-to-left     layouts if the \a mode is \c{Qt::ElideLeft}, and on the left side of the     text if the \a mode is \c{Qt::ElideRight}. */
end_comment
begin_function
DECL|function|elidedText
name|QString
name|QFontMetricsF
operator|::
name|elidedText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|Qt
operator|::
name|TextElideMode
name|mode
parameter_list|,
name|qreal
name|width
parameter_list|,
name|int
name|flags
parameter_list|)
specifier|const
block|{
name|QString
name|_text
init|=
name|text
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|Qt
operator|::
name|TextLongestVariant
operator|)
condition|)
block|{
name|int
name|posA
init|=
literal|0
decl_stmt|;
name|int
name|posB
init|=
name|_text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|posB
operator|>=
literal|0
condition|)
block|{
name|QString
name|portion
init|=
name|_text
operator|.
name|mid
argument_list|(
name|posA
argument_list|,
name|posB
operator|-
name|posA
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
argument_list|(
name|flags
argument_list|,
name|portion
argument_list|)
operator|.
name|width
argument_list|()
operator|<=
name|width
condition|)
return|return
name|portion
return|;
name|posA
operator|=
name|posB
operator|+
literal|1
expr_stmt|;
name|posB
operator|=
name|_text
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\x9c'
argument_list|)
argument_list|,
name|posA
argument_list|)
expr_stmt|;
block|}
name|_text
operator|=
name|_text
operator|.
name|mid
argument_list|(
name|posA
argument_list|)
expr_stmt|;
block|}
name|QStackTextEngine
name|engine
argument_list|(
name|_text
argument_list|,
name|QFont
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|engine
operator|.
name|elidedText
argument_list|(
name|mode
argument_list|,
name|QFixed
operator|::
name|fromReal
argument_list|(
name|width
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where an underscore     should be drawn.      \sa overlinePos(), strikeOutPos(), lineWidth() */
end_comment
begin_function
DECL|function|underlinePos
name|qreal
name|QFontMetricsF
operator|::
name|underlinePos
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|underlinePosition
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where an overline     should be drawn.      \sa underlinePos(), strikeOutPos(), lineWidth() */
end_comment
begin_function
DECL|function|overlinePos
name|qreal
name|QFontMetricsF
operator|::
name|overlinePos
parameter_list|()
specifier|const
block|{
return|return
name|ascent
argument_list|()
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the distance from the base line to where the strikeout     line should be drawn.      \sa underlinePos(), overlinePos(), lineWidth() */
end_comment
begin_function
DECL|function|strikeOutPos
name|qreal
name|QFontMetricsF
operator|::
name|strikeOutPos
parameter_list|()
specifier|const
block|{
return|return
name|ascent
argument_list|()
operator|/
literal|3.
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the width of the underline and strikeout lines, adjusted     for the point size of the font.      \sa underlinePos(), overlinePos(), strikeOutPos() */
end_comment
begin_function
DECL|function|lineWidth
name|qreal
name|QFontMetricsF
operator|::
name|lineWidth
parameter_list|()
specifier|const
block|{
name|QFontEngine
modifier|*
name|engine
init|=
name|d
operator|->
name|engineForScript
argument_list|(
name|QChar
operator|::
name|Script_Common
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|engine
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|engine
operator|->
name|lineThickness
argument_list|()
operator|.
name|toReal
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
